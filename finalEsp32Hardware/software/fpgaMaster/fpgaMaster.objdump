
fpgaMaster.elf:     file format elf32-littlenios2
fpgaMaster.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x04000364

Program Header:
    LOAD off    0x00001000 vaddr 0x04000000 paddr 0x04000000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x04000020 paddr 0x04000020 align 2**12
         filesz 0x0001b20c memsz 0x0001b20c flags r-x
    LOAD off    0x0001c22c vaddr 0x0401b22c paddr 0x0401ce34 align 2**12
         filesz 0x00001c08 memsz 0x00001c08 flags rw-
    LOAD off    0x0001ea3c vaddr 0x0401ea3c paddr 0x0401ea3c align 2**12
         filesz 0x00000000 memsz 0x00800270 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  04000000  04000000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000344  04000020  04000020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0001a74c  04000364  04000364  00001364  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       0000077c  0401aab0  0401aab0  0001bab0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001c08  0401b22c  0401ce34  0001c22c  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          008002f6  0401ea3c  0401ea3c  0001ea3c  2**2
                  ALLOC, SMALL_DATA
  6 .dram         00000000  0481ecac  0481ecac  0001de34  2**0
                  CONTENTS
  7 .comment      0000002c  00000000  00000000  0001de34  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00001258  00000000  00000000  0001de60  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   00052e57  00000000  00000000  0001f0b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 0000ff14  00000000  00000000  00071f0f  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00017fee  00000000  00000000  00081e23  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00003ff4  00000000  00000000  00099e14  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00006658  00000000  00000000  0009de08  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    0000af74  00000000  00000000  000a4460  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000010  00000000  00000000  000af3d4  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00001650  00000000  00000000  000af3e8  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000003  00000000  00000000  000b59b6  2**0
                  CONTENTS, READONLY
 18 .cpu          00000005  00000000  00000000  000b59b9  2**0
                  CONTENTS, READONLY
 19 .qsys         00000001  00000000  00000000  000b59be  2**0
                  CONTENTS, READONLY
 20 .simulation_enabled 00000001  00000000  00000000  000b59bf  2**0
                  CONTENTS, READONLY
 21 .stderr_dev   0000000b  00000000  00000000  000b59c0  2**0
                  CONTENTS, READONLY
 22 .stdin_dev    0000000b  00000000  00000000  000b59cb  2**0
                  CONTENTS, READONLY
 23 .stdout_dev   0000000b  00000000  00000000  000b59d6  2**0
                  CONTENTS, READONLY
 24 .sopc_system_name 0000000d  00000000  00000000  000b59e1  2**0
                  CONTENTS, READONLY
 25 .quartus_project_dir 0000003d  00000000  00000000  000b59ee  2**0
                  CONTENTS, READONLY
 26 .jdi          00004d09  00000000  00000000  000b5a2b  2**0
                  CONTENTS, READONLY
 27 .sopcinfo     0006f179  00000000  00000000  000ba734  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
04000000 l    d  .entry	00000000 .entry
04000020 l    d  .exceptions	00000000 .exceptions
04000364 l    d  .text	00000000 .text
0401aab0 l    d  .rodata	00000000 .rodata
0401b22c l    d  .rwdata	00000000 .rwdata
0401ea3c l    d  .bss	00000000 .bss
0481ecac l    d  .dram	00000000 .dram
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../fpgaMaster_bsp//obj/HAL/src/crt0.o
0400039c l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 obj/default/FreeRTOS/portable/GCC/NiosII/port_asm.o
04000020 l       .exceptions	00000000 save_context
0400009c l       .exceptions	00000000 save_sp_to_pxCurrentTCB
04000104 l       .exceptions	00000000 irq_test_user
0400016c l       .exceptions	00000000 restore_context
04000124 l       .exceptions	00000000 soft_exceptions
04000134 l       .exceptions	00000000 call_scheduler
04000148 l       .exceptions	00000000 exceptions_unknown_user
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 croutine.c
00000000 l    df *ABS*	00000000 event_groups.c
04000a30 l     F .text	00000070 prvTestWaitCondition
00000000 l    df *ABS*	00000000 list.c
00000000 l    df *ABS*	00000000 port.c
04000d30 l     F .text	0000002c prvReadGp
04000e94 l     F .text	00000090 prvSetupTimerInterrupt
00000000 l    df *ABS*	00000000 heap_1.c
0401eabc l     O .bss	00800000 ucHeap
0401ea3c l     O .bss	00000004 xNextFreeByte
0401ea40 l     O .bss	00000004 pucAlignedHeap.2603
00000000 l    df *ABS*	00000000 queue.c
04001574 l     F .text	00000084 prvInitialiseNewQueue
040015f8 l     F .text	00000060 prvInitialiseMutex
04002430 l     F .text	0000018c prvCopyDataToQueue
040027e4 l     F .text	00000058 prvIsQueueFull
04002658 l     F .text	000000f4 prvUnlockQueue
040025bc l     F .text	0000009c prvCopyDataFromQueue
0400274c l     F .text	00000050 prvIsQueueEmpty
040023e0 l     F .text	00000050 prvGetDisinheritPriorityAfterTimeout
00000000 l    df *ABS*	00000000 stream_buffer.c
0400372c l     F .text	00000080 prvInitialiseNewStreamBuffer
040036b8 l     F .text	00000074 prvBytesInBuffer
04002e8c l     F .text	000000d0 prvWriteMessageToBuffer
040034f8 l     F .text	000000e0 prvWriteBytesToBuffer
04003234 l     F .text	000000e0 prvReadMessageFromBuffer
040035d8 l     F .text	000000e0 prvReadBytesFromBuffer
00000000 l    df *ABS*	00000000 tasks.c
0481eabc l     O .bss	00000064 pxReadyTasksLists
0481eb20 l     O .bss	00000014 xDelayedTaskList1
0481eb34 l     O .bss	00000014 xDelayedTaskList2
0401ea48 l     O .bss	00000004 pxDelayedTaskList
0401ea4c l     O .bss	00000004 pxOverflowDelayedTaskList
0481eb48 l     O .bss	00000014 xPendingReadyList
0481eb5c l     O .bss	00000014 xTasksWaitingTermination
0401ea50 l     O .bss	00000004 uxDeletedTasksWaitingCleanUp
0481eb70 l     O .bss	00000014 xSuspendedTaskList
0401ea54 l     O .bss	00000004 uxCurrentNumberOfTasks
0401ea58 l     O .bss	00000004 xTickCount
0401ea5c l     O .bss	00000004 uxTopReadyPriority
0401ea60 l     O .bss	00000004 xSchedulerRunning
0401ea64 l     O .bss	00000004 xPendedTicks
0401ea68 l     O .bss	00000004 xYieldPending
0401ea6c l     O .bss	00000004 xNumOfOverflows
0401ea70 l     O .bss	00000004 uxTaskNumber
0401ea74 l     O .bss	00000004 xNextTaskUnblockTime
0401ea78 l     O .bss	00000004 xIdleTaskHandle
0401ea7c l     O .bss	00000004 uxSchedulerSuspended
040038a0 l     F .text	000001ac prvInitialiseNewTask
04003a4c l     F .text	000001b8 prvAddNewTaskToReadyList
040056f8 l     F .text	000000c0 prvInitialiseTaskLists
04005940 l     F .text	00000048 prvResetNextTaskUnblockTime
040058fc l     F .text	00000044 prvDeleteTCB
04006e34 l     F .text	00000144 prvAddCurrentTaskToDelayedList
04004274 l     F .text	0000006c prvTaskIsTaskSuspended
040056dc l     F .text	0000001c prvIdleTask
040057b8 l     F .text	00000080 prvCheckTasksWaitingTermination
04005838 l     F .text	00000064 prvTaskCheckFreeStackSpace
00000000 l    df *ABS*	00000000 timers.c
00000000 l    df *ABS*	00000000 float2_functionality.c
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 vfprintf.c
0400795c l     F .text	000000f0 __sbprintf
04009bfc l     F .text	00000208 cvt
04009e04 l     F .text	00000148 exponent
0401ab60 l     O .rodata	00000010 blanks.5176
0401ab70 l     O .rodata	00000010 zeroes.5177
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 dtoa.c
0400a0ec l     F .text	000003b4 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
0400c4a4 l     F .text	000000f0 std
0400c594 l     F .text	0000003c stdin_init
0400c5d0 l     F .text	0000003c stdout_init
0400c60c l     F .text	0000003c stderr_init
0401ea80 l     O .bss	00000004 __sfp_recursive_mutex
0401ea84 l     O .bss	00000004 __sinit_recursive_mutex
0400ca44 l     F .text	00000024 __fp_lock
0400ca68 l     F .text	00000024 __fp_unlock
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 impure.c
0401b22c l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 localeconv.c
0400d9c4 l     F .text	00000024 __get_global_locale
0400d9e8 l     F .text	00000028 __get_current_locale
0400da10 l     F .text	00000028 __get_C_locale
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
0400dd7c l     F .text	000003c4 malloc_extend_top
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mprec.c
0401ad8c l     O .rodata	0000000c p05.3991
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 vfprintf.c
04011bdc l     F .text	000000f0 __sbprintf
0401ade4 l     O .rodata	00000010 blanks.5153
0401adf4 l     O .rodata	00000010 zeroes.5154
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 assert.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fiprintf.c
00000000 l    df *ABS*	00000000 fputwc.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 locale.c
04013874 l     F .text	00000024 __get_global_locale
04013898 l     F .text	00000028 __get_current_locale
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 mbtowc_r.c
04013a28 l     F .text	00000024 __get_global_locale
04013a4c l     F .text	00000028 __get_current_locale
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 vfiprintfr_1.c
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 wcrtomb.c
04013f0c l     F .text	00000024 __get_global_locale
04013f30 l     F .text	00000028 __get_current_locale
00000000 l    df *ABS*	00000000 wctomb_r.c
040140c4 l     F .text	00000024 __get_global_locale
040140e8 l     F .text	00000028 __get_current_locale
00000000 l    df *ABS*	00000000 abort.c
00000000 l    df *ABS*	00000000 ctype_.c
00000000 l    df *ABS*	00000000 signal.c
00000000 l    df *ABS*	00000000 signalr.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 divdf3.c
00000000 l    df *ABS*	00000000 eqdf2.c
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 ledf2.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 subdf3.c
00000000 l    df *ABS*	00000000 unorddf2.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 floatunsidf.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 alt_close.c
04017c9c l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_dev.c
04017db4 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_exit.c
00000000 l    df *ABS*	00000000 alt_fstat.c
04017e18 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_getpid.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_isatty.c
040181c8 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_kill.c
040182b4 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_load.c
0401841c l     F .text	00000068 alt_load_section
00000000 l    df *ABS*	00000000 alt_lseek.c
04018508 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
00000000 l    df *ABS*	00000000 alt_read.c
040186e8 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
0401ce28 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_write.c
04018954 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_sys_init.c
04018a94 l     F .text	00000034 alt_dev_reg
0401bd6c l     O .rwdata	00001060 jtag_uart_0
0401cdcc l     O .rwdata	0000002c accelerometer_spi
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
04018d98 l     F .text	0000020c altera_avalon_jtag_uart_irq
04018fa4 l     F .text	000000a0 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
040195e8 l     F .text	0000007c alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_up_avalon_accelerometer_spi.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
04019c08 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
04019efc l     F .text	000000d4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_open.c
0401a04c l     F .text	0000003c alt_get_errno
0401a088 l     F .text	000000dc alt_file_locked
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
0401eab8 l     O .bss	00000004 __atexit_recursive_mutex
0401eaac g     O .bss	00000004 alt_instruction_exception_handler
04010948 g     F .text	000000b4 _mprec_log10
04010ac0 g     F .text	00000124 __any_on
04013814 g     F .text	00000060 _isatty_r
0401ad64 g     O .rodata	00000028 __mprec_tinytens
04018624 g     F .text	0000007c alt_main
04007718 g     F .text	00000118 _puts_r
0481ebac g     O .bss	00000100 alt_irq
040139b8 g     F .text	00000070 _lseek_r
0400015c g       .exceptions	00000000 restore_sp_from_pxCurrentTCB
04004f68 g     F .text	000000bc vTaskPlaceOnUnorderedEventList
04001164 g     F .text	0000002c xPortGetFreeHeapSize
04000788 g     F .text	0000003c xEventGroupGetBitsFromISR
0401ce34 g       *ABS*	00000000 __flash_rwdata_start
040166ec g     F .text	00000080 .hidden __eqdf2
0481ecac g       *ABS*	00000000 __alt_heap_start
04003e44 g     F .text	00000058 uxTaskPriorityGet
04014610 g     F .text	00000068 _kill_r
040076b0 g     F .text	00000068 printf
04013f58 g     F .text	000000b4 _wcrtomb_r
04014294 g     F .text	000000b4 _signal_r
040119b8 g     F .text	000000a0 __sseek
0400c910 g     F .text	000000b4 __sinit
04013d64 g     F .text	00000168 __swbuf_r
040138c0 g     F .text	00000080 _setlocale_r
0400c648 g     F .text	000000bc __sfmoreglue
04002f5c g     F .text	00000160 xStreamBufferReceive
040186c4 g     F .text	00000024 __malloc_unlock
04003cf8 g     F .text	000000f0 xTaskDelayUntil
040003f4 g     F .text	00000184 xEventGroupSync
0400ee64 g     F .text	00000208 memmove
04006d88 g     F .text	000000ac ulTaskGenericNotifyValueClear
04005f74 g     F .text	00000054 vTaskEnterCritical
0400c8dc g     F .text	00000034 _cleanup
04001a04 g     F .text	00000108 xQueueGenericSendFromISR
04004a5c g     F .text	00000040 pcTaskGetName
0400f06c g     F .text	00000124 _Balloc
04002ae4 g     F .text	000000a4 xStreamBufferSpacesAvailable
0401676c g     F .text	000000f0 .hidden __gtdf2
0401a470 g     F .text	00000024 altera_nios2_gen2_irq_init
040029c4 g     F .text	000000b4 xStreamBufferReset
04000000 g     F .entry	0000000c __reset
040016b4 g     F .text	00000090 xQueueGiveMutexRecursive
0400da38 g     F .text	00000050 __localeconv_l
04006f78 g     F .text	000000e8 convertData
0401ea44 g     O .bss	00000004 pxCurrentTCB
04019838 g     F .text	000000d4 alt_up_accelerometer_spi_read_x_axis
04000020 g       *ABS*	00000000 __flash_exceptions_start
040137ac g     F .text	00000068 _fstat_r
0401ea94 g     O .bss	00000004 errno
040118d4 g     F .text	00000030 __seofread
04002d98 g     F .text	000000f4 xStreamBufferSendFromISR
0401eaa4 g     O .bss	00000004 alt_argv
04024df8 g       *ABS*	00000000 _gp
04003ee8 g     F .text	00000268 vTaskPrioritySet
04017f10 g     F .text	00000020 getpid
04005590 g     F .text	0000003c vTaskInternalSetTimeOutState
04000578 g     F .text	000001a8 xEventGroupWaitBits
04000f68 g     F .text	000000cc _alt_ic_isr_register
0401bbec g     O .rwdata	00000180 alt_fd_list
04000e3c g     F .text	00000038 xPortStartScheduler
040046a0 g     F .text	00000048 vTaskEndScheduler
04019db4 g     F .text	00000090 alt_find_dev
04007300 g     F .text	00000188 memcpy
04004f18 g     F .text	00000050 vTaskPlaceOnEventList
040052f4 g     F .text	00000250 vTaskRemoveFromUnorderedEventList
0400c898 g     F .text	00000044 _cleanup_r
04017afc g     F .text	000000bc .hidden __floatsidf
04019fd0 g     F .text	0000007c alt_io_redirect
0401685c g     F .text	000000f0 .hidden __ltdf2
0400225c g     F .text	0000007c xQueuePeekFromISR
0401aab0 g       *ABS*	00000000 __DTOR_END__
04007830 g     F .text	00000038 puts
04019e64 g     F .text	00000098 alt_exception_cause_generated_bad_addr
0400111c g     F .text	00000024 vPortFree
0401082c g     F .text	0000011c __ratio
04011ccc g     F .text	00000050 __vfiprintf_internal
04001da4 g     F .text	00000210 xQueueSemaphoreTake
040191a0 g     F .text	00000220 altera_avalon_jtag_uart_read
0400764c g     F .text	00000064 _printf_r
04015380 g     F .text	00000064 .hidden __udivsi3
04018204 g     F .text	000000b0 isatty
04014348 g     F .text	00000104 _raise_r
040130ac g     F .text	00000084 __assert_func
0401ac74 g     O .rodata	000000c8 __mprec_tens
0400589c g     F .text	00000060 uxTaskGetStackHighWaterMark
04000b34 g     F .text	0000008c vListInsertEnd
0401ea88 g     O .bss	00000004 __malloc_top_pad
040060a8 g     F .text	00000104 ulTaskGenericNotifyTake
04014678 g     F .text	00000034 _getpid_r
040003a0 g     F .text	00000054 xEventGroupCreate
0400da88 g     F .text	00000034 _localeconv_r
0400f704 g     F .text	00000084 __i2b
0400d228 g     F .text	000005e8 __sfvwrite_r
0401444c g     F .text	000000e4 __sigtramp_r
040117d8 g     F .text	00000060 _sbrk_r
040009b8 g     F .text	0000003c vEventGroupSetBitsCallback
04004468 g     F .text	000001a4 xTaskResumeFromISR
04013b60 g     F .text	00000070 _read_r
04000b08 g     F .text	0000002c vListInitialiseItem
0401ce1c g     O .rwdata	00000004 alt_max_fd
04000f24 g     F .text	00000044 vPortSysTickHandler
040132c4 g     F .text	0000012c _fclose_r
04001bfc g     F .text	000001a8 xQueueReceive
0400c450 g     F .text	00000054 fflush
0401ea8c g     O .bss	00000004 __malloc_max_sbrked_mem
04003e9c g     F .text	0000004c uxTaskPriorityGetFromISR
04015440 g     F .text	00000978 .hidden __adddf3
040103cc g     F .text	000001fc __b2d
04014cc8 g     F .text	000005c4 .hidden __umoddi3
04018544 g     F .text	000000e0 lseek
0401ce00 g     O .rwdata	00000004 _global_impure_ptr
040007c4 g     F .text	00000180 xEventGroupSetBits
04010be4 g     F .text	00000bf4 _realloc_r
0481ecac g       *ABS*	00000000 __bss_end
040180e0 g     F .text	000000e8 alt_iic_isr_register
0401a368 g     F .text	00000108 alt_tick
040146ac g     F .text	0000061c .hidden __udivdi3
040136bc g     F .text	00000088 _fputwc_r
0401ad3c g     O .rodata	00000028 __mprec_bigtens
0400f3d4 g     F .text	000001b8 __s2b
040141d8 g     F .text	00000020 abort
04017bb8 g     F .text	00000090 .hidden __floatunsidf
0400ff10 g     F .text	00000104 __mcmp
04001034 g     F .text	000000e8 pvPortMalloc
0400ca8c g     F .text	00000040 __fp_lock_all
04018094 g     F .text	0000004c alt_ic_irq_enabled
040023a4 g     F .text	0000003c vQueueDelete
04000e74 g     F .text	00000020 vPortEndScheduler
04000aa0 g     F .text	00000068 vListInitialise
04003314 g     F .text	00000058 xStreamBufferIsEmpty
0401a2c4 g     F .text	000000a4 alt_alarm_stop
0401ea9c g     O .bss	00000004 alt_irq_active
0400023c g     F .exceptions	000000c8 alt_irq_handler
0401bbc4 g     O .rwdata	00000028 alt_dev_null
040049e8 g     F .text	00000028 xTaskGetTickCount
04001850 g     F .text	000001b4 xQueueGenericSend
04002bc8 g     F .text	000001d0 xStreamBufferSend
04003470 g     F .text	00000088 xStreamBufferReceiveCompletedFromISR
04019be8 g     F .text	00000020 alt_dcache_flush_all
0400f58c g     F .text	0000008c __hi0bits
04006a30 g     F .text	000002cc vTaskGenericNotifyGiveFromISR
04017a7c g     F .text	00000080 .hidden __fixdfsi
040030bc g     F .text	00000098 xStreamBufferNextMessageLengthBytes
04005bb8 g     F .text	000001b8 xTaskPriorityDisinherit
0401ce34 g       *ABS*	00000000 __ram_rwdata_end
0401ce14 g     O .rwdata	00000008 alt_dev_list
04018990 g     F .text	00000104 write
04005024 g     F .text	000002d0 xTaskRemoveFromEventList
0401b22c g       *ABS*	00000000 __ram_rodata_end
040070c4 g     F .text	0000003c writeScore
04017e54 g     F .text	000000bc fstat
04000720 g     F .text	00000068 xEventGroupClearBits
040182f0 g     F .text	0000012c kill
0401685c g     F .text	000000f0 .hidden __ledf2
04001fb4 g     F .text	000001b0 xQueuePeek
0400fb84 g     F .text	00000170 __pow5mult
04011d1c g     F .text	000012c0 ___vfiprintf_internal_r
040153e4 g     F .text	0000005c .hidden __umodsi3
0481ecac g       *ABS*	00000000 end
04003154 g     F .text	000000e0 xStreamBufferReceiveFromISR
04003c04 g     F .text	000000f4 vTaskDelete
0400713c g     F .text	00000038 getScore
04018cd8 g     F .text	000000c0 altera_avalon_jtag_uart_init
04000304 g     F .exceptions	00000060 alt_instruction_exception_entry
04006070 g     F .text	00000038 pvTaskIncrementMutexHeldCount
0401aab0 g       *ABS*	00000000 __CTOR_LIST__
08000000 g       *ABS*	00000000 __alt_stack_pointer
04019664 g     F .text	00000084 alt_avalon_timer_sc_init
04017c48 g     F .text	00000054 .hidden __clzsi2
040193c0 g     F .text	00000228 altera_avalon_jtag_uart_write
0400c9c4 g     F .text	00000020 __sfp_lock_acquire
0400eca8 g     F .text	000001bc memchr
04007a9c g     F .text	00002160 ___vfprintf_internal_r
04007174 g     F .text	000000b8 task1
040055cc g     F .text	000000e8 xTaskCheckForTimeOut
0400cb0c g     F .text	00000558 _free_r
040059b0 g     F .text	00000208 xTaskPriorityInherit
0401ae5c g     O .rodata	00000180 _ctype_b
04013940 g     F .text	00000038 __locale_mb_cur_max
0401a924 g     F .text	0000018c __call_exitprocs
040061ac g     F .text	00000164 xTaskGenericNotifyWait
04002960 g     F .text	00000064 vStreamBufferDelete
0401ce08 g     O .rwdata	00000004 __malloc_sbrk_base
04000364 g     F .text	0000003c _start
0400722c g     F .text	00000034 task2
0401eab0 g     O .bss	00000004 _alt_tick_rate
040046e8 g     F .text	0000002c vTaskSuspendAll
0400336c g     F .text	0000007c xStreamBufferIsFull
04004a10 g     F .text	0000002c xTaskGetTickCountFromISR
0400fcf4 g     F .text	0000021c __lshift
0401eab4 g     O .bss	00000004 _alt_nticks
04007060 g     F .text	00000064 parseData
04014568 g     F .text	00000040 signal
04018724 g     F .text	00000108 read
04018b04 g     F .text	00000070 alt_sys_init
04019724 g     F .text	00000044 alt_up_accelerometer_spi_read_address_register
04000c98 g     F .text	00000098 uxListRemove
0401a80c g     F .text	00000118 __register_exitproc
0400288c g     F .text	000000d4 xStreamBufferGenericCreate
0400f788 g     F .text	000003fc __multiply
04019044 g     F .text	00000068 altera_avalon_jtag_uart_close
040072d8 g     F .text	00000028 .hidden __mulsi3
0401b22c g       *ABS*	00000000 __ram_rwdata_start
0401aab0 g       *ABS*	00000000 __ram_rodata_start
0481eb84 g     O .bss	00000028 __malloc_current_mallinfo
040042e0 g     F .text	00000188 vTaskResume
040105c8 g     F .text	00000264 __d2b
04004e28 g     F .text	000000f0 vTaskSwitchContext
04000000 g       *ABS*	00000000 __alt_mem_dram
04018b74 g     F .text	00000060 altera_avalon_jtag_uart_read_fd
0401a59c g     F .text	000000b8 alt_get_fd
0401990c g     F .text	000000d4 alt_up_accelerometer_spi_read_y_axis
0401304c g     F .text	00000060 _close_r
0401a6d8 g     F .text	00000134 memcmp
04018c34 g     F .text	00000050 altera_avalon_jtag_uart_close_fd
0481ecac g       *ABS*	00000000 __alt_stack_base
04018c84 g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
04009f4c g     F .text	000001a0 __swsetup_r
04004150 g     F .text	00000124 vTaskSuspend
04015db8 g     F .text	00000934 .hidden __divdf3
0400c704 g     F .text	00000194 __sfp
040109fc g     F .text	000000c4 __copybits
04004a9c g     F .text	00000050 xTaskCatchUpTicks
04004a3c g     F .text	00000020 uxTaskGetNumberOfTasks
0401b650 g     O .rwdata	00000408 __malloc_av_
0400ca24 g     F .text	00000020 __sinit_lock_release
0401694c g     F .text	000007a8 .hidden __muldf3
04011838 g     F .text	0000009c __sread
0401a494 g     F .text	00000108 alt_find_file
04019c44 g     F .text	000000a8 alt_dev_llist_insert
040186a0 g     F .text	00000024 __malloc_lock
0401889c g     F .text	000000b8 sbrk
04001744 g     F .text	0000009c xQueueTakeMutexRecursive
0400c3c8 g     F .text	00000088 _fflush_r
04000944 g     F .text	00000074 vEventGroupDelete
04013160 g     F .text	00000164 _calloc_r
04006310 g     F .text	00000348 xTaskGenericNotify
0401ea3c g       *ABS*	00000000 __bss_start
04007488 g     F .text	000001c4 memset
04007260 g     F .text	00000078 main
0401eaa8 g     O .bss	00000004 alt_envp
0401ea90 g     O .bss	00000004 __malloc_max_total_mem
04018bd4 g     F .text	00000060 altera_avalon_jtag_uart_write_fd
04013ecc g     F .text	00000040 __swbuf
04000bc0 g     F .text	000000d8 vListInsert
04011a58 g     F .text	00000054 __sclose
08000000 g       *ABS*	00000000 __alt_heap_limit
040133f0 g     F .text	00000038 fclose
0400a4a0 g     F .text	00001c2c _dtoa_r
0400e140 g     F .text	00000b68 _malloc_r
04014160 g     F .text	00000078 __ascii_wctomb
0401ce20 g     O .rwdata	00000004 alt_errno
04013428 g     F .text	0000005c _fiprintf_r
040145a8 g     F .text	00000030 _init_signal
0400d810 g     F .text	000000d8 _fwalk
04002164 g     F .text	000000f8 xQueueReceiveFromISR
04013a74 g     F .text	00000058 _mbtowc_r
04005988 g     F .text	00000028 xTaskGetCurrentTaskHandle
0401528c g     F .text	00000080 .hidden __divsi3
040013d0 g     F .text	000001a4 xQueueGenericCreate
0400d064 g     F .text	000001c4 _malloc_trim_r
0401aab0 g       *ABS*	00000000 __CTOR_END__
04013bd0 g     F .text	00000140 strcmp
040017e0 g     F .text	00000070 xQueueCreateCountingSemaphore
0401aab0 g       *ABS*	00000000 __flash_rodata_start
0401aab0 g       *ABS*	00000000 __DTOR_LIST__
04002a78 g     F .text	0000006c xStreamBufferSetTriggerLevel
04006658 g     F .text	000003d8 xTaskGenericNotifyFromISR
040166ec g     F .text	00000080 .hidden __nedf2
04018ac8 g     F .text	0000003c alt_irq_init
0401882c g     F .text	00000070 alt_release_fd
04004714 g     F .text	000002d4 xTaskResumeAll
0401cdf8 g     O .rwdata	00000004 uxTopUsedPriority
04002318 g     F .text	00000054 uxQueueSpacesAvailable
0401b0e0 g     O .rodata	00000100 .hidden __clz_tab
0400460c g     F .text	00000094 vTaskStartScheduler
0401ea98 g     O .bss	00000004 _PathLocale
0401a654 g     F .text	0000003c atexit
04012fdc g     F .text	00000070 _write_r
04013978 g     F .text	00000040 setlocale
0400283c g     F .text	00000050 xQueueIsQueueFullFromISR
0401cdfc g     O .rwdata	00000004 _impure_ptr
0401eaa0 g     O .bss	00000004 alt_argc
0400c0cc g     F .text	000002fc __sflush_r
04019d50 g     F .text	00000064 _do_dtors
04007100 g     F .text	0000003c sendReading
04000020 g       .exceptions	00000000 alt_irq_entry
04013acc g     F .text	00000094 __ascii_mbtowc
04010308 g     F .text	000000c4 __ulp
0400cacc g     F .text	00000040 __fp_unlock_all
040056b4 g     F .text	00000028 vTaskMissedYield
0401ce0c g     O .rwdata	00000008 alt_fs_list
040022d8 g     F .text	00000040 uxQueueMessagesWaiting
04004aec g     F .text	0000033c xTaskIncrementTick
04000020 g       *ABS*	00000000 __ram_exceptions_start
040196e8 g     F .text	0000003c alt_up_accelerometer_spi_open_dev
0400dabc g     F .text	00000030 localeconv
0400dc94 g     F .text	000000e8 __swhatbuf_r
04017f30 g     F .text	00000050 alt_ic_isr_register
04001190 g     F .text	00000240 xQueueGenericReset
0401ce34 g       *ABS*	00000000 _edata
0481ecac g       *ABS*	00000000 _end
040134e4 g     F .text	000001d8 __fputwc
04000364 g       *ABS*	00000000 __ram_exceptions_end
040190ac g     F .text	000000f4 altera_avalon_jtag_uart_ioctl
040037ac g     F .text	000000f4 xTaskCreate
04001140 g     F .text	00000024 vPortInitialiseBlocks
04006cfc g     F .text	0000008c xTaskGenericNotifyStateClear
04018008 g     F .text	0000008c alt_ic_irq_disable
04011904 g     F .text	000000b4 __swrite
0401ce04 g     O .rwdata	00000004 __malloc_trim_threshold
0401a690 g     F .text	00000048 exit
04013484 g     F .text	00000060 fiprintf
04013d10 g     F .text	00000054 _vfiprintf_r
0400d8e8 g     F .text	000000dc _fwalk_reent
04010014 g     F .text	000002f4 __mdiff
0401530c g     F .text	00000074 .hidden __modsi3
04003de8 g     F .text	0000005c vTaskDelay
040199e0 g     F .text	000000d4 alt_up_accelerometer_spi_read_z_axis
08000000 g       *ABS*	00000000 __alt_data_end
04000020 g     F .exceptions	00000000 alt_exception
0400c9e4 g     F .text	00000020 __sfp_lock_release
0401afdc g     O .rodata	00000101 _ctype_
04005d70 g     F .text	00000204 vTaskPriorityDisinheritAfterTimeout
04017a28 g     F .text	00000054 .hidden __unorddf2
04017de0 g     F .text	00000038 _exit
04019ab4 g     F .text	00000134 alt_alarm_start
04019768 g     F .text	00000068 alt_up_accelerometer_spi_read
040197d0 g     F .text	00000068 alt_up_accelerometer_spi_write
0400daec g     F .text	000001a8 __smakebuf_r
04005fc8 g     F .text	00000064 vTaskExitCritical
04007868 g     F .text	000000f4 strlen
04000d5c g     F .text	000000e0 pxPortInitialiseStack
040141f8 g     F .text	0000009c _init_signal_r
0401a164 g     F .text	00000160 open
0401676c g     F .text	000000f0 .hidden __gedf2
04013130 g     F .text	00000030 __assert
04011aac g     F .text	00000130 __sprint_r
04019e44 g     F .text	00000020 alt_icache_flush_all
04005544 g     F .text	0000004c vTaskSetTimeOutState
0401ce24 g     O .rwdata	00000004 alt_priority_mask
04017f80 g     F .text	00000088 alt_ic_irq_enable
04007a4c g     F .text	00000050 __vfprintf_internal
04014110 g     F .text	00000050 _wctomb_r
0400236c g     F .text	00000038 uxQueueMessagesWaitingFromISR
0400279c g     F .text	00000048 xQueueIsQueueEmptyFromISR
04002b88 g     F .text	00000040 xStreamBufferBytesAvailable
040170f4 g     F .text	00000934 .hidden __subdf3
0400f618 g     F .text	000000ec __lo0bits
0401ce2c g     O .rwdata	00000008 alt_alarm_list
04019cec g     F .text	00000064 _do_ctors
040145d8 g     F .text	00000038 __sigtramp
0400602c g     F .text	00000044 uxTaskResetEventItemValue
0401400c g     F .text	000000b8 wcrtomb
04001658 g     F .text	0000005c xQueueCreateMutex
04017cd8 g     F .text	000000dc close
0401ba58 g     O .rwdata	0000016c __global_locale
04018484 g     F .text	00000084 alt_load
040009f4 g     F .text	0000003c vEventGroupClearBitsCallback
040033e8 g     F .text	00000088 xStreamBufferSendCompletedFromISR
04001b0c g     F .text	000000f0 xQueueGiveFromISR
04013744 g     F .text	00000068 fputwc
04014530 g     F .text	00000038 raise
0400ca04 g     F .text	00000020 __sinit_lock_acquire
0400f204 g     F .text	000001d0 __multadd
0400f190 g     F .text	00000074 _Bfree



Disassembly of section .entry:

04000000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
 4000000:	00410034 	movhi	at,1024
    ori r1, r1, %lo(_start)
 4000004:	0840d914 	ori	at,at,868
    jmp r1
 4000008:	0800683a 	jmp	at
	...

Disassembly of section .exceptions:

04000020 <alt_exception>:
# Entry point for exceptions.
.section .exceptions.entry.user, "xa"

# Save the entire context of a task.
save_context:
	addi	sp,	sp, -116		# Create space on the stack.
 4000020:	deffe304 	addi	sp,sp,-116
	stw		ra, 0(sp)
 4000024:	dfc00015 	stw	ra,0(sp)
								# Leave a gap for muldiv 0
	stw		at, 8(sp)
 4000028:	d8400215 	stw	at,8(sp)
	stw		r2, 12(sp)
 400002c:	d8800315 	stw	r2,12(sp)
	stw		r3, 16(sp)
 4000030:	d8c00415 	stw	r3,16(sp)
	stw		r4, 20(sp)
 4000034:	d9000515 	stw	r4,20(sp)
	stw		r5, 24(sp)
 4000038:	d9400615 	stw	r5,24(sp)
	stw		r6, 28(sp)
 400003c:	d9800715 	stw	r6,28(sp)
	stw		r7, 32(sp)
 4000040:	d9c00815 	stw	r7,32(sp)
	stw		r8, 36(sp)
 4000044:	da000915 	stw	r8,36(sp)
	stw		r9, 40(sp)
 4000048:	da400a15 	stw	r9,40(sp)
	stw		r10, 44(sp)
 400004c:	da800b15 	stw	r10,44(sp)
	stw		r11, 48(sp)
 4000050:	dac00c15 	stw	r11,48(sp)
	stw		r12, 52(sp)
 4000054:	db000d15 	stw	r12,52(sp)
	stw		r13, 56(sp)
 4000058:	db400e15 	stw	r13,56(sp)
	stw		r14, 60(sp)
 400005c:	db800f15 	stw	r14,60(sp)
	stw		r15, 64(sp)
 4000060:	dbc01015 	stw	r15,64(sp)
	rdctl	r5, estatus 		# Save the eStatus
 4000064:	000b307a 	rdctl	r5,estatus
	stw		r5, 68(sp)
 4000068:	d9401115 	stw	r5,68(sp)
	addi	r15, ea, -4			# Instruction that caused exception
 400006c:	ebffff04 	addi	r15,ea,-4
	stw		r15, 72(sp)			# Save as EA
 4000070:	dbc01215 	stw	r15,72(sp)
	stw		r16, 76(sp)			# Save the remaining registers
 4000074:	dc001315 	stw	r16,76(sp)
	stw		r17, 80(sp)
 4000078:	dc401415 	stw	r17,80(sp)
	stw		r18, 84(sp)
 400007c:	dc801515 	stw	r18,84(sp)
	stw		r19, 88(sp)
 4000080:	dcc01615 	stw	r19,88(sp)
	stw		r20, 92(sp)
 4000084:	dd001715 	stw	r20,92(sp)
	stw		r21, 96(sp)
 4000088:	dd401815 	stw	r21,96(sp)
	stw		r22, 100(sp)
 400008c:	dd801915 	stw	r22,100(sp)
	stw		r23, 104(sp)
 4000090:	ddc01a15 	stw	r23,104(sp)
	stw		gp, 108(sp)
 4000094:	de801b15 	stw	gp,108(sp)
	stw		fp, 112(sp)
 4000098:	df001c15 	stw	fp,112(sp)

0400009c <save_sp_to_pxCurrentTCB>:
 400009c:	060100b4 	movhi	et,1026

save_sp_to_pxCurrentTCB:
	movia	et, pxCurrentTCB	# Load the address of the pxCurrentTCB pointer
 40000a0:	c63a9104 	addi	et,et,-5564
	ldw		et, (et)			# Load the value of the pxCurrentTCB pointer
 40000a4:	c6000017 	ldw	et,0(et)
	stw		sp, (et)			# Store the stack pointer into the top of the TCB
 40000a8:	c6c00015 	stw	sp,0(et)

	br		irq_test_user		# skip the section .exceptions.entry
 40000ac:	00001506 	br	4000104 <irq_test_user>

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
 40000b0:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
 40000b4:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
 40000b8:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
 40000bc:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
 40000c0:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
 40000c4:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
 40000c8:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
 40000cc:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
 40000d0:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
 40000d4:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
 40000d8:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
 40000dc:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
 40000e0:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
 40000e4:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
 40000e8:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
 40000ec:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
 40000f0:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
 40000f4:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
 40000f8:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
 40000fc:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 4000100:	dbc01215 	stw	r15,72(sp)

04000104 <irq_test_user>:
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
 4000104:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
 4000108:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
 400010c:	10000326 	beq	r2,zero,400011c <irq_test_user+0x18>
        beq   r4, zero, .Lnot_irq
 4000110:	20000226 	beq	r4,zero,400011c <irq_test_user+0x18>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
 4000114:	400023c0 	call	400023c <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
 4000118:	00001006 	br	400015c <restore_sp_from_pxCurrentTCB>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
 400011c:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
 4000120:	e8bfff17 	ldw	r2,-4(ea)

04000124 <soft_exceptions>:

	eret					# Return to address ea, loading eStatus into Status.

	.section .exceptions.soft, "xa"
soft_exceptions:
	movhi	r3, 0x003b				/* upper half of trap opcode */
 4000124:	00c00ef4 	movhi	r3,59
	ori		r3, r3, 0x683a			/* lower half of trap opcode */
 4000128:	18da0e94 	ori	r3,r3,26682
	beq		r2, r3, call_scheduler
 400012c:	10c00126 	beq	r2,r3,4000134 <call_scheduler>
	br		exceptions_unknown_user			# its something else
 4000130:	00000506 	br	4000148 <exceptions_unknown_user>

04000134 <call_scheduler>:

call_scheduler:
	stw		ea, 72(sp)						# EA is PC+4 so will skip over instruction causing exception
 4000134:	df401215 	stw	ea,72(sp)
 4000138:	03c10034 	movhi	r15,1024
	movia	r15, vTaskSwitchContext			# Pick the next context - use long call version in place of "call"
 400013c:	7bd38a04 	addi	r15,r15,20008
	callr	r15
 4000140:	783ee83a 	callr	r15
	br		restore_sp_from_pxCurrentTCB	# Switch in the task context and restore.
 4000144:	00000506 	br	400015c <restore_sp_from_pxCurrentTCB>

04000148 <exceptions_unknown_user>:
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
 4000148:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
 400014c:	40003040 	call	4000304 <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
 4000150:	1000021e 	bne	r2,zero,400015c <restore_sp_from_pxCurrentTCB>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
 4000154:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 4000158:	dbc01215 	stw	r15,72(sp)

0400015c <restore_sp_from_pxCurrentTCB>:
 400015c:	060100b4 	movhi	et,1026
	movia	et, pxCurrentTCB		# Load the address of the pxCurrentTCB pointer
 4000160:	c63a9104 	addi	et,et,-5564
	ldw		et, (et)				# Load the value of the pxCurrentTCB pointer
 4000164:	c6000017 	ldw	et,0(et)
	ldw		sp, (et)				# Load the stack pointer with the top value of the TCB
 4000168:	c6c00017 	ldw	sp,0(et)

0400016c <restore_context>:
	ldw		ra, 0(sp)		# Restore the registers.
 400016c:	dfc00017 	ldw	ra,0(sp)
	ldw		at, 8(sp)
 4000170:	d8400217 	ldw	at,8(sp)
	ldw		r2, 12(sp)
 4000174:	d8800317 	ldw	r2,12(sp)
	ldw		r3, 16(sp)
 4000178:	d8c00417 	ldw	r3,16(sp)
	ldw		r4, 20(sp)
 400017c:	d9000517 	ldw	r4,20(sp)
	ldw		r5, 24(sp)
 4000180:	d9400617 	ldw	r5,24(sp)
	ldw		r6, 28(sp)
 4000184:	d9800717 	ldw	r6,28(sp)
	ldw		r7, 32(sp)
 4000188:	d9c00817 	ldw	r7,32(sp)
	ldw		r8, 36(sp)
 400018c:	da000917 	ldw	r8,36(sp)
	ldw		r9, 40(sp)
 4000190:	da400a17 	ldw	r9,40(sp)
	ldw		r10, 44(sp)
 4000194:	da800b17 	ldw	r10,44(sp)
	ldw		r11, 48(sp)
 4000198:	dac00c17 	ldw	r11,48(sp)
	ldw		r12, 52(sp)
 400019c:	db000d17 	ldw	r12,52(sp)
	ldw		r13, 56(sp)
 40001a0:	db400e17 	ldw	r13,56(sp)
	ldw		r14, 60(sp)
 40001a4:	db800f17 	ldw	r14,60(sp)
	ldw		r15, 64(sp)
 40001a8:	dbc01017 	ldw	r15,64(sp)
	ldw		et, 68(sp)		# Load the eStatus
 40001ac:	de001117 	ldw	et,68(sp)
	wrctl	estatus, et 	# Write the eStatus
 40001b0:	c001707a 	wrctl	estatus,et
	ldw		ea, 72(sp)		# Load the Program Counter
 40001b4:	df401217 	ldw	ea,72(sp)
	ldw		r16, 76(sp)
 40001b8:	dc001317 	ldw	r16,76(sp)
	ldw		r17, 80(sp)
 40001bc:	dc401417 	ldw	r17,80(sp)
	ldw		r18, 84(sp)
 40001c0:	dc801517 	ldw	r18,84(sp)
	ldw		r19, 88(sp)
 40001c4:	dcc01617 	ldw	r19,88(sp)
	ldw		r20, 92(sp)
 40001c8:	dd001717 	ldw	r20,92(sp)
	ldw		r21, 96(sp)
 40001cc:	dd401817 	ldw	r21,96(sp)
	ldw		r22, 100(sp)
 40001d0:	dd801917 	ldw	r22,100(sp)
	ldw		r23, 104(sp)
 40001d4:	ddc01a17 	ldw	r23,104(sp)
	ldw		gp, 108(sp)
 40001d8:	de801b17 	ldw	gp,108(sp)
	ldw		fp, 112(sp)
 40001dc:	df001c17 	ldw	fp,112(sp)
	addi	sp,	sp, 116		# Release stack space
 40001e0:	dec01d04 	addi	sp,sp,116
	eret					# Return to address ea, loading eStatus into Status.
 40001e4:	ef80083a 	eret
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
 40001e8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
 40001ec:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
 40001f0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
 40001f4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
 40001f8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
 40001fc:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
 4000200:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
 4000204:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
 4000208:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
 400020c:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
 4000210:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
 4000214:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
 4000218:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
 400021c:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
 4000220:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
 4000224:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
 4000228:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
 400022c:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
 4000230:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
 4000234:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
 4000238:	ef80083a 	eret

0400023c <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
 400023c:	defff904 	addi	sp,sp,-28
 4000240:	dfc00615 	stw	ra,24(sp)
 4000244:	df000515 	stw	fp,20(sp)
 4000248:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
 400024c:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 4000250:	0005313a 	rdctl	r2,ipending
 4000254:	e0bffc15 	stw	r2,-16(fp)

  return active;
 4000258:	e0bffc17 	ldw	r2,-16(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
 400025c:	e0bfff15 	stw	r2,-4(fp)

  do
  {
    i = 0;
 4000260:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
 4000264:	00800044 	movi	r2,1
 4000268:	e0bffe15 	stw	r2,-8(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
 400026c:	e0ffff17 	ldw	r3,-4(fp)
 4000270:	e0bffe17 	ldw	r2,-8(fp)
 4000274:	1884703a 	and	r2,r3,r2
 4000278:	10001126 	beq	r2,zero,40002c0 <alt_irq_handler+0x84>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
 400027c:	e0bffd17 	ldw	r2,-12(fp)
 4000280:	100690fa 	slli	r3,r2,3
 4000284:	008120b4 	movhi	r2,1154
 4000288:	1885883a 	add	r2,r3,r2
 400028c:	10faeb17 	ldw	r3,-5204(r2)
 4000290:	e0bffd17 	ldw	r2,-12(fp)
 4000294:	100890fa 	slli	r4,r2,3
 4000298:	008120b4 	movhi	r2,1154
 400029c:	2085883a 	add	r2,r4,r2
 40002a0:	10baec17 	ldw	r2,-5200(r2)
 40002a4:	1009883a 	mov	r4,r2
 40002a8:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
 40002ac:	0001883a 	nop
  NIOS2_READ_IPENDING (active);
 40002b0:	0005313a 	rdctl	r2,ipending
 40002b4:	e0bffb15 	stw	r2,-20(fp)
  return active;
 40002b8:	e0bffb17 	ldw	r2,-20(fp)
 40002bc:	00000706 	br	40002dc <alt_irq_handler+0xa0>
      }
      mask <<= 1;
 40002c0:	e0bffe17 	ldw	r2,-8(fp)
 40002c4:	1085883a 	add	r2,r2,r2
 40002c8:	e0bffe15 	stw	r2,-8(fp)
      i++;
 40002cc:	e0bffd17 	ldw	r2,-12(fp)
 40002d0:	10800044 	addi	r2,r2,1
 40002d4:	e0bffd15 	stw	r2,-12(fp)
      if (active & mask)
 40002d8:	003fe406 	br	400026c <alt_irq_handler+0x30>

    } while (1);

    active = alt_irq_pending ();
 40002dc:	e0bfff15 	stw	r2,-4(fp)
    
  } while (active);
 40002e0:	e0bfff17 	ldw	r2,-4(fp)
 40002e4:	103fde1e 	bne	r2,zero,4000260 <alt_irq_handler+0x24>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
 40002e8:	0001883a 	nop
}
 40002ec:	0001883a 	nop
 40002f0:	e037883a 	mov	sp,fp
 40002f4:	dfc00117 	ldw	ra,4(sp)
 40002f8:	df000017 	ldw	fp,0(sp)
 40002fc:	dec00204 	addi	sp,sp,8
 4000300:	f800283a 	ret

04000304 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
 4000304:	defffb04 	addi	sp,sp,-20
 4000308:	dfc00415 	stw	ra,16(sp)
 400030c:	df000315 	stw	fp,12(sp)
 4000310:	df000304 	addi	fp,sp,12
 4000314:	e13ffd15 	stw	r4,-12(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
 4000318:	00bfffc4 	movi	r2,-1
 400031c:	e0bfff15 	stw	r2,-4(fp)
  badaddr = 0;
 4000320:	e03ffe15 	stw	zero,-8(fp)
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
 4000324:	d0a72d17 	ldw	r2,-25420(gp)
 4000328:	10000726 	beq	r2,zero,4000348 <alt_instruction_exception_entry+0x44>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
 400032c:	d0a72d17 	ldw	r2,-25420(gp)
 4000330:	e0ffff17 	ldw	r3,-4(fp)
 4000334:	e1bffe17 	ldw	r6,-8(fp)
 4000338:	e17ffd17 	ldw	r5,-12(fp)
 400033c:	1809883a 	mov	r4,r3
 4000340:	103ee83a 	callr	r2
 4000344:	00000206 	br	4000350 <alt_instruction_exception_entry+0x4c>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
 4000348:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
 400034c:	0005883a 	mov	r2,zero
}
 4000350:	e037883a 	mov	sp,fp
 4000354:	dfc00117 	ldw	ra,4(sp)
 4000358:	df000017 	ldw	fp,0(sp)
 400035c:	dec00204 	addi	sp,sp,8
 4000360:	f800283a 	ret

Disassembly of section .text:

04000364 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 4000364:	06c20034 	movhi	sp,2048
    ori sp, sp, %lo(__alt_stack_pointer)
 4000368:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
 400036c:	068100b4 	movhi	gp,1026
    ori gp, gp, %lo(_gp)
 4000370:	d6937e14 	ori	gp,gp,19960
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 4000374:	00810074 	movhi	r2,1025
    ori r2, r2, %lo(__bss_start)
 4000378:	10ba8f14 	ori	r2,r2,59964

    movhi r3, %hi(__bss_end)
 400037c:	00c12074 	movhi	r3,1153
    ori r3, r3, %lo(__bss_end)
 4000380:	18fb2b14 	ori	r3,r3,60588

    beq r2, r3, 1f
 4000384:	10c00326 	beq	r2,r3,4000394 <_start+0x30>

0:
    stw zero, (r2)
 4000388:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 400038c:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 4000390:	10fffd36 	bltu	r2,r3,4000388 <_start+0x24>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
 4000394:	40184840 	call	4018484 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 4000398:	40186240 	call	4018624 <alt_main>

0400039c <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 400039c:	003fff06 	br	400039c <alt_after_alt_main>

040003a0 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    EventGroupHandle_t xEventGroupCreate( void )
    {
 40003a0:	defffd04 	addi	sp,sp,-12
 40003a4:	dfc00215 	stw	ra,8(sp)
 40003a8:	df000115 	stw	fp,4(sp)
 40003ac:	df000104 	addi	fp,sp,4
         * TickType_t alignment requirements the cast is safe.  In other cases,
         * where the natural word size of the architecture is less than
         * sizeof( TickType_t ), the TickType_t variables will be accessed in two
         * or more reads operations, and the alignment requirements is only that
         * of each individual read. */
        pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
 40003b0:	01000604 	movi	r4,24
 40003b4:	40010340 	call	4001034 <pvPortMalloc>
 40003b8:	e0bfff15 	stw	r2,-4(fp)

        if( pxEventBits != NULL )
 40003bc:	e0bfff17 	ldw	r2,-4(fp)
 40003c0:	10000626 	beq	r2,zero,40003dc <xEventGroupCreate+0x3c>
        {
            pxEventBits->uxEventBits = 0;
 40003c4:	e0bfff17 	ldw	r2,-4(fp)
 40003c8:	10000015 	stw	zero,0(r2)
            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
 40003cc:	e0bfff17 	ldw	r2,-4(fp)
 40003d0:	10800104 	addi	r2,r2,4
 40003d4:	1009883a 	mov	r4,r2
 40003d8:	4000aa00 	call	4000aa0 <vListInitialise>
        else
        {
            traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
        }

        return pxEventBits;
 40003dc:	e0bfff17 	ldw	r2,-4(fp)
    }
 40003e0:	e037883a 	mov	sp,fp
 40003e4:	dfc00117 	ldw	ra,4(sp)
 40003e8:	df000017 	ldw	fp,0(sp)
 40003ec:	dec00204 	addi	sp,sp,8
 40003f0:	f800283a 	ret

040003f4 <xEventGroupSync>:

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
                             const EventBits_t uxBitsToSet,
                             const EventBits_t uxBitsToWaitFor,
                             TickType_t xTicksToWait )
{
 40003f4:	defff504 	addi	sp,sp,-44
 40003f8:	dfc00a15 	stw	ra,40(sp)
 40003fc:	df000915 	stw	fp,36(sp)
 4000400:	df000904 	addi	fp,sp,36
 4000404:	e13ffa15 	stw	r4,-24(fp)
 4000408:	e17ff915 	stw	r5,-28(fp)
 400040c:	e1bff815 	stw	r6,-32(fp)
 4000410:	e1fff715 	stw	r7,-36(fp)
    EventBits_t uxOriginalBitValue, uxReturn;
    EventGroup_t * pxEventBits = xEventGroup;
 4000414:	e0bffa17 	ldw	r2,-24(fp)
 4000418:	e0bffe15 	stw	r2,-8(fp)
    BaseType_t xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
 400041c:	e03ffd15 	stw	zero,-12(fp)
    {
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    }
    #endif

    vTaskSuspendAll();
 4000420:	40046e80 	call	40046e8 <vTaskSuspendAll>
    {
        uxOriginalBitValue = pxEventBits->uxEventBits;
 4000424:	e0bffe17 	ldw	r2,-8(fp)
 4000428:	10800017 	ldw	r2,0(r2)
 400042c:	e0bffc15 	stw	r2,-16(fp)

        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
 4000430:	e17ff917 	ldw	r5,-28(fp)
 4000434:	e13ffa17 	ldw	r4,-24(fp)
 4000438:	40007c40 	call	40007c4 <xEventGroupSetBits>

        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
 400043c:	e0fffc17 	ldw	r3,-16(fp)
 4000440:	e0bff917 	ldw	r2,-28(fp)
 4000444:	1886b03a 	or	r3,r3,r2
 4000448:	e0bff817 	ldw	r2,-32(fp)
 400044c:	1884703a 	and	r2,r3,r2
 4000450:	e0fff817 	ldw	r3,-32(fp)
 4000454:	18800d1e 	bne	r3,r2,400048c <xEventGroupSync+0x98>
        {
            /* All the rendezvous bits are now set - no need to block. */
            uxReturn = ( uxOriginalBitValue | uxBitsToSet );
 4000458:	e0fffc17 	ldw	r3,-16(fp)
 400045c:	e0bff917 	ldw	r2,-28(fp)
 4000460:	1884b03a 	or	r2,r3,r2
 4000464:	e0bfff15 	stw	r2,-4(fp)

            /* Rendezvous always clear the bits.  They will have been cleared
             * already unless this is the only task in the rendezvous. */
            pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 4000468:	e0bffe17 	ldw	r2,-8(fp)
 400046c:	10c00017 	ldw	r3,0(r2)
 4000470:	e0bff817 	ldw	r2,-32(fp)
 4000474:	0084303a 	nor	r2,zero,r2
 4000478:	1886703a 	and	r3,r3,r2
 400047c:	e0bffe17 	ldw	r2,-8(fp)
 4000480:	10c00015 	stw	r3,0(r2)

            xTicksToWait = 0;
 4000484:	e03ff715 	stw	zero,-36(fp)
 4000488:	00001106 	br	40004d0 <xEventGroupSync+0xdc>
        }
        else
        {
            if( xTicksToWait != ( TickType_t ) 0 )
 400048c:	e0bff717 	ldw	r2,-36(fp)
 4000490:	10000a26 	beq	r2,zero,40004bc <xEventGroupSync+0xc8>
                traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

                /* Store the bits that the calling task is waiting for in the
                 * task's event list item so the kernel knows when a match is
                 * found.  Then enter the blocked state. */
                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
 4000494:	e0bffe17 	ldw	r2,-8(fp)
 4000498:	10c00104 	addi	r3,r2,4
 400049c:	e0bff817 	ldw	r2,-32(fp)
 40004a0:	10814034 	orhi	r2,r2,1280
 40004a4:	e1bff717 	ldw	r6,-36(fp)
 40004a8:	100b883a 	mov	r5,r2
 40004ac:	1809883a 	mov	r4,r3
 40004b0:	4004f680 	call	4004f68 <vTaskPlaceOnUnorderedEventList>

                /* This assignment is obsolete as uxReturn will get set after
                 * the task unblocks, but some compilers mistakenly generate a
                 * warning about uxReturn being returned without being set if the
                 * assignment is omitted. */
                uxReturn = 0;
 40004b4:	e03fff15 	stw	zero,-4(fp)
 40004b8:	00000506 	br	40004d0 <xEventGroupSync+0xdc>
            }
            else
            {
                /* The rendezvous bits were not set, but no block time was
                 * specified - just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
 40004bc:	e0bffe17 	ldw	r2,-8(fp)
 40004c0:	10800017 	ldw	r2,0(r2)
 40004c4:	e0bfff15 	stw	r2,-4(fp)
                xTimeoutOccurred = pdTRUE;
 40004c8:	00800044 	movi	r2,1
 40004cc:	e0bffd15 	stw	r2,-12(fp)
            }
        }
    }
    xAlreadyYielded = xTaskResumeAll();
 40004d0:	40047140 	call	4004714 <xTaskResumeAll>
 40004d4:	e0bffb15 	stw	r2,-20(fp)

    if( xTicksToWait != ( TickType_t ) 0 )
 40004d8:	e0bff717 	ldw	r2,-36(fp)
 40004dc:	10002026 	beq	r2,zero,4000560 <xEventGroupSync+0x16c>
    {
        if( xAlreadyYielded == pdFALSE )
 40004e0:	e0bffb17 	ldw	r2,-20(fp)
 40004e4:	1000011e 	bne	r2,zero,40004ec <xEventGroupSync+0xf8>
        {
            portYIELD_WITHIN_API();
 40004e8:	003b683a 	trap	0

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
 40004ec:	400602c0 	call	400602c <uxTaskResetEventItemValue>
 40004f0:	e0bfff15 	stw	r2,-4(fp)

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
 40004f4:	e0bfff17 	ldw	r2,-4(fp)
 40004f8:	1080802c 	andhi	r2,r2,512
 40004fc:	1000131e 	bne	r2,zero,400054c <xEventGroupSync+0x158>
        {
            /* The task timed out, just return the current event bit value. */
            taskENTER_CRITICAL();
 4000500:	4005f740 	call	4005f74 <vTaskEnterCritical>
            {
                uxReturn = pxEventBits->uxEventBits;
 4000504:	e0bffe17 	ldw	r2,-8(fp)
 4000508:	10800017 	ldw	r2,0(r2)
 400050c:	e0bfff15 	stw	r2,-4(fp)

                /* Although the task got here because it timed out before the
                 * bits it was waiting for were set, it is possible that since it
                 * unblocked another task has set the bits.  If this is the case
                 * then it needs to clear the bits before exiting. */
                if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
 4000510:	e0ffff17 	ldw	r3,-4(fp)
 4000514:	e0bff817 	ldw	r2,-32(fp)
 4000518:	1884703a 	and	r2,r3,r2
 400051c:	e0fff817 	ldw	r3,-32(fp)
 4000520:	1880071e 	bne	r3,r2,4000540 <xEventGroupSync+0x14c>
                {
                    pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 4000524:	e0bffe17 	ldw	r2,-8(fp)
 4000528:	10c00017 	ldw	r3,0(r2)
 400052c:	e0bff817 	ldw	r2,-32(fp)
 4000530:	0084303a 	nor	r2,zero,r2
 4000534:	1886703a 	and	r3,r3,r2
 4000538:	e0bffe17 	ldw	r2,-8(fp)
 400053c:	10c00015 	stw	r3,0(r2)
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
 4000540:	4005fc80 	call	4005fc8 <vTaskExitCritical>

            xTimeoutOccurred = pdTRUE;
 4000544:	00800044 	movi	r2,1
 4000548:	e0bffd15 	stw	r2,-12(fp)
            /* The task unblocked because the bits were set. */
        }

        /* Control bits might be set as the task had blocked should not be
         * returned. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
 400054c:	e0ffff17 	ldw	r3,-4(fp)
 4000550:	00804034 	movhi	r2,256
 4000554:	10bfffc4 	addi	r2,r2,-1
 4000558:	1884703a 	and	r2,r3,r2
 400055c:	e0bfff15 	stw	r2,-4(fp)
    traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
 4000560:	e0bfff17 	ldw	r2,-4(fp)
}
 4000564:	e037883a 	mov	sp,fp
 4000568:	dfc00117 	ldw	ra,4(sp)
 400056c:	df000017 	ldw	fp,0(sp)
 4000570:	dec00204 	addi	sp,sp,8
 4000574:	f800283a 	ret

04000578 <xEventGroupWaitBits>:
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait )
{
 4000578:	defff304 	addi	sp,sp,-52
 400057c:	dfc00c15 	stw	ra,48(sp)
 4000580:	df000b15 	stw	fp,44(sp)
 4000584:	df000b04 	addi	fp,sp,44
 4000588:	e13ff815 	stw	r4,-32(fp)
 400058c:	e17ff715 	stw	r5,-36(fp)
 4000590:	e1bff615 	stw	r6,-40(fp)
 4000594:	e1fff515 	stw	r7,-44(fp)
    EventGroup_t * pxEventBits = xEventGroup;
 4000598:	e0bff817 	ldw	r2,-32(fp)
 400059c:	e0bffd15 	stw	r2,-12(fp)
    EventBits_t uxReturn, uxControlBits = 0;
 40005a0:	e03ffe15 	stw	zero,-8(fp)
    BaseType_t xWaitConditionMet, xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
 40005a4:	e03ffc15 	stw	zero,-16(fp)
    {
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    }
    #endif

    vTaskSuspendAll();
 40005a8:	40046e80 	call	40046e8 <vTaskSuspendAll>
    {
        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
 40005ac:	e0bffd17 	ldw	r2,-12(fp)
 40005b0:	10800017 	ldw	r2,0(r2)
 40005b4:	e0bffb15 	stw	r2,-20(fp)

        /* Check to see if the wait condition is already met or not. */
        xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
 40005b8:	e1bff517 	ldw	r6,-44(fp)
 40005bc:	e17ff717 	ldw	r5,-36(fp)
 40005c0:	e13ffb17 	ldw	r4,-20(fp)
 40005c4:	4000a300 	call	4000a30 <prvTestWaitCondition>
 40005c8:	e0bffa15 	stw	r2,-24(fp)

        if( xWaitConditionMet != pdFALSE )
 40005cc:	e0bffa17 	ldw	r2,-24(fp)
 40005d0:	10000d26 	beq	r2,zero,4000608 <xEventGroupWaitBits+0x90>
        {
            /* The wait condition has already been met so there is no need to
             * block. */
            uxReturn = uxCurrentEventBits;
 40005d4:	e0bffb17 	ldw	r2,-20(fp)
 40005d8:	e0bfff15 	stw	r2,-4(fp)
            xTicksToWait = ( TickType_t ) 0;
 40005dc:	e0000215 	stw	zero,8(fp)

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
 40005e0:	e0bff617 	ldw	r2,-40(fp)
 40005e4:	10002226 	beq	r2,zero,4000670 <xEventGroupWaitBits+0xf8>
            {
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 40005e8:	e0bffd17 	ldw	r2,-12(fp)
 40005ec:	10c00017 	ldw	r3,0(r2)
 40005f0:	e0bff717 	ldw	r2,-36(fp)
 40005f4:	0084303a 	nor	r2,zero,r2
 40005f8:	1886703a 	and	r3,r3,r2
 40005fc:	e0bffd17 	ldw	r2,-12(fp)
 4000600:	10c00015 	stw	r3,0(r2)
 4000604:	00001a06 	br	4000670 <xEventGroupWaitBits+0xf8>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else if( xTicksToWait == ( TickType_t ) 0 )
 4000608:	e0800217 	ldw	r2,8(fp)
 400060c:	1000051e 	bne	r2,zero,4000624 <xEventGroupWaitBits+0xac>
        {
            /* The wait condition has not been met, but no block time was
             * specified, so just return the current value. */
            uxReturn = uxCurrentEventBits;
 4000610:	e0bffb17 	ldw	r2,-20(fp)
 4000614:	e0bfff15 	stw	r2,-4(fp)
            xTimeoutOccurred = pdTRUE;
 4000618:	00800044 	movi	r2,1
 400061c:	e0bffc15 	stw	r2,-16(fp)
 4000620:	00001306 	br	4000670 <xEventGroupWaitBits+0xf8>
        {
            /* The task is going to block to wait for its required bits to be
             * set.  uxControlBits are used to remember the specified behaviour of
             * this call to xEventGroupWaitBits() - for use when the event bits
             * unblock the task. */
            if( xClearOnExit != pdFALSE )
 4000624:	e0bff617 	ldw	r2,-40(fp)
 4000628:	10000326 	beq	r2,zero,4000638 <xEventGroupWaitBits+0xc0>
            {
                uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
 400062c:	e0bffe17 	ldw	r2,-8(fp)
 4000630:	10804034 	orhi	r2,r2,256
 4000634:	e0bffe15 	stw	r2,-8(fp)
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if( xWaitForAllBits != pdFALSE )
 4000638:	e0bff517 	ldw	r2,-44(fp)
 400063c:	10000326 	beq	r2,zero,400064c <xEventGroupWaitBits+0xd4>
            {
                uxControlBits |= eventWAIT_FOR_ALL_BITS;
 4000640:	e0bffe17 	ldw	r2,-8(fp)
 4000644:	10810034 	orhi	r2,r2,1024
 4000648:	e0bffe15 	stw	r2,-8(fp)
            }

            /* Store the bits that the calling task is waiting for in the
             * task's event list item so the kernel knows when a match is
             * found.  Then enter the blocked state. */
            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
 400064c:	e0bffd17 	ldw	r2,-12(fp)
 4000650:	11000104 	addi	r4,r2,4
 4000654:	e0fff717 	ldw	r3,-36(fp)
 4000658:	e0bffe17 	ldw	r2,-8(fp)
 400065c:	1884b03a 	or	r2,r3,r2
 4000660:	e1800217 	ldw	r6,8(fp)
 4000664:	100b883a 	mov	r5,r2
 4000668:	4004f680 	call	4004f68 <vTaskPlaceOnUnorderedEventList>

            /* This is obsolete as it will get set after the task unblocks, but
             * some compilers mistakenly generate a warning about the variable
             * being returned without being set if it is not done. */
            uxReturn = 0;
 400066c:	e03fff15 	stw	zero,-4(fp)

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
 4000670:	40047140 	call	4004714 <xTaskResumeAll>
 4000674:	e0bff915 	stw	r2,-28(fp)

    if( xTicksToWait != ( TickType_t ) 0 )
 4000678:	e0800217 	ldw	r2,8(fp)
 400067c:	10002226 	beq	r2,zero,4000708 <xEventGroupWaitBits+0x190>
    {
        if( xAlreadyYielded == pdFALSE )
 4000680:	e0bff917 	ldw	r2,-28(fp)
 4000684:	1000011e 	bne	r2,zero,400068c <xEventGroupWaitBits+0x114>
        {
            portYIELD_WITHIN_API();
 4000688:	003b683a 	trap	0

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
 400068c:	400602c0 	call	400602c <uxTaskResetEventItemValue>
 4000690:	e0bfff15 	stw	r2,-4(fp)

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
 4000694:	e0bfff17 	ldw	r2,-4(fp)
 4000698:	1080802c 	andhi	r2,r2,512
 400069c:	1000151e 	bne	r2,zero,40006f4 <xEventGroupWaitBits+0x17c>
        {
            taskENTER_CRITICAL();
 40006a0:	4005f740 	call	4005f74 <vTaskEnterCritical>
            {
                /* The task timed out, just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
 40006a4:	e0bffd17 	ldw	r2,-12(fp)
 40006a8:	10800017 	ldw	r2,0(r2)
 40006ac:	e0bfff15 	stw	r2,-4(fp)

                /* It is possible that the event bits were updated between this
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
 40006b0:	e1bff517 	ldw	r6,-44(fp)
 40006b4:	e17ff717 	ldw	r5,-36(fp)
 40006b8:	e13fff17 	ldw	r4,-4(fp)
 40006bc:	4000a300 	call	4000a30 <prvTestWaitCondition>
 40006c0:	10000926 	beq	r2,zero,40006e8 <xEventGroupWaitBits+0x170>
                {
                    if( xClearOnExit != pdFALSE )
 40006c4:	e0bff617 	ldw	r2,-40(fp)
 40006c8:	10000726 	beq	r2,zero,40006e8 <xEventGroupWaitBits+0x170>
                    {
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 40006cc:	e0bffd17 	ldw	r2,-12(fp)
 40006d0:	10c00017 	ldw	r3,0(r2)
 40006d4:	e0bff717 	ldw	r2,-36(fp)
 40006d8:	0084303a 	nor	r2,zero,r2
 40006dc:	1886703a 	and	r3,r3,r2
 40006e0:	e0bffd17 	ldw	r2,-12(fp)
 40006e4:	10c00015 	stw	r3,0(r2)
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                xTimeoutOccurred = pdTRUE;
 40006e8:	00800044 	movi	r2,1
 40006ec:	e0bffc15 	stw	r2,-16(fp)
            }
            taskEXIT_CRITICAL();
 40006f0:	4005fc80 	call	4005fc8 <vTaskExitCritical>
        {
            /* The task unblocked because the bits were set. */
        }

        /* The task blocked so control bits may have been set. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
 40006f4:	e0ffff17 	ldw	r3,-4(fp)
 40006f8:	00804034 	movhi	r2,256
 40006fc:	10bfffc4 	addi	r2,r2,-1
 4000700:	1884703a 	and	r2,r3,r2
 4000704:	e0bfff15 	stw	r2,-4(fp)
    traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
 4000708:	e0bfff17 	ldw	r2,-4(fp)
}
 400070c:	e037883a 	mov	sp,fp
 4000710:	dfc00117 	ldw	ra,4(sp)
 4000714:	df000017 	ldw	fp,0(sp)
 4000718:	dec00204 	addi	sp,sp,8
 400071c:	f800283a 	ret

04000720 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                  const EventBits_t uxBitsToClear )
{
 4000720:	defffa04 	addi	sp,sp,-24
 4000724:	dfc00515 	stw	ra,20(sp)
 4000728:	df000415 	stw	fp,16(sp)
 400072c:	df000404 	addi	fp,sp,16
 4000730:	e13ffd15 	stw	r4,-12(fp)
 4000734:	e17ffc15 	stw	r5,-16(fp)
    EventGroup_t * pxEventBits = xEventGroup;
 4000738:	e0bffd17 	ldw	r2,-12(fp)
 400073c:	e0bfff15 	stw	r2,-4(fp)
    /* Check the user is not attempting to clear the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    taskENTER_CRITICAL();
 4000740:	4005f740 	call	4005f74 <vTaskEnterCritical>
    {
        traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

        /* The value returned is the event group value prior to the bits being
         * cleared. */
        uxReturn = pxEventBits->uxEventBits;
 4000744:	e0bfff17 	ldw	r2,-4(fp)
 4000748:	10800017 	ldw	r2,0(r2)
 400074c:	e0bffe15 	stw	r2,-8(fp)

        /* Clear the bits. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
 4000750:	e0bfff17 	ldw	r2,-4(fp)
 4000754:	10c00017 	ldw	r3,0(r2)
 4000758:	e0bffc17 	ldw	r2,-16(fp)
 400075c:	0084303a 	nor	r2,zero,r2
 4000760:	1886703a 	and	r3,r3,r2
 4000764:	e0bfff17 	ldw	r2,-4(fp)
 4000768:	10c00015 	stw	r3,0(r2)
    }
    taskEXIT_CRITICAL();
 400076c:	4005fc80 	call	4005fc8 <vTaskExitCritical>

    return uxReturn;
 4000770:	e0bffe17 	ldw	r2,-8(fp)
}
 4000774:	e037883a 	mov	sp,fp
 4000778:	dfc00117 	ldw	ra,4(sp)
 400077c:	df000017 	ldw	fp,0(sp)
 4000780:	dec00204 	addi	sp,sp,8
 4000784:	f800283a 	ret

04000788 <xEventGroupGetBitsFromISR>:

#endif /* if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) ) */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
 4000788:	defffb04 	addi	sp,sp,-20
 400078c:	df000415 	stw	fp,16(sp)
 4000790:	df000404 	addi	fp,sp,16
 4000794:	e13ffc15 	stw	r4,-16(fp)
    UBaseType_t uxSavedInterruptStatus;
    EventGroup_t const * const pxEventBits = xEventGroup;
 4000798:	e0bffc17 	ldw	r2,-16(fp)
 400079c:	e0bfff15 	stw	r2,-4(fp)
    EventBits_t uxReturn;

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 40007a0:	e03ffe15 	stw	zero,-8(fp)
    {
        uxReturn = pxEventBits->uxEventBits;
 40007a4:	e0bfff17 	ldw	r2,-4(fp)
 40007a8:	10800017 	ldw	r2,0(r2)
 40007ac:	e0bffd15 	stw	r2,-12(fp)
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return uxReturn;
 40007b0:	e0bffd17 	ldw	r2,-12(fp)
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
 40007b4:	e037883a 	mov	sp,fp
 40007b8:	df000017 	ldw	fp,0(sp)
 40007bc:	dec00104 	addi	sp,sp,4
 40007c0:	f800283a 	ret

040007c4 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet )
{
 40007c4:	defff304 	addi	sp,sp,-52
 40007c8:	dfc00c15 	stw	ra,48(sp)
 40007cc:	df000b15 	stw	fp,44(sp)
 40007d0:	df000b04 	addi	fp,sp,44
 40007d4:	e13ff615 	stw	r4,-40(fp)
 40007d8:	e17ff515 	stw	r5,-44(fp)
    ListItem_t * pxListItem;
    ListItem_t * pxNext;
    ListItem_t const * pxListEnd;
    List_t const * pxList;
    EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
 40007dc:	e03ffe15 	stw	zero,-8(fp)
    EventGroup_t * pxEventBits = xEventGroup;
 40007e0:	e0bff617 	ldw	r2,-40(fp)
 40007e4:	e0bffc15 	stw	r2,-16(fp)
    BaseType_t xMatchFound = pdFALSE;
 40007e8:	e03ffd15 	stw	zero,-12(fp)
    /* Check the user is not attempting to set the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    pxList = &( pxEventBits->xTasksWaitingForBits );
 40007ec:	e0bffc17 	ldw	r2,-16(fp)
 40007f0:	10800104 	addi	r2,r2,4
 40007f4:	e0bffb15 	stw	r2,-20(fp)
    pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 40007f8:	e0bffb17 	ldw	r2,-20(fp)
 40007fc:	10800204 	addi	r2,r2,8
 4000800:	e0bffa15 	stw	r2,-24(fp)
    vTaskSuspendAll();
 4000804:	40046e80 	call	40046e8 <vTaskSuspendAll>
    {
        traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

        pxListItem = listGET_HEAD_ENTRY( pxList );
 4000808:	e0bffb17 	ldw	r2,-20(fp)
 400080c:	10800317 	ldw	r2,12(r2)
 4000810:	e0bfff15 	stw	r2,-4(fp)

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;
 4000814:	e0bffc17 	ldw	r2,-16(fp)
 4000818:	10c00017 	ldw	r3,0(r2)
 400081c:	e0bff517 	ldw	r2,-44(fp)
 4000820:	1886b03a 	or	r3,r3,r2
 4000824:	e0bffc17 	ldw	r2,-16(fp)
 4000828:	10c00015 	stw	r3,0(r2)

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
 400082c:	00003306 	br	40008fc <xEventGroupSetBits+0x138>
        {
            pxNext = listGET_NEXT( pxListItem );
 4000830:	e0bfff17 	ldw	r2,-4(fp)
 4000834:	10800117 	ldw	r2,4(r2)
 4000838:	e0bff915 	stw	r2,-28(fp)
            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
 400083c:	e0bfff17 	ldw	r2,-4(fp)
 4000840:	10800017 	ldw	r2,0(r2)
 4000844:	e0bff815 	stw	r2,-32(fp)
            xMatchFound = pdFALSE;
 4000848:	e03ffd15 	stw	zero,-12(fp)

            /* Split the bits waited for from the control bits. */
            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
 400084c:	e0bff817 	ldw	r2,-32(fp)
 4000850:	10bfc02c 	andhi	r2,r2,65280
 4000854:	e0bff715 	stw	r2,-36(fp)
            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
 4000858:	e0fff817 	ldw	r3,-32(fp)
 400085c:	00804034 	movhi	r2,256
 4000860:	10bfffc4 	addi	r2,r2,-1
 4000864:	1884703a 	and	r2,r3,r2
 4000868:	e0bff815 	stw	r2,-32(fp)

            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
 400086c:	e0bff717 	ldw	r2,-36(fp)
 4000870:	1081002c 	andhi	r2,r2,1024
 4000874:	1000081e 	bne	r2,zero,4000898 <xEventGroupSetBits+0xd4>
            {
                /* Just looking for single bit being set. */
                if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
 4000878:	e0bffc17 	ldw	r2,-16(fp)
 400087c:	10c00017 	ldw	r3,0(r2)
 4000880:	e0bff817 	ldw	r2,-32(fp)
 4000884:	1884703a 	and	r2,r3,r2
 4000888:	10000b26 	beq	r2,zero,40008b8 <xEventGroupSetBits+0xf4>
                {
                    xMatchFound = pdTRUE;
 400088c:	00800044 	movi	r2,1
 4000890:	e0bffd15 	stw	r2,-12(fp)
 4000894:	00000806 	br	40008b8 <xEventGroupSetBits+0xf4>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
 4000898:	e0bffc17 	ldw	r2,-16(fp)
 400089c:	10c00017 	ldw	r3,0(r2)
 40008a0:	e0bff817 	ldw	r2,-32(fp)
 40008a4:	1884703a 	and	r2,r3,r2
 40008a8:	e0fff817 	ldw	r3,-32(fp)
 40008ac:	1880021e 	bne	r3,r2,40008b8 <xEventGroupSetBits+0xf4>
            {
                /* All bits are set. */
                xMatchFound = pdTRUE;
 40008b0:	00800044 	movi	r2,1
 40008b4:	e0bffd15 	stw	r2,-12(fp)
            else
            {
                /* Need all bits to be set, but not all the bits were set. */
            }

            if( xMatchFound != pdFALSE )
 40008b8:	e0bffd17 	ldw	r2,-12(fp)
 40008bc:	10000d26 	beq	r2,zero,40008f4 <xEventGroupSetBits+0x130>
            {
                /* The bits match.  Should the bits be cleared on exit? */
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
 40008c0:	e0bff717 	ldw	r2,-36(fp)
 40008c4:	1080402c 	andhi	r2,r2,256
 40008c8:	10000426 	beq	r2,zero,40008dc <xEventGroupSetBits+0x118>
                {
                    uxBitsToClear |= uxBitsWaitedFor;
 40008cc:	e0fffe17 	ldw	r3,-8(fp)
 40008d0:	e0bff817 	ldw	r2,-32(fp)
 40008d4:	1884b03a 	or	r2,r3,r2
 40008d8:	e0bffe15 	stw	r2,-8(fp)
                /* Store the actual event flag value in the task's event list
                 * item before removing the task from the event list.  The
                 * eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
                 * that is was unblocked due to its required bits matching, rather
                 * than because it timed out. */
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
 40008dc:	e0bffc17 	ldw	r2,-16(fp)
 40008e0:	10800017 	ldw	r2,0(r2)
 40008e4:	10808034 	orhi	r2,r2,512
 40008e8:	100b883a 	mov	r5,r2
 40008ec:	e13fff17 	ldw	r4,-4(fp)
 40008f0:	40052f40 	call	40052f4 <vTaskRemoveFromUnorderedEventList>
            }

            /* Move onto the next list item.  Note pxListItem->pxNext is not
             * used here as the list item may have been removed from the event list
             * and inserted into the ready/pending reading list. */
            pxListItem = pxNext;
 40008f4:	e0bff917 	ldw	r2,-28(fp)
 40008f8:	e0bfff15 	stw	r2,-4(fp)
        while( pxListItem != pxListEnd )
 40008fc:	e0ffff17 	ldw	r3,-4(fp)
 4000900:	e0bffa17 	ldw	r2,-24(fp)
 4000904:	18bfca1e 	bne	r3,r2,4000830 <xEventGroupSetBits+0x6c>
        }

        /* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
         * bit was set in the control word. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
 4000908:	e0bffc17 	ldw	r2,-16(fp)
 400090c:	10c00017 	ldw	r3,0(r2)
 4000910:	e0bffe17 	ldw	r2,-8(fp)
 4000914:	0084303a 	nor	r2,zero,r2
 4000918:	1886703a 	and	r3,r3,r2
 400091c:	e0bffc17 	ldw	r2,-16(fp)
 4000920:	10c00015 	stw	r3,0(r2)
    }
    ( void ) xTaskResumeAll();
 4000924:	40047140 	call	4004714 <xTaskResumeAll>

    return pxEventBits->uxEventBits;
 4000928:	e0bffc17 	ldw	r2,-16(fp)
 400092c:	10800017 	ldw	r2,0(r2)
}
 4000930:	e037883a 	mov	sp,fp
 4000934:	dfc00117 	ldw	ra,4(sp)
 4000938:	df000017 	ldw	fp,0(sp)
 400093c:	dec00204 	addi	sp,sp,8
 4000940:	f800283a 	ret

04000944 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
 4000944:	defffb04 	addi	sp,sp,-20
 4000948:	dfc00415 	stw	ra,16(sp)
 400094c:	df000315 	stw	fp,12(sp)
 4000950:	df000304 	addi	fp,sp,12
 4000954:	e13ffd15 	stw	r4,-12(fp)
    EventGroup_t * pxEventBits = xEventGroup;
 4000958:	e0bffd17 	ldw	r2,-12(fp)
 400095c:	e0bfff15 	stw	r2,-4(fp)
    const List_t * pxTasksWaitingForBits;

    configASSERT( pxEventBits );

    pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
 4000960:	e0bfff17 	ldw	r2,-4(fp)
 4000964:	10800104 	addi	r2,r2,4
 4000968:	e0bffe15 	stw	r2,-8(fp)

    vTaskSuspendAll();
 400096c:	40046e80 	call	40046e8 <vTaskSuspendAll>
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
 4000970:	00000506 	br	4000988 <vEventGroupDelete+0x44>
        {
            /* Unblock the task, returning 0 as the event list is being deleted
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
 4000974:	e0bffe17 	ldw	r2,-8(fp)
 4000978:	10800317 	ldw	r2,12(r2)
 400097c:	01408034 	movhi	r5,512
 4000980:	1009883a 	mov	r4,r2
 4000984:	40052f40 	call	40052f4 <vTaskRemoveFromUnorderedEventList>
        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
 4000988:	e0bffe17 	ldw	r2,-8(fp)
 400098c:	10800017 	ldw	r2,0(r2)
 4000990:	103ff81e 	bne	r2,zero,4000974 <vEventGroupDelete+0x30>
        }
    }
    ( void ) xTaskResumeAll();
 4000994:	40047140 	call	4004714 <xTaskResumeAll>

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
    {
        /* The event group can only have been allocated dynamically - free
         * it again. */
        vPortFree( pxEventBits );
 4000998:	e13fff17 	ldw	r4,-4(fp)
 400099c:	400111c0 	call	400111c <vPortFree>
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
 40009a0:	0001883a 	nop
 40009a4:	e037883a 	mov	sp,fp
 40009a8:	dfc00117 	ldw	ra,4(sp)
 40009ac:	df000017 	ldw	fp,0(sp)
 40009b0:	dec00204 	addi	sp,sp,8
 40009b4:	f800283a 	ret

040009b8 <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
 * an interrupt. */
void vEventGroupSetBitsCallback( void * pvEventGroup,
                                 const uint32_t ulBitsToSet )
{
 40009b8:	defffc04 	addi	sp,sp,-16
 40009bc:	dfc00315 	stw	ra,12(sp)
 40009c0:	df000215 	stw	fp,8(sp)
 40009c4:	df000204 	addi	fp,sp,8
 40009c8:	e13fff15 	stw	r4,-4(fp)
 40009cc:	e17ffe15 	stw	r5,-8(fp)
    ( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
 40009d0:	e17ffe17 	ldw	r5,-8(fp)
 40009d4:	e13fff17 	ldw	r4,-4(fp)
 40009d8:	40007c40 	call	40007c4 <xEventGroupSetBits>
}
 40009dc:	0001883a 	nop
 40009e0:	e037883a 	mov	sp,fp
 40009e4:	dfc00117 	ldw	ra,4(sp)
 40009e8:	df000017 	ldw	fp,0(sp)
 40009ec:	dec00204 	addi	sp,sp,8
 40009f0:	f800283a 	ret

040009f4 <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
 * an interrupt. */
void vEventGroupClearBitsCallback( void * pvEventGroup,
                                   const uint32_t ulBitsToClear )
{
 40009f4:	defffc04 	addi	sp,sp,-16
 40009f8:	dfc00315 	stw	ra,12(sp)
 40009fc:	df000215 	stw	fp,8(sp)
 4000a00:	df000204 	addi	fp,sp,8
 4000a04:	e13fff15 	stw	r4,-4(fp)
 4000a08:	e17ffe15 	stw	r5,-8(fp)
    ( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
 4000a0c:	e17ffe17 	ldw	r5,-8(fp)
 4000a10:	e13fff17 	ldw	r4,-4(fp)
 4000a14:	40007200 	call	4000720 <xEventGroupClearBits>
}
 4000a18:	0001883a 	nop
 4000a1c:	e037883a 	mov	sp,fp
 4000a20:	dfc00117 	ldw	ra,4(sp)
 4000a24:	df000017 	ldw	fp,0(sp)
 4000a28:	dec00204 	addi	sp,sp,8
 4000a2c:	f800283a 	ret

04000a30 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits,
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
 4000a30:	defffb04 	addi	sp,sp,-20
 4000a34:	df000415 	stw	fp,16(sp)
 4000a38:	df000404 	addi	fp,sp,16
 4000a3c:	e13ffe15 	stw	r4,-8(fp)
 4000a40:	e17ffd15 	stw	r5,-12(fp)
 4000a44:	e1bffc15 	stw	r6,-16(fp)
    BaseType_t xWaitConditionMet = pdFALSE;
 4000a48:	e03fff15 	stw	zero,-4(fp)

    if( xWaitForAllBits == pdFALSE )
 4000a4c:	e0bffc17 	ldw	r2,-16(fp)
 4000a50:	1000071e 	bne	r2,zero,4000a70 <prvTestWaitCondition+0x40>
    {
        /* Task only has to wait for one bit within uxBitsToWaitFor to be
         * set.  Is one already set? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
 4000a54:	e0fffe17 	ldw	r3,-8(fp)
 4000a58:	e0bffd17 	ldw	r2,-12(fp)
 4000a5c:	1884703a 	and	r2,r3,r2
 4000a60:	10000a26 	beq	r2,zero,4000a8c <prvTestWaitCondition+0x5c>
        {
            xWaitConditionMet = pdTRUE;
 4000a64:	00800044 	movi	r2,1
 4000a68:	e0bfff15 	stw	r2,-4(fp)
 4000a6c:	00000706 	br	4000a8c <prvTestWaitCondition+0x5c>
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
 4000a70:	e0fffe17 	ldw	r3,-8(fp)
 4000a74:	e0bffd17 	ldw	r2,-12(fp)
 4000a78:	1884703a 	and	r2,r3,r2
 4000a7c:	e0fffd17 	ldw	r3,-12(fp)
 4000a80:	1880021e 	bne	r3,r2,4000a8c <prvTestWaitCondition+0x5c>
        {
            xWaitConditionMet = pdTRUE;
 4000a84:	00800044 	movi	r2,1
 4000a88:	e0bfff15 	stw	r2,-4(fp)
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    return xWaitConditionMet;
 4000a8c:	e0bfff17 	ldw	r2,-4(fp)
}
 4000a90:	e037883a 	mov	sp,fp
 4000a94:	df000017 	ldw	fp,0(sp)
 4000a98:	dec00104 	addi	sp,sp,4
 4000a9c:	f800283a 	ret

04000aa0 <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 4000aa0:	defffe04 	addi	sp,sp,-8
 4000aa4:	df000115 	stw	fp,4(sp)
 4000aa8:	df000104 	addi	fp,sp,4
 4000aac:	e13fff15 	stw	r4,-4(fp)
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 4000ab0:	e0bfff17 	ldw	r2,-4(fp)
 4000ab4:	10c00204 	addi	r3,r2,8
 4000ab8:	e0bfff17 	ldw	r2,-4(fp)
 4000abc:	10c00115 	stw	r3,4(r2)

    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
 4000ac0:	e0bfff17 	ldw	r2,-4(fp)
 4000ac4:	00ffffc4 	movi	r3,-1
 4000ac8:	10c00215 	stw	r3,8(r2)

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 4000acc:	e0bfff17 	ldw	r2,-4(fp)
 4000ad0:	10c00204 	addi	r3,r2,8
 4000ad4:	e0bfff17 	ldw	r2,-4(fp)
 4000ad8:	10c00315 	stw	r3,12(r2)
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 4000adc:	e0bfff17 	ldw	r2,-4(fp)
 4000ae0:	10c00204 	addi	r3,r2,8
 4000ae4:	e0bfff17 	ldw	r2,-4(fp)
 4000ae8:	10c00415 	stw	r3,16(r2)
        pxList->xListEnd.pxContainer = NULL;
        listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );
    }
    #endif

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 4000aec:	e0bfff17 	ldw	r2,-4(fp)
 4000af0:	10000015 	stw	zero,0(r2)

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 4000af4:	0001883a 	nop
 4000af8:	e037883a 	mov	sp,fp
 4000afc:	df000017 	ldw	fp,0(sp)
 4000b00:	dec00104 	addi	sp,sp,4
 4000b04:	f800283a 	ret

04000b08 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
 4000b08:	defffe04 	addi	sp,sp,-8
 4000b0c:	df000115 	stw	fp,4(sp)
 4000b10:	df000104 	addi	fp,sp,4
 4000b14:	e13fff15 	stw	r4,-4(fp)
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
 4000b18:	e0bfff17 	ldw	r2,-4(fp)
 4000b1c:	10000415 	stw	zero,16(r2)

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 4000b20:	0001883a 	nop
 4000b24:	e037883a 	mov	sp,fp
 4000b28:	df000017 	ldw	fp,0(sp)
 4000b2c:	dec00104 	addi	sp,sp,4
 4000b30:	f800283a 	ret

04000b34 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
 4000b34:	defffc04 	addi	sp,sp,-16
 4000b38:	df000315 	stw	fp,12(sp)
 4000b3c:	df000304 	addi	fp,sp,12
 4000b40:	e13ffe15 	stw	r4,-8(fp)
 4000b44:	e17ffd15 	stw	r5,-12(fp)
    ListItem_t * const pxIndex = pxList->pxIndex;
 4000b48:	e0bffe17 	ldw	r2,-8(fp)
 4000b4c:	10800117 	ldw	r2,4(r2)
 4000b50:	e0bfff15 	stw	r2,-4(fp)
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
 4000b54:	e0bffd17 	ldw	r2,-12(fp)
 4000b58:	e0ffff17 	ldw	r3,-4(fp)
 4000b5c:	10c00115 	stw	r3,4(r2)
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 4000b60:	e0bfff17 	ldw	r2,-4(fp)
 4000b64:	10c00217 	ldw	r3,8(r2)
 4000b68:	e0bffd17 	ldw	r2,-12(fp)
 4000b6c:	10c00215 	stw	r3,8(r2)

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
 4000b70:	e0bfff17 	ldw	r2,-4(fp)
 4000b74:	10800217 	ldw	r2,8(r2)
 4000b78:	e0fffd17 	ldw	r3,-12(fp)
 4000b7c:	10c00115 	stw	r3,4(r2)
    pxIndex->pxPrevious = pxNewListItem;
 4000b80:	e0bfff17 	ldw	r2,-4(fp)
 4000b84:	e0fffd17 	ldw	r3,-12(fp)
 4000b88:	10c00215 	stw	r3,8(r2)

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
 4000b8c:	e0bffd17 	ldw	r2,-12(fp)
 4000b90:	e0fffe17 	ldw	r3,-8(fp)
 4000b94:	10c00415 	stw	r3,16(r2)

    ( pxList->uxNumberOfItems )++;
 4000b98:	e0bffe17 	ldw	r2,-8(fp)
 4000b9c:	10800017 	ldw	r2,0(r2)
 4000ba0:	10c00044 	addi	r3,r2,1
 4000ba4:	e0bffe17 	ldw	r2,-8(fp)
 4000ba8:	10c00015 	stw	r3,0(r2)
}
 4000bac:	0001883a 	nop
 4000bb0:	e037883a 	mov	sp,fp
 4000bb4:	df000017 	ldw	fp,0(sp)
 4000bb8:	dec00104 	addi	sp,sp,4
 4000bbc:	f800283a 	ret

04000bc0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
 4000bc0:	defffb04 	addi	sp,sp,-20
 4000bc4:	df000415 	stw	fp,16(sp)
 4000bc8:	df000404 	addi	fp,sp,16
 4000bcc:	e13ffd15 	stw	r4,-12(fp)
 4000bd0:	e17ffc15 	stw	r5,-16(fp)
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 4000bd4:	e0bffc17 	ldw	r2,-16(fp)
 4000bd8:	10800017 	ldw	r2,0(r2)
 4000bdc:	e0bffe15 	stw	r2,-8(fp)
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
 4000be0:	e0bffe17 	ldw	r2,-8(fp)
 4000be4:	10bfffd8 	cmpnei	r2,r2,-1
 4000be8:	1000041e 	bne	r2,zero,4000bfc <vListInsert+0x3c>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
 4000bec:	e0bffd17 	ldw	r2,-12(fp)
 4000bf0:	10800417 	ldw	r2,16(r2)
 4000bf4:	e0bfff15 	stw	r2,-4(fp)
 4000bf8:	00000c06 	br	4000c2c <vListInsert+0x6c>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 4000bfc:	e0bffd17 	ldw	r2,-12(fp)
 4000c00:	10800204 	addi	r2,r2,8
 4000c04:	e0bfff15 	stw	r2,-4(fp)
 4000c08:	00000306 	br	4000c18 <vListInsert+0x58>
 4000c0c:	e0bfff17 	ldw	r2,-4(fp)
 4000c10:	10800117 	ldw	r2,4(r2)
 4000c14:	e0bfff15 	stw	r2,-4(fp)
 4000c18:	e0bfff17 	ldw	r2,-4(fp)
 4000c1c:	10800117 	ldw	r2,4(r2)
 4000c20:	10800017 	ldw	r2,0(r2)
 4000c24:	e0fffe17 	ldw	r3,-8(fp)
 4000c28:	18bff82e 	bgeu	r3,r2,4000c0c <vListInsert+0x4c>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
 4000c2c:	e0bfff17 	ldw	r2,-4(fp)
 4000c30:	10c00117 	ldw	r3,4(r2)
 4000c34:	e0bffc17 	ldw	r2,-16(fp)
 4000c38:	10c00115 	stw	r3,4(r2)
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 4000c3c:	e0bffc17 	ldw	r2,-16(fp)
 4000c40:	10800117 	ldw	r2,4(r2)
 4000c44:	e0fffc17 	ldw	r3,-16(fp)
 4000c48:	10c00215 	stw	r3,8(r2)
    pxNewListItem->pxPrevious = pxIterator;
 4000c4c:	e0bffc17 	ldw	r2,-16(fp)
 4000c50:	e0ffff17 	ldw	r3,-4(fp)
 4000c54:	10c00215 	stw	r3,8(r2)
    pxIterator->pxNext = pxNewListItem;
 4000c58:	e0bfff17 	ldw	r2,-4(fp)
 4000c5c:	e0fffc17 	ldw	r3,-16(fp)
 4000c60:	10c00115 	stw	r3,4(r2)

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
 4000c64:	e0bffc17 	ldw	r2,-16(fp)
 4000c68:	e0fffd17 	ldw	r3,-12(fp)
 4000c6c:	10c00415 	stw	r3,16(r2)

    ( pxList->uxNumberOfItems )++;
 4000c70:	e0bffd17 	ldw	r2,-12(fp)
 4000c74:	10800017 	ldw	r2,0(r2)
 4000c78:	10c00044 	addi	r3,r2,1
 4000c7c:	e0bffd17 	ldw	r2,-12(fp)
 4000c80:	10c00015 	stw	r3,0(r2)
}
 4000c84:	0001883a 	nop
 4000c88:	e037883a 	mov	sp,fp
 4000c8c:	df000017 	ldw	fp,0(sp)
 4000c90:	dec00104 	addi	sp,sp,4
 4000c94:	f800283a 	ret

04000c98 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 4000c98:	defffd04 	addi	sp,sp,-12
 4000c9c:	df000215 	stw	fp,8(sp)
 4000ca0:	df000204 	addi	fp,sp,8
 4000ca4:	e13ffe15 	stw	r4,-8(fp)
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
 4000ca8:	e0bffe17 	ldw	r2,-8(fp)
 4000cac:	10800417 	ldw	r2,16(r2)
 4000cb0:	e0bfff15 	stw	r2,-4(fp)

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 4000cb4:	e0bffe17 	ldw	r2,-8(fp)
 4000cb8:	10800117 	ldw	r2,4(r2)
 4000cbc:	e0fffe17 	ldw	r3,-8(fp)
 4000cc0:	18c00217 	ldw	r3,8(r3)
 4000cc4:	10c00215 	stw	r3,8(r2)
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 4000cc8:	e0bffe17 	ldw	r2,-8(fp)
 4000ccc:	10800217 	ldw	r2,8(r2)
 4000cd0:	e0fffe17 	ldw	r3,-8(fp)
 4000cd4:	18c00117 	ldw	r3,4(r3)
 4000cd8:	10c00115 	stw	r3,4(r2)

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
 4000cdc:	e0bfff17 	ldw	r2,-4(fp)
 4000ce0:	10800117 	ldw	r2,4(r2)
 4000ce4:	e0fffe17 	ldw	r3,-8(fp)
 4000ce8:	1880041e 	bne	r3,r2,4000cfc <uxListRemove+0x64>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
 4000cec:	e0bffe17 	ldw	r2,-8(fp)
 4000cf0:	10c00217 	ldw	r3,8(r2)
 4000cf4:	e0bfff17 	ldw	r2,-4(fp)
 4000cf8:	10c00115 	stw	r3,4(r2)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
 4000cfc:	e0bffe17 	ldw	r2,-8(fp)
 4000d00:	10000415 	stw	zero,16(r2)
    ( pxList->uxNumberOfItems )--;
 4000d04:	e0bfff17 	ldw	r2,-4(fp)
 4000d08:	10800017 	ldw	r2,0(r2)
 4000d0c:	10ffffc4 	addi	r3,r2,-1
 4000d10:	e0bfff17 	ldw	r2,-4(fp)
 4000d14:	10c00015 	stw	r3,0(r2)

    return pxList->uxNumberOfItems;
 4000d18:	e0bfff17 	ldw	r2,-4(fp)
 4000d1c:	10800017 	ldw	r2,0(r2)
}
 4000d20:	e037883a 	mov	sp,fp
 4000d24:	df000017 	ldw	fp,0(sp)
 4000d28:	dec00104 	addi	sp,sp,4
 4000d2c:	f800283a 	ret

04000d30 <prvReadGp>:
void vPortSysTickHandler( void * context);

/*-----------------------------------------------------------*/

static void prvReadGp( uint32_t *ulValue )
{
 4000d30:	defffe04 	addi	sp,sp,-8
 4000d34:	df000115 	stw	fp,4(sp)
 4000d38:	df000104 	addi	fp,sp,4
 4000d3c:	e13fff15 	stw	r4,-4(fp)
	asm( "stw gp, (%0)" :: "r"(ulValue) );
 4000d40:	e0bfff17 	ldw	r2,-4(fp)
 4000d44:	16800015 	stw	gp,0(r2)
}
 4000d48:	0001883a 	nop
 4000d4c:	e037883a 	mov	sp,fp
 4000d50:	df000017 	ldw	fp,0(sp)
 4000d54:	dec00104 	addi	sp,sp,4
 4000d58:	f800283a 	ret

04000d5c <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{    
 4000d5c:	defff904 	addi	sp,sp,-28
 4000d60:	dfc00615 	stw	ra,24(sp)
 4000d64:	df000515 	stw	fp,20(sp)
 4000d68:	df000504 	addi	fp,sp,20
 4000d6c:	e13ffd15 	stw	r4,-12(fp)
 4000d70:	e17ffc15 	stw	r5,-16(fp)
 4000d74:	e1bffb15 	stw	r6,-20(fp)
StackType_t *pxFramePointer = pxTopOfStack - 1;
 4000d78:	e0bffd17 	ldw	r2,-12(fp)
 4000d7c:	10bfff04 	addi	r2,r2,-4
 4000d80:	e0bfff15 	stw	r2,-4(fp)
StackType_t xGlobalPointer;

    prvReadGp( &xGlobalPointer ); 
 4000d84:	e0bffe04 	addi	r2,fp,-8
 4000d88:	1009883a 	mov	r4,r2
 4000d8c:	4000d300 	call	4000d30 <prvReadGp>

    /* End of stack marker. */
    *pxTopOfStack = 0xdeadbeef;
 4000d90:	e0fffd17 	ldw	r3,-12(fp)
 4000d94:	00b7abb4 	movhi	r2,57006
 4000d98:	10afbbc4 	addi	r2,r2,-16657
 4000d9c:	18800015 	stw	r2,0(r3)
    pxTopOfStack--;
 4000da0:	e0bffd17 	ldw	r2,-12(fp)
 4000da4:	10bfff04 	addi	r2,r2,-4
 4000da8:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = ( StackType_t ) pxFramePointer; 
 4000dac:	e0ffff17 	ldw	r3,-4(fp)
 4000db0:	e0bffd17 	ldw	r2,-12(fp)
 4000db4:	10c00015 	stw	r3,0(r2)
    pxTopOfStack--;
 4000db8:	e0bffd17 	ldw	r2,-12(fp)
 4000dbc:	10bfff04 	addi	r2,r2,-4
 4000dc0:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = xGlobalPointer; 
 4000dc4:	e0fffe17 	ldw	r3,-8(fp)
 4000dc8:	e0bffd17 	ldw	r2,-12(fp)
 4000dcc:	10c00015 	stw	r3,0(r2)
    
    /* Space for R23 to R16. */
    pxTopOfStack -= 9;
 4000dd0:	e0bffd17 	ldw	r2,-12(fp)
 4000dd4:	10bff704 	addi	r2,r2,-36
 4000dd8:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = ( StackType_t ) pxCode; 
 4000ddc:	e0fffc17 	ldw	r3,-16(fp)
 4000de0:	e0bffd17 	ldw	r2,-12(fp)
 4000de4:	10c00015 	stw	r3,0(r2)
    pxTopOfStack--;
 4000de8:	e0bffd17 	ldw	r2,-12(fp)
 4000dec:	10bfff04 	addi	r2,r2,-4
 4000df0:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = portINITIAL_ESTATUS; 
 4000df4:	e0bffd17 	ldw	r2,-12(fp)
 4000df8:	00c00044 	movi	r3,1
 4000dfc:	10c00015 	stw	r3,0(r2)

    /* Space for R15 to R5. */    
    pxTopOfStack -= 12;
 4000e00:	e0bffd17 	ldw	r2,-12(fp)
 4000e04:	10bff404 	addi	r2,r2,-48
 4000e08:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = ( StackType_t ) pvParameters; 
 4000e0c:	e0fffb17 	ldw	r3,-20(fp)
 4000e10:	e0bffd17 	ldw	r2,-12(fp)
 4000e14:	10c00015 	stw	r3,0(r2)

    /* Space for R3 to R1, muldiv and RA. */
    pxTopOfStack -= 5;
 4000e18:	e0bffd17 	ldw	r2,-12(fp)
 4000e1c:	10bffb04 	addi	r2,r2,-20
 4000e20:	e0bffd15 	stw	r2,-12(fp)
    
    return pxTopOfStack;
 4000e24:	e0bffd17 	ldw	r2,-12(fp)
}
 4000e28:	e037883a 	mov	sp,fp
 4000e2c:	dfc00117 	ldw	ra,4(sp)
 4000e30:	df000017 	ldw	fp,0(sp)
 4000e34:	dec00204 	addi	sp,sp,8
 4000e38:	f800283a 	ret

04000e3c <xPortStartScheduler>:

/* 
 * See header file for description. 
 */
BaseType_t xPortStartScheduler( void )
{
 4000e3c:	defffe04 	addi	sp,sp,-8
 4000e40:	dfc00115 	stw	ra,4(sp)
 4000e44:	df000015 	stw	fp,0(sp)
 4000e48:	d839883a 	mov	fp,sp
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
 4000e4c:	4000e940 	call	4000e94 <prvSetupTimerInterrupt>
 4000e50:	00810034 	movhi	r2,1024
	
	/* Start the first task. */
    asm volatile (  " movia r2, restore_sp_from_pxCurrentTCB        \n"
 4000e54:	10805704 	addi	r2,r2,348
 4000e58:	1000683a 	jmp	r2
                    " jmp r2                                          " );

	/* Should not get here! */
	return 0;
 4000e5c:	0005883a 	mov	r2,zero
}
 4000e60:	e037883a 	mov	sp,fp
 4000e64:	dfc00117 	ldw	ra,4(sp)
 4000e68:	df000017 	ldw	fp,0(sp)
 4000e6c:	dec00204 	addi	sp,sp,8
 4000e70:	f800283a 	ret

04000e74 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 4000e74:	deffff04 	addi	sp,sp,-4
 4000e78:	df000015 	stw	fp,0(sp)
 4000e7c:	d839883a 	mov	fp,sp
	/* It is unlikely that the NIOS2 port will require this function as there
	is nothing to return to.  */
}
 4000e80:	0001883a 	nop
 4000e84:	e037883a 	mov	sp,fp
 4000e88:	df000017 	ldw	fp,0(sp)
 4000e8c:	dec00104 	addi	sp,sp,4
 4000e90:	f800283a 	ret

04000e94 <prvSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
 4000e94:	defffd04 	addi	sp,sp,-12
 4000e98:	dfc00215 	stw	ra,8(sp)
 4000e9c:	df000115 	stw	fp,4(sp)
 4000ea0:	df000104 	addi	fp,sp,4
	/* Try to register the interrupt handler. */
	if ( -EINVAL == _alt_ic_isr_register( SYS_CLK_IRQ_INTERRUPT_CONTROLLER_ID, SYS_CLK_IRQ, vPortSysTickHandler, 0x0, 0x0 ) )
 4000ea4:	d8000015 	stw	zero,0(sp)
 4000ea8:	000f883a 	mov	r7,zero
 4000eac:	01810034 	movhi	r6,1024
 4000eb0:	3183c904 	addi	r6,r6,3876
 4000eb4:	01400084 	movi	r5,2
 4000eb8:	0009883a 	mov	r4,zero
 4000ebc:	4000f680 	call	4000f68 <_alt_ic_isr_register>
 4000ec0:	10bffa98 	cmpnei	r2,r2,-22
 4000ec4:	1000021e 	bne	r2,zero,4000ed0 <prvSetupTimerInterrupt+0x3c>
	{ 
		/* Failed to install the Interrupt Handler. */
		asm( "break" );
 4000ec8:	003da03a 	break	0
 4000ecc:	00000c06 	br	4000f00 <prvSetupTimerInterrupt+0x6c>
	}
	else
	{
		/* Configure SysTick to interrupt at the requested rate. */
		IOWR_ALTERA_AVALON_TIMER_CONTROL( SYS_CLK_BASE, ALTERA_AVALON_TIMER_CONTROL_STOP_MSK );
 4000ed0:	00c00204 	movi	r3,8
 4000ed4:	00820034 	movhi	r2,2048
 4000ed8:	10c40135 	stwio	r3,4100(r2)
		IOWR_ALTERA_AVALON_TIMER_PERIODL( SYS_CLK_BASE, ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) & 0xFFFF );
 4000edc:	00e1a814 	movui	r3,34464
 4000ee0:	00820034 	movhi	r2,2048
 4000ee4:	10c40235 	stwio	r3,4104(r2)
		IOWR_ALTERA_AVALON_TIMER_PERIODH( SYS_CLK_BASE, ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) >> 16 );
 4000ee8:	00c00044 	movi	r3,1
 4000eec:	00820034 	movhi	r2,2048
 4000ef0:	10c40335 	stwio	r3,4108(r2)
		IOWR_ALTERA_AVALON_TIMER_CONTROL( SYS_CLK_BASE, ALTERA_AVALON_TIMER_CONTROL_CONT_MSK | ALTERA_AVALON_TIMER_CONTROL_START_MSK | ALTERA_AVALON_TIMER_CONTROL_ITO_MSK );	
 4000ef4:	00c001c4 	movi	r3,7
 4000ef8:	00820034 	movhi	r2,2048
 4000efc:	10c40135 	stwio	r3,4100(r2)
	} 

	/* Clear any already pending interrupts generated by the Timer. */
	IOWR_ALTERA_AVALON_TIMER_STATUS( SYS_CLK_BASE, ~ALTERA_AVALON_TIMER_STATUS_TO_MSK );
 4000f00:	00ffff84 	movi	r3,-2
 4000f04:	00820034 	movhi	r2,2048
 4000f08:	10c40035 	stwio	r3,4096(r2)
}
 4000f0c:	0001883a 	nop
 4000f10:	e037883a 	mov	sp,fp
 4000f14:	dfc00117 	ldw	ra,4(sp)
 4000f18:	df000017 	ldw	fp,0(sp)
 4000f1c:	dec00204 	addi	sp,sp,8
 4000f20:	f800283a 	ret

04000f24 <vPortSysTickHandler>:
/*-----------------------------------------------------------*/

void vPortSysTickHandler( void * context)
{
 4000f24:	defffd04 	addi	sp,sp,-12
 4000f28:	dfc00215 	stw	ra,8(sp)
 4000f2c:	df000115 	stw	fp,4(sp)
 4000f30:	df000104 	addi	fp,sp,4
 4000f34:	e13fff15 	stw	r4,-4(fp)
	/* Increment the kernel tick. */
	if( xTaskIncrementTick() != pdFALSE )
 4000f38:	4004aec0 	call	4004aec <xTaskIncrementTick>
 4000f3c:	10000126 	beq	r2,zero,4000f44 <vPortSysTickHandler+0x20>
	{
        vTaskSwitchContext();
 4000f40:	4004e280 	call	4004e28 <vTaskSwitchContext>
	}
		
	/* Clear the interrupt. */
	IOWR_ALTERA_AVALON_TIMER_STATUS( SYS_CLK_BASE, ~ALTERA_AVALON_TIMER_STATUS_TO_MSK );
 4000f44:	00ffff84 	movi	r3,-2
 4000f48:	00820034 	movhi	r2,2048
 4000f4c:	10c40035 	stwio	r3,4096(r2)
}
 4000f50:	0001883a 	nop
 4000f54:	e037883a 	mov	sp,fp
 4000f58:	dfc00117 	ldw	ra,4(sp)
 4000f5c:	df000017 	ldw	fp,0(sp)
 4000f60:	dec00204 	addi	sp,sp,8
 4000f64:	f800283a 	ret

04000f68 <_alt_ic_isr_register>:
 * kernel has its scheduler started so that contexts are saved and switched 
 * correctly.
 */
int _alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr,
  void *isr_context, void *flags)
{
 4000f68:	defff604 	addi	sp,sp,-40
 4000f6c:	dfc00915 	stw	ra,36(sp)
 4000f70:	df000815 	stw	fp,32(sp)
 4000f74:	df000804 	addi	fp,sp,32
 4000f78:	e13ffb15 	stw	r4,-20(fp)
 4000f7c:	e17ffa15 	stw	r5,-24(fp)
 4000f80:	e1bff915 	stw	r6,-28(fp)
 4000f84:	e1fff815 	stw	r7,-32(fp)
	int rc = -EINVAL;  
 4000f88:	00bffa84 	movi	r2,-22
 4000f8c:	e0bfff15 	stw	r2,-4(fp)
	alt_irq_context status;
	int id = irq;             /* IRQ interpreted as the interrupt ID. */
 4000f90:	e0bffa17 	ldw	r2,-24(fp)
 4000f94:	e0bffe15 	stw	r2,-8(fp)

	if (id < ALT_NIRQ)
 4000f98:	e0bffe17 	ldw	r2,-8(fp)
 4000f9c:	10800808 	cmpgei	r2,r2,32
 4000fa0:	10001e1e 	bne	r2,zero,400101c <_alt_ic_isr_register+0xb4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 4000fa4:	0005303a 	rdctl	r2,status
 4000fa8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 4000fac:	e0fffc17 	ldw	r3,-16(fp)
 4000fb0:	00bfff84 	movi	r2,-2
 4000fb4:	1884703a 	and	r2,r3,r2
 4000fb8:	1001703a 	wrctl	status,r2
  
  return context;
 4000fbc:	e0bffc17 	ldw	r2,-16(fp)
		 * interrupts are disabled while the handler tables are updated to ensure
		 * that an interrupt doesn't occur while the tables are in an inconsistant
		 * state.
		 */
	
		status = alt_irq_disable_all ();
 4000fc0:	e0bffd15 	stw	r2,-12(fp)
	
		alt_irq[id].handler = isr;
 4000fc4:	e0bffe17 	ldw	r2,-8(fp)
 4000fc8:	100890fa 	slli	r4,r2,3
 4000fcc:	e0fff917 	ldw	r3,-28(fp)
 4000fd0:	008120b4 	movhi	r2,1154
 4000fd4:	2085883a 	add	r2,r4,r2
 4000fd8:	10faeb15 	stw	r3,-5204(r2)
		alt_irq[id].context = isr_context;
 4000fdc:	e0bffe17 	ldw	r2,-8(fp)
 4000fe0:	100890fa 	slli	r4,r2,3
 4000fe4:	e0fff817 	ldw	r3,-32(fp)
 4000fe8:	008120b4 	movhi	r2,1154
 4000fec:	2085883a 	add	r2,r4,r2
 4000ff0:	10faec15 	stw	r3,-5200(r2)
	
		rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
 4000ff4:	e0bff917 	ldw	r2,-28(fp)
 4000ff8:	10000426 	beq	r2,zero,400100c <_alt_ic_isr_register+0xa4>
 4000ffc:	e17ffe17 	ldw	r5,-8(fp)
 4001000:	e13ffb17 	ldw	r4,-20(fp)
 4001004:	4017f800 	call	4017f80 <alt_ic_irq_enable>
 4001008:	00000306 	br	4001018 <_alt_ic_isr_register+0xb0>
 400100c:	e17ffe17 	ldw	r5,-8(fp)
 4001010:	e13ffb17 	ldw	r4,-20(fp)
 4001014:	40180080 	call	4018008 <alt_ic_irq_disable>
 4001018:	e0bfff15 	stw	r2,-4(fp)
	
		/* alt_irq_enable_all(status); This line is removed to prevent the interrupt from being immediately enabled. */
	}
    
	return rc; 
 400101c:	e0bfff17 	ldw	r2,-4(fp)
}
 4001020:	e037883a 	mov	sp,fp
 4001024:	dfc00117 	ldw	ra,4(sp)
 4001028:	df000017 	ldw	fp,0(sp)
 400102c:	dec00204 	addi	sp,sp,8
 4001030:	f800283a 	ret

04001034 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
 4001034:	defffc04 	addi	sp,sp,-16
 4001038:	dfc00315 	stw	ra,12(sp)
 400103c:	df000215 	stw	fp,8(sp)
 4001040:	df000204 	addi	fp,sp,8
 4001044:	e13ffe15 	stw	r4,-8(fp)
    void * pvReturn = NULL;
 4001048:	e03fff15 	stw	zero,-4(fp)
    static uint8_t * pucAlignedHeap = NULL;

    /* Ensure that blocks are always aligned. */
    #if ( portBYTE_ALIGNMENT != 1 )
    {
        if( xWantedSize & portBYTE_ALIGNMENT_MASK )
 400104c:	e0bffe17 	ldw	r2,-8(fp)
 4001050:	108000cc 	andi	r2,r2,3
 4001054:	10000d26 	beq	r2,zero,400108c <pvPortMalloc+0x58>
        {
            /* Byte alignment required. Check for overflow. */
            if( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) > xWantedSize )
 4001058:	e0fffe17 	ldw	r3,-8(fp)
 400105c:	00bfff04 	movi	r2,-4
 4001060:	1884703a 	and	r2,r3,r2
 4001064:	10800104 	addi	r2,r2,4
 4001068:	e0fffe17 	ldw	r3,-8(fp)
 400106c:	1880062e 	bgeu	r3,r2,4001088 <pvPortMalloc+0x54>
            {
                xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 4001070:	e0fffe17 	ldw	r3,-8(fp)
 4001074:	00bfff04 	movi	r2,-4
 4001078:	1884703a 	and	r2,r3,r2
 400107c:	10800104 	addi	r2,r2,4
 4001080:	e0bffe15 	stw	r2,-8(fp)
 4001084:	00000106 	br	400108c <pvPortMalloc+0x58>
            }
            else
            {
                xWantedSize = 0;
 4001088:	e03ffe15 	stw	zero,-8(fp)
            }
        }
    }
    #endif /* if ( portBYTE_ALIGNMENT != 1 ) */

    vTaskSuspendAll();
 400108c:	40046e80 	call	40046e8 <vTaskSuspendAll>
    {
        if( pucAlignedHeap == NULL )
 4001090:	d0a71217 	ldw	r2,-25528(gp)
 4001094:	1000051e 	bne	r2,zero,40010ac <pvPortMalloc+0x78>
        {
            /* Ensure the heap starts on a correctly aligned boundary. */
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT - 1 ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
 4001098:	008100b4 	movhi	r2,1026
 400109c:	10baafc4 	addi	r2,r2,-5441
 40010a0:	00ffff04 	movi	r3,-4
 40010a4:	10c4703a 	and	r2,r2,r3
 40010a8:	d0a71215 	stw	r2,-25528(gp)
        }

        /* Check there is enough room left for the allocation and. */
        if( ( xWantedSize > 0 ) &&                                /* valid size */
 40010ac:	e0bffe17 	ldw	r2,-8(fp)
 40010b0:	10001326 	beq	r2,zero,4001100 <pvPortMalloc+0xcc>
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 40010b4:	d0e71117 	ldw	r3,-25532(gp)
 40010b8:	e0bffe17 	ldw	r2,-8(fp)
 40010bc:	1887883a 	add	r3,r3,r2
        if( ( xWantedSize > 0 ) &&                                /* valid size */
 40010c0:	00802034 	movhi	r2,128
 40010c4:	10bffec4 	addi	r2,r2,-5
 40010c8:	10c00d36 	bltu	r2,r3,4001100 <pvPortMalloc+0xcc>
            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */
 40010cc:	d0e71117 	ldw	r3,-25532(gp)
 40010d0:	e0bffe17 	ldw	r2,-8(fp)
 40010d4:	1885883a 	add	r2,r3,r2
 40010d8:	d0e71117 	ldw	r3,-25532(gp)
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 40010dc:	1880082e 	bgeu	r3,r2,4001100 <pvPortMalloc+0xcc>
        {
            /* Return the next free byte then increment the index past this
             * block. */
            pvReturn = pucAlignedHeap + xNextFreeByte;
 40010e0:	d0e71217 	ldw	r3,-25528(gp)
 40010e4:	d0a71117 	ldw	r2,-25532(gp)
 40010e8:	1885883a 	add	r2,r3,r2
 40010ec:	e0bfff15 	stw	r2,-4(fp)
            xNextFreeByte += xWantedSize;
 40010f0:	d0e71117 	ldw	r3,-25532(gp)
 40010f4:	e0bffe17 	ldw	r2,-8(fp)
 40010f8:	1885883a 	add	r2,r3,r2
 40010fc:	d0a71115 	stw	r2,-25532(gp)
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
 4001100:	40047140 	call	4004714 <xTaskResumeAll>
            vApplicationMallocFailedHook();
        }
    }
    #endif

    return pvReturn;
 4001104:	e0bfff17 	ldw	r2,-4(fp)
}
 4001108:	e037883a 	mov	sp,fp
 400110c:	dfc00117 	ldw	ra,4(sp)
 4001110:	df000017 	ldw	fp,0(sp)
 4001114:	dec00204 	addi	sp,sp,8
 4001118:	f800283a 	ret

0400111c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
 400111c:	defffe04 	addi	sp,sp,-8
 4001120:	df000115 	stw	fp,4(sp)
 4001124:	df000104 	addi	fp,sp,4
 4001128:	e13fff15 	stw	r4,-4(fp)
     * https://www.FreeRTOS.org for more information. */
    ( void ) pv;

    /* Force an assert as it is invalid to call this function. */
    configASSERT( pv == NULL );
}
 400112c:	0001883a 	nop
 4001130:	e037883a 	mov	sp,fp
 4001134:	df000017 	ldw	fp,0(sp)
 4001138:	dec00104 	addi	sp,sp,4
 400113c:	f800283a 	ret

04001140 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
 4001140:	deffff04 	addi	sp,sp,-4
 4001144:	df000015 	stw	fp,0(sp)
 4001148:	d839883a 	mov	fp,sp
    /* Only required when static memory is not cleared. */
    xNextFreeByte = ( size_t ) 0;
 400114c:	d0271115 	stw	zero,-25532(gp)
}
 4001150:	0001883a 	nop
 4001154:	e037883a 	mov	sp,fp
 4001158:	df000017 	ldw	fp,0(sp)
 400115c:	dec00104 	addi	sp,sp,4
 4001160:	f800283a 	ret

04001164 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
 4001164:	deffff04 	addi	sp,sp,-4
 4001168:	df000015 	stw	fp,0(sp)
 400116c:	d839883a 	mov	fp,sp
    return( configADJUSTED_HEAP_SIZE - xNextFreeByte );
 4001170:	d0e71117 	ldw	r3,-25532(gp)
 4001174:	00802034 	movhi	r2,128
 4001178:	10bfff04 	addi	r2,r2,-4
 400117c:	10c5c83a 	sub	r2,r2,r3
}
 4001180:	e037883a 	mov	sp,fp
 4001184:	df000017 	ldw	fp,0(sp)
 4001188:	dec00104 	addi	sp,sp,4
 400118c:	f800283a 	ret

04001190 <xQueueGenericReset>:
    }
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
 4001190:	defff404 	addi	sp,sp,-48
 4001194:	dfc00b15 	stw	ra,44(sp)
 4001198:	df000a15 	stw	fp,40(sp)
 400119c:	dd400915 	stw	r21,36(sp)
 40011a0:	dd000815 	stw	r20,32(sp)
 40011a4:	dcc00715 	stw	r19,28(sp)
 40011a8:	dc800615 	stw	r18,24(sp)
 40011ac:	dc400515 	stw	r17,20(sp)
 40011b0:	dc000415 	stw	r16,16(sp)
 40011b4:	df000a04 	addi	fp,sp,40
 40011b8:	e13ff715 	stw	r4,-36(fp)
 40011bc:	e17ff615 	stw	r5,-40(fp)
    BaseType_t xReturn = pdPASS;
 40011c0:	00800044 	movi	r2,1
 40011c4:	e0bff915 	stw	r2,-28(fp)
    Queue_t * const pxQueue = xQueue;
 40011c8:	e0bff717 	ldw	r2,-36(fp)
 40011cc:	e0bff815 	stw	r2,-32(fp)

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
 40011d0:	e0bff817 	ldw	r2,-32(fp)
 40011d4:	10007126 	beq	r2,zero,400139c <xQueueGenericReset+0x20c>
        ( pxQueue->uxLength >= 1U ) &&
 40011d8:	e0bff817 	ldw	r2,-32(fp)
 40011dc:	10800f17 	ldw	r2,60(r2)
    if( ( pxQueue != NULL ) &&
 40011e0:	10006e26 	beq	r2,zero,400139c <xQueueGenericReset+0x20c>
        /* Check for multiplication overflow. */
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
 40011e4:	e0bff817 	ldw	r2,-32(fp)
 40011e8:	14001017 	ldw	r16,64(r2)
 40011ec:	e0bff817 	ldw	r2,-32(fp)
 40011f0:	14400f17 	ldw	r17,60(r2)
 40011f4:	0025883a 	mov	r18,zero
 40011f8:	8008d43a 	srli	r4,r16,16
 40011fc:	8804d43a 	srli	r2,r17,16
 4001200:	20ffffcc 	andi	r3,r4,65535
 4001204:	18000b1e 	bne	r3,zero,4001234 <xQueueGenericReset+0xa4>
 4001208:	10ffffcc 	andi	r3,r2,65535
 400120c:	1800061e 	bne	r3,zero,4001228 <xQueueGenericReset+0x98>
 4001210:	80bfffcc 	andi	r2,r16,65535
 4001214:	88ffffcc 	andi	r3,r17,65535
 4001218:	180b883a 	mov	r5,r3
 400121c:	1009883a 	mov	r4,r2
 4001220:	40072d80 	call	40072d8 <__mulsi3>
 4001224:	00001f06 	br	40012a4 <xQueueGenericReset+0x114>
 4001228:	1029883a 	mov	r20,r2
 400122c:	802b883a 	mov	r21,r16
 4001230:	00000406 	br	4001244 <xQueueGenericReset+0xb4>
 4001234:	10bfffcc 	andi	r2,r2,65535
 4001238:	1000131e 	bne	r2,zero,4001288 <xQueueGenericReset+0xf8>
 400123c:	2029883a 	mov	r20,r4
 4001240:	882b883a 	mov	r21,r17
 4001244:	80bfffcc 	andi	r2,r16,65535
 4001248:	88ffffcc 	andi	r3,r17,65535
 400124c:	180b883a 	mov	r5,r3
 4001250:	1009883a 	mov	r4,r2
 4001254:	40072d80 	call	40072d8 <__mulsi3>
 4001258:	1027883a 	mov	r19,r2
 400125c:	a8bfffcc 	andi	r2,r21,65535
 4001260:	a0ffffcc 	andi	r3,r20,65535
 4001264:	180b883a 	mov	r5,r3
 4001268:	1009883a 	mov	r4,r2
 400126c:	40072d80 	call	40072d8 <__mulsi3>
 4001270:	9806d43a 	srli	r3,r19,16
 4001274:	10c5883a 	add	r2,r2,r3
 4001278:	1005d43a 	srai	r2,r2,16
 400127c:	10bfffcc 	andi	r2,r2,65535
 4001280:	1000041e 	bne	r2,zero,4001294 <xQueueGenericReset+0x104>
 4001284:	00000706 	br	40012a4 <xQueueGenericReset+0x114>
 4001288:	880b883a 	mov	r5,r17
 400128c:	8009883a 	mov	r4,r16
 4001290:	40072d80 	call	40072d8 <__mulsi3>
 4001294:	880b883a 	mov	r5,r17
 4001298:	8009883a 	mov	r4,r16
 400129c:	40072d80 	call	40072d8 <__mulsi3>
 40012a0:	04800044 	movi	r18,1
 40012a4:	9005883a 	mov	r2,r18
        ( pxQueue->uxLength >= 1U ) &&
 40012a8:	10003c1e 	bne	r2,zero,400139c <xQueueGenericReset+0x20c>
    {
        taskENTER_CRITICAL();
 40012ac:	4005f740 	call	4005f74 <vTaskEnterCritical>
        {
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 40012b0:	e0bff817 	ldw	r2,-32(fp)
 40012b4:	14000017 	ldw	r16,0(r2)
 40012b8:	e0bff817 	ldw	r2,-32(fp)
 40012bc:	10c00f17 	ldw	r3,60(r2)
 40012c0:	e0bff817 	ldw	r2,-32(fp)
 40012c4:	10801017 	ldw	r2,64(r2)
 40012c8:	100b883a 	mov	r5,r2
 40012cc:	1809883a 	mov	r4,r3
 40012d0:	40072d80 	call	40072d8 <__mulsi3>
 40012d4:	8087883a 	add	r3,r16,r2
 40012d8:	e0bff817 	ldw	r2,-32(fp)
 40012dc:	10c00215 	stw	r3,8(r2)
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 40012e0:	e0bff817 	ldw	r2,-32(fp)
 40012e4:	10000e15 	stw	zero,56(r2)
            pxQueue->pcWriteTo = pxQueue->pcHead;
 40012e8:	e0bff817 	ldw	r2,-32(fp)
 40012ec:	10c00017 	ldw	r3,0(r2)
 40012f0:	e0bff817 	ldw	r2,-32(fp)
 40012f4:	10c00115 	stw	r3,4(r2)
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 40012f8:	e0bff817 	ldw	r2,-32(fp)
 40012fc:	14000017 	ldw	r16,0(r2)
 4001300:	e0bff817 	ldw	r2,-32(fp)
 4001304:	10800f17 	ldw	r2,60(r2)
 4001308:	10ffffc4 	addi	r3,r2,-1
 400130c:	e0bff817 	ldw	r2,-32(fp)
 4001310:	10801017 	ldw	r2,64(r2)
 4001314:	100b883a 	mov	r5,r2
 4001318:	1809883a 	mov	r4,r3
 400131c:	40072d80 	call	40072d8 <__mulsi3>
 4001320:	8087883a 	add	r3,r16,r2
 4001324:	e0bff817 	ldw	r2,-32(fp)
 4001328:	10c00315 	stw	r3,12(r2)
            pxQueue->cRxLock = queueUNLOCKED;
 400132c:	e0bff817 	ldw	r2,-32(fp)
 4001330:	00ffffc4 	movi	r3,-1
 4001334:	10c01105 	stb	r3,68(r2)
            pxQueue->cTxLock = queueUNLOCKED;
 4001338:	e0bff817 	ldw	r2,-32(fp)
 400133c:	00ffffc4 	movi	r3,-1
 4001340:	10c01145 	stb	r3,69(r2)

            if( xNewQueue == pdFALSE )
 4001344:	e0bff617 	ldw	r2,-40(fp)
 4001348:	10000a1e 	bne	r2,zero,4001374 <xQueueGenericReset+0x1e4>
                /* If there are tasks blocked waiting to read from the queue, then
                 * the tasks will remain blocked as after this function exits the queue
                 * will still be empty.  If there are tasks blocked waiting to write to
                 * the queue, then one should be unblocked as after this function exits
                 * it will be possible to write to it. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 400134c:	e0bff817 	ldw	r2,-32(fp)
 4001350:	10800417 	ldw	r2,16(r2)
 4001354:	10000f26 	beq	r2,zero,4001394 <xQueueGenericReset+0x204>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 4001358:	e0bff817 	ldw	r2,-32(fp)
 400135c:	10800404 	addi	r2,r2,16
 4001360:	1009883a 	mov	r4,r2
 4001364:	40050240 	call	4005024 <xTaskRemoveFromEventList>
 4001368:	10000a26 	beq	r2,zero,4001394 <xQueueGenericReset+0x204>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
 400136c:	003b683a 	trap	0
 4001370:	00000806 	br	4001394 <xQueueGenericReset+0x204>
                }
            }
            else
            {
                /* Ensure the event queues start in the correct state. */
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 4001374:	e0bff817 	ldw	r2,-32(fp)
 4001378:	10800404 	addi	r2,r2,16
 400137c:	1009883a 	mov	r4,r2
 4001380:	4000aa00 	call	4000aa0 <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 4001384:	e0bff817 	ldw	r2,-32(fp)
 4001388:	10800904 	addi	r2,r2,36
 400138c:	1009883a 	mov	r4,r2
 4001390:	4000aa00 	call	4000aa0 <vListInitialise>
            }
        }
        taskEXIT_CRITICAL();
 4001394:	4005fc80 	call	4005fc8 <vTaskExitCritical>
 4001398:	00000106 	br	40013a0 <xQueueGenericReset+0x210>
    }
    else
    {
        xReturn = pdFAIL;
 400139c:	e03ff915 	stw	zero,-28(fp)

    configASSERT( xReturn != pdFAIL );

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return xReturn;
 40013a0:	e0bff917 	ldw	r2,-28(fp)
}
 40013a4:	e6fffa04 	addi	sp,fp,-24
 40013a8:	dfc00717 	ldw	ra,28(sp)
 40013ac:	df000617 	ldw	fp,24(sp)
 40013b0:	dd400517 	ldw	r21,20(sp)
 40013b4:	dd000417 	ldw	r20,16(sp)
 40013b8:	dcc00317 	ldw	r19,12(sp)
 40013bc:	dc800217 	ldw	r18,8(sp)
 40013c0:	dc400117 	ldw	r17,4(sp)
 40013c4:	dc000017 	ldw	r16,0(sp)
 40013c8:	dec00804 	addi	sp,sp,32
 40013cc:	f800283a 	ret

040013d0 <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
 40013d0:	defff304 	addi	sp,sp,-52
 40013d4:	dfc00c15 	stw	ra,48(sp)
 40013d8:	df000b15 	stw	fp,44(sp)
 40013dc:	dcc00a15 	stw	r19,40(sp)
 40013e0:	dc800915 	stw	r18,36(sp)
 40013e4:	dc400815 	stw	r17,32(sp)
 40013e8:	dc000715 	stw	r16,28(sp)
 40013ec:	df000b04 	addi	fp,sp,44
 40013f0:	e13ff815 	stw	r4,-32(fp)
 40013f4:	e17ff715 	stw	r5,-36(fp)
 40013f8:	3005883a 	mov	r2,r6
 40013fc:	e0bff605 	stb	r2,-40(fp)
        Queue_t * pxNewQueue = NULL;
 4001400:	e03ffb15 	stw	zero,-20(fp)
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
 4001404:	e0bff817 	ldw	r2,-32(fp)
 4001408:	10005026 	beq	r2,zero,400154c <xQueueGenericCreate+0x17c>
            /* Check for multiplication overflow. */
            ( ( SIZE_MAX / uxQueueLength ) >= uxItemSize ) &&
 400140c:	0021883a 	mov	r16,zero
 4001410:	e0bff717 	ldw	r2,-36(fp)
 4001414:	100cd43a 	srli	r6,r2,16
 4001418:	e0fff717 	ldw	r3,-36(fp)
 400141c:	e0bff817 	ldw	r2,-32(fp)
 4001420:	1008d43a 	srli	r4,r2,16
 4001424:	e0bff817 	ldw	r2,-32(fp)
 4001428:	317fffcc 	andi	r5,r6,65535
 400142c:	28000b1e 	bne	r5,zero,400145c <xQueueGenericCreate+0x8c>
 4001430:	217fffcc 	andi	r5,r4,65535
 4001434:	2800061e 	bne	r5,zero,4001450 <xQueueGenericCreate+0x80>
 4001438:	18ffffcc 	andi	r3,r3,65535
 400143c:	10bfffcc 	andi	r2,r2,65535
 4001440:	100b883a 	mov	r5,r2
 4001444:	1809883a 	mov	r4,r3
 4001448:	40072d80 	call	40072d8 <__mulsi3>
 400144c:	00001f06 	br	40014cc <xQueueGenericCreate+0xfc>
 4001450:	2025883a 	mov	r18,r4
 4001454:	1827883a 	mov	r19,r3
 4001458:	00000406 	br	400146c <xQueueGenericCreate+0x9c>
 400145c:	213fffcc 	andi	r4,r4,65535
 4001460:	2000131e 	bne	r4,zero,40014b0 <xQueueGenericCreate+0xe0>
 4001464:	3025883a 	mov	r18,r6
 4001468:	1027883a 	mov	r19,r2
 400146c:	18ffffcc 	andi	r3,r3,65535
 4001470:	10bfffcc 	andi	r2,r2,65535
 4001474:	100b883a 	mov	r5,r2
 4001478:	1809883a 	mov	r4,r3
 400147c:	40072d80 	call	40072d8 <__mulsi3>
 4001480:	1023883a 	mov	r17,r2
 4001484:	98bfffcc 	andi	r2,r19,65535
 4001488:	90ffffcc 	andi	r3,r18,65535
 400148c:	180b883a 	mov	r5,r3
 4001490:	1009883a 	mov	r4,r2
 4001494:	40072d80 	call	40072d8 <__mulsi3>
 4001498:	8806d43a 	srli	r3,r17,16
 400149c:	10c5883a 	add	r2,r2,r3
 40014a0:	1005d43a 	srai	r2,r2,16
 40014a4:	10bfffcc 	andi	r2,r2,65535
 40014a8:	1000041e 	bne	r2,zero,40014bc <xQueueGenericCreate+0xec>
 40014ac:	00000706 	br	40014cc <xQueueGenericCreate+0xfc>
 40014b0:	e17ff817 	ldw	r5,-32(fp)
 40014b4:	e13ff717 	ldw	r4,-36(fp)
 40014b8:	40072d80 	call	40072d8 <__mulsi3>
 40014bc:	e17ff817 	ldw	r5,-32(fp)
 40014c0:	e13ff717 	ldw	r4,-36(fp)
 40014c4:	40072d80 	call	40072d8 <__mulsi3>
 40014c8:	04000044 	movi	r16,1
 40014cc:	8005883a 	mov	r2,r16
        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
 40014d0:	10001e1e 	bne	r2,zero,400154c <xQueueGenericCreate+0x17c>
            /* Check for addition overflow. */
            ( ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
 40014d4:	e17ff717 	ldw	r5,-36(fp)
 40014d8:	e13ff817 	ldw	r4,-32(fp)
 40014dc:	40072d80 	call	40072d8 <__mulsi3>
 40014e0:	1007883a 	mov	r3,r2
            ( ( SIZE_MAX / uxQueueLength ) >= uxItemSize ) &&
 40014e4:	00bfedc4 	movi	r2,-73
 40014e8:	10c01836 	bltu	r2,r3,400154c <xQueueGenericCreate+0x17c>
        {
            /* Allocate enough space to hold the maximum number of items that
             * can be in the queue at any time.  It is valid for uxItemSize to be
             * zero in the case the queue is used as a semaphore. */
            xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 40014ec:	e17ff717 	ldw	r5,-36(fp)
 40014f0:	e13ff817 	ldw	r4,-32(fp)
 40014f4:	40072d80 	call	40072d8 <__mulsi3>
 40014f8:	e0bffa15 	stw	r2,-24(fp)
             * alignment requirements of the Queue_t structure - which in this case
             * is an int8_t *.  Therefore, whenever the stack alignment requirements
             * are greater than or equal to the pointer to char requirements the cast
             * is safe.  In other cases alignment requirements are not strict (one or
             * two bytes). */
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
 40014fc:	e0bffa17 	ldw	r2,-24(fp)
 4001500:	10801204 	addi	r2,r2,72
 4001504:	1009883a 	mov	r4,r2
 4001508:	40010340 	call	4001034 <pvPortMalloc>
 400150c:	e0bffb15 	stw	r2,-20(fp)

            if( pxNewQueue != NULL )
 4001510:	e0bffb17 	ldw	r2,-20(fp)
 4001514:	10000d26 	beq	r2,zero,400154c <xQueueGenericCreate+0x17c>
            {
                /* Jump past the queue structure to find the location of the queue
                 * storage area. */
                pucQueueStorage = ( uint8_t * ) pxNewQueue;
 4001518:	e0bffb17 	ldw	r2,-20(fp)
 400151c:	e0bff915 	stw	r2,-28(fp)
                pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 4001520:	e0bff917 	ldw	r2,-28(fp)
 4001524:	10801204 	addi	r2,r2,72
 4001528:	e0bff915 	stw	r2,-28(fp)
                     * deleted. */
                    pxNewQueue->ucStaticallyAllocated = pdFALSE;
                }
                #endif /* configSUPPORT_STATIC_ALLOCATION */

                prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 400152c:	e0fff603 	ldbu	r3,-40(fp)
 4001530:	e0bffb17 	ldw	r2,-20(fp)
 4001534:	d8800015 	stw	r2,0(sp)
 4001538:	180f883a 	mov	r7,r3
 400153c:	e1bff917 	ldw	r6,-28(fp)
 4001540:	e17ff717 	ldw	r5,-36(fp)
 4001544:	e13ff817 	ldw	r4,-32(fp)
 4001548:	40015740 	call	4001574 <prvInitialiseNewQueue>
        {
            configASSERT( pxNewQueue );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
 400154c:	e0bffb17 	ldw	r2,-20(fp)
    }
 4001550:	e6fffc04 	addi	sp,fp,-16
 4001554:	dfc00517 	ldw	ra,20(sp)
 4001558:	df000417 	ldw	fp,16(sp)
 400155c:	dcc00317 	ldw	r19,12(sp)
 4001560:	dc800217 	ldw	r18,8(sp)
 4001564:	dc400117 	ldw	r17,4(sp)
 4001568:	dc000017 	ldw	r16,0(sp)
 400156c:	dec00604 	addi	sp,sp,24
 4001570:	f800283a 	ret

04001574 <prvInitialiseNewQueue>:
static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
                                   const UBaseType_t uxItemSize,
                                   uint8_t * pucQueueStorage,
                                   const uint8_t ucQueueType,
                                   Queue_t * pxNewQueue )
{
 4001574:	defffa04 	addi	sp,sp,-24
 4001578:	dfc00515 	stw	ra,20(sp)
 400157c:	df000415 	stw	fp,16(sp)
 4001580:	df000404 	addi	fp,sp,16
 4001584:	e13fff15 	stw	r4,-4(fp)
 4001588:	e17ffe15 	stw	r5,-8(fp)
 400158c:	e1bffd15 	stw	r6,-12(fp)
 4001590:	3805883a 	mov	r2,r7
 4001594:	e0bffc05 	stb	r2,-16(fp)
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
 4001598:	e0bffe17 	ldw	r2,-8(fp)
 400159c:	1000041e 	bne	r2,zero,40015b0 <prvInitialiseNewQueue+0x3c>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 40015a0:	e0800217 	ldw	r2,8(fp)
 40015a4:	e0c00217 	ldw	r3,8(fp)
 40015a8:	10c00015 	stw	r3,0(r2)
 40015ac:	00000306 	br	40015bc <prvInitialiseNewQueue+0x48>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 40015b0:	e0800217 	ldw	r2,8(fp)
 40015b4:	e0fffd17 	ldw	r3,-12(fp)
 40015b8:	10c00015 	stw	r3,0(r2)
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
 40015bc:	e0800217 	ldw	r2,8(fp)
 40015c0:	e0ffff17 	ldw	r3,-4(fp)
 40015c4:	10c00f15 	stw	r3,60(r2)
    pxNewQueue->uxItemSize = uxItemSize;
 40015c8:	e0800217 	ldw	r2,8(fp)
 40015cc:	e0fffe17 	ldw	r3,-8(fp)
 40015d0:	10c01015 	stw	r3,64(r2)
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 40015d4:	01400044 	movi	r5,1
 40015d8:	e1000217 	ldw	r4,8(fp)
 40015dc:	40011900 	call	4001190 <xQueueGenericReset>
        pxNewQueue->pxQueueSetContainer = NULL;
    }
    #endif /* configUSE_QUEUE_SETS */

    traceQUEUE_CREATE( pxNewQueue );
}
 40015e0:	0001883a 	nop
 40015e4:	e037883a 	mov	sp,fp
 40015e8:	dfc00117 	ldw	ra,4(sp)
 40015ec:	df000017 	ldw	fp,0(sp)
 40015f0:	dec00204 	addi	sp,sp,8
 40015f4:	f800283a 	ret

040015f8 <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    static void prvInitialiseMutex( Queue_t * pxNewQueue )
    {
 40015f8:	defffd04 	addi	sp,sp,-12
 40015fc:	dfc00215 	stw	ra,8(sp)
 4001600:	df000115 	stw	fp,4(sp)
 4001604:	df000104 	addi	fp,sp,4
 4001608:	e13fff15 	stw	r4,-4(fp)
        if( pxNewQueue != NULL )
 400160c:	e0bfff17 	ldw	r2,-4(fp)
 4001610:	10000b26 	beq	r2,zero,4001640 <prvInitialiseMutex+0x48>
        {
            /* The queue create function will set all the queue structure members
            * correctly for a generic queue, but this function is creating a
            * mutex.  Overwrite those members that need to be set differently -
            * in particular the information required for priority inheritance. */
            pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 4001614:	e0bfff17 	ldw	r2,-4(fp)
 4001618:	10000215 	stw	zero,8(r2)
            pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 400161c:	e0bfff17 	ldw	r2,-4(fp)
 4001620:	10000015 	stw	zero,0(r2)

            /* In case this is a recursive mutex. */
            pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
 4001624:	e0bfff17 	ldw	r2,-4(fp)
 4001628:	10000315 	stw	zero,12(r2)

            traceCREATE_MUTEX( pxNewQueue );

            /* Start with the semaphore in the expected state. */
            ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 400162c:	000f883a 	mov	r7,zero
 4001630:	000d883a 	mov	r6,zero
 4001634:	000b883a 	mov	r5,zero
 4001638:	e13fff17 	ldw	r4,-4(fp)
 400163c:	40018500 	call	4001850 <xQueueGenericSend>
        }
        else
        {
            traceCREATE_MUTEX_FAILED();
        }
    }
 4001640:	0001883a 	nop
 4001644:	e037883a 	mov	sp,fp
 4001648:	dfc00117 	ldw	ra,4(sp)
 400164c:	df000017 	ldw	fp,0(sp)
 4001650:	dec00204 	addi	sp,sp,8
 4001654:	f800283a 	ret

04001658 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

    QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
    {
 4001658:	defffa04 	addi	sp,sp,-24
 400165c:	dfc00515 	stw	ra,20(sp)
 4001660:	df000415 	stw	fp,16(sp)
 4001664:	df000404 	addi	fp,sp,16
 4001668:	2005883a 	mov	r2,r4
 400166c:	e0bffc05 	stb	r2,-16(fp)
        QueueHandle_t xNewQueue;
        const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 4001670:	00800044 	movi	r2,1
 4001674:	e0bfff15 	stw	r2,-4(fp)
 4001678:	e03ffe15 	stw	zero,-8(fp)

        xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 400167c:	e0bffc03 	ldbu	r2,-16(fp)
 4001680:	100d883a 	mov	r6,r2
 4001684:	e17ffe17 	ldw	r5,-8(fp)
 4001688:	e13fff17 	ldw	r4,-4(fp)
 400168c:	40013d00 	call	40013d0 <xQueueGenericCreate>
 4001690:	e0bffd15 	stw	r2,-12(fp)
        prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 4001694:	e13ffd17 	ldw	r4,-12(fp)
 4001698:	40015f80 	call	40015f8 <prvInitialiseMutex>

        return xNewQueue;
 400169c:	e0bffd17 	ldw	r2,-12(fp)
    }
 40016a0:	e037883a 	mov	sp,fp
 40016a4:	dfc00117 	ldw	ra,4(sp)
 40016a8:	df000017 	ldw	fp,0(sp)
 40016ac:	dec00204 	addi	sp,sp,8
 40016b0:	f800283a 	ret

040016b4 <xQueueGiveMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

    BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
    {
 40016b4:	defffa04 	addi	sp,sp,-24
 40016b8:	dfc00515 	stw	ra,20(sp)
 40016bc:	df000415 	stw	fp,16(sp)
 40016c0:	dc000315 	stw	r16,12(sp)
 40016c4:	df000404 	addi	fp,sp,16
 40016c8:	e13ffc15 	stw	r4,-16(fp)
        BaseType_t xReturn;
        Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 40016cc:	e0bffc17 	ldw	r2,-16(fp)
 40016d0:	e0bffd15 	stw	r2,-12(fp)
         * change outside of this task.  If this task does not hold the mutex then
         * pxMutexHolder can never coincidentally equal the tasks handle, and as
         * this is the only condition we are interested in it does not matter if
         * pxMutexHolder is accessed simultaneously by another task.  Therefore no
         * mutual exclusion is required to test the pxMutexHolder variable. */
        if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 40016d4:	e0bffd17 	ldw	r2,-12(fp)
 40016d8:	14000217 	ldw	r16,8(r2)
 40016dc:	40059880 	call	4005988 <xTaskGetCurrentTaskHandle>
 40016e0:	8080101e 	bne	r16,r2,4001724 <xQueueGiveMutexRecursive+0x70>
            /* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
             * the task handle, therefore no underflow check is required.  Also,
             * uxRecursiveCallCount is only modified by the mutex holder, and as
             * there can only be one, no mutual exclusion is required to modify the
             * uxRecursiveCallCount member. */
            ( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
 40016e4:	e0bffd17 	ldw	r2,-12(fp)
 40016e8:	10800317 	ldw	r2,12(r2)
 40016ec:	10ffffc4 	addi	r3,r2,-1
 40016f0:	e0bffd17 	ldw	r2,-12(fp)
 40016f4:	10c00315 	stw	r3,12(r2)

            /* Has the recursive call count unwound to 0? */
            if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 40016f8:	e0bffd17 	ldw	r2,-12(fp)
 40016fc:	10800317 	ldw	r2,12(r2)
 4001700:	1000051e 	bne	r2,zero,4001718 <xQueueGiveMutexRecursive+0x64>
            {
                /* Return the mutex.  This will automatically unblock any other
                 * task that might be waiting to access the mutex. */
                ( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 4001704:	000f883a 	mov	r7,zero
 4001708:	000d883a 	mov	r6,zero
 400170c:	000b883a 	mov	r5,zero
 4001710:	e13ffd17 	ldw	r4,-12(fp)
 4001714:	40018500 	call	4001850 <xQueueGenericSend>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            xReturn = pdPASS;
 4001718:	00800044 	movi	r2,1
 400171c:	e0bffe15 	stw	r2,-8(fp)
 4001720:	00000106 	br	4001728 <xQueueGiveMutexRecursive+0x74>
        }
        else
        {
            /* The mutex cannot be given because the calling task is not the
             * holder. */
            xReturn = pdFAIL;
 4001724:	e03ffe15 	stw	zero,-8(fp)

            traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
        }

        return xReturn;
 4001728:	e0bffe17 	ldw	r2,-8(fp)
    }
 400172c:	e6ffff04 	addi	sp,fp,-4
 4001730:	dfc00217 	ldw	ra,8(sp)
 4001734:	df000117 	ldw	fp,4(sp)
 4001738:	dc000017 	ldw	r16,0(sp)
 400173c:	dec00304 	addi	sp,sp,12
 4001740:	f800283a 	ret

04001744 <xQueueTakeMutexRecursive>:

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

    BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex,
                                         TickType_t xTicksToWait )
    {
 4001744:	defff904 	addi	sp,sp,-28
 4001748:	dfc00615 	stw	ra,24(sp)
 400174c:	df000515 	stw	fp,20(sp)
 4001750:	dc000415 	stw	r16,16(sp)
 4001754:	df000504 	addi	fp,sp,20
 4001758:	e13ffc15 	stw	r4,-16(fp)
 400175c:	e17ffb15 	stw	r5,-20(fp)
        BaseType_t xReturn;
        Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 4001760:	e0bffc17 	ldw	r2,-16(fp)
 4001764:	e0bffd15 	stw	r2,-12(fp)
        /* Comments regarding mutual exclusion as per those within
         * xQueueGiveMutexRecursive(). */

        traceTAKE_MUTEX_RECURSIVE( pxMutex );

        if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 4001768:	e0bffd17 	ldw	r2,-12(fp)
 400176c:	14000217 	ldw	r16,8(r2)
 4001770:	40059880 	call	4005988 <xTaskGetCurrentTaskHandle>
 4001774:	8080081e 	bne	r16,r2,4001798 <xQueueTakeMutexRecursive+0x54>
        {
            ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 4001778:	e0bffd17 	ldw	r2,-12(fp)
 400177c:	10800317 	ldw	r2,12(r2)
 4001780:	10c00044 	addi	r3,r2,1
 4001784:	e0bffd17 	ldw	r2,-12(fp)
 4001788:	10c00315 	stw	r3,12(r2)
            xReturn = pdPASS;
 400178c:	00800044 	movi	r2,1
 4001790:	e0bffe15 	stw	r2,-8(fp)
 4001794:	00000b06 	br	40017c4 <xQueueTakeMutexRecursive+0x80>
        }
        else
        {
            xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
 4001798:	e17ffb17 	ldw	r5,-20(fp)
 400179c:	e13ffd17 	ldw	r4,-12(fp)
 40017a0:	4001da40 	call	4001da4 <xQueueSemaphoreTake>
 40017a4:	e0bffe15 	stw	r2,-8(fp)

            /* pdPASS will only be returned if the mutex was successfully
             * obtained.  The calling task may have entered the Blocked state
             * before reaching here. */
            if( xReturn != pdFAIL )
 40017a8:	e0bffe17 	ldw	r2,-8(fp)
 40017ac:	10000526 	beq	r2,zero,40017c4 <xQueueTakeMutexRecursive+0x80>
            {
                ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 40017b0:	e0bffd17 	ldw	r2,-12(fp)
 40017b4:	10800317 	ldw	r2,12(r2)
 40017b8:	10c00044 	addi	r3,r2,1
 40017bc:	e0bffd17 	ldw	r2,-12(fp)
 40017c0:	10c00315 	stw	r3,12(r2)
            {
                traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
            }
        }

        return xReturn;
 40017c4:	e0bffe17 	ldw	r2,-8(fp)
    }
 40017c8:	e6ffff04 	addi	sp,fp,-4
 40017cc:	dfc00217 	ldw	ra,8(sp)
 40017d0:	df000117 	ldw	fp,4(sp)
 40017d4:	dc000017 	ldw	r16,0(sp)
 40017d8:	dec00304 	addi	sp,sp,12
 40017dc:	f800283a 	ret

040017e0 <xQueueCreateCountingSemaphore>:

#if ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

    QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount,
                                                 const UBaseType_t uxInitialCount )
    {
 40017e0:	defffb04 	addi	sp,sp,-20
 40017e4:	dfc00415 	stw	ra,16(sp)
 40017e8:	df000315 	stw	fp,12(sp)
 40017ec:	df000304 	addi	fp,sp,12
 40017f0:	e13ffe15 	stw	r4,-8(fp)
 40017f4:	e17ffd15 	stw	r5,-12(fp)
        QueueHandle_t xHandle = NULL;
 40017f8:	e03fff15 	stw	zero,-4(fp)

        if( ( uxMaxCount != 0 ) &&
 40017fc:	e0bffe17 	ldw	r2,-8(fp)
 4001800:	10000d26 	beq	r2,zero,4001838 <xQueueCreateCountingSemaphore+0x58>
 4001804:	e0bffd17 	ldw	r2,-12(fp)
 4001808:	e0fffe17 	ldw	r3,-8(fp)
 400180c:	18800a36 	bltu	r3,r2,4001838 <xQueueCreateCountingSemaphore+0x58>
            ( uxInitialCount <= uxMaxCount ) )
        {
            xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
 4001810:	01800084 	movi	r6,2
 4001814:	000b883a 	mov	r5,zero
 4001818:	e13ffe17 	ldw	r4,-8(fp)
 400181c:	40013d00 	call	40013d0 <xQueueGenericCreate>
 4001820:	e0bfff15 	stw	r2,-4(fp)

            if( xHandle != NULL )
 4001824:	e0bfff17 	ldw	r2,-4(fp)
 4001828:	10000326 	beq	r2,zero,4001838 <xQueueCreateCountingSemaphore+0x58>
            {
                ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 400182c:	e0bfff17 	ldw	r2,-4(fp)
 4001830:	e0fffd17 	ldw	r3,-12(fp)
 4001834:	10c00e15 	stw	r3,56(r2)
        {
            configASSERT( xHandle );
            mtCOVERAGE_TEST_MARKER();
        }

        return xHandle;
 4001838:	e0bfff17 	ldw	r2,-4(fp)
    }
 400183c:	e037883a 	mov	sp,fp
 4001840:	dfc00117 	ldw	ra,4(sp)
 4001844:	df000017 	ldw	fp,0(sp)
 4001848:	dec00204 	addi	sp,sp,8
 400184c:	f800283a 	ret

04001850 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
 4001850:	defff504 	addi	sp,sp,-44
 4001854:	dfc00a15 	stw	ra,40(sp)
 4001858:	df000915 	stw	fp,36(sp)
 400185c:	df000904 	addi	fp,sp,36
 4001860:	e13ffa15 	stw	r4,-24(fp)
 4001864:	e17ff915 	stw	r5,-28(fp)
 4001868:	e1bff815 	stw	r6,-32(fp)
 400186c:	e1fff715 	stw	r7,-36(fp)
    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 4001870:	e03fff15 	stw	zero,-4(fp)
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
 4001874:	e0bffa17 	ldw	r2,-24(fp)
 4001878:	e0bffe15 	stw	r2,-8(fp)
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
 400187c:	4005f740 	call	4005f74 <vTaskEnterCritical>
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 4001880:	e0bffe17 	ldw	r2,-8(fp)
 4001884:	10c00e17 	ldw	r3,56(r2)
 4001888:	e0bffe17 	ldw	r2,-8(fp)
 400188c:	10800f17 	ldw	r2,60(r2)
 4001890:	18800336 	bltu	r3,r2,40018a0 <xQueueGenericSend+0x50>
 4001894:	e0bff717 	ldw	r2,-36(fp)
 4001898:	10800098 	cmpnei	r2,r2,2
 400189c:	1000151e 	bne	r2,zero,40018f4 <xQueueGenericSend+0xa4>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 40018a0:	e1bff717 	ldw	r6,-36(fp)
 40018a4:	e17ff917 	ldw	r5,-28(fp)
 40018a8:	e13ffe17 	ldw	r4,-8(fp)
 40018ac:	40024300 	call	4002430 <prvCopyDataToQueue>
 40018b0:	e0bffd15 	stw	r2,-12(fp)

                    /* If there was a task waiting for data to arrive on the
                     * queue then unblock it now. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 40018b4:	e0bffe17 	ldw	r2,-8(fp)
 40018b8:	10800917 	ldw	r2,36(r2)
 40018bc:	10000726 	beq	r2,zero,40018dc <xQueueGenericSend+0x8c>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 40018c0:	e0bffe17 	ldw	r2,-8(fp)
 40018c4:	10800904 	addi	r2,r2,36
 40018c8:	1009883a 	mov	r4,r2
 40018cc:	40050240 	call	4005024 <xTaskRemoveFromEventList>
 40018d0:	10000526 	beq	r2,zero,40018e8 <xQueueGenericSend+0x98>
                        {
                            /* The unblocked task has a priority higher than
                             * our own so yield immediately.  Yes it is ok to do
                             * this from within the critical section - the kernel
                             * takes care of that. */
                            queueYIELD_IF_USING_PREEMPTION();
 40018d4:	003b683a 	trap	0
 40018d8:	00000306 	br	40018e8 <xQueueGenericSend+0x98>
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                    else if( xYieldRequired != pdFALSE )
 40018dc:	e0bffd17 	ldw	r2,-12(fp)
 40018e0:	10000126 	beq	r2,zero,40018e8 <xQueueGenericSend+0x98>
                    {
                        /* This path is a special case that will only get
                         * executed if the task was holding multiple mutexes and
                         * the mutexes were given back in an order that is
                         * different to that in which they were taken. */
                        queueYIELD_IF_USING_PREEMPTION();
 40018e4:	003b683a 	trap	0
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
 40018e8:	4005fc80 	call	4005fc8 <vTaskExitCritical>
                return pdPASS;
 40018ec:	00800044 	movi	r2,1
 40018f0:	00003f06 	br	40019f0 <xQueueGenericSend+0x1a0>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
 40018f4:	e0bff817 	ldw	r2,-32(fp)
 40018f8:	1000031e 	bne	r2,zero,4001908 <xQueueGenericSend+0xb8>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
 40018fc:	4005fc80 	call	4005fc8 <vTaskExitCritical>

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
 4001900:	0005883a 	mov	r2,zero
 4001904:	00003a06 	br	40019f0 <xQueueGenericSend+0x1a0>
                }
                else if( xEntryTimeSet == pdFALSE )
 4001908:	e0bfff17 	ldw	r2,-4(fp)
 400190c:	1000051e 	bne	r2,zero,4001924 <xQueueGenericSend+0xd4>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
 4001910:	e0bffb04 	addi	r2,fp,-20
 4001914:	1009883a 	mov	r4,r2
 4001918:	40055900 	call	4005590 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
 400191c:	00800044 	movi	r2,1
 4001920:	e0bfff15 	stw	r2,-4(fp)
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
 4001924:	4005fc80 	call	4005fc8 <vTaskExitCritical>

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
 4001928:	40046e80 	call	40046e8 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 400192c:	4005f740 	call	4005f74 <vTaskEnterCritical>
 4001930:	e0bffe17 	ldw	r2,-8(fp)
 4001934:	10801103 	ldbu	r2,68(r2)
 4001938:	10803fcc 	andi	r2,r2,255
 400193c:	1080201c 	xori	r2,r2,128
 4001940:	10bfe004 	addi	r2,r2,-128
 4001944:	10bfffd8 	cmpnei	r2,r2,-1
 4001948:	1000021e 	bne	r2,zero,4001954 <xQueueGenericSend+0x104>
 400194c:	e0bffe17 	ldw	r2,-8(fp)
 4001950:	10001105 	stb	zero,68(r2)
 4001954:	e0bffe17 	ldw	r2,-8(fp)
 4001958:	10801143 	ldbu	r2,69(r2)
 400195c:	10803fcc 	andi	r2,r2,255
 4001960:	1080201c 	xori	r2,r2,128
 4001964:	10bfe004 	addi	r2,r2,-128
 4001968:	10bfffd8 	cmpnei	r2,r2,-1
 400196c:	1000021e 	bne	r2,zero,4001978 <xQueueGenericSend+0x128>
 4001970:	e0bffe17 	ldw	r2,-8(fp)
 4001974:	10001145 	stb	zero,69(r2)
 4001978:	4005fc80 	call	4005fc8 <vTaskExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 400197c:	e0fff804 	addi	r3,fp,-32
 4001980:	e0bffb04 	addi	r2,fp,-20
 4001984:	180b883a 	mov	r5,r3
 4001988:	1009883a 	mov	r4,r2
 400198c:	40055cc0 	call	40055cc <xTaskCheckForTimeOut>
 4001990:	1000131e 	bne	r2,zero,40019e0 <xQueueGenericSend+0x190>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
 4001994:	e13ffe17 	ldw	r4,-8(fp)
 4001998:	40027e40 	call	40027e4 <prvIsQueueFull>
 400199c:	10000c26 	beq	r2,zero,40019d0 <xQueueGenericSend+0x180>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 40019a0:	e0bffe17 	ldw	r2,-8(fp)
 40019a4:	10800404 	addi	r2,r2,16
 40019a8:	e0fff817 	ldw	r3,-32(fp)
 40019ac:	180b883a 	mov	r5,r3
 40019b0:	1009883a 	mov	r4,r2
 40019b4:	4004f180 	call	4004f18 <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list. It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready list instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
 40019b8:	e13ffe17 	ldw	r4,-8(fp)
 40019bc:	40026580 	call	4002658 <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in the ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
 40019c0:	40047140 	call	4004714 <xTaskResumeAll>
 40019c4:	103fad1e 	bne	r2,zero,400187c <xQueueGenericSend+0x2c>
                {
                    portYIELD_WITHIN_API();
 40019c8:	003b683a 	trap	0
 40019cc:	003fab06 	br	400187c <xQueueGenericSend+0x2c>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
 40019d0:	e13ffe17 	ldw	r4,-8(fp)
 40019d4:	40026580 	call	4002658 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
 40019d8:	40047140 	call	4004714 <xTaskResumeAll>
 40019dc:	003fa706 	br	400187c <xQueueGenericSend+0x2c>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
 40019e0:	e13ffe17 	ldw	r4,-8(fp)
 40019e4:	40026580 	call	4002658 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
 40019e8:	40047140 	call	4004714 <xTaskResumeAll>

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
 40019ec:	0005883a 	mov	r2,zero
        }
    } /*lint -restore */
}
 40019f0:	e037883a 	mov	sp,fp
 40019f4:	dfc00117 	ldw	ra,4(sp)
 40019f8:	df000017 	ldw	fp,0(sp)
 40019fc:	dec00204 	addi	sp,sp,8
 4001a00:	f800283a 	ret

04001a04 <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
 4001a04:	defff404 	addi	sp,sp,-48
 4001a08:	dfc00b15 	stw	ra,44(sp)
 4001a0c:	df000a15 	stw	fp,40(sp)
 4001a10:	df000a04 	addi	fp,sp,40
 4001a14:	e13ff915 	stw	r4,-28(fp)
 4001a18:	e17ff815 	stw	r5,-32(fp)
 4001a1c:	e1bff715 	stw	r6,-36(fp)
 4001a20:	e1fff615 	stw	r7,-40(fp)
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
 4001a24:	e0bff917 	ldw	r2,-28(fp)
 4001a28:	e0bffe15 	stw	r2,-8(fp)
    /* Similar to xQueueGenericSend, except without blocking if there is no room
     * in the queue.  Also don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4001a2c:	e03ffd15 	stw	zero,-12(fp)
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 4001a30:	e0bffe17 	ldw	r2,-8(fp)
 4001a34:	10c00e17 	ldw	r3,56(r2)
 4001a38:	e0bffe17 	ldw	r2,-8(fp)
 4001a3c:	10800f17 	ldw	r2,60(r2)
 4001a40:	18800336 	bltu	r3,r2,4001a50 <xQueueGenericSendFromISR+0x4c>
 4001a44:	e0bff617 	ldw	r2,-40(fp)
 4001a48:	10800098 	cmpnei	r2,r2,2
 4001a4c:	1000281e 	bne	r2,zero,4001af0 <xQueueGenericSendFromISR+0xec>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
 4001a50:	e0bffe17 	ldw	r2,-8(fp)
 4001a54:	10801143 	ldbu	r2,69(r2)
 4001a58:	e0bffcc5 	stb	r2,-13(fp)
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 4001a5c:	e0bffe17 	ldw	r2,-8(fp)
 4001a60:	10800e17 	ldw	r2,56(r2)
 4001a64:	e0bffb15 	stw	r2,-20(fp)
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 4001a68:	e1bff617 	ldw	r6,-40(fp)
 4001a6c:	e17ff817 	ldw	r5,-32(fp)
 4001a70:	e13ffe17 	ldw	r4,-8(fp)
 4001a74:	40024300 	call	4002430 <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
 4001a78:	e0bffcc7 	ldb	r2,-13(fp)
 4001a7c:	10bfffd8 	cmpnei	r2,r2,-1
 4001a80:	10000e1e 	bne	r2,zero,4001abc <xQueueGenericSendFromISR+0xb8>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 4001a84:	e0bffe17 	ldw	r2,-8(fp)
 4001a88:	10800917 	ldw	r2,36(r2)
 4001a8c:	10001526 	beq	r2,zero,4001ae4 <xQueueGenericSendFromISR+0xe0>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 4001a90:	e0bffe17 	ldw	r2,-8(fp)
 4001a94:	10800904 	addi	r2,r2,36
 4001a98:	1009883a 	mov	r4,r2
 4001a9c:	40050240 	call	4005024 <xTaskRemoveFromEventList>
 4001aa0:	10001026 	beq	r2,zero,4001ae4 <xQueueGenericSendFromISR+0xe0>
                        {
                            /* The task waiting has a higher priority so record that a
                             * context switch is required. */
                            if( pxHigherPriorityTaskWoken != NULL )
 4001aa4:	e0bff717 	ldw	r2,-36(fp)
 4001aa8:	10000e26 	beq	r2,zero,4001ae4 <xQueueGenericSendFromISR+0xe0>
                            {
                                *pxHigherPriorityTaskWoken = pdTRUE;
 4001aac:	e0bff717 	ldw	r2,-36(fp)
 4001ab0:	00c00044 	movi	r3,1
 4001ab4:	10c00015 	stw	r3,0(r2)
 4001ab8:	00000a06 	br	4001ae4 <xQueueGenericSendFromISR+0xe0>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                prvIncrementQueueTxLock( pxQueue, cTxLock );
 4001abc:	4004a3c0 	call	4004a3c <uxTaskGetNumberOfTasks>
 4001ac0:	e0bffa15 	stw	r2,-24(fp)
 4001ac4:	e0fffcc7 	ldb	r3,-13(fp)
 4001ac8:	e0bffa17 	ldw	r2,-24(fp)
 4001acc:	1880052e 	bgeu	r3,r2,4001ae4 <xQueueGenericSendFromISR+0xe0>
 4001ad0:	e0bffcc3 	ldbu	r2,-13(fp)
 4001ad4:	10800044 	addi	r2,r2,1
 4001ad8:	1007883a 	mov	r3,r2
 4001adc:	e0bffe17 	ldw	r2,-8(fp)
 4001ae0:	10c01145 	stb	r3,69(r2)
            }

            xReturn = pdPASS;
 4001ae4:	00800044 	movi	r2,1
 4001ae8:	e0bfff15 	stw	r2,-4(fp)
        {
 4001aec:	00000106 	br	4001af4 <xQueueGenericSendFromISR+0xf0>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
 4001af0:	e03fff15 	stw	zero,-4(fp)
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 4001af4:	e0bfff17 	ldw	r2,-4(fp)
}
 4001af8:	e037883a 	mov	sp,fp
 4001afc:	dfc00117 	ldw	ra,4(sp)
 4001b00:	df000017 	ldw	fp,0(sp)
 4001b04:	dec00204 	addi	sp,sp,8
 4001b08:	f800283a 	ret

04001b0c <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
 4001b0c:	defff604 	addi	sp,sp,-40
 4001b10:	dfc00915 	stw	ra,36(sp)
 4001b14:	df000815 	stw	fp,32(sp)
 4001b18:	df000804 	addi	fp,sp,32
 4001b1c:	e13ff915 	stw	r4,-28(fp)
 4001b20:	e17ff815 	stw	r5,-32(fp)
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
 4001b24:	e0bff917 	ldw	r2,-28(fp)
 4001b28:	e0bffe15 	stw	r2,-8(fp)
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4001b2c:	e03ffd15 	stw	zero,-12(fp)
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 4001b30:	e0bffe17 	ldw	r2,-8(fp)
 4001b34:	10800e17 	ldw	r2,56(r2)
 4001b38:	e0bffc15 	stw	r2,-16(fp)

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
 4001b3c:	e0bffe17 	ldw	r2,-8(fp)
 4001b40:	10800f17 	ldw	r2,60(r2)
 4001b44:	e0fffc17 	ldw	r3,-16(fp)
 4001b48:	1880252e 	bgeu	r3,r2,4001be0 <xQueueGiveFromISR+0xd4>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
 4001b4c:	e0bffe17 	ldw	r2,-8(fp)
 4001b50:	10801143 	ldbu	r2,69(r2)
 4001b54:	e0bffbc5 	stb	r2,-17(fp)
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 4001b58:	e0bffc17 	ldw	r2,-16(fp)
 4001b5c:	10c00044 	addi	r3,r2,1
 4001b60:	e0bffe17 	ldw	r2,-8(fp)
 4001b64:	10c00e15 	stw	r3,56(r2)

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
 4001b68:	e0bffbc7 	ldb	r2,-17(fp)
 4001b6c:	10bfffd8 	cmpnei	r2,r2,-1
 4001b70:	10000e1e 	bne	r2,zero,4001bac <xQueueGiveFromISR+0xa0>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 4001b74:	e0bffe17 	ldw	r2,-8(fp)
 4001b78:	10800917 	ldw	r2,36(r2)
 4001b7c:	10001526 	beq	r2,zero,4001bd4 <xQueueGiveFromISR+0xc8>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 4001b80:	e0bffe17 	ldw	r2,-8(fp)
 4001b84:	10800904 	addi	r2,r2,36
 4001b88:	1009883a 	mov	r4,r2
 4001b8c:	40050240 	call	4005024 <xTaskRemoveFromEventList>
 4001b90:	10001026 	beq	r2,zero,4001bd4 <xQueueGiveFromISR+0xc8>
                        {
                            /* The task waiting has a higher priority so record that a
                             * context switch is required. */
                            if( pxHigherPriorityTaskWoken != NULL )
 4001b94:	e0bff817 	ldw	r2,-32(fp)
 4001b98:	10000e26 	beq	r2,zero,4001bd4 <xQueueGiveFromISR+0xc8>
                            {
                                *pxHigherPriorityTaskWoken = pdTRUE;
 4001b9c:	e0bff817 	ldw	r2,-32(fp)
 4001ba0:	00c00044 	movi	r3,1
 4001ba4:	10c00015 	stw	r3,0(r2)
 4001ba8:	00000a06 	br	4001bd4 <xQueueGiveFromISR+0xc8>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                prvIncrementQueueTxLock( pxQueue, cTxLock );
 4001bac:	4004a3c0 	call	4004a3c <uxTaskGetNumberOfTasks>
 4001bb0:	e0bffa15 	stw	r2,-24(fp)
 4001bb4:	e0fffbc7 	ldb	r3,-17(fp)
 4001bb8:	e0bffa17 	ldw	r2,-24(fp)
 4001bbc:	1880052e 	bgeu	r3,r2,4001bd4 <xQueueGiveFromISR+0xc8>
 4001bc0:	e0bffbc3 	ldbu	r2,-17(fp)
 4001bc4:	10800044 	addi	r2,r2,1
 4001bc8:	1007883a 	mov	r3,r2
 4001bcc:	e0bffe17 	ldw	r2,-8(fp)
 4001bd0:	10c01145 	stb	r3,69(r2)
            }

            xReturn = pdPASS;
 4001bd4:	00800044 	movi	r2,1
 4001bd8:	e0bfff15 	stw	r2,-4(fp)
 4001bdc:	00000106 	br	4001be4 <xQueueGiveFromISR+0xd8>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
 4001be0:	e03fff15 	stw	zero,-4(fp)
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 4001be4:	e0bfff17 	ldw	r2,-4(fp)
}
 4001be8:	e037883a 	mov	sp,fp
 4001bec:	dfc00117 	ldw	ra,4(sp)
 4001bf0:	df000017 	ldw	fp,0(sp)
 4001bf4:	dec00204 	addi	sp,sp,8
 4001bf8:	f800283a 	ret

04001bfc <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
 4001bfc:	defff604 	addi	sp,sp,-40
 4001c00:	dfc00915 	stw	ra,36(sp)
 4001c04:	df000815 	stw	fp,32(sp)
 4001c08:	df000804 	addi	fp,sp,32
 4001c0c:	e13ffa15 	stw	r4,-24(fp)
 4001c10:	e17ff915 	stw	r5,-28(fp)
 4001c14:	e1bff815 	stw	r6,-32(fp)
    BaseType_t xEntryTimeSet = pdFALSE;
 4001c18:	e03fff15 	stw	zero,-4(fp)
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
 4001c1c:	e0bffa17 	ldw	r2,-24(fp)
 4001c20:	e0bffe15 	stw	r2,-8(fp)
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
 4001c24:	4005f740 	call	4005f74 <vTaskEnterCritical>
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 4001c28:	e0bffe17 	ldw	r2,-8(fp)
 4001c2c:	10800e17 	ldw	r2,56(r2)
 4001c30:	e0bffd15 	stw	r2,-12(fp)

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 4001c34:	e0bffd17 	ldw	r2,-12(fp)
 4001c38:	10001326 	beq	r2,zero,4001c88 <xQueueReceive+0x8c>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
 4001c3c:	e17ff917 	ldw	r5,-28(fp)
 4001c40:	e13ffe17 	ldw	r4,-8(fp)
 4001c44:	40025bc0 	call	40025bc <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 4001c48:	e0bffd17 	ldw	r2,-12(fp)
 4001c4c:	10ffffc4 	addi	r3,r2,-1
 4001c50:	e0bffe17 	ldw	r2,-8(fp)
 4001c54:	10c00e15 	stw	r3,56(r2)

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 4001c58:	e0bffe17 	ldw	r2,-8(fp)
 4001c5c:	10800417 	ldw	r2,16(r2)
 4001c60:	10000626 	beq	r2,zero,4001c7c <xQueueReceive+0x80>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 4001c64:	e0bffe17 	ldw	r2,-8(fp)
 4001c68:	10800404 	addi	r2,r2,16
 4001c6c:	1009883a 	mov	r4,r2
 4001c70:	40050240 	call	4005024 <xTaskRemoveFromEventList>
 4001c74:	10000126 	beq	r2,zero,4001c7c <xQueueReceive+0x80>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
 4001c78:	003b683a 	trap	0
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
 4001c7c:	4005fc80 	call	4005fc8 <vTaskExitCritical>
                return pdPASS;
 4001c80:	00800044 	movi	r2,1
 4001c84:	00004206 	br	4001d90 <xQueueReceive+0x194>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
 4001c88:	e0bff817 	ldw	r2,-32(fp)
 4001c8c:	1000031e 	bne	r2,zero,4001c9c <xQueueReceive+0xa0>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
 4001c90:	4005fc80 	call	4005fc8 <vTaskExitCritical>
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
 4001c94:	0005883a 	mov	r2,zero
 4001c98:	00003d06 	br	4001d90 <xQueueReceive+0x194>
                }
                else if( xEntryTimeSet == pdFALSE )
 4001c9c:	e0bfff17 	ldw	r2,-4(fp)
 4001ca0:	1000051e 	bne	r2,zero,4001cb8 <xQueueReceive+0xbc>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
 4001ca4:	e0bffb04 	addi	r2,fp,-20
 4001ca8:	1009883a 	mov	r4,r2
 4001cac:	40055900 	call	4005590 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
 4001cb0:	00800044 	movi	r2,1
 4001cb4:	e0bfff15 	stw	r2,-4(fp)
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
 4001cb8:	4005fc80 	call	4005fc8 <vTaskExitCritical>

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
 4001cbc:	40046e80 	call	40046e8 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 4001cc0:	4005f740 	call	4005f74 <vTaskEnterCritical>
 4001cc4:	e0bffe17 	ldw	r2,-8(fp)
 4001cc8:	10801103 	ldbu	r2,68(r2)
 4001ccc:	10803fcc 	andi	r2,r2,255
 4001cd0:	1080201c 	xori	r2,r2,128
 4001cd4:	10bfe004 	addi	r2,r2,-128
 4001cd8:	10bfffd8 	cmpnei	r2,r2,-1
 4001cdc:	1000021e 	bne	r2,zero,4001ce8 <xQueueReceive+0xec>
 4001ce0:	e0bffe17 	ldw	r2,-8(fp)
 4001ce4:	10001105 	stb	zero,68(r2)
 4001ce8:	e0bffe17 	ldw	r2,-8(fp)
 4001cec:	10801143 	ldbu	r2,69(r2)
 4001cf0:	10803fcc 	andi	r2,r2,255
 4001cf4:	1080201c 	xori	r2,r2,128
 4001cf8:	10bfe004 	addi	r2,r2,-128
 4001cfc:	10bfffd8 	cmpnei	r2,r2,-1
 4001d00:	1000021e 	bne	r2,zero,4001d0c <xQueueReceive+0x110>
 4001d04:	e0bffe17 	ldw	r2,-8(fp)
 4001d08:	10001145 	stb	zero,69(r2)
 4001d0c:	4005fc80 	call	4005fc8 <vTaskExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 4001d10:	e0fff804 	addi	r3,fp,-32
 4001d14:	e0bffb04 	addi	r2,fp,-20
 4001d18:	180b883a 	mov	r5,r3
 4001d1c:	1009883a 	mov	r4,r2
 4001d20:	40055cc0 	call	40055cc <xTaskCheckForTimeOut>
 4001d24:	1000131e 	bne	r2,zero,4001d74 <xQueueReceive+0x178>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 4001d28:	e13ffe17 	ldw	r4,-8(fp)
 4001d2c:	400274c0 	call	400274c <prvIsQueueEmpty>
 4001d30:	10000c26 	beq	r2,zero,4001d64 <xQueueReceive+0x168>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 4001d34:	e0bffe17 	ldw	r2,-8(fp)
 4001d38:	10800904 	addi	r2,r2,36
 4001d3c:	e0fff817 	ldw	r3,-32(fp)
 4001d40:	180b883a 	mov	r5,r3
 4001d44:	1009883a 	mov	r4,r2
 4001d48:	4004f180 	call	4004f18 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
 4001d4c:	e13ffe17 	ldw	r4,-8(fp)
 4001d50:	40026580 	call	4002658 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
 4001d54:	40047140 	call	4004714 <xTaskResumeAll>
 4001d58:	103fb21e 	bne	r2,zero,4001c24 <xQueueReceive+0x28>
                {
                    portYIELD_WITHIN_API();
 4001d5c:	003b683a 	trap	0
 4001d60:	003fb006 	br	4001c24 <xQueueReceive+0x28>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
 4001d64:	e13ffe17 	ldw	r4,-8(fp)
 4001d68:	40026580 	call	4002658 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
 4001d6c:	40047140 	call	4004714 <xTaskResumeAll>
 4001d70:	003fac06 	br	4001c24 <xQueueReceive+0x28>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
 4001d74:	e13ffe17 	ldw	r4,-8(fp)
 4001d78:	40026580 	call	4002658 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
 4001d7c:	40047140 	call	4004714 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 4001d80:	e13ffe17 	ldw	r4,-8(fp)
 4001d84:	400274c0 	call	400274c <prvIsQueueEmpty>
 4001d88:	103fa626 	beq	r2,zero,4001c24 <xQueueReceive+0x28>
            {
                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
 4001d8c:	0005883a 	mov	r2,zero
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
 4001d90:	e037883a 	mov	sp,fp
 4001d94:	dfc00117 	ldw	ra,4(sp)
 4001d98:	df000017 	ldw	fp,0(sp)
 4001d9c:	dec00204 	addi	sp,sp,8
 4001da0:	f800283a 	ret

04001da4 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
 4001da4:	defff504 	addi	sp,sp,-44
 4001da8:	dfc00a15 	stw	ra,40(sp)
 4001dac:	df000915 	stw	fp,36(sp)
 4001db0:	df000904 	addi	fp,sp,36
 4001db4:	e13ff815 	stw	r4,-32(fp)
 4001db8:	e17ff715 	stw	r5,-36(fp)
    BaseType_t xEntryTimeSet = pdFALSE;
 4001dbc:	e03fff15 	stw	zero,-4(fp)
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
 4001dc0:	e0bff817 	ldw	r2,-32(fp)
 4001dc4:	e0bffd15 	stw	r2,-12(fp)

    #if ( configUSE_MUTEXES == 1 )
        BaseType_t xInheritanceOccurred = pdFALSE;
 4001dc8:	e03ffe15 	stw	zero,-8(fp)
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
 4001dcc:	4005f740 	call	4005f74 <vTaskEnterCritical>
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 4001dd0:	e0bffd17 	ldw	r2,-12(fp)
 4001dd4:	10800e17 	ldw	r2,56(r2)
 4001dd8:	e0bffc15 	stw	r2,-16(fp)

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 4001ddc:	e0bffc17 	ldw	r2,-16(fp)
 4001de0:	10001726 	beq	r2,zero,4001e40 <xQueueSemaphoreTake+0x9c>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
 4001de4:	e0bffc17 	ldw	r2,-16(fp)
 4001de8:	10ffffc4 	addi	r3,r2,-1
 4001dec:	e0bffd17 	ldw	r2,-12(fp)
 4001df0:	10c00e15 	stw	r3,56(r2)

                #if ( configUSE_MUTEXES == 1 )
                {
                    if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 4001df4:	e0bffd17 	ldw	r2,-12(fp)
 4001df8:	10800017 	ldw	r2,0(r2)
 4001dfc:	1000041e 	bne	r2,zero,4001e10 <xQueueSemaphoreTake+0x6c>
                    {
                        /* Record the information required to implement
                         * priority inheritance should it become necessary. */
                        pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
 4001e00:	40060700 	call	4006070 <pvTaskIncrementMutexHeldCount>
 4001e04:	1007883a 	mov	r3,r2
 4001e08:	e0bffd17 	ldw	r2,-12(fp)
 4001e0c:	10c00215 	stw	r3,8(r2)
                }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 4001e10:	e0bffd17 	ldw	r2,-12(fp)
 4001e14:	10800417 	ldw	r2,16(r2)
 4001e18:	10000626 	beq	r2,zero,4001e34 <xQueueSemaphoreTake+0x90>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 4001e1c:	e0bffd17 	ldw	r2,-12(fp)
 4001e20:	10800404 	addi	r2,r2,16
 4001e24:	1009883a 	mov	r4,r2
 4001e28:	40050240 	call	4005024 <xTaskRemoveFromEventList>
 4001e2c:	10000126 	beq	r2,zero,4001e34 <xQueueSemaphoreTake+0x90>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
 4001e30:	003b683a 	trap	0
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
 4001e34:	4005fc80 	call	4005fc8 <vTaskExitCritical>
                return pdPASS;
 4001e38:	00800044 	movi	r2,1
 4001e3c:	00005806 	br	4001fa0 <xQueueSemaphoreTake+0x1fc>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
 4001e40:	e0bff717 	ldw	r2,-36(fp)
 4001e44:	1000031e 	bne	r2,zero,4001e54 <xQueueSemaphoreTake+0xb0>
                {
                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
 4001e48:	4005fc80 	call	4005fc8 <vTaskExitCritical>
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
 4001e4c:	0005883a 	mov	r2,zero
 4001e50:	00005306 	br	4001fa0 <xQueueSemaphoreTake+0x1fc>
                }
                else if( xEntryTimeSet == pdFALSE )
 4001e54:	e0bfff17 	ldw	r2,-4(fp)
 4001e58:	1000051e 	bne	r2,zero,4001e70 <xQueueSemaphoreTake+0xcc>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
 4001e5c:	e0bff904 	addi	r2,fp,-28
 4001e60:	1009883a 	mov	r4,r2
 4001e64:	40055900 	call	4005590 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
 4001e68:	00800044 	movi	r2,1
 4001e6c:	e0bfff15 	stw	r2,-4(fp)
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
 4001e70:	4005fc80 	call	4005fc8 <vTaskExitCritical>

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
 4001e74:	40046e80 	call	40046e8 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 4001e78:	4005f740 	call	4005f74 <vTaskEnterCritical>
 4001e7c:	e0bffd17 	ldw	r2,-12(fp)
 4001e80:	10801103 	ldbu	r2,68(r2)
 4001e84:	10803fcc 	andi	r2,r2,255
 4001e88:	1080201c 	xori	r2,r2,128
 4001e8c:	10bfe004 	addi	r2,r2,-128
 4001e90:	10bfffd8 	cmpnei	r2,r2,-1
 4001e94:	1000021e 	bne	r2,zero,4001ea0 <xQueueSemaphoreTake+0xfc>
 4001e98:	e0bffd17 	ldw	r2,-12(fp)
 4001e9c:	10001105 	stb	zero,68(r2)
 4001ea0:	e0bffd17 	ldw	r2,-12(fp)
 4001ea4:	10801143 	ldbu	r2,69(r2)
 4001ea8:	10803fcc 	andi	r2,r2,255
 4001eac:	1080201c 	xori	r2,r2,128
 4001eb0:	10bfe004 	addi	r2,r2,-128
 4001eb4:	10bfffd8 	cmpnei	r2,r2,-1
 4001eb8:	1000021e 	bne	r2,zero,4001ec4 <xQueueSemaphoreTake+0x120>
 4001ebc:	e0bffd17 	ldw	r2,-12(fp)
 4001ec0:	10001145 	stb	zero,69(r2)
 4001ec4:	4005fc80 	call	4005fc8 <vTaskExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 4001ec8:	e0fff704 	addi	r3,fp,-36
 4001ecc:	e0bff904 	addi	r2,fp,-28
 4001ed0:	180b883a 	mov	r5,r3
 4001ed4:	1009883a 	mov	r4,r2
 4001ed8:	40055cc0 	call	40055cc <xTaskCheckForTimeOut>
 4001edc:	10001d1e 	bne	r2,zero,4001f54 <xQueueSemaphoreTake+0x1b0>
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 4001ee0:	e13ffd17 	ldw	r4,-12(fp)
 4001ee4:	400274c0 	call	400274c <prvIsQueueEmpty>
 4001ee8:	10001626 	beq	r2,zero,4001f44 <xQueueSemaphoreTake+0x1a0>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

                #if ( configUSE_MUTEXES == 1 )
                {
                    if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 4001eec:	e0bffd17 	ldw	r2,-12(fp)
 4001ef0:	10800017 	ldw	r2,0(r2)
 4001ef4:	1000071e 	bne	r2,zero,4001f14 <xQueueSemaphoreTake+0x170>
                    {
                        taskENTER_CRITICAL();
 4001ef8:	4005f740 	call	4005f74 <vTaskEnterCritical>
                        {
                            xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
 4001efc:	e0bffd17 	ldw	r2,-12(fp)
 4001f00:	10800217 	ldw	r2,8(r2)
 4001f04:	1009883a 	mov	r4,r2
 4001f08:	40059b00 	call	40059b0 <xTaskPriorityInherit>
 4001f0c:	e0bffe15 	stw	r2,-8(fp)
                        }
                        taskEXIT_CRITICAL();
 4001f10:	4005fc80 	call	4005fc8 <vTaskExitCritical>
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 4001f14:	e0bffd17 	ldw	r2,-12(fp)
 4001f18:	10800904 	addi	r2,r2,36
 4001f1c:	e0fff717 	ldw	r3,-36(fp)
 4001f20:	180b883a 	mov	r5,r3
 4001f24:	1009883a 	mov	r4,r2
 4001f28:	4004f180 	call	4004f18 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
 4001f2c:	e13ffd17 	ldw	r4,-12(fp)
 4001f30:	40026580 	call	4002658 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
 4001f34:	40047140 	call	4004714 <xTaskResumeAll>
 4001f38:	103fa41e 	bne	r2,zero,4001dcc <xQueueSemaphoreTake+0x28>
                {
                    portYIELD_WITHIN_API();
 4001f3c:	003b683a 	trap	0
 4001f40:	003fa206 	br	4001dcc <xQueueSemaphoreTake+0x28>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
 4001f44:	e13ffd17 	ldw	r4,-12(fp)
 4001f48:	40026580 	call	4002658 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
 4001f4c:	40047140 	call	4004714 <xTaskResumeAll>
 4001f50:	003f9e06 	br	4001dcc <xQueueSemaphoreTake+0x28>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
 4001f54:	e13ffd17 	ldw	r4,-12(fp)
 4001f58:	40026580 	call	4002658 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
 4001f5c:	40047140 	call	4004714 <xTaskResumeAll>

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 4001f60:	e13ffd17 	ldw	r4,-12(fp)
 4001f64:	400274c0 	call	400274c <prvIsQueueEmpty>
 4001f68:	103f9826 	beq	r2,zero,4001dcc <xQueueSemaphoreTake+0x28>
                #if ( configUSE_MUTEXES == 1 )
                {
                    /* xInheritanceOccurred could only have be set if
                     * pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
                     * test the mutex type again to check it is actually a mutex. */
                    if( xInheritanceOccurred != pdFALSE )
 4001f6c:	e0bffe17 	ldw	r2,-8(fp)
 4001f70:	10000a26 	beq	r2,zero,4001f9c <xQueueSemaphoreTake+0x1f8>
                    {
                        taskENTER_CRITICAL();
 4001f74:	4005f740 	call	4005f74 <vTaskEnterCritical>
                            /* This task blocking on the mutex caused another
                             * task to inherit this task's priority.  Now this task
                             * has timed out the priority should be disinherited
                             * again, but only as low as the next highest priority
                             * task that is waiting for the same mutex. */
                            uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
 4001f78:	e13ffd17 	ldw	r4,-12(fp)
 4001f7c:	40023e00 	call	40023e0 <prvGetDisinheritPriorityAfterTimeout>
 4001f80:	e0bffb15 	stw	r2,-20(fp)
                            vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
 4001f84:	e0bffd17 	ldw	r2,-12(fp)
 4001f88:	10800217 	ldw	r2,8(r2)
 4001f8c:	e17ffb17 	ldw	r5,-20(fp)
 4001f90:	1009883a 	mov	r4,r2
 4001f94:	4005d700 	call	4005d70 <vTaskPriorityDisinheritAfterTimeout>
                        }
                        taskEXIT_CRITICAL();
 4001f98:	4005fc80 	call	4005fc8 <vTaskExitCritical>
                    }
                }
                #endif /* configUSE_MUTEXES */

                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
 4001f9c:	0005883a 	mov	r2,zero
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
 4001fa0:	e037883a 	mov	sp,fp
 4001fa4:	dfc00117 	ldw	ra,4(sp)
 4001fa8:	df000017 	ldw	fp,0(sp)
 4001fac:	dec00204 	addi	sp,sp,8
 4001fb0:	f800283a 	ret

04001fb4 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
 4001fb4:	defff504 	addi	sp,sp,-44
 4001fb8:	dfc00a15 	stw	ra,40(sp)
 4001fbc:	df000915 	stw	fp,36(sp)
 4001fc0:	df000904 	addi	fp,sp,36
 4001fc4:	e13ff915 	stw	r4,-28(fp)
 4001fc8:	e17ff815 	stw	r5,-32(fp)
 4001fcc:	e1bff715 	stw	r6,-36(fp)
    BaseType_t xEntryTimeSet = pdFALSE;
 4001fd0:	e03fff15 	stw	zero,-4(fp)
    TimeOut_t xTimeOut;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
 4001fd4:	e0bff917 	ldw	r2,-28(fp)
 4001fd8:	e0bffe15 	stw	r2,-8(fp)
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
 4001fdc:	4005f740 	call	4005f74 <vTaskEnterCritical>
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 4001fe0:	e0bffe17 	ldw	r2,-8(fp)
 4001fe4:	10800e17 	ldw	r2,56(r2)
 4001fe8:	e0bffd15 	stw	r2,-12(fp)

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 4001fec:	e0bffd17 	ldw	r2,-12(fp)
 4001ff0:	10001526 	beq	r2,zero,4002048 <xQueuePeek+0x94>
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 4001ff4:	e0bffe17 	ldw	r2,-8(fp)
 4001ff8:	10800317 	ldw	r2,12(r2)
 4001ffc:	e0bffc15 	stw	r2,-16(fp)

                prvCopyDataFromQueue( pxQueue, pvBuffer );
 4002000:	e17ff817 	ldw	r5,-32(fp)
 4002004:	e13ffe17 	ldw	r4,-8(fp)
 4002008:	40025bc0 	call	40025bc <prvCopyDataFromQueue>
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 400200c:	e0bffe17 	ldw	r2,-8(fp)
 4002010:	e0fffc17 	ldw	r3,-16(fp)
 4002014:	10c00315 	stw	r3,12(r2)

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 4002018:	e0bffe17 	ldw	r2,-8(fp)
 400201c:	10800917 	ldw	r2,36(r2)
 4002020:	10000626 	beq	r2,zero,400203c <xQueuePeek+0x88>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 4002024:	e0bffe17 	ldw	r2,-8(fp)
 4002028:	10800904 	addi	r2,r2,36
 400202c:	1009883a 	mov	r4,r2
 4002030:	40050240 	call	4005024 <xTaskRemoveFromEventList>
 4002034:	10000126 	beq	r2,zero,400203c <xQueuePeek+0x88>
                    {
                        /* The task waiting has a higher priority than this task. */
                        queueYIELD_IF_USING_PREEMPTION();
 4002038:	003b683a 	trap	0
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
 400203c:	4005fc80 	call	4005fc8 <vTaskExitCritical>
                return pdPASS;
 4002040:	00800044 	movi	r2,1
 4002044:	00004206 	br	4002150 <xQueuePeek+0x19c>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
 4002048:	e0bff717 	ldw	r2,-36(fp)
 400204c:	1000031e 	bne	r2,zero,400205c <xQueuePeek+0xa8>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
 4002050:	4005fc80 	call	4005fc8 <vTaskExitCritical>
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
 4002054:	0005883a 	mov	r2,zero
 4002058:	00003d06 	br	4002150 <xQueuePeek+0x19c>
                }
                else if( xEntryTimeSet == pdFALSE )
 400205c:	e0bfff17 	ldw	r2,-4(fp)
 4002060:	1000051e 	bne	r2,zero,4002078 <xQueuePeek+0xc4>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
 4002064:	e0bffa04 	addi	r2,fp,-24
 4002068:	1009883a 	mov	r4,r2
 400206c:	40055900 	call	4005590 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
 4002070:	00800044 	movi	r2,1
 4002074:	e0bfff15 	stw	r2,-4(fp)
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
 4002078:	4005fc80 	call	4005fc8 <vTaskExitCritical>

        /* Interrupts and other tasks can send to and receive from the queue
         * now that the critical section has been exited. */

        vTaskSuspendAll();
 400207c:	40046e80 	call	40046e8 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 4002080:	4005f740 	call	4005f74 <vTaskEnterCritical>
 4002084:	e0bffe17 	ldw	r2,-8(fp)
 4002088:	10801103 	ldbu	r2,68(r2)
 400208c:	10803fcc 	andi	r2,r2,255
 4002090:	1080201c 	xori	r2,r2,128
 4002094:	10bfe004 	addi	r2,r2,-128
 4002098:	10bfffd8 	cmpnei	r2,r2,-1
 400209c:	1000021e 	bne	r2,zero,40020a8 <xQueuePeek+0xf4>
 40020a0:	e0bffe17 	ldw	r2,-8(fp)
 40020a4:	10001105 	stb	zero,68(r2)
 40020a8:	e0bffe17 	ldw	r2,-8(fp)
 40020ac:	10801143 	ldbu	r2,69(r2)
 40020b0:	10803fcc 	andi	r2,r2,255
 40020b4:	1080201c 	xori	r2,r2,128
 40020b8:	10bfe004 	addi	r2,r2,-128
 40020bc:	10bfffd8 	cmpnei	r2,r2,-1
 40020c0:	1000021e 	bne	r2,zero,40020cc <xQueuePeek+0x118>
 40020c4:	e0bffe17 	ldw	r2,-8(fp)
 40020c8:	10001145 	stb	zero,69(r2)
 40020cc:	4005fc80 	call	4005fc8 <vTaskExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 40020d0:	e0fff704 	addi	r3,fp,-36
 40020d4:	e0bffa04 	addi	r2,fp,-24
 40020d8:	180b883a 	mov	r5,r3
 40020dc:	1009883a 	mov	r4,r2
 40020e0:	40055cc0 	call	40055cc <xTaskCheckForTimeOut>
 40020e4:	1000131e 	bne	r2,zero,4002134 <xQueuePeek+0x180>
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 40020e8:	e13ffe17 	ldw	r4,-8(fp)
 40020ec:	400274c0 	call	400274c <prvIsQueueEmpty>
 40020f0:	10000c26 	beq	r2,zero,4002124 <xQueuePeek+0x170>
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 40020f4:	e0bffe17 	ldw	r2,-8(fp)
 40020f8:	10800904 	addi	r2,r2,36
 40020fc:	e0fff717 	ldw	r3,-36(fp)
 4002100:	180b883a 	mov	r5,r3
 4002104:	1009883a 	mov	r4,r2
 4002108:	4004f180 	call	4004f18 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
 400210c:	e13ffe17 	ldw	r4,-8(fp)
 4002110:	40026580 	call	4002658 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
 4002114:	40047140 	call	4004714 <xTaskResumeAll>
 4002118:	103fb01e 	bne	r2,zero,4001fdc <xQueuePeek+0x28>
                {
                    portYIELD_WITHIN_API();
 400211c:	003b683a 	trap	0
 4002120:	003fae06 	br	4001fdc <xQueuePeek+0x28>
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
 4002124:	e13ffe17 	ldw	r4,-8(fp)
 4002128:	40026580 	call	4002658 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
 400212c:	40047140 	call	4004714 <xTaskResumeAll>
 4002130:	003faa06 	br	4001fdc <xQueuePeek+0x28>
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
 4002134:	e13ffe17 	ldw	r4,-8(fp)
 4002138:	40026580 	call	4002658 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
 400213c:	40047140 	call	4004714 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 4002140:	e13ffe17 	ldw	r4,-8(fp)
 4002144:	400274c0 	call	400274c <prvIsQueueEmpty>
 4002148:	103fa426 	beq	r2,zero,4001fdc <xQueuePeek+0x28>
            {
                traceQUEUE_PEEK_FAILED( pxQueue );
                return errQUEUE_EMPTY;
 400214c:	0005883a 	mov	r2,zero
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
 4002150:	e037883a 	mov	sp,fp
 4002154:	dfc00117 	ldw	ra,4(sp)
 4002158:	df000017 	ldw	fp,0(sp)
 400215c:	dec00204 	addi	sp,sp,8
 4002160:	f800283a 	ret

04002164 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
 4002164:	defff504 	addi	sp,sp,-44
 4002168:	dfc00a15 	stw	ra,40(sp)
 400216c:	df000915 	stw	fp,36(sp)
 4002170:	df000904 	addi	fp,sp,36
 4002174:	e13ff915 	stw	r4,-28(fp)
 4002178:	e17ff815 	stw	r5,-32(fp)
 400217c:	e1bff715 	stw	r6,-36(fp)
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
 4002180:	e0bff917 	ldw	r2,-28(fp)
 4002184:	e0bffe15 	stw	r2,-8(fp)
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4002188:	e03ffd15 	stw	zero,-12(fp)
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 400218c:	e0bffe17 	ldw	r2,-8(fp)
 4002190:	10800e17 	ldw	r2,56(r2)
 4002194:	e0bffc15 	stw	r2,-16(fp)

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 4002198:	e0bffc17 	ldw	r2,-16(fp)
 400219c:	10002826 	beq	r2,zero,4002240 <xQueueReceiveFromISR+0xdc>
        {
            const int8_t cRxLock = pxQueue->cRxLock;
 40021a0:	e0bffe17 	ldw	r2,-8(fp)
 40021a4:	10801103 	ldbu	r2,68(r2)
 40021a8:	e0bffbc5 	stb	r2,-17(fp)

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
 40021ac:	e17ff817 	ldw	r5,-32(fp)
 40021b0:	e13ffe17 	ldw	r4,-8(fp)
 40021b4:	40025bc0 	call	40025bc <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 40021b8:	e0bffc17 	ldw	r2,-16(fp)
 40021bc:	10ffffc4 	addi	r3,r2,-1
 40021c0:	e0bffe17 	ldw	r2,-8(fp)
 40021c4:	10c00e15 	stw	r3,56(r2)

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
 40021c8:	e0bffbc7 	ldb	r2,-17(fp)
 40021cc:	10bfffd8 	cmpnei	r2,r2,-1
 40021d0:	10000e1e 	bne	r2,zero,400220c <xQueueReceiveFromISR+0xa8>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 40021d4:	e0bffe17 	ldw	r2,-8(fp)
 40021d8:	10800417 	ldw	r2,16(r2)
 40021dc:	10001526 	beq	r2,zero,4002234 <xQueueReceiveFromISR+0xd0>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 40021e0:	e0bffe17 	ldw	r2,-8(fp)
 40021e4:	10800404 	addi	r2,r2,16
 40021e8:	1009883a 	mov	r4,r2
 40021ec:	40050240 	call	4005024 <xTaskRemoveFromEventList>
 40021f0:	10001026 	beq	r2,zero,4002234 <xQueueReceiveFromISR+0xd0>
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
 40021f4:	e0bff717 	ldw	r2,-36(fp)
 40021f8:	10000e26 	beq	r2,zero,4002234 <xQueueReceiveFromISR+0xd0>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
 40021fc:	e0bff717 	ldw	r2,-36(fp)
 4002200:	00c00044 	movi	r3,1
 4002204:	10c00015 	stw	r3,0(r2)
 4002208:	00000a06 	br	4002234 <xQueueReceiveFromISR+0xd0>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                prvIncrementQueueRxLock( pxQueue, cRxLock );
 400220c:	4004a3c0 	call	4004a3c <uxTaskGetNumberOfTasks>
 4002210:	e0bffa15 	stw	r2,-24(fp)
 4002214:	e0fffbc7 	ldb	r3,-17(fp)
 4002218:	e0bffa17 	ldw	r2,-24(fp)
 400221c:	1880052e 	bgeu	r3,r2,4002234 <xQueueReceiveFromISR+0xd0>
 4002220:	e0bffbc3 	ldbu	r2,-17(fp)
 4002224:	10800044 	addi	r2,r2,1
 4002228:	1007883a 	mov	r3,r2
 400222c:	e0bffe17 	ldw	r2,-8(fp)
 4002230:	10c01105 	stb	r3,68(r2)
            }

            xReturn = pdPASS;
 4002234:	00800044 	movi	r2,1
 4002238:	e0bfff15 	stw	r2,-4(fp)
 400223c:	00000106 	br	4002244 <xQueueReceiveFromISR+0xe0>
        }
        else
        {
            xReturn = pdFAIL;
 4002240:	e03fff15 	stw	zero,-4(fp)
            traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 4002244:	e0bfff17 	ldw	r2,-4(fp)
}
 4002248:	e037883a 	mov	sp,fp
 400224c:	dfc00117 	ldw	ra,4(sp)
 4002250:	df000017 	ldw	fp,0(sp)
 4002254:	dec00204 	addi	sp,sp,8
 4002258:	f800283a 	ret

0400225c <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
 400225c:	defff804 	addi	sp,sp,-32
 4002260:	dfc00715 	stw	ra,28(sp)
 4002264:	df000615 	stw	fp,24(sp)
 4002268:	df000604 	addi	fp,sp,24
 400226c:	e13ffb15 	stw	r4,-20(fp)
 4002270:	e17ffa15 	stw	r5,-24(fp)
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
 4002274:	e0bffb17 	ldw	r2,-20(fp)
 4002278:	e0bffe15 	stw	r2,-8(fp)
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 400227c:	e03ffd15 	stw	zero,-12(fp)
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 4002280:	e0bffe17 	ldw	r2,-8(fp)
 4002284:	10800e17 	ldw	r2,56(r2)
 4002288:	10000c26 	beq	r2,zero,40022bc <xQueuePeekFromISR+0x60>
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 400228c:	e0bffe17 	ldw	r2,-8(fp)
 4002290:	10800317 	ldw	r2,12(r2)
 4002294:	e0bffc15 	stw	r2,-16(fp)
            prvCopyDataFromQueue( pxQueue, pvBuffer );
 4002298:	e17ffa17 	ldw	r5,-24(fp)
 400229c:	e13ffe17 	ldw	r4,-8(fp)
 40022a0:	40025bc0 	call	40025bc <prvCopyDataFromQueue>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 40022a4:	e0bffe17 	ldw	r2,-8(fp)
 40022a8:	e0fffc17 	ldw	r3,-16(fp)
 40022ac:	10c00315 	stw	r3,12(r2)

            xReturn = pdPASS;
 40022b0:	00800044 	movi	r2,1
 40022b4:	e0bfff15 	stw	r2,-4(fp)
 40022b8:	00000106 	br	40022c0 <xQueuePeekFromISR+0x64>
        }
        else
        {
            xReturn = pdFAIL;
 40022bc:	e03fff15 	stw	zero,-4(fp)
            traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 40022c0:	e0bfff17 	ldw	r2,-4(fp)
}
 40022c4:	e037883a 	mov	sp,fp
 40022c8:	dfc00117 	ldw	ra,4(sp)
 40022cc:	df000017 	ldw	fp,0(sp)
 40022d0:	dec00204 	addi	sp,sp,8
 40022d4:	f800283a 	ret

040022d8 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
 40022d8:	defffc04 	addi	sp,sp,-16
 40022dc:	dfc00315 	stw	ra,12(sp)
 40022e0:	df000215 	stw	fp,8(sp)
 40022e4:	df000204 	addi	fp,sp,8
 40022e8:	e13ffe15 	stw	r4,-8(fp)
    UBaseType_t uxReturn;

    configASSERT( xQueue );

    taskENTER_CRITICAL();
 40022ec:	4005f740 	call	4005f74 <vTaskEnterCritical>
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 40022f0:	e0bffe17 	ldw	r2,-8(fp)
 40022f4:	10800e17 	ldw	r2,56(r2)
 40022f8:	e0bfff15 	stw	r2,-4(fp)
    }
    taskEXIT_CRITICAL();
 40022fc:	4005fc80 	call	4005fc8 <vTaskExitCritical>

    return uxReturn;
 4002300:	e0bfff17 	ldw	r2,-4(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 4002304:	e037883a 	mov	sp,fp
 4002308:	dfc00117 	ldw	ra,4(sp)
 400230c:	df000017 	ldw	fp,0(sp)
 4002310:	dec00204 	addi	sp,sp,8
 4002314:	f800283a 	ret

04002318 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
 4002318:	defffb04 	addi	sp,sp,-20
 400231c:	dfc00415 	stw	ra,16(sp)
 4002320:	df000315 	stw	fp,12(sp)
 4002324:	df000304 	addi	fp,sp,12
 4002328:	e13ffd15 	stw	r4,-12(fp)
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
 400232c:	e0bffd17 	ldw	r2,-12(fp)
 4002330:	e0bfff15 	stw	r2,-4(fp)

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
 4002334:	4005f740 	call	4005f74 <vTaskEnterCritical>
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
 4002338:	e0bfff17 	ldw	r2,-4(fp)
 400233c:	10c00f17 	ldw	r3,60(r2)
 4002340:	e0bfff17 	ldw	r2,-4(fp)
 4002344:	10800e17 	ldw	r2,56(r2)
 4002348:	1885c83a 	sub	r2,r3,r2
 400234c:	e0bffe15 	stw	r2,-8(fp)
    }
    taskEXIT_CRITICAL();
 4002350:	4005fc80 	call	4005fc8 <vTaskExitCritical>

    return uxReturn;
 4002354:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 4002358:	e037883a 	mov	sp,fp
 400235c:	dfc00117 	ldw	ra,4(sp)
 4002360:	df000017 	ldw	fp,0(sp)
 4002364:	dec00204 	addi	sp,sp,8
 4002368:	f800283a 	ret

0400236c <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
 400236c:	defffc04 	addi	sp,sp,-16
 4002370:	df000315 	stw	fp,12(sp)
 4002374:	df000304 	addi	fp,sp,12
 4002378:	e13ffd15 	stw	r4,-12(fp)
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
 400237c:	e0bffd17 	ldw	r2,-12(fp)
 4002380:	e0bfff15 	stw	r2,-4(fp)

    configASSERT( pxQueue );
    uxReturn = pxQueue->uxMessagesWaiting;
 4002384:	e0bfff17 	ldw	r2,-4(fp)
 4002388:	10800e17 	ldw	r2,56(r2)
 400238c:	e0bffe15 	stw	r2,-8(fp)

    return uxReturn;
 4002390:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 4002394:	e037883a 	mov	sp,fp
 4002398:	df000017 	ldw	fp,0(sp)
 400239c:	dec00104 	addi	sp,sp,4
 40023a0:	f800283a 	ret

040023a4 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
 40023a4:	defffc04 	addi	sp,sp,-16
 40023a8:	dfc00315 	stw	ra,12(sp)
 40023ac:	df000215 	stw	fp,8(sp)
 40023b0:	df000204 	addi	fp,sp,8
 40023b4:	e13ffe15 	stw	r4,-8(fp)
    Queue_t * const pxQueue = xQueue;
 40023b8:	e0bffe17 	ldw	r2,-8(fp)
 40023bc:	e0bfff15 	stw	r2,-4(fp)

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
    {
        /* The queue can only have been allocated dynamically - free it
         * again. */
        vPortFree( pxQueue );
 40023c0:	e13fff17 	ldw	r4,-4(fp)
 40023c4:	400111c0 	call	400111c <vPortFree>
        /* The queue must have been statically allocated, so is not going to be
         * deleted.  Avoid compiler warnings about the unused parameter. */
        ( void ) pxQueue;
    }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
 40023c8:	0001883a 	nop
 40023cc:	e037883a 	mov	sp,fp
 40023d0:	dfc00117 	ldw	ra,4(sp)
 40023d4:	df000017 	ldw	fp,0(sp)
 40023d8:	dec00204 	addi	sp,sp,8
 40023dc:	f800283a 	ret

040023e0 <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
    {
 40023e0:	defffd04 	addi	sp,sp,-12
 40023e4:	df000215 	stw	fp,8(sp)
 40023e8:	df000204 	addi	fp,sp,8
 40023ec:	e13ffe15 	stw	r4,-8(fp)
         * priority, but the waiting task times out, then the holder should
         * disinherit the priority - but only down to the highest priority of any
         * other tasks that are waiting for the same mutex.  For this purpose,
         * return the priority of the highest priority task that is waiting for the
         * mutex. */
        if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
 40023f0:	e0bffe17 	ldw	r2,-8(fp)
 40023f4:	10800917 	ldw	r2,36(r2)
 40023f8:	10000726 	beq	r2,zero,4002418 <prvGetDisinheritPriorityAfterTimeout+0x38>
        {
            uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
 40023fc:	e0bffe17 	ldw	r2,-8(fp)
 4002400:	10800c17 	ldw	r2,48(r2)
 4002404:	10800017 	ldw	r2,0(r2)
 4002408:	00c00144 	movi	r3,5
 400240c:	1885c83a 	sub	r2,r3,r2
 4002410:	e0bfff15 	stw	r2,-4(fp)
 4002414:	00000106 	br	400241c <prvGetDisinheritPriorityAfterTimeout+0x3c>
        }
        else
        {
            uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
 4002418:	e03fff15 	stw	zero,-4(fp)
        }

        return uxHighestPriorityOfWaitingTasks;
 400241c:	e0bfff17 	ldw	r2,-4(fp)
    }
 4002420:	e037883a 	mov	sp,fp
 4002424:	df000017 	ldw	fp,0(sp)
 4002428:	dec00104 	addi	sp,sp,4
 400242c:	f800283a 	ret

04002430 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
 4002430:	defff904 	addi	sp,sp,-28
 4002434:	dfc00615 	stw	ra,24(sp)
 4002438:	df000515 	stw	fp,20(sp)
 400243c:	df000504 	addi	fp,sp,20
 4002440:	e13ffd15 	stw	r4,-12(fp)
 4002444:	e17ffc15 	stw	r5,-16(fp)
 4002448:	e1bffb15 	stw	r6,-20(fp)
    BaseType_t xReturn = pdFALSE;
 400244c:	e03fff15 	stw	zero,-4(fp)
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 4002450:	e0bffd17 	ldw	r2,-12(fp)
 4002454:	10800e17 	ldw	r2,56(r2)
 4002458:	e0bffe15 	stw	r2,-8(fp)

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 400245c:	e0bffd17 	ldw	r2,-12(fp)
 4002460:	10801017 	ldw	r2,64(r2)
 4002464:	10000b1e 	bne	r2,zero,4002494 <prvCopyDataToQueue+0x64>
    {
        #if ( configUSE_MUTEXES == 1 )
        {
            if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 4002468:	e0bffd17 	ldw	r2,-12(fp)
 400246c:	10800017 	ldw	r2,0(r2)
 4002470:	1000481e 	bne	r2,zero,4002594 <prvCopyDataToQueue+0x164>
            {
                /* The mutex is no longer being held. */
                xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
 4002474:	e0bffd17 	ldw	r2,-12(fp)
 4002478:	10800217 	ldw	r2,8(r2)
 400247c:	1009883a 	mov	r4,r2
 4002480:	4005bb80 	call	4005bb8 <xTaskPriorityDisinherit>
 4002484:	e0bfff15 	stw	r2,-4(fp)
                pxQueue->u.xSemaphore.xMutexHolder = NULL;
 4002488:	e0bffd17 	ldw	r2,-12(fp)
 400248c:	10000215 	stw	zero,8(r2)
 4002490:	00004006 	br	4002594 <prvCopyDataToQueue+0x164>
                mtCOVERAGE_TEST_MARKER();
            }
        }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
 4002494:	e0bffb17 	ldw	r2,-20(fp)
 4002498:	1000191e 	bne	r2,zero,4002500 <prvCopyDataToQueue+0xd0>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 400249c:	e0bffd17 	ldw	r2,-12(fp)
 40024a0:	10c00117 	ldw	r3,4(r2)
 40024a4:	e0bffd17 	ldw	r2,-12(fp)
 40024a8:	10801017 	ldw	r2,64(r2)
 40024ac:	100d883a 	mov	r6,r2
 40024b0:	e17ffc17 	ldw	r5,-16(fp)
 40024b4:	1809883a 	mov	r4,r3
 40024b8:	40073000 	call	4007300 <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 40024bc:	e0bffd17 	ldw	r2,-12(fp)
 40024c0:	10c00117 	ldw	r3,4(r2)
 40024c4:	e0bffd17 	ldw	r2,-12(fp)
 40024c8:	10801017 	ldw	r2,64(r2)
 40024cc:	1887883a 	add	r3,r3,r2
 40024d0:	e0bffd17 	ldw	r2,-12(fp)
 40024d4:	10c00115 	stw	r3,4(r2)

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 40024d8:	e0bffd17 	ldw	r2,-12(fp)
 40024dc:	10c00117 	ldw	r3,4(r2)
 40024e0:	e0bffd17 	ldw	r2,-12(fp)
 40024e4:	10800217 	ldw	r2,8(r2)
 40024e8:	18802a36 	bltu	r3,r2,4002594 <prvCopyDataToQueue+0x164>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
 40024ec:	e0bffd17 	ldw	r2,-12(fp)
 40024f0:	10c00017 	ldw	r3,0(r2)
 40024f4:	e0bffd17 	ldw	r2,-12(fp)
 40024f8:	10c00115 	stw	r3,4(r2)
 40024fc:	00002506 	br	4002594 <prvCopyDataToQueue+0x164>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
 4002500:	e0bffd17 	ldw	r2,-12(fp)
 4002504:	10c00317 	ldw	r3,12(r2)
 4002508:	e0bffd17 	ldw	r2,-12(fp)
 400250c:	10801017 	ldw	r2,64(r2)
 4002510:	100d883a 	mov	r6,r2
 4002514:	e17ffc17 	ldw	r5,-16(fp)
 4002518:	1809883a 	mov	r4,r3
 400251c:	40073000 	call	4007300 <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 4002520:	e0bffd17 	ldw	r2,-12(fp)
 4002524:	10c00317 	ldw	r3,12(r2)
 4002528:	e0bffd17 	ldw	r2,-12(fp)
 400252c:	10801017 	ldw	r2,64(r2)
 4002530:	0085c83a 	sub	r2,zero,r2
 4002534:	1887883a 	add	r3,r3,r2
 4002538:	e0bffd17 	ldw	r2,-12(fp)
 400253c:	10c00315 	stw	r3,12(r2)

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 4002540:	e0bffd17 	ldw	r2,-12(fp)
 4002544:	10c00317 	ldw	r3,12(r2)
 4002548:	e0bffd17 	ldw	r2,-12(fp)
 400254c:	10800017 	ldw	r2,0(r2)
 4002550:	1880082e 	bgeu	r3,r2,4002574 <prvCopyDataToQueue+0x144>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
 4002554:	e0bffd17 	ldw	r2,-12(fp)
 4002558:	10c00217 	ldw	r3,8(r2)
 400255c:	e0bffd17 	ldw	r2,-12(fp)
 4002560:	10801017 	ldw	r2,64(r2)
 4002564:	0085c83a 	sub	r2,zero,r2
 4002568:	1887883a 	add	r3,r3,r2
 400256c:	e0bffd17 	ldw	r2,-12(fp)
 4002570:	10c00315 	stw	r3,12(r2)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
 4002574:	e0bffb17 	ldw	r2,-20(fp)
 4002578:	10800098 	cmpnei	r2,r2,2
 400257c:	1000051e 	bne	r2,zero,4002594 <prvCopyDataToQueue+0x164>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 4002580:	e0bffe17 	ldw	r2,-8(fp)
 4002584:	10000326 	beq	r2,zero,4002594 <prvCopyDataToQueue+0x164>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
 4002588:	e0bffe17 	ldw	r2,-8(fp)
 400258c:	10bfffc4 	addi	r2,r2,-1
 4002590:	e0bffe15 	stw	r2,-8(fp)
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 4002594:	e0bffe17 	ldw	r2,-8(fp)
 4002598:	10c00044 	addi	r3,r2,1
 400259c:	e0bffd17 	ldw	r2,-12(fp)
 40025a0:	10c00e15 	stw	r3,56(r2)

    return xReturn;
 40025a4:	e0bfff17 	ldw	r2,-4(fp)
}
 40025a8:	e037883a 	mov	sp,fp
 40025ac:	dfc00117 	ldw	ra,4(sp)
 40025b0:	df000017 	ldw	fp,0(sp)
 40025b4:	dec00204 	addi	sp,sp,8
 40025b8:	f800283a 	ret

040025bc <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
 40025bc:	defffc04 	addi	sp,sp,-16
 40025c0:	dfc00315 	stw	ra,12(sp)
 40025c4:	df000215 	stw	fp,8(sp)
 40025c8:	df000204 	addi	fp,sp,8
 40025cc:	e13fff15 	stw	r4,-4(fp)
 40025d0:	e17ffe15 	stw	r5,-8(fp)
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 40025d4:	e0bfff17 	ldw	r2,-4(fp)
 40025d8:	10801017 	ldw	r2,64(r2)
 40025dc:	10001826 	beq	r2,zero,4002640 <prvCopyDataFromQueue+0x84>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 40025e0:	e0bfff17 	ldw	r2,-4(fp)
 40025e4:	10c00317 	ldw	r3,12(r2)
 40025e8:	e0bfff17 	ldw	r2,-4(fp)
 40025ec:	10801017 	ldw	r2,64(r2)
 40025f0:	1887883a 	add	r3,r3,r2
 40025f4:	e0bfff17 	ldw	r2,-4(fp)
 40025f8:	10c00315 	stw	r3,12(r2)

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 40025fc:	e0bfff17 	ldw	r2,-4(fp)
 4002600:	10c00317 	ldw	r3,12(r2)
 4002604:	e0bfff17 	ldw	r2,-4(fp)
 4002608:	10800217 	ldw	r2,8(r2)
 400260c:	18800436 	bltu	r3,r2,4002620 <prvCopyDataFromQueue+0x64>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 4002610:	e0bfff17 	ldw	r2,-4(fp)
 4002614:	10c00017 	ldw	r3,0(r2)
 4002618:	e0bfff17 	ldw	r2,-4(fp)
 400261c:	10c00315 	stw	r3,12(r2)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 4002620:	e0bfff17 	ldw	r2,-4(fp)
 4002624:	10c00317 	ldw	r3,12(r2)
 4002628:	e0bfff17 	ldw	r2,-4(fp)
 400262c:	10801017 	ldw	r2,64(r2)
 4002630:	100d883a 	mov	r6,r2
 4002634:	180b883a 	mov	r5,r3
 4002638:	e13ffe17 	ldw	r4,-8(fp)
 400263c:	40073000 	call	4007300 <memcpy>
    }
}
 4002640:	0001883a 	nop
 4002644:	e037883a 	mov	sp,fp
 4002648:	dfc00117 	ldw	ra,4(sp)
 400264c:	df000017 	ldw	fp,0(sp)
 4002650:	dec00204 	addi	sp,sp,8
 4002654:	f800283a 	ret

04002658 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 4002658:	defffc04 	addi	sp,sp,-16
 400265c:	dfc00315 	stw	ra,12(sp)
 4002660:	df000215 	stw	fp,8(sp)
 4002664:	df000204 	addi	fp,sp,8
 4002668:	e13ffe15 	stw	r4,-8(fp)

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
 400266c:	4005f740 	call	4005f74 <vTaskEnterCritical>
    {
        int8_t cTxLock = pxQueue->cTxLock;
 4002670:	e0bffe17 	ldw	r2,-8(fp)
 4002674:	10801143 	ldbu	r2,69(r2)
 4002678:	e0bfffc5 	stb	r2,-1(fp)

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
 400267c:	00000c06 	br	40026b0 <prvUnlockQueue+0x58>
            }
            #else /* configUSE_QUEUE_SETS */
            {
                /* Tasks that are removed from the event list will get added to
                 * the pending ready list as the scheduler is still suspended. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 4002680:	e0bffe17 	ldw	r2,-8(fp)
 4002684:	10800917 	ldw	r2,36(r2)
 4002688:	10000c26 	beq	r2,zero,40026bc <prvUnlockQueue+0x64>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 400268c:	e0bffe17 	ldw	r2,-8(fp)
 4002690:	10800904 	addi	r2,r2,36
 4002694:	1009883a 	mov	r4,r2
 4002698:	40050240 	call	4005024 <xTaskRemoveFromEventList>
 400269c:	10000126 	beq	r2,zero,40026a4 <prvUnlockQueue+0x4c>
                    {
                        /* The task waiting has a higher priority so record that
                         * a context switch is required. */
                        vTaskMissedYield();
 40026a0:	40056b40 	call	40056b4 <vTaskMissedYield>
                    break;
                }
            }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
 40026a4:	e0bfffc3 	ldbu	r2,-1(fp)
 40026a8:	10bfffc4 	addi	r2,r2,-1
 40026ac:	e0bfffc5 	stb	r2,-1(fp)
        while( cTxLock > queueLOCKED_UNMODIFIED )
 40026b0:	e0bfffc7 	ldb	r2,-1(fp)
 40026b4:	00bff216 	blt	zero,r2,4002680 <prvUnlockQueue+0x28>
 40026b8:	00000106 	br	40026c0 <prvUnlockQueue+0x68>
                    break;
 40026bc:	0001883a 	nop
        }

        pxQueue->cTxLock = queueUNLOCKED;
 40026c0:	e0bffe17 	ldw	r2,-8(fp)
 40026c4:	00ffffc4 	movi	r3,-1
 40026c8:	10c01145 	stb	r3,69(r2)
    }
    taskEXIT_CRITICAL();
 40026cc:	4005fc80 	call	4005fc8 <vTaskExitCritical>

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
 40026d0:	4005f740 	call	4005f74 <vTaskEnterCritical>
    {
        int8_t cRxLock = pxQueue->cRxLock;
 40026d4:	e0bffe17 	ldw	r2,-8(fp)
 40026d8:	10801103 	ldbu	r2,68(r2)
 40026dc:	e0bfff85 	stb	r2,-2(fp)

        while( cRxLock > queueLOCKED_UNMODIFIED )
 40026e0:	00000c06 	br	4002714 <prvUnlockQueue+0xbc>
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 40026e4:	e0bffe17 	ldw	r2,-8(fp)
 40026e8:	10800417 	ldw	r2,16(r2)
 40026ec:	10000c26 	beq	r2,zero,4002720 <prvUnlockQueue+0xc8>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 40026f0:	e0bffe17 	ldw	r2,-8(fp)
 40026f4:	10800404 	addi	r2,r2,16
 40026f8:	1009883a 	mov	r4,r2
 40026fc:	40050240 	call	4005024 <xTaskRemoveFromEventList>
 4002700:	10000126 	beq	r2,zero,4002708 <prvUnlockQueue+0xb0>
                {
                    vTaskMissedYield();
 4002704:	40056b40 	call	40056b4 <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
 4002708:	e0bfff83 	ldbu	r2,-2(fp)
 400270c:	10bfffc4 	addi	r2,r2,-1
 4002710:	e0bfff85 	stb	r2,-2(fp)
        while( cRxLock > queueLOCKED_UNMODIFIED )
 4002714:	e0bfff87 	ldb	r2,-2(fp)
 4002718:	00bff216 	blt	zero,r2,40026e4 <prvUnlockQueue+0x8c>
 400271c:	00000106 	br	4002724 <prvUnlockQueue+0xcc>
            }
            else
            {
                break;
 4002720:	0001883a 	nop
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
 4002724:	e0bffe17 	ldw	r2,-8(fp)
 4002728:	00ffffc4 	movi	r3,-1
 400272c:	10c01105 	stb	r3,68(r2)
    }
    taskEXIT_CRITICAL();
 4002730:	4005fc80 	call	4005fc8 <vTaskExitCritical>
}
 4002734:	0001883a 	nop
 4002738:	e037883a 	mov	sp,fp
 400273c:	dfc00117 	ldw	ra,4(sp)
 4002740:	df000017 	ldw	fp,0(sp)
 4002744:	dec00204 	addi	sp,sp,8
 4002748:	f800283a 	ret

0400274c <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
 400274c:	defffc04 	addi	sp,sp,-16
 4002750:	dfc00315 	stw	ra,12(sp)
 4002754:	df000215 	stw	fp,8(sp)
 4002758:	df000204 	addi	fp,sp,8
 400275c:	e13ffe15 	stw	r4,-8(fp)
    BaseType_t xReturn;

    taskENTER_CRITICAL();
 4002760:	4005f740 	call	4005f74 <vTaskEnterCritical>
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 4002764:	e0bffe17 	ldw	r2,-8(fp)
 4002768:	10800e17 	ldw	r2,56(r2)
 400276c:	1000031e 	bne	r2,zero,400277c <prvIsQueueEmpty+0x30>
        {
            xReturn = pdTRUE;
 4002770:	00800044 	movi	r2,1
 4002774:	e0bfff15 	stw	r2,-4(fp)
 4002778:	00000106 	br	4002780 <prvIsQueueEmpty+0x34>
        }
        else
        {
            xReturn = pdFALSE;
 400277c:	e03fff15 	stw	zero,-4(fp)
        }
    }
    taskEXIT_CRITICAL();
 4002780:	4005fc80 	call	4005fc8 <vTaskExitCritical>

    return xReturn;
 4002784:	e0bfff17 	ldw	r2,-4(fp)
}
 4002788:	e037883a 	mov	sp,fp
 400278c:	dfc00117 	ldw	ra,4(sp)
 4002790:	df000017 	ldw	fp,0(sp)
 4002794:	dec00204 	addi	sp,sp,8
 4002798:	f800283a 	ret

0400279c <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
 400279c:	defffc04 	addi	sp,sp,-16
 40027a0:	df000315 	stw	fp,12(sp)
 40027a4:	df000304 	addi	fp,sp,12
 40027a8:	e13ffd15 	stw	r4,-12(fp)
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
 40027ac:	e0bffd17 	ldw	r2,-12(fp)
 40027b0:	e0bffe15 	stw	r2,-8(fp)

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 40027b4:	e0bffe17 	ldw	r2,-8(fp)
 40027b8:	10800e17 	ldw	r2,56(r2)
 40027bc:	1000031e 	bne	r2,zero,40027cc <xQueueIsQueueEmptyFromISR+0x30>
    {
        xReturn = pdTRUE;
 40027c0:	00800044 	movi	r2,1
 40027c4:	e0bfff15 	stw	r2,-4(fp)
 40027c8:	00000106 	br	40027d0 <xQueueIsQueueEmptyFromISR+0x34>
    }
    else
    {
        xReturn = pdFALSE;
 40027cc:	e03fff15 	stw	zero,-4(fp)
    }

    return xReturn;
 40027d0:	e0bfff17 	ldw	r2,-4(fp)
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 40027d4:	e037883a 	mov	sp,fp
 40027d8:	df000017 	ldw	fp,0(sp)
 40027dc:	dec00104 	addi	sp,sp,4
 40027e0:	f800283a 	ret

040027e4 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
 40027e4:	defffc04 	addi	sp,sp,-16
 40027e8:	dfc00315 	stw	ra,12(sp)
 40027ec:	df000215 	stw	fp,8(sp)
 40027f0:	df000204 	addi	fp,sp,8
 40027f4:	e13ffe15 	stw	r4,-8(fp)
    BaseType_t xReturn;

    taskENTER_CRITICAL();
 40027f8:	4005f740 	call	4005f74 <vTaskEnterCritical>
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 40027fc:	e0bffe17 	ldw	r2,-8(fp)
 4002800:	10c00e17 	ldw	r3,56(r2)
 4002804:	e0bffe17 	ldw	r2,-8(fp)
 4002808:	10800f17 	ldw	r2,60(r2)
 400280c:	1880031e 	bne	r3,r2,400281c <prvIsQueueFull+0x38>
        {
            xReturn = pdTRUE;
 4002810:	00800044 	movi	r2,1
 4002814:	e0bfff15 	stw	r2,-4(fp)
 4002818:	00000106 	br	4002820 <prvIsQueueFull+0x3c>
        }
        else
        {
            xReturn = pdFALSE;
 400281c:	e03fff15 	stw	zero,-4(fp)
        }
    }
    taskEXIT_CRITICAL();
 4002820:	4005fc80 	call	4005fc8 <vTaskExitCritical>

    return xReturn;
 4002824:	e0bfff17 	ldw	r2,-4(fp)
}
 4002828:	e037883a 	mov	sp,fp
 400282c:	dfc00117 	ldw	ra,4(sp)
 4002830:	df000017 	ldw	fp,0(sp)
 4002834:	dec00204 	addi	sp,sp,8
 4002838:	f800283a 	ret

0400283c <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
 400283c:	defffc04 	addi	sp,sp,-16
 4002840:	df000315 	stw	fp,12(sp)
 4002844:	df000304 	addi	fp,sp,12
 4002848:	e13ffd15 	stw	r4,-12(fp)
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
 400284c:	e0bffd17 	ldw	r2,-12(fp)
 4002850:	e0bffe15 	stw	r2,-8(fp)

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 4002854:	e0bffe17 	ldw	r2,-8(fp)
 4002858:	10c00e17 	ldw	r3,56(r2)
 400285c:	e0bffe17 	ldw	r2,-8(fp)
 4002860:	10800f17 	ldw	r2,60(r2)
 4002864:	1880031e 	bne	r3,r2,4002874 <xQueueIsQueueFullFromISR+0x38>
    {
        xReturn = pdTRUE;
 4002868:	00800044 	movi	r2,1
 400286c:	e0bfff15 	stw	r2,-4(fp)
 4002870:	00000106 	br	4002878 <xQueueIsQueueFullFromISR+0x3c>
    }
    else
    {
        xReturn = pdFALSE;
 4002874:	e03fff15 	stw	zero,-4(fp)
    }

    return xReturn;
 4002878:	e0bfff17 	ldw	r2,-4(fp)
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 400287c:	e037883a 	mov	sp,fp
 4002880:	df000017 	ldw	fp,0(sp)
 4002884:	dec00104 	addi	sp,sp,4
 4002888:	f800283a 	ret

0400288c <xStreamBufferGenericCreate>:
    StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,
                                                     size_t xTriggerLevelBytes,
                                                     BaseType_t xIsMessageBuffer,
                                                     StreamBufferCallbackFunction_t pxSendCompletedCallback,
                                                     StreamBufferCallbackFunction_t pxReceiveCompletedCallback )
    {
 400288c:	defff504 	addi	sp,sp,-44
 4002890:	dfc00a15 	stw	ra,40(sp)
 4002894:	df000915 	stw	fp,36(sp)
 4002898:	df000904 	addi	fp,sp,36
 400289c:	e13ffd15 	stw	r4,-12(fp)
 40028a0:	e17ffc15 	stw	r5,-16(fp)
 40028a4:	e1bffb15 	stw	r6,-20(fp)
 40028a8:	e1fffa15 	stw	r7,-24(fp)

        /* In case the stream buffer is going to be used as a message buffer
         * (that is, it will hold discrete messages with a little meta data that
         * says how big the next message is) check the buffer will be large enough
         * to hold at least one message. */
        if( xIsMessageBuffer == pdTRUE )
 40028ac:	e0bffb17 	ldw	r2,-20(fp)
 40028b0:	10800058 	cmpnei	r2,r2,1
 40028b4:	1000031e 	bne	r2,zero,40028c4 <xStreamBufferGenericCreate+0x38>
        {
            /* Is a message buffer but not statically allocated. */
            ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
 40028b8:	00800044 	movi	r2,1
 40028bc:	e0bffec5 	stb	r2,-5(fp)
 40028c0:	00000106 	br	40028c8 <xStreamBufferGenericCreate+0x3c>
            configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
        }
        else
        {
            /* Not a message buffer and not statically allocated. */
            ucFlags = 0;
 40028c4:	e03ffec5 	stb	zero,-5(fp)

        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

        /* A trigger level of 0 would cause a waiting task to unblock even when
         * the buffer was empty. */
        if( xTriggerLevelBytes == ( size_t ) 0 )
 40028c8:	e0bffc17 	ldw	r2,-16(fp)
 40028cc:	1000021e 	bne	r2,zero,40028d8 <xStreamBufferGenericCreate+0x4c>
        {
            xTriggerLevelBytes = ( size_t ) 1;
 40028d0:	00800044 	movi	r2,1
 40028d4:	e0bffc15 	stw	r2,-16(fp)
         * and the buffer follows immediately after.  The requested size is
         * incremented so the free space is returned as the user would expect -
         * this is a quirk of the implementation that means otherwise the free
         * space would be reported as one byte smaller than would be logically
         * expected. */
        if( xBufferSizeBytes < ( xBufferSizeBytes + 1 + sizeof( StreamBuffer_t ) ) )
 40028d8:	e0bffd17 	ldw	r2,-12(fp)
 40028dc:	00fff784 	movi	r3,-34
 40028e0:	18800936 	bltu	r3,r2,4002908 <xStreamBufferGenericCreate+0x7c>
        {
            xBufferSizeBytes++;
 40028e4:	e0bffd17 	ldw	r2,-12(fp)
 40028e8:	10800044 	addi	r2,r2,1
 40028ec:	e0bffd15 	stw	r2,-12(fp)
            pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
 40028f0:	e0bffd17 	ldw	r2,-12(fp)
 40028f4:	10800804 	addi	r2,r2,32
 40028f8:	1009883a 	mov	r4,r2
 40028fc:	40010340 	call	4001034 <pvPortMalloc>
 4002900:	e0bfff15 	stw	r2,-4(fp)
 4002904:	00000106 	br	400290c <xStreamBufferGenericCreate+0x80>
        }
        else
        {
            pucAllocatedMemory = NULL;
 4002908:	e03fff15 	stw	zero,-4(fp)
        }

        if( pucAllocatedMemory != NULL )
 400290c:	e0bfff17 	ldw	r2,-4(fp)
 4002910:	10000d26 	beq	r2,zero,4002948 <xStreamBufferGenericCreate+0xbc>
        {
            prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory,       /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
 4002914:	e0bfff17 	ldw	r2,-4(fp)
 4002918:	11000804 	addi	r4,r2,32
 400291c:	e0bffec3 	ldbu	r2,-5(fp)
 4002920:	e0c00217 	ldw	r3,8(fp)
 4002924:	d8c00215 	stw	r3,8(sp)
 4002928:	e0fffa17 	ldw	r3,-24(fp)
 400292c:	d8c00115 	stw	r3,4(sp)
 4002930:	d8800015 	stw	r2,0(sp)
 4002934:	e1fffc17 	ldw	r7,-16(fp)
 4002938:	e1bffd17 	ldw	r6,-12(fp)
 400293c:	200b883a 	mov	r5,r4
 4002940:	e13fff17 	ldw	r4,-4(fp)
 4002944:	400372c0 	call	400372c <prvInitialiseNewStreamBuffer>
        else
        {
            traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
        }

        return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
 4002948:	e0bfff17 	ldw	r2,-4(fp)
    }
 400294c:	e037883a 	mov	sp,fp
 4002950:	dfc00117 	ldw	ra,4(sp)
 4002954:	df000017 	ldw	fp,0(sp)
 4002958:	dec00204 	addi	sp,sp,8
 400295c:	f800283a 	ret

04002960 <vStreamBufferDelete>:
    }
#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
 4002960:	defffc04 	addi	sp,sp,-16
 4002964:	dfc00315 	stw	ra,12(sp)
 4002968:	df000215 	stw	fp,8(sp)
 400296c:	df000204 	addi	fp,sp,8
 4002970:	e13ffe15 	stw	r4,-8(fp)
    StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
 4002974:	e0bffe17 	ldw	r2,-8(fp)
 4002978:	e0bfff15 	stw	r2,-4(fp)

    configASSERT( pxStreamBuffer );

    traceSTREAM_BUFFER_DELETE( xStreamBuffer );

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
 400297c:	e0bfff17 	ldw	r2,-4(fp)
 4002980:	10800703 	ldbu	r2,28(r2)
 4002984:	10803fcc 	andi	r2,r2,255
 4002988:	1080008c 	andi	r2,r2,2
 400298c:	1000031e 	bne	r2,zero,400299c <vStreamBufferDelete+0x3c>
    {
        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
        {
            /* Both the structure and the buffer were allocated using a single call
            * to pvPortMalloc(), hence only one call to vPortFree() is required. */
            vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
 4002990:	e13fff17 	ldw	r4,-4(fp)
 4002994:	400111c0 	call	400111c <vPortFree>
    {
        /* The structure and buffer were not allocated dynamically and cannot be
         * freed - just scrub the structure so future use will assert. */
        ( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    }
}
 4002998:	00000406 	br	40029ac <vStreamBufferDelete+0x4c>
        ( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
 400299c:	01800804 	movi	r6,32
 40029a0:	000b883a 	mov	r5,zero
 40029a4:	e13fff17 	ldw	r4,-4(fp)
 40029a8:	40074880 	call	4007488 <memset>
}
 40029ac:	0001883a 	nop
 40029b0:	e037883a 	mov	sp,fp
 40029b4:	dfc00117 	ldw	ra,4(sp)
 40029b8:	df000017 	ldw	fp,0(sp)
 40029bc:	dec00204 	addi	sp,sp,8
 40029c0:	f800283a 	ret

040029c4 <xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
 40029c4:	defff604 	addi	sp,sp,-40
 40029c8:	dfc00915 	stw	ra,36(sp)
 40029cc:	df000815 	stw	fp,32(sp)
 40029d0:	df000804 	addi	fp,sp,32
 40029d4:	e13ffb15 	stw	r4,-20(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 40029d8:	e0bffb17 	ldw	r2,-20(fp)
 40029dc:	e0bffe15 	stw	r2,-8(fp)
    BaseType_t xReturn = pdFAIL;
 40029e0:	e03fff15 	stw	zero,-4(fp)
    StreamBufferCallbackFunction_t pxSendCallback = NULL, pxReceiveCallback = NULL;
 40029e4:	e03ffd15 	stw	zero,-12(fp)
 40029e8:	e03ffc15 	stw	zero,-16(fp)
        uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
    }
    #endif

    /* Can only reset a message buffer if there are no tasks blocked on it. */
    taskENTER_CRITICAL();
 40029ec:	4005f740 	call	4005f74 <vTaskEnterCritical>
    {
        if( ( pxStreamBuffer->xTaskWaitingToReceive == NULL ) && ( pxStreamBuffer->xTaskWaitingToSend == NULL ) )
 40029f0:	e0bffe17 	ldw	r2,-8(fp)
 40029f4:	10800417 	ldw	r2,16(r2)
 40029f8:	1000181e 	bne	r2,zero,4002a5c <xStreamBufferReset+0x98>
 40029fc:	e0bffe17 	ldw	r2,-8(fp)
 4002a00:	10800517 	ldw	r2,20(r2)
 4002a04:	1000151e 	bne	r2,zero,4002a5c <xStreamBufferReset+0x98>
                pxSendCallback = pxStreamBuffer->pxSendCompletedCallback;
                pxReceiveCallback = pxStreamBuffer->pxReceiveCompletedCallback;
            }
            #endif

            prvInitialiseNewStreamBuffer( pxStreamBuffer,
 4002a08:	e0bffe17 	ldw	r2,-8(fp)
 4002a0c:	11000617 	ldw	r4,24(r2)
 4002a10:	e0bffe17 	ldw	r2,-8(fp)
 4002a14:	11400217 	ldw	r5,8(r2)
 4002a18:	e0bffe17 	ldw	r2,-8(fp)
 4002a1c:	11800317 	ldw	r6,12(r2)
                                          pxStreamBuffer->pucBuffer,
                                          pxStreamBuffer->xLength,
                                          pxStreamBuffer->xTriggerLevelBytes,
                                          pxStreamBuffer->ucFlags,
 4002a20:	e0bffe17 	ldw	r2,-8(fp)
 4002a24:	10800703 	ldbu	r2,28(r2)
            prvInitialiseNewStreamBuffer( pxStreamBuffer,
 4002a28:	10803fcc 	andi	r2,r2,255
 4002a2c:	e0fffc17 	ldw	r3,-16(fp)
 4002a30:	d8c00215 	stw	r3,8(sp)
 4002a34:	e0fffd17 	ldw	r3,-12(fp)
 4002a38:	d8c00115 	stw	r3,4(sp)
 4002a3c:	d8800015 	stw	r2,0(sp)
 4002a40:	300f883a 	mov	r7,r6
 4002a44:	280d883a 	mov	r6,r5
 4002a48:	200b883a 	mov	r5,r4
 4002a4c:	e13ffe17 	ldw	r4,-8(fp)
 4002a50:	400372c0 	call	400372c <prvInitialiseNewStreamBuffer>
            }
            #endif

            traceSTREAM_BUFFER_RESET( xStreamBuffer );

            xReturn = pdPASS;
 4002a54:	00800044 	movi	r2,1
 4002a58:	e0bfff15 	stw	r2,-4(fp)
        }
    }
    taskEXIT_CRITICAL();
 4002a5c:	4005fc80 	call	4005fc8 <vTaskExitCritical>

    return xReturn;
 4002a60:	e0bfff17 	ldw	r2,-4(fp)
}
 4002a64:	e037883a 	mov	sp,fp
 4002a68:	dfc00117 	ldw	ra,4(sp)
 4002a6c:	df000017 	ldw	fp,0(sp)
 4002a70:	dec00204 	addi	sp,sp,8
 4002a74:	f800283a 	ret

04002a78 <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer,
                                         size_t xTriggerLevel )
{
 4002a78:	defffb04 	addi	sp,sp,-20
 4002a7c:	df000415 	stw	fp,16(sp)
 4002a80:	df000404 	addi	fp,sp,16
 4002a84:	e13ffd15 	stw	r4,-12(fp)
 4002a88:	e17ffc15 	stw	r5,-16(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4002a8c:	e0bffd17 	ldw	r2,-12(fp)
 4002a90:	e0bffe15 	stw	r2,-8(fp)
    BaseType_t xReturn;

    configASSERT( pxStreamBuffer );

    /* It is not valid for the trigger level to be 0. */
    if( xTriggerLevel == ( size_t ) 0 )
 4002a94:	e0bffc17 	ldw	r2,-16(fp)
 4002a98:	1000021e 	bne	r2,zero,4002aa4 <xStreamBufferSetTriggerLevel+0x2c>
    {
        xTriggerLevel = ( size_t ) 1;
 4002a9c:	00800044 	movi	r2,1
 4002aa0:	e0bffc15 	stw	r2,-16(fp)
    }

    /* The trigger level is the number of bytes that must be in the stream
     * buffer before a task that is waiting for data is unblocked. */
    if( xTriggerLevel < pxStreamBuffer->xLength )
 4002aa4:	e0bffe17 	ldw	r2,-8(fp)
 4002aa8:	10800217 	ldw	r2,8(r2)
 4002aac:	e0fffc17 	ldw	r3,-16(fp)
 4002ab0:	1880062e 	bgeu	r3,r2,4002acc <xStreamBufferSetTriggerLevel+0x54>
    {
        pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
 4002ab4:	e0bffe17 	ldw	r2,-8(fp)
 4002ab8:	e0fffc17 	ldw	r3,-16(fp)
 4002abc:	10c00315 	stw	r3,12(r2)
        xReturn = pdPASS;
 4002ac0:	00800044 	movi	r2,1
 4002ac4:	e0bfff15 	stw	r2,-4(fp)
 4002ac8:	00000106 	br	4002ad0 <xStreamBufferSetTriggerLevel+0x58>
    }
    else
    {
        xReturn = pdFALSE;
 4002acc:	e03fff15 	stw	zero,-4(fp)
    }

    return xReturn;
 4002ad0:	e0bfff17 	ldw	r2,-4(fp)
}
 4002ad4:	e037883a 	mov	sp,fp
 4002ad8:	df000017 	ldw	fp,0(sp)
 4002adc:	dec00104 	addi	sp,sp,4
 4002ae0:	f800283a 	ret

04002ae4 <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
 4002ae4:	defffb04 	addi	sp,sp,-20
 4002ae8:	df000415 	stw	fp,16(sp)
 4002aec:	df000404 	addi	fp,sp,16
 4002af0:	e13ffc15 	stw	r4,-16(fp)
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4002af4:	e0bffc17 	ldw	r2,-16(fp)
 4002af8:	e0bffe15 	stw	r2,-8(fp)
    /* The code below reads xTail and then xHead.  This is safe if the stream
     * buffer is updated once between the two reads - but not if the stream buffer
     * is updated more than once between the two reads - hence the loop. */
    do
    {
        xOriginalTail = pxStreamBuffer->xTail;
 4002afc:	e0bffe17 	ldw	r2,-8(fp)
 4002b00:	10800017 	ldw	r2,0(r2)
 4002b04:	e0bffd15 	stw	r2,-12(fp)
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
 4002b08:	e0bffe17 	ldw	r2,-8(fp)
 4002b0c:	10c00217 	ldw	r3,8(r2)
 4002b10:	e0bffe17 	ldw	r2,-8(fp)
 4002b14:	10800017 	ldw	r2,0(r2)
 4002b18:	1885883a 	add	r2,r3,r2
 4002b1c:	e0bfff15 	stw	r2,-4(fp)
        xSpace -= pxStreamBuffer->xHead;
 4002b20:	e0bffe17 	ldw	r2,-8(fp)
 4002b24:	10800117 	ldw	r2,4(r2)
 4002b28:	e0ffff17 	ldw	r3,-4(fp)
 4002b2c:	1885c83a 	sub	r2,r3,r2
 4002b30:	e0bfff15 	stw	r2,-4(fp)
    } while( xOriginalTail != pxStreamBuffer->xTail );
 4002b34:	e0bffe17 	ldw	r2,-8(fp)
 4002b38:	10800017 	ldw	r2,0(r2)
 4002b3c:	e0fffd17 	ldw	r3,-12(fp)
 4002b40:	18bfee1e 	bne	r3,r2,4002afc <xStreamBufferSpacesAvailable+0x18>

    xSpace -= ( size_t ) 1;
 4002b44:	e0bfff17 	ldw	r2,-4(fp)
 4002b48:	10bfffc4 	addi	r2,r2,-1
 4002b4c:	e0bfff15 	stw	r2,-4(fp)

    if( xSpace >= pxStreamBuffer->xLength )
 4002b50:	e0bffe17 	ldw	r2,-8(fp)
 4002b54:	10800217 	ldw	r2,8(r2)
 4002b58:	e0ffff17 	ldw	r3,-4(fp)
 4002b5c:	18800536 	bltu	r3,r2,4002b74 <xStreamBufferSpacesAvailable+0x90>
    {
        xSpace -= pxStreamBuffer->xLength;
 4002b60:	e0bffe17 	ldw	r2,-8(fp)
 4002b64:	10800217 	ldw	r2,8(r2)
 4002b68:	e0ffff17 	ldw	r3,-4(fp)
 4002b6c:	1885c83a 	sub	r2,r3,r2
 4002b70:	e0bfff15 	stw	r2,-4(fp)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xSpace;
 4002b74:	e0bfff17 	ldw	r2,-4(fp)
}
 4002b78:	e037883a 	mov	sp,fp
 4002b7c:	df000017 	ldw	fp,0(sp)
 4002b80:	dec00104 	addi	sp,sp,4
 4002b84:	f800283a 	ret

04002b88 <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
 4002b88:	defffb04 	addi	sp,sp,-20
 4002b8c:	dfc00415 	stw	ra,16(sp)
 4002b90:	df000315 	stw	fp,12(sp)
 4002b94:	df000304 	addi	fp,sp,12
 4002b98:	e13ffd15 	stw	r4,-12(fp)
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4002b9c:	e0bffd17 	ldw	r2,-12(fp)
 4002ba0:	e0bfff15 	stw	r2,-4(fp)
    size_t xReturn;

    configASSERT( pxStreamBuffer );

    xReturn = prvBytesInBuffer( pxStreamBuffer );
 4002ba4:	e13fff17 	ldw	r4,-4(fp)
 4002ba8:	40036b80 	call	40036b8 <prvBytesInBuffer>
 4002bac:	e0bffe15 	stw	r2,-8(fp)
    return xReturn;
 4002bb0:	e0bffe17 	ldw	r2,-8(fp)
}
 4002bb4:	e037883a 	mov	sp,fp
 4002bb8:	dfc00117 	ldw	ra,4(sp)
 4002bbc:	df000017 	ldw	fp,0(sp)
 4002bc0:	dec00204 	addi	sp,sp,8
 4002bc4:	f800283a 	ret

04002bc8 <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
                          const void * pvTxData,
                          size_t xDataLengthBytes,
                          TickType_t xTicksToWait )
{
 4002bc8:	defff204 	addi	sp,sp,-56
 4002bcc:	dfc00d15 	stw	ra,52(sp)
 4002bd0:	df000c15 	stw	fp,48(sp)
 4002bd4:	df000c04 	addi	fp,sp,48
 4002bd8:	e13ff815 	stw	r4,-32(fp)
 4002bdc:	e17ff715 	stw	r5,-36(fp)
 4002be0:	e1bff615 	stw	r6,-40(fp)
 4002be4:	e1fff515 	stw	r7,-44(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4002be8:	e0bff817 	ldw	r2,-32(fp)
 4002bec:	e0bffd15 	stw	r2,-12(fp)
    size_t xReturn, xSpace = 0;
 4002bf0:	e03fff15 	stw	zero,-4(fp)
    size_t xRequiredSpace = xDataLengthBytes;
 4002bf4:	e0bff617 	ldw	r2,-40(fp)
 4002bf8:	e0bffe15 	stw	r2,-8(fp)
    TimeOut_t xTimeOut;
    size_t xMaxReportedSpace = 0;
 4002bfc:	e03ffc15 	stw	zero,-16(fp)
    configASSERT( pvTxData );
    configASSERT( pxStreamBuffer );

    /* The maximum amount of space a stream buffer will ever report is its length
     * minus 1. */
    xMaxReportedSpace = pxStreamBuffer->xLength - ( size_t ) 1;
 4002c00:	e0bffd17 	ldw	r2,-12(fp)
 4002c04:	10800217 	ldw	r2,8(r2)
 4002c08:	10bfffc4 	addi	r2,r2,-1
 4002c0c:	e0bffc15 	stw	r2,-16(fp)

    /* This send function is used to write to both message buffers and stream
     * buffers.  If this is a message buffer then the space needed must be
     * increased by the amount of bytes needed to store the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 4002c10:	e0bffd17 	ldw	r2,-12(fp)
 4002c14:	10800703 	ldbu	r2,28(r2)
 4002c18:	10803fcc 	andi	r2,r2,255
 4002c1c:	1080004c 	andi	r2,r2,1
 4002c20:	10000826 	beq	r2,zero,4002c44 <xStreamBufferSend+0x7c>
    {
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
 4002c24:	e0bffe17 	ldw	r2,-8(fp)
 4002c28:	10800104 	addi	r2,r2,4
 4002c2c:	e0bffe15 	stw	r2,-8(fp)
        /* Overflow? */
        configASSERT( xRequiredSpace > xDataLengthBytes );

        /* If this is a message buffer then it must be possible to write the
         * whole message. */
        if( xRequiredSpace > xMaxReportedSpace )
 4002c30:	e0bffe17 	ldw	r2,-8(fp)
 4002c34:	e0fffc17 	ldw	r3,-16(fp)
 4002c38:	1880072e 	bgeu	r3,r2,4002c58 <xStreamBufferSend+0x90>
        {
            /* The message would not fit even if the entire buffer was empty,
             * so don't wait for space. */
            xTicksToWait = ( TickType_t ) 0;
 4002c3c:	e03ff515 	stw	zero,-44(fp)
 4002c40:	00000506 	br	4002c58 <xStreamBufferSend+0x90>
    else
    {
        /* If this is a stream buffer then it is acceptable to write only part
         * of the message to the buffer.  Cap the length to the total length of
         * the buffer. */
        if( xRequiredSpace > xMaxReportedSpace )
 4002c44:	e0bffe17 	ldw	r2,-8(fp)
 4002c48:	e0fffc17 	ldw	r3,-16(fp)
 4002c4c:	1880022e 	bgeu	r3,r2,4002c58 <xStreamBufferSend+0x90>
        {
            xRequiredSpace = xMaxReportedSpace;
 4002c50:	e0bffc17 	ldw	r2,-16(fp)
 4002c54:	e0bffe15 	stw	r2,-8(fp)
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    if( xTicksToWait != ( TickType_t ) 0 )
 4002c58:	e0bff517 	ldw	r2,-44(fp)
 4002c5c:	10002426 	beq	r2,zero,4002cf0 <xStreamBufferSend+0x128>
    {
        vTaskSetTimeOutState( &xTimeOut );
 4002c60:	e0bff904 	addi	r2,fp,-28
 4002c64:	1009883a 	mov	r4,r2
 4002c68:	40055440 	call	4005544 <vTaskSetTimeOutState>

        do
        {
            /* Wait until the required number of bytes are free in the message
             * buffer. */
            taskENTER_CRITICAL();
 4002c6c:	4005f740 	call	4005f74 <vTaskEnterCritical>
            {
                xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
 4002c70:	e13ffd17 	ldw	r4,-12(fp)
 4002c74:	4002ae40 	call	4002ae4 <xStreamBufferSpacesAvailable>
 4002c78:	e0bfff15 	stw	r2,-4(fp)

                if( xSpace < xRequiredSpace )
 4002c7c:	e0ffff17 	ldw	r3,-4(fp)
 4002c80:	e0bffe17 	ldw	r2,-8(fp)
 4002c84:	1880082e 	bgeu	r3,r2,4002ca8 <xStreamBufferSend+0xe0>
                {
                    /* Clear notification state as going to wait for space. */
                    ( void ) xTaskNotifyStateClear( NULL );
 4002c88:	000b883a 	mov	r5,zero
 4002c8c:	0009883a 	mov	r4,zero
 4002c90:	4006cfc0 	call	4006cfc <xTaskGenericNotifyStateClear>

                    /* Should only be one writer. */
                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
 4002c94:	40059880 	call	4005988 <xTaskGetCurrentTaskHandle>
 4002c98:	1007883a 	mov	r3,r2
 4002c9c:	e0bffd17 	ldw	r2,-12(fp)
 4002ca0:	10c00515 	stw	r3,20(r2)
 4002ca4:	00000206 	br	4002cb0 <xStreamBufferSend+0xe8>
                }
                else
                {
                    taskEXIT_CRITICAL();
 4002ca8:	4005fc80 	call	4005fc8 <vTaskExitCritical>
                    break;
 4002cac:	00001006 	br	4002cf0 <xStreamBufferSend+0x128>
                }
            }
            taskEXIT_CRITICAL();
 4002cb0:	4005fc80 	call	4005fc8 <vTaskExitCritical>

            traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
 4002cb4:	e0bff517 	ldw	r2,-44(fp)
 4002cb8:	d8800015 	stw	r2,0(sp)
 4002cbc:	000f883a 	mov	r7,zero
 4002cc0:	000d883a 	mov	r6,zero
 4002cc4:	000b883a 	mov	r5,zero
 4002cc8:	0009883a 	mov	r4,zero
 4002ccc:	40061ac0 	call	40061ac <xTaskGenericNotifyWait>
            pxStreamBuffer->xTaskWaitingToSend = NULL;
 4002cd0:	e0bffd17 	ldw	r2,-12(fp)
 4002cd4:	10000515 	stw	zero,20(r2)
        } while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
 4002cd8:	e0fff504 	addi	r3,fp,-44
 4002cdc:	e0bff904 	addi	r2,fp,-28
 4002ce0:	180b883a 	mov	r5,r3
 4002ce4:	1009883a 	mov	r4,r2
 4002ce8:	40055cc0 	call	40055cc <xTaskCheckForTimeOut>
 4002cec:	103fdf26 	beq	r2,zero,4002c6c <xStreamBufferSend+0xa4>
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    if( xSpace == ( size_t ) 0 )
 4002cf0:	e0bfff17 	ldw	r2,-4(fp)
 4002cf4:	1000031e 	bne	r2,zero,4002d04 <xStreamBufferSend+0x13c>
    {
        xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
 4002cf8:	e13ffd17 	ldw	r4,-12(fp)
 4002cfc:	4002ae40 	call	4002ae4 <xStreamBufferSpacesAvailable>
 4002d00:	e0bfff15 	stw	r2,-4(fp)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
 4002d04:	e0bffe17 	ldw	r2,-8(fp)
 4002d08:	d8800015 	stw	r2,0(sp)
 4002d0c:	e1ffff17 	ldw	r7,-4(fp)
 4002d10:	e1bff617 	ldw	r6,-40(fp)
 4002d14:	e17ff717 	ldw	r5,-36(fp)
 4002d18:	e13ffd17 	ldw	r4,-12(fp)
 4002d1c:	4002e8c0 	call	4002e8c <prvWriteMessageToBuffer>
 4002d20:	e0bffb15 	stw	r2,-20(fp)

    if( xReturn > ( size_t ) 0 )
 4002d24:	e0bffb17 	ldw	r2,-20(fp)
 4002d28:	10001526 	beq	r2,zero,4002d80 <xStreamBufferSend+0x1b8>
    {
        traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

        /* Was a task waiting for the data? */
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
 4002d2c:	e13ffd17 	ldw	r4,-12(fp)
 4002d30:	40036b80 	call	40036b8 <prvBytesInBuffer>
 4002d34:	1007883a 	mov	r3,r2
 4002d38:	e0bffd17 	ldw	r2,-12(fp)
 4002d3c:	10800317 	ldw	r2,12(r2)
 4002d40:	18800f36 	bltu	r3,r2,4002d80 <xStreamBufferSend+0x1b8>
        {
            prvSEND_COMPLETED( pxStreamBuffer );
 4002d44:	40046e80 	call	40046e8 <vTaskSuspendAll>
 4002d48:	e0bffd17 	ldw	r2,-12(fp)
 4002d4c:	10800417 	ldw	r2,16(r2)
 4002d50:	10000a26 	beq	r2,zero,4002d7c <xStreamBufferSend+0x1b4>
 4002d54:	e0bffd17 	ldw	r2,-12(fp)
 4002d58:	10800417 	ldw	r2,16(r2)
 4002d5c:	d8000015 	stw	zero,0(sp)
 4002d60:	000f883a 	mov	r7,zero
 4002d64:	000d883a 	mov	r6,zero
 4002d68:	000b883a 	mov	r5,zero
 4002d6c:	1009883a 	mov	r4,r2
 4002d70:	40063100 	call	4006310 <xTaskGenericNotify>
 4002d74:	e0bffd17 	ldw	r2,-12(fp)
 4002d78:	10000415 	stw	zero,16(r2)
 4002d7c:	40047140 	call	4004714 <xTaskResumeAll>
    {
        mtCOVERAGE_TEST_MARKER();
        traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
    }

    return xReturn;
 4002d80:	e0bffb17 	ldw	r2,-20(fp)
}
 4002d84:	e037883a 	mov	sp,fp
 4002d88:	dfc00117 	ldw	ra,4(sp)
 4002d8c:	df000017 	ldw	fp,0(sp)
 4002d90:	dec00204 	addi	sp,sp,8
 4002d94:	f800283a 	ret

04002d98 <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
                                 const void * pvTxData,
                                 size_t xDataLengthBytes,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
 4002d98:	defff304 	addi	sp,sp,-52
 4002d9c:	dfc00c15 	stw	ra,48(sp)
 4002da0:	df000b15 	stw	fp,44(sp)
 4002da4:	df000b04 	addi	fp,sp,44
 4002da8:	e13ffa15 	stw	r4,-24(fp)
 4002dac:	e17ff915 	stw	r5,-28(fp)
 4002db0:	e1bff815 	stw	r6,-32(fp)
 4002db4:	e1fff715 	stw	r7,-36(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4002db8:	e0bffa17 	ldw	r2,-24(fp)
 4002dbc:	e0bffe15 	stw	r2,-8(fp)
    size_t xReturn, xSpace;
    size_t xRequiredSpace = xDataLengthBytes;
 4002dc0:	e0bff817 	ldw	r2,-32(fp)
 4002dc4:	e0bfff15 	stw	r2,-4(fp)

    /* This send function is used to write to both message buffers and stream
     * buffers.  If this is a message buffer then the space needed must be
     * increased by the amount of bytes needed to store the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 4002dc8:	e0bffe17 	ldw	r2,-8(fp)
 4002dcc:	10800703 	ldbu	r2,28(r2)
 4002dd0:	10803fcc 	andi	r2,r2,255
 4002dd4:	1080004c 	andi	r2,r2,1
 4002dd8:	10000326 	beq	r2,zero,4002de8 <xStreamBufferSendFromISR+0x50>
    {
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
 4002ddc:	e0bfff17 	ldw	r2,-4(fp)
 4002de0:	10800104 	addi	r2,r2,4
 4002de4:	e0bfff15 	stw	r2,-4(fp)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
 4002de8:	e13ffe17 	ldw	r4,-8(fp)
 4002dec:	4002ae40 	call	4002ae4 <xStreamBufferSpacesAvailable>
 4002df0:	e0bffd15 	stw	r2,-12(fp)
    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
 4002df4:	e0bfff17 	ldw	r2,-4(fp)
 4002df8:	d8800015 	stw	r2,0(sp)
 4002dfc:	e1fffd17 	ldw	r7,-12(fp)
 4002e00:	e1bff817 	ldw	r6,-32(fp)
 4002e04:	e17ff917 	ldw	r5,-28(fp)
 4002e08:	e13ffe17 	ldw	r4,-8(fp)
 4002e0c:	4002e8c0 	call	4002e8c <prvWriteMessageToBuffer>
 4002e10:	e0bffc15 	stw	r2,-16(fp)

    if( xReturn > ( size_t ) 0 )
 4002e14:	e0bffc17 	ldw	r2,-16(fp)
 4002e18:	10001626 	beq	r2,zero,4002e74 <xStreamBufferSendFromISR+0xdc>
    {
        /* Was a task waiting for the data? */
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
 4002e1c:	e13ffe17 	ldw	r4,-8(fp)
 4002e20:	40036b80 	call	40036b8 <prvBytesInBuffer>
 4002e24:	1007883a 	mov	r3,r2
 4002e28:	e0bffe17 	ldw	r2,-8(fp)
 4002e2c:	10800317 	ldw	r2,12(r2)
 4002e30:	18801036 	bltu	r3,r2,4002e74 <xStreamBufferSendFromISR+0xdc>
        {
            prvSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
 4002e34:	e03ffb15 	stw	zero,-20(fp)
 4002e38:	e0bffe17 	ldw	r2,-8(fp)
 4002e3c:	10800417 	ldw	r2,16(r2)
 4002e40:	10000c26 	beq	r2,zero,4002e74 <xStreamBufferSendFromISR+0xdc>
 4002e44:	e0bffe17 	ldw	r2,-8(fp)
 4002e48:	10c00417 	ldw	r3,16(r2)
 4002e4c:	e0bff717 	ldw	r2,-36(fp)
 4002e50:	d8800115 	stw	r2,4(sp)
 4002e54:	d8000015 	stw	zero,0(sp)
 4002e58:	000f883a 	mov	r7,zero
 4002e5c:	000d883a 	mov	r6,zero
 4002e60:	000b883a 	mov	r5,zero
 4002e64:	1809883a 	mov	r4,r3
 4002e68:	40066580 	call	4006658 <xTaskGenericNotifyFromISR>
 4002e6c:	e0bffe17 	ldw	r2,-8(fp)
 4002e70:	10000415 	stw	zero,16(r2)
        mtCOVERAGE_TEST_MARKER();
    }

    traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

    return xReturn;
 4002e74:	e0bffc17 	ldw	r2,-16(fp)
}
 4002e78:	e037883a 	mov	sp,fp
 4002e7c:	dfc00117 	ldw	ra,4(sp)
 4002e80:	df000017 	ldw	fp,0(sp)
 4002e84:	dec00204 	addi	sp,sp,8
 4002e88:	f800283a 	ret

04002e8c <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
                                       const void * pvTxData,
                                       size_t xDataLengthBytes,
                                       size_t xSpace,
                                       size_t xRequiredSpace )
{
 4002e8c:	defff804 	addi	sp,sp,-32
 4002e90:	dfc00715 	stw	ra,28(sp)
 4002e94:	df000615 	stw	fp,24(sp)
 4002e98:	df000604 	addi	fp,sp,24
 4002e9c:	e13ffd15 	stw	r4,-12(fp)
 4002ea0:	e17ffc15 	stw	r5,-16(fp)
 4002ea4:	e1bffb15 	stw	r6,-20(fp)
 4002ea8:	e1fffa15 	stw	r7,-24(fp)
    size_t xNextHead = pxStreamBuffer->xHead;
 4002eac:	e0bffd17 	ldw	r2,-12(fp)
 4002eb0:	10800117 	ldw	r2,4(r2)
 4002eb4:	e0bfff15 	stw	r2,-4(fp)
    configMESSAGE_BUFFER_LENGTH_TYPE xMessageLength;

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 4002eb8:	e0bffd17 	ldw	r2,-12(fp)
 4002ebc:	10800703 	ldbu	r2,28(r2)
 4002ec0:	10803fcc 	andi	r2,r2,255
 4002ec4:	1080004c 	andi	r2,r2,1
 4002ec8:	10000f26 	beq	r2,zero,4002f08 <prvWriteMessageToBuffer+0x7c>
    {
        /* This is a message buffer, as opposed to a stream buffer. */

        /* Convert xDataLengthBytes to the message length type. */
        xMessageLength = ( configMESSAGE_BUFFER_LENGTH_TYPE ) xDataLengthBytes;
 4002ecc:	e0bffb17 	ldw	r2,-20(fp)
 4002ed0:	e0bffe15 	stw	r2,-8(fp)

        /* Ensure the data length given fits within configMESSAGE_BUFFER_LENGTH_TYPE. */
        configASSERT( ( size_t ) xMessageLength == xDataLengthBytes );

        if( xSpace >= xRequiredSpace )
 4002ed4:	e0fffa17 	ldw	r3,-24(fp)
 4002ed8:	e0800217 	ldw	r2,8(fp)
 4002edc:	18800836 	bltu	r3,r2,4002f00 <prvWriteMessageToBuffer+0x74>
        {
            /* There is enough space to write both the message length and the message
             * itself into the buffer.  Start by writing the length of the data, the data
             * itself will be written later in this function. */
            xNextHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xMessageLength ), sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextHead );
 4002ee0:	e0bffe04 	addi	r2,fp,-8
 4002ee4:	e1ffff17 	ldw	r7,-4(fp)
 4002ee8:	01800104 	movi	r6,4
 4002eec:	100b883a 	mov	r5,r2
 4002ef0:	e13ffd17 	ldw	r4,-12(fp)
 4002ef4:	40034f80 	call	40034f8 <prvWriteBytesToBuffer>
 4002ef8:	e0bfff15 	stw	r2,-4(fp)
 4002efc:	00000706 	br	4002f1c <prvWriteMessageToBuffer+0x90>
        }
        else
        {
            /* Not enough space, so do not write data to the buffer. */
            xDataLengthBytes = 0;
 4002f00:	e03ffb15 	stw	zero,-20(fp)
 4002f04:	00000506 	br	4002f1c <prvWriteMessageToBuffer+0x90>
    else
    {
        /* This is a stream buffer, as opposed to a message buffer, so writing a
         * stream of bytes rather than discrete messages.  Plan to write as many
         * bytes as possible. */
        xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
 4002f08:	e0fffb17 	ldw	r3,-20(fp)
 4002f0c:	e0bffa17 	ldw	r2,-24(fp)
 4002f10:	1880012e 	bgeu	r3,r2,4002f18 <prvWriteMessageToBuffer+0x8c>
 4002f14:	1805883a 	mov	r2,r3
 4002f18:	e0bffb15 	stw	r2,-20(fp)
    }

    if( xDataLengthBytes != ( size_t ) 0 )
 4002f1c:	e0bffb17 	ldw	r2,-20(fp)
 4002f20:	10000826 	beq	r2,zero,4002f44 <prvWriteMessageToBuffer+0xb8>
    {
        /* Write the data to the buffer. */
        pxStreamBuffer->xHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes, xNextHead ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alignment and access. */
 4002f24:	e1ffff17 	ldw	r7,-4(fp)
 4002f28:	e1bffb17 	ldw	r6,-20(fp)
 4002f2c:	e17ffc17 	ldw	r5,-16(fp)
 4002f30:	e13ffd17 	ldw	r4,-12(fp)
 4002f34:	40034f80 	call	40034f8 <prvWriteBytesToBuffer>
 4002f38:	1007883a 	mov	r3,r2
 4002f3c:	e0bffd17 	ldw	r2,-12(fp)
 4002f40:	10c00115 	stw	r3,4(r2)
    }

    return xDataLengthBytes;
 4002f44:	e0bffb17 	ldw	r2,-20(fp)
}
 4002f48:	e037883a 	mov	sp,fp
 4002f4c:	dfc00117 	ldw	ra,4(sp)
 4002f50:	df000017 	ldw	fp,0(sp)
 4002f54:	dec00204 	addi	sp,sp,8
 4002f58:	f800283a 	ret

04002f5c <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
                             void * pvRxData,
                             size_t xBufferLengthBytes,
                             TickType_t xTicksToWait )
{
 4002f5c:	defff504 	addi	sp,sp,-44
 4002f60:	dfc00a15 	stw	ra,40(sp)
 4002f64:	df000915 	stw	fp,36(sp)
 4002f68:	df000904 	addi	fp,sp,36
 4002f6c:	e13ffb15 	stw	r4,-20(fp)
 4002f70:	e17ffa15 	stw	r5,-24(fp)
 4002f74:	e1bff915 	stw	r6,-28(fp)
 4002f78:	e1fff815 	stw	r7,-32(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4002f7c:	e0bffb17 	ldw	r2,-20(fp)
 4002f80:	e0bffc15 	stw	r2,-16(fp)
    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
 4002f84:	e03fff15 	stw	zero,-4(fp)
    /* This receive function is used by both message buffers, which store
     * discrete messages, and stream buffers, which store a continuous stream of
     * bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 4002f88:	e0bffc17 	ldw	r2,-16(fp)
 4002f8c:	10800703 	ldbu	r2,28(r2)
 4002f90:	10803fcc 	andi	r2,r2,255
 4002f94:	1080004c 	andi	r2,r2,1
 4002f98:	10000326 	beq	r2,zero,4002fa8 <xStreamBufferReceive+0x4c>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
 4002f9c:	00800104 	movi	r2,4
 4002fa0:	e0bffd15 	stw	r2,-12(fp)
 4002fa4:	00000106 	br	4002fac <xStreamBufferReceive+0x50>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
 4002fa8:	e03ffd15 	stw	zero,-12(fp)
    }

    if( xTicksToWait != ( TickType_t ) 0 )
 4002fac:	e0bff817 	ldw	r2,-32(fp)
 4002fb0:	10001f26 	beq	r2,zero,4003030 <xStreamBufferReceive+0xd4>
    {
        /* Checking if there is data and clearing the notification state must be
         * performed atomically. */
        taskENTER_CRITICAL();
 4002fb4:	4005f740 	call	4005f74 <vTaskEnterCritical>
        {
            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 4002fb8:	e13ffc17 	ldw	r4,-16(fp)
 4002fbc:	40036b80 	call	40036b8 <prvBytesInBuffer>
 4002fc0:	e0bffe15 	stw	r2,-8(fp)
            /* If this function was invoked by a message buffer read then
             * xBytesToStoreMessageLength holds the number of bytes used to hold
             * the length of the next discrete message.  If this function was
             * invoked by a stream buffer read then xBytesToStoreMessageLength will
             * be 0. */
            if( xBytesAvailable <= xBytesToStoreMessageLength )
 4002fc4:	e0bffe17 	ldw	r2,-8(fp)
 4002fc8:	e0fffd17 	ldw	r3,-12(fp)
 4002fcc:	18800736 	bltu	r3,r2,4002fec <xStreamBufferReceive+0x90>
            {
                /* Clear notification state as going to wait for data. */
                ( void ) xTaskNotifyStateClear( NULL );
 4002fd0:	000b883a 	mov	r5,zero
 4002fd4:	0009883a 	mov	r4,zero
 4002fd8:	4006cfc0 	call	4006cfc <xTaskGenericNotifyStateClear>

                /* Should only be one reader. */
                configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
                pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
 4002fdc:	40059880 	call	4005988 <xTaskGetCurrentTaskHandle>
 4002fe0:	1007883a 	mov	r3,r2
 4002fe4:	e0bffc17 	ldw	r2,-16(fp)
 4002fe8:	10c00415 	stw	r3,16(r2)
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
 4002fec:	4005fc80 	call	4005fc8 <vTaskExitCritical>

        if( xBytesAvailable <= xBytesToStoreMessageLength )
 4002ff0:	e0bffe17 	ldw	r2,-8(fp)
 4002ff4:	e0fffd17 	ldw	r3,-12(fp)
 4002ff8:	18801036 	bltu	r3,r2,400303c <xStreamBufferReceive+0xe0>
        {
            /* Wait for data to be available. */
            traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
 4002ffc:	e0bff817 	ldw	r2,-32(fp)
 4003000:	d8800015 	stw	r2,0(sp)
 4003004:	000f883a 	mov	r7,zero
 4003008:	000d883a 	mov	r6,zero
 400300c:	000b883a 	mov	r5,zero
 4003010:	0009883a 	mov	r4,zero
 4003014:	40061ac0 	call	40061ac <xTaskGenericNotifyWait>
            pxStreamBuffer->xTaskWaitingToReceive = NULL;
 4003018:	e0bffc17 	ldw	r2,-16(fp)
 400301c:	10000415 	stw	zero,16(r2)

            /* Recheck the data available after blocking. */
            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 4003020:	e13ffc17 	ldw	r4,-16(fp)
 4003024:	40036b80 	call	40036b8 <prvBytesInBuffer>
 4003028:	e0bffe15 	stw	r2,-8(fp)
 400302c:	00000306 	br	400303c <xStreamBufferReceive+0xe0>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 4003030:	e13ffc17 	ldw	r4,-16(fp)
 4003034:	40036b80 	call	40036b8 <prvBytesInBuffer>
 4003038:	e0bffe15 	stw	r2,-8(fp)
    /* Whether receiving a discrete message (where xBytesToStoreMessageLength
     * holds the number of bytes used to store the message length) or a stream of
     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
     * available must be greater than xBytesToStoreMessageLength to be able to
     * read bytes from the buffer. */
    if( xBytesAvailable > xBytesToStoreMessageLength )
 400303c:	e0bffe17 	ldw	r2,-8(fp)
 4003040:	e0fffd17 	ldw	r3,-12(fp)
 4003044:	1880172e 	bgeu	r3,r2,40030a4 <xStreamBufferReceive+0x148>
    {
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );
 4003048:	e1fffe17 	ldw	r7,-8(fp)
 400304c:	e1bff917 	ldw	r6,-28(fp)
 4003050:	e17ffa17 	ldw	r5,-24(fp)
 4003054:	e13ffc17 	ldw	r4,-16(fp)
 4003058:	40032340 	call	4003234 <prvReadMessageFromBuffer>
 400305c:	e0bfff15 	stw	r2,-4(fp)

        /* Was a task waiting for space in the buffer? */
        if( xReceivedLength != ( size_t ) 0 )
 4003060:	e0bfff17 	ldw	r2,-4(fp)
 4003064:	10000f26 	beq	r2,zero,40030a4 <xStreamBufferReceive+0x148>
        {
            traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
            prvRECEIVE_COMPLETED( xStreamBuffer );
 4003068:	40046e80 	call	40046e8 <vTaskSuspendAll>
 400306c:	e0bffb17 	ldw	r2,-20(fp)
 4003070:	10800517 	ldw	r2,20(r2)
 4003074:	10000a26 	beq	r2,zero,40030a0 <xStreamBufferReceive+0x144>
 4003078:	e0bffb17 	ldw	r2,-20(fp)
 400307c:	10800517 	ldw	r2,20(r2)
 4003080:	d8000015 	stw	zero,0(sp)
 4003084:	000f883a 	mov	r7,zero
 4003088:	000d883a 	mov	r6,zero
 400308c:	000b883a 	mov	r5,zero
 4003090:	1009883a 	mov	r4,r2
 4003094:	40063100 	call	4006310 <xTaskGenericNotify>
 4003098:	e0bffb17 	ldw	r2,-20(fp)
 400309c:	10000515 	stw	zero,20(r2)
 40030a0:	40047140 	call	4004714 <xTaskResumeAll>
    {
        traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
        mtCOVERAGE_TEST_MARKER();
    }

    return xReceivedLength;
 40030a4:	e0bfff17 	ldw	r2,-4(fp)
}
 40030a8:	e037883a 	mov	sp,fp
 40030ac:	dfc00117 	ldw	ra,4(sp)
 40030b0:	df000017 	ldw	fp,0(sp)
 40030b4:	dec00204 	addi	sp,sp,8
 40030b8:	f800283a 	ret

040030bc <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
 40030bc:	defff904 	addi	sp,sp,-28
 40030c0:	dfc00615 	stw	ra,24(sp)
 40030c4:	df000515 	stw	fp,20(sp)
 40030c8:	df000504 	addi	fp,sp,20
 40030cc:	e13ffb15 	stw	r4,-20(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 40030d0:	e0bffb17 	ldw	r2,-20(fp)
 40030d4:	e0bffe15 	stw	r2,-8(fp)
    configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

    configASSERT( pxStreamBuffer );

    /* Ensure the stream buffer is being used as a message buffer. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 40030d8:	e0bffe17 	ldw	r2,-8(fp)
 40030dc:	10800703 	ldbu	r2,28(r2)
 40030e0:	10803fcc 	andi	r2,r2,255
 40030e4:	1080004c 	andi	r2,r2,1
 40030e8:	10001326 	beq	r2,zero,4003138 <xStreamBufferNextMessageLengthBytes+0x7c>
    {
        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 40030ec:	e13ffe17 	ldw	r4,-8(fp)
 40030f0:	40036b80 	call	40036b8 <prvBytesInBuffer>
 40030f4:	e0bffd15 	stw	r2,-12(fp)

        if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
 40030f8:	e0bffd17 	ldw	r2,-12(fp)
 40030fc:	10800170 	cmpltui	r2,r2,5
 4003100:	10000b1e 	bne	r2,zero,4003130 <xStreamBufferNextMessageLengthBytes+0x74>
        {
            /* The number of bytes available is greater than the number of bytes
             * required to hold the length of the next message, so another message
             * is available. */
            ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, pxStreamBuffer->xTail );
 4003104:	e0bffe17 	ldw	r2,-8(fp)
 4003108:	10c00017 	ldw	r3,0(r2)
 400310c:	e0bffc04 	addi	r2,fp,-16
 4003110:	180f883a 	mov	r7,r3
 4003114:	01800104 	movi	r6,4
 4003118:	100b883a 	mov	r5,r2
 400311c:	e13ffe17 	ldw	r4,-8(fp)
 4003120:	40035d80 	call	40035d8 <prvReadBytesFromBuffer>
            xReturn = ( size_t ) xTempReturn;
 4003124:	e0bffc17 	ldw	r2,-16(fp)
 4003128:	e0bfff15 	stw	r2,-4(fp)
 400312c:	00000306 	br	400313c <xStreamBufferNextMessageLengthBytes+0x80>
            /* The minimum amount of bytes in a message buffer is
             * ( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
             * less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
             * value is 0. */
            configASSERT( xBytesAvailable == 0 );
            xReturn = 0;
 4003130:	e03fff15 	stw	zero,-4(fp)
 4003134:	00000106 	br	400313c <xStreamBufferNextMessageLengthBytes+0x80>
        }
    }
    else
    {
        xReturn = 0;
 4003138:	e03fff15 	stw	zero,-4(fp)
    }

    return xReturn;
 400313c:	e0bfff17 	ldw	r2,-4(fp)
}
 4003140:	e037883a 	mov	sp,fp
 4003144:	dfc00117 	ldw	ra,4(sp)
 4003148:	df000017 	ldw	fp,0(sp)
 400314c:	dec00204 	addi	sp,sp,8
 4003150:	f800283a 	ret

04003154 <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
                                    void * pvRxData,
                                    size_t xBufferLengthBytes,
                                    BaseType_t * const pxHigherPriorityTaskWoken )
{
 4003154:	defff304 	addi	sp,sp,-52
 4003158:	dfc00c15 	stw	ra,48(sp)
 400315c:	df000b15 	stw	fp,44(sp)
 4003160:	df000b04 	addi	fp,sp,44
 4003164:	e13ffa15 	stw	r4,-24(fp)
 4003168:	e17ff915 	stw	r5,-28(fp)
 400316c:	e1bff815 	stw	r6,-32(fp)
 4003170:	e1fff715 	stw	r7,-36(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4003174:	e0bffa17 	ldw	r2,-24(fp)
 4003178:	e0bffd15 	stw	r2,-12(fp)
    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
 400317c:	e03fff15 	stw	zero,-4(fp)
    /* This receive function is used by both message buffers, which store
     * discrete messages, and stream buffers, which store a continuous stream of
     * bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 4003180:	e0bffd17 	ldw	r2,-12(fp)
 4003184:	10800703 	ldbu	r2,28(r2)
 4003188:	10803fcc 	andi	r2,r2,255
 400318c:	1080004c 	andi	r2,r2,1
 4003190:	10000326 	beq	r2,zero,40031a0 <xStreamBufferReceiveFromISR+0x4c>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
 4003194:	00800104 	movi	r2,4
 4003198:	e0bffe15 	stw	r2,-8(fp)
 400319c:	00000106 	br	40031a4 <xStreamBufferReceiveFromISR+0x50>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
 40031a0:	e03ffe15 	stw	zero,-8(fp)
    }

    xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 40031a4:	e13ffd17 	ldw	r4,-12(fp)
 40031a8:	40036b80 	call	40036b8 <prvBytesInBuffer>
 40031ac:	e0bffc15 	stw	r2,-16(fp)
    /* Whether receiving a discrete message (where xBytesToStoreMessageLength
     * holds the number of bytes used to store the message length) or a stream of
     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
     * available must be greater than xBytesToStoreMessageLength to be able to
     * read bytes from the buffer. */
    if( xBytesAvailable > xBytesToStoreMessageLength )
 40031b0:	e0bffc17 	ldw	r2,-16(fp)
 40031b4:	e0fffe17 	ldw	r3,-8(fp)
 40031b8:	1880182e 	bgeu	r3,r2,400321c <xStreamBufferReceiveFromISR+0xc8>
    {
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );
 40031bc:	e1fffc17 	ldw	r7,-16(fp)
 40031c0:	e1bff817 	ldw	r6,-32(fp)
 40031c4:	e17ff917 	ldw	r5,-28(fp)
 40031c8:	e13ffd17 	ldw	r4,-12(fp)
 40031cc:	40032340 	call	4003234 <prvReadMessageFromBuffer>
 40031d0:	e0bfff15 	stw	r2,-4(fp)

        /* Was a task waiting for space in the buffer? */
        if( xReceivedLength != ( size_t ) 0 )
 40031d4:	e0bfff17 	ldw	r2,-4(fp)
 40031d8:	10001026 	beq	r2,zero,400321c <xStreamBufferReceiveFromISR+0xc8>
        {
            prvRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
 40031dc:	e03ffb15 	stw	zero,-20(fp)
 40031e0:	e0bffd17 	ldw	r2,-12(fp)
 40031e4:	10800517 	ldw	r2,20(r2)
 40031e8:	10000c26 	beq	r2,zero,400321c <xStreamBufferReceiveFromISR+0xc8>
 40031ec:	e0bffd17 	ldw	r2,-12(fp)
 40031f0:	10c00517 	ldw	r3,20(r2)
 40031f4:	e0bff717 	ldw	r2,-36(fp)
 40031f8:	d8800115 	stw	r2,4(sp)
 40031fc:	d8000015 	stw	zero,0(sp)
 4003200:	000f883a 	mov	r7,zero
 4003204:	000d883a 	mov	r6,zero
 4003208:	000b883a 	mov	r5,zero
 400320c:	1809883a 	mov	r4,r3
 4003210:	40066580 	call	4006658 <xTaskGenericNotifyFromISR>
 4003214:	e0bffd17 	ldw	r2,-12(fp)
 4003218:	10000515 	stw	zero,20(r2)
        mtCOVERAGE_TEST_MARKER();
    }

    traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

    return xReceivedLength;
 400321c:	e0bfff17 	ldw	r2,-4(fp)
}
 4003220:	e037883a 	mov	sp,fp
 4003224:	dfc00117 	ldw	ra,4(sp)
 4003228:	df000017 	ldw	fp,0(sp)
 400322c:	dec00204 	addi	sp,sp,8
 4003230:	f800283a 	ret

04003234 <prvReadMessageFromBuffer>:

static size_t prvReadMessageFromBuffer( StreamBuffer_t * pxStreamBuffer,
                                        void * pvRxData,
                                        size_t xBufferLengthBytes,
                                        size_t xBytesAvailable )
{
 4003234:	defff604 	addi	sp,sp,-40
 4003238:	dfc00915 	stw	ra,36(sp)
 400323c:	df000815 	stw	fp,32(sp)
 4003240:	df000804 	addi	fp,sp,32
 4003244:	e13ffb15 	stw	r4,-20(fp)
 4003248:	e17ffa15 	stw	r5,-24(fp)
 400324c:	e1bff915 	stw	r6,-28(fp)
 4003250:	e1fff815 	stw	r7,-32(fp)
    size_t xCount, xNextMessageLength;
    configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;
    size_t xNextTail = pxStreamBuffer->xTail;
 4003254:	e0bffb17 	ldw	r2,-20(fp)
 4003258:	10800017 	ldw	r2,0(r2)
 400325c:	e0bffe15 	stw	r2,-8(fp)

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 4003260:	e0bffb17 	ldw	r2,-20(fp)
 4003264:	10800703 	ldbu	r2,28(r2)
 4003268:	10803fcc 	andi	r2,r2,255
 400326c:	1080004c 	andi	r2,r2,1
 4003270:	10001126 	beq	r2,zero,40032b8 <prvReadMessageFromBuffer+0x84>
    {
        /* A discrete message is being received.  First receive the length
         * of the message. */
        xNextTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextTail );
 4003274:	e0bffc04 	addi	r2,fp,-16
 4003278:	e1fffe17 	ldw	r7,-8(fp)
 400327c:	01800104 	movi	r6,4
 4003280:	100b883a 	mov	r5,r2
 4003284:	e13ffb17 	ldw	r4,-20(fp)
 4003288:	40035d80 	call	40035d8 <prvReadBytesFromBuffer>
 400328c:	e0bffe15 	stw	r2,-8(fp)
        xNextMessageLength = ( size_t ) xTempNextMessageLength;
 4003290:	e0bffc17 	ldw	r2,-16(fp)
 4003294:	e0bfff15 	stw	r2,-4(fp)

        /* Reduce the number of bytes available by the number of bytes just
         * read out. */
        xBytesAvailable -= sbBYTES_TO_STORE_MESSAGE_LENGTH;
 4003298:	e0bff817 	ldw	r2,-32(fp)
 400329c:	10bfff04 	addi	r2,r2,-4
 40032a0:	e0bff815 	stw	r2,-32(fp)

        /* Check there is enough space in the buffer provided by the
         * user. */
        if( xNextMessageLength > xBufferLengthBytes )
 40032a4:	e0bfff17 	ldw	r2,-4(fp)
 40032a8:	e0fff917 	ldw	r3,-28(fp)
 40032ac:	1880042e 	bgeu	r3,r2,40032c0 <prvReadMessageFromBuffer+0x8c>
        {
            /* The user has provided insufficient space to read the message. */
            xNextMessageLength = 0;
 40032b0:	e03fff15 	stw	zero,-4(fp)
 40032b4:	00000206 	br	40032c0 <prvReadMessageFromBuffer+0x8c>
    }
    else
    {
        /* A stream of bytes is being received (as opposed to a discrete
         * message), so read as many bytes as possible. */
        xNextMessageLength = xBufferLengthBytes;
 40032b8:	e0bff917 	ldw	r2,-28(fp)
 40032bc:	e0bfff15 	stw	r2,-4(fp)
    }

    /* Use the minimum of the wanted bytes and the available bytes. */
    xCount = configMIN( xNextMessageLength, xBytesAvailable );
 40032c0:	e0ffff17 	ldw	r3,-4(fp)
 40032c4:	e0bff817 	ldw	r2,-32(fp)
 40032c8:	1880012e 	bgeu	r3,r2,40032d0 <prvReadMessageFromBuffer+0x9c>
 40032cc:	1805883a 	mov	r2,r3
 40032d0:	e0bffd15 	stw	r2,-12(fp)

    if( xCount != ( size_t ) 0 )
 40032d4:	e0bffd17 	ldw	r2,-12(fp)
 40032d8:	10000826 	beq	r2,zero,40032fc <prvReadMessageFromBuffer+0xc8>
    {
        /* Read the actual data and update the tail to mark the data as officially consumed. */
        pxStreamBuffer->xTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xCount, xNextTail ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
 40032dc:	e1fffe17 	ldw	r7,-8(fp)
 40032e0:	e1bffd17 	ldw	r6,-12(fp)
 40032e4:	e17ffa17 	ldw	r5,-24(fp)
 40032e8:	e13ffb17 	ldw	r4,-20(fp)
 40032ec:	40035d80 	call	40035d8 <prvReadBytesFromBuffer>
 40032f0:	1007883a 	mov	r3,r2
 40032f4:	e0bffb17 	ldw	r2,-20(fp)
 40032f8:	10c00015 	stw	r3,0(r2)
    }

    return xCount;
 40032fc:	e0bffd17 	ldw	r2,-12(fp)
}
 4003300:	e037883a 	mov	sp,fp
 4003304:	dfc00117 	ldw	ra,4(sp)
 4003308:	df000017 	ldw	fp,0(sp)
 400330c:	dec00204 	addi	sp,sp,8
 4003310:	f800283a 	ret

04003314 <xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
 4003314:	defffb04 	addi	sp,sp,-20
 4003318:	df000415 	stw	fp,16(sp)
 400331c:	df000404 	addi	fp,sp,16
 4003320:	e13ffc15 	stw	r4,-16(fp)
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4003324:	e0bffc17 	ldw	r2,-16(fp)
 4003328:	e0bffe15 	stw	r2,-8(fp)
    size_t xTail;

    configASSERT( pxStreamBuffer );

    /* True if no bytes are available. */
    xTail = pxStreamBuffer->xTail;
 400332c:	e0bffe17 	ldw	r2,-8(fp)
 4003330:	10800017 	ldw	r2,0(r2)
 4003334:	e0bffd15 	stw	r2,-12(fp)

    if( pxStreamBuffer->xHead == xTail )
 4003338:	e0bffe17 	ldw	r2,-8(fp)
 400333c:	10800117 	ldw	r2,4(r2)
 4003340:	e0fffd17 	ldw	r3,-12(fp)
 4003344:	1880031e 	bne	r3,r2,4003354 <xStreamBufferIsEmpty+0x40>
    {
        xReturn = pdTRUE;
 4003348:	00800044 	movi	r2,1
 400334c:	e0bfff15 	stw	r2,-4(fp)
 4003350:	00000106 	br	4003358 <xStreamBufferIsEmpty+0x44>
    }
    else
    {
        xReturn = pdFALSE;
 4003354:	e03fff15 	stw	zero,-4(fp)
    }

    return xReturn;
 4003358:	e0bfff17 	ldw	r2,-4(fp)
}
 400335c:	e037883a 	mov	sp,fp
 4003360:	df000017 	ldw	fp,0(sp)
 4003364:	dec00104 	addi	sp,sp,4
 4003368:	f800283a 	ret

0400336c <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
 400336c:	defffa04 	addi	sp,sp,-24
 4003370:	dfc00515 	stw	ra,20(sp)
 4003374:	df000415 	stw	fp,16(sp)
 4003378:	df000404 	addi	fp,sp,16
 400337c:	e13ffc15 	stw	r4,-16(fp)
    BaseType_t xReturn;
    size_t xBytesToStoreMessageLength;
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4003380:	e0bffc17 	ldw	r2,-16(fp)
 4003384:	e0bffd15 	stw	r2,-12(fp)

    /* This generic version of the receive function is used by both message
     * buffers, which store discrete messages, and stream buffers, which store a
     * continuous stream of bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 4003388:	e0bffd17 	ldw	r2,-12(fp)
 400338c:	10800703 	ldbu	r2,28(r2)
 4003390:	10803fcc 	andi	r2,r2,255
 4003394:	1080004c 	andi	r2,r2,1
 4003398:	10000326 	beq	r2,zero,40033a8 <xStreamBufferIsFull+0x3c>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
 400339c:	00800104 	movi	r2,4
 40033a0:	e0bffe15 	stw	r2,-8(fp)
 40033a4:	00000106 	br	40033ac <xStreamBufferIsFull+0x40>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
 40033a8:	e03ffe15 	stw	zero,-8(fp)
    }

    /* True if the available space equals zero. */
    if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
 40033ac:	e13ffc17 	ldw	r4,-16(fp)
 40033b0:	4002ae40 	call	4002ae4 <xStreamBufferSpacesAvailable>
 40033b4:	1007883a 	mov	r3,r2
 40033b8:	e0bffe17 	ldw	r2,-8(fp)
 40033bc:	10c00336 	bltu	r2,r3,40033cc <xStreamBufferIsFull+0x60>
    {
        xReturn = pdTRUE;
 40033c0:	00800044 	movi	r2,1
 40033c4:	e0bfff15 	stw	r2,-4(fp)
 40033c8:	00000106 	br	40033d0 <xStreamBufferIsFull+0x64>
    }
    else
    {
        xReturn = pdFALSE;
 40033cc:	e03fff15 	stw	zero,-4(fp)
    }

    return xReturn;
 40033d0:	e0bfff17 	ldw	r2,-4(fp)
}
 40033d4:	e037883a 	mov	sp,fp
 40033d8:	dfc00117 	ldw	ra,4(sp)
 40033dc:	df000017 	ldw	fp,0(sp)
 40033e0:	dec00204 	addi	sp,sp,8
 40033e4:	f800283a 	ret

040033e8 <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
                                              BaseType_t * pxHigherPriorityTaskWoken )
{
 40033e8:	defff704 	addi	sp,sp,-36
 40033ec:	dfc00815 	stw	ra,32(sp)
 40033f0:	df000715 	stw	fp,28(sp)
 40033f4:	df000704 	addi	fp,sp,28
 40033f8:	e13ffc15 	stw	r4,-16(fp)
 40033fc:	e17ffb15 	stw	r5,-20(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4003400:	e0bffc17 	ldw	r2,-16(fp)
 4003404:	e0bffe15 	stw	r2,-8(fp)
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;

    configASSERT( pxStreamBuffer );

    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
 4003408:	e03ffd15 	stw	zero,-12(fp)
    {
        if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
 400340c:	e0bffe17 	ldw	r2,-8(fp)
 4003410:	10800417 	ldw	r2,16(r2)
 4003414:	10000f26 	beq	r2,zero,4003454 <xStreamBufferSendCompletedFromISR+0x6c>
        {
            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
 4003418:	e0bffe17 	ldw	r2,-8(fp)
 400341c:	10c00417 	ldw	r3,16(r2)
 4003420:	e0bffb17 	ldw	r2,-20(fp)
 4003424:	d8800115 	stw	r2,4(sp)
 4003428:	d8000015 	stw	zero,0(sp)
 400342c:	000f883a 	mov	r7,zero
 4003430:	000d883a 	mov	r6,zero
 4003434:	000b883a 	mov	r5,zero
 4003438:	1809883a 	mov	r4,r3
 400343c:	40066580 	call	4006658 <xTaskGenericNotifyFromISR>
                                         ( uint32_t ) 0,
                                         eNoAction,
                                         pxHigherPriorityTaskWoken );
            ( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
 4003440:	e0bffe17 	ldw	r2,-8(fp)
 4003444:	10000415 	stw	zero,16(r2)
            xReturn = pdTRUE;
 4003448:	00800044 	movi	r2,1
 400344c:	e0bfff15 	stw	r2,-4(fp)
 4003450:	00000106 	br	4003458 <xStreamBufferSendCompletedFromISR+0x70>
        }
        else
        {
            xReturn = pdFALSE;
 4003454:	e03fff15 	stw	zero,-4(fp)
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 4003458:	e0bfff17 	ldw	r2,-4(fp)
}
 400345c:	e037883a 	mov	sp,fp
 4003460:	dfc00117 	ldw	ra,4(sp)
 4003464:	df000017 	ldw	fp,0(sp)
 4003468:	dec00204 	addi	sp,sp,8
 400346c:	f800283a 	ret

04003470 <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
                                                 BaseType_t * pxHigherPriorityTaskWoken )
{
 4003470:	defff704 	addi	sp,sp,-36
 4003474:	dfc00815 	stw	ra,32(sp)
 4003478:	df000715 	stw	fp,28(sp)
 400347c:	df000704 	addi	fp,sp,28
 4003480:	e13ffc15 	stw	r4,-16(fp)
 4003484:	e17ffb15 	stw	r5,-20(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4003488:	e0bffc17 	ldw	r2,-16(fp)
 400348c:	e0bffe15 	stw	r2,-8(fp)
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;

    configASSERT( pxStreamBuffer );

    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
 4003490:	e03ffd15 	stw	zero,-12(fp)
    {
        if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
 4003494:	e0bffe17 	ldw	r2,-8(fp)
 4003498:	10800517 	ldw	r2,20(r2)
 400349c:	10000f26 	beq	r2,zero,40034dc <xStreamBufferReceiveCompletedFromISR+0x6c>
        {
            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
 40034a0:	e0bffe17 	ldw	r2,-8(fp)
 40034a4:	10c00517 	ldw	r3,20(r2)
 40034a8:	e0bffb17 	ldw	r2,-20(fp)
 40034ac:	d8800115 	stw	r2,4(sp)
 40034b0:	d8000015 	stw	zero,0(sp)
 40034b4:	000f883a 	mov	r7,zero
 40034b8:	000d883a 	mov	r6,zero
 40034bc:	000b883a 	mov	r5,zero
 40034c0:	1809883a 	mov	r4,r3
 40034c4:	40066580 	call	4006658 <xTaskGenericNotifyFromISR>
                                         ( uint32_t ) 0,
                                         eNoAction,
                                         pxHigherPriorityTaskWoken );
            ( pxStreamBuffer )->xTaskWaitingToSend = NULL;
 40034c8:	e0bffe17 	ldw	r2,-8(fp)
 40034cc:	10000515 	stw	zero,20(r2)
            xReturn = pdTRUE;
 40034d0:	00800044 	movi	r2,1
 40034d4:	e0bfff15 	stw	r2,-4(fp)
 40034d8:	00000106 	br	40034e0 <xStreamBufferReceiveCompletedFromISR+0x70>
        }
        else
        {
            xReturn = pdFALSE;
 40034dc:	e03fff15 	stw	zero,-4(fp)
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 40034e0:	e0bfff17 	ldw	r2,-4(fp)
}
 40034e4:	e037883a 	mov	sp,fp
 40034e8:	dfc00117 	ldw	ra,4(sp)
 40034ec:	df000017 	ldw	fp,0(sp)
 40034f0:	dec00204 	addi	sp,sp,8
 40034f4:	f800283a 	ret

040034f8 <prvWriteBytesToBuffer>:

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer,
                                     const uint8_t * pucData,
                                     size_t xCount,
                                     size_t xHead )
{
 40034f8:	defff904 	addi	sp,sp,-28
 40034fc:	dfc00615 	stw	ra,24(sp)
 4003500:	df000515 	stw	fp,20(sp)
 4003504:	df000504 	addi	fp,sp,20
 4003508:	e13ffe15 	stw	r4,-8(fp)
 400350c:	e17ffd15 	stw	r5,-12(fp)
 4003510:	e1bffc15 	stw	r6,-16(fp)
 4003514:	e1fffb15 	stw	r7,-20(fp)
    configASSERT( xCount > ( size_t ) 0 );

    /* Calculate the number of bytes that can be added in the first write -
     * which may be less than the total number of bytes that need to be added if
     * the buffer will wrap back to the beginning. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xHead, xCount );
 4003518:	e0bffe17 	ldw	r2,-8(fp)
 400351c:	10c00217 	ldw	r3,8(r2)
 4003520:	e0bffb17 	ldw	r2,-20(fp)
 4003524:	1887c83a 	sub	r3,r3,r2
 4003528:	e0bffc17 	ldw	r2,-16(fp)
 400352c:	1880012e 	bgeu	r3,r2,4003534 <prvWriteBytesToBuffer+0x3c>
 4003530:	1805883a 	mov	r2,r3
 4003534:	e0bfff15 	stw	r2,-4(fp)

    /* Write as many bytes as can be written in the first write. */
    configASSERT( ( xHead + xFirstLength ) <= pxStreamBuffer->xLength );
    ( void ) memcpy( ( void * ) ( &( pxStreamBuffer->pucBuffer[ xHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
 4003538:	e0bffe17 	ldw	r2,-8(fp)
 400353c:	10c00617 	ldw	r3,24(r2)
 4003540:	e0bffb17 	ldw	r2,-20(fp)
 4003544:	1885883a 	add	r2,r3,r2
 4003548:	e1bfff17 	ldw	r6,-4(fp)
 400354c:	e17ffd17 	ldw	r5,-12(fp)
 4003550:	1009883a 	mov	r4,r2
 4003554:	40073000 	call	4007300 <memcpy>

    /* If the number of bytes written was less than the number that could be
     * written in the first write... */
    if( xCount > xFirstLength )
 4003558:	e0bffc17 	ldw	r2,-16(fp)
 400355c:	e0ffff17 	ldw	r3,-4(fp)
 4003560:	18800a2e 	bgeu	r3,r2,400358c <prvWriteBytesToBuffer+0x94>
    {
        /* ...then write the remaining bytes to the start of the buffer. */
        configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
        ( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
 4003564:	e0bffe17 	ldw	r2,-8(fp)
 4003568:	11000617 	ldw	r4,24(r2)
 400356c:	e0fffd17 	ldw	r3,-12(fp)
 4003570:	e0bfff17 	ldw	r2,-4(fp)
 4003574:	188b883a 	add	r5,r3,r2
 4003578:	e0fffc17 	ldw	r3,-16(fp)
 400357c:	e0bfff17 	ldw	r2,-4(fp)
 4003580:	1885c83a 	sub	r2,r3,r2
 4003584:	100d883a 	mov	r6,r2
 4003588:	40073000 	call	4007300 <memcpy>
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xHead += xCount;
 400358c:	e0fffb17 	ldw	r3,-20(fp)
 4003590:	e0bffc17 	ldw	r2,-16(fp)
 4003594:	1885883a 	add	r2,r3,r2
 4003598:	e0bffb15 	stw	r2,-20(fp)

    if( xHead >= pxStreamBuffer->xLength )
 400359c:	e0bffe17 	ldw	r2,-8(fp)
 40035a0:	10800217 	ldw	r2,8(r2)
 40035a4:	e0fffb17 	ldw	r3,-20(fp)
 40035a8:	18800536 	bltu	r3,r2,40035c0 <prvWriteBytesToBuffer+0xc8>
    {
        xHead -= pxStreamBuffer->xLength;
 40035ac:	e0bffe17 	ldw	r2,-8(fp)
 40035b0:	10800217 	ldw	r2,8(r2)
 40035b4:	e0fffb17 	ldw	r3,-20(fp)
 40035b8:	1885c83a 	sub	r2,r3,r2
 40035bc:	e0bffb15 	stw	r2,-20(fp)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xHead;
 40035c0:	e0bffb17 	ldw	r2,-20(fp)
}
 40035c4:	e037883a 	mov	sp,fp
 40035c8:	dfc00117 	ldw	ra,4(sp)
 40035cc:	df000017 	ldw	fp,0(sp)
 40035d0:	dec00204 	addi	sp,sp,8
 40035d4:	f800283a 	ret

040035d8 <prvReadBytesFromBuffer>:

static size_t prvReadBytesFromBuffer( StreamBuffer_t * pxStreamBuffer,
                                      uint8_t * pucData,
                                      size_t xCount,
                                      size_t xTail )
{
 40035d8:	defff904 	addi	sp,sp,-28
 40035dc:	dfc00615 	stw	ra,24(sp)
 40035e0:	df000515 	stw	fp,20(sp)
 40035e4:	df000504 	addi	fp,sp,20
 40035e8:	e13ffe15 	stw	r4,-8(fp)
 40035ec:	e17ffd15 	stw	r5,-12(fp)
 40035f0:	e1bffc15 	stw	r6,-16(fp)
 40035f4:	e1fffb15 	stw	r7,-20(fp)
    configASSERT( xCount != ( size_t ) 0 );

    /* Calculate the number of bytes that can be read - which may be
     * less than the number wanted if the data wraps around to the start of
     * the buffer. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xTail, xCount );
 40035f8:	e0bffe17 	ldw	r2,-8(fp)
 40035fc:	10c00217 	ldw	r3,8(r2)
 4003600:	e0bffb17 	ldw	r2,-20(fp)
 4003604:	1887c83a 	sub	r3,r3,r2
 4003608:	e0bffc17 	ldw	r2,-16(fp)
 400360c:	1880012e 	bgeu	r3,r2,4003614 <prvReadBytesFromBuffer+0x3c>
 4003610:	1805883a 	mov	r2,r3
 4003614:	e0bfff15 	stw	r2,-4(fp)

    /* Obtain the number of bytes it is possible to obtain in the first
     * read.  Asserts check bounds of read and write. */
    configASSERT( xFirstLength <= xCount );
    configASSERT( ( xTail + xFirstLength ) <= pxStreamBuffer->xLength );
    ( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
 4003618:	e0bffe17 	ldw	r2,-8(fp)
 400361c:	10c00617 	ldw	r3,24(r2)
 4003620:	e0bffb17 	ldw	r2,-20(fp)
 4003624:	1885883a 	add	r2,r3,r2
 4003628:	e1bfff17 	ldw	r6,-4(fp)
 400362c:	100b883a 	mov	r5,r2
 4003630:	e13ffd17 	ldw	r4,-12(fp)
 4003634:	40073000 	call	4007300 <memcpy>

    /* If the total number of wanted bytes is greater than the number
     * that could be read in the first read... */
    if( xCount > xFirstLength )
 4003638:	e0bffc17 	ldw	r2,-16(fp)
 400363c:	e0ffff17 	ldw	r3,-4(fp)
 4003640:	18800a2e 	bgeu	r3,r2,400366c <prvReadBytesFromBuffer+0x94>
    {
        /* ...then read the remaining bytes from the start of the buffer. */
        ( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
 4003644:	e0fffd17 	ldw	r3,-12(fp)
 4003648:	e0bfff17 	ldw	r2,-4(fp)
 400364c:	1889883a 	add	r4,r3,r2
 4003650:	e0bffe17 	ldw	r2,-8(fp)
 4003654:	11400617 	ldw	r5,24(r2)
 4003658:	e0fffc17 	ldw	r3,-16(fp)
 400365c:	e0bfff17 	ldw	r2,-4(fp)
 4003660:	1885c83a 	sub	r2,r3,r2
 4003664:	100d883a 	mov	r6,r2
 4003668:	40073000 	call	4007300 <memcpy>
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* Move the tail pointer to effectively remove the data read from the buffer. */
    xTail += xCount;
 400366c:	e0fffb17 	ldw	r3,-20(fp)
 4003670:	e0bffc17 	ldw	r2,-16(fp)
 4003674:	1885883a 	add	r2,r3,r2
 4003678:	e0bffb15 	stw	r2,-20(fp)

    if( xTail >= pxStreamBuffer->xLength )
 400367c:	e0bffe17 	ldw	r2,-8(fp)
 4003680:	10800217 	ldw	r2,8(r2)
 4003684:	e0fffb17 	ldw	r3,-20(fp)
 4003688:	18800536 	bltu	r3,r2,40036a0 <prvReadBytesFromBuffer+0xc8>
    {
        xTail -= pxStreamBuffer->xLength;
 400368c:	e0bffe17 	ldw	r2,-8(fp)
 4003690:	10800217 	ldw	r2,8(r2)
 4003694:	e0fffb17 	ldw	r3,-20(fp)
 4003698:	1885c83a 	sub	r2,r3,r2
 400369c:	e0bffb15 	stw	r2,-20(fp)
    }

    return xTail;
 40036a0:	e0bffb17 	ldw	r2,-20(fp)
}
 40036a4:	e037883a 	mov	sp,fp
 40036a8:	dfc00117 	ldw	ra,4(sp)
 40036ac:	df000017 	ldw	fp,0(sp)
 40036b0:	dec00204 	addi	sp,sp,8
 40036b4:	f800283a 	ret

040036b8 <prvBytesInBuffer>:
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
 40036b8:	defffd04 	addi	sp,sp,-12
 40036bc:	df000215 	stw	fp,8(sp)
 40036c0:	df000204 	addi	fp,sp,8
 40036c4:	e13ffe15 	stw	r4,-8(fp)
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 40036c8:	e0bffe17 	ldw	r2,-8(fp)
 40036cc:	10c00217 	ldw	r3,8(r2)
 40036d0:	e0bffe17 	ldw	r2,-8(fp)
 40036d4:	10800117 	ldw	r2,4(r2)
 40036d8:	1885883a 	add	r2,r3,r2
 40036dc:	e0bfff15 	stw	r2,-4(fp)
    xCount -= pxStreamBuffer->xTail;
 40036e0:	e0bffe17 	ldw	r2,-8(fp)
 40036e4:	10800017 	ldw	r2,0(r2)
 40036e8:	e0ffff17 	ldw	r3,-4(fp)
 40036ec:	1885c83a 	sub	r2,r3,r2
 40036f0:	e0bfff15 	stw	r2,-4(fp)

    if( xCount >= pxStreamBuffer->xLength )
 40036f4:	e0bffe17 	ldw	r2,-8(fp)
 40036f8:	10800217 	ldw	r2,8(r2)
 40036fc:	e0ffff17 	ldw	r3,-4(fp)
 4003700:	18800536 	bltu	r3,r2,4003718 <prvBytesInBuffer+0x60>
    {
        xCount -= pxStreamBuffer->xLength;
 4003704:	e0bffe17 	ldw	r2,-8(fp)
 4003708:	10800217 	ldw	r2,8(r2)
 400370c:	e0ffff17 	ldw	r3,-4(fp)
 4003710:	1885c83a 	sub	r2,r3,r2
 4003714:	e0bfff15 	stw	r2,-4(fp)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xCount;
 4003718:	e0bfff17 	ldw	r2,-4(fp)
}
 400371c:	e037883a 	mov	sp,fp
 4003720:	df000017 	ldw	fp,0(sp)
 4003724:	dec00104 	addi	sp,sp,4
 4003728:	f800283a 	ret

0400372c <prvInitialiseNewStreamBuffer>:
                                          size_t xBufferSizeBytes,
                                          size_t xTriggerLevelBytes,
                                          uint8_t ucFlags,
                                          StreamBufferCallbackFunction_t pxSendCompletedCallback,
                                          StreamBufferCallbackFunction_t pxReceiveCompletedCallback )
{
 400372c:	defff904 	addi	sp,sp,-28
 4003730:	dfc00615 	stw	ra,24(sp)
 4003734:	df000515 	stw	fp,20(sp)
 4003738:	df000504 	addi	fp,sp,20
 400373c:	e13fff15 	stw	r4,-4(fp)
 4003740:	e17ffe15 	stw	r5,-8(fp)
 4003744:	e1bffd15 	stw	r6,-12(fp)
 4003748:	e1fffc15 	stw	r7,-16(fp)
 400374c:	e0800217 	ldw	r2,8(fp)
 4003750:	e0bffb05 	stb	r2,-20(fp)
        const BaseType_t xWriteValue = 0x55;
        configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
    } /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
    #endif

    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
 4003754:	01800804 	movi	r6,32
 4003758:	000b883a 	mov	r5,zero
 400375c:	e13fff17 	ldw	r4,-4(fp)
 4003760:	40074880 	call	4007488 <memset>
    pxStreamBuffer->pucBuffer = pucBuffer;
 4003764:	e0bfff17 	ldw	r2,-4(fp)
 4003768:	e0fffe17 	ldw	r3,-8(fp)
 400376c:	10c00615 	stw	r3,24(r2)
    pxStreamBuffer->xLength = xBufferSizeBytes;
 4003770:	e0bfff17 	ldw	r2,-4(fp)
 4003774:	e0fffd17 	ldw	r3,-12(fp)
 4003778:	10c00215 	stw	r3,8(r2)
    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
 400377c:	e0bfff17 	ldw	r2,-4(fp)
 4003780:	e0fffc17 	ldw	r3,-16(fp)
 4003784:	10c00315 	stw	r3,12(r2)
    pxStreamBuffer->ucFlags = ucFlags;
 4003788:	e0bfff17 	ldw	r2,-4(fp)
 400378c:	e0fffb03 	ldbu	r3,-20(fp)
 4003790:	10c00705 	stb	r3,28(r2)
    {
        ( void ) pxSendCompletedCallback;
        ( void ) pxReceiveCompletedCallback;
    }
    #endif
}
 4003794:	0001883a 	nop
 4003798:	e037883a 	mov	sp,fp
 400379c:	dfc00117 	ldw	ra,4(sp)
 40037a0:	df000017 	ldw	fp,0(sp)
 40037a4:	dec00204 	addi	sp,sp,8
 40037a8:	f800283a 	ret

040037ac <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
 40037ac:	defff304 	addi	sp,sp,-52
 40037b0:	dfc00c15 	stw	ra,48(sp)
 40037b4:	df000b15 	stw	fp,44(sp)
 40037b8:	df000b04 	addi	fp,sp,44
 40037bc:	e13ffc15 	stw	r4,-16(fp)
 40037c0:	e17ffb15 	stw	r5,-20(fp)
 40037c4:	3005883a 	mov	r2,r6
 40037c8:	e1fff915 	stw	r7,-28(fp)
 40037cc:	e0bffa0d 	sth	r2,-24(fp)
        #else /* portSTACK_GROWTH */
        {
            StackType_t * pxStack;

            /* Allocate space for the stack used by the task being created. */
            pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 40037d0:	e0bffa0b 	ldhu	r2,-24(fp)
 40037d4:	100490ba 	slli	r2,r2,2
 40037d8:	1009883a 	mov	r4,r2
 40037dc:	40010340 	call	4001034 <pvPortMalloc>
 40037e0:	e0bffd15 	stw	r2,-12(fp)

            if( pxStack != NULL )
 40037e4:	e0bffd17 	ldw	r2,-12(fp)
 40037e8:	10001026 	beq	r2,zero,400382c <xTaskCreate+0x80>
            {
                /* Allocate space for the TCB. */
                pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
 40037ec:	01001404 	movi	r4,80
 40037f0:	40010340 	call	4001034 <pvPortMalloc>
 40037f4:	e0bfff15 	stw	r2,-4(fp)

                if( pxNewTCB != NULL )
 40037f8:	e0bfff17 	ldw	r2,-4(fp)
 40037fc:	10000826 	beq	r2,zero,4003820 <xTaskCreate+0x74>
                {
                    memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
 4003800:	01801404 	movi	r6,80
 4003804:	000b883a 	mov	r5,zero
 4003808:	e13fff17 	ldw	r4,-4(fp)
 400380c:	40074880 	call	4007488 <memset>

                    /* Store the stack location in the TCB. */
                    pxNewTCB->pxStack = pxStack;
 4003810:	e0bfff17 	ldw	r2,-4(fp)
 4003814:	e0fffd17 	ldw	r3,-12(fp)
 4003818:	10c00c15 	stw	r3,48(r2)
 400381c:	00000406 	br	4003830 <xTaskCreate+0x84>
                }
                else
                {
                    /* The stack cannot be used as the TCB was not created.  Free
                     * it again. */
                    vPortFreeStack( pxStack );
 4003820:	e13ffd17 	ldw	r4,-12(fp)
 4003824:	400111c0 	call	400111c <vPortFree>
 4003828:	00000106 	br	4003830 <xTaskCreate+0x84>
                }
            }
            else
            {
                pxNewTCB = NULL;
 400382c:	e03fff15 	stw	zero,-4(fp)
            }
        }
        #endif /* portSTACK_GROWTH */

        if( pxNewTCB != NULL )
 4003830:	e0bfff17 	ldw	r2,-4(fp)
 4003834:	10001226 	beq	r2,zero,4003880 <xTaskCreate+0xd4>
                 * task was created dynamically in case it is later deleted. */
                pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
            }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 4003838:	e0fffa0b 	ldhu	r3,-24(fp)
 400383c:	d8000315 	stw	zero,12(sp)
 4003840:	e0bfff17 	ldw	r2,-4(fp)
 4003844:	d8800215 	stw	r2,8(sp)
 4003848:	e0800317 	ldw	r2,12(fp)
 400384c:	d8800115 	stw	r2,4(sp)
 4003850:	e0800217 	ldw	r2,8(fp)
 4003854:	d8800015 	stw	r2,0(sp)
 4003858:	e1fff917 	ldw	r7,-28(fp)
 400385c:	180d883a 	mov	r6,r3
 4003860:	e17ffb17 	ldw	r5,-20(fp)
 4003864:	e13ffc17 	ldw	r4,-16(fp)
 4003868:	40038a00 	call	40038a0 <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
 400386c:	e13fff17 	ldw	r4,-4(fp)
 4003870:	4003a4c0 	call	4003a4c <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
 4003874:	00800044 	movi	r2,1
 4003878:	e0bffe15 	stw	r2,-8(fp)
 400387c:	00000206 	br	4003888 <xTaskCreate+0xdc>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 4003880:	00bfffc4 	movi	r2,-1
 4003884:	e0bffe15 	stw	r2,-8(fp)
        }

        return xReturn;
 4003888:	e0bffe17 	ldw	r2,-8(fp)
    }
 400388c:	e037883a 	mov	sp,fp
 4003890:	dfc00117 	ldw	ra,4(sp)
 4003894:	df000017 	ldw	fp,0(sp)
 4003898:	dec00204 	addi	sp,sp,8
 400389c:	f800283a 	ret

040038a0 <prvInitialiseNewTask>:
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions )
{
 40038a0:	defff804 	addi	sp,sp,-32
 40038a4:	dfc00715 	stw	ra,28(sp)
 40038a8:	df000615 	stw	fp,24(sp)
 40038ac:	df000604 	addi	fp,sp,24
 40038b0:	e13ffd15 	stw	r4,-12(fp)
 40038b4:	e17ffc15 	stw	r5,-16(fp)
 40038b8:	e1bffb15 	stw	r6,-20(fp)
 40038bc:	e1fffa15 	stw	r7,-24(fp)

    /* Avoid dependency on memset() if it is not required. */
    #if ( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
    {
        /* Fill the stack with a known value to assist debugging. */
        ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 40038c0:	e0800417 	ldw	r2,16(fp)
 40038c4:	10c00c17 	ldw	r3,48(r2)
 40038c8:	e0bffb17 	ldw	r2,-20(fp)
 40038cc:	100490ba 	slli	r2,r2,2
 40038d0:	100d883a 	mov	r6,r2
 40038d4:	01402944 	movi	r5,165
 40038d8:	1809883a 	mov	r4,r3
 40038dc:	40074880 	call	4007488 <memset>
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
    {
        pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 40038e0:	e0800417 	ldw	r2,16(fp)
 40038e4:	10c00c17 	ldw	r3,48(r2)
 40038e8:	e13ffb17 	ldw	r4,-20(fp)
 40038ec:	00900034 	movhi	r2,16384
 40038f0:	10bfffc4 	addi	r2,r2,-1
 40038f4:	2085883a 	add	r2,r4,r2
 40038f8:	100490ba 	slli	r2,r2,2
 40038fc:	1885883a 	add	r2,r3,r2
 4003900:	e0bffe15 	stw	r2,-8(fp)
        pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 4003904:	e0fffe17 	ldw	r3,-8(fp)
 4003908:	00bfff04 	movi	r2,-4
 400390c:	1884703a 	and	r2,r3,r2
 4003910:	e0bffe15 	stw	r2,-8(fp)
        pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
 4003914:	e0bffc17 	ldw	r2,-16(fp)
 4003918:	10001c26 	beq	r2,zero,400398c <prvInitialiseNewTask+0xec>
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 400391c:	e03fff15 	stw	zero,-4(fp)
 4003920:	00001306 	br	4003970 <prvInitialiseNewTask+0xd0>
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 4003924:	e0fffc17 	ldw	r3,-16(fp)
 4003928:	e0bfff17 	ldw	r2,-4(fp)
 400392c:	1885883a 	add	r2,r3,r2
 4003930:	10c00003 	ldbu	r3,0(r2)
 4003934:	e1000417 	ldw	r4,16(fp)
 4003938:	e0bfff17 	ldw	r2,-4(fp)
 400393c:	2085883a 	add	r2,r4,r2
 4003940:	10c00d05 	stb	r3,52(r2)

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
 4003944:	e0fffc17 	ldw	r3,-16(fp)
 4003948:	e0bfff17 	ldw	r2,-4(fp)
 400394c:	1885883a 	add	r2,r3,r2
 4003950:	10800003 	ldbu	r2,0(r2)
 4003954:	10803fcc 	andi	r2,r2,255
 4003958:	1080201c 	xori	r2,r2,128
 400395c:	10bfe004 	addi	r2,r2,-128
 4003960:	10000726 	beq	r2,zero,4003980 <prvInitialiseNewTask+0xe0>
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 4003964:	e0bfff17 	ldw	r2,-4(fp)
 4003968:	10800044 	addi	r2,r2,1
 400396c:	e0bfff15 	stw	r2,-4(fp)
 4003970:	e0bfff17 	ldw	r2,-4(fp)
 4003974:	10800230 	cmpltui	r2,r2,8
 4003978:	103fea1e 	bne	r2,zero,4003924 <prvInitialiseNewTask+0x84>
 400397c:	00000106 	br	4003984 <prvInitialiseNewTask+0xe4>
            {
                break;
 4003980:	0001883a 	nop
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 4003984:	e0800417 	ldw	r2,16(fp)
 4003988:	10000ec5 	stb	zero,59(r2)
    }

    /* This is used as an array index so must ensure it's not too large. */
    configASSERT( uxPriority < configMAX_PRIORITIES );

    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 400398c:	e0800217 	ldw	r2,8(fp)
 4003990:	10800170 	cmpltui	r2,r2,5
 4003994:	1000021e 	bne	r2,zero,40039a0 <prvInitialiseNewTask+0x100>
    {
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 4003998:	00800104 	movi	r2,4
 400399c:	e0800215 	stw	r2,8(fp)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
 40039a0:	e0800417 	ldw	r2,16(fp)
 40039a4:	e0c00217 	ldw	r3,8(fp)
 40039a8:	10c00b15 	stw	r3,44(r2)
    #if ( configUSE_MUTEXES == 1 )
    {
        pxNewTCB->uxBasePriority = uxPriority;
 40039ac:	e0800417 	ldw	r2,16(fp)
 40039b0:	e0c00217 	ldw	r3,8(fp)
 40039b4:	10c01015 	stw	r3,64(r2)
    }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 40039b8:	e0800417 	ldw	r2,16(fp)
 40039bc:	10800104 	addi	r2,r2,4
 40039c0:	1009883a 	mov	r4,r2
 40039c4:	4000b080 	call	4000b08 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 40039c8:	e0800417 	ldw	r2,16(fp)
 40039cc:	10800604 	addi	r2,r2,24
 40039d0:	1009883a 	mov	r4,r2
 40039d4:	4000b080 	call	4000b08 <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 40039d8:	e0800417 	ldw	r2,16(fp)
 40039dc:	e0c00417 	ldw	r3,16(fp)
 40039e0:	10c00415 	stw	r3,16(r2)

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 40039e4:	00c00144 	movi	r3,5
 40039e8:	e0800217 	ldw	r2,8(fp)
 40039ec:	1887c83a 	sub	r3,r3,r2
 40039f0:	e0800417 	ldw	r2,16(fp)
 40039f4:	10c00615 	stw	r3,24(r2)
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 40039f8:	e0800417 	ldw	r2,16(fp)
 40039fc:	e0c00417 	ldw	r3,16(fp)
 4003a00:	10c00915 	stw	r3,36(r2)
            }
            #endif /* portSTACK_GROWTH */
        }
        #else /* portHAS_STACK_OVERFLOW_CHECKING */
        {
            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 4003a04:	e1bffa17 	ldw	r6,-24(fp)
 4003a08:	e17ffd17 	ldw	r5,-12(fp)
 4003a0c:	e13ffe17 	ldw	r4,-8(fp)
 4003a10:	4000d5c0 	call	4000d5c <pxPortInitialiseStack>
 4003a14:	1007883a 	mov	r3,r2
 4003a18:	e0800417 	ldw	r2,16(fp)
 4003a1c:	10c00015 	stw	r3,0(r2)
        }
        #endif /* portHAS_STACK_OVERFLOW_CHECKING */
    }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
 4003a20:	e0800317 	ldw	r2,12(fp)
 4003a24:	10000326 	beq	r2,zero,4003a34 <prvInitialiseNewTask+0x194>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 4003a28:	e0800317 	ldw	r2,12(fp)
 4003a2c:	e0c00417 	ldw	r3,16(fp)
 4003a30:	10c00015 	stw	r3,0(r2)
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
 4003a34:	0001883a 	nop
 4003a38:	e037883a 	mov	sp,fp
 4003a3c:	dfc00117 	ldw	ra,4(sp)
 4003a40:	df000017 	ldw	fp,0(sp)
 4003a44:	dec00204 	addi	sp,sp,8
 4003a48:	f800283a 	ret

04003a4c <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
 4003a4c:	defffa04 	addi	sp,sp,-24
 4003a50:	dfc00515 	stw	ra,20(sp)
 4003a54:	df000415 	stw	fp,16(sp)
 4003a58:	dc400315 	stw	r17,12(sp)
 4003a5c:	dc000215 	stw	r16,8(sp)
 4003a60:	df000404 	addi	fp,sp,16
 4003a64:	e13ffc15 	stw	r4,-16(fp)
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
 4003a68:	4005f740 	call	4005f74 <vTaskEnterCritical>
    {
        uxCurrentNumberOfTasks++;
 4003a6c:	d0a71717 	ldw	r2,-25508(gp)
 4003a70:	10800044 	addi	r2,r2,1
 4003a74:	d0a71715 	stw	r2,-25508(gp)

        if( pxCurrentTCB == NULL )
 4003a78:	d0a71317 	ldw	r2,-25524(gp)
 4003a7c:	1000071e 	bne	r2,zero,4003a9c <prvAddNewTaskToReadyList+0x50>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
 4003a80:	e0bffc17 	ldw	r2,-16(fp)
 4003a84:	d0a71315 	stw	r2,-25524(gp)

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 4003a88:	d0a71717 	ldw	r2,-25508(gp)
 4003a8c:	10800058 	cmpnei	r2,r2,1
 4003a90:	10000b1e 	bne	r2,zero,4003ac0 <prvAddNewTaskToReadyList+0x74>
            {
                /* This is the first task to be created so do the preliminary
                 * initialisation required.  We will not recover if this call
                 * fails, but we will report the failure. */
                prvInitialiseTaskLists();
 4003a94:	40056f80 	call	40056f8 <prvInitialiseTaskLists>
 4003a98:	00000906 	br	4003ac0 <prvAddNewTaskToReadyList+0x74>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
 4003a9c:	d0a71a17 	ldw	r2,-25496(gp)
 4003aa0:	1000071e 	bne	r2,zero,4003ac0 <prvAddNewTaskToReadyList+0x74>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 4003aa4:	d0a71317 	ldw	r2,-25524(gp)
 4003aa8:	10800b17 	ldw	r2,44(r2)
 4003aac:	e0fffc17 	ldw	r3,-16(fp)
 4003ab0:	18c00b17 	ldw	r3,44(r3)
 4003ab4:	18800236 	bltu	r3,r2,4003ac0 <prvAddNewTaskToReadyList+0x74>
                {
                    pxCurrentTCB = pxNewTCB;
 4003ab8:	e0bffc17 	ldw	r2,-16(fp)
 4003abc:	d0a71315 	stw	r2,-25524(gp)
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
 4003ac0:	d0a71e17 	ldw	r2,-25480(gp)
 4003ac4:	10800044 	addi	r2,r2,1
 4003ac8:	d0a71e15 	stw	r2,-25480(gp)
            pxNewTCB->uxTCBNumber = uxTaskNumber;
        }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
 4003acc:	e0bffc17 	ldw	r2,-16(fp)
 4003ad0:	10800b17 	ldw	r2,44(r2)
 4003ad4:	d0e71917 	ldw	r3,-25500(gp)
 4003ad8:	1880032e 	bgeu	r3,r2,4003ae8 <prvAddNewTaskToReadyList+0x9c>
 4003adc:	e0bffc17 	ldw	r2,-16(fp)
 4003ae0:	10800b17 	ldw	r2,44(r2)
 4003ae4:	d0a71915 	stw	r2,-25500(gp)
 4003ae8:	e0bffc17 	ldw	r2,-16(fp)
 4003aec:	10800b17 	ldw	r2,44(r2)
 4003af0:	01400504 	movi	r5,20
 4003af4:	1009883a 	mov	r4,r2
 4003af8:	40072d80 	call	40072d8 <__mulsi3>
 4003afc:	1007883a 	mov	r3,r2
 4003b00:	008120b4 	movhi	r2,1154
 4003b04:	1885883a 	add	r2,r3,r2
 4003b08:	10bab017 	ldw	r2,-5440(r2)
 4003b0c:	e0bffd15 	stw	r2,-12(fp)
 4003b10:	e0bffc17 	ldw	r2,-16(fp)
 4003b14:	e0fffd17 	ldw	r3,-12(fp)
 4003b18:	10c00215 	stw	r3,8(r2)
 4003b1c:	e0bffd17 	ldw	r2,-12(fp)
 4003b20:	10c00217 	ldw	r3,8(r2)
 4003b24:	e0bffc17 	ldw	r2,-16(fp)
 4003b28:	10c00315 	stw	r3,12(r2)
 4003b2c:	e0bffd17 	ldw	r2,-12(fp)
 4003b30:	10800217 	ldw	r2,8(r2)
 4003b34:	e0fffc17 	ldw	r3,-16(fp)
 4003b38:	18c00104 	addi	r3,r3,4
 4003b3c:	10c00115 	stw	r3,4(r2)
 4003b40:	e0bffc17 	ldw	r2,-16(fp)
 4003b44:	10c00104 	addi	r3,r2,4
 4003b48:	e0bffd17 	ldw	r2,-12(fp)
 4003b4c:	10c00215 	stw	r3,8(r2)
 4003b50:	e0bffc17 	ldw	r2,-16(fp)
 4003b54:	10800b17 	ldw	r2,44(r2)
 4003b58:	01400504 	movi	r5,20
 4003b5c:	1009883a 	mov	r4,r2
 4003b60:	40072d80 	call	40072d8 <__mulsi3>
 4003b64:	1007883a 	mov	r3,r2
 4003b68:	008120b4 	movhi	r2,1154
 4003b6c:	10baaf04 	addi	r2,r2,-5444
 4003b70:	1887883a 	add	r3,r3,r2
 4003b74:	e0bffc17 	ldw	r2,-16(fp)
 4003b78:	10c00515 	stw	r3,20(r2)
 4003b7c:	e0bffc17 	ldw	r2,-16(fp)
 4003b80:	14400b17 	ldw	r17,44(r2)
 4003b84:	01400504 	movi	r5,20
 4003b88:	8809883a 	mov	r4,r17
 4003b8c:	40072d80 	call	40072d8 <__mulsi3>
 4003b90:	1007883a 	mov	r3,r2
 4003b94:	008120b4 	movhi	r2,1154
 4003b98:	1885883a 	add	r2,r3,r2
 4003b9c:	10baaf17 	ldw	r2,-5444(r2)
 4003ba0:	14000044 	addi	r16,r2,1
 4003ba4:	01400504 	movi	r5,20
 4003ba8:	8809883a 	mov	r4,r17
 4003bac:	40072d80 	call	40072d8 <__mulsi3>
 4003bb0:	1007883a 	mov	r3,r2
 4003bb4:	008120b4 	movhi	r2,1154
 4003bb8:	1885883a 	add	r2,r3,r2
 4003bbc:	143aaf15 	stw	r16,-5444(r2)

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
 4003bc0:	4005fc80 	call	4005fc8 <vTaskExitCritical>

    if( xSchedulerRunning != pdFALSE )
 4003bc4:	d0a71a17 	ldw	r2,-25496(gp)
 4003bc8:	10000626 	beq	r2,zero,4003be4 <prvAddNewTaskToReadyList+0x198>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 4003bcc:	d0a71317 	ldw	r2,-25524(gp)
 4003bd0:	10c00b17 	ldw	r3,44(r2)
 4003bd4:	e0bffc17 	ldw	r2,-16(fp)
 4003bd8:	10800b17 	ldw	r2,44(r2)
 4003bdc:	1880012e 	bgeu	r3,r2,4003be4 <prvAddNewTaskToReadyList+0x198>
        {
            taskYIELD_IF_USING_PREEMPTION();
 4003be0:	003b683a 	trap	0
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
 4003be4:	0001883a 	nop
 4003be8:	e6fffe04 	addi	sp,fp,-8
 4003bec:	dfc00317 	ldw	ra,12(sp)
 4003bf0:	df000217 	ldw	fp,8(sp)
 4003bf4:	dc400117 	ldw	r17,4(sp)
 4003bf8:	dc000017 	ldw	r16,0(sp)
 4003bfc:	dec00404 	addi	sp,sp,16
 4003c00:	f800283a 	ret

04003c04 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
 4003c04:	defffc04 	addi	sp,sp,-16
 4003c08:	dfc00315 	stw	ra,12(sp)
 4003c0c:	df000215 	stw	fp,8(sp)
 4003c10:	df000204 	addi	fp,sp,8
 4003c14:	e13ffe15 	stw	r4,-8(fp)
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
 4003c18:	4005f740 	call	4005f74 <vTaskEnterCritical>
        {
            /* If null is passed in here then it is the calling task that is
             * being deleted. */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 4003c1c:	e0bffe17 	ldw	r2,-8(fp)
 4003c20:	1000021e 	bne	r2,zero,4003c2c <vTaskDelete+0x28>
 4003c24:	d0a71317 	ldw	r2,-25524(gp)
 4003c28:	00000106 	br	4003c30 <vTaskDelete+0x2c>
 4003c2c:	e0bffe17 	ldw	r2,-8(fp)
 4003c30:	e0bfff15 	stw	r2,-4(fp)

            /* Remove task from the ready/delayed list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4003c34:	e0bfff17 	ldw	r2,-4(fp)
 4003c38:	10800104 	addi	r2,r2,4
 4003c3c:	1009883a 	mov	r4,r2
 4003c40:	4000c980 	call	4000c98 <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 4003c44:	e0bfff17 	ldw	r2,-4(fp)
 4003c48:	10800a17 	ldw	r2,40(r2)
 4003c4c:	10000426 	beq	r2,zero,4003c60 <vTaskDelete+0x5c>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 4003c50:	e0bfff17 	ldw	r2,-4(fp)
 4003c54:	10800604 	addi	r2,r2,24
 4003c58:	1009883a 	mov	r4,r2
 4003c5c:	4000c980 	call	4000c98 <uxListRemove>

            /* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. */
            uxTaskNumber++;
 4003c60:	d0a71e17 	ldw	r2,-25480(gp)
 4003c64:	10800044 	addi	r2,r2,1
 4003c68:	d0a71e15 	stw	r2,-25480(gp)

            if( pxTCB == pxCurrentTCB )
 4003c6c:	d0a71317 	ldw	r2,-25524(gp)
 4003c70:	e0ffff17 	ldw	r3,-4(fp)
 4003c74:	18800a1e 	bne	r3,r2,4003ca0 <vTaskDelete+0x9c>
                /* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
 4003c78:	e0bfff17 	ldw	r2,-4(fp)
 4003c7c:	10800104 	addi	r2,r2,4
 4003c80:	100b883a 	mov	r5,r2
 4003c84:	010120b4 	movhi	r4,1154
 4003c88:	213ad704 	addi	r4,r4,-5284
 4003c8c:	4000b340 	call	4000b34 <vListInsertEnd>

                /* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. */
                ++uxDeletedTasksWaitingCleanUp;
 4003c90:	d0a71617 	ldw	r2,-25512(gp)
 4003c94:	10800044 	addi	r2,r2,1
 4003c98:	d0a71615 	stw	r2,-25512(gp)
 4003c9c:	00000406 	br	4003cb0 <vTaskDelete+0xac>
                 * required. */
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
            }
            else
            {
                --uxCurrentNumberOfTasks;
 4003ca0:	d0a71717 	ldw	r2,-25508(gp)
 4003ca4:	10bfffc4 	addi	r2,r2,-1
 4003ca8:	d0a71715 	stw	r2,-25508(gp)
                traceTASK_DELETE( pxTCB );

                /* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. */
                prvResetNextTaskUnblockTime();
 4003cac:	40059400 	call	4005940 <prvResetNextTaskUnblockTime>
            }
        }
        taskEXIT_CRITICAL();
 4003cb0:	4005fc80 	call	4005fc8 <vTaskExitCritical>

        /* If the task is not deleting itself, call prvDeleteTCB from outside of
         * critical section. If a task deletes itself, prvDeleteTCB is called
         * from prvCheckTasksWaitingTermination which is called from Idle task. */
        if( pxTCB != pxCurrentTCB )
 4003cb4:	d0a71317 	ldw	r2,-25524(gp)
 4003cb8:	e0ffff17 	ldw	r3,-4(fp)
 4003cbc:	18800226 	beq	r3,r2,4003cc8 <vTaskDelete+0xc4>
        {
            prvDeleteTCB( pxTCB );
 4003cc0:	e13fff17 	ldw	r4,-4(fp)
 4003cc4:	40058fc0 	call	40058fc <prvDeleteTCB>
        }

        /* Force a reschedule if it is the currently running task that has just
         * been deleted. */
        if( xSchedulerRunning != pdFALSE )
 4003cc8:	d0a71a17 	ldw	r2,-25496(gp)
 4003ccc:	10000426 	beq	r2,zero,4003ce0 <vTaskDelete+0xdc>
        {
            if( pxTCB == pxCurrentTCB )
 4003cd0:	d0a71317 	ldw	r2,-25524(gp)
 4003cd4:	e0ffff17 	ldw	r3,-4(fp)
 4003cd8:	1880011e 	bne	r3,r2,4003ce0 <vTaskDelete+0xdc>
            {
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
 4003cdc:	003b683a 	trap	0
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
 4003ce0:	0001883a 	nop
 4003ce4:	e037883a 	mov	sp,fp
 4003ce8:	dfc00117 	ldw	ra,4(sp)
 4003cec:	df000017 	ldw	fp,0(sp)
 4003cf0:	dec00204 	addi	sp,sp,8
 4003cf4:	f800283a 	ret

04003cf8 <xTaskDelayUntil>:

#if ( INCLUDE_xTaskDelayUntil == 1 )

    BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                                const TickType_t xTimeIncrement )
    {
 4003cf8:	defff804 	addi	sp,sp,-32
 4003cfc:	dfc00715 	stw	ra,28(sp)
 4003d00:	df000615 	stw	fp,24(sp)
 4003d04:	df000604 	addi	fp,sp,24
 4003d08:	e13ffb15 	stw	r4,-20(fp)
 4003d0c:	e17ffa15 	stw	r5,-24(fp)
        TickType_t xTimeToWake;
        BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
 4003d10:	e03fff15 	stw	zero,-4(fp)

        configASSERT( pxPreviousWakeTime );
        configASSERT( ( xTimeIncrement > 0U ) );
        configASSERT( uxSchedulerSuspended == 0 );

        vTaskSuspendAll();
 4003d14:	40046e80 	call	40046e8 <vTaskSuspendAll>
        {
            /* Minor optimisation.  The tick count cannot change in this
             * block. */
            const TickType_t xConstTickCount = xTickCount;
 4003d18:	d0a71817 	ldw	r2,-25504(gp)
 4003d1c:	e0bffe15 	stw	r2,-8(fp)

            /* Generate the tick time at which the task wants to wake. */
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 4003d20:	e0bffb17 	ldw	r2,-20(fp)
 4003d24:	10800017 	ldw	r2,0(r2)
 4003d28:	e0fffa17 	ldw	r3,-24(fp)
 4003d2c:	1885883a 	add	r2,r3,r2
 4003d30:	e0bffd15 	stw	r2,-12(fp)

            if( xConstTickCount < *pxPreviousWakeTime )
 4003d34:	e0bffb17 	ldw	r2,-20(fp)
 4003d38:	10800017 	ldw	r2,0(r2)
 4003d3c:	e0fffe17 	ldw	r3,-8(fp)
 4003d40:	18800a2e 	bgeu	r3,r2,4003d6c <xTaskDelayUntil+0x74>
                /* The tick count has overflowed since this function was
                 * lasted called.  In this case the only time we should ever
                 * actually delay is if the wake time has also  overflowed,
                 * and the wake time is greater than the tick time.  When this
                 * is the case it is as if neither time had overflowed. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 4003d44:	e0bffb17 	ldw	r2,-20(fp)
 4003d48:	10800017 	ldw	r2,0(r2)
 4003d4c:	e0fffd17 	ldw	r3,-12(fp)
 4003d50:	18800f2e 	bgeu	r3,r2,4003d90 <xTaskDelayUntil+0x98>
 4003d54:	e0bffd17 	ldw	r2,-12(fp)
 4003d58:	e0fffe17 	ldw	r3,-8(fp)
 4003d5c:	18800c2e 	bgeu	r3,r2,4003d90 <xTaskDelayUntil+0x98>
                {
                    xShouldDelay = pdTRUE;
 4003d60:	00800044 	movi	r2,1
 4003d64:	e0bfff15 	stw	r2,-4(fp)
 4003d68:	00000906 	br	4003d90 <xTaskDelayUntil+0x98>
            else
            {
                /* The tick time has not overflowed.  In this case we will
                 * delay if either the wake time has overflowed, and/or the
                 * tick time is less than the wake time. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 4003d6c:	e0bffb17 	ldw	r2,-20(fp)
 4003d70:	10800017 	ldw	r2,0(r2)
 4003d74:	e0fffd17 	ldw	r3,-12(fp)
 4003d78:	18800336 	bltu	r3,r2,4003d88 <xTaskDelayUntil+0x90>
 4003d7c:	e0bffd17 	ldw	r2,-12(fp)
 4003d80:	e0fffe17 	ldw	r3,-8(fp)
 4003d84:	1880022e 	bgeu	r3,r2,4003d90 <xTaskDelayUntil+0x98>
                {
                    xShouldDelay = pdTRUE;
 4003d88:	00800044 	movi	r2,1
 4003d8c:	e0bfff15 	stw	r2,-4(fp)
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            /* Update the wake time ready for the next call. */
            *pxPreviousWakeTime = xTimeToWake;
 4003d90:	e0bffb17 	ldw	r2,-20(fp)
 4003d94:	e0fffd17 	ldw	r3,-12(fp)
 4003d98:	10c00015 	stw	r3,0(r2)

            if( xShouldDelay != pdFALSE )
 4003d9c:	e0bfff17 	ldw	r2,-4(fp)
 4003da0:	10000626 	beq	r2,zero,4003dbc <xTaskDelayUntil+0xc4>
            {
                traceTASK_DELAY_UNTIL( xTimeToWake );

                /* prvAddCurrentTaskToDelayedList() needs the block time, not
                 * the time to wake, so subtract the current tick count. */
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
 4003da4:	e0fffd17 	ldw	r3,-12(fp)
 4003da8:	e0bffe17 	ldw	r2,-8(fp)
 4003dac:	1885c83a 	sub	r2,r3,r2
 4003db0:	000b883a 	mov	r5,zero
 4003db4:	1009883a 	mov	r4,r2
 4003db8:	4006e340 	call	4006e34 <prvAddCurrentTaskToDelayedList>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        xAlreadyYielded = xTaskResumeAll();
 4003dbc:	40047140 	call	4004714 <xTaskResumeAll>
 4003dc0:	e0bffc15 	stw	r2,-16(fp)

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
 4003dc4:	e0bffc17 	ldw	r2,-16(fp)
 4003dc8:	1000011e 	bne	r2,zero,4003dd0 <xTaskDelayUntil+0xd8>
        {
            portYIELD_WITHIN_API();
 4003dcc:	003b683a 	trap	0
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xShouldDelay;
 4003dd0:	e0bfff17 	ldw	r2,-4(fp)
    }
 4003dd4:	e037883a 	mov	sp,fp
 4003dd8:	dfc00117 	ldw	ra,4(sp)
 4003ddc:	df000017 	ldw	fp,0(sp)
 4003de0:	dec00204 	addi	sp,sp,8
 4003de4:	f800283a 	ret

04003de8 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
 4003de8:	defffc04 	addi	sp,sp,-16
 4003dec:	dfc00315 	stw	ra,12(sp)
 4003df0:	df000215 	stw	fp,8(sp)
 4003df4:	df000204 	addi	fp,sp,8
 4003df8:	e13ffe15 	stw	r4,-8(fp)
        BaseType_t xAlreadyYielded = pdFALSE;
 4003dfc:	e03fff15 	stw	zero,-4(fp)

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
 4003e00:	e0bffe17 	ldw	r2,-8(fp)
 4003e04:	10000626 	beq	r2,zero,4003e20 <vTaskDelay+0x38>
        {
            configASSERT( uxSchedulerSuspended == 0 );
            vTaskSuspendAll();
 4003e08:	40046e80 	call	40046e8 <vTaskSuspendAll>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 4003e0c:	000b883a 	mov	r5,zero
 4003e10:	e13ffe17 	ldw	r4,-8(fp)
 4003e14:	4006e340 	call	4006e34 <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
 4003e18:	40047140 	call	4004714 <xTaskResumeAll>
 4003e1c:	e0bfff15 	stw	r2,-4(fp)
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
 4003e20:	e0bfff17 	ldw	r2,-4(fp)
 4003e24:	1000011e 	bne	r2,zero,4003e2c <vTaskDelay+0x44>
        {
            portYIELD_WITHIN_API();
 4003e28:	003b683a 	trap	0
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
 4003e2c:	0001883a 	nop
 4003e30:	e037883a 	mov	sp,fp
 4003e34:	dfc00117 	ldw	ra,4(sp)
 4003e38:	df000017 	ldw	fp,0(sp)
 4003e3c:	dec00204 	addi	sp,sp,8
 4003e40:	f800283a 	ret

04003e44 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

    UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
    {
 4003e44:	defffb04 	addi	sp,sp,-20
 4003e48:	dfc00415 	stw	ra,16(sp)
 4003e4c:	df000315 	stw	fp,12(sp)
 4003e50:	df000304 	addi	fp,sp,12
 4003e54:	e13ffd15 	stw	r4,-12(fp)
        TCB_t const * pxTCB;
        UBaseType_t uxReturn;

        taskENTER_CRITICAL();
 4003e58:	4005f740 	call	4005f74 <vTaskEnterCritical>
        {
            /* If null is passed in here then it is the priority of the task
             * that called uxTaskPriorityGet() that is being queried. */
            pxTCB = prvGetTCBFromHandle( xTask );
 4003e5c:	e0bffd17 	ldw	r2,-12(fp)
 4003e60:	1000021e 	bne	r2,zero,4003e6c <uxTaskPriorityGet+0x28>
 4003e64:	d0a71317 	ldw	r2,-25524(gp)
 4003e68:	00000106 	br	4003e70 <uxTaskPriorityGet+0x2c>
 4003e6c:	e0bffd17 	ldw	r2,-12(fp)
 4003e70:	e0bfff15 	stw	r2,-4(fp)
            uxReturn = pxTCB->uxPriority;
 4003e74:	e0bfff17 	ldw	r2,-4(fp)
 4003e78:	10800b17 	ldw	r2,44(r2)
 4003e7c:	e0bffe15 	stw	r2,-8(fp)
        }
        taskEXIT_CRITICAL();
 4003e80:	4005fc80 	call	4005fc8 <vTaskExitCritical>

        return uxReturn;
 4003e84:	e0bffe17 	ldw	r2,-8(fp)
    }
 4003e88:	e037883a 	mov	sp,fp
 4003e8c:	dfc00117 	ldw	ra,4(sp)
 4003e90:	df000017 	ldw	fp,0(sp)
 4003e94:	dec00204 	addi	sp,sp,8
 4003e98:	f800283a 	ret

04003e9c <uxTaskPriorityGetFromISR>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

    UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
    {
 4003e9c:	defffb04 	addi	sp,sp,-20
 4003ea0:	df000415 	stw	fp,16(sp)
 4003ea4:	df000404 	addi	fp,sp,16
 4003ea8:	e13ffc15 	stw	r4,-16(fp)
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
 4003eac:	e03fff15 	stw	zero,-4(fp)
        {
            /* If null is passed in here then it is the priority of the calling
             * task that is being queried. */
            pxTCB = prvGetTCBFromHandle( xTask );
 4003eb0:	e0bffc17 	ldw	r2,-16(fp)
 4003eb4:	1000021e 	bne	r2,zero,4003ec0 <uxTaskPriorityGetFromISR+0x24>
 4003eb8:	d0a71317 	ldw	r2,-25524(gp)
 4003ebc:	00000106 	br	4003ec4 <uxTaskPriorityGetFromISR+0x28>
 4003ec0:	e0bffc17 	ldw	r2,-16(fp)
 4003ec4:	e0bffe15 	stw	r2,-8(fp)
            uxReturn = pxTCB->uxPriority;
 4003ec8:	e0bffe17 	ldw	r2,-8(fp)
 4003ecc:	10800b17 	ldw	r2,44(r2)
 4003ed0:	e0bffd15 	stw	r2,-12(fp)
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

        return uxReturn;
 4003ed4:	e0bffd17 	ldw	r2,-12(fp)
    }
 4003ed8:	e037883a 	mov	sp,fp
 4003edc:	df000017 	ldw	fp,0(sp)
 4003ee0:	dec00104 	addi	sp,sp,4
 4003ee4:	f800283a 	ret

04003ee8 <vTaskPrioritySet>:

#if ( INCLUDE_vTaskPrioritySet == 1 )

    void vTaskPrioritySet( TaskHandle_t xTask,
                           UBaseType_t uxNewPriority )
    {
 4003ee8:	defff504 	addi	sp,sp,-44
 4003eec:	dfc00a15 	stw	ra,40(sp)
 4003ef0:	df000915 	stw	fp,36(sp)
 4003ef4:	dc400815 	stw	r17,32(sp)
 4003ef8:	dc000715 	stw	r16,28(sp)
 4003efc:	df000904 	addi	fp,sp,36
 4003f00:	e13ff815 	stw	r4,-32(fp)
 4003f04:	e17ff715 	stw	r5,-36(fp)
        TCB_t * pxTCB;
        UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
        BaseType_t xYieldRequired = pdFALSE;
 4003f08:	e03ffd15 	stw	zero,-12(fp)

        configASSERT( uxNewPriority < configMAX_PRIORITIES );

        /* Ensure the new priority is valid. */
        if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 4003f0c:	e0bff717 	ldw	r2,-36(fp)
 4003f10:	10800170 	cmpltui	r2,r2,5
 4003f14:	1000021e 	bne	r2,zero,4003f20 <vTaskPrioritySet+0x38>
        {
            uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 4003f18:	00800104 	movi	r2,4
 4003f1c:	e0bff715 	stw	r2,-36(fp)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        taskENTER_CRITICAL();
 4003f20:	4005f740 	call	4005f74 <vTaskEnterCritical>
        {
            /* If null is passed in here then it is the priority of the calling
             * task that is being changed. */
            pxTCB = prvGetTCBFromHandle( xTask );
 4003f24:	e0bff817 	ldw	r2,-32(fp)
 4003f28:	1000021e 	bne	r2,zero,4003f34 <vTaskPrioritySet+0x4c>
 4003f2c:	d0a71317 	ldw	r2,-25524(gp)
 4003f30:	00000106 	br	4003f38 <vTaskPrioritySet+0x50>
 4003f34:	e0bff817 	ldw	r2,-32(fp)
 4003f38:	e0bffc15 	stw	r2,-16(fp)

            traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

            #if ( configUSE_MUTEXES == 1 )
            {
                uxCurrentBasePriority = pxTCB->uxBasePriority;
 4003f3c:	e0bffc17 	ldw	r2,-16(fp)
 4003f40:	10801017 	ldw	r2,64(r2)
 4003f44:	e0bffb15 	stw	r2,-20(fp)
            {
                uxCurrentBasePriority = pxTCB->uxPriority;
            }
            #endif

            if( uxCurrentBasePriority != uxNewPriority )
 4003f48:	e0fffb17 	ldw	r3,-20(fp)
 4003f4c:	e0bff717 	ldw	r2,-36(fp)
 4003f50:	18807626 	beq	r3,r2,400412c <vTaskPrioritySet+0x244>
            {
                /* The priority change may have readied a task of higher
                 * priority than the calling task. */
                if( uxNewPriority > uxCurrentBasePriority )
 4003f54:	e0bff717 	ldw	r2,-36(fp)
 4003f58:	e0fffb17 	ldw	r3,-20(fp)
 4003f5c:	18800a2e 	bgeu	r3,r2,4003f88 <vTaskPrioritySet+0xa0>
                {
                    if( pxTCB != pxCurrentTCB )
 4003f60:	d0a71317 	ldw	r2,-25524(gp)
 4003f64:	e0fffc17 	ldw	r3,-16(fp)
 4003f68:	18800c26 	beq	r3,r2,4003f9c <vTaskPrioritySet+0xb4>
                    {
                        /* The priority of a task other than the currently
                         * running task is being raised.  Is the priority being
                         * raised above that of the running task? */
                        if( uxNewPriority >= pxCurrentTCB->uxPriority )
 4003f6c:	d0a71317 	ldw	r2,-25524(gp)
 4003f70:	10800b17 	ldw	r2,44(r2)
 4003f74:	e0fff717 	ldw	r3,-36(fp)
 4003f78:	18800836 	bltu	r3,r2,4003f9c <vTaskPrioritySet+0xb4>
                        {
                            xYieldRequired = pdTRUE;
 4003f7c:	00800044 	movi	r2,1
 4003f80:	e0bffd15 	stw	r2,-12(fp)
 4003f84:	00000506 	br	4003f9c <vTaskPrioritySet+0xb4>
                        /* The priority of the running task is being raised,
                         * but the running task must already be the highest
                         * priority task able to run so no yield is required. */
                    }
                }
                else if( pxTCB == pxCurrentTCB )
 4003f88:	d0a71317 	ldw	r2,-25524(gp)
 4003f8c:	e0fffc17 	ldw	r3,-16(fp)
 4003f90:	1880021e 	bne	r3,r2,4003f9c <vTaskPrioritySet+0xb4>
                {
                    /* Setting the priority of the running task down means
                     * there may now be another task of higher priority that
                     * is ready to execute. */
                    xYieldRequired = pdTRUE;
 4003f94:	00800044 	movi	r2,1
 4003f98:	e0bffd15 	stw	r2,-12(fp)
                }

                /* Remember the ready list the task might be referenced from
                 * before its uxPriority member is changed so the
                 * taskRESET_READY_PRIORITY() macro can function correctly. */
                uxPriorityUsedOnEntry = pxTCB->uxPriority;
 4003f9c:	e0bffc17 	ldw	r2,-16(fp)
 4003fa0:	10800b17 	ldw	r2,44(r2)
 4003fa4:	e0bffa15 	stw	r2,-24(fp)

                #if ( configUSE_MUTEXES == 1 )
                {
                    /* Only change the priority being used if the task is not
                     * currently using an inherited priority. */
                    if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 4003fa8:	e0bffc17 	ldw	r2,-16(fp)
 4003fac:	10c01017 	ldw	r3,64(r2)
 4003fb0:	e0bffc17 	ldw	r2,-16(fp)
 4003fb4:	10800b17 	ldw	r2,44(r2)
 4003fb8:	1880031e 	bne	r3,r2,4003fc8 <vTaskPrioritySet+0xe0>
                    {
                        pxTCB->uxPriority = uxNewPriority;
 4003fbc:	e0bffc17 	ldw	r2,-16(fp)
 4003fc0:	e0fff717 	ldw	r3,-36(fp)
 4003fc4:	10c00b15 	stw	r3,44(r2)
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* The base priority gets set whatever. */
                    pxTCB->uxBasePriority = uxNewPriority;
 4003fc8:	e0bffc17 	ldw	r2,-16(fp)
 4003fcc:	e0fff717 	ldw	r3,-36(fp)
 4003fd0:	10c01015 	stw	r3,64(r2)
                }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                /* Only reset the event list item value if the value is not
                 * being used for anything else. */
                if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 4003fd4:	e0bffc17 	ldw	r2,-16(fp)
 4003fd8:	10800617 	ldw	r2,24(r2)
 4003fdc:	10000516 	blt	r2,zero,4003ff4 <vTaskPrioritySet+0x10c>
                {
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 4003fe0:	00c00144 	movi	r3,5
 4003fe4:	e0bff717 	ldw	r2,-36(fp)
 4003fe8:	1887c83a 	sub	r3,r3,r2
 4003fec:	e0bffc17 	ldw	r2,-16(fp)
 4003ff0:	10c00615 	stw	r3,24(r2)

                /* If the task is in the blocked or suspended list we need do
                 * nothing more than change its priority variable. However, if
                 * the task is in a ready list it needs to be removed and placed
                 * in the list appropriate to its new priority. */
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 4003ff4:	e0bffc17 	ldw	r2,-16(fp)
 4003ff8:	14000517 	ldw	r16,20(r2)
 4003ffc:	01400504 	movi	r5,20
 4004000:	e13ffa17 	ldw	r4,-24(fp)
 4004004:	40072d80 	call	40072d8 <__mulsi3>
 4004008:	1007883a 	mov	r3,r2
 400400c:	008120b4 	movhi	r2,1154
 4004010:	10baaf04 	addi	r2,r2,-5444
 4004014:	1885883a 	add	r2,r3,r2
 4004018:	8080411e 	bne	r16,r2,4004120 <vTaskPrioritySet+0x238>
                {
                    /* The task is currently in its ready list - remove before
                     * adding it to its new ready list.  As we are in a critical
                     * section we can do this even if the scheduler is suspended. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 400401c:	e0bffc17 	ldw	r2,-16(fp)
 4004020:	10800104 	addi	r2,r2,4
 4004024:	1009883a 	mov	r4,r2
 4004028:	4000c980 	call	4000c98 <uxListRemove>
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    prvAddTaskToReadyList( pxTCB );
 400402c:	e0bffc17 	ldw	r2,-16(fp)
 4004030:	10800b17 	ldw	r2,44(r2)
 4004034:	d0e71917 	ldw	r3,-25500(gp)
 4004038:	1880032e 	bgeu	r3,r2,4004048 <vTaskPrioritySet+0x160>
 400403c:	e0bffc17 	ldw	r2,-16(fp)
 4004040:	10800b17 	ldw	r2,44(r2)
 4004044:	d0a71915 	stw	r2,-25500(gp)
 4004048:	e0bffc17 	ldw	r2,-16(fp)
 400404c:	10800b17 	ldw	r2,44(r2)
 4004050:	01400504 	movi	r5,20
 4004054:	1009883a 	mov	r4,r2
 4004058:	40072d80 	call	40072d8 <__mulsi3>
 400405c:	1007883a 	mov	r3,r2
 4004060:	008120b4 	movhi	r2,1154
 4004064:	1885883a 	add	r2,r3,r2
 4004068:	10bab017 	ldw	r2,-5440(r2)
 400406c:	e0bff915 	stw	r2,-28(fp)
 4004070:	e0bffc17 	ldw	r2,-16(fp)
 4004074:	e0fff917 	ldw	r3,-28(fp)
 4004078:	10c00215 	stw	r3,8(r2)
 400407c:	e0bff917 	ldw	r2,-28(fp)
 4004080:	10c00217 	ldw	r3,8(r2)
 4004084:	e0bffc17 	ldw	r2,-16(fp)
 4004088:	10c00315 	stw	r3,12(r2)
 400408c:	e0bff917 	ldw	r2,-28(fp)
 4004090:	10800217 	ldw	r2,8(r2)
 4004094:	e0fffc17 	ldw	r3,-16(fp)
 4004098:	18c00104 	addi	r3,r3,4
 400409c:	10c00115 	stw	r3,4(r2)
 40040a0:	e0bffc17 	ldw	r2,-16(fp)
 40040a4:	10c00104 	addi	r3,r2,4
 40040a8:	e0bff917 	ldw	r2,-28(fp)
 40040ac:	10c00215 	stw	r3,8(r2)
 40040b0:	e0bffc17 	ldw	r2,-16(fp)
 40040b4:	10800b17 	ldw	r2,44(r2)
 40040b8:	01400504 	movi	r5,20
 40040bc:	1009883a 	mov	r4,r2
 40040c0:	40072d80 	call	40072d8 <__mulsi3>
 40040c4:	1007883a 	mov	r3,r2
 40040c8:	008120b4 	movhi	r2,1154
 40040cc:	10baaf04 	addi	r2,r2,-5444
 40040d0:	1887883a 	add	r3,r3,r2
 40040d4:	e0bffc17 	ldw	r2,-16(fp)
 40040d8:	10c00515 	stw	r3,20(r2)
 40040dc:	e0bffc17 	ldw	r2,-16(fp)
 40040e0:	14400b17 	ldw	r17,44(r2)
 40040e4:	01400504 	movi	r5,20
 40040e8:	8809883a 	mov	r4,r17
 40040ec:	40072d80 	call	40072d8 <__mulsi3>
 40040f0:	1007883a 	mov	r3,r2
 40040f4:	008120b4 	movhi	r2,1154
 40040f8:	1885883a 	add	r2,r3,r2
 40040fc:	10baaf17 	ldw	r2,-5444(r2)
 4004100:	14000044 	addi	r16,r2,1
 4004104:	01400504 	movi	r5,20
 4004108:	8809883a 	mov	r4,r17
 400410c:	40072d80 	call	40072d8 <__mulsi3>
 4004110:	1007883a 	mov	r3,r2
 4004114:	008120b4 	movhi	r2,1154
 4004118:	1885883a 	add	r2,r3,r2
 400411c:	143aaf15 	stw	r16,-5444(r2)
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                if( xYieldRequired != pdFALSE )
 4004120:	e0bffd17 	ldw	r2,-12(fp)
 4004124:	10000126 	beq	r2,zero,400412c <vTaskPrioritySet+0x244>
                {
                    taskYIELD_IF_USING_PREEMPTION();
 4004128:	003b683a 	trap	0
                /* Remove compiler warning about unused variables when the port
                 * optimised task selection is not being used. */
                ( void ) uxPriorityUsedOnEntry;
            }
        }
        taskEXIT_CRITICAL();
 400412c:	4005fc80 	call	4005fc8 <vTaskExitCritical>
    }
 4004130:	0001883a 	nop
 4004134:	e6fffe04 	addi	sp,fp,-8
 4004138:	dfc00317 	ldw	ra,12(sp)
 400413c:	df000217 	ldw	fp,8(sp)
 4004140:	dc400117 	ldw	r17,4(sp)
 4004144:	dc000017 	ldw	r16,0(sp)
 4004148:	dec00404 	addi	sp,sp,16
 400414c:	f800283a 	ret

04004150 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    void vTaskSuspend( TaskHandle_t xTaskToSuspend )
    {
 4004150:	defffb04 	addi	sp,sp,-20
 4004154:	dfc00415 	stw	ra,16(sp)
 4004158:	df000315 	stw	fp,12(sp)
 400415c:	df000304 	addi	fp,sp,12
 4004160:	e13ffd15 	stw	r4,-12(fp)
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
 4004164:	4005f740 	call	4005f74 <vTaskEnterCritical>
        {
            /* If null is passed in here then it is the running task that is
             * being suspended. */
            pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 4004168:	e0bffd17 	ldw	r2,-12(fp)
 400416c:	1000021e 	bne	r2,zero,4004178 <vTaskSuspend+0x28>
 4004170:	d0a71317 	ldw	r2,-25524(gp)
 4004174:	00000106 	br	400417c <vTaskSuspend+0x2c>
 4004178:	e0bffd17 	ldw	r2,-12(fp)
 400417c:	e0bffe15 	stw	r2,-8(fp)

            traceTASK_SUSPEND( pxTCB );

            /* Remove task from the ready/delayed list and place in the
             * suspended list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4004180:	e0bffe17 	ldw	r2,-8(fp)
 4004184:	10800104 	addi	r2,r2,4
 4004188:	1009883a 	mov	r4,r2
 400418c:	4000c980 	call	4000c98 <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 4004190:	e0bffe17 	ldw	r2,-8(fp)
 4004194:	10800a17 	ldw	r2,40(r2)
 4004198:	10000426 	beq	r2,zero,40041ac <vTaskSuspend+0x5c>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 400419c:	e0bffe17 	ldw	r2,-8(fp)
 40041a0:	10800604 	addi	r2,r2,24
 40041a4:	1009883a 	mov	r4,r2
 40041a8:	4000c980 	call	4000c98 <uxListRemove>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 40041ac:	e0bffe17 	ldw	r2,-8(fp)
 40041b0:	10800104 	addi	r2,r2,4
 40041b4:	100b883a 	mov	r5,r2
 40041b8:	010120b4 	movhi	r4,1154
 40041bc:	213adc04 	addi	r4,r4,-5264
 40041c0:	4000b340 	call	4000b34 <vListInsertEnd>

            #if ( configUSE_TASK_NOTIFICATIONS == 1 )
            {
                BaseType_t x;

                for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
 40041c4:	e03fff15 	stw	zero,-4(fp)
 40041c8:	00000e06 	br	4004204 <vTaskSuspend+0xb4>
                {
                    if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
 40041cc:	e0fffe17 	ldw	r3,-8(fp)
 40041d0:	e0bfff17 	ldw	r2,-4(fp)
 40041d4:	1885883a 	add	r2,r3,r2
 40041d8:	10801303 	ldbu	r2,76(r2)
 40041dc:	10803fcc 	andi	r2,r2,255
 40041e0:	10800058 	cmpnei	r2,r2,1
 40041e4:	1000041e 	bne	r2,zero,40041f8 <vTaskSuspend+0xa8>
                    {
                        /* The task was blocked to wait for a notification, but is
                         * now suspended, so no notification was received. */
                        pxTCB->ucNotifyState[ x ] = taskNOT_WAITING_NOTIFICATION;
 40041e8:	e0fffe17 	ldw	r3,-8(fp)
 40041ec:	e0bfff17 	ldw	r2,-4(fp)
 40041f0:	1885883a 	add	r2,r3,r2
 40041f4:	10001305 	stb	zero,76(r2)
                for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
 40041f8:	e0bfff17 	ldw	r2,-4(fp)
 40041fc:	10800044 	addi	r2,r2,1
 4004200:	e0bfff15 	stw	r2,-4(fp)
 4004204:	e0bfff17 	ldw	r2,-4(fp)
 4004208:	00bff00e 	bge	zero,r2,40041cc <vTaskSuspend+0x7c>
                    }
                }
            }
            #endif /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
        }
        taskEXIT_CRITICAL();
 400420c:	4005fc80 	call	4005fc8 <vTaskExitCritical>

        if( xSchedulerRunning != pdFALSE )
 4004210:	d0a71a17 	ldw	r2,-25496(gp)
 4004214:	10000326 	beq	r2,zero,4004224 <vTaskSuspend+0xd4>
        {
            /* Reset the next expected unblock time in case it referred to the
             * task that is now in the Suspended state. */
            taskENTER_CRITICAL();
 4004218:	4005f740 	call	4005f74 <vTaskEnterCritical>
            {
                prvResetNextTaskUnblockTime();
 400421c:	40059400 	call	4005940 <prvResetNextTaskUnblockTime>
            }
            taskEXIT_CRITICAL();
 4004220:	4005fc80 	call	4005fc8 <vTaskExitCritical>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( pxTCB == pxCurrentTCB )
 4004224:	d0a71317 	ldw	r2,-25524(gp)
 4004228:	e0fffe17 	ldw	r3,-8(fp)
 400422c:	18800b1e 	bne	r3,r2,400425c <vTaskSuspend+0x10c>
        {
            if( xSchedulerRunning != pdFALSE )
 4004230:	d0a71a17 	ldw	r2,-25496(gp)
 4004234:	10000226 	beq	r2,zero,4004240 <vTaskSuspend+0xf0>
            {
                /* The current task has just been suspended. */
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
 4004238:	003b683a 	trap	0
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
 400423c:	00000706 	br	400425c <vTaskSuspend+0x10c>
                if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
 4004240:	008120b4 	movhi	r2,1154
 4004244:	10fadc17 	ldw	r3,-5264(r2)
 4004248:	d0a71717 	ldw	r2,-25508(gp)
 400424c:	1880021e 	bne	r3,r2,4004258 <vTaskSuspend+0x108>
                    pxCurrentTCB = NULL;
 4004250:	d0271315 	stw	zero,-25524(gp)
    }
 4004254:	00000106 	br	400425c <vTaskSuspend+0x10c>
                    vTaskSwitchContext();
 4004258:	4004e280 	call	4004e28 <vTaskSwitchContext>
    }
 400425c:	0001883a 	nop
 4004260:	e037883a 	mov	sp,fp
 4004264:	dfc00117 	ldw	ra,4(sp)
 4004268:	df000017 	ldw	fp,0(sp)
 400426c:	dec00204 	addi	sp,sp,8
 4004270:	f800283a 	ret

04004274 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
    {
 4004274:	defffc04 	addi	sp,sp,-16
 4004278:	df000315 	stw	fp,12(sp)
 400427c:	df000304 	addi	fp,sp,12
 4004280:	e13ffd15 	stw	r4,-12(fp)
        BaseType_t xReturn = pdFALSE;
 4004284:	e03fff15 	stw	zero,-4(fp)
        const TCB_t * const pxTCB = xTask;
 4004288:	e0bffd17 	ldw	r2,-12(fp)
 400428c:	e0bffe15 	stw	r2,-8(fp)

        /* It does not make sense to check if the calling task is suspended. */
        configASSERT( xTask );

        /* Is the task being resumed actually in the suspended list? */
        if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
 4004290:	e0bffe17 	ldw	r2,-8(fp)
 4004294:	10c00517 	ldw	r3,20(r2)
 4004298:	008120b4 	movhi	r2,1154
 400429c:	10badc04 	addi	r2,r2,-5264
 40042a0:	18800a1e 	bne	r3,r2,40042cc <prvTaskIsTaskSuspended+0x58>
        {
            /* Has the task already been resumed from within an ISR? */
            if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 40042a4:	e0bffe17 	ldw	r2,-8(fp)
 40042a8:	10c00a17 	ldw	r3,40(r2)
 40042ac:	008120b4 	movhi	r2,1154
 40042b0:	10bad204 	addi	r2,r2,-5304
 40042b4:	18800526 	beq	r3,r2,40042cc <prvTaskIsTaskSuspended+0x58>
            {
                /* Is it in the suspended list because it is in the Suspended
                 * state, or because is is blocked with no timeout? */
                if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
 40042b8:	e0bffe17 	ldw	r2,-8(fp)
 40042bc:	10800a17 	ldw	r2,40(r2)
 40042c0:	1000021e 	bne	r2,zero,40042cc <prvTaskIsTaskSuspended+0x58>
                {
                    xReturn = pdTRUE;
 40042c4:	00800044 	movi	r2,1
 40042c8:	e0bfff15 	stw	r2,-4(fp)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
 40042cc:	e0bfff17 	ldw	r2,-4(fp)
    } /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 40042d0:	e037883a 	mov	sp,fp
 40042d4:	df000017 	ldw	fp,0(sp)
 40042d8:	dec00104 	addi	sp,sp,4
 40042dc:	f800283a 	ret

040042e0 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    void vTaskResume( TaskHandle_t xTaskToResume )
    {
 40042e0:	defff904 	addi	sp,sp,-28
 40042e4:	dfc00615 	stw	ra,24(sp)
 40042e8:	df000515 	stw	fp,20(sp)
 40042ec:	dc400415 	stw	r17,16(sp)
 40042f0:	dc000315 	stw	r16,12(sp)
 40042f4:	df000504 	addi	fp,sp,20
 40042f8:	e13ffb15 	stw	r4,-20(fp)
        TCB_t * const pxTCB = xTaskToResume;
 40042fc:	e0bffb17 	ldw	r2,-20(fp)
 4004300:	e0bffd15 	stw	r2,-12(fp)
        /* It does not make sense to resume the calling task. */
        configASSERT( xTaskToResume );

        /* The parameter cannot be NULL as it is impossible to resume the
         * currently executing task. */
        if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
 4004304:	d0a71317 	ldw	r2,-25524(gp)
 4004308:	e0fffd17 	ldw	r3,-12(fp)
 400430c:	18804e26 	beq	r3,r2,4004448 <vTaskResume+0x168>
 4004310:	e0bffd17 	ldw	r2,-12(fp)
 4004314:	10004c26 	beq	r2,zero,4004448 <vTaskResume+0x168>
        {
            taskENTER_CRITICAL();
 4004318:	4005f740 	call	4005f74 <vTaskEnterCritical>
            {
                if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 400431c:	e13ffd17 	ldw	r4,-12(fp)
 4004320:	40042740 	call	4004274 <prvTaskIsTaskSuspended>
 4004324:	10004726 	beq	r2,zero,4004444 <vTaskResume+0x164>
                {
                    traceTASK_RESUME( pxTCB );

                    /* The ready list can be accessed even if the scheduler is
                     * suspended because this is inside a critical section. */
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 4004328:	e0bffd17 	ldw	r2,-12(fp)
 400432c:	10800104 	addi	r2,r2,4
 4004330:	1009883a 	mov	r4,r2
 4004334:	4000c980 	call	4000c98 <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
 4004338:	e0bffd17 	ldw	r2,-12(fp)
 400433c:	10800b17 	ldw	r2,44(r2)
 4004340:	d0e71917 	ldw	r3,-25500(gp)
 4004344:	1880032e 	bgeu	r3,r2,4004354 <vTaskResume+0x74>
 4004348:	e0bffd17 	ldw	r2,-12(fp)
 400434c:	10800b17 	ldw	r2,44(r2)
 4004350:	d0a71915 	stw	r2,-25500(gp)
 4004354:	e0bffd17 	ldw	r2,-12(fp)
 4004358:	10800b17 	ldw	r2,44(r2)
 400435c:	01400504 	movi	r5,20
 4004360:	1009883a 	mov	r4,r2
 4004364:	40072d80 	call	40072d8 <__mulsi3>
 4004368:	1007883a 	mov	r3,r2
 400436c:	008120b4 	movhi	r2,1154
 4004370:	1885883a 	add	r2,r3,r2
 4004374:	10bab017 	ldw	r2,-5440(r2)
 4004378:	e0bffc15 	stw	r2,-16(fp)
 400437c:	e0bffd17 	ldw	r2,-12(fp)
 4004380:	e0fffc17 	ldw	r3,-16(fp)
 4004384:	10c00215 	stw	r3,8(r2)
 4004388:	e0bffc17 	ldw	r2,-16(fp)
 400438c:	10c00217 	ldw	r3,8(r2)
 4004390:	e0bffd17 	ldw	r2,-12(fp)
 4004394:	10c00315 	stw	r3,12(r2)
 4004398:	e0bffc17 	ldw	r2,-16(fp)
 400439c:	10800217 	ldw	r2,8(r2)
 40043a0:	e0fffd17 	ldw	r3,-12(fp)
 40043a4:	18c00104 	addi	r3,r3,4
 40043a8:	10c00115 	stw	r3,4(r2)
 40043ac:	e0bffd17 	ldw	r2,-12(fp)
 40043b0:	10c00104 	addi	r3,r2,4
 40043b4:	e0bffc17 	ldw	r2,-16(fp)
 40043b8:	10c00215 	stw	r3,8(r2)
 40043bc:	e0bffd17 	ldw	r2,-12(fp)
 40043c0:	10800b17 	ldw	r2,44(r2)
 40043c4:	01400504 	movi	r5,20
 40043c8:	1009883a 	mov	r4,r2
 40043cc:	40072d80 	call	40072d8 <__mulsi3>
 40043d0:	1007883a 	mov	r3,r2
 40043d4:	008120b4 	movhi	r2,1154
 40043d8:	10baaf04 	addi	r2,r2,-5444
 40043dc:	1887883a 	add	r3,r3,r2
 40043e0:	e0bffd17 	ldw	r2,-12(fp)
 40043e4:	10c00515 	stw	r3,20(r2)
 40043e8:	e0bffd17 	ldw	r2,-12(fp)
 40043ec:	14400b17 	ldw	r17,44(r2)
 40043f0:	01400504 	movi	r5,20
 40043f4:	8809883a 	mov	r4,r17
 40043f8:	40072d80 	call	40072d8 <__mulsi3>
 40043fc:	1007883a 	mov	r3,r2
 4004400:	008120b4 	movhi	r2,1154
 4004404:	1885883a 	add	r2,r3,r2
 4004408:	10baaf17 	ldw	r2,-5444(r2)
 400440c:	14000044 	addi	r16,r2,1
 4004410:	01400504 	movi	r5,20
 4004414:	8809883a 	mov	r4,r17
 4004418:	40072d80 	call	40072d8 <__mulsi3>
 400441c:	1007883a 	mov	r3,r2
 4004420:	008120b4 	movhi	r2,1154
 4004424:	1885883a 	add	r2,r3,r2
 4004428:	143aaf15 	stw	r16,-5444(r2)

                    /* A higher priority task may have just been resumed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 400442c:	e0bffd17 	ldw	r2,-12(fp)
 4004430:	10c00b17 	ldw	r3,44(r2)
 4004434:	d0a71317 	ldw	r2,-25524(gp)
 4004438:	10800b17 	ldw	r2,44(r2)
 400443c:	18800136 	bltu	r3,r2,4004444 <vTaskResume+0x164>
                    {
                        /* This yield may not cause the task just resumed to run,
                         * but will leave the lists in the correct state for the
                         * next yield. */
                        taskYIELD_IF_USING_PREEMPTION();
 4004440:	003b683a 	trap	0
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
 4004444:	4005fc80 	call	4005fc8 <vTaskExitCritical>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
 4004448:	0001883a 	nop
 400444c:	e6fffe04 	addi	sp,fp,-8
 4004450:	dfc00317 	ldw	ra,12(sp)
 4004454:	df000217 	ldw	fp,8(sp)
 4004458:	dc400117 	ldw	r17,4(sp)
 400445c:	dc000017 	ldw	r16,0(sp)
 4004460:	dec00404 	addi	sp,sp,16
 4004464:	f800283a 	ret

04004468 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

    BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
    {
 4004468:	defff704 	addi	sp,sp,-36
 400446c:	dfc00815 	stw	ra,32(sp)
 4004470:	df000715 	stw	fp,28(sp)
 4004474:	dc400615 	stw	r17,24(sp)
 4004478:	dc000515 	stw	r16,20(sp)
 400447c:	df000704 	addi	fp,sp,28
 4004480:	e13ff915 	stw	r4,-28(fp)
        BaseType_t xYieldRequired = pdFALSE;
 4004484:	e03ffd15 	stw	zero,-12(fp)
        TCB_t * const pxTCB = xTaskToResume;
 4004488:	e0bff917 	ldw	r2,-28(fp)
 400448c:	e0bffc15 	stw	r2,-16(fp)
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4004490:	e03ffb15 	stw	zero,-20(fp)
        {
            if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 4004494:	e13ffc17 	ldw	r4,-16(fp)
 4004498:	40042740 	call	4004274 <prvTaskIsTaskSuspended>
 400449c:	10005326 	beq	r2,zero,40045ec <xTaskResumeFromISR+0x184>
            {
                traceTASK_RESUME_FROM_ISR( pxTCB );

                /* Check the ready lists can be accessed. */
                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 40044a0:	d0a72117 	ldw	r2,-25468(gp)
 40044a4:	10004b1e 	bne	r2,zero,40045d4 <xTaskResumeFromISR+0x16c>
                {
                    /* Ready lists can be accessed so move the task from the
                     * suspended list to the ready list directly. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 40044a8:	e0bffc17 	ldw	r2,-16(fp)
 40044ac:	10c00b17 	ldw	r3,44(r2)
 40044b0:	d0a71317 	ldw	r2,-25524(gp)
 40044b4:	10800b17 	ldw	r2,44(r2)
 40044b8:	18800436 	bltu	r3,r2,40044cc <xTaskResumeFromISR+0x64>
                    {
                        xYieldRequired = pdTRUE;
 40044bc:	00800044 	movi	r2,1
 40044c0:	e0bffd15 	stw	r2,-12(fp)

                        /* Mark that a yield is pending in case the user is not
                         * using the return value to initiate a context switch
                         * from the ISR using portYIELD_FROM_ISR. */
                        xYieldPending = pdTRUE;
 40044c4:	00800044 	movi	r2,1
 40044c8:	d0a71c15 	stw	r2,-25488(gp)
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 40044cc:	e0bffc17 	ldw	r2,-16(fp)
 40044d0:	10800104 	addi	r2,r2,4
 40044d4:	1009883a 	mov	r4,r2
 40044d8:	4000c980 	call	4000c98 <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
 40044dc:	e0bffc17 	ldw	r2,-16(fp)
 40044e0:	10800b17 	ldw	r2,44(r2)
 40044e4:	d0e71917 	ldw	r3,-25500(gp)
 40044e8:	1880032e 	bgeu	r3,r2,40044f8 <xTaskResumeFromISR+0x90>
 40044ec:	e0bffc17 	ldw	r2,-16(fp)
 40044f0:	10800b17 	ldw	r2,44(r2)
 40044f4:	d0a71915 	stw	r2,-25500(gp)
 40044f8:	e0bffc17 	ldw	r2,-16(fp)
 40044fc:	10800b17 	ldw	r2,44(r2)
 4004500:	01400504 	movi	r5,20
 4004504:	1009883a 	mov	r4,r2
 4004508:	40072d80 	call	40072d8 <__mulsi3>
 400450c:	1007883a 	mov	r3,r2
 4004510:	008120b4 	movhi	r2,1154
 4004514:	1885883a 	add	r2,r3,r2
 4004518:	10bab017 	ldw	r2,-5440(r2)
 400451c:	e0bffa15 	stw	r2,-24(fp)
 4004520:	e0bffc17 	ldw	r2,-16(fp)
 4004524:	e0fffa17 	ldw	r3,-24(fp)
 4004528:	10c00215 	stw	r3,8(r2)
 400452c:	e0bffa17 	ldw	r2,-24(fp)
 4004530:	10c00217 	ldw	r3,8(r2)
 4004534:	e0bffc17 	ldw	r2,-16(fp)
 4004538:	10c00315 	stw	r3,12(r2)
 400453c:	e0bffa17 	ldw	r2,-24(fp)
 4004540:	10800217 	ldw	r2,8(r2)
 4004544:	e0fffc17 	ldw	r3,-16(fp)
 4004548:	18c00104 	addi	r3,r3,4
 400454c:	10c00115 	stw	r3,4(r2)
 4004550:	e0bffc17 	ldw	r2,-16(fp)
 4004554:	10c00104 	addi	r3,r2,4
 4004558:	e0bffa17 	ldw	r2,-24(fp)
 400455c:	10c00215 	stw	r3,8(r2)
 4004560:	e0bffc17 	ldw	r2,-16(fp)
 4004564:	10800b17 	ldw	r2,44(r2)
 4004568:	01400504 	movi	r5,20
 400456c:	1009883a 	mov	r4,r2
 4004570:	40072d80 	call	40072d8 <__mulsi3>
 4004574:	1007883a 	mov	r3,r2
 4004578:	008120b4 	movhi	r2,1154
 400457c:	10baaf04 	addi	r2,r2,-5444
 4004580:	1887883a 	add	r3,r3,r2
 4004584:	e0bffc17 	ldw	r2,-16(fp)
 4004588:	10c00515 	stw	r3,20(r2)
 400458c:	e0bffc17 	ldw	r2,-16(fp)
 4004590:	14400b17 	ldw	r17,44(r2)
 4004594:	01400504 	movi	r5,20
 4004598:	8809883a 	mov	r4,r17
 400459c:	40072d80 	call	40072d8 <__mulsi3>
 40045a0:	1007883a 	mov	r3,r2
 40045a4:	008120b4 	movhi	r2,1154
 40045a8:	1885883a 	add	r2,r3,r2
 40045ac:	10baaf17 	ldw	r2,-5444(r2)
 40045b0:	14000044 	addi	r16,r2,1
 40045b4:	01400504 	movi	r5,20
 40045b8:	8809883a 	mov	r4,r17
 40045bc:	40072d80 	call	40072d8 <__mulsi3>
 40045c0:	1007883a 	mov	r3,r2
 40045c4:	008120b4 	movhi	r2,1154
 40045c8:	1885883a 	add	r2,r3,r2
 40045cc:	143aaf15 	stw	r16,-5444(r2)
 40045d0:	00000606 	br	40045ec <xTaskResumeFromISR+0x184>
                else
                {
                    /* The delayed or ready lists cannot be accessed so the task
                     * is held in the pending ready list until the scheduler is
                     * unsuspended. */
                    vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 40045d4:	e0bffc17 	ldw	r2,-16(fp)
 40045d8:	10800604 	addi	r2,r2,24
 40045dc:	100b883a 	mov	r5,r2
 40045e0:	010120b4 	movhi	r4,1154
 40045e4:	213ad204 	addi	r4,r4,-5304
 40045e8:	4000b340 	call	4000b34 <vListInsertEnd>
                mtCOVERAGE_TEST_MARKER();
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xYieldRequired;
 40045ec:	e0bffd17 	ldw	r2,-12(fp)
    }
 40045f0:	e6fffe04 	addi	sp,fp,-8
 40045f4:	dfc00317 	ldw	ra,12(sp)
 40045f8:	df000217 	ldw	fp,8(sp)
 40045fc:	dc400117 	ldw	r17,4(sp)
 4004600:	dc000017 	ldw	r16,0(sp)
 4004604:	dec00404 	addi	sp,sp,16
 4004608:	f800283a 	ret

0400460c <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 400460c:	defffa04 	addi	sp,sp,-24
 4004610:	dfc00515 	stw	ra,20(sp)
 4004614:	df000415 	stw	fp,16(sp)
 4004618:	df000404 	addi	fp,sp,16
        }
    }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
    {
        /* The Idle task is being created using dynamically allocated RAM. */
        xReturn = xTaskCreate( prvIdleTask,
 400461c:	d0a72004 	addi	r2,gp,-25472
 4004620:	d8800115 	stw	r2,4(sp)
 4004624:	d8000015 	stw	zero,0(sp)
 4004628:	000f883a 	mov	r7,zero
 400462c:	01810004 	movi	r6,1024
 4004630:	014100b4 	movhi	r5,1026
 4004634:	296aac04 	addi	r5,r5,-21840
 4004638:	01010034 	movhi	r4,1024
 400463c:	2115b704 	addi	r4,r4,22236
 4004640:	40037ac0 	call	40037ac <xTaskCreate>
 4004644:	e0bfff15 	stw	r2,-4(fp)
            mtCOVERAGE_TEST_MARKER();
        }
    }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
 4004648:	e0bfff17 	ldw	r2,-4(fp)
 400464c:	10800058 	cmpnei	r2,r2,1
 4004650:	10000c1e 	bne	r2,zero,4004684 <vTaskStartScheduler+0x78>
  NIOS2_READ_STATUS (context);
 4004654:	0005303a 	rdctl	r2,status
 4004658:	e0bffe15 	stw	r2,-8(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 400465c:	e0fffe17 	ldw	r3,-8(fp)
 4004660:	00bfff84 	movi	r2,-2
 4004664:	1884703a 	and	r2,r3,r2
 4004668:	1001703a 	wrctl	status,r2
             * block specific to the task that will run first. */
            configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );
        }
        #endif

        xNextTaskUnblockTime = portMAX_DELAY;
 400466c:	00bfffc4 	movi	r2,-1
 4004670:	d0a71f15 	stw	r2,-25476(gp)
        xSchedulerRunning = pdTRUE;
 4004674:	00800044 	movi	r2,1
 4004678:	d0a71a15 	stw	r2,-25496(gp)
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 400467c:	d0271815 	stw	zero,-25504(gp)

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        xPortStartScheduler();
 4004680:	4000e3c0 	call	4000e3c <xPortStartScheduler>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
 4004684:	d0a00017 	ldw	r2,-32768(gp)
}
 4004688:	0001883a 	nop
 400468c:	e037883a 	mov	sp,fp
 4004690:	dfc00117 	ldw	ra,4(sp)
 4004694:	df000017 	ldw	fp,0(sp)
 4004698:	dec00204 	addi	sp,sp,8
 400469c:	f800283a 	ret

040046a0 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
 40046a0:	defffd04 	addi	sp,sp,-12
 40046a4:	dfc00215 	stw	ra,8(sp)
 40046a8:	df000115 	stw	fp,4(sp)
 40046ac:	df000104 	addi	fp,sp,4
  NIOS2_READ_STATUS (context);
 40046b0:	0005303a 	rdctl	r2,status
 40046b4:	e0bfff15 	stw	r2,-4(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 40046b8:	e0ffff17 	ldw	r3,-4(fp)
 40046bc:	00bfff84 	movi	r2,-2
 40046c0:	1884703a 	and	r2,r3,r2
 40046c4:	1001703a 	wrctl	status,r2
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    xSchedulerRunning = pdFALSE;
 40046c8:	d0271a15 	stw	zero,-25496(gp)
    vPortEndScheduler();
 40046cc:	4000e740 	call	4000e74 <vPortEndScheduler>
}
 40046d0:	0001883a 	nop
 40046d4:	e037883a 	mov	sp,fp
 40046d8:	dfc00117 	ldw	ra,4(sp)
 40046dc:	df000017 	ldw	fp,0(sp)
 40046e0:	dec00204 	addi	sp,sp,8
 40046e4:	f800283a 	ret

040046e8 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
 40046e8:	deffff04 	addi	sp,sp,-4
 40046ec:	df000015 	stw	fp,0(sp)
 40046f0:	d839883a 	mov	fp,sp
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
 40046f4:	d0a72117 	ldw	r2,-25468(gp)
 40046f8:	10800044 	addi	r2,r2,1
 40046fc:	d0a72115 	stw	r2,-25468(gp)

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
 4004700:	0001883a 	nop
 4004704:	e037883a 	mov	sp,fp
 4004708:	df000017 	ldw	fp,0(sp)
 400470c:	dec00104 	addi	sp,sp,4
 4004710:	f800283a 	ret

04004714 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 4004714:	defff604 	addi	sp,sp,-40
 4004718:	dfc00915 	stw	ra,36(sp)
 400471c:	df000815 	stw	fp,32(sp)
 4004720:	dc400715 	stw	r17,28(sp)
 4004724:	dc000615 	stw	r16,24(sp)
 4004728:	df000804 	addi	fp,sp,32
    TCB_t * pxTCB = NULL;
 400472c:	e03ffd15 	stw	zero,-12(fp)
    BaseType_t xAlreadyYielded = pdFALSE;
 4004730:	e03ffc15 	stw	zero,-16(fp)
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
 4004734:	4005f740 	call	4005f74 <vTaskEnterCritical>
    {
        --uxSchedulerSuspended;
 4004738:	d0a72117 	ldw	r2,-25468(gp)
 400473c:	10bfffc4 	addi	r2,r2,-1
 4004740:	d0a72115 	stw	r2,-25468(gp)

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 4004744:	d0a72117 	ldw	r2,-25468(gp)
 4004748:	10009e1e 	bne	r2,zero,40049c4 <xTaskResumeAll+0x2b0>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 400474c:	d0a71717 	ldw	r2,-25508(gp)
 4004750:	10009c26 	beq	r2,zero,40049c4 <xTaskResumeAll+0x2b0>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 4004754:	00008206 	br	4004960 <xTaskResumeAll+0x24c>
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 4004758:	008120b4 	movhi	r2,1154
 400475c:	10bad517 	ldw	r2,-5292(r2)
 4004760:	10800317 	ldw	r2,12(r2)
 4004764:	e0bffd15 	stw	r2,-12(fp)
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
 4004768:	e0bffd17 	ldw	r2,-12(fp)
 400476c:	10800a17 	ldw	r2,40(r2)
 4004770:	e0bffa15 	stw	r2,-24(fp)
 4004774:	e0bffd17 	ldw	r2,-12(fp)
 4004778:	10800717 	ldw	r2,28(r2)
 400477c:	e0fffd17 	ldw	r3,-12(fp)
 4004780:	18c00817 	ldw	r3,32(r3)
 4004784:	10c00215 	stw	r3,8(r2)
 4004788:	e0bffd17 	ldw	r2,-12(fp)
 400478c:	10800817 	ldw	r2,32(r2)
 4004790:	e0fffd17 	ldw	r3,-12(fp)
 4004794:	18c00717 	ldw	r3,28(r3)
 4004798:	10c00115 	stw	r3,4(r2)
 400479c:	e0bffa17 	ldw	r2,-24(fp)
 40047a0:	10c00117 	ldw	r3,4(r2)
 40047a4:	e0bffd17 	ldw	r2,-12(fp)
 40047a8:	10800604 	addi	r2,r2,24
 40047ac:	1880041e 	bne	r3,r2,40047c0 <xTaskResumeAll+0xac>
 40047b0:	e0bffd17 	ldw	r2,-12(fp)
 40047b4:	10c00817 	ldw	r3,32(r2)
 40047b8:	e0bffa17 	ldw	r2,-24(fp)
 40047bc:	10c00115 	stw	r3,4(r2)
 40047c0:	e0bffd17 	ldw	r2,-12(fp)
 40047c4:	10000a15 	stw	zero,40(r2)
 40047c8:	e0bffa17 	ldw	r2,-24(fp)
 40047cc:	10800017 	ldw	r2,0(r2)
 40047d0:	10ffffc4 	addi	r3,r2,-1
 40047d4:	e0bffa17 	ldw	r2,-24(fp)
 40047d8:	10c00015 	stw	r3,0(r2)
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 40047dc:	e0bffd17 	ldw	r2,-12(fp)
 40047e0:	10800517 	ldw	r2,20(r2)
 40047e4:	e0bff915 	stw	r2,-28(fp)
 40047e8:	e0bffd17 	ldw	r2,-12(fp)
 40047ec:	10800217 	ldw	r2,8(r2)
 40047f0:	e0fffd17 	ldw	r3,-12(fp)
 40047f4:	18c00317 	ldw	r3,12(r3)
 40047f8:	10c00215 	stw	r3,8(r2)
 40047fc:	e0bffd17 	ldw	r2,-12(fp)
 4004800:	10800317 	ldw	r2,12(r2)
 4004804:	e0fffd17 	ldw	r3,-12(fp)
 4004808:	18c00217 	ldw	r3,8(r3)
 400480c:	10c00115 	stw	r3,4(r2)
 4004810:	e0bff917 	ldw	r2,-28(fp)
 4004814:	10c00117 	ldw	r3,4(r2)
 4004818:	e0bffd17 	ldw	r2,-12(fp)
 400481c:	10800104 	addi	r2,r2,4
 4004820:	1880041e 	bne	r3,r2,4004834 <xTaskResumeAll+0x120>
 4004824:	e0bffd17 	ldw	r2,-12(fp)
 4004828:	10c00317 	ldw	r3,12(r2)
 400482c:	e0bff917 	ldw	r2,-28(fp)
 4004830:	10c00115 	stw	r3,4(r2)
 4004834:	e0bffd17 	ldw	r2,-12(fp)
 4004838:	10000515 	stw	zero,20(r2)
 400483c:	e0bff917 	ldw	r2,-28(fp)
 4004840:	10800017 	ldw	r2,0(r2)
 4004844:	10ffffc4 	addi	r3,r2,-1
 4004848:	e0bff917 	ldw	r2,-28(fp)
 400484c:	10c00015 	stw	r3,0(r2)
                    prvAddTaskToReadyList( pxTCB );
 4004850:	e0bffd17 	ldw	r2,-12(fp)
 4004854:	10800b17 	ldw	r2,44(r2)
 4004858:	d0e71917 	ldw	r3,-25500(gp)
 400485c:	1880032e 	bgeu	r3,r2,400486c <xTaskResumeAll+0x158>
 4004860:	e0bffd17 	ldw	r2,-12(fp)
 4004864:	10800b17 	ldw	r2,44(r2)
 4004868:	d0a71915 	stw	r2,-25500(gp)
 400486c:	e0bffd17 	ldw	r2,-12(fp)
 4004870:	10800b17 	ldw	r2,44(r2)
 4004874:	01400504 	movi	r5,20
 4004878:	1009883a 	mov	r4,r2
 400487c:	40072d80 	call	40072d8 <__mulsi3>
 4004880:	1007883a 	mov	r3,r2
 4004884:	008120b4 	movhi	r2,1154
 4004888:	1885883a 	add	r2,r3,r2
 400488c:	10bab017 	ldw	r2,-5440(r2)
 4004890:	e0bff815 	stw	r2,-32(fp)
 4004894:	e0bffd17 	ldw	r2,-12(fp)
 4004898:	e0fff817 	ldw	r3,-32(fp)
 400489c:	10c00215 	stw	r3,8(r2)
 40048a0:	e0bff817 	ldw	r2,-32(fp)
 40048a4:	10c00217 	ldw	r3,8(r2)
 40048a8:	e0bffd17 	ldw	r2,-12(fp)
 40048ac:	10c00315 	stw	r3,12(r2)
 40048b0:	e0bff817 	ldw	r2,-32(fp)
 40048b4:	10800217 	ldw	r2,8(r2)
 40048b8:	e0fffd17 	ldw	r3,-12(fp)
 40048bc:	18c00104 	addi	r3,r3,4
 40048c0:	10c00115 	stw	r3,4(r2)
 40048c4:	e0bffd17 	ldw	r2,-12(fp)
 40048c8:	10c00104 	addi	r3,r2,4
 40048cc:	e0bff817 	ldw	r2,-32(fp)
 40048d0:	10c00215 	stw	r3,8(r2)
 40048d4:	e0bffd17 	ldw	r2,-12(fp)
 40048d8:	10800b17 	ldw	r2,44(r2)
 40048dc:	01400504 	movi	r5,20
 40048e0:	1009883a 	mov	r4,r2
 40048e4:	40072d80 	call	40072d8 <__mulsi3>
 40048e8:	1007883a 	mov	r3,r2
 40048ec:	008120b4 	movhi	r2,1154
 40048f0:	10baaf04 	addi	r2,r2,-5444
 40048f4:	1887883a 	add	r3,r3,r2
 40048f8:	e0bffd17 	ldw	r2,-12(fp)
 40048fc:	10c00515 	stw	r3,20(r2)
 4004900:	e0bffd17 	ldw	r2,-12(fp)
 4004904:	14400b17 	ldw	r17,44(r2)
 4004908:	01400504 	movi	r5,20
 400490c:	8809883a 	mov	r4,r17
 4004910:	40072d80 	call	40072d8 <__mulsi3>
 4004914:	1007883a 	mov	r3,r2
 4004918:	008120b4 	movhi	r2,1154
 400491c:	1885883a 	add	r2,r3,r2
 4004920:	10baaf17 	ldw	r2,-5444(r2)
 4004924:	14000044 	addi	r16,r2,1
 4004928:	01400504 	movi	r5,20
 400492c:	8809883a 	mov	r4,r17
 4004930:	40072d80 	call	40072d8 <__mulsi3>
 4004934:	1007883a 	mov	r3,r2
 4004938:	008120b4 	movhi	r2,1154
 400493c:	1885883a 	add	r2,r3,r2
 4004940:	143aaf15 	stw	r16,-5444(r2)

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 4004944:	e0bffd17 	ldw	r2,-12(fp)
 4004948:	10c00b17 	ldw	r3,44(r2)
 400494c:	d0a71317 	ldw	r2,-25524(gp)
 4004950:	10800b17 	ldw	r2,44(r2)
 4004954:	18800236 	bltu	r3,r2,4004960 <xTaskResumeAll+0x24c>
                    {
                        xYieldPending = pdTRUE;
 4004958:	00800044 	movi	r2,1
 400495c:	d0a71c15 	stw	r2,-25488(gp)
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 4004960:	008120b4 	movhi	r2,1154
 4004964:	10bad217 	ldw	r2,-5304(r2)
 4004968:	103f7b1e 	bne	r2,zero,4004758 <xTaskResumeAll+0x44>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
 400496c:	e0bffd17 	ldw	r2,-12(fp)
 4004970:	10000126 	beq	r2,zero,4004978 <xTaskResumeAll+0x264>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
 4004974:	40059400 	call	4005940 <prvResetNextTaskUnblockTime>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
 4004978:	d0a71b17 	ldw	r2,-25492(gp)
 400497c:	e0bffb15 	stw	r2,-20(fp)

                    if( xPendedCounts > ( TickType_t ) 0U )
 4004980:	e0bffb17 	ldw	r2,-20(fp)
 4004984:	10000a26 	beq	r2,zero,40049b0 <xTaskResumeAll+0x29c>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
 4004988:	4004aec0 	call	4004aec <xTaskIncrementTick>
 400498c:	10000226 	beq	r2,zero,4004998 <xTaskResumeAll+0x284>
                            {
                                xYieldPending = pdTRUE;
 4004990:	00800044 	movi	r2,1
 4004994:	d0a71c15 	stw	r2,-25488(gp)
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
 4004998:	e0bffb17 	ldw	r2,-20(fp)
 400499c:	10bfffc4 	addi	r2,r2,-1
 40049a0:	e0bffb15 	stw	r2,-20(fp)
                        } while( xPendedCounts > ( TickType_t ) 0U );
 40049a4:	e0bffb17 	ldw	r2,-20(fp)
 40049a8:	103ff71e 	bne	r2,zero,4004988 <xTaskResumeAll+0x274>

                        xPendedTicks = 0;
 40049ac:	d0271b15 	stw	zero,-25492(gp)
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
 40049b0:	d0a71c17 	ldw	r2,-25488(gp)
 40049b4:	10000326 	beq	r2,zero,40049c4 <xTaskResumeAll+0x2b0>
                {
                    #if ( configUSE_PREEMPTION != 0 )
                    {
                        xAlreadyYielded = pdTRUE;
 40049b8:	00800044 	movi	r2,1
 40049bc:	e0bffc15 	stw	r2,-16(fp)
                    }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
 40049c0:	003b683a 	trap	0
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
 40049c4:	4005fc80 	call	4005fc8 <vTaskExitCritical>

    return xAlreadyYielded;
 40049c8:	e0bffc17 	ldw	r2,-16(fp)
}
 40049cc:	e6fffe04 	addi	sp,fp,-8
 40049d0:	dfc00317 	ldw	ra,12(sp)
 40049d4:	df000217 	ldw	fp,8(sp)
 40049d8:	dc400117 	ldw	r17,4(sp)
 40049dc:	dc000017 	ldw	r16,0(sp)
 40049e0:	dec00404 	addi	sp,sp,16
 40049e4:	f800283a 	ret

040049e8 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
 40049e8:	defffe04 	addi	sp,sp,-8
 40049ec:	df000115 	stw	fp,4(sp)
 40049f0:	df000104 	addi	fp,sp,4
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    {
        xTicks = xTickCount;
 40049f4:	d0a71817 	ldw	r2,-25504(gp)
 40049f8:	e0bfff15 	stw	r2,-4(fp)
    }
    portTICK_TYPE_EXIT_CRITICAL();

    return xTicks;
 40049fc:	e0bfff17 	ldw	r2,-4(fp)
}
 4004a00:	e037883a 	mov	sp,fp
 4004a04:	df000017 	ldw	fp,0(sp)
 4004a08:	dec00104 	addi	sp,sp,4
 4004a0c:	f800283a 	ret

04004a10 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
 4004a10:	defffd04 	addi	sp,sp,-12
 4004a14:	df000215 	stw	fp,8(sp)
 4004a18:	df000204 	addi	fp,sp,8
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
 4004a1c:	e03fff15 	stw	zero,-4(fp)
    {
        xReturn = xTickCount;
 4004a20:	d0a71817 	ldw	r2,-25504(gp)
 4004a24:	e0bffe15 	stw	r2,-8(fp)
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 4004a28:	e0bffe17 	ldw	r2,-8(fp)
}
 4004a2c:	e037883a 	mov	sp,fp
 4004a30:	df000017 	ldw	fp,0(sp)
 4004a34:	dec00104 	addi	sp,sp,4
 4004a38:	f800283a 	ret

04004a3c <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
 4004a3c:	deffff04 	addi	sp,sp,-4
 4004a40:	df000015 	stw	fp,0(sp)
 4004a44:	d839883a 	mov	fp,sp
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
 4004a48:	d0a71717 	ldw	r2,-25508(gp)
}
 4004a4c:	e037883a 	mov	sp,fp
 4004a50:	df000017 	ldw	fp,0(sp)
 4004a54:	dec00104 	addi	sp,sp,4
 4004a58:	f800283a 	ret

04004a5c <pcTaskGetName>:
/*-----------------------------------------------------------*/

char * pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
 4004a5c:	defffd04 	addi	sp,sp,-12
 4004a60:	df000215 	stw	fp,8(sp)
 4004a64:	df000204 	addi	fp,sp,8
 4004a68:	e13ffe15 	stw	r4,-8(fp)
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 4004a6c:	e0bffe17 	ldw	r2,-8(fp)
 4004a70:	1000021e 	bne	r2,zero,4004a7c <pcTaskGetName+0x20>
 4004a74:	d0a71317 	ldw	r2,-25524(gp)
 4004a78:	00000106 	br	4004a80 <pcTaskGetName+0x24>
 4004a7c:	e0bffe17 	ldw	r2,-8(fp)
 4004a80:	e0bfff15 	stw	r2,-4(fp)
    configASSERT( pxTCB );
    return &( pxTCB->pcTaskName[ 0 ] );
 4004a84:	e0bfff17 	ldw	r2,-4(fp)
 4004a88:	10800d04 	addi	r2,r2,52
}
 4004a8c:	e037883a 	mov	sp,fp
 4004a90:	df000017 	ldw	fp,0(sp)
 4004a94:	dec00104 	addi	sp,sp,4
 4004a98:	f800283a 	ret

04004a9c <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
 4004a9c:	defffc04 	addi	sp,sp,-16
 4004aa0:	dfc00315 	stw	ra,12(sp)
 4004aa4:	df000215 	stw	fp,8(sp)
 4004aa8:	df000204 	addi	fp,sp,8
 4004aac:	e13ffe15 	stw	r4,-8(fp)
     * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
    configASSERT( uxSchedulerSuspended == 0 );

    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();
 4004ab0:	40046e80 	call	40046e8 <vTaskSuspendAll>

    /* Prevent the tick interrupt modifying xPendedTicks simultaneously. */
    taskENTER_CRITICAL();
 4004ab4:	4005f740 	call	4005f74 <vTaskEnterCritical>
    {
        xPendedTicks += xTicksToCatchUp;
 4004ab8:	d0e71b17 	ldw	r3,-25492(gp)
 4004abc:	e0bffe17 	ldw	r2,-8(fp)
 4004ac0:	1885883a 	add	r2,r3,r2
 4004ac4:	d0a71b15 	stw	r2,-25492(gp)
    }
    taskEXIT_CRITICAL();
 4004ac8:	4005fc80 	call	4005fc8 <vTaskExitCritical>
    xYieldOccurred = xTaskResumeAll();
 4004acc:	40047140 	call	4004714 <xTaskResumeAll>
 4004ad0:	e0bfff15 	stw	r2,-4(fp)

    return xYieldOccurred;
 4004ad4:	e0bfff17 	ldw	r2,-4(fp)
}
 4004ad8:	e037883a 	mov	sp,fp
 4004adc:	dfc00117 	ldw	ra,4(sp)
 4004ae0:	df000017 	ldw	fp,0(sp)
 4004ae4:	dec00204 	addi	sp,sp,8
 4004ae8:	f800283a 	ret

04004aec <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 4004aec:	defff404 	addi	sp,sp,-48
 4004af0:	dfc00b15 	stw	ra,44(sp)
 4004af4:	df000a15 	stw	fp,40(sp)
 4004af8:	dc400915 	stw	r17,36(sp)
 4004afc:	dc000815 	stw	r16,32(sp)
 4004b00:	df000a04 	addi	fp,sp,40
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
 4004b04:	e03ffd15 	stw	zero,-12(fp)
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 4004b08:	d0a72117 	ldw	r2,-25468(gp)
 4004b0c:	1000bb1e 	bne	r2,zero,4004dfc <xTaskIncrementTick+0x310>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 4004b10:	d0a71817 	ldw	r2,-25504(gp)
 4004b14:	10800044 	addi	r2,r2,1
 4004b18:	e0bffc15 	stw	r2,-16(fp)

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
 4004b1c:	e0bffc17 	ldw	r2,-16(fp)
 4004b20:	d0a71815 	stw	r2,-25504(gp)

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 4004b24:	e0bffc17 	ldw	r2,-16(fp)
 4004b28:	10000a1e 	bne	r2,zero,4004b54 <xTaskIncrementTick+0x68>
        {
            taskSWITCH_DELAYED_LISTS();
 4004b2c:	d0a71417 	ldw	r2,-25520(gp)
 4004b30:	e0bffb15 	stw	r2,-20(fp)
 4004b34:	d0a71517 	ldw	r2,-25516(gp)
 4004b38:	d0a71415 	stw	r2,-25520(gp)
 4004b3c:	e0bffb17 	ldw	r2,-20(fp)
 4004b40:	d0a71515 	stw	r2,-25516(gp)
 4004b44:	d0a71d17 	ldw	r2,-25484(gp)
 4004b48:	10800044 	addi	r2,r2,1
 4004b4c:	d0a71d15 	stw	r2,-25484(gp)
 4004b50:	40059400 	call	4005940 <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
 4004b54:	d0a71f17 	ldw	r2,-25476(gp)
 4004b58:	e0fffc17 	ldw	r3,-16(fp)
 4004b5c:	18809536 	bltu	r3,r2,4004db4 <xTaskIncrementTick+0x2c8>
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 4004b60:	d0a71417 	ldw	r2,-25520(gp)
 4004b64:	10800017 	ldw	r2,0(r2)
 4004b68:	1000031e 	bne	r2,zero,4004b78 <xTaskIncrementTick+0x8c>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 4004b6c:	00bfffc4 	movi	r2,-1
 4004b70:	d0a71f15 	stw	r2,-25476(gp)
                    break;
 4004b74:	00008f06 	br	4004db4 <xTaskIncrementTick+0x2c8>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 4004b78:	d0a71417 	ldw	r2,-25520(gp)
 4004b7c:	10800317 	ldw	r2,12(r2)
 4004b80:	10800317 	ldw	r2,12(r2)
 4004b84:	e0bffa15 	stw	r2,-24(fp)
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 4004b88:	e0bffa17 	ldw	r2,-24(fp)
 4004b8c:	10800117 	ldw	r2,4(r2)
 4004b90:	e0bff915 	stw	r2,-28(fp)

                    if( xConstTickCount < xItemValue )
 4004b94:	e0fffc17 	ldw	r3,-16(fp)
 4004b98:	e0bff917 	ldw	r2,-28(fp)
 4004b9c:	1880032e 	bgeu	r3,r2,4004bac <xTaskIncrementTick+0xc0>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
 4004ba0:	e0bff917 	ldw	r2,-28(fp)
 4004ba4:	d0a71f15 	stw	r2,-25476(gp)
                        break; /*lint !e9011 Code structure here is deemed easier to understand with multiple breaks. */
 4004ba8:	00008206 	br	4004db4 <xTaskIncrementTick+0x2c8>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 4004bac:	e0bffa17 	ldw	r2,-24(fp)
 4004bb0:	10800517 	ldw	r2,20(r2)
 4004bb4:	e0bff815 	stw	r2,-32(fp)
 4004bb8:	e0bffa17 	ldw	r2,-24(fp)
 4004bbc:	10800217 	ldw	r2,8(r2)
 4004bc0:	e0fffa17 	ldw	r3,-24(fp)
 4004bc4:	18c00317 	ldw	r3,12(r3)
 4004bc8:	10c00215 	stw	r3,8(r2)
 4004bcc:	e0bffa17 	ldw	r2,-24(fp)
 4004bd0:	10800317 	ldw	r2,12(r2)
 4004bd4:	e0fffa17 	ldw	r3,-24(fp)
 4004bd8:	18c00217 	ldw	r3,8(r3)
 4004bdc:	10c00115 	stw	r3,4(r2)
 4004be0:	e0bff817 	ldw	r2,-32(fp)
 4004be4:	10c00117 	ldw	r3,4(r2)
 4004be8:	e0bffa17 	ldw	r2,-24(fp)
 4004bec:	10800104 	addi	r2,r2,4
 4004bf0:	1880041e 	bne	r3,r2,4004c04 <xTaskIncrementTick+0x118>
 4004bf4:	e0bffa17 	ldw	r2,-24(fp)
 4004bf8:	10c00317 	ldw	r3,12(r2)
 4004bfc:	e0bff817 	ldw	r2,-32(fp)
 4004c00:	10c00115 	stw	r3,4(r2)
 4004c04:	e0bffa17 	ldw	r2,-24(fp)
 4004c08:	10000515 	stw	zero,20(r2)
 4004c0c:	e0bff817 	ldw	r2,-32(fp)
 4004c10:	10800017 	ldw	r2,0(r2)
 4004c14:	10ffffc4 	addi	r3,r2,-1
 4004c18:	e0bff817 	ldw	r2,-32(fp)
 4004c1c:	10c00015 	stw	r3,0(r2)

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 4004c20:	e0bffa17 	ldw	r2,-24(fp)
 4004c24:	10800a17 	ldw	r2,40(r2)
 4004c28:	10001d26 	beq	r2,zero,4004ca0 <xTaskIncrementTick+0x1b4>
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
 4004c2c:	e0bffa17 	ldw	r2,-24(fp)
 4004c30:	10800a17 	ldw	r2,40(r2)
 4004c34:	e0bff715 	stw	r2,-36(fp)
 4004c38:	e0bffa17 	ldw	r2,-24(fp)
 4004c3c:	10800717 	ldw	r2,28(r2)
 4004c40:	e0fffa17 	ldw	r3,-24(fp)
 4004c44:	18c00817 	ldw	r3,32(r3)
 4004c48:	10c00215 	stw	r3,8(r2)
 4004c4c:	e0bffa17 	ldw	r2,-24(fp)
 4004c50:	10800817 	ldw	r2,32(r2)
 4004c54:	e0fffa17 	ldw	r3,-24(fp)
 4004c58:	18c00717 	ldw	r3,28(r3)
 4004c5c:	10c00115 	stw	r3,4(r2)
 4004c60:	e0bff717 	ldw	r2,-36(fp)
 4004c64:	10c00117 	ldw	r3,4(r2)
 4004c68:	e0bffa17 	ldw	r2,-24(fp)
 4004c6c:	10800604 	addi	r2,r2,24
 4004c70:	1880041e 	bne	r3,r2,4004c84 <xTaskIncrementTick+0x198>
 4004c74:	e0bffa17 	ldw	r2,-24(fp)
 4004c78:	10c00817 	ldw	r3,32(r2)
 4004c7c:	e0bff717 	ldw	r2,-36(fp)
 4004c80:	10c00115 	stw	r3,4(r2)
 4004c84:	e0bffa17 	ldw	r2,-24(fp)
 4004c88:	10000a15 	stw	zero,40(r2)
 4004c8c:	e0bff717 	ldw	r2,-36(fp)
 4004c90:	10800017 	ldw	r2,0(r2)
 4004c94:	10ffffc4 	addi	r3,r2,-1
 4004c98:	e0bff717 	ldw	r2,-36(fp)
 4004c9c:	10c00015 	stw	r3,0(r2)
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
 4004ca0:	e0bffa17 	ldw	r2,-24(fp)
 4004ca4:	10800b17 	ldw	r2,44(r2)
 4004ca8:	d0e71917 	ldw	r3,-25500(gp)
 4004cac:	1880032e 	bgeu	r3,r2,4004cbc <xTaskIncrementTick+0x1d0>
 4004cb0:	e0bffa17 	ldw	r2,-24(fp)
 4004cb4:	10800b17 	ldw	r2,44(r2)
 4004cb8:	d0a71915 	stw	r2,-25500(gp)
 4004cbc:	e0bffa17 	ldw	r2,-24(fp)
 4004cc0:	10800b17 	ldw	r2,44(r2)
 4004cc4:	01400504 	movi	r5,20
 4004cc8:	1009883a 	mov	r4,r2
 4004ccc:	40072d80 	call	40072d8 <__mulsi3>
 4004cd0:	1007883a 	mov	r3,r2
 4004cd4:	008120b4 	movhi	r2,1154
 4004cd8:	1885883a 	add	r2,r3,r2
 4004cdc:	10bab017 	ldw	r2,-5440(r2)
 4004ce0:	e0bff615 	stw	r2,-40(fp)
 4004ce4:	e0bffa17 	ldw	r2,-24(fp)
 4004ce8:	e0fff617 	ldw	r3,-40(fp)
 4004cec:	10c00215 	stw	r3,8(r2)
 4004cf0:	e0bff617 	ldw	r2,-40(fp)
 4004cf4:	10c00217 	ldw	r3,8(r2)
 4004cf8:	e0bffa17 	ldw	r2,-24(fp)
 4004cfc:	10c00315 	stw	r3,12(r2)
 4004d00:	e0bff617 	ldw	r2,-40(fp)
 4004d04:	10800217 	ldw	r2,8(r2)
 4004d08:	e0fffa17 	ldw	r3,-24(fp)
 4004d0c:	18c00104 	addi	r3,r3,4
 4004d10:	10c00115 	stw	r3,4(r2)
 4004d14:	e0bffa17 	ldw	r2,-24(fp)
 4004d18:	10c00104 	addi	r3,r2,4
 4004d1c:	e0bff617 	ldw	r2,-40(fp)
 4004d20:	10c00215 	stw	r3,8(r2)
 4004d24:	e0bffa17 	ldw	r2,-24(fp)
 4004d28:	10800b17 	ldw	r2,44(r2)
 4004d2c:	01400504 	movi	r5,20
 4004d30:	1009883a 	mov	r4,r2
 4004d34:	40072d80 	call	40072d8 <__mulsi3>
 4004d38:	1007883a 	mov	r3,r2
 4004d3c:	008120b4 	movhi	r2,1154
 4004d40:	10baaf04 	addi	r2,r2,-5444
 4004d44:	1887883a 	add	r3,r3,r2
 4004d48:	e0bffa17 	ldw	r2,-24(fp)
 4004d4c:	10c00515 	stw	r3,20(r2)
 4004d50:	e0bffa17 	ldw	r2,-24(fp)
 4004d54:	14400b17 	ldw	r17,44(r2)
 4004d58:	01400504 	movi	r5,20
 4004d5c:	8809883a 	mov	r4,r17
 4004d60:	40072d80 	call	40072d8 <__mulsi3>
 4004d64:	1007883a 	mov	r3,r2
 4004d68:	008120b4 	movhi	r2,1154
 4004d6c:	1885883a 	add	r2,r3,r2
 4004d70:	10baaf17 	ldw	r2,-5444(r2)
 4004d74:	14000044 	addi	r16,r2,1
 4004d78:	01400504 	movi	r5,20
 4004d7c:	8809883a 	mov	r4,r17
 4004d80:	40072d80 	call	40072d8 <__mulsi3>
 4004d84:	1007883a 	mov	r3,r2
 4004d88:	008120b4 	movhi	r2,1154
 4004d8c:	1885883a 	add	r2,r3,r2
 4004d90:	143aaf15 	stw	r16,-5444(r2)
                         * task.
                         * The case of equal priority tasks sharing
                         * processing time (which happens when both
                         * preemption and time slicing are on) is
                         * handled below.*/
                        if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 4004d94:	e0bffa17 	ldw	r2,-24(fp)
 4004d98:	10800b17 	ldw	r2,44(r2)
 4004d9c:	d0e71317 	ldw	r3,-25524(gp)
 4004da0:	18c00b17 	ldw	r3,44(r3)
 4004da4:	18bf6e2e 	bgeu	r3,r2,4004b60 <xTaskIncrementTick+0x74>
                        {
                            xSwitchRequired = pdTRUE;
 4004da8:	00800044 	movi	r2,1
 4004dac:	e0bffd15 	stw	r2,-12(fp)
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 4004db0:	003f6b06 	br	4004b60 <xTaskIncrementTick+0x74>
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
        {
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 4004db4:	d0a71317 	ldw	r2,-25524(gp)
 4004db8:	10800b17 	ldw	r2,44(r2)
 4004dbc:	01400504 	movi	r5,20
 4004dc0:	1009883a 	mov	r4,r2
 4004dc4:	40072d80 	call	40072d8 <__mulsi3>
 4004dc8:	1007883a 	mov	r3,r2
 4004dcc:	008120b4 	movhi	r2,1154
 4004dd0:	1885883a 	add	r2,r3,r2
 4004dd4:	10baaf17 	ldw	r2,-5444(r2)
 4004dd8:	108000b0 	cmpltui	r2,r2,2
 4004ddc:	1000021e 	bne	r2,zero,4004de8 <xTaskIncrementTick+0x2fc>
            {
                xSwitchRequired = pdTRUE;
 4004de0:	00800044 	movi	r2,1
 4004de4:	e0bffd15 	stw	r2,-12(fp)
        }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
        {
            if( xYieldPending != pdFALSE )
 4004de8:	d0a71c17 	ldw	r2,-25488(gp)
 4004dec:	10000626 	beq	r2,zero,4004e08 <xTaskIncrementTick+0x31c>
            {
                xSwitchRequired = pdTRUE;
 4004df0:	00800044 	movi	r2,1
 4004df4:	e0bffd15 	stw	r2,-12(fp)
 4004df8:	00000306 	br	4004e08 <xTaskIncrementTick+0x31c>
        }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
 4004dfc:	d0a71b17 	ldw	r2,-25492(gp)
 4004e00:	10800044 	addi	r2,r2,1
 4004e04:	d0a71b15 	stw	r2,-25492(gp)
            vApplicationTickHook();
        }
        #endif
    }

    return xSwitchRequired;
 4004e08:	e0bffd17 	ldw	r2,-12(fp)
}
 4004e0c:	e6fffe04 	addi	sp,fp,-8
 4004e10:	dfc00317 	ldw	ra,12(sp)
 4004e14:	df000217 	ldw	fp,8(sp)
 4004e18:	dc400117 	ldw	r17,4(sp)
 4004e1c:	dc000017 	ldw	r16,0(sp)
 4004e20:	dec00404 	addi	sp,sp,16
 4004e24:	f800283a 	ret

04004e28 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 4004e28:	defffc04 	addi	sp,sp,-16
 4004e2c:	dfc00315 	stw	ra,12(sp)
 4004e30:	df000215 	stw	fp,8(sp)
 4004e34:	df000204 	addi	fp,sp,8
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 4004e38:	d0a72117 	ldw	r2,-25468(gp)
 4004e3c:	10000326 	beq	r2,zero,4004e4c <vTaskSwitchContext+0x24>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
 4004e40:	00800044 	movi	r2,1
 4004e44:	d0a71c15 	stw	r2,-25488(gp)
             * Block specific to this task. */
            configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );
        }
        #endif
    }
}
 4004e48:	00002d06 	br	4004f00 <vTaskSwitchContext+0xd8>
        xYieldPending = pdFALSE;
 4004e4c:	d0271c15 	stw	zero,-25488(gp)
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 4004e50:	d0a71917 	ldw	r2,-25500(gp)
 4004e54:	e0bfff15 	stw	r2,-4(fp)
 4004e58:	00000306 	br	4004e68 <vTaskSwitchContext+0x40>
 4004e5c:	e0bfff17 	ldw	r2,-4(fp)
 4004e60:	10bfffc4 	addi	r2,r2,-1
 4004e64:	e0bfff15 	stw	r2,-4(fp)
 4004e68:	e0bfff17 	ldw	r2,-4(fp)
 4004e6c:	01400504 	movi	r5,20
 4004e70:	1009883a 	mov	r4,r2
 4004e74:	40072d80 	call	40072d8 <__mulsi3>
 4004e78:	1007883a 	mov	r3,r2
 4004e7c:	008120b4 	movhi	r2,1154
 4004e80:	1885883a 	add	r2,r3,r2
 4004e84:	10baaf17 	ldw	r2,-5444(r2)
 4004e88:	103ff426 	beq	r2,zero,4004e5c <vTaskSwitchContext+0x34>
 4004e8c:	01400504 	movi	r5,20
 4004e90:	e13fff17 	ldw	r4,-4(fp)
 4004e94:	40072d80 	call	40072d8 <__mulsi3>
 4004e98:	1007883a 	mov	r3,r2
 4004e9c:	008120b4 	movhi	r2,1154
 4004ea0:	10baaf04 	addi	r2,r2,-5444
 4004ea4:	1885883a 	add	r2,r3,r2
 4004ea8:	e0bffe15 	stw	r2,-8(fp)
 4004eac:	e0bffe17 	ldw	r2,-8(fp)
 4004eb0:	10800117 	ldw	r2,4(r2)
 4004eb4:	10c00117 	ldw	r3,4(r2)
 4004eb8:	e0bffe17 	ldw	r2,-8(fp)
 4004ebc:	10c00115 	stw	r3,4(r2)
 4004ec0:	e0bffe17 	ldw	r2,-8(fp)
 4004ec4:	10c00117 	ldw	r3,4(r2)
 4004ec8:	e0bffe17 	ldw	r2,-8(fp)
 4004ecc:	10800204 	addi	r2,r2,8
 4004ed0:	1880051e 	bne	r3,r2,4004ee8 <vTaskSwitchContext+0xc0>
 4004ed4:	e0bffe17 	ldw	r2,-8(fp)
 4004ed8:	10800117 	ldw	r2,4(r2)
 4004edc:	10c00117 	ldw	r3,4(r2)
 4004ee0:	e0bffe17 	ldw	r2,-8(fp)
 4004ee4:	10c00115 	stw	r3,4(r2)
 4004ee8:	e0bffe17 	ldw	r2,-8(fp)
 4004eec:	10800117 	ldw	r2,4(r2)
 4004ef0:	10800317 	ldw	r2,12(r2)
 4004ef4:	d0a71315 	stw	r2,-25524(gp)
 4004ef8:	e0bfff17 	ldw	r2,-4(fp)
 4004efc:	d0a71915 	stw	r2,-25500(gp)
}
 4004f00:	0001883a 	nop
 4004f04:	e037883a 	mov	sp,fp
 4004f08:	dfc00117 	ldw	ra,4(sp)
 4004f0c:	df000017 	ldw	fp,0(sp)
 4004f10:	dec00204 	addi	sp,sp,8
 4004f14:	f800283a 	ret

04004f18 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
 4004f18:	defffc04 	addi	sp,sp,-16
 4004f1c:	dfc00315 	stw	ra,12(sp)
 4004f20:	df000215 	stw	fp,8(sp)
 4004f24:	df000204 	addi	fp,sp,8
 4004f28:	e13fff15 	stw	r4,-4(fp)
 4004f2c:	e17ffe15 	stw	r5,-8(fp)
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 4004f30:	d0a71317 	ldw	r2,-25524(gp)
 4004f34:	10800604 	addi	r2,r2,24
 4004f38:	100b883a 	mov	r5,r2
 4004f3c:	e13fff17 	ldw	r4,-4(fp)
 4004f40:	4000bc00 	call	4000bc0 <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 4004f44:	01400044 	movi	r5,1
 4004f48:	e13ffe17 	ldw	r4,-8(fp)
 4004f4c:	4006e340 	call	4006e34 <prvAddCurrentTaskToDelayedList>
}
 4004f50:	0001883a 	nop
 4004f54:	e037883a 	mov	sp,fp
 4004f58:	dfc00117 	ldw	ra,4(sp)
 4004f5c:	df000017 	ldw	fp,0(sp)
 4004f60:	dec00204 	addi	sp,sp,8
 4004f64:	f800283a 	ret

04004f68 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
 4004f68:	defffa04 	addi	sp,sp,-24
 4004f6c:	dfc00515 	stw	ra,20(sp)
 4004f70:	df000415 	stw	fp,16(sp)
 4004f74:	df000404 	addi	fp,sp,16
 4004f78:	e13ffe15 	stw	r4,-8(fp)
 4004f7c:	e17ffd15 	stw	r5,-12(fp)
 4004f80:	e1bffc15 	stw	r6,-16(fp)
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 4004f84:	d0a71317 	ldw	r2,-25524(gp)
 4004f88:	e0fffd17 	ldw	r3,-12(fp)
 4004f8c:	18e00034 	orhi	r3,r3,32768
 4004f90:	10c00615 	stw	r3,24(r2)
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 4004f94:	e0bffe17 	ldw	r2,-8(fp)
 4004f98:	10800117 	ldw	r2,4(r2)
 4004f9c:	e0bfff15 	stw	r2,-4(fp)
 4004fa0:	d0a71317 	ldw	r2,-25524(gp)
 4004fa4:	e0ffff17 	ldw	r3,-4(fp)
 4004fa8:	10c00715 	stw	r3,28(r2)
 4004fac:	d0a71317 	ldw	r2,-25524(gp)
 4004fb0:	e0ffff17 	ldw	r3,-4(fp)
 4004fb4:	18c00217 	ldw	r3,8(r3)
 4004fb8:	10c00815 	stw	r3,32(r2)
 4004fbc:	d0e71317 	ldw	r3,-25524(gp)
 4004fc0:	e0bfff17 	ldw	r2,-4(fp)
 4004fc4:	10800217 	ldw	r2,8(r2)
 4004fc8:	18c00604 	addi	r3,r3,24
 4004fcc:	10c00115 	stw	r3,4(r2)
 4004fd0:	d0a71317 	ldw	r2,-25524(gp)
 4004fd4:	10c00604 	addi	r3,r2,24
 4004fd8:	e0bfff17 	ldw	r2,-4(fp)
 4004fdc:	10c00215 	stw	r3,8(r2)
 4004fe0:	d0a71317 	ldw	r2,-25524(gp)
 4004fe4:	e0fffe17 	ldw	r3,-8(fp)
 4004fe8:	10c00a15 	stw	r3,40(r2)
 4004fec:	e0bffe17 	ldw	r2,-8(fp)
 4004ff0:	10800017 	ldw	r2,0(r2)
 4004ff4:	10c00044 	addi	r3,r2,1
 4004ff8:	e0bffe17 	ldw	r2,-8(fp)
 4004ffc:	10c00015 	stw	r3,0(r2)

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 4005000:	01400044 	movi	r5,1
 4005004:	e13ffc17 	ldw	r4,-16(fp)
 4005008:	4006e340 	call	4006e34 <prvAddCurrentTaskToDelayedList>
}
 400500c:	0001883a 	nop
 4005010:	e037883a 	mov	sp,fp
 4005014:	dfc00117 	ldw	ra,4(sp)
 4005018:	df000017 	ldw	fp,0(sp)
 400501c:	dec00204 	addi	sp,sp,8
 4005020:	f800283a 	ret

04005024 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
 4005024:	defff504 	addi	sp,sp,-44
 4005028:	dfc00a15 	stw	ra,40(sp)
 400502c:	df000915 	stw	fp,36(sp)
 4005030:	dc400815 	stw	r17,32(sp)
 4005034:	dc000715 	stw	r16,28(sp)
 4005038:	df000904 	addi	fp,sp,36
 400503c:	e13ff715 	stw	r4,-36(fp)
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 4005040:	e0bff717 	ldw	r2,-36(fp)
 4005044:	10800317 	ldw	r2,12(r2)
 4005048:	10800317 	ldw	r2,12(r2)
 400504c:	e0bffc15 	stw	r2,-16(fp)
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
 4005050:	e0bffc17 	ldw	r2,-16(fp)
 4005054:	10800a17 	ldw	r2,40(r2)
 4005058:	e0bffb15 	stw	r2,-20(fp)
 400505c:	e0bffc17 	ldw	r2,-16(fp)
 4005060:	10800717 	ldw	r2,28(r2)
 4005064:	e0fffc17 	ldw	r3,-16(fp)
 4005068:	18c00817 	ldw	r3,32(r3)
 400506c:	10c00215 	stw	r3,8(r2)
 4005070:	e0bffc17 	ldw	r2,-16(fp)
 4005074:	10800817 	ldw	r2,32(r2)
 4005078:	e0fffc17 	ldw	r3,-16(fp)
 400507c:	18c00717 	ldw	r3,28(r3)
 4005080:	10c00115 	stw	r3,4(r2)
 4005084:	e0bffb17 	ldw	r2,-20(fp)
 4005088:	10c00117 	ldw	r3,4(r2)
 400508c:	e0bffc17 	ldw	r2,-16(fp)
 4005090:	10800604 	addi	r2,r2,24
 4005094:	1880041e 	bne	r3,r2,40050a8 <xTaskRemoveFromEventList+0x84>
 4005098:	e0bffc17 	ldw	r2,-16(fp)
 400509c:	10c00817 	ldw	r3,32(r2)
 40050a0:	e0bffb17 	ldw	r2,-20(fp)
 40050a4:	10c00115 	stw	r3,4(r2)
 40050a8:	e0bffc17 	ldw	r2,-16(fp)
 40050ac:	10000a15 	stw	zero,40(r2)
 40050b0:	e0bffb17 	ldw	r2,-20(fp)
 40050b4:	10800017 	ldw	r2,0(r2)
 40050b8:	10ffffc4 	addi	r3,r2,-1
 40050bc:	e0bffb17 	ldw	r2,-20(fp)
 40050c0:	10c00015 	stw	r3,0(r2)

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 40050c4:	d0a72117 	ldw	r2,-25468(gp)
 40050c8:	10005b1e 	bne	r2,zero,4005238 <xTaskRemoveFromEventList+0x214>
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
 40050cc:	e0bffc17 	ldw	r2,-16(fp)
 40050d0:	10800517 	ldw	r2,20(r2)
 40050d4:	e0bff915 	stw	r2,-28(fp)
 40050d8:	e0bffc17 	ldw	r2,-16(fp)
 40050dc:	10800217 	ldw	r2,8(r2)
 40050e0:	e0fffc17 	ldw	r3,-16(fp)
 40050e4:	18c00317 	ldw	r3,12(r3)
 40050e8:	10c00215 	stw	r3,8(r2)
 40050ec:	e0bffc17 	ldw	r2,-16(fp)
 40050f0:	10800317 	ldw	r2,12(r2)
 40050f4:	e0fffc17 	ldw	r3,-16(fp)
 40050f8:	18c00217 	ldw	r3,8(r3)
 40050fc:	10c00115 	stw	r3,4(r2)
 4005100:	e0bff917 	ldw	r2,-28(fp)
 4005104:	10c00117 	ldw	r3,4(r2)
 4005108:	e0bffc17 	ldw	r2,-16(fp)
 400510c:	10800104 	addi	r2,r2,4
 4005110:	1880041e 	bne	r3,r2,4005124 <xTaskRemoveFromEventList+0x100>
 4005114:	e0bffc17 	ldw	r2,-16(fp)
 4005118:	10c00317 	ldw	r3,12(r2)
 400511c:	e0bff917 	ldw	r2,-28(fp)
 4005120:	10c00115 	stw	r3,4(r2)
 4005124:	e0bffc17 	ldw	r2,-16(fp)
 4005128:	10000515 	stw	zero,20(r2)
 400512c:	e0bff917 	ldw	r2,-28(fp)
 4005130:	10800017 	ldw	r2,0(r2)
 4005134:	10ffffc4 	addi	r3,r2,-1
 4005138:	e0bff917 	ldw	r2,-28(fp)
 400513c:	10c00015 	stw	r3,0(r2)
        prvAddTaskToReadyList( pxUnblockedTCB );
 4005140:	e0bffc17 	ldw	r2,-16(fp)
 4005144:	10800b17 	ldw	r2,44(r2)
 4005148:	d0e71917 	ldw	r3,-25500(gp)
 400514c:	1880032e 	bgeu	r3,r2,400515c <xTaskRemoveFromEventList+0x138>
 4005150:	e0bffc17 	ldw	r2,-16(fp)
 4005154:	10800b17 	ldw	r2,44(r2)
 4005158:	d0a71915 	stw	r2,-25500(gp)
 400515c:	e0bffc17 	ldw	r2,-16(fp)
 4005160:	10800b17 	ldw	r2,44(r2)
 4005164:	01400504 	movi	r5,20
 4005168:	1009883a 	mov	r4,r2
 400516c:	40072d80 	call	40072d8 <__mulsi3>
 4005170:	1007883a 	mov	r3,r2
 4005174:	008120b4 	movhi	r2,1154
 4005178:	1885883a 	add	r2,r3,r2
 400517c:	10bab017 	ldw	r2,-5440(r2)
 4005180:	e0bff815 	stw	r2,-32(fp)
 4005184:	e0bffc17 	ldw	r2,-16(fp)
 4005188:	e0fff817 	ldw	r3,-32(fp)
 400518c:	10c00215 	stw	r3,8(r2)
 4005190:	e0bff817 	ldw	r2,-32(fp)
 4005194:	10c00217 	ldw	r3,8(r2)
 4005198:	e0bffc17 	ldw	r2,-16(fp)
 400519c:	10c00315 	stw	r3,12(r2)
 40051a0:	e0bff817 	ldw	r2,-32(fp)
 40051a4:	10800217 	ldw	r2,8(r2)
 40051a8:	e0fffc17 	ldw	r3,-16(fp)
 40051ac:	18c00104 	addi	r3,r3,4
 40051b0:	10c00115 	stw	r3,4(r2)
 40051b4:	e0bffc17 	ldw	r2,-16(fp)
 40051b8:	10c00104 	addi	r3,r2,4
 40051bc:	e0bff817 	ldw	r2,-32(fp)
 40051c0:	10c00215 	stw	r3,8(r2)
 40051c4:	e0bffc17 	ldw	r2,-16(fp)
 40051c8:	10800b17 	ldw	r2,44(r2)
 40051cc:	01400504 	movi	r5,20
 40051d0:	1009883a 	mov	r4,r2
 40051d4:	40072d80 	call	40072d8 <__mulsi3>
 40051d8:	1007883a 	mov	r3,r2
 40051dc:	008120b4 	movhi	r2,1154
 40051e0:	10baaf04 	addi	r2,r2,-5444
 40051e4:	1887883a 	add	r3,r3,r2
 40051e8:	e0bffc17 	ldw	r2,-16(fp)
 40051ec:	10c00515 	stw	r3,20(r2)
 40051f0:	e0bffc17 	ldw	r2,-16(fp)
 40051f4:	14400b17 	ldw	r17,44(r2)
 40051f8:	01400504 	movi	r5,20
 40051fc:	8809883a 	mov	r4,r17
 4005200:	40072d80 	call	40072d8 <__mulsi3>
 4005204:	1007883a 	mov	r3,r2
 4005208:	008120b4 	movhi	r2,1154
 400520c:	1885883a 	add	r2,r3,r2
 4005210:	10baaf17 	ldw	r2,-5444(r2)
 4005214:	14000044 	addi	r16,r2,1
 4005218:	01400504 	movi	r5,20
 400521c:	8809883a 	mov	r4,r17
 4005220:	40072d80 	call	40072d8 <__mulsi3>
 4005224:	1007883a 	mov	r3,r2
 4005228:	008120b4 	movhi	r2,1154
 400522c:	1885883a 	add	r2,r3,r2
 4005230:	143aaf15 	stw	r16,-5444(r2)
 4005234:	00001c06 	br	40052a8 <xTaskRemoveFromEventList+0x284>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 4005238:	008120b4 	movhi	r2,1154
 400523c:	10bad317 	ldw	r2,-5300(r2)
 4005240:	e0bffa15 	stw	r2,-24(fp)
 4005244:	e0bffc17 	ldw	r2,-16(fp)
 4005248:	e0fffa17 	ldw	r3,-24(fp)
 400524c:	10c00715 	stw	r3,28(r2)
 4005250:	e0bffa17 	ldw	r2,-24(fp)
 4005254:	10c00217 	ldw	r3,8(r2)
 4005258:	e0bffc17 	ldw	r2,-16(fp)
 400525c:	10c00815 	stw	r3,32(r2)
 4005260:	e0bffa17 	ldw	r2,-24(fp)
 4005264:	10800217 	ldw	r2,8(r2)
 4005268:	e0fffc17 	ldw	r3,-16(fp)
 400526c:	18c00604 	addi	r3,r3,24
 4005270:	10c00115 	stw	r3,4(r2)
 4005274:	e0bffc17 	ldw	r2,-16(fp)
 4005278:	10c00604 	addi	r3,r2,24
 400527c:	e0bffa17 	ldw	r2,-24(fp)
 4005280:	10c00215 	stw	r3,8(r2)
 4005284:	e0fffc17 	ldw	r3,-16(fp)
 4005288:	008120b4 	movhi	r2,1154
 400528c:	10bad204 	addi	r2,r2,-5304
 4005290:	18800a15 	stw	r2,40(r3)
 4005294:	008120b4 	movhi	r2,1154
 4005298:	10bad217 	ldw	r2,-5304(r2)
 400529c:	10c00044 	addi	r3,r2,1
 40052a0:	008120b4 	movhi	r2,1154
 40052a4:	10fad215 	stw	r3,-5304(r2)
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 40052a8:	e0bffc17 	ldw	r2,-16(fp)
 40052ac:	10800b17 	ldw	r2,44(r2)
 40052b0:	d0e71317 	ldw	r3,-25524(gp)
 40052b4:	18c00b17 	ldw	r3,44(r3)
 40052b8:	1880052e 	bgeu	r3,r2,40052d0 <xTaskRemoveFromEventList+0x2ac>
    {
        /* Return true if the task removed from the event list has a higher
         * priority than the calling task.  This allows the calling task to know if
         * it should force a context switch now. */
        xReturn = pdTRUE;
 40052bc:	00800044 	movi	r2,1
 40052c0:	e0bffd15 	stw	r2,-12(fp)

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
 40052c4:	00800044 	movi	r2,1
 40052c8:	d0a71c15 	stw	r2,-25488(gp)
 40052cc:	00000106 	br	40052d4 <xTaskRemoveFromEventList+0x2b0>
    }
    else
    {
        xReturn = pdFALSE;
 40052d0:	e03ffd15 	stw	zero,-12(fp)
    }

    return xReturn;
 40052d4:	e0bffd17 	ldw	r2,-12(fp)
}
 40052d8:	e6fffe04 	addi	sp,fp,-8
 40052dc:	dfc00317 	ldw	ra,12(sp)
 40052e0:	df000217 	ldw	fp,8(sp)
 40052e4:	dc400117 	ldw	r17,4(sp)
 40052e8:	dc000017 	ldw	r16,0(sp)
 40052ec:	dec00404 	addi	sp,sp,16
 40052f0:	f800283a 	ret

040052f4 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
 40052f4:	defff604 	addi	sp,sp,-40
 40052f8:	dfc00915 	stw	ra,36(sp)
 40052fc:	df000815 	stw	fp,32(sp)
 4005300:	dc400715 	stw	r17,28(sp)
 4005304:	dc000615 	stw	r16,24(sp)
 4005308:	df000804 	addi	fp,sp,32
 400530c:	e13ff915 	stw	r4,-28(fp)
 4005310:	e17ff815 	stw	r5,-32(fp)
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 4005314:	e0bff817 	ldw	r2,-32(fp)
 4005318:	10e00034 	orhi	r3,r2,32768
 400531c:	e0bff917 	ldw	r2,-28(fp)
 4005320:	10c00015 	stw	r3,0(r2)

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 4005324:	e0bff917 	ldw	r2,-28(fp)
 4005328:	10800317 	ldw	r2,12(r2)
 400532c:	e0bffd15 	stw	r2,-12(fp)
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( pxEventListItem );
 4005330:	e0bff917 	ldw	r2,-28(fp)
 4005334:	10800417 	ldw	r2,16(r2)
 4005338:	e0bffc15 	stw	r2,-16(fp)
 400533c:	e0bff917 	ldw	r2,-28(fp)
 4005340:	10800117 	ldw	r2,4(r2)
 4005344:	e0fff917 	ldw	r3,-28(fp)
 4005348:	18c00217 	ldw	r3,8(r3)
 400534c:	10c00215 	stw	r3,8(r2)
 4005350:	e0bff917 	ldw	r2,-28(fp)
 4005354:	10800217 	ldw	r2,8(r2)
 4005358:	e0fff917 	ldw	r3,-28(fp)
 400535c:	18c00117 	ldw	r3,4(r3)
 4005360:	10c00115 	stw	r3,4(r2)
 4005364:	e0bffc17 	ldw	r2,-16(fp)
 4005368:	10800117 	ldw	r2,4(r2)
 400536c:	e0fff917 	ldw	r3,-28(fp)
 4005370:	1880041e 	bne	r3,r2,4005384 <vTaskRemoveFromUnorderedEventList+0x90>
 4005374:	e0bff917 	ldw	r2,-28(fp)
 4005378:	10c00217 	ldw	r3,8(r2)
 400537c:	e0bffc17 	ldw	r2,-16(fp)
 4005380:	10c00115 	stw	r3,4(r2)
 4005384:	e0bff917 	ldw	r2,-28(fp)
 4005388:	10000415 	stw	zero,16(r2)
 400538c:	e0bffc17 	ldw	r2,-16(fp)
 4005390:	10800017 	ldw	r2,0(r2)
 4005394:	10ffffc4 	addi	r3,r2,-1
 4005398:	e0bffc17 	ldw	r2,-16(fp)
 400539c:	10c00015 	stw	r3,0(r2)
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
 40053a0:	e0bffd17 	ldw	r2,-12(fp)
 40053a4:	10800517 	ldw	r2,20(r2)
 40053a8:	e0bffb15 	stw	r2,-20(fp)
 40053ac:	e0bffd17 	ldw	r2,-12(fp)
 40053b0:	10800217 	ldw	r2,8(r2)
 40053b4:	e0fffd17 	ldw	r3,-12(fp)
 40053b8:	18c00317 	ldw	r3,12(r3)
 40053bc:	10c00215 	stw	r3,8(r2)
 40053c0:	e0bffd17 	ldw	r2,-12(fp)
 40053c4:	10800317 	ldw	r2,12(r2)
 40053c8:	e0fffd17 	ldw	r3,-12(fp)
 40053cc:	18c00217 	ldw	r3,8(r3)
 40053d0:	10c00115 	stw	r3,4(r2)
 40053d4:	e0bffb17 	ldw	r2,-20(fp)
 40053d8:	10c00117 	ldw	r3,4(r2)
 40053dc:	e0bffd17 	ldw	r2,-12(fp)
 40053e0:	10800104 	addi	r2,r2,4
 40053e4:	1880041e 	bne	r3,r2,40053f8 <vTaskRemoveFromUnorderedEventList+0x104>
 40053e8:	e0bffd17 	ldw	r2,-12(fp)
 40053ec:	10c00317 	ldw	r3,12(r2)
 40053f0:	e0bffb17 	ldw	r2,-20(fp)
 40053f4:	10c00115 	stw	r3,4(r2)
 40053f8:	e0bffd17 	ldw	r2,-12(fp)
 40053fc:	10000515 	stw	zero,20(r2)
 4005400:	e0bffb17 	ldw	r2,-20(fp)
 4005404:	10800017 	ldw	r2,0(r2)
 4005408:	10ffffc4 	addi	r3,r2,-1
 400540c:	e0bffb17 	ldw	r2,-20(fp)
 4005410:	10c00015 	stw	r3,0(r2)
    prvAddTaskToReadyList( pxUnblockedTCB );
 4005414:	e0bffd17 	ldw	r2,-12(fp)
 4005418:	10800b17 	ldw	r2,44(r2)
 400541c:	d0e71917 	ldw	r3,-25500(gp)
 4005420:	1880032e 	bgeu	r3,r2,4005430 <vTaskRemoveFromUnorderedEventList+0x13c>
 4005424:	e0bffd17 	ldw	r2,-12(fp)
 4005428:	10800b17 	ldw	r2,44(r2)
 400542c:	d0a71915 	stw	r2,-25500(gp)
 4005430:	e0bffd17 	ldw	r2,-12(fp)
 4005434:	10800b17 	ldw	r2,44(r2)
 4005438:	01400504 	movi	r5,20
 400543c:	1009883a 	mov	r4,r2
 4005440:	40072d80 	call	40072d8 <__mulsi3>
 4005444:	1007883a 	mov	r3,r2
 4005448:	008120b4 	movhi	r2,1154
 400544c:	1885883a 	add	r2,r3,r2
 4005450:	10bab017 	ldw	r2,-5440(r2)
 4005454:	e0bffa15 	stw	r2,-24(fp)
 4005458:	e0bffd17 	ldw	r2,-12(fp)
 400545c:	e0fffa17 	ldw	r3,-24(fp)
 4005460:	10c00215 	stw	r3,8(r2)
 4005464:	e0bffa17 	ldw	r2,-24(fp)
 4005468:	10c00217 	ldw	r3,8(r2)
 400546c:	e0bffd17 	ldw	r2,-12(fp)
 4005470:	10c00315 	stw	r3,12(r2)
 4005474:	e0bffa17 	ldw	r2,-24(fp)
 4005478:	10800217 	ldw	r2,8(r2)
 400547c:	e0fffd17 	ldw	r3,-12(fp)
 4005480:	18c00104 	addi	r3,r3,4
 4005484:	10c00115 	stw	r3,4(r2)
 4005488:	e0bffd17 	ldw	r2,-12(fp)
 400548c:	10c00104 	addi	r3,r2,4
 4005490:	e0bffa17 	ldw	r2,-24(fp)
 4005494:	10c00215 	stw	r3,8(r2)
 4005498:	e0bffd17 	ldw	r2,-12(fp)
 400549c:	10800b17 	ldw	r2,44(r2)
 40054a0:	01400504 	movi	r5,20
 40054a4:	1009883a 	mov	r4,r2
 40054a8:	40072d80 	call	40072d8 <__mulsi3>
 40054ac:	1007883a 	mov	r3,r2
 40054b0:	008120b4 	movhi	r2,1154
 40054b4:	10baaf04 	addi	r2,r2,-5444
 40054b8:	1887883a 	add	r3,r3,r2
 40054bc:	e0bffd17 	ldw	r2,-12(fp)
 40054c0:	10c00515 	stw	r3,20(r2)
 40054c4:	e0bffd17 	ldw	r2,-12(fp)
 40054c8:	14400b17 	ldw	r17,44(r2)
 40054cc:	01400504 	movi	r5,20
 40054d0:	8809883a 	mov	r4,r17
 40054d4:	40072d80 	call	40072d8 <__mulsi3>
 40054d8:	1007883a 	mov	r3,r2
 40054dc:	008120b4 	movhi	r2,1154
 40054e0:	1885883a 	add	r2,r3,r2
 40054e4:	10baaf17 	ldw	r2,-5444(r2)
 40054e8:	14000044 	addi	r16,r2,1
 40054ec:	01400504 	movi	r5,20
 40054f0:	8809883a 	mov	r4,r17
 40054f4:	40072d80 	call	40072d8 <__mulsi3>
 40054f8:	1007883a 	mov	r3,r2
 40054fc:	008120b4 	movhi	r2,1154
 4005500:	1885883a 	add	r2,r3,r2
 4005504:	143aaf15 	stw	r16,-5444(r2)

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 4005508:	e0bffd17 	ldw	r2,-12(fp)
 400550c:	10800b17 	ldw	r2,44(r2)
 4005510:	d0e71317 	ldw	r3,-25524(gp)
 4005514:	18c00b17 	ldw	r3,44(r3)
 4005518:	1880022e 	bgeu	r3,r2,4005524 <vTaskRemoveFromUnorderedEventList+0x230>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
 400551c:	00800044 	movi	r2,1
 4005520:	d0a71c15 	stw	r2,-25488(gp)
    }
}
 4005524:	0001883a 	nop
 4005528:	e6fffe04 	addi	sp,fp,-8
 400552c:	dfc00317 	ldw	ra,12(sp)
 4005530:	df000217 	ldw	fp,8(sp)
 4005534:	dc400117 	ldw	r17,4(sp)
 4005538:	dc000017 	ldw	r16,0(sp)
 400553c:	dec00404 	addi	sp,sp,16
 4005540:	f800283a 	ret

04005544 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
 4005544:	defffd04 	addi	sp,sp,-12
 4005548:	dfc00215 	stw	ra,8(sp)
 400554c:	df000115 	stw	fp,4(sp)
 4005550:	df000104 	addi	fp,sp,4
 4005554:	e13fff15 	stw	r4,-4(fp)
    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
 4005558:	4005f740 	call	4005f74 <vTaskEnterCritical>
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
 400555c:	d0e71d17 	ldw	r3,-25484(gp)
 4005560:	e0bfff17 	ldw	r2,-4(fp)
 4005564:	10c00015 	stw	r3,0(r2)
        pxTimeOut->xTimeOnEntering = xTickCount;
 4005568:	d0e71817 	ldw	r3,-25504(gp)
 400556c:	e0bfff17 	ldw	r2,-4(fp)
 4005570:	10c00115 	stw	r3,4(r2)
    }
    taskEXIT_CRITICAL();
 4005574:	4005fc80 	call	4005fc8 <vTaskExitCritical>
}
 4005578:	0001883a 	nop
 400557c:	e037883a 	mov	sp,fp
 4005580:	dfc00117 	ldw	ra,4(sp)
 4005584:	df000017 	ldw	fp,0(sp)
 4005588:	dec00204 	addi	sp,sp,8
 400558c:	f800283a 	ret

04005590 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
 4005590:	defffe04 	addi	sp,sp,-8
 4005594:	df000115 	stw	fp,4(sp)
 4005598:	df000104 	addi	fp,sp,4
 400559c:	e13fff15 	stw	r4,-4(fp)
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
 40055a0:	d0e71d17 	ldw	r3,-25484(gp)
 40055a4:	e0bfff17 	ldw	r2,-4(fp)
 40055a8:	10c00015 	stw	r3,0(r2)
    pxTimeOut->xTimeOnEntering = xTickCount;
 40055ac:	d0e71817 	ldw	r3,-25504(gp)
 40055b0:	e0bfff17 	ldw	r2,-4(fp)
 40055b4:	10c00115 	stw	r3,4(r2)
}
 40055b8:	0001883a 	nop
 40055bc:	e037883a 	mov	sp,fp
 40055c0:	df000017 	ldw	fp,0(sp)
 40055c4:	dec00104 	addi	sp,sp,4
 40055c8:	f800283a 	ret

040055cc <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
 40055cc:	defff904 	addi	sp,sp,-28
 40055d0:	dfc00615 	stw	ra,24(sp)
 40055d4:	df000515 	stw	fp,20(sp)
 40055d8:	df000504 	addi	fp,sp,20
 40055dc:	e13ffc15 	stw	r4,-16(fp)
 40055e0:	e17ffb15 	stw	r5,-20(fp)
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
 40055e4:	4005f740 	call	4005f74 <vTaskEnterCritical>
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
 40055e8:	d0a71817 	ldw	r2,-25504(gp)
 40055ec:	e0bffe15 	stw	r2,-8(fp)
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 40055f0:	e0bffc17 	ldw	r2,-16(fp)
 40055f4:	10800117 	ldw	r2,4(r2)
 40055f8:	e0fffe17 	ldw	r3,-8(fp)
 40055fc:	1885c83a 	sub	r2,r3,r2
 4005600:	e0bffd15 	stw	r2,-12(fp)
            }
            else
        #endif

        #if ( INCLUDE_vTaskSuspend == 1 )
            if( *pxTicksToWait == portMAX_DELAY )
 4005604:	e0bffb17 	ldw	r2,-20(fp)
 4005608:	10800017 	ldw	r2,0(r2)
 400560c:	10bfffd8 	cmpnei	r2,r2,-1
 4005610:	1000021e 	bne	r2,zero,400561c <xTaskCheckForTimeOut+0x50>
            {
                /* If INCLUDE_vTaskSuspend is set to 1 and the block time
                 * specified is the maximum block time then the task should block
                 * indefinitely, and therefore never time out. */
                xReturn = pdFALSE;
 4005614:	e03fff15 	stw	zero,-4(fp)
 4005618:	00001f06 	br	4005698 <xTaskCheckForTimeOut+0xcc>
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 400561c:	e0bffc17 	ldw	r2,-16(fp)
 4005620:	10c00017 	ldw	r3,0(r2)
 4005624:	d0a71d17 	ldw	r2,-25484(gp)
 4005628:	18800926 	beq	r3,r2,4005650 <xTaskCheckForTimeOut+0x84>
 400562c:	e0bffc17 	ldw	r2,-16(fp)
 4005630:	10800117 	ldw	r2,4(r2)
 4005634:	e0fffe17 	ldw	r3,-8(fp)
 4005638:	18800536 	bltu	r3,r2,4005650 <xTaskCheckForTimeOut+0x84>
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
 400563c:	00800044 	movi	r2,1
 4005640:	e0bfff15 	stw	r2,-4(fp)
            *pxTicksToWait = ( TickType_t ) 0;
 4005644:	e0bffb17 	ldw	r2,-20(fp)
 4005648:	10000015 	stw	zero,0(r2)
 400564c:	00001206 	br	4005698 <xTaskCheckForTimeOut+0xcc>
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 4005650:	e0bffb17 	ldw	r2,-20(fp)
 4005654:	10800017 	ldw	r2,0(r2)
 4005658:	e0fffd17 	ldw	r3,-12(fp)
 400565c:	18800a2e 	bgeu	r3,r2,4005688 <xTaskCheckForTimeOut+0xbc>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
 4005660:	e0bffb17 	ldw	r2,-20(fp)
 4005664:	10c00017 	ldw	r3,0(r2)
 4005668:	e0bffd17 	ldw	r2,-12(fp)
 400566c:	1887c83a 	sub	r3,r3,r2
 4005670:	e0bffb17 	ldw	r2,-20(fp)
 4005674:	10c00015 	stw	r3,0(r2)
            vTaskInternalSetTimeOutState( pxTimeOut );
 4005678:	e13ffc17 	ldw	r4,-16(fp)
 400567c:	40055900 	call	4005590 <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
 4005680:	e03fff15 	stw	zero,-4(fp)
 4005684:	00000406 	br	4005698 <xTaskCheckForTimeOut+0xcc>
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
 4005688:	e0bffb17 	ldw	r2,-20(fp)
 400568c:	10000015 	stw	zero,0(r2)
            xReturn = pdTRUE;
 4005690:	00800044 	movi	r2,1
 4005694:	e0bfff15 	stw	r2,-4(fp)
        }
    }
    taskEXIT_CRITICAL();
 4005698:	4005fc80 	call	4005fc8 <vTaskExitCritical>

    return xReturn;
 400569c:	e0bfff17 	ldw	r2,-4(fp)
}
 40056a0:	e037883a 	mov	sp,fp
 40056a4:	dfc00117 	ldw	ra,4(sp)
 40056a8:	df000017 	ldw	fp,0(sp)
 40056ac:	dec00204 	addi	sp,sp,8
 40056b0:	f800283a 	ret

040056b4 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
 40056b4:	deffff04 	addi	sp,sp,-4
 40056b8:	df000015 	stw	fp,0(sp)
 40056bc:	d839883a 	mov	fp,sp
    xYieldPending = pdTRUE;
 40056c0:	00800044 	movi	r2,1
 40056c4:	d0a71c15 	stw	r2,-25488(gp)
}
 40056c8:	0001883a 	nop
 40056cc:	e037883a 	mov	sp,fp
 40056d0:	df000017 	ldw	fp,0(sp)
 40056d4:	dec00104 	addi	sp,sp,4
 40056d8:	f800283a 	ret

040056dc <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 40056dc:	defffd04 	addi	sp,sp,-12
 40056e0:	dfc00215 	stw	ra,8(sp)
 40056e4:	df000115 	stw	fp,4(sp)
 40056e8:	df000104 	addi	fp,sp,4
 40056ec:	e13fff15 	stw	r4,-4(fp)

    for( ; ; )
    {
        /* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();
 40056f0:	40057b80 	call	40057b8 <prvCheckTasksWaitingTermination>
 40056f4:	003ffe06 	br	40056f0 <prvIdleTask+0x14>

040056f8 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
 40056f8:	defffd04 	addi	sp,sp,-12
 40056fc:	dfc00215 	stw	ra,8(sp)
 4005700:	df000115 	stw	fp,4(sp)
 4005704:	df000104 	addi	fp,sp,4
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 4005708:	e03fff15 	stw	zero,-4(fp)
 400570c:	00000c06 	br	4005740 <prvInitialiseTaskLists+0x48>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 4005710:	01400504 	movi	r5,20
 4005714:	e13fff17 	ldw	r4,-4(fp)
 4005718:	40072d80 	call	40072d8 <__mulsi3>
 400571c:	1007883a 	mov	r3,r2
 4005720:	008120b4 	movhi	r2,1154
 4005724:	10baaf04 	addi	r2,r2,-5444
 4005728:	1885883a 	add	r2,r3,r2
 400572c:	1009883a 	mov	r4,r2
 4005730:	4000aa00 	call	4000aa0 <vListInitialise>
    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 4005734:	e0bfff17 	ldw	r2,-4(fp)
 4005738:	10800044 	addi	r2,r2,1
 400573c:	e0bfff15 	stw	r2,-4(fp)
 4005740:	e0bfff17 	ldw	r2,-4(fp)
 4005744:	10800170 	cmpltui	r2,r2,5
 4005748:	103ff11e 	bne	r2,zero,4005710 <prvInitialiseTaskLists+0x18>
    }

    vListInitialise( &xDelayedTaskList1 );
 400574c:	010120b4 	movhi	r4,1154
 4005750:	213ac804 	addi	r4,r4,-5344
 4005754:	4000aa00 	call	4000aa0 <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
 4005758:	010120b4 	movhi	r4,1154
 400575c:	213acd04 	addi	r4,r4,-5324
 4005760:	4000aa00 	call	4000aa0 <vListInitialise>
    vListInitialise( &xPendingReadyList );
 4005764:	010120b4 	movhi	r4,1154
 4005768:	213ad204 	addi	r4,r4,-5304
 400576c:	4000aa00 	call	4000aa0 <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        vListInitialise( &xTasksWaitingTermination );
 4005770:	010120b4 	movhi	r4,1154
 4005774:	213ad704 	addi	r4,r4,-5284
 4005778:	4000aa00 	call	4000aa0 <vListInitialise>
    }
    #endif /* INCLUDE_vTaskDelete */

    #if ( INCLUDE_vTaskSuspend == 1 )
    {
        vListInitialise( &xSuspendedTaskList );
 400577c:	010120b4 	movhi	r4,1154
 4005780:	213adc04 	addi	r4,r4,-5264
 4005784:	4000aa00 	call	4000aa0 <vListInitialise>
    }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
 4005788:	008120b4 	movhi	r2,1154
 400578c:	10bac804 	addi	r2,r2,-5344
 4005790:	d0a71415 	stw	r2,-25520(gp)
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
 4005794:	008120b4 	movhi	r2,1154
 4005798:	10bacd04 	addi	r2,r2,-5324
 400579c:	d0a71515 	stw	r2,-25516(gp)
}
 40057a0:	0001883a 	nop
 40057a4:	e037883a 	mov	sp,fp
 40057a8:	dfc00117 	ldw	ra,4(sp)
 40057ac:	df000017 	ldw	fp,0(sp)
 40057b0:	dec00204 	addi	sp,sp,8
 40057b4:	f800283a 	ret

040057b8 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
 40057b8:	defffd04 	addi	sp,sp,-12
 40057bc:	dfc00215 	stw	ra,8(sp)
 40057c0:	df000115 	stw	fp,4(sp)
 40057c4:	df000104 	addi	fp,sp,4
    {
        TCB_t * pxTCB;

        /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
         * being called too often in the idle task. */
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 40057c8:	00001206 	br	4005814 <prvCheckTasksWaitingTermination+0x5c>
        {
            taskENTER_CRITICAL();
 40057cc:	4005f740 	call	4005f74 <vTaskEnterCritical>
            {
                pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 40057d0:	008120b4 	movhi	r2,1154
 40057d4:	10bada17 	ldw	r2,-5272(r2)
 40057d8:	10800317 	ldw	r2,12(r2)
 40057dc:	e0bfff15 	stw	r2,-4(fp)
                ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 40057e0:	e0bfff17 	ldw	r2,-4(fp)
 40057e4:	10800104 	addi	r2,r2,4
 40057e8:	1009883a 	mov	r4,r2
 40057ec:	4000c980 	call	4000c98 <uxListRemove>
                --uxCurrentNumberOfTasks;
 40057f0:	d0a71717 	ldw	r2,-25508(gp)
 40057f4:	10bfffc4 	addi	r2,r2,-1
 40057f8:	d0a71715 	stw	r2,-25508(gp)
                --uxDeletedTasksWaitingCleanUp;
 40057fc:	d0a71617 	ldw	r2,-25512(gp)
 4005800:	10bfffc4 	addi	r2,r2,-1
 4005804:	d0a71615 	stw	r2,-25512(gp)
            }
            taskEXIT_CRITICAL();
 4005808:	4005fc80 	call	4005fc8 <vTaskExitCritical>

            prvDeleteTCB( pxTCB );
 400580c:	e13fff17 	ldw	r4,-4(fp)
 4005810:	40058fc0 	call	40058fc <prvDeleteTCB>
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 4005814:	d0a71617 	ldw	r2,-25512(gp)
 4005818:	103fec1e 	bne	r2,zero,40057cc <prvCheckTasksWaitingTermination+0x14>
        }
    }
    #endif /* INCLUDE_vTaskDelete */
}
 400581c:	0001883a 	nop
 4005820:	0001883a 	nop
 4005824:	e037883a 	mov	sp,fp
 4005828:	dfc00117 	ldw	ra,4(sp)
 400582c:	df000017 	ldw	fp,0(sp)
 4005830:	dec00204 	addi	sp,sp,8
 4005834:	f800283a 	ret

04005838 <prvTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )

    static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
    {
 4005838:	defffd04 	addi	sp,sp,-12
 400583c:	df000215 	stw	fp,8(sp)
 4005840:	df000204 	addi	fp,sp,8
 4005844:	e13ffe15 	stw	r4,-8(fp)
        uint32_t ulCount = 0U;
 4005848:	e03fff15 	stw	zero,-4(fp)

        while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 400584c:	00000606 	br	4005868 <prvTaskCheckFreeStackSpace+0x30>
        {
            pucStackByte -= portSTACK_GROWTH;
 4005850:	e0bffe17 	ldw	r2,-8(fp)
 4005854:	10800044 	addi	r2,r2,1
 4005858:	e0bffe15 	stw	r2,-8(fp)
            ulCount++;
 400585c:	e0bfff17 	ldw	r2,-4(fp)
 4005860:	10800044 	addi	r2,r2,1
 4005864:	e0bfff15 	stw	r2,-4(fp)
        while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 4005868:	e0bffe17 	ldw	r2,-8(fp)
 400586c:	10800003 	ldbu	r2,0(r2)
 4005870:	10803fcc 	andi	r2,r2,255
 4005874:	10802960 	cmpeqi	r2,r2,165
 4005878:	103ff51e 	bne	r2,zero,4005850 <prvTaskCheckFreeStackSpace+0x18>
        }

        ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
 400587c:	e0bfff17 	ldw	r2,-4(fp)
 4005880:	1004d0ba 	srli	r2,r2,2
 4005884:	e0bfff15 	stw	r2,-4(fp)

        return ( configSTACK_DEPTH_TYPE ) ulCount;
 4005888:	e0bfff17 	ldw	r2,-4(fp)
    }
 400588c:	e037883a 	mov	sp,fp
 4005890:	df000017 	ldw	fp,0(sp)
 4005894:	dec00104 	addi	sp,sp,4
 4005898:	f800283a 	ret

0400589c <uxTaskGetStackHighWaterMark>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

    UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
    {
 400589c:	defffa04 	addi	sp,sp,-24
 40058a0:	dfc00515 	stw	ra,20(sp)
 40058a4:	df000415 	stw	fp,16(sp)
 40058a8:	df000404 	addi	fp,sp,16
 40058ac:	e13ffc15 	stw	r4,-16(fp)
        TCB_t * pxTCB;
        uint8_t * pucEndOfStack;
        UBaseType_t uxReturn;

        pxTCB = prvGetTCBFromHandle( xTask );
 40058b0:	e0bffc17 	ldw	r2,-16(fp)
 40058b4:	1000021e 	bne	r2,zero,40058c0 <uxTaskGetStackHighWaterMark+0x24>
 40058b8:	d0a71317 	ldw	r2,-25524(gp)
 40058bc:	00000106 	br	40058c4 <uxTaskGetStackHighWaterMark+0x28>
 40058c0:	e0bffc17 	ldw	r2,-16(fp)
 40058c4:	e0bfff15 	stw	r2,-4(fp)

        #if portSTACK_GROWTH < 0
        {
            pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
 40058c8:	e0bfff17 	ldw	r2,-4(fp)
 40058cc:	10800c17 	ldw	r2,48(r2)
 40058d0:	e0bffe15 	stw	r2,-8(fp)
        {
            pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
        }
        #endif

        uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
 40058d4:	e13ffe17 	ldw	r4,-8(fp)
 40058d8:	40058380 	call	4005838 <prvTaskCheckFreeStackSpace>
 40058dc:	10bfffcc 	andi	r2,r2,65535
 40058e0:	e0bffd15 	stw	r2,-12(fp)

        return uxReturn;
 40058e4:	e0bffd17 	ldw	r2,-12(fp)
    }
 40058e8:	e037883a 	mov	sp,fp
 40058ec:	dfc00117 	ldw	ra,4(sp)
 40058f0:	df000017 	ldw	fp,0(sp)
 40058f4:	dec00204 	addi	sp,sp,8
 40058f8:	f800283a 	ret

040058fc <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
 40058fc:	defffd04 	addi	sp,sp,-12
 4005900:	dfc00215 	stw	ra,8(sp)
 4005904:	df000115 	stw	fp,4(sp)
 4005908:	df000104 	addi	fp,sp,4
 400590c:	e13fff15 	stw	r4,-4(fp)

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
        {
            /* The task can only have been allocated dynamically - free both
             * the stack and TCB. */
            vPortFreeStack( pxTCB->pxStack );
 4005910:	e0bfff17 	ldw	r2,-4(fp)
 4005914:	10800c17 	ldw	r2,48(r2)
 4005918:	1009883a 	mov	r4,r2
 400591c:	400111c0 	call	400111c <vPortFree>
            vPortFree( pxTCB );
 4005920:	e13fff17 	ldw	r4,-4(fp)
 4005924:	400111c0 	call	400111c <vPortFree>
                configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                mtCOVERAGE_TEST_MARKER();
            }
        }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
 4005928:	0001883a 	nop
 400592c:	e037883a 	mov	sp,fp
 4005930:	dfc00117 	ldw	ra,4(sp)
 4005934:	df000017 	ldw	fp,0(sp)
 4005938:	dec00204 	addi	sp,sp,8
 400593c:	f800283a 	ret

04005940 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
 4005940:	deffff04 	addi	sp,sp,-4
 4005944:	df000015 	stw	fp,0(sp)
 4005948:	d839883a 	mov	fp,sp
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 400594c:	d0a71417 	ldw	r2,-25520(gp)
 4005950:	10800017 	ldw	r2,0(r2)
 4005954:	1000031e 	bne	r2,zero,4005964 <prvResetNextTaskUnblockTime+0x24>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
 4005958:	00bfffc4 	movi	r2,-1
 400595c:	d0a71f15 	stw	r2,-25476(gp)
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    }
}
 4005960:	00000406 	br	4005974 <prvResetNextTaskUnblockTime+0x34>
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
 4005964:	d0a71417 	ldw	r2,-25520(gp)
 4005968:	10800317 	ldw	r2,12(r2)
 400596c:	10800017 	ldw	r2,0(r2)
 4005970:	d0a71f15 	stw	r2,-25476(gp)
}
 4005974:	0001883a 	nop
 4005978:	e037883a 	mov	sp,fp
 400597c:	df000017 	ldw	fp,0(sp)
 4005980:	dec00104 	addi	sp,sp,4
 4005984:	f800283a 	ret

04005988 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

    TaskHandle_t xTaskGetCurrentTaskHandle( void )
    {
 4005988:	defffe04 	addi	sp,sp,-8
 400598c:	df000115 	stw	fp,4(sp)
 4005990:	df000104 	addi	fp,sp,4
        TaskHandle_t xReturn;

        /* A critical section is not required as this is not called from
         * an interrupt and the current TCB will always be the same for any
         * individual execution thread. */
        xReturn = pxCurrentTCB;
 4005994:	d0a71317 	ldw	r2,-25524(gp)
 4005998:	e0bfff15 	stw	r2,-4(fp)

        return xReturn;
 400599c:	e0bfff17 	ldw	r2,-4(fp)
    }
 40059a0:	e037883a 	mov	sp,fp
 40059a4:	df000017 	ldw	fp,0(sp)
 40059a8:	dec00104 	addi	sp,sp,4
 40059ac:	f800283a 	ret

040059b0 <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
    {
 40059b0:	defff804 	addi	sp,sp,-32
 40059b4:	dfc00715 	stw	ra,28(sp)
 40059b8:	df000615 	stw	fp,24(sp)
 40059bc:	dc400515 	stw	r17,20(sp)
 40059c0:	dc000415 	stw	r16,16(sp)
 40059c4:	df000604 	addi	fp,sp,24
 40059c8:	e13ffa15 	stw	r4,-24(fp)
        TCB_t * const pxMutexHolderTCB = pxMutexHolder;
 40059cc:	e0bffa17 	ldw	r2,-24(fp)
 40059d0:	e0bffc15 	stw	r2,-16(fp)
        BaseType_t xReturn = pdFALSE;
 40059d4:	e03ffd15 	stw	zero,-12(fp)

        /* If the mutex was given back by an interrupt while the queue was
         * locked then the mutex holder might now be NULL.  _RB_ Is this still
         * needed as interrupts can no longer use mutexes? */
        if( pxMutexHolder != NULL )
 40059d8:	e0bffa17 	ldw	r2,-24(fp)
 40059dc:	10006e26 	beq	r2,zero,4005b98 <xTaskPriorityInherit+0x1e8>
        {
            /* If the holder of the mutex has a priority below the priority of
             * the task attempting to obtain the mutex then it will temporarily
             * inherit the priority of the task attempting to obtain the mutex. */
            if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
 40059e0:	e0bffc17 	ldw	r2,-16(fp)
 40059e4:	10c00b17 	ldw	r3,44(r2)
 40059e8:	d0a71317 	ldw	r2,-25524(gp)
 40059ec:	10800b17 	ldw	r2,44(r2)
 40059f0:	1880622e 	bgeu	r3,r2,4005b7c <xTaskPriorityInherit+0x1cc>
            {
                /* Adjust the mutex holder state to account for its new
                 * priority.  Only reset the event list item value if the value is
                 * not being used for anything else. */
                if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 40059f4:	e0bffc17 	ldw	r2,-16(fp)
 40059f8:	10800617 	ldw	r2,24(r2)
 40059fc:	10000616 	blt	r2,zero,4005a18 <xTaskPriorityInherit+0x68>
                {
                    listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 4005a00:	d0a71317 	ldw	r2,-25524(gp)
 4005a04:	10800b17 	ldw	r2,44(r2)
 4005a08:	00c00144 	movi	r3,5
 4005a0c:	1887c83a 	sub	r3,r3,r2
 4005a10:	e0bffc17 	ldw	r2,-16(fp)
 4005a14:	10c00615 	stw	r3,24(r2)
                    mtCOVERAGE_TEST_MARKER();
                }

                /* If the task being modified is in the ready state it will need
                 * to be moved into a new list. */
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 4005a18:	e0bffc17 	ldw	r2,-16(fp)
 4005a1c:	14000517 	ldw	r16,20(r2)
 4005a20:	e0bffc17 	ldw	r2,-16(fp)
 4005a24:	10800b17 	ldw	r2,44(r2)
 4005a28:	01400504 	movi	r5,20
 4005a2c:	1009883a 	mov	r4,r2
 4005a30:	40072d80 	call	40072d8 <__mulsi3>
 4005a34:	1007883a 	mov	r3,r2
 4005a38:	008120b4 	movhi	r2,1154
 4005a3c:	10baaf04 	addi	r2,r2,-5444
 4005a40:	1885883a 	add	r2,r3,r2
 4005a44:	8080461e 	bne	r16,r2,4005b60 <xTaskPriorityInherit+0x1b0>
                {
                    if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4005a48:	e0bffc17 	ldw	r2,-16(fp)
 4005a4c:	10800104 	addi	r2,r2,4
 4005a50:	1009883a 	mov	r4,r2
 4005a54:	4000c980 	call	4000c98 <uxListRemove>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Inherit the priority before being moved into the new list. */
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 4005a58:	d0a71317 	ldw	r2,-25524(gp)
 4005a5c:	10c00b17 	ldw	r3,44(r2)
 4005a60:	e0bffc17 	ldw	r2,-16(fp)
 4005a64:	10c00b15 	stw	r3,44(r2)
                    prvAddTaskToReadyList( pxMutexHolderTCB );
 4005a68:	e0bffc17 	ldw	r2,-16(fp)
 4005a6c:	10800b17 	ldw	r2,44(r2)
 4005a70:	d0e71917 	ldw	r3,-25500(gp)
 4005a74:	1880032e 	bgeu	r3,r2,4005a84 <xTaskPriorityInherit+0xd4>
 4005a78:	e0bffc17 	ldw	r2,-16(fp)
 4005a7c:	10800b17 	ldw	r2,44(r2)
 4005a80:	d0a71915 	stw	r2,-25500(gp)
 4005a84:	e0bffc17 	ldw	r2,-16(fp)
 4005a88:	10800b17 	ldw	r2,44(r2)
 4005a8c:	01400504 	movi	r5,20
 4005a90:	1009883a 	mov	r4,r2
 4005a94:	40072d80 	call	40072d8 <__mulsi3>
 4005a98:	1007883a 	mov	r3,r2
 4005a9c:	008120b4 	movhi	r2,1154
 4005aa0:	1885883a 	add	r2,r3,r2
 4005aa4:	10bab017 	ldw	r2,-5440(r2)
 4005aa8:	e0bffb15 	stw	r2,-20(fp)
 4005aac:	e0bffc17 	ldw	r2,-16(fp)
 4005ab0:	e0fffb17 	ldw	r3,-20(fp)
 4005ab4:	10c00215 	stw	r3,8(r2)
 4005ab8:	e0bffb17 	ldw	r2,-20(fp)
 4005abc:	10c00217 	ldw	r3,8(r2)
 4005ac0:	e0bffc17 	ldw	r2,-16(fp)
 4005ac4:	10c00315 	stw	r3,12(r2)
 4005ac8:	e0bffb17 	ldw	r2,-20(fp)
 4005acc:	10800217 	ldw	r2,8(r2)
 4005ad0:	e0fffc17 	ldw	r3,-16(fp)
 4005ad4:	18c00104 	addi	r3,r3,4
 4005ad8:	10c00115 	stw	r3,4(r2)
 4005adc:	e0bffc17 	ldw	r2,-16(fp)
 4005ae0:	10c00104 	addi	r3,r2,4
 4005ae4:	e0bffb17 	ldw	r2,-20(fp)
 4005ae8:	10c00215 	stw	r3,8(r2)
 4005aec:	e0bffc17 	ldw	r2,-16(fp)
 4005af0:	10800b17 	ldw	r2,44(r2)
 4005af4:	01400504 	movi	r5,20
 4005af8:	1009883a 	mov	r4,r2
 4005afc:	40072d80 	call	40072d8 <__mulsi3>
 4005b00:	1007883a 	mov	r3,r2
 4005b04:	008120b4 	movhi	r2,1154
 4005b08:	10baaf04 	addi	r2,r2,-5444
 4005b0c:	1887883a 	add	r3,r3,r2
 4005b10:	e0bffc17 	ldw	r2,-16(fp)
 4005b14:	10c00515 	stw	r3,20(r2)
 4005b18:	e0bffc17 	ldw	r2,-16(fp)
 4005b1c:	14400b17 	ldw	r17,44(r2)
 4005b20:	01400504 	movi	r5,20
 4005b24:	8809883a 	mov	r4,r17
 4005b28:	40072d80 	call	40072d8 <__mulsi3>
 4005b2c:	1007883a 	mov	r3,r2
 4005b30:	008120b4 	movhi	r2,1154
 4005b34:	1885883a 	add	r2,r3,r2
 4005b38:	10baaf17 	ldw	r2,-5444(r2)
 4005b3c:	14000044 	addi	r16,r2,1
 4005b40:	01400504 	movi	r5,20
 4005b44:	8809883a 	mov	r4,r17
 4005b48:	40072d80 	call	40072d8 <__mulsi3>
 4005b4c:	1007883a 	mov	r3,r2
 4005b50:	008120b4 	movhi	r2,1154
 4005b54:	1885883a 	add	r2,r3,r2
 4005b58:	143aaf15 	stw	r16,-5444(r2)
 4005b5c:	00000406 	br	4005b70 <xTaskPriorityInherit+0x1c0>
                }
                else
                {
                    /* Just inherit the priority. */
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 4005b60:	d0a71317 	ldw	r2,-25524(gp)
 4005b64:	10c00b17 	ldw	r3,44(r2)
 4005b68:	e0bffc17 	ldw	r2,-16(fp)
 4005b6c:	10c00b15 	stw	r3,44(r2)
                }

                traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

                /* Inheritance occurred. */
                xReturn = pdTRUE;
 4005b70:	00800044 	movi	r2,1
 4005b74:	e0bffd15 	stw	r2,-12(fp)
 4005b78:	00000706 	br	4005b98 <xTaskPriorityInherit+0x1e8>
            }
            else
            {
                if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
 4005b7c:	e0bffc17 	ldw	r2,-16(fp)
 4005b80:	10c01017 	ldw	r3,64(r2)
 4005b84:	d0a71317 	ldw	r2,-25524(gp)
 4005b88:	10800b17 	ldw	r2,44(r2)
 4005b8c:	1880022e 	bgeu	r3,r2,4005b98 <xTaskPriorityInherit+0x1e8>
                     * current priority of the mutex holder is not lower than the
                     * priority of the task attempting to take the mutex.
                     * Therefore the mutex holder must have already inherited a
                     * priority, but inheritance would have occurred if that had
                     * not been the case. */
                    xReturn = pdTRUE;
 4005b90:	00800044 	movi	r2,1
 4005b94:	e0bffd15 	stw	r2,-12(fp)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
 4005b98:	e0bffd17 	ldw	r2,-12(fp)
    }
 4005b9c:	e6fffe04 	addi	sp,fp,-8
 4005ba0:	dfc00317 	ldw	ra,12(sp)
 4005ba4:	df000217 	ldw	fp,8(sp)
 4005ba8:	dc400117 	ldw	r17,4(sp)
 4005bac:	dc000017 	ldw	r16,0(sp)
 4005bb0:	dec00404 	addi	sp,sp,16
 4005bb4:	f800283a 	ret

04005bb8 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
 4005bb8:	defff804 	addi	sp,sp,-32
 4005bbc:	dfc00715 	stw	ra,28(sp)
 4005bc0:	df000615 	stw	fp,24(sp)
 4005bc4:	dc400515 	stw	r17,20(sp)
 4005bc8:	dc000415 	stw	r16,16(sp)
 4005bcc:	df000604 	addi	fp,sp,24
 4005bd0:	e13ffa15 	stw	r4,-24(fp)
        TCB_t * const pxTCB = pxMutexHolder;
 4005bd4:	e0bffa17 	ldw	r2,-24(fp)
 4005bd8:	e0bffc15 	stw	r2,-16(fp)
        BaseType_t xReturn = pdFALSE;
 4005bdc:	e03ffd15 	stw	zero,-12(fp)

        if( pxMutexHolder != NULL )
 4005be0:	e0bffa17 	ldw	r2,-24(fp)
 4005be4:	10005a26 	beq	r2,zero,4005d50 <xTaskPriorityDisinherit+0x198>
             * If the mutex is held by a task then it cannot be given from an
             * interrupt, and if a mutex is given by the holding task then it must
             * be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
            configASSERT( pxTCB->uxMutexesHeld );
            ( pxTCB->uxMutexesHeld )--;
 4005be8:	e0bffc17 	ldw	r2,-16(fp)
 4005bec:	10801117 	ldw	r2,68(r2)
 4005bf0:	10ffffc4 	addi	r3,r2,-1
 4005bf4:	e0bffc17 	ldw	r2,-16(fp)
 4005bf8:	10c01115 	stw	r3,68(r2)

            /* Has the holder of the mutex inherited the priority of another
             * task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 4005bfc:	e0bffc17 	ldw	r2,-16(fp)
 4005c00:	10c00b17 	ldw	r3,44(r2)
 4005c04:	e0bffc17 	ldw	r2,-16(fp)
 4005c08:	10801017 	ldw	r2,64(r2)
 4005c0c:	18805026 	beq	r3,r2,4005d50 <xTaskPriorityDisinherit+0x198>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 4005c10:	e0bffc17 	ldw	r2,-16(fp)
 4005c14:	10801117 	ldw	r2,68(r2)
 4005c18:	10004d1e 	bne	r2,zero,4005d50 <xTaskPriorityDisinherit+0x198>
                    /* A task can only have an inherited priority if it holds
                     * the mutex.  If the mutex is held by a task then it cannot be
                     * given from an interrupt, and if a mutex is given by the
                     * holding task then it must be the running state task.  Remove
                     * the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4005c1c:	e0bffc17 	ldw	r2,-16(fp)
 4005c20:	10800104 	addi	r2,r2,4
 4005c24:	1009883a 	mov	r4,r2
 4005c28:	4000c980 	call	4000c98 <uxListRemove>
                    }

                    /* Disinherit the priority before adding the task into the
                     * new  ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
 4005c2c:	e0bffc17 	ldw	r2,-16(fp)
 4005c30:	10c01017 	ldw	r3,64(r2)
 4005c34:	e0bffc17 	ldw	r2,-16(fp)
 4005c38:	10c00b15 	stw	r3,44(r2)

                    /* Reset the event list item value.  It cannot be in use for
                     * any other purpose if this task is running, and it must be
                     * running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 4005c3c:	e0bffc17 	ldw	r2,-16(fp)
 4005c40:	10800b17 	ldw	r2,44(r2)
 4005c44:	00c00144 	movi	r3,5
 4005c48:	1887c83a 	sub	r3,r3,r2
 4005c4c:	e0bffc17 	ldw	r2,-16(fp)
 4005c50:	10c00615 	stw	r3,24(r2)
                    prvAddTaskToReadyList( pxTCB );
 4005c54:	e0bffc17 	ldw	r2,-16(fp)
 4005c58:	10800b17 	ldw	r2,44(r2)
 4005c5c:	d0e71917 	ldw	r3,-25500(gp)
 4005c60:	1880032e 	bgeu	r3,r2,4005c70 <xTaskPriorityDisinherit+0xb8>
 4005c64:	e0bffc17 	ldw	r2,-16(fp)
 4005c68:	10800b17 	ldw	r2,44(r2)
 4005c6c:	d0a71915 	stw	r2,-25500(gp)
 4005c70:	e0bffc17 	ldw	r2,-16(fp)
 4005c74:	10800b17 	ldw	r2,44(r2)
 4005c78:	01400504 	movi	r5,20
 4005c7c:	1009883a 	mov	r4,r2
 4005c80:	40072d80 	call	40072d8 <__mulsi3>
 4005c84:	1007883a 	mov	r3,r2
 4005c88:	008120b4 	movhi	r2,1154
 4005c8c:	1885883a 	add	r2,r3,r2
 4005c90:	10bab017 	ldw	r2,-5440(r2)
 4005c94:	e0bffb15 	stw	r2,-20(fp)
 4005c98:	e0bffc17 	ldw	r2,-16(fp)
 4005c9c:	e0fffb17 	ldw	r3,-20(fp)
 4005ca0:	10c00215 	stw	r3,8(r2)
 4005ca4:	e0bffb17 	ldw	r2,-20(fp)
 4005ca8:	10c00217 	ldw	r3,8(r2)
 4005cac:	e0bffc17 	ldw	r2,-16(fp)
 4005cb0:	10c00315 	stw	r3,12(r2)
 4005cb4:	e0bffb17 	ldw	r2,-20(fp)
 4005cb8:	10800217 	ldw	r2,8(r2)
 4005cbc:	e0fffc17 	ldw	r3,-16(fp)
 4005cc0:	18c00104 	addi	r3,r3,4
 4005cc4:	10c00115 	stw	r3,4(r2)
 4005cc8:	e0bffc17 	ldw	r2,-16(fp)
 4005ccc:	10c00104 	addi	r3,r2,4
 4005cd0:	e0bffb17 	ldw	r2,-20(fp)
 4005cd4:	10c00215 	stw	r3,8(r2)
 4005cd8:	e0bffc17 	ldw	r2,-16(fp)
 4005cdc:	10800b17 	ldw	r2,44(r2)
 4005ce0:	01400504 	movi	r5,20
 4005ce4:	1009883a 	mov	r4,r2
 4005ce8:	40072d80 	call	40072d8 <__mulsi3>
 4005cec:	1007883a 	mov	r3,r2
 4005cf0:	008120b4 	movhi	r2,1154
 4005cf4:	10baaf04 	addi	r2,r2,-5444
 4005cf8:	1887883a 	add	r3,r3,r2
 4005cfc:	e0bffc17 	ldw	r2,-16(fp)
 4005d00:	10c00515 	stw	r3,20(r2)
 4005d04:	e0bffc17 	ldw	r2,-16(fp)
 4005d08:	14400b17 	ldw	r17,44(r2)
 4005d0c:	01400504 	movi	r5,20
 4005d10:	8809883a 	mov	r4,r17
 4005d14:	40072d80 	call	40072d8 <__mulsi3>
 4005d18:	1007883a 	mov	r3,r2
 4005d1c:	008120b4 	movhi	r2,1154
 4005d20:	1885883a 	add	r2,r3,r2
 4005d24:	10baaf17 	ldw	r2,-5444(r2)
 4005d28:	14000044 	addi	r16,r2,1
 4005d2c:	01400504 	movi	r5,20
 4005d30:	8809883a 	mov	r4,r17
 4005d34:	40072d80 	call	40072d8 <__mulsi3>
 4005d38:	1007883a 	mov	r3,r2
 4005d3c:	008120b4 	movhi	r2,1154
 4005d40:	1885883a 	add	r2,r3,r2
 4005d44:	143aaf15 	stw	r16,-5444(r2)
                     * in an order different to that in which they were taken.
                     * If a context switch did not occur when the first mutex was
                     * returned, even if a task was waiting on it, then a context
                     * switch should occur when the last mutex is returned whether
                     * a task is waiting on it or not. */
                    xReturn = pdTRUE;
 4005d48:	00800044 	movi	r2,1
 4005d4c:	e0bffd15 	stw	r2,-12(fp)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
 4005d50:	e0bffd17 	ldw	r2,-12(fp)
    }
 4005d54:	e6fffe04 	addi	sp,fp,-8
 4005d58:	dfc00317 	ldw	ra,12(sp)
 4005d5c:	df000217 	ldw	fp,8(sp)
 4005d60:	dc400117 	ldw	r17,4(sp)
 4005d64:	dc000017 	ldw	r16,0(sp)
 4005d68:	dec00404 	addi	sp,sp,16
 4005d6c:	f800283a 	ret

04005d70 <vTaskPriorityDisinheritAfterTimeout>:

#if ( configUSE_MUTEXES == 1 )

    void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder,
                                              UBaseType_t uxHighestPriorityWaitingTask )
    {
 4005d70:	defff504 	addi	sp,sp,-44
 4005d74:	dfc00a15 	stw	ra,40(sp)
 4005d78:	df000915 	stw	fp,36(sp)
 4005d7c:	dc400815 	stw	r17,32(sp)
 4005d80:	dc000715 	stw	r16,28(sp)
 4005d84:	df000904 	addi	fp,sp,36
 4005d88:	e13ff815 	stw	r4,-32(fp)
 4005d8c:	e17ff715 	stw	r5,-36(fp)
        TCB_t * const pxTCB = pxMutexHolder;
 4005d90:	e0bff817 	ldw	r2,-32(fp)
 4005d94:	e0bffc15 	stw	r2,-16(fp)
        UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
        const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
 4005d98:	00800044 	movi	r2,1
 4005d9c:	e0bffb15 	stw	r2,-20(fp)

        if( pxMutexHolder != NULL )
 4005da0:	e0bff817 	ldw	r2,-32(fp)
 4005da4:	10006b26 	beq	r2,zero,4005f54 <vTaskPriorityDisinheritAfterTimeout+0x1e4>

            /* Determine the priority to which the priority of the task that
             * holds the mutex should be set.  This will be the greater of the
             * holding task's base priority and the priority of the highest
             * priority task that is waiting to obtain the mutex. */
            if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
 4005da8:	e0bffc17 	ldw	r2,-16(fp)
 4005dac:	10c01017 	ldw	r3,64(r2)
 4005db0:	e0bff717 	ldw	r2,-36(fp)
 4005db4:	1880032e 	bgeu	r3,r2,4005dc4 <vTaskPriorityDisinheritAfterTimeout+0x54>
            {
                uxPriorityToUse = uxHighestPriorityWaitingTask;
 4005db8:	e0bff717 	ldw	r2,-36(fp)
 4005dbc:	e0bffd15 	stw	r2,-12(fp)
 4005dc0:	00000306 	br	4005dd0 <vTaskPriorityDisinheritAfterTimeout+0x60>
            }
            else
            {
                uxPriorityToUse = pxTCB->uxBasePriority;
 4005dc4:	e0bffc17 	ldw	r2,-16(fp)
 4005dc8:	10801017 	ldw	r2,64(r2)
 4005dcc:	e0bffd15 	stw	r2,-12(fp)
            }

            /* Does the priority need to change? */
            if( pxTCB->uxPriority != uxPriorityToUse )
 4005dd0:	e0bffc17 	ldw	r2,-16(fp)
 4005dd4:	10800b17 	ldw	r2,44(r2)
 4005dd8:	e0fffd17 	ldw	r3,-12(fp)
 4005ddc:	18805d26 	beq	r3,r2,4005f54 <vTaskPriorityDisinheritAfterTimeout+0x1e4>
            {
                /* Only disinherit if no other mutexes are held.  This is a
                 * simplification in the priority inheritance implementation.  If
                 * the task that holds the mutex is also holding other mutexes then
                 * the other mutexes may have caused the priority inheritance. */
                if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
 4005de0:	e0bffc17 	ldw	r2,-16(fp)
 4005de4:	10801117 	ldw	r2,68(r2)
 4005de8:	e0fffb17 	ldw	r3,-20(fp)
 4005dec:	1880591e 	bne	r3,r2,4005f54 <vTaskPriorityDisinheritAfterTimeout+0x1e4>

                    /* Disinherit the priority, remembering the previous
                     * priority to facilitate determining the subject task's
                     * state. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, uxPriorityToUse );
                    uxPriorityUsedOnEntry = pxTCB->uxPriority;
 4005df0:	e0bffc17 	ldw	r2,-16(fp)
 4005df4:	10800b17 	ldw	r2,44(r2)
 4005df8:	e0bffa15 	stw	r2,-24(fp)
                    pxTCB->uxPriority = uxPriorityToUse;
 4005dfc:	e0bffc17 	ldw	r2,-16(fp)
 4005e00:	e0fffd17 	ldw	r3,-12(fp)
 4005e04:	10c00b15 	stw	r3,44(r2)

                    /* Only reset the event list item value if the value is not
                     * being used for anything else. */
                    if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 4005e08:	e0bffc17 	ldw	r2,-16(fp)
 4005e0c:	10800617 	ldw	r2,24(r2)
 4005e10:	10000516 	blt	r2,zero,4005e28 <vTaskPriorityDisinheritAfterTimeout+0xb8>
                    {
                        listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 4005e14:	00c00144 	movi	r3,5
 4005e18:	e0bffd17 	ldw	r2,-12(fp)
 4005e1c:	1887c83a 	sub	r3,r3,r2
 4005e20:	e0bffc17 	ldw	r2,-16(fp)
 4005e24:	10c00615 	stw	r3,24(r2)
                     * then the task that holds the mutex could be in either the
                     * Ready, Blocked or Suspended states.  Only remove the task
                     * from its current state list if it is in the Ready state as
                     * the task's priority is going to change and there is one
                     * Ready list per priority. */
                    if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 4005e28:	e0bffc17 	ldw	r2,-16(fp)
 4005e2c:	14000517 	ldw	r16,20(r2)
 4005e30:	01400504 	movi	r5,20
 4005e34:	e13ffa17 	ldw	r4,-24(fp)
 4005e38:	40072d80 	call	40072d8 <__mulsi3>
 4005e3c:	1007883a 	mov	r3,r2
 4005e40:	008120b4 	movhi	r2,1154
 4005e44:	10baaf04 	addi	r2,r2,-5444
 4005e48:	1885883a 	add	r2,r3,r2
 4005e4c:	8080411e 	bne	r16,r2,4005f54 <vTaskPriorityDisinheritAfterTimeout+0x1e4>
                    {
                        if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4005e50:	e0bffc17 	ldw	r2,-16(fp)
 4005e54:	10800104 	addi	r2,r2,4
 4005e58:	1009883a 	mov	r4,r2
 4005e5c:	4000c980 	call	4000c98 <uxListRemove>
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }

                        prvAddTaskToReadyList( pxTCB );
 4005e60:	e0bffc17 	ldw	r2,-16(fp)
 4005e64:	10800b17 	ldw	r2,44(r2)
 4005e68:	d0e71917 	ldw	r3,-25500(gp)
 4005e6c:	1880032e 	bgeu	r3,r2,4005e7c <vTaskPriorityDisinheritAfterTimeout+0x10c>
 4005e70:	e0bffc17 	ldw	r2,-16(fp)
 4005e74:	10800b17 	ldw	r2,44(r2)
 4005e78:	d0a71915 	stw	r2,-25500(gp)
 4005e7c:	e0bffc17 	ldw	r2,-16(fp)
 4005e80:	10800b17 	ldw	r2,44(r2)
 4005e84:	01400504 	movi	r5,20
 4005e88:	1009883a 	mov	r4,r2
 4005e8c:	40072d80 	call	40072d8 <__mulsi3>
 4005e90:	1007883a 	mov	r3,r2
 4005e94:	008120b4 	movhi	r2,1154
 4005e98:	1885883a 	add	r2,r3,r2
 4005e9c:	10bab017 	ldw	r2,-5440(r2)
 4005ea0:	e0bff915 	stw	r2,-28(fp)
 4005ea4:	e0bffc17 	ldw	r2,-16(fp)
 4005ea8:	e0fff917 	ldw	r3,-28(fp)
 4005eac:	10c00215 	stw	r3,8(r2)
 4005eb0:	e0bff917 	ldw	r2,-28(fp)
 4005eb4:	10c00217 	ldw	r3,8(r2)
 4005eb8:	e0bffc17 	ldw	r2,-16(fp)
 4005ebc:	10c00315 	stw	r3,12(r2)
 4005ec0:	e0bff917 	ldw	r2,-28(fp)
 4005ec4:	10800217 	ldw	r2,8(r2)
 4005ec8:	e0fffc17 	ldw	r3,-16(fp)
 4005ecc:	18c00104 	addi	r3,r3,4
 4005ed0:	10c00115 	stw	r3,4(r2)
 4005ed4:	e0bffc17 	ldw	r2,-16(fp)
 4005ed8:	10c00104 	addi	r3,r2,4
 4005edc:	e0bff917 	ldw	r2,-28(fp)
 4005ee0:	10c00215 	stw	r3,8(r2)
 4005ee4:	e0bffc17 	ldw	r2,-16(fp)
 4005ee8:	10800b17 	ldw	r2,44(r2)
 4005eec:	01400504 	movi	r5,20
 4005ef0:	1009883a 	mov	r4,r2
 4005ef4:	40072d80 	call	40072d8 <__mulsi3>
 4005ef8:	1007883a 	mov	r3,r2
 4005efc:	008120b4 	movhi	r2,1154
 4005f00:	10baaf04 	addi	r2,r2,-5444
 4005f04:	1887883a 	add	r3,r3,r2
 4005f08:	e0bffc17 	ldw	r2,-16(fp)
 4005f0c:	10c00515 	stw	r3,20(r2)
 4005f10:	e0bffc17 	ldw	r2,-16(fp)
 4005f14:	14400b17 	ldw	r17,44(r2)
 4005f18:	01400504 	movi	r5,20
 4005f1c:	8809883a 	mov	r4,r17
 4005f20:	40072d80 	call	40072d8 <__mulsi3>
 4005f24:	1007883a 	mov	r3,r2
 4005f28:	008120b4 	movhi	r2,1154
 4005f2c:	1885883a 	add	r2,r3,r2
 4005f30:	10baaf17 	ldw	r2,-5444(r2)
 4005f34:	14000044 	addi	r16,r2,1
 4005f38:	01400504 	movi	r5,20
 4005f3c:	8809883a 	mov	r4,r17
 4005f40:	40072d80 	call	40072d8 <__mulsi3>
 4005f44:	1007883a 	mov	r3,r2
 4005f48:	008120b4 	movhi	r2,1154
 4005f4c:	1885883a 	add	r2,r3,r2
 4005f50:	143aaf15 	stw	r16,-5444(r2)
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
 4005f54:	0001883a 	nop
 4005f58:	e6fffe04 	addi	sp,fp,-8
 4005f5c:	dfc00317 	ldw	ra,12(sp)
 4005f60:	df000217 	ldw	fp,8(sp)
 4005f64:	dc400117 	ldw	r17,4(sp)
 4005f68:	dc000017 	ldw	r16,0(sp)
 4005f6c:	dec00404 	addi	sp,sp,16
 4005f70:	f800283a 	ret

04005f74 <vTaskEnterCritical>:
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

    void vTaskEnterCritical( void )
    {
 4005f74:	defffe04 	addi	sp,sp,-8
 4005f78:	df000115 	stw	fp,4(sp)
 4005f7c:	df000104 	addi	fp,sp,4
  NIOS2_READ_STATUS (context);
 4005f80:	0005303a 	rdctl	r2,status
 4005f84:	e0bfff15 	stw	r2,-4(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 4005f88:	e0ffff17 	ldw	r3,-4(fp)
 4005f8c:	00bfff84 	movi	r2,-2
 4005f90:	1884703a 	and	r2,r3,r2
 4005f94:	1001703a 	wrctl	status,r2
        portDISABLE_INTERRUPTS();

        if( xSchedulerRunning != pdFALSE )
 4005f98:	d0a71a17 	ldw	r2,-25496(gp)
 4005f9c:	10000526 	beq	r2,zero,4005fb4 <vTaskEnterCritical+0x40>
        {
            ( pxCurrentTCB->uxCriticalNesting )++;
 4005fa0:	d0a71317 	ldw	r2,-25524(gp)
 4005fa4:	10c00f17 	ldw	r3,60(r2)
 4005fa8:	18c00044 	addi	r3,r3,1
 4005fac:	10c00f15 	stw	r3,60(r2)
             * function so  assert() if it is being called from an interrupt
             * context.  Only API functions that end in "FromISR" can be used in an
             * interrupt.  Only assert if the critical nesting count is 1 to
             * protect against recursive calls if the assert function also uses a
             * critical section. */
            if( pxCurrentTCB->uxCriticalNesting == 1 )
 4005fb0:	d0a71317 	ldw	r2,-25524(gp)
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
 4005fb4:	0001883a 	nop
 4005fb8:	e037883a 	mov	sp,fp
 4005fbc:	df000017 	ldw	fp,0(sp)
 4005fc0:	dec00104 	addi	sp,sp,4
 4005fc4:	f800283a 	ret

04005fc8 <vTaskExitCritical>:
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

    void vTaskExitCritical( void )
    {
 4005fc8:	defffe04 	addi	sp,sp,-8
 4005fcc:	df000115 	stw	fp,4(sp)
 4005fd0:	df000104 	addi	fp,sp,4
        if( xSchedulerRunning != pdFALSE )
 4005fd4:	d0a71a17 	ldw	r2,-25496(gp)
 4005fd8:	10000f26 	beq	r2,zero,4006018 <vTaskExitCritical+0x50>
        {
            if( pxCurrentTCB->uxCriticalNesting > 0U )
 4005fdc:	d0a71317 	ldw	r2,-25524(gp)
 4005fe0:	10800f17 	ldw	r2,60(r2)
 4005fe4:	10000c26 	beq	r2,zero,4006018 <vTaskExitCritical+0x50>
            {
                ( pxCurrentTCB->uxCriticalNesting )--;
 4005fe8:	d0a71317 	ldw	r2,-25524(gp)
 4005fec:	10c00f17 	ldw	r3,60(r2)
 4005ff0:	18ffffc4 	addi	r3,r3,-1
 4005ff4:	10c00f15 	stw	r3,60(r2)

                if( pxCurrentTCB->uxCriticalNesting == 0U )
 4005ff8:	d0a71317 	ldw	r2,-25524(gp)
 4005ffc:	10800f17 	ldw	r2,60(r2)
 4006000:	1000051e 	bne	r2,zero,4006018 <vTaskExitCritical+0x50>
 4006004:	00800044 	movi	r2,1
 4006008:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 400600c:	e0bfff17 	ldw	r2,-4(fp)
 4006010:	1001703a 	wrctl	status,r2
#endif
}
 4006014:	0001883a 	nop
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
 4006018:	0001883a 	nop
 400601c:	e037883a 	mov	sp,fp
 4006020:	df000017 	ldw	fp,0(sp)
 4006024:	dec00104 	addi	sp,sp,4
 4006028:	f800283a 	ret

0400602c <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
 400602c:	defffe04 	addi	sp,sp,-8
 4006030:	df000115 	stw	fp,4(sp)
 4006034:	df000104 	addi	fp,sp,4
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 4006038:	d0a71317 	ldw	r2,-25524(gp)
 400603c:	10800617 	ldw	r2,24(r2)
 4006040:	e0bfff15 	stw	r2,-4(fp)

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 4006044:	d0a71317 	ldw	r2,-25524(gp)
 4006048:	10c00b17 	ldw	r3,44(r2)
 400604c:	d0a71317 	ldw	r2,-25524(gp)
 4006050:	01000144 	movi	r4,5
 4006054:	20c7c83a 	sub	r3,r4,r3
 4006058:	10c00615 	stw	r3,24(r2)

    return uxReturn;
 400605c:	e0bfff17 	ldw	r2,-4(fp)
}
 4006060:	e037883a 	mov	sp,fp
 4006064:	df000017 	ldw	fp,0(sp)
 4006068:	dec00104 	addi	sp,sp,4
 400606c:	f800283a 	ret

04006070 <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    TaskHandle_t pvTaskIncrementMutexHeldCount( void )
    {
 4006070:	deffff04 	addi	sp,sp,-4
 4006074:	df000015 	stw	fp,0(sp)
 4006078:	d839883a 	mov	fp,sp
        /* If xSemaphoreCreateMutex() is called before any tasks have been created
         * then pxCurrentTCB will be NULL. */
        if( pxCurrentTCB != NULL )
 400607c:	d0a71317 	ldw	r2,-25524(gp)
 4006080:	10000426 	beq	r2,zero,4006094 <pvTaskIncrementMutexHeldCount+0x24>
        {
            ( pxCurrentTCB->uxMutexesHeld )++;
 4006084:	d0a71317 	ldw	r2,-25524(gp)
 4006088:	10c01117 	ldw	r3,68(r2)
 400608c:	18c00044 	addi	r3,r3,1
 4006090:	10c01115 	stw	r3,68(r2)
        }

        return pxCurrentTCB;
 4006094:	d0a71317 	ldw	r2,-25524(gp)
    }
 4006098:	e037883a 	mov	sp,fp
 400609c:	df000017 	ldw	fp,0(sp)
 40060a0:	dec00104 	addi	sp,sp,4
 40060a4:	f800283a 	ret

040060a8 <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
 40060a8:	defffa04 	addi	sp,sp,-24
 40060ac:	dfc00515 	stw	ra,20(sp)
 40060b0:	df000415 	stw	fp,16(sp)
 40060b4:	df000404 	addi	fp,sp,16
 40060b8:	e13ffe15 	stw	r4,-8(fp)
 40060bc:	e17ffd15 	stw	r5,-12(fp)
 40060c0:	e1bffc15 	stw	r6,-16(fp)
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
 40060c4:	4005f740 	call	4005f74 <vTaskEnterCritical>
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
 40060c8:	d0e71317 	ldw	r3,-25524(gp)
 40060cc:	e0bffe17 	ldw	r2,-8(fp)
 40060d0:	10800484 	addi	r2,r2,18
 40060d4:	100490ba 	slli	r2,r2,2
 40060d8:	1885883a 	add	r2,r3,r2
 40060dc:	10800017 	ldw	r2,0(r2)
 40060e0:	10000b1e 	bne	r2,zero,4006110 <ulTaskGenericNotifyTake+0x68>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
 40060e4:	d0e71317 	ldw	r3,-25524(gp)
 40060e8:	e0bffe17 	ldw	r2,-8(fp)
 40060ec:	1885883a 	add	r2,r3,r2
 40060f0:	00c00044 	movi	r3,1
 40060f4:	10c01305 	stb	r3,76(r2)

                if( xTicksToWait > ( TickType_t ) 0 )
 40060f8:	e0bffc17 	ldw	r2,-16(fp)
 40060fc:	10000426 	beq	r2,zero,4006110 <ulTaskGenericNotifyTake+0x68>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 4006100:	01400044 	movi	r5,1
 4006104:	e13ffc17 	ldw	r4,-16(fp)
 4006108:	4006e340 	call	4006e34 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
 400610c:	003b683a 	trap	0
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
 4006110:	4005fc80 	call	4005fc8 <vTaskExitCritical>

        taskENTER_CRITICAL();
 4006114:	4005f740 	call	4005f74 <vTaskEnterCritical>
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
 4006118:	d0e71317 	ldw	r3,-25524(gp)
 400611c:	e0bffe17 	ldw	r2,-8(fp)
 4006120:	10800484 	addi	r2,r2,18
 4006124:	100490ba 	slli	r2,r2,2
 4006128:	1885883a 	add	r2,r3,r2
 400612c:	10800017 	ldw	r2,0(r2)
 4006130:	e0bfff15 	stw	r2,-4(fp)

            if( ulReturn != 0UL )
 4006134:	e0bfff17 	ldw	r2,-4(fp)
 4006138:	10001126 	beq	r2,zero,4006180 <ulTaskGenericNotifyTake+0xd8>
            {
                if( xClearCountOnExit != pdFALSE )
 400613c:	e0bffd17 	ldw	r2,-12(fp)
 4006140:	10000726 	beq	r2,zero,4006160 <ulTaskGenericNotifyTake+0xb8>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
 4006144:	d0e71317 	ldw	r3,-25524(gp)
 4006148:	e0bffe17 	ldw	r2,-8(fp)
 400614c:	10800484 	addi	r2,r2,18
 4006150:	100490ba 	slli	r2,r2,2
 4006154:	1885883a 	add	r2,r3,r2
 4006158:	10000015 	stw	zero,0(r2)
 400615c:	00000806 	br	4006180 <ulTaskGenericNotifyTake+0xd8>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
 4006160:	d1271317 	ldw	r4,-25524(gp)
 4006164:	e0bfff17 	ldw	r2,-4(fp)
 4006168:	10ffffc4 	addi	r3,r2,-1
 400616c:	e0bffe17 	ldw	r2,-8(fp)
 4006170:	10800484 	addi	r2,r2,18
 4006174:	100490ba 	slli	r2,r2,2
 4006178:	2085883a 	add	r2,r4,r2
 400617c:	10c00015 	stw	r3,0(r2)
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
 4006180:	d0e71317 	ldw	r3,-25524(gp)
 4006184:	e0bffe17 	ldw	r2,-8(fp)
 4006188:	1885883a 	add	r2,r3,r2
 400618c:	10001305 	stb	zero,76(r2)
        }
        taskEXIT_CRITICAL();
 4006190:	4005fc80 	call	4005fc8 <vTaskExitCritical>

        return ulReturn;
 4006194:	e0bfff17 	ldw	r2,-4(fp)
    }
 4006198:	e037883a 	mov	sp,fp
 400619c:	dfc00117 	ldw	ra,4(sp)
 40061a0:	df000017 	ldw	fp,0(sp)
 40061a4:	dec00204 	addi	sp,sp,8
 40061a8:	f800283a 	ret

040061ac <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
 40061ac:	defff904 	addi	sp,sp,-28
 40061b0:	dfc00615 	stw	ra,24(sp)
 40061b4:	df000515 	stw	fp,20(sp)
 40061b8:	df000504 	addi	fp,sp,20
 40061bc:	e13ffe15 	stw	r4,-8(fp)
 40061c0:	e17ffd15 	stw	r5,-12(fp)
 40061c4:	e1bffc15 	stw	r6,-16(fp)
 40061c8:	e1fffb15 	stw	r7,-20(fp)
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
 40061cc:	4005f740 	call	4005f74 <vTaskEnterCritical>
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
 40061d0:	d0e71317 	ldw	r3,-25524(gp)
 40061d4:	e0bffe17 	ldw	r2,-8(fp)
 40061d8:	1885883a 	add	r2,r3,r2
 40061dc:	10801303 	ldbu	r2,76(r2)
 40061e0:	10803fcc 	andi	r2,r2,255
 40061e4:	108000a0 	cmpeqi	r2,r2,2
 40061e8:	1000191e 	bne	r2,zero,4006250 <xTaskGenericNotifyWait+0xa4>
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
 40061ec:	d0a71317 	ldw	r2,-25524(gp)
 40061f0:	e0fffe17 	ldw	r3,-8(fp)
 40061f4:	18c00484 	addi	r3,r3,18
 40061f8:	180690ba 	slli	r3,r3,2
 40061fc:	10c7883a 	add	r3,r2,r3
 4006200:	19000017 	ldw	r4,0(r3)
 4006204:	e0fffd17 	ldw	r3,-12(fp)
 4006208:	00c6303a 	nor	r3,zero,r3
 400620c:	20c6703a 	and	r3,r4,r3
 4006210:	e13ffe17 	ldw	r4,-8(fp)
 4006214:	21000484 	addi	r4,r4,18
 4006218:	200890ba 	slli	r4,r4,2
 400621c:	1105883a 	add	r2,r2,r4
 4006220:	10c00015 	stw	r3,0(r2)

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
 4006224:	d0e71317 	ldw	r3,-25524(gp)
 4006228:	e0bffe17 	ldw	r2,-8(fp)
 400622c:	1885883a 	add	r2,r3,r2
 4006230:	00c00044 	movi	r3,1
 4006234:	10c01305 	stb	r3,76(r2)

                if( xTicksToWait > ( TickType_t ) 0 )
 4006238:	e0800217 	ldw	r2,8(fp)
 400623c:	10000426 	beq	r2,zero,4006250 <xTaskGenericNotifyWait+0xa4>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 4006240:	01400044 	movi	r5,1
 4006244:	e1000217 	ldw	r4,8(fp)
 4006248:	4006e340 	call	4006e34 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
 400624c:	003b683a 	trap	0
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
 4006250:	4005fc80 	call	4005fc8 <vTaskExitCritical>

        taskENTER_CRITICAL();
 4006254:	4005f740 	call	4005f74 <vTaskEnterCritical>
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
 4006258:	e0bffb17 	ldw	r2,-20(fp)
 400625c:	10000826 	beq	r2,zero,4006280 <xTaskGenericNotifyWait+0xd4>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
 4006260:	d0e71317 	ldw	r3,-25524(gp)
 4006264:	e0bffe17 	ldw	r2,-8(fp)
 4006268:	10800484 	addi	r2,r2,18
 400626c:	100490ba 	slli	r2,r2,2
 4006270:	1885883a 	add	r2,r3,r2
 4006274:	10c00017 	ldw	r3,0(r2)
 4006278:	e0bffb17 	ldw	r2,-20(fp)
 400627c:	10c00015 	stw	r3,0(r2)

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
 4006280:	d0e71317 	ldw	r3,-25524(gp)
 4006284:	e0bffe17 	ldw	r2,-8(fp)
 4006288:	1885883a 	add	r2,r3,r2
 400628c:	10801303 	ldbu	r2,76(r2)
 4006290:	10803fcc 	andi	r2,r2,255
 4006294:	108000a0 	cmpeqi	r2,r2,2
 4006298:	1000021e 	bne	r2,zero,40062a4 <xTaskGenericNotifyWait+0xf8>
            {
                /* A notification was not received. */
                xReturn = pdFALSE;
 400629c:	e03fff15 	stw	zero,-4(fp)
 40062a0:	00001006 	br	40062e4 <xTaskGenericNotifyWait+0x138>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
 40062a4:	d0a71317 	ldw	r2,-25524(gp)
 40062a8:	e0fffe17 	ldw	r3,-8(fp)
 40062ac:	18c00484 	addi	r3,r3,18
 40062b0:	180690ba 	slli	r3,r3,2
 40062b4:	10c7883a 	add	r3,r2,r3
 40062b8:	19000017 	ldw	r4,0(r3)
 40062bc:	e0fffc17 	ldw	r3,-16(fp)
 40062c0:	00c6303a 	nor	r3,zero,r3
 40062c4:	20c6703a 	and	r3,r4,r3
 40062c8:	e13ffe17 	ldw	r4,-8(fp)
 40062cc:	21000484 	addi	r4,r4,18
 40062d0:	200890ba 	slli	r4,r4,2
 40062d4:	1105883a 	add	r2,r2,r4
 40062d8:	10c00015 	stw	r3,0(r2)
                xReturn = pdTRUE;
 40062dc:	00800044 	movi	r2,1
 40062e0:	e0bfff15 	stw	r2,-4(fp)
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
 40062e4:	d0e71317 	ldw	r3,-25524(gp)
 40062e8:	e0bffe17 	ldw	r2,-8(fp)
 40062ec:	1885883a 	add	r2,r3,r2
 40062f0:	10001305 	stb	zero,76(r2)
        }
        taskEXIT_CRITICAL();
 40062f4:	4005fc80 	call	4005fc8 <vTaskExitCritical>

        return xReturn;
 40062f8:	e0bfff17 	ldw	r2,-4(fp)
    }
 40062fc:	e037883a 	mov	sp,fp
 4006300:	dfc00117 	ldw	ra,4(sp)
 4006304:	df000017 	ldw	fp,0(sp)
 4006308:	dec00204 	addi	sp,sp,8
 400630c:	f800283a 	ret

04006310 <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
 4006310:	defff304 	addi	sp,sp,-52
 4006314:	dfc00c15 	stw	ra,48(sp)
 4006318:	df000b15 	stw	fp,44(sp)
 400631c:	dc400a15 	stw	r17,40(sp)
 4006320:	dc000915 	stw	r16,36(sp)
 4006324:	df000b04 	addi	fp,sp,44
 4006328:	e13ff815 	stw	r4,-32(fp)
 400632c:	e17ff715 	stw	r5,-36(fp)
 4006330:	e1bff615 	stw	r6,-40(fp)
 4006334:	e1fff515 	stw	r7,-44(fp)
        TCB_t * pxTCB;
        BaseType_t xReturn = pdPASS;
 4006338:	00800044 	movi	r2,1
 400633c:	e0bffd15 	stw	r2,-12(fp)
        uint8_t ucOriginalNotifyState;

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;
 4006340:	e0bff817 	ldw	r2,-32(fp)
 4006344:	e0bffc15 	stw	r2,-16(fp)

        taskENTER_CRITICAL();
 4006348:	4005f740 	call	4005f74 <vTaskEnterCritical>
        {
            if( pulPreviousNotificationValue != NULL )
 400634c:	e0800217 	ldw	r2,8(fp)
 4006350:	10000826 	beq	r2,zero,4006374 <xTaskGenericNotify+0x64>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
 4006354:	e0fffc17 	ldw	r3,-16(fp)
 4006358:	e0bff717 	ldw	r2,-36(fp)
 400635c:	10800484 	addi	r2,r2,18
 4006360:	100490ba 	slli	r2,r2,2
 4006364:	1885883a 	add	r2,r3,r2
 4006368:	10c00017 	ldw	r3,0(r2)
 400636c:	e0800217 	ldw	r2,8(fp)
 4006370:	10c00015 	stw	r3,0(r2)
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 4006374:	e0fffc17 	ldw	r3,-16(fp)
 4006378:	e0bff717 	ldw	r2,-36(fp)
 400637c:	1885883a 	add	r2,r3,r2
 4006380:	10801303 	ldbu	r2,76(r2)
 4006384:	e0bffbc5 	stb	r2,-17(fp)

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 4006388:	e0fffc17 	ldw	r3,-16(fp)
 400638c:	e0bff717 	ldw	r2,-36(fp)
 4006390:	1885883a 	add	r2,r3,r2
 4006394:	00c00084 	movi	r3,2
 4006398:	10c01305 	stb	r3,76(r2)
 400639c:	e0bff517 	ldw	r2,-44(fp)
 40063a0:	10800168 	cmpgeui	r2,r2,5
 40063a4:	10003d1e 	bne	r2,zero,400649c <xTaskGenericNotify+0x18c>
 40063a8:	e0bff517 	ldw	r2,-44(fp)
 40063ac:	100690ba 	slli	r3,r2,2
 40063b0:	00810034 	movhi	r2,1024
 40063b4:	1885883a 	add	r2,r3,r2
 40063b8:	1098f017 	ldw	r2,25536(r2)
 40063bc:	1000683a 	jmp	r2
 40063c0:	040064a4 	muli	r16,zero,402
 40063c4:	040063d4 	movui	r16,399
 40063c8:	04006410 	cmplti	r16,zero,400
 40063cc:	04006448 	cmpgei	r16,zero,401
 40063d0:	04006468 	cmpgeui	r16,zero,401

            switch( eAction )
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
 40063d4:	e0fffc17 	ldw	r3,-16(fp)
 40063d8:	e0bff717 	ldw	r2,-36(fp)
 40063dc:	10800484 	addi	r2,r2,18
 40063e0:	100490ba 	slli	r2,r2,2
 40063e4:	1885883a 	add	r2,r3,r2
 40063e8:	10c00017 	ldw	r3,0(r2)
 40063ec:	e0bff617 	ldw	r2,-40(fp)
 40063f0:	1886b03a 	or	r3,r3,r2
 40063f4:	e13ffc17 	ldw	r4,-16(fp)
 40063f8:	e0bff717 	ldw	r2,-36(fp)
 40063fc:	10800484 	addi	r2,r2,18
 4006400:	100490ba 	slli	r2,r2,2
 4006404:	2085883a 	add	r2,r4,r2
 4006408:	10c00015 	stw	r3,0(r2)
                    break;
 400640c:	00002606 	br	40064a8 <xTaskGenericNotify+0x198>

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
 4006410:	e0fffc17 	ldw	r3,-16(fp)
 4006414:	e0bff717 	ldw	r2,-36(fp)
 4006418:	10800484 	addi	r2,r2,18
 400641c:	100490ba 	slli	r2,r2,2
 4006420:	1885883a 	add	r2,r3,r2
 4006424:	10800017 	ldw	r2,0(r2)
 4006428:	10c00044 	addi	r3,r2,1
 400642c:	e13ffc17 	ldw	r4,-16(fp)
 4006430:	e0bff717 	ldw	r2,-36(fp)
 4006434:	10800484 	addi	r2,r2,18
 4006438:	100490ba 	slli	r2,r2,2
 400643c:	2085883a 	add	r2,r4,r2
 4006440:	10c00015 	stw	r3,0(r2)
                    break;
 4006444:	00001806 	br	40064a8 <xTaskGenericNotify+0x198>

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 4006448:	e0fffc17 	ldw	r3,-16(fp)
 400644c:	e0bff717 	ldw	r2,-36(fp)
 4006450:	10800484 	addi	r2,r2,18
 4006454:	100490ba 	slli	r2,r2,2
 4006458:	1885883a 	add	r2,r3,r2
 400645c:	e0fff617 	ldw	r3,-40(fp)
 4006460:	10c00015 	stw	r3,0(r2)
                    break;
 4006464:	00001006 	br	40064a8 <xTaskGenericNotify+0x198>

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 4006468:	e0bffbc3 	ldbu	r2,-17(fp)
 400646c:	108000a0 	cmpeqi	r2,r2,2
 4006470:	1000081e 	bne	r2,zero,4006494 <xTaskGenericNotify+0x184>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 4006474:	e0fffc17 	ldw	r3,-16(fp)
 4006478:	e0bff717 	ldw	r2,-36(fp)
 400647c:	10800484 	addi	r2,r2,18
 4006480:	100490ba 	slli	r2,r2,2
 4006484:	1885883a 	add	r2,r3,r2
 4006488:	e0fff617 	ldw	r3,-40(fp)
 400648c:	10c00015 	stw	r3,0(r2)
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
                    }

                    break;
 4006490:	00000506 	br	40064a8 <xTaskGenericNotify+0x198>
                        xReturn = pdFAIL;
 4006494:	e03ffd15 	stw	zero,-12(fp)
                    break;
 4006498:	00000306 	br	40064a8 <xTaskGenericNotify+0x198>
                    /* Should not get here if all enums are handled.
                     * Artificially force an assert by testing a value the
                     * compiler can't assume is const. */
                    configASSERT( xTickCount == ( TickType_t ) 0 );

                    break;
 400649c:	0001883a 	nop
 40064a0:	00000106 	br	40064a8 <xTaskGenericNotify+0x198>
                    break;
 40064a4:	0001883a 	nop

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 40064a8:	e0bffbc3 	ldbu	r2,-17(fp)
 40064ac:	10800058 	cmpnei	r2,r2,1
 40064b0:	1000601e 	bne	r2,zero,4006634 <xTaskGenericNotify+0x324>
            {
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 40064b4:	e0bffc17 	ldw	r2,-16(fp)
 40064b8:	10800517 	ldw	r2,20(r2)
 40064bc:	e0bffa15 	stw	r2,-24(fp)
 40064c0:	e0bffc17 	ldw	r2,-16(fp)
 40064c4:	10800217 	ldw	r2,8(r2)
 40064c8:	e0fffc17 	ldw	r3,-16(fp)
 40064cc:	18c00317 	ldw	r3,12(r3)
 40064d0:	10c00215 	stw	r3,8(r2)
 40064d4:	e0bffc17 	ldw	r2,-16(fp)
 40064d8:	10800317 	ldw	r2,12(r2)
 40064dc:	e0fffc17 	ldw	r3,-16(fp)
 40064e0:	18c00217 	ldw	r3,8(r3)
 40064e4:	10c00115 	stw	r3,4(r2)
 40064e8:	e0bffa17 	ldw	r2,-24(fp)
 40064ec:	10c00117 	ldw	r3,4(r2)
 40064f0:	e0bffc17 	ldw	r2,-16(fp)
 40064f4:	10800104 	addi	r2,r2,4
 40064f8:	1880041e 	bne	r3,r2,400650c <xTaskGenericNotify+0x1fc>
 40064fc:	e0bffc17 	ldw	r2,-16(fp)
 4006500:	10c00317 	ldw	r3,12(r2)
 4006504:	e0bffa17 	ldw	r2,-24(fp)
 4006508:	10c00115 	stw	r3,4(r2)
 400650c:	e0bffc17 	ldw	r2,-16(fp)
 4006510:	10000515 	stw	zero,20(r2)
 4006514:	e0bffa17 	ldw	r2,-24(fp)
 4006518:	10800017 	ldw	r2,0(r2)
 400651c:	10ffffc4 	addi	r3,r2,-1
 4006520:	e0bffa17 	ldw	r2,-24(fp)
 4006524:	10c00015 	stw	r3,0(r2)
                prvAddTaskToReadyList( pxTCB );
 4006528:	e0bffc17 	ldw	r2,-16(fp)
 400652c:	10800b17 	ldw	r2,44(r2)
 4006530:	d0e71917 	ldw	r3,-25500(gp)
 4006534:	1880032e 	bgeu	r3,r2,4006544 <xTaskGenericNotify+0x234>
 4006538:	e0bffc17 	ldw	r2,-16(fp)
 400653c:	10800b17 	ldw	r2,44(r2)
 4006540:	d0a71915 	stw	r2,-25500(gp)
 4006544:	e0bffc17 	ldw	r2,-16(fp)
 4006548:	10800b17 	ldw	r2,44(r2)
 400654c:	01400504 	movi	r5,20
 4006550:	1009883a 	mov	r4,r2
 4006554:	40072d80 	call	40072d8 <__mulsi3>
 4006558:	1007883a 	mov	r3,r2
 400655c:	008120b4 	movhi	r2,1154
 4006560:	1885883a 	add	r2,r3,r2
 4006564:	10bab017 	ldw	r2,-5440(r2)
 4006568:	e0bff915 	stw	r2,-28(fp)
 400656c:	e0bffc17 	ldw	r2,-16(fp)
 4006570:	e0fff917 	ldw	r3,-28(fp)
 4006574:	10c00215 	stw	r3,8(r2)
 4006578:	e0bff917 	ldw	r2,-28(fp)
 400657c:	10c00217 	ldw	r3,8(r2)
 4006580:	e0bffc17 	ldw	r2,-16(fp)
 4006584:	10c00315 	stw	r3,12(r2)
 4006588:	e0bff917 	ldw	r2,-28(fp)
 400658c:	10800217 	ldw	r2,8(r2)
 4006590:	e0fffc17 	ldw	r3,-16(fp)
 4006594:	18c00104 	addi	r3,r3,4
 4006598:	10c00115 	stw	r3,4(r2)
 400659c:	e0bffc17 	ldw	r2,-16(fp)
 40065a0:	10c00104 	addi	r3,r2,4
 40065a4:	e0bff917 	ldw	r2,-28(fp)
 40065a8:	10c00215 	stw	r3,8(r2)
 40065ac:	e0bffc17 	ldw	r2,-16(fp)
 40065b0:	10800b17 	ldw	r2,44(r2)
 40065b4:	01400504 	movi	r5,20
 40065b8:	1009883a 	mov	r4,r2
 40065bc:	40072d80 	call	40072d8 <__mulsi3>
 40065c0:	1007883a 	mov	r3,r2
 40065c4:	008120b4 	movhi	r2,1154
 40065c8:	10baaf04 	addi	r2,r2,-5444
 40065cc:	1887883a 	add	r3,r3,r2
 40065d0:	e0bffc17 	ldw	r2,-16(fp)
 40065d4:	10c00515 	stw	r3,20(r2)
 40065d8:	e0bffc17 	ldw	r2,-16(fp)
 40065dc:	14400b17 	ldw	r17,44(r2)
 40065e0:	01400504 	movi	r5,20
 40065e4:	8809883a 	mov	r4,r17
 40065e8:	40072d80 	call	40072d8 <__mulsi3>
 40065ec:	1007883a 	mov	r3,r2
 40065f0:	008120b4 	movhi	r2,1154
 40065f4:	1885883a 	add	r2,r3,r2
 40065f8:	10baaf17 	ldw	r2,-5444(r2)
 40065fc:	14000044 	addi	r16,r2,1
 4006600:	01400504 	movi	r5,20
 4006604:	8809883a 	mov	r4,r17
 4006608:	40072d80 	call	40072d8 <__mulsi3>
 400660c:	1007883a 	mov	r3,r2
 4006610:	008120b4 	movhi	r2,1154
 4006614:	1885883a 	add	r2,r3,r2
 4006618:	143aaf15 	stw	r16,-5444(r2)
                     * earliest possible time. */
                    prvResetNextTaskUnblockTime();
                }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 400661c:	e0bffc17 	ldw	r2,-16(fp)
 4006620:	10800b17 	ldw	r2,44(r2)
 4006624:	d0e71317 	ldw	r3,-25524(gp)
 4006628:	18c00b17 	ldw	r3,44(r3)
 400662c:	1880012e 	bgeu	r3,r2,4006634 <xTaskGenericNotify+0x324>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
 4006630:	003b683a 	trap	0
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
 4006634:	4005fc80 	call	4005fc8 <vTaskExitCritical>

        return xReturn;
 4006638:	e0bffd17 	ldw	r2,-12(fp)
    }
 400663c:	e6fffe04 	addi	sp,fp,-8
 4006640:	dfc00317 	ldw	ra,12(sp)
 4006644:	df000217 	ldw	fp,8(sp)
 4006648:	dc400117 	ldw	r17,4(sp)
 400664c:	dc000017 	ldw	r16,0(sp)
 4006650:	dec00404 	addi	sp,sp,16
 4006654:	f800283a 	ret

04006658 <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
 4006658:	defff104 	addi	sp,sp,-60
 400665c:	dfc00e15 	stw	ra,56(sp)
 4006660:	df000d15 	stw	fp,52(sp)
 4006664:	dc400c15 	stw	r17,48(sp)
 4006668:	dc000b15 	stw	r16,44(sp)
 400666c:	df000d04 	addi	fp,sp,52
 4006670:	e13ff615 	stw	r4,-40(fp)
 4006674:	e17ff515 	stw	r5,-44(fp)
 4006678:	e1bff415 	stw	r6,-48(fp)
 400667c:	e1fff315 	stw	r7,-52(fp)
        TCB_t * pxTCB;
        uint8_t ucOriginalNotifyState;
        BaseType_t xReturn = pdPASS;
 4006680:	00800044 	movi	r2,1
 4006684:	e0bffd15 	stw	r2,-12(fp)
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
 4006688:	e0bff617 	ldw	r2,-40(fp)
 400668c:	e0bffc15 	stw	r2,-16(fp)

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4006690:	e03ffb15 	stw	zero,-20(fp)
        {
            if( pulPreviousNotificationValue != NULL )
 4006694:	e0800217 	ldw	r2,8(fp)
 4006698:	10000826 	beq	r2,zero,40066bc <xTaskGenericNotifyFromISR+0x64>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
 400669c:	e0fffc17 	ldw	r3,-16(fp)
 40066a0:	e0bff517 	ldw	r2,-44(fp)
 40066a4:	10800484 	addi	r2,r2,18
 40066a8:	100490ba 	slli	r2,r2,2
 40066ac:	1885883a 	add	r2,r3,r2
 40066b0:	10c00017 	ldw	r3,0(r2)
 40066b4:	e0800217 	ldw	r2,8(fp)
 40066b8:	10c00015 	stw	r3,0(r2)
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 40066bc:	e0fffc17 	ldw	r3,-16(fp)
 40066c0:	e0bff517 	ldw	r2,-44(fp)
 40066c4:	1885883a 	add	r2,r3,r2
 40066c8:	10801303 	ldbu	r2,76(r2)
 40066cc:	e0bffac5 	stb	r2,-21(fp)
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 40066d0:	e0fffc17 	ldw	r3,-16(fp)
 40066d4:	e0bff517 	ldw	r2,-44(fp)
 40066d8:	1885883a 	add	r2,r3,r2
 40066dc:	00c00084 	movi	r3,2
 40066e0:	10c01305 	stb	r3,76(r2)
 40066e4:	e0bff317 	ldw	r2,-52(fp)
 40066e8:	10800168 	cmpgeui	r2,r2,5
 40066ec:	10003d1e 	bne	r2,zero,40067e4 <xTaskGenericNotifyFromISR+0x18c>
 40066f0:	e0bff317 	ldw	r2,-52(fp)
 40066f4:	100690ba 	slli	r3,r2,2
 40066f8:	00810034 	movhi	r2,1024
 40066fc:	1885883a 	add	r2,r3,r2
 4006700:	1099c217 	ldw	r2,26376(r2)
 4006704:	1000683a 	jmp	r2
 4006708:	040067ec 	andhi	r16,zero,415
 400670c:	0400671c 	xori	r16,zero,412
 4006710:	04006758 	cmpnei	r16,zero,413
 4006714:	04006790 	cmplti	r16,zero,414
 4006718:	040067b0 	cmpltui	r16,zero,414

            switch( eAction )
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
 400671c:	e0fffc17 	ldw	r3,-16(fp)
 4006720:	e0bff517 	ldw	r2,-44(fp)
 4006724:	10800484 	addi	r2,r2,18
 4006728:	100490ba 	slli	r2,r2,2
 400672c:	1885883a 	add	r2,r3,r2
 4006730:	10c00017 	ldw	r3,0(r2)
 4006734:	e0bff417 	ldw	r2,-48(fp)
 4006738:	1886b03a 	or	r3,r3,r2
 400673c:	e13ffc17 	ldw	r4,-16(fp)
 4006740:	e0bff517 	ldw	r2,-44(fp)
 4006744:	10800484 	addi	r2,r2,18
 4006748:	100490ba 	slli	r2,r2,2
 400674c:	2085883a 	add	r2,r4,r2
 4006750:	10c00015 	stw	r3,0(r2)
                    break;
 4006754:	00002606 	br	40067f0 <xTaskGenericNotifyFromISR+0x198>

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
 4006758:	e0fffc17 	ldw	r3,-16(fp)
 400675c:	e0bff517 	ldw	r2,-44(fp)
 4006760:	10800484 	addi	r2,r2,18
 4006764:	100490ba 	slli	r2,r2,2
 4006768:	1885883a 	add	r2,r3,r2
 400676c:	10800017 	ldw	r2,0(r2)
 4006770:	10c00044 	addi	r3,r2,1
 4006774:	e13ffc17 	ldw	r4,-16(fp)
 4006778:	e0bff517 	ldw	r2,-44(fp)
 400677c:	10800484 	addi	r2,r2,18
 4006780:	100490ba 	slli	r2,r2,2
 4006784:	2085883a 	add	r2,r4,r2
 4006788:	10c00015 	stw	r3,0(r2)
                    break;
 400678c:	00001806 	br	40067f0 <xTaskGenericNotifyFromISR+0x198>

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 4006790:	e0fffc17 	ldw	r3,-16(fp)
 4006794:	e0bff517 	ldw	r2,-44(fp)
 4006798:	10800484 	addi	r2,r2,18
 400679c:	100490ba 	slli	r2,r2,2
 40067a0:	1885883a 	add	r2,r3,r2
 40067a4:	e0fff417 	ldw	r3,-48(fp)
 40067a8:	10c00015 	stw	r3,0(r2)
                    break;
 40067ac:	00001006 	br	40067f0 <xTaskGenericNotifyFromISR+0x198>

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 40067b0:	e0bffac3 	ldbu	r2,-21(fp)
 40067b4:	108000a0 	cmpeqi	r2,r2,2
 40067b8:	1000081e 	bne	r2,zero,40067dc <xTaskGenericNotifyFromISR+0x184>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 40067bc:	e0fffc17 	ldw	r3,-16(fp)
 40067c0:	e0bff517 	ldw	r2,-44(fp)
 40067c4:	10800484 	addi	r2,r2,18
 40067c8:	100490ba 	slli	r2,r2,2
 40067cc:	1885883a 	add	r2,r3,r2
 40067d0:	e0fff417 	ldw	r3,-48(fp)
 40067d4:	10c00015 	stw	r3,0(r2)
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
                    }

                    break;
 40067d8:	00000506 	br	40067f0 <xTaskGenericNotifyFromISR+0x198>
                        xReturn = pdFAIL;
 40067dc:	e03ffd15 	stw	zero,-12(fp)
                    break;
 40067e0:	00000306 	br	40067f0 <xTaskGenericNotifyFromISR+0x198>

                    /* Should not get here if all enums are handled.
                     * Artificially force an assert by testing a value the
                     * compiler can't assume is const. */
                    configASSERT( xTickCount == ( TickType_t ) 0 );
                    break;
 40067e4:	0001883a 	nop
 40067e8:	00000106 	br	40067f0 <xTaskGenericNotifyFromISR+0x198>
                    break;
 40067ec:	0001883a 	nop

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 40067f0:	e0bffac3 	ldbu	r2,-21(fp)
 40067f4:	10800058 	cmpnei	r2,r2,1
 40067f8:	1000851e 	bne	r2,zero,4006a10 <xTaskGenericNotifyFromISR+0x3b8>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 40067fc:	d0a72117 	ldw	r2,-25468(gp)
 4006800:	10005b1e 	bne	r2,zero,4006970 <xTaskGenericNotifyFromISR+0x318>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 4006804:	e0bffc17 	ldw	r2,-16(fp)
 4006808:	10800517 	ldw	r2,20(r2)
 400680c:	e0bff815 	stw	r2,-32(fp)
 4006810:	e0bffc17 	ldw	r2,-16(fp)
 4006814:	10800217 	ldw	r2,8(r2)
 4006818:	e0fffc17 	ldw	r3,-16(fp)
 400681c:	18c00317 	ldw	r3,12(r3)
 4006820:	10c00215 	stw	r3,8(r2)
 4006824:	e0bffc17 	ldw	r2,-16(fp)
 4006828:	10800317 	ldw	r2,12(r2)
 400682c:	e0fffc17 	ldw	r3,-16(fp)
 4006830:	18c00217 	ldw	r3,8(r3)
 4006834:	10c00115 	stw	r3,4(r2)
 4006838:	e0bff817 	ldw	r2,-32(fp)
 400683c:	10c00117 	ldw	r3,4(r2)
 4006840:	e0bffc17 	ldw	r2,-16(fp)
 4006844:	10800104 	addi	r2,r2,4
 4006848:	1880041e 	bne	r3,r2,400685c <xTaskGenericNotifyFromISR+0x204>
 400684c:	e0bffc17 	ldw	r2,-16(fp)
 4006850:	10c00317 	ldw	r3,12(r2)
 4006854:	e0bff817 	ldw	r2,-32(fp)
 4006858:	10c00115 	stw	r3,4(r2)
 400685c:	e0bffc17 	ldw	r2,-16(fp)
 4006860:	10000515 	stw	zero,20(r2)
 4006864:	e0bff817 	ldw	r2,-32(fp)
 4006868:	10800017 	ldw	r2,0(r2)
 400686c:	10ffffc4 	addi	r3,r2,-1
 4006870:	e0bff817 	ldw	r2,-32(fp)
 4006874:	10c00015 	stw	r3,0(r2)
                    prvAddTaskToReadyList( pxTCB );
 4006878:	e0bffc17 	ldw	r2,-16(fp)
 400687c:	10800b17 	ldw	r2,44(r2)
 4006880:	d0e71917 	ldw	r3,-25500(gp)
 4006884:	1880032e 	bgeu	r3,r2,4006894 <xTaskGenericNotifyFromISR+0x23c>
 4006888:	e0bffc17 	ldw	r2,-16(fp)
 400688c:	10800b17 	ldw	r2,44(r2)
 4006890:	d0a71915 	stw	r2,-25500(gp)
 4006894:	e0bffc17 	ldw	r2,-16(fp)
 4006898:	10800b17 	ldw	r2,44(r2)
 400689c:	01400504 	movi	r5,20
 40068a0:	1009883a 	mov	r4,r2
 40068a4:	40072d80 	call	40072d8 <__mulsi3>
 40068a8:	1007883a 	mov	r3,r2
 40068ac:	008120b4 	movhi	r2,1154
 40068b0:	1885883a 	add	r2,r3,r2
 40068b4:	10bab017 	ldw	r2,-5440(r2)
 40068b8:	e0bff715 	stw	r2,-36(fp)
 40068bc:	e0bffc17 	ldw	r2,-16(fp)
 40068c0:	e0fff717 	ldw	r3,-36(fp)
 40068c4:	10c00215 	stw	r3,8(r2)
 40068c8:	e0bff717 	ldw	r2,-36(fp)
 40068cc:	10c00217 	ldw	r3,8(r2)
 40068d0:	e0bffc17 	ldw	r2,-16(fp)
 40068d4:	10c00315 	stw	r3,12(r2)
 40068d8:	e0bff717 	ldw	r2,-36(fp)
 40068dc:	10800217 	ldw	r2,8(r2)
 40068e0:	e0fffc17 	ldw	r3,-16(fp)
 40068e4:	18c00104 	addi	r3,r3,4
 40068e8:	10c00115 	stw	r3,4(r2)
 40068ec:	e0bffc17 	ldw	r2,-16(fp)
 40068f0:	10c00104 	addi	r3,r2,4
 40068f4:	e0bff717 	ldw	r2,-36(fp)
 40068f8:	10c00215 	stw	r3,8(r2)
 40068fc:	e0bffc17 	ldw	r2,-16(fp)
 4006900:	10800b17 	ldw	r2,44(r2)
 4006904:	01400504 	movi	r5,20
 4006908:	1009883a 	mov	r4,r2
 400690c:	40072d80 	call	40072d8 <__mulsi3>
 4006910:	1007883a 	mov	r3,r2
 4006914:	008120b4 	movhi	r2,1154
 4006918:	10baaf04 	addi	r2,r2,-5444
 400691c:	1887883a 	add	r3,r3,r2
 4006920:	e0bffc17 	ldw	r2,-16(fp)
 4006924:	10c00515 	stw	r3,20(r2)
 4006928:	e0bffc17 	ldw	r2,-16(fp)
 400692c:	14400b17 	ldw	r17,44(r2)
 4006930:	01400504 	movi	r5,20
 4006934:	8809883a 	mov	r4,r17
 4006938:	40072d80 	call	40072d8 <__mulsi3>
 400693c:	1007883a 	mov	r3,r2
 4006940:	008120b4 	movhi	r2,1154
 4006944:	1885883a 	add	r2,r3,r2
 4006948:	10baaf17 	ldw	r2,-5444(r2)
 400694c:	14000044 	addi	r16,r2,1
 4006950:	01400504 	movi	r5,20
 4006954:	8809883a 	mov	r4,r17
 4006958:	40072d80 	call	40072d8 <__mulsi3>
 400695c:	1007883a 	mov	r3,r2
 4006960:	008120b4 	movhi	r2,1154
 4006964:	1885883a 	add	r2,r3,r2
 4006968:	143aaf15 	stw	r16,-5444(r2)
 400696c:	00001c06 	br	40069e0 <xTaskGenericNotifyFromISR+0x388>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 4006970:	008120b4 	movhi	r2,1154
 4006974:	10bad317 	ldw	r2,-5300(r2)
 4006978:	e0bff915 	stw	r2,-28(fp)
 400697c:	e0bffc17 	ldw	r2,-16(fp)
 4006980:	e0fff917 	ldw	r3,-28(fp)
 4006984:	10c00715 	stw	r3,28(r2)
 4006988:	e0bff917 	ldw	r2,-28(fp)
 400698c:	10c00217 	ldw	r3,8(r2)
 4006990:	e0bffc17 	ldw	r2,-16(fp)
 4006994:	10c00815 	stw	r3,32(r2)
 4006998:	e0bff917 	ldw	r2,-28(fp)
 400699c:	10800217 	ldw	r2,8(r2)
 40069a0:	e0fffc17 	ldw	r3,-16(fp)
 40069a4:	18c00604 	addi	r3,r3,24
 40069a8:	10c00115 	stw	r3,4(r2)
 40069ac:	e0bffc17 	ldw	r2,-16(fp)
 40069b0:	10c00604 	addi	r3,r2,24
 40069b4:	e0bff917 	ldw	r2,-28(fp)
 40069b8:	10c00215 	stw	r3,8(r2)
 40069bc:	e0fffc17 	ldw	r3,-16(fp)
 40069c0:	008120b4 	movhi	r2,1154
 40069c4:	10bad204 	addi	r2,r2,-5304
 40069c8:	18800a15 	stw	r2,40(r3)
 40069cc:	008120b4 	movhi	r2,1154
 40069d0:	10bad217 	ldw	r2,-5304(r2)
 40069d4:	10c00044 	addi	r3,r2,1
 40069d8:	008120b4 	movhi	r2,1154
 40069dc:	10fad215 	stw	r3,-5304(r2)
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 40069e0:	e0bffc17 	ldw	r2,-16(fp)
 40069e4:	10800b17 	ldw	r2,44(r2)
 40069e8:	d0e71317 	ldw	r3,-25524(gp)
 40069ec:	18c00b17 	ldw	r3,44(r3)
 40069f0:	1880072e 	bgeu	r3,r2,4006a10 <xTaskGenericNotifyFromISR+0x3b8>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
 40069f4:	e0800317 	ldw	r2,12(fp)
 40069f8:	10000326 	beq	r2,zero,4006a08 <xTaskGenericNotifyFromISR+0x3b0>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
 40069fc:	e0800317 	ldw	r2,12(fp)
 4006a00:	00c00044 	movi	r3,1
 4006a04:	10c00015 	stw	r3,0(r2)
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
 4006a08:	00800044 	movi	r2,1
 4006a0c:	d0a71c15 	stw	r2,-25488(gp)
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
 4006a10:	e0bffd17 	ldw	r2,-12(fp)
    }
 4006a14:	e6fffe04 	addi	sp,fp,-8
 4006a18:	dfc00317 	ldw	ra,12(sp)
 4006a1c:	df000217 	ldw	fp,8(sp)
 4006a20:	dc400117 	ldw	r17,4(sp)
 4006a24:	dc000017 	ldw	r16,0(sp)
 4006a28:	dec00404 	addi	sp,sp,16
 4006a2c:	f800283a 	ret

04006a30 <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
 4006a30:	defff304 	addi	sp,sp,-52
 4006a34:	dfc00c15 	stw	ra,48(sp)
 4006a38:	df000b15 	stw	fp,44(sp)
 4006a3c:	dc400a15 	stw	r17,40(sp)
 4006a40:	dc000915 	stw	r16,36(sp)
 4006a44:	df000b04 	addi	fp,sp,44
 4006a48:	e13ff715 	stw	r4,-36(fp)
 4006a4c:	e17ff615 	stw	r5,-40(fp)
 4006a50:	e1bff515 	stw	r6,-44(fp)
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
 4006a54:	e0bff717 	ldw	r2,-36(fp)
 4006a58:	e0bffd15 	stw	r2,-12(fp)

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4006a5c:	e03ffc15 	stw	zero,-16(fp)
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 4006a60:	e0fffd17 	ldw	r3,-12(fp)
 4006a64:	e0bff617 	ldw	r2,-40(fp)
 4006a68:	1885883a 	add	r2,r3,r2
 4006a6c:	10801303 	ldbu	r2,76(r2)
 4006a70:	e0bffbc5 	stb	r2,-17(fp)
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 4006a74:	e0fffd17 	ldw	r3,-12(fp)
 4006a78:	e0bff617 	ldw	r2,-40(fp)
 4006a7c:	1885883a 	add	r2,r3,r2
 4006a80:	00c00084 	movi	r3,2
 4006a84:	10c01305 	stb	r3,76(r2)

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
 4006a88:	e0fffd17 	ldw	r3,-12(fp)
 4006a8c:	e0bff617 	ldw	r2,-40(fp)
 4006a90:	10800484 	addi	r2,r2,18
 4006a94:	100490ba 	slli	r2,r2,2
 4006a98:	1885883a 	add	r2,r3,r2
 4006a9c:	10800017 	ldw	r2,0(r2)
 4006aa0:	10c00044 	addi	r3,r2,1
 4006aa4:	e13ffd17 	ldw	r4,-12(fp)
 4006aa8:	e0bff617 	ldw	r2,-40(fp)
 4006aac:	10800484 	addi	r2,r2,18
 4006ab0:	100490ba 	slli	r2,r2,2
 4006ab4:	2085883a 	add	r2,r4,r2
 4006ab8:	10c00015 	stw	r3,0(r2)

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 4006abc:	e0bffbc3 	ldbu	r2,-17(fp)
 4006ac0:	10800058 	cmpnei	r2,r2,1
 4006ac4:	1000851e 	bne	r2,zero,4006cdc <vTaskGenericNotifyGiveFromISR+0x2ac>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 4006ac8:	d0a72117 	ldw	r2,-25468(gp)
 4006acc:	10005b1e 	bne	r2,zero,4006c3c <vTaskGenericNotifyGiveFromISR+0x20c>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 4006ad0:	e0bffd17 	ldw	r2,-12(fp)
 4006ad4:	10800517 	ldw	r2,20(r2)
 4006ad8:	e0bff915 	stw	r2,-28(fp)
 4006adc:	e0bffd17 	ldw	r2,-12(fp)
 4006ae0:	10800217 	ldw	r2,8(r2)
 4006ae4:	e0fffd17 	ldw	r3,-12(fp)
 4006ae8:	18c00317 	ldw	r3,12(r3)
 4006aec:	10c00215 	stw	r3,8(r2)
 4006af0:	e0bffd17 	ldw	r2,-12(fp)
 4006af4:	10800317 	ldw	r2,12(r2)
 4006af8:	e0fffd17 	ldw	r3,-12(fp)
 4006afc:	18c00217 	ldw	r3,8(r3)
 4006b00:	10c00115 	stw	r3,4(r2)
 4006b04:	e0bff917 	ldw	r2,-28(fp)
 4006b08:	10c00117 	ldw	r3,4(r2)
 4006b0c:	e0bffd17 	ldw	r2,-12(fp)
 4006b10:	10800104 	addi	r2,r2,4
 4006b14:	1880041e 	bne	r3,r2,4006b28 <vTaskGenericNotifyGiveFromISR+0xf8>
 4006b18:	e0bffd17 	ldw	r2,-12(fp)
 4006b1c:	10c00317 	ldw	r3,12(r2)
 4006b20:	e0bff917 	ldw	r2,-28(fp)
 4006b24:	10c00115 	stw	r3,4(r2)
 4006b28:	e0bffd17 	ldw	r2,-12(fp)
 4006b2c:	10000515 	stw	zero,20(r2)
 4006b30:	e0bff917 	ldw	r2,-28(fp)
 4006b34:	10800017 	ldw	r2,0(r2)
 4006b38:	10ffffc4 	addi	r3,r2,-1
 4006b3c:	e0bff917 	ldw	r2,-28(fp)
 4006b40:	10c00015 	stw	r3,0(r2)
                    prvAddTaskToReadyList( pxTCB );
 4006b44:	e0bffd17 	ldw	r2,-12(fp)
 4006b48:	10800b17 	ldw	r2,44(r2)
 4006b4c:	d0e71917 	ldw	r3,-25500(gp)
 4006b50:	1880032e 	bgeu	r3,r2,4006b60 <vTaskGenericNotifyGiveFromISR+0x130>
 4006b54:	e0bffd17 	ldw	r2,-12(fp)
 4006b58:	10800b17 	ldw	r2,44(r2)
 4006b5c:	d0a71915 	stw	r2,-25500(gp)
 4006b60:	e0bffd17 	ldw	r2,-12(fp)
 4006b64:	10800b17 	ldw	r2,44(r2)
 4006b68:	01400504 	movi	r5,20
 4006b6c:	1009883a 	mov	r4,r2
 4006b70:	40072d80 	call	40072d8 <__mulsi3>
 4006b74:	1007883a 	mov	r3,r2
 4006b78:	008120b4 	movhi	r2,1154
 4006b7c:	1885883a 	add	r2,r3,r2
 4006b80:	10bab017 	ldw	r2,-5440(r2)
 4006b84:	e0bff815 	stw	r2,-32(fp)
 4006b88:	e0bffd17 	ldw	r2,-12(fp)
 4006b8c:	e0fff817 	ldw	r3,-32(fp)
 4006b90:	10c00215 	stw	r3,8(r2)
 4006b94:	e0bff817 	ldw	r2,-32(fp)
 4006b98:	10c00217 	ldw	r3,8(r2)
 4006b9c:	e0bffd17 	ldw	r2,-12(fp)
 4006ba0:	10c00315 	stw	r3,12(r2)
 4006ba4:	e0bff817 	ldw	r2,-32(fp)
 4006ba8:	10800217 	ldw	r2,8(r2)
 4006bac:	e0fffd17 	ldw	r3,-12(fp)
 4006bb0:	18c00104 	addi	r3,r3,4
 4006bb4:	10c00115 	stw	r3,4(r2)
 4006bb8:	e0bffd17 	ldw	r2,-12(fp)
 4006bbc:	10c00104 	addi	r3,r2,4
 4006bc0:	e0bff817 	ldw	r2,-32(fp)
 4006bc4:	10c00215 	stw	r3,8(r2)
 4006bc8:	e0bffd17 	ldw	r2,-12(fp)
 4006bcc:	10800b17 	ldw	r2,44(r2)
 4006bd0:	01400504 	movi	r5,20
 4006bd4:	1009883a 	mov	r4,r2
 4006bd8:	40072d80 	call	40072d8 <__mulsi3>
 4006bdc:	1007883a 	mov	r3,r2
 4006be0:	008120b4 	movhi	r2,1154
 4006be4:	10baaf04 	addi	r2,r2,-5444
 4006be8:	1887883a 	add	r3,r3,r2
 4006bec:	e0bffd17 	ldw	r2,-12(fp)
 4006bf0:	10c00515 	stw	r3,20(r2)
 4006bf4:	e0bffd17 	ldw	r2,-12(fp)
 4006bf8:	14400b17 	ldw	r17,44(r2)
 4006bfc:	01400504 	movi	r5,20
 4006c00:	8809883a 	mov	r4,r17
 4006c04:	40072d80 	call	40072d8 <__mulsi3>
 4006c08:	1007883a 	mov	r3,r2
 4006c0c:	008120b4 	movhi	r2,1154
 4006c10:	1885883a 	add	r2,r3,r2
 4006c14:	10baaf17 	ldw	r2,-5444(r2)
 4006c18:	14000044 	addi	r16,r2,1
 4006c1c:	01400504 	movi	r5,20
 4006c20:	8809883a 	mov	r4,r17
 4006c24:	40072d80 	call	40072d8 <__mulsi3>
 4006c28:	1007883a 	mov	r3,r2
 4006c2c:	008120b4 	movhi	r2,1154
 4006c30:	1885883a 	add	r2,r3,r2
 4006c34:	143aaf15 	stw	r16,-5444(r2)
 4006c38:	00001c06 	br	4006cac <vTaskGenericNotifyGiveFromISR+0x27c>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 4006c3c:	008120b4 	movhi	r2,1154
 4006c40:	10bad317 	ldw	r2,-5300(r2)
 4006c44:	e0bffa15 	stw	r2,-24(fp)
 4006c48:	e0bffd17 	ldw	r2,-12(fp)
 4006c4c:	e0fffa17 	ldw	r3,-24(fp)
 4006c50:	10c00715 	stw	r3,28(r2)
 4006c54:	e0bffa17 	ldw	r2,-24(fp)
 4006c58:	10c00217 	ldw	r3,8(r2)
 4006c5c:	e0bffd17 	ldw	r2,-12(fp)
 4006c60:	10c00815 	stw	r3,32(r2)
 4006c64:	e0bffa17 	ldw	r2,-24(fp)
 4006c68:	10800217 	ldw	r2,8(r2)
 4006c6c:	e0fffd17 	ldw	r3,-12(fp)
 4006c70:	18c00604 	addi	r3,r3,24
 4006c74:	10c00115 	stw	r3,4(r2)
 4006c78:	e0bffd17 	ldw	r2,-12(fp)
 4006c7c:	10c00604 	addi	r3,r2,24
 4006c80:	e0bffa17 	ldw	r2,-24(fp)
 4006c84:	10c00215 	stw	r3,8(r2)
 4006c88:	e0fffd17 	ldw	r3,-12(fp)
 4006c8c:	008120b4 	movhi	r2,1154
 4006c90:	10bad204 	addi	r2,r2,-5304
 4006c94:	18800a15 	stw	r2,40(r3)
 4006c98:	008120b4 	movhi	r2,1154
 4006c9c:	10bad217 	ldw	r2,-5304(r2)
 4006ca0:	10c00044 	addi	r3,r2,1
 4006ca4:	008120b4 	movhi	r2,1154
 4006ca8:	10fad215 	stw	r3,-5304(r2)
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 4006cac:	e0bffd17 	ldw	r2,-12(fp)
 4006cb0:	10800b17 	ldw	r2,44(r2)
 4006cb4:	d0e71317 	ldw	r3,-25524(gp)
 4006cb8:	18c00b17 	ldw	r3,44(r3)
 4006cbc:	1880072e 	bgeu	r3,r2,4006cdc <vTaskGenericNotifyGiveFromISR+0x2ac>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
 4006cc0:	e0bff517 	ldw	r2,-44(fp)
 4006cc4:	10000326 	beq	r2,zero,4006cd4 <vTaskGenericNotifyGiveFromISR+0x2a4>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
 4006cc8:	e0bff517 	ldw	r2,-44(fp)
 4006ccc:	00c00044 	movi	r3,1
 4006cd0:	10c00015 	stw	r3,0(r2)
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
 4006cd4:	00800044 	movi	r2,1
 4006cd8:	d0a71c15 	stw	r2,-25488(gp)
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
 4006cdc:	0001883a 	nop
 4006ce0:	e6fffe04 	addi	sp,fp,-8
 4006ce4:	dfc00317 	ldw	ra,12(sp)
 4006ce8:	df000217 	ldw	fp,8(sp)
 4006cec:	dc400117 	ldw	r17,4(sp)
 4006cf0:	dc000017 	ldw	r16,0(sp)
 4006cf4:	dec00404 	addi	sp,sp,16
 4006cf8:	f800283a 	ret

04006cfc <xTaskGenericNotifyStateClear>:

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                             UBaseType_t uxIndexToClear )
    {
 4006cfc:	defffa04 	addi	sp,sp,-24
 4006d00:	dfc00515 	stw	ra,20(sp)
 4006d04:	df000415 	stw	fp,16(sp)
 4006d08:	df000404 	addi	fp,sp,16
 4006d0c:	e13ffd15 	stw	r4,-12(fp)
 4006d10:	e17ffc15 	stw	r5,-16(fp)

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
 4006d14:	e0bffd17 	ldw	r2,-12(fp)
 4006d18:	1000021e 	bne	r2,zero,4006d24 <xTaskGenericNotifyStateClear+0x28>
 4006d1c:	d0a71317 	ldw	r2,-25524(gp)
 4006d20:	00000106 	br	4006d28 <xTaskGenericNotifyStateClear+0x2c>
 4006d24:	e0bffd17 	ldw	r2,-12(fp)
 4006d28:	e0bffe15 	stw	r2,-8(fp)

        taskENTER_CRITICAL();
 4006d2c:	4005f740 	call	4005f74 <vTaskEnterCritical>
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
 4006d30:	e0fffe17 	ldw	r3,-8(fp)
 4006d34:	e0bffc17 	ldw	r2,-16(fp)
 4006d38:	1885883a 	add	r2,r3,r2
 4006d3c:	10801303 	ldbu	r2,76(r2)
 4006d40:	10803fcc 	andi	r2,r2,255
 4006d44:	10800098 	cmpnei	r2,r2,2
 4006d48:	1000071e 	bne	r2,zero,4006d68 <xTaskGenericNotifyStateClear+0x6c>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
 4006d4c:	e0fffe17 	ldw	r3,-8(fp)
 4006d50:	e0bffc17 	ldw	r2,-16(fp)
 4006d54:	1885883a 	add	r2,r3,r2
 4006d58:	10001305 	stb	zero,76(r2)
                xReturn = pdPASS;
 4006d5c:	00800044 	movi	r2,1
 4006d60:	e0bfff15 	stw	r2,-4(fp)
 4006d64:	00000106 	br	4006d6c <xTaskGenericNotifyStateClear+0x70>
            }
            else
            {
                xReturn = pdFAIL;
 4006d68:	e03fff15 	stw	zero,-4(fp)
            }
        }
        taskEXIT_CRITICAL();
 4006d6c:	4005fc80 	call	4005fc8 <vTaskExitCritical>

        return xReturn;
 4006d70:	e0bfff17 	ldw	r2,-4(fp)
    }
 4006d74:	e037883a 	mov	sp,fp
 4006d78:	dfc00117 	ldw	ra,4(sp)
 4006d7c:	df000017 	ldw	fp,0(sp)
 4006d80:	dec00204 	addi	sp,sp,8
 4006d84:	f800283a 	ret

04006d88 <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
 4006d88:	defff904 	addi	sp,sp,-28
 4006d8c:	dfc00615 	stw	ra,24(sp)
 4006d90:	df000515 	stw	fp,20(sp)
 4006d94:	df000504 	addi	fp,sp,20
 4006d98:	e13ffd15 	stw	r4,-12(fp)
 4006d9c:	e17ffc15 	stw	r5,-16(fp)
 4006da0:	e1bffb15 	stw	r6,-20(fp)
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
 4006da4:	e0bffd17 	ldw	r2,-12(fp)
 4006da8:	1000021e 	bne	r2,zero,4006db4 <ulTaskGenericNotifyValueClear+0x2c>
 4006dac:	d0a71317 	ldw	r2,-25524(gp)
 4006db0:	00000106 	br	4006db8 <ulTaskGenericNotifyValueClear+0x30>
 4006db4:	e0bffd17 	ldw	r2,-12(fp)
 4006db8:	e0bfff15 	stw	r2,-4(fp)

        taskENTER_CRITICAL();
 4006dbc:	4005f740 	call	4005f74 <vTaskEnterCritical>
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
 4006dc0:	e0ffff17 	ldw	r3,-4(fp)
 4006dc4:	e0bffc17 	ldw	r2,-16(fp)
 4006dc8:	10800484 	addi	r2,r2,18
 4006dcc:	100490ba 	slli	r2,r2,2
 4006dd0:	1885883a 	add	r2,r3,r2
 4006dd4:	10800017 	ldw	r2,0(r2)
 4006dd8:	e0bffe15 	stw	r2,-8(fp)
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
 4006ddc:	e0ffff17 	ldw	r3,-4(fp)
 4006de0:	e0bffc17 	ldw	r2,-16(fp)
 4006de4:	10800484 	addi	r2,r2,18
 4006de8:	100490ba 	slli	r2,r2,2
 4006dec:	1885883a 	add	r2,r3,r2
 4006df0:	10c00017 	ldw	r3,0(r2)
 4006df4:	e0bffb17 	ldw	r2,-20(fp)
 4006df8:	0084303a 	nor	r2,zero,r2
 4006dfc:	1886703a 	and	r3,r3,r2
 4006e00:	e13fff17 	ldw	r4,-4(fp)
 4006e04:	e0bffc17 	ldw	r2,-16(fp)
 4006e08:	10800484 	addi	r2,r2,18
 4006e0c:	100490ba 	slli	r2,r2,2
 4006e10:	2085883a 	add	r2,r4,r2
 4006e14:	10c00015 	stw	r3,0(r2)
        }
        taskEXIT_CRITICAL();
 4006e18:	4005fc80 	call	4005fc8 <vTaskExitCritical>

        return ulReturn;
 4006e1c:	e0bffe17 	ldw	r2,-8(fp)
    }
 4006e20:	e037883a 	mov	sp,fp
 4006e24:	dfc00117 	ldw	ra,4(sp)
 4006e28:	df000017 	ldw	fp,0(sp)
 4006e2c:	dec00204 	addi	sp,sp,8
 4006e30:	f800283a 	ret

04006e34 <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
 4006e34:	defff904 	addi	sp,sp,-28
 4006e38:	dfc00615 	stw	ra,24(sp)
 4006e3c:	df000515 	stw	fp,20(sp)
 4006e40:	df000504 	addi	fp,sp,20
 4006e44:	e13ffc15 	stw	r4,-16(fp)
 4006e48:	e17ffb15 	stw	r5,-20(fp)
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
 4006e4c:	d0a71817 	ldw	r2,-25504(gp)
 4006e50:	e0bfff15 	stw	r2,-4(fp)
    }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4006e54:	d0a71317 	ldw	r2,-25524(gp)
 4006e58:	10800104 	addi	r2,r2,4
 4006e5c:	1009883a 	mov	r4,r2
 4006e60:	4000c980 	call	4000c98 <uxListRemove>
        mtCOVERAGE_TEST_MARKER();
    }

    #if ( INCLUDE_vTaskSuspend == 1 )
    {
        if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 4006e64:	e0bffc17 	ldw	r2,-16(fp)
 4006e68:	10bfffd8 	cmpnei	r2,r2,-1
 4006e6c:	1000201e 	bne	r2,zero,4006ef0 <prvAddCurrentTaskToDelayedList+0xbc>
 4006e70:	e0bffb17 	ldw	r2,-20(fp)
 4006e74:	10001e26 	beq	r2,zero,4006ef0 <prvAddCurrentTaskToDelayedList+0xbc>
        {
            /* Add the task to the suspended task list instead of a delayed task
             * list to ensure it is not woken by a timing event.  It will block
             * indefinitely. */
            listINSERT_END( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 4006e78:	008120b4 	movhi	r2,1154
 4006e7c:	10badd17 	ldw	r2,-5260(r2)
 4006e80:	e0bffe15 	stw	r2,-8(fp)
 4006e84:	d0a71317 	ldw	r2,-25524(gp)
 4006e88:	e0fffe17 	ldw	r3,-8(fp)
 4006e8c:	10c00215 	stw	r3,8(r2)
 4006e90:	d0a71317 	ldw	r2,-25524(gp)
 4006e94:	e0fffe17 	ldw	r3,-8(fp)
 4006e98:	18c00217 	ldw	r3,8(r3)
 4006e9c:	10c00315 	stw	r3,12(r2)
 4006ea0:	d0e71317 	ldw	r3,-25524(gp)
 4006ea4:	e0bffe17 	ldw	r2,-8(fp)
 4006ea8:	10800217 	ldw	r2,8(r2)
 4006eac:	18c00104 	addi	r3,r3,4
 4006eb0:	10c00115 	stw	r3,4(r2)
 4006eb4:	d0a71317 	ldw	r2,-25524(gp)
 4006eb8:	10c00104 	addi	r3,r2,4
 4006ebc:	e0bffe17 	ldw	r2,-8(fp)
 4006ec0:	10c00215 	stw	r3,8(r2)
 4006ec4:	d0e71317 	ldw	r3,-25524(gp)
 4006ec8:	008120b4 	movhi	r2,1154
 4006ecc:	10badc04 	addi	r2,r2,-5264
 4006ed0:	18800515 	stw	r2,20(r3)
 4006ed4:	008120b4 	movhi	r2,1154
 4006ed8:	10badc17 	ldw	r2,-5264(r2)
 4006edc:	10c00044 	addi	r3,r2,1
 4006ee0:	008120b4 	movhi	r2,1154
 4006ee4:	10fadc15 	stw	r3,-5264(r2)
 4006ee8:	0001883a 	nop

        /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
        ( void ) xCanBlockIndefinitely;
    }
    #endif /* INCLUDE_vTaskSuspend */
}
 4006eec:	00001c06 	br	4006f60 <prvAddCurrentTaskToDelayedList+0x12c>
            xTimeToWake = xConstTickCount + xTicksToWait;
 4006ef0:	e0ffff17 	ldw	r3,-4(fp)
 4006ef4:	e0bffc17 	ldw	r2,-16(fp)
 4006ef8:	1885883a 	add	r2,r3,r2
 4006efc:	e0bffd15 	stw	r2,-12(fp)
            listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 4006f00:	d0a71317 	ldw	r2,-25524(gp)
 4006f04:	e0fffd17 	ldw	r3,-12(fp)
 4006f08:	10c00115 	stw	r3,4(r2)
            if( xTimeToWake < xConstTickCount )
 4006f0c:	e0fffd17 	ldw	r3,-12(fp)
 4006f10:	e0bfff17 	ldw	r2,-4(fp)
 4006f14:	1880072e 	bgeu	r3,r2,4006f34 <prvAddCurrentTaskToDelayedList+0x100>
                vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 4006f18:	d0e71517 	ldw	r3,-25516(gp)
 4006f1c:	d0a71317 	ldw	r2,-25524(gp)
 4006f20:	10800104 	addi	r2,r2,4
 4006f24:	100b883a 	mov	r5,r2
 4006f28:	1809883a 	mov	r4,r3
 4006f2c:	4000bc00 	call	4000bc0 <vListInsert>
}
 4006f30:	00000b06 	br	4006f60 <prvAddCurrentTaskToDelayedList+0x12c>
                vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 4006f34:	d0e71417 	ldw	r3,-25520(gp)
 4006f38:	d0a71317 	ldw	r2,-25524(gp)
 4006f3c:	10800104 	addi	r2,r2,4
 4006f40:	100b883a 	mov	r5,r2
 4006f44:	1809883a 	mov	r4,r3
 4006f48:	4000bc00 	call	4000bc0 <vListInsert>
                if( xTimeToWake < xNextTaskUnblockTime )
 4006f4c:	d0a71f17 	ldw	r2,-25476(gp)
 4006f50:	e0fffd17 	ldw	r3,-12(fp)
 4006f54:	1880022e 	bgeu	r3,r2,4006f60 <prvAddCurrentTaskToDelayedList+0x12c>
                    xNextTaskUnblockTime = xTimeToWake;
 4006f58:	e0bffd17 	ldw	r2,-12(fp)
 4006f5c:	d0a71f15 	stw	r2,-25476(gp)
}
 4006f60:	0001883a 	nop
 4006f64:	e037883a 	mov	sp,fp
 4006f68:	dfc00117 	ldw	ra,4(sp)
 4006f6c:	df000017 	ldw	fp,0(sp)
 4006f70:	dec00204 	addi	sp,sp,8
 4006f74:	f800283a 	ret

04006f78 <convertData>:
#include "FreeRTOS.h"



unsigned convertData( int x )
{
 4006f78:	defffe04 	addi	sp,sp,-8
 4006f7c:	df000115 	stw	fp,4(sp)
 4006f80:	df000104 	addi	fp,sp,4
 4006f84:	e13fff15 	stw	r4,-4(fp)
    if (x == 0)
 4006f88:	e0bfff17 	ldw	r2,-4(fp)
 4006f8c:	1000021e 	bne	r2,zero,4006f98 <convertData+0x20>
    {
      return 0b1000000;
 4006f90:	00801004 	movi	r2,64
 4006f94:	00002e06 	br	4007050 <convertData+0xd8>
    }
    else if (x == 1)
 4006f98:	e0bfff17 	ldw	r2,-4(fp)
 4006f9c:	10800058 	cmpnei	r2,r2,1
 4006fa0:	1000021e 	bne	r2,zero,4006fac <convertData+0x34>
    {
      return 0b1111001;
 4006fa4:	00801e44 	movi	r2,121
 4006fa8:	00002906 	br	4007050 <convertData+0xd8>
    }
    else if (x == 2)
 4006fac:	e0bfff17 	ldw	r2,-4(fp)
 4006fb0:	10800098 	cmpnei	r2,r2,2
 4006fb4:	1000021e 	bne	r2,zero,4006fc0 <convertData+0x48>
    {
      return 0b0100100;
 4006fb8:	00800904 	movi	r2,36
 4006fbc:	00002406 	br	4007050 <convertData+0xd8>
    }
    else if (x == 3)
 4006fc0:	e0bfff17 	ldw	r2,-4(fp)
 4006fc4:	108000d8 	cmpnei	r2,r2,3
 4006fc8:	1000021e 	bne	r2,zero,4006fd4 <convertData+0x5c>
    {
      return 0b0110000;
 4006fcc:	00800c04 	movi	r2,48
 4006fd0:	00001f06 	br	4007050 <convertData+0xd8>
    }
    else if (x == 4)
 4006fd4:	e0bfff17 	ldw	r2,-4(fp)
 4006fd8:	10800118 	cmpnei	r2,r2,4
 4006fdc:	1000021e 	bne	r2,zero,4006fe8 <convertData+0x70>
    {
      return 0b00011001;
 4006fe0:	00800644 	movi	r2,25
 4006fe4:	00001a06 	br	4007050 <convertData+0xd8>
    }
    else if (x == 5)
 4006fe8:	e0bfff17 	ldw	r2,-4(fp)
 4006fec:	10800158 	cmpnei	r2,r2,5
 4006ff0:	1000021e 	bne	r2,zero,4006ffc <convertData+0x84>
    {
      return 0b0010010;
 4006ff4:	00800484 	movi	r2,18
 4006ff8:	00001506 	br	4007050 <convertData+0xd8>
    }
    else if (x == 6)
 4006ffc:	e0bfff17 	ldw	r2,-4(fp)
 4007000:	10800198 	cmpnei	r2,r2,6
 4007004:	1000021e 	bne	r2,zero,4007010 <convertData+0x98>
    {
      return 0b0000010;
 4007008:	00800084 	movi	r2,2
 400700c:	00001006 	br	4007050 <convertData+0xd8>
    }
    else if (x == 7)
 4007010:	e0bfff17 	ldw	r2,-4(fp)
 4007014:	108001d8 	cmpnei	r2,r2,7
 4007018:	1000021e 	bne	r2,zero,4007024 <convertData+0xac>
    {
      return 0b1111000;
 400701c:	00801e04 	movi	r2,120
 4007020:	00000b06 	br	4007050 <convertData+0xd8>
    }
    else if(x == 8)
 4007024:	e0bfff17 	ldw	r2,-4(fp)
 4007028:	10800218 	cmpnei	r2,r2,8
 400702c:	1000021e 	bne	r2,zero,4007038 <convertData+0xc0>
    {
      return 0b0000000;
 4007030:	0005883a 	mov	r2,zero
 4007034:	00000606 	br	4007050 <convertData+0xd8>
    }
    else if(x == 9)
 4007038:	e0bfff17 	ldw	r2,-4(fp)
 400703c:	10800258 	cmpnei	r2,r2,9
 4007040:	1000021e 	bne	r2,zero,400704c <convertData+0xd4>
    {
      return 0b0011000;
 4007044:	00800604 	movi	r2,24
 4007048:	00000106 	br	4007050 <convertData+0xd8>
    }
  return 0;
 400704c:	0005883a 	mov	r2,zero
}
 4007050:	e037883a 	mov	sp,fp
 4007054:	df000017 	ldw	fp,0(sp)
 4007058:	dec00104 	addi	sp,sp,4
 400705c:	f800283a 	ret

04007060 <parseData>:

unsigned parseData(int x)
{
 4007060:	defffd04 	addi	sp,sp,-12
 4007064:	df000215 	stw	fp,8(sp)
 4007068:	df000204 	addi	fp,sp,8
 400706c:	e13ffe15 	stw	r4,-8(fp)
    unsigned int rev = 0;
 4007070:	e03fff15 	stw	zero,-4(fp)

    while (x > 0) {
 4007074:	00000c06 	br	40070a8 <parseData+0x48>
        rev <<= 1;
 4007078:	e0bfff17 	ldw	r2,-4(fp)
 400707c:	1085883a 	add	r2,r2,r2
 4007080:	e0bfff15 	stw	r2,-4(fp)

        if ((x & 1) == 1)
 4007084:	e0bffe17 	ldw	r2,-8(fp)
 4007088:	1080004c 	andi	r2,r2,1
 400708c:	10000326 	beq	r2,zero,400709c <parseData+0x3c>
            rev ^= 1;
 4007090:	e0bfff17 	ldw	r2,-4(fp)
 4007094:	1080005c 	xori	r2,r2,1
 4007098:	e0bfff15 	stw	r2,-4(fp)

        x >>= 1;
 400709c:	e0bffe17 	ldw	r2,-8(fp)
 40070a0:	1005d07a 	srai	r2,r2,1
 40070a4:	e0bffe15 	stw	r2,-8(fp)
    while (x > 0) {
 40070a8:	e0bffe17 	ldw	r2,-8(fp)
 40070ac:	00bff216 	blt	zero,r2,4007078 <parseData+0x18>
    }
    return rev;
 40070b0:	e0bfff17 	ldw	r2,-4(fp)
}
 40070b4:	e037883a 	mov	sp,fp
 40070b8:	df000017 	ldw	fp,0(sp)
 40070bc:	dec00104 	addi	sp,sp,4
 40070c0:	f800283a 	ret

040070c4 <writeScore>:

void writeScore(int s)
{
 40070c4:	defffd04 	addi	sp,sp,-12
 40070c8:	dfc00215 	stw	ra,8(sp)
 40070cc:	df000115 	stw	fp,4(sp)
 40070d0:	df000104 	addi	fp,sp,4
 40070d4:	e13fff15 	stw	r4,-4(fp)
//   IOWR_ALTERA_AVALON_PIO_DATA(HEX_1_BASE, convertData(arr[1]));
//   IOWR_ALTERA_AVALON_PIO_DATA(HEX_2_BASE, convertData(arr[2]));
//   IOWR_ALTERA_AVALON_PIO_DATA(HEX_3_BASE, convertData(arr[3]));
//   IOWR_ALTERA_AVALON_PIO_DATA(HEX_4_BASE, convertData(arr[4]));
//   IOWR_ALTERA_AVALON_PIO_DATA(HEX_5_BASE, convertData(arr[5]));
    printf("str: %d\n", s);
 40070d8:	e17fff17 	ldw	r5,-4(fp)
 40070dc:	010100b4 	movhi	r4,1026
 40070e0:	212aae04 	addi	r4,r4,-21832
 40070e4:	40076b00 	call	40076b0 <printf>
}
 40070e8:	0001883a 	nop
 40070ec:	e037883a 	mov	sp,fp
 40070f0:	dfc00117 	ldw	ra,4(sp)
 40070f4:	df000017 	ldw	fp,0(sp)
 40070f8:	dec00204 	addi	sp,sp,8
 40070fc:	f800283a 	ret

04007100 <sendReading>:




void sendReading ( alt_32 x )
{
 4007100:	defffe04 	addi	sp,sp,-8
 4007104:	df000115 	stw	fp,4(sp)
 4007108:	df000104 	addi	fp,sp,4
 400710c:	e13fff15 	stw	r4,-4(fp)
  if ( IORD_ALTERA_AVALON_SPI_STATUS(ESP32_SPI_BASE) && 0b01000000 )
 4007110:	00820034 	movhi	r2,2048
 4007114:	10840a37 	ldwio	r2,4136(r2)
 4007118:	10000326 	beq	r2,zero,4007128 <sendReading+0x28>
  {
    IOWR_ALTERA_AVALON_SPI_TXDATA(ESP32_SPI_BASE, (int) x);
 400711c:	e0ffff17 	ldw	r3,-4(fp)
 4007120:	00820034 	movhi	r2,2048
 4007124:	10c40935 	stwio	r3,4132(r2)
    // printf("txreg: %d\n", IORD_ALTERA_AVALON_SPI_TXDATA(ESP32_SPI_BASE));
    // printf("data: %ld\n", (x & 0b111111111));
  }
}
 4007128:	0001883a 	nop
 400712c:	e037883a 	mov	sp,fp
 4007130:	df000017 	ldw	fp,0(sp)
 4007134:	dec00104 	addi	sp,sp,4
 4007138:	f800283a 	ret

0400713c <getScore>:

unsigned getScore ()
{
 400713c:	deffff04 	addi	sp,sp,-4
 4007140:	df000015 	stw	fp,0(sp)
 4007144:	d839883a 	mov	fp,sp
  if ( IORD_ALTERA_AVALON_SPI_STATUS(ESP32_SPI_BASE) && 0b010000000 )
 4007148:	00820034 	movhi	r2,2048
 400714c:	10840a37 	ldwio	r2,4136(r2)
 4007150:	10000326 	beq	r2,zero,4007160 <getScore+0x24>
  {
    return IORD_ALTERA_AVALON_SPI_TXDATA(ESP32_SPI_BASE);
 4007154:	00820034 	movhi	r2,2048
 4007158:	10840937 	ldwio	r2,4132(r2)
 400715c:	00000106 	br	4007164 <getScore+0x28>
    // printf("txreg: %d\n", IORD_ALTERA_AVALON_SPI_TXDATA(ESP32_SPI_BASE));
    // printf("data: %ld\n", (x & 0b111111111));
  }
  return 0;
 4007160:	0005883a 	mov	r2,zero
}
 4007164:	e037883a 	mov	sp,fp
 4007168:	df000017 	ldw	fp,0(sp)
 400716c:	dec00104 	addi	sp,sp,4
 4007170:	f800283a 	ret

04007174 <task1>:

void task1()
{
 4007174:	defffa04 	addi	sp,sp,-24
 4007178:	dfc00515 	stw	ra,20(sp)
 400717c:	df000415 	stw	fp,16(sp)
 4007180:	df000404 	addi	fp,sp,16
  printf("asdas\n");
 4007184:	010100b4 	movhi	r4,1026
 4007188:	212ab104 	addi	r4,r4,-21820
 400718c:	40078300 	call	4007830 <puts>
  alt_32 x_read, y_read;
  int buttons;
  alt_up_accelerometer_spi_dev *accDev;
  accDev = alt_up_accelerometer_spi_open_dev(ACCELEROMETER_SPI_NAME);
 4007190:	010100b4 	movhi	r4,1026
 4007194:	212ab304 	addi	r4,r4,-21812
 4007198:	40196e80 	call	40196e8 <alt_up_accelerometer_spi_open_dev>
 400719c:	e0bfff15 	stw	r2,-4(fp)

  if ( accDev == NULL )
 40071a0:	e0bfff17 	ldw	r2,-4(fp)
 40071a4:	10001b26 	beq	r2,zero,4007214 <task1+0xa0>
    return;
  }

  while ( 1 )
  {
    buttons = (~IORD_ALTERA_AVALON_PIO_DATA(KEYS_0_BASE)) & 0x3;
 40071a8:	00820034 	movhi	r2,2048
 40071ac:	10842837 	ldwio	r2,4256(r2)
 40071b0:	0084303a 	nor	r2,zero,r2
 40071b4:	108000cc 	andi	r2,r2,3
 40071b8:	e0bffe15 	stw	r2,-8(fp)
    alt_up_accelerometer_spi_read_x_axis(accDev, &x_read);
 40071bc:	e0bffd04 	addi	r2,fp,-12
 40071c0:	100b883a 	mov	r5,r2
 40071c4:	e13fff17 	ldw	r4,-4(fp)
 40071c8:	40198380 	call	4019838 <alt_up_accelerometer_spi_read_x_axis>
    alt_up_accelerometer_spi_read_y_axis(accDev, &y_read);
 40071cc:	e0bffc04 	addi	r2,fp,-16
 40071d0:	100b883a 	mov	r5,r2
 40071d4:	e13fff17 	ldw	r4,-4(fp)
 40071d8:	401990c0 	call	401990c <alt_up_accelerometer_spi_read_y_axis>
    // printf("x: %ld, y: %ld, buttons:%d\n", x_read, y_read, buttons);
    sendReading(((x_read & 0b1111111111) + ((y_read & 0b1111111111) << 9)) + (buttons << 24));
 40071dc:	e0bffd17 	ldw	r2,-12(fp)
 40071e0:	10c0ffcc 	andi	r3,r2,1023
 40071e4:	e0bffc17 	ldw	r2,-16(fp)
 40071e8:	1008927a 	slli	r4,r2,9
 40071ec:	00800234 	movhi	r2,8
 40071f0:	10bf8004 	addi	r2,r2,-512
 40071f4:	2084703a 	and	r2,r4,r2
 40071f8:	1887883a 	add	r3,r3,r2
 40071fc:	e0bffe17 	ldw	r2,-8(fp)
 4007200:	1004963a 	slli	r2,r2,24
 4007204:	1885883a 	add	r2,r3,r2
 4007208:	1009883a 	mov	r4,r2
 400720c:	40071000 	call	4007100 <sendReading>
    buttons = (~IORD_ALTERA_AVALON_PIO_DATA(KEYS_0_BASE)) & 0x3;
 4007210:	003fe506 	br	40071a8 <task1+0x34>
    return;
 4007214:	0001883a 	nop
  }
//  vTaskDelay(100);
}
 4007218:	e037883a 	mov	sp,fp
 400721c:	dfc00117 	ldw	ra,4(sp)
 4007220:	df000017 	ldw	fp,0(sp)
 4007224:	dec00204 	addi	sp,sp,8
 4007228:	f800283a 	ret

0400722c <task2>:


void task2()
{
 400722c:	defffe04 	addi	sp,sp,-8
 4007230:	dfc00115 	stw	ra,4(sp)
 4007234:	df000015 	stw	fp,0(sp)
 4007238:	d839883a 	mov	fp,sp
//   writeScore(getScore());
  printf("zift\n");
 400723c:	010100b4 	movhi	r4,1026
 4007240:	212ab904 	addi	r4,r4,-21788
 4007244:	40078300 	call	4007830 <puts>
//  vTaskDelay(10000);

}
 4007248:	0001883a 	nop
 400724c:	e037883a 	mov	sp,fp
 4007250:	dfc00117 	ldw	ra,4(sp)
 4007254:	df000017 	ldw	fp,0(sp)
 4007258:	dec00204 	addi	sp,sp,8
 400725c:	f800283a 	ret

04007260 <main>:



int main()
{
 4007260:	defffc04 	addi	sp,sp,-16
 4007264:	dfc00315 	stw	ra,12(sp)
 4007268:	df000215 	stw	fp,8(sp)
 400726c:	df000204 	addi	fp,sp,8
  xTaskCreate(task1, "Task 1", 512, NULL, 2, NULL);
 4007270:	d8000115 	stw	zero,4(sp)
 4007274:	00800084 	movi	r2,2
 4007278:	d8800015 	stw	r2,0(sp)
 400727c:	000f883a 	mov	r7,zero
 4007280:	01808004 	movi	r6,512
 4007284:	014100b4 	movhi	r5,1026
 4007288:	296abb04 	addi	r5,r5,-21780
 400728c:	01010034 	movhi	r4,1024
 4007290:	211c5d04 	addi	r4,r4,29044
 4007294:	40037ac0 	call	40037ac <xTaskCreate>
  xTaskCreate(task2, "Task 2", 512, NULL, 2, NULL);
 4007298:	d8000115 	stw	zero,4(sp)
 400729c:	00800084 	movi	r2,2
 40072a0:	d8800015 	stw	r2,0(sp)
 40072a4:	000f883a 	mov	r7,zero
 40072a8:	01808004 	movi	r6,512
 40072ac:	014100b4 	movhi	r5,1026
 40072b0:	296abd04 	addi	r5,r5,-21772
 40072b4:	01010034 	movhi	r4,1024
 40072b8:	211c8b04 	addi	r4,r4,29228
 40072bc:	40037ac0 	call	40037ac <xTaskCreate>

  return 0;
 40072c0:	0005883a 	mov	r2,zero
}
 40072c4:	e037883a 	mov	sp,fp
 40072c8:	dfc00117 	ldw	ra,4(sp)
 40072cc:	df000017 	ldw	fp,0(sp)
 40072d0:	dec00204 	addi	sp,sp,8
 40072d4:	f800283a 	ret

040072d8 <__mulsi3>:
 40072d8:	0005883a 	mov	r2,zero
 40072dc:	20000726 	beq	r4,zero,40072fc <__mulsi3+0x24>
 40072e0:	20c0004c 	andi	r3,r4,1
 40072e4:	2008d07a 	srli	r4,r4,1
 40072e8:	18000126 	beq	r3,zero,40072f0 <__mulsi3+0x18>
 40072ec:	1145883a 	add	r2,r2,r5
 40072f0:	294b883a 	add	r5,r5,r5
 40072f4:	203ffa1e 	bne	r4,zero,40072e0 <__mulsi3+0x8>
 40072f8:	f800283a 	ret
 40072fc:	f800283a 	ret

04007300 <memcpy>:
void *
__inhibit_loop_to_libcall
memcpy (void *__restrict dst0,
	const void *__restrict src0,
	size_t len0)
{
 4007300:	defff804 	addi	sp,sp,-32
 4007304:	df000715 	stw	fp,28(sp)
 4007308:	df000704 	addi	fp,sp,28
 400730c:	e13ffb15 	stw	r4,-20(fp)
 4007310:	e17ffa15 	stw	r5,-24(fp)
 4007314:	e1bff915 	stw	r6,-28(fp)
      *dst++ = *src++;
    }

  return save;
#else
  char *dst = dst0;
 4007318:	e0bffb17 	ldw	r2,-20(fp)
 400731c:	e0bfff15 	stw	r2,-4(fp)
  const char *src = src0;
 4007320:	e0bffa17 	ldw	r2,-24(fp)
 4007324:	e0bffe15 	stw	r2,-8(fp)
  long *aligned_dst;
  const long *aligned_src;

  /* If the size is small, or either SRC or DST is unaligned,
     then punt into the byte copy loop.  This should be rare.  */
  if (!TOO_SMALL(len0) && !UNALIGNED (src, dst))
 4007328:	e0bff917 	ldw	r2,-28(fp)
 400732c:	10800430 	cmpltui	r2,r2,16
 4007330:	10004c1e 	bne	r2,zero,4007464 <memcpy+0x164>
 4007334:	e0fffe17 	ldw	r3,-8(fp)
 4007338:	e0bfff17 	ldw	r2,-4(fp)
 400733c:	1884b03a 	or	r2,r3,r2
 4007340:	108000cc 	andi	r2,r2,3
 4007344:	1000471e 	bne	r2,zero,4007464 <memcpy+0x164>
    {
      aligned_dst = (long*)dst;
 4007348:	e0bfff17 	ldw	r2,-4(fp)
 400734c:	e0bffd15 	stw	r2,-12(fp)
      aligned_src = (long*)src;
 4007350:	e0bffe17 	ldw	r2,-8(fp)
 4007354:	e0bffc15 	stw	r2,-16(fp)

      /* Copy 4X long words at a time if possible.  */
      while (len0 >= BIGBLOCKSIZE)
 4007358:	00002306 	br	40073e8 <memcpy+0xe8>
        {
          *aligned_dst++ = *aligned_src++;
 400735c:	e0fffc17 	ldw	r3,-16(fp)
 4007360:	18800104 	addi	r2,r3,4
 4007364:	e0bffc15 	stw	r2,-16(fp)
 4007368:	e0bffd17 	ldw	r2,-12(fp)
 400736c:	11000104 	addi	r4,r2,4
 4007370:	e13ffd15 	stw	r4,-12(fp)
 4007374:	18c00017 	ldw	r3,0(r3)
 4007378:	10c00015 	stw	r3,0(r2)
          *aligned_dst++ = *aligned_src++;
 400737c:	e0fffc17 	ldw	r3,-16(fp)
 4007380:	18800104 	addi	r2,r3,4
 4007384:	e0bffc15 	stw	r2,-16(fp)
 4007388:	e0bffd17 	ldw	r2,-12(fp)
 400738c:	11000104 	addi	r4,r2,4
 4007390:	e13ffd15 	stw	r4,-12(fp)
 4007394:	18c00017 	ldw	r3,0(r3)
 4007398:	10c00015 	stw	r3,0(r2)
          *aligned_dst++ = *aligned_src++;
 400739c:	e0fffc17 	ldw	r3,-16(fp)
 40073a0:	18800104 	addi	r2,r3,4
 40073a4:	e0bffc15 	stw	r2,-16(fp)
 40073a8:	e0bffd17 	ldw	r2,-12(fp)
 40073ac:	11000104 	addi	r4,r2,4
 40073b0:	e13ffd15 	stw	r4,-12(fp)
 40073b4:	18c00017 	ldw	r3,0(r3)
 40073b8:	10c00015 	stw	r3,0(r2)
          *aligned_dst++ = *aligned_src++;
 40073bc:	e0fffc17 	ldw	r3,-16(fp)
 40073c0:	18800104 	addi	r2,r3,4
 40073c4:	e0bffc15 	stw	r2,-16(fp)
 40073c8:	e0bffd17 	ldw	r2,-12(fp)
 40073cc:	11000104 	addi	r4,r2,4
 40073d0:	e13ffd15 	stw	r4,-12(fp)
 40073d4:	18c00017 	ldw	r3,0(r3)
 40073d8:	10c00015 	stw	r3,0(r2)
          len0 -= BIGBLOCKSIZE;
 40073dc:	e0bff917 	ldw	r2,-28(fp)
 40073e0:	10bffc04 	addi	r2,r2,-16
 40073e4:	e0bff915 	stw	r2,-28(fp)
      while (len0 >= BIGBLOCKSIZE)
 40073e8:	e0bff917 	ldw	r2,-28(fp)
 40073ec:	10800428 	cmpgeui	r2,r2,16
 40073f0:	103fda1e 	bne	r2,zero,400735c <memcpy+0x5c>
        }

      /* Copy one long word at a time if possible.  */
      while (len0 >= LITTLEBLOCKSIZE)
 40073f4:	00000b06 	br	4007424 <memcpy+0x124>
        {
          *aligned_dst++ = *aligned_src++;
 40073f8:	e0fffc17 	ldw	r3,-16(fp)
 40073fc:	18800104 	addi	r2,r3,4
 4007400:	e0bffc15 	stw	r2,-16(fp)
 4007404:	e0bffd17 	ldw	r2,-12(fp)
 4007408:	11000104 	addi	r4,r2,4
 400740c:	e13ffd15 	stw	r4,-12(fp)
 4007410:	18c00017 	ldw	r3,0(r3)
 4007414:	10c00015 	stw	r3,0(r2)
          len0 -= LITTLEBLOCKSIZE;
 4007418:	e0bff917 	ldw	r2,-28(fp)
 400741c:	10bfff04 	addi	r2,r2,-4
 4007420:	e0bff915 	stw	r2,-28(fp)
      while (len0 >= LITTLEBLOCKSIZE)
 4007424:	e0bff917 	ldw	r2,-28(fp)
 4007428:	10800128 	cmpgeui	r2,r2,4
 400742c:	103ff21e 	bne	r2,zero,40073f8 <memcpy+0xf8>
        }

       /* Pick up any residual with a byte copier.  */
      dst = (char*)aligned_dst;
 4007430:	e0bffd17 	ldw	r2,-12(fp)
 4007434:	e0bfff15 	stw	r2,-4(fp)
      src = (char*)aligned_src;
 4007438:	e0bffc17 	ldw	r2,-16(fp)
 400743c:	e0bffe15 	stw	r2,-8(fp)
    }

  while (len0--)
 4007440:	00000806 	br	4007464 <memcpy+0x164>
    *dst++ = *src++;
 4007444:	e0fffe17 	ldw	r3,-8(fp)
 4007448:	18800044 	addi	r2,r3,1
 400744c:	e0bffe15 	stw	r2,-8(fp)
 4007450:	e0bfff17 	ldw	r2,-4(fp)
 4007454:	11000044 	addi	r4,r2,1
 4007458:	e13fff15 	stw	r4,-4(fp)
 400745c:	18c00003 	ldbu	r3,0(r3)
 4007460:	10c00005 	stb	r3,0(r2)
  while (len0--)
 4007464:	e0bff917 	ldw	r2,-28(fp)
 4007468:	10ffffc4 	addi	r3,r2,-1
 400746c:	e0fff915 	stw	r3,-28(fp)
 4007470:	103ff41e 	bne	r2,zero,4007444 <memcpy+0x144>

  return dst0;
 4007474:	e0bffb17 	ldw	r2,-20(fp)
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 4007478:	e037883a 	mov	sp,fp
 400747c:	df000017 	ldw	fp,0(sp)
 4007480:	dec00104 	addi	sp,sp,4
 4007484:	f800283a 	ret

04007488 <memset>:
void *
__inhibit_loop_to_libcall
memset (void *m,
	int c,
	size_t n)
{
 4007488:	defff704 	addi	sp,sp,-36
 400748c:	df000815 	stw	fp,32(sp)
 4007490:	df000804 	addi	fp,sp,32
 4007494:	e13ffa15 	stw	r4,-24(fp)
 4007498:	e17ff915 	stw	r5,-28(fp)
 400749c:	e1bff815 	stw	r6,-32(fp)
  char *s = (char *) m;
 40074a0:	e0bffa17 	ldw	r2,-24(fp)
 40074a4:	e0bfff15 	stw	r2,-4(fp)

#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned int i;
  unsigned long buffer;
  unsigned long *aligned_addr;
  unsigned int d = c & 0xff;	/* To avoid sign extension, copy C to an
 40074a8:	e0bff917 	ldw	r2,-28(fp)
 40074ac:	10803fcc 	andi	r2,r2,255
 40074b0:	e0bffb15 	stw	r2,-20(fp)
				   unsigned variable.  */

  while (UNALIGNED (s))
 40074b4:	00000c06 	br	40074e8 <memset+0x60>
    {
      if (n--)
 40074b8:	e0bff817 	ldw	r2,-32(fp)
 40074bc:	10ffffc4 	addi	r3,r2,-1
 40074c0:	e0fff815 	stw	r3,-32(fp)
 40074c4:	10000626 	beq	r2,zero,40074e0 <memset+0x58>
        *s++ = (char) c;
 40074c8:	e0bfff17 	ldw	r2,-4(fp)
 40074cc:	10c00044 	addi	r3,r2,1
 40074d0:	e0ffff15 	stw	r3,-4(fp)
 40074d4:	e0fff917 	ldw	r3,-28(fp)
 40074d8:	10c00005 	stb	r3,0(r2)
 40074dc:	00000206 	br	40074e8 <memset+0x60>
      else
        return m;
 40074e0:	e0bffa17 	ldw	r2,-24(fp)
 40074e4:	00005506 	br	400763c <memset+0x1b4>
  while (UNALIGNED (s))
 40074e8:	e0bfff17 	ldw	r2,-4(fp)
 40074ec:	108000cc 	andi	r2,r2,3
 40074f0:	103ff11e 	bne	r2,zero,40074b8 <memset+0x30>
    }

  if (!TOO_SMALL (n))
 40074f4:	e0bff817 	ldw	r2,-32(fp)
 40074f8:	10800130 	cmpltui	r2,r2,4
 40074fc:	10004a1e 	bne	r2,zero,4007628 <memset+0x1a0>
    {
      /* If we get this far, we know that n is large and s is word-aligned. */
      aligned_addr = (unsigned long *) s;
 4007500:	e0bfff17 	ldw	r2,-4(fp)
 4007504:	e0bffc15 	stw	r2,-16(fp)

      /* Store D into each char sized location in BUFFER so that
         we can set large blocks quickly.  */
      buffer = (d << 8) | d;
 4007508:	e0bffb17 	ldw	r2,-20(fp)
 400750c:	1004923a 	slli	r2,r2,8
 4007510:	e0fffb17 	ldw	r3,-20(fp)
 4007514:	1884b03a 	or	r2,r3,r2
 4007518:	e0bffd15 	stw	r2,-12(fp)
      buffer |= (buffer << 16);
 400751c:	e0bffd17 	ldw	r2,-12(fp)
 4007520:	1004943a 	slli	r2,r2,16
 4007524:	e0fffd17 	ldw	r3,-12(fp)
 4007528:	1884b03a 	or	r2,r3,r2
 400752c:	e0bffd15 	stw	r2,-12(fp)
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
 4007530:	00800804 	movi	r2,32
 4007534:	e0bffe15 	stw	r2,-8(fp)
 4007538:	00000906 	br	4007560 <memset+0xd8>
        buffer = (buffer << i) | buffer;
 400753c:	e0fffd17 	ldw	r3,-12(fp)
 4007540:	e0bffe17 	ldw	r2,-8(fp)
 4007544:	1884983a 	sll	r2,r3,r2
 4007548:	e0fffd17 	ldw	r3,-12(fp)
 400754c:	1884b03a 	or	r2,r3,r2
 4007550:	e0bffd15 	stw	r2,-12(fp)
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
 4007554:	e0bffe17 	ldw	r2,-8(fp)
 4007558:	1085883a 	add	r2,r2,r2
 400755c:	e0bffe15 	stw	r2,-8(fp)
 4007560:	e0bffe17 	ldw	r2,-8(fp)
 4007564:	10800830 	cmpltui	r2,r2,32
 4007568:	103ff41e 	bne	r2,zero,400753c <memset+0xb4>

      /* Unroll the loop.  */
      while (n >= LBLOCKSIZE*4)
 400756c:	00001706 	br	40075cc <memset+0x144>
        {
          *aligned_addr++ = buffer;
 4007570:	e0bffc17 	ldw	r2,-16(fp)
 4007574:	10c00104 	addi	r3,r2,4
 4007578:	e0fffc15 	stw	r3,-16(fp)
 400757c:	e0fffd17 	ldw	r3,-12(fp)
 4007580:	10c00015 	stw	r3,0(r2)
          *aligned_addr++ = buffer;
 4007584:	e0bffc17 	ldw	r2,-16(fp)
 4007588:	10c00104 	addi	r3,r2,4
 400758c:	e0fffc15 	stw	r3,-16(fp)
 4007590:	e0fffd17 	ldw	r3,-12(fp)
 4007594:	10c00015 	stw	r3,0(r2)
          *aligned_addr++ = buffer;
 4007598:	e0bffc17 	ldw	r2,-16(fp)
 400759c:	10c00104 	addi	r3,r2,4
 40075a0:	e0fffc15 	stw	r3,-16(fp)
 40075a4:	e0fffd17 	ldw	r3,-12(fp)
 40075a8:	10c00015 	stw	r3,0(r2)
          *aligned_addr++ = buffer;
 40075ac:	e0bffc17 	ldw	r2,-16(fp)
 40075b0:	10c00104 	addi	r3,r2,4
 40075b4:	e0fffc15 	stw	r3,-16(fp)
 40075b8:	e0fffd17 	ldw	r3,-12(fp)
 40075bc:	10c00015 	stw	r3,0(r2)
          n -= 4*LBLOCKSIZE;
 40075c0:	e0bff817 	ldw	r2,-32(fp)
 40075c4:	10bffc04 	addi	r2,r2,-16
 40075c8:	e0bff815 	stw	r2,-32(fp)
      while (n >= LBLOCKSIZE*4)
 40075cc:	e0bff817 	ldw	r2,-32(fp)
 40075d0:	10800428 	cmpgeui	r2,r2,16
 40075d4:	103fe61e 	bne	r2,zero,4007570 <memset+0xe8>
        }

      while (n >= LBLOCKSIZE)
 40075d8:	00000806 	br	40075fc <memset+0x174>
        {
          *aligned_addr++ = buffer;
 40075dc:	e0bffc17 	ldw	r2,-16(fp)
 40075e0:	10c00104 	addi	r3,r2,4
 40075e4:	e0fffc15 	stw	r3,-16(fp)
 40075e8:	e0fffd17 	ldw	r3,-12(fp)
 40075ec:	10c00015 	stw	r3,0(r2)
          n -= LBLOCKSIZE;
 40075f0:	e0bff817 	ldw	r2,-32(fp)
 40075f4:	10bfff04 	addi	r2,r2,-4
 40075f8:	e0bff815 	stw	r2,-32(fp)
      while (n >= LBLOCKSIZE)
 40075fc:	e0bff817 	ldw	r2,-32(fp)
 4007600:	10800128 	cmpgeui	r2,r2,4
 4007604:	103ff51e 	bne	r2,zero,40075dc <memset+0x154>
        }
      /* Pick up the remainder with a bytewise loop.  */
      s = (char*)aligned_addr;
 4007608:	e0bffc17 	ldw	r2,-16(fp)
 400760c:	e0bfff15 	stw	r2,-4(fp)
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (n--)
 4007610:	00000506 	br	4007628 <memset+0x1a0>
    *s++ = (char) c;
 4007614:	e0bfff17 	ldw	r2,-4(fp)
 4007618:	10c00044 	addi	r3,r2,1
 400761c:	e0ffff15 	stw	r3,-4(fp)
 4007620:	e0fff917 	ldw	r3,-28(fp)
 4007624:	10c00005 	stb	r3,0(r2)
  while (n--)
 4007628:	e0bff817 	ldw	r2,-32(fp)
 400762c:	10ffffc4 	addi	r3,r2,-1
 4007630:	e0fff815 	stw	r3,-32(fp)
 4007634:	103ff71e 	bne	r2,zero,4007614 <memset+0x18c>

  return m;
 4007638:	e0bffa17 	ldw	r2,-24(fp)
}
 400763c:	e037883a 	mov	sp,fp
 4007640:	df000017 	ldw	fp,0(sp)
 4007644:	dec00104 	addi	sp,sp,4
 4007648:	f800283a 	ret

0400764c <_printf_r>:
#include "fvwrite.h"    /* IntelSpecific */

int
_printf_r (struct _reent *ptr,
       const char *__restrict fmt, ...)
{
 400764c:	defff804 	addi	sp,sp,-32
 4007650:	dfc00515 	stw	ra,20(sp)
 4007654:	df000415 	stw	fp,16(sp)
 4007658:	df000404 	addi	fp,sp,16
 400765c:	e13ffd15 	stw	r4,-12(fp)
 4007660:	e17ffc15 	stw	r5,-16(fp)
 4007664:	e1800215 	stw	r6,8(fp)
 4007668:	e1c00315 	stw	r7,12(fp)
  int ret;
  va_list ap;

  _REENT_SMALL_CHECK_INIT (ptr);
  _FILE_INIT_DEV_WRITE (_stdout_r (ptr));    /* IntelSpecific */
  va_start (ap, fmt);
 400766c:	e0800204 	addi	r2,fp,8
 4007670:	e0bffe15 	stw	r2,-8(fp)
/*ret =   _vfprintf_r          (ptr, _stdout_r (ptr), fmt, ap);	*/	/*1.16.0*/	/* IntelSpecific */
/*ret = ___vfprintf_internal_r (ptr, _stdout_r (ptr), fmt, ap);	*/	/*1.16  */	/* IntelSpecific */
/*ret =   _vfprintf_r          (ptr, _stdout_r (ptr), fmt, ap);	*/	/*1.18.0*/	/* IntelSpecific */
/*ret =   _vfprintf_r          (ptr, _stdout_r (ptr), fmt, ap);	*/	/* try1 */	/* IntelSpecific */
  ret = ___vfprintf_internal_r (ptr, _stdout_r (ptr), fmt, ap);		/* try2 */	/* IntelSpecific */
 4007674:	e0bffd17 	ldw	r2,-12(fp)
 4007678:	10800217 	ldw	r2,8(r2)
 400767c:	e0fffe17 	ldw	r3,-8(fp)
 4007680:	180f883a 	mov	r7,r3
 4007684:	e1bffc17 	ldw	r6,-16(fp)
 4007688:	100b883a 	mov	r5,r2
 400768c:	e13ffd17 	ldw	r4,-12(fp)
 4007690:	4007a9c0 	call	4007a9c <___vfprintf_internal_r>
 4007694:	e0bfff15 	stw	r2,-4(fp)
  va_end (ap);
  return ret;
 4007698:	e0bfff17 	ldw	r2,-4(fp)
}
 400769c:	e037883a 	mov	sp,fp
 40076a0:	dfc00117 	ldw	ra,4(sp)
 40076a4:	df000017 	ldw	fp,0(sp)
 40076a8:	dec00404 	addi	sp,sp,16
 40076ac:	f800283a 	ret

040076b0 <printf>:

#ifndef _REENT_ONLY

int
printf (const char *__restrict fmt, ...)
{
 40076b0:	defff704 	addi	sp,sp,-36
 40076b4:	dfc00515 	stw	ra,20(sp)
 40076b8:	df000415 	stw	fp,16(sp)
 40076bc:	df000404 	addi	fp,sp,16
 40076c0:	e13ffc15 	stw	r4,-16(fp)
 40076c4:	e1400215 	stw	r5,8(fp)
 40076c8:	e1800315 	stw	r6,12(fp)
 40076cc:	e1c00415 	stw	r7,16(fp)
  int ret;
  va_list ap;
  struct _reent *ptr = _REENT;
 40076d0:	d0a00117 	ldw	r2,-32764(gp)
 40076d4:	e0bfff15 	stw	r2,-4(fp)

  _REENT_SMALL_CHECK_INIT (ptr);
  _FILE_INIT_DEV_WRITE (_stdout_r (_REENT));    /* IntelSpecific. Mirror changes here in iprintf.c */
  va_start (ap, fmt);
 40076d8:	e0800204 	addi	r2,fp,8
 40076dc:	e0bffd15 	stw	r2,-12(fp)
/*ret =  _vfprintf_r        (ptr, _stdout_r    (ptr), fmt, ap);	*/ /*1.16.0*/	/* IntelSpecific */
/*ret = __vfprintf_internal (     _stdout_r (_REENT), fmt, ap);	*/ /*1.16  */	/* IntelSpecific */
/*ret =  _vfprintf_r        (ptr, _stdout_r    (ptr), fmt, ap);	*/ /*1.18.0*/	/* IntelSpecific */
/*ret =  _vfprintf_r        (ptr, _stdout_r    (ptr), fmt, ap); */ /* try1 */	/* IntelSpecific */
  ret = __vfprintf_internal (     _stdout_r (_REENT), fmt, ap);    /* try2 */	/* IntelSpecific */
 40076e0:	d0a00117 	ldw	r2,-32764(gp)
 40076e4:	10800217 	ldw	r2,8(r2)
 40076e8:	e0fffd17 	ldw	r3,-12(fp)
 40076ec:	180d883a 	mov	r6,r3
 40076f0:	e17ffc17 	ldw	r5,-16(fp)
 40076f4:	1009883a 	mov	r4,r2
 40076f8:	4007a4c0 	call	4007a4c <__vfprintf_internal>
 40076fc:	e0bffe15 	stw	r2,-8(fp)
  va_end (ap);
  return ret;
 4007700:	e0bffe17 	ldw	r2,-8(fp)
}
 4007704:	e037883a 	mov	sp,fp
 4007708:	dfc00117 	ldw	ra,4(sp)
 400770c:	df000017 	ldw	fp,0(sp)
 4007710:	dec00504 	addi	sp,sp,20
 4007714:	f800283a 	ret

04007718 <_puts_r>:
 */

int
_puts_r (struct _reent *ptr,
       const char * s)
{
 4007718:	defff104 	addi	sp,sp,-60
 400771c:	dfc00e15 	stw	ra,56(sp)
 4007720:	df000d15 	stw	fp,52(sp)
 4007724:	df000d04 	addi	fp,sp,52
 4007728:	e13ff415 	stw	r4,-48(fp)
 400772c:	e17ff315 	stw	r5,-52(fp)
#ifdef _FVWRITE_IN_STREAMIO
  int result;
  size_t c = strlen (s);
 4007730:	e13ff317 	ldw	r4,-52(fp)
 4007734:	40078680 	call	4007868 <strlen>
 4007738:	e0bfff15 	stw	r2,-4(fp)
  struct __suio uio;
  struct __siov iov[2];
  FILE *fp;

  iov[0].iov_base = s;
 400773c:	e0bff317 	ldw	r2,-52(fp)
 4007740:	e0bff515 	stw	r2,-44(fp)
  iov[0].iov_len = c;
 4007744:	e0bfff17 	ldw	r2,-4(fp)
 4007748:	e0bff615 	stw	r2,-40(fp)
  iov[1].iov_base = "\n";
 400774c:	008100b4 	movhi	r2,1026
 4007750:	10aabf04 	addi	r2,r2,-21764
 4007754:	e0bff715 	stw	r2,-36(fp)
  iov[1].iov_len = 1;
 4007758:	00800044 	movi	r2,1
 400775c:	e0bff815 	stw	r2,-32(fp)
  uio.uio_resid = c + 1;
 4007760:	e0bfff17 	ldw	r2,-4(fp)
 4007764:	10800044 	addi	r2,r2,1
 4007768:	e0bffb15 	stw	r2,-20(fp)
  uio.uio_iov = &iov[0];
 400776c:	e0bff504 	addi	r2,fp,-44
 4007770:	e0bff915 	stw	r2,-28(fp)
  uio.uio_iovcnt = 2;
 4007774:	00800084 	movi	r2,2
 4007778:	e0bffa15 	stw	r2,-24(fp)

  _REENT_SMALL_CHECK_INIT (ptr);
  fp = _stdout_r (ptr);
 400777c:	e0bff417 	ldw	r2,-48(fp)
 4007780:	10800217 	ldw	r2,8(r2)
 4007784:	e0bffe15 	stw	r2,-8(fp)
  CHECK_INIT (ptr, fp);
 4007788:	e0bff417 	ldw	r2,-48(fp)
 400778c:	e0bffd15 	stw	r2,-12(fp)
 4007790:	e0bffd17 	ldw	r2,-12(fp)
 4007794:	10000526 	beq	r2,zero,40077ac <_puts_r+0x94>
 4007798:	e0bffd17 	ldw	r2,-12(fp)
 400779c:	10800e17 	ldw	r2,56(r2)
 40077a0:	1000021e 	bne	r2,zero,40077ac <_puts_r+0x94>
 40077a4:	e13ffd17 	ldw	r4,-12(fp)
 40077a8:	400c9100 	call	400c910 <__sinit>
  _newlib_flockfile_start (fp);
  ORIENT (fp, -1);
 40077ac:	e0bffe17 	ldw	r2,-8(fp)
 40077b0:	1080030b 	ldhu	r2,12(r2)
 40077b4:	10bfffcc 	andi	r2,r2,65535
 40077b8:	1088000c 	andi	r2,r2,8192
 40077bc:	10000c1e 	bne	r2,zero,40077f0 <_puts_r+0xd8>
 40077c0:	e0bffe17 	ldw	r2,-8(fp)
 40077c4:	1080030b 	ldhu	r2,12(r2)
 40077c8:	10880014 	ori	r2,r2,8192
 40077cc:	1007883a 	mov	r3,r2
 40077d0:	e0bffe17 	ldw	r2,-8(fp)
 40077d4:	10c0030d 	sth	r3,12(r2)
 40077d8:	e0bffe17 	ldw	r2,-8(fp)
 40077dc:	10c01917 	ldw	r3,100(r2)
 40077e0:	00b7ffc4 	movi	r2,-8193
 40077e4:	1886703a 	and	r3,r3,r2
 40077e8:	e0bffe17 	ldw	r2,-8(fp)
 40077ec:	10c01915 	stw	r3,100(r2)
  result = (__sfvwrite_r (ptr, fp, &uio) ? EOF : '\n');
 40077f0:	e0bff904 	addi	r2,fp,-28
 40077f4:	100d883a 	mov	r6,r2
 40077f8:	e17ffe17 	ldw	r5,-8(fp)
 40077fc:	e13ff417 	ldw	r4,-48(fp)
 4007800:	400d2280 	call	400d228 <__sfvwrite_r>
 4007804:	10000226 	beq	r2,zero,4007810 <_puts_r+0xf8>
 4007808:	00bfffc4 	movi	r2,-1
 400780c:	00000106 	br	4007814 <_puts_r+0xfc>
 4007810:	00800284 	movi	r2,10
 4007814:	e0bffc15 	stw	r2,-16(fp)
  _newlib_flockfile_end (fp);
  return result;
 4007818:	e0bffc17 	ldw	r2,-16(fp)

err:
  _newlib_flockfile_end (fp);
  return result;
#endif
}
 400781c:	e037883a 	mov	sp,fp
 4007820:	dfc00117 	ldw	ra,4(sp)
 4007824:	df000017 	ldw	fp,0(sp)
 4007828:	dec00204 	addi	sp,sp,8
 400782c:	f800283a 	ret

04007830 <puts>:

#ifndef _REENT_ONLY

int
puts (char const * s)
{
 4007830:	defffd04 	addi	sp,sp,-12
 4007834:	dfc00215 	stw	ra,8(sp)
 4007838:	df000115 	stw	fp,4(sp)
 400783c:	df000104 	addi	fp,sp,4
 4007840:	e13fff15 	stw	r4,-4(fp)
  return _puts_r (_REENT, s);
 4007844:	d0a00117 	ldw	r2,-32764(gp)
 4007848:	e17fff17 	ldw	r5,-4(fp)
 400784c:	1009883a 	mov	r4,r2
 4007850:	40077180 	call	4007718 <_puts_r>
}
 4007854:	e037883a 	mov	sp,fp
 4007858:	dfc00117 	ldw	ra,4(sp)
 400785c:	df000017 	ldw	fp,0(sp)
 4007860:	dec00204 	addi	sp,sp,8
 4007864:	f800283a 	ret

04007868 <strlen>:
#error long int is not a 32bit or 64bit byte
#endif

size_t
strlen (const char *str)
{
 4007868:	defffc04 	addi	sp,sp,-16
 400786c:	df000315 	stw	fp,12(sp)
 4007870:	df000304 	addi	fp,sp,12
 4007874:	e13ffd15 	stw	r4,-12(fp)
  const char *start = str;
 4007878:	e0bffd17 	ldw	r2,-12(fp)
 400787c:	e0bffe15 	stw	r2,-8(fp)

#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *aligned_addr;

  /* Align the pointer, so we can search a word at a time.  */
  while (UNALIGNED (str))
 4007880:	00000d06 	br	40078b8 <strlen+0x50>
    {
      if (!*str)
 4007884:	e0bffd17 	ldw	r2,-12(fp)
 4007888:	10800003 	ldbu	r2,0(r2)
 400788c:	10803fcc 	andi	r2,r2,255
 4007890:	1080201c 	xori	r2,r2,128
 4007894:	10bfe004 	addi	r2,r2,-128
 4007898:	1000041e 	bne	r2,zero,40078ac <strlen+0x44>
	return str - start;
 400789c:	e0fffd17 	ldw	r3,-12(fp)
 40078a0:	e0bffe17 	ldw	r2,-8(fp)
 40078a4:	1885c83a 	sub	r2,r3,r2
 40078a8:	00002806 	br	400794c <strlen+0xe4>
      str++;
 40078ac:	e0bffd17 	ldw	r2,-12(fp)
 40078b0:	10800044 	addi	r2,r2,1
 40078b4:	e0bffd15 	stw	r2,-12(fp)
  while (UNALIGNED (str))
 40078b8:	e0bffd17 	ldw	r2,-12(fp)
 40078bc:	108000cc 	andi	r2,r2,3
 40078c0:	103ff01e 	bne	r2,zero,4007884 <strlen+0x1c>
    }

  /* If the string is word-aligned, we can check for the presence of
     a null in each word-sized block.  */
  aligned_addr = (unsigned long *)str;
 40078c4:	e0bffd17 	ldw	r2,-12(fp)
 40078c8:	e0bfff15 	stw	r2,-4(fp)
  while (!DETECTNULL (*aligned_addr))
 40078cc:	00000306 	br	40078dc <strlen+0x74>
    aligned_addr++;
 40078d0:	e0bfff17 	ldw	r2,-4(fp)
 40078d4:	10800104 	addi	r2,r2,4
 40078d8:	e0bfff15 	stw	r2,-4(fp)
  while (!DETECTNULL (*aligned_addr))
 40078dc:	e0bfff17 	ldw	r2,-4(fp)
 40078e0:	10c00017 	ldw	r3,0(r2)
 40078e4:	00bfbff4 	movhi	r2,65279
 40078e8:	10bfbfc4 	addi	r2,r2,-257
 40078ec:	1887883a 	add	r3,r3,r2
 40078f0:	e0bfff17 	ldw	r2,-4(fp)
 40078f4:	10800017 	ldw	r2,0(r2)
 40078f8:	0084303a 	nor	r2,zero,r2
 40078fc:	1886703a 	and	r3,r3,r2
 4007900:	00a02074 	movhi	r2,32897
 4007904:	10a02004 	addi	r2,r2,-32640
 4007908:	1884703a 	and	r2,r3,r2
 400790c:	103ff026 	beq	r2,zero,40078d0 <strlen+0x68>

  /* Once a null is detected, we check each byte in that block for a
     precise position of the null.  */
  str = (char *) aligned_addr;
 4007910:	e0bfff17 	ldw	r2,-4(fp)
 4007914:	e0bffd15 	stw	r2,-12(fp)

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (*str)
 4007918:	00000306 	br	4007928 <strlen+0xc0>
    str++;
 400791c:	e0bffd17 	ldw	r2,-12(fp)
 4007920:	10800044 	addi	r2,r2,1
 4007924:	e0bffd15 	stw	r2,-12(fp)
  while (*str)
 4007928:	e0bffd17 	ldw	r2,-12(fp)
 400792c:	10800003 	ldbu	r2,0(r2)
 4007930:	10803fcc 	andi	r2,r2,255
 4007934:	1080201c 	xori	r2,r2,128
 4007938:	10bfe004 	addi	r2,r2,-128
 400793c:	103ff71e 	bne	r2,zero,400791c <strlen+0xb4>
  return str - start;
 4007940:	e0fffd17 	ldw	r3,-12(fp)
 4007944:	e0bffe17 	ldw	r2,-8(fp)
 4007948:	1885c83a 	sub	r2,r3,r2
}
 400794c:	e037883a 	mov	sp,fp
 4007950:	df000017 	ldw	fp,0(sp)
 4007954:	dec00104 	addi	sp,sp,4
 4007958:	f800283a 	ret

0400795c <__sbprintf>:
_NOINLINE_STATIC int
__sbprintf (struct _reent *rptr,
       register FILE *fp,
       const char *fmt,
       va_list ap)
{
 400795c:	defedf04 	addi	sp,sp,-1156
 4007960:	dfc12015 	stw	ra,1152(sp)
 4007964:	df011f15 	stw	fp,1148(sp)
 4007968:	dc011e15 	stw	r16,1144(sp)
 400796c:	df011f04 	addi	fp,sp,1148
 4007970:	e13ee315 	stw	r4,-1140(fp)
 4007974:	2821883a 	mov	r16,r5
 4007978:	e1bee215 	stw	r6,-1144(fp)
 400797c:	e1fee115 	stw	r7,-1148(fp)
	int ret;
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
 4007980:	80c0030b 	ldhu	r3,12(r16)
 4007984:	00bfff44 	movi	r2,-3
 4007988:	1884703a 	and	r2,r3,r2
 400798c:	e0bfe70d 	sth	r2,-100(fp)
	fake._flags2 = fp->_flags2;
 4007990:	80801917 	ldw	r2,100(r16)
 4007994:	e0bffd15 	stw	r2,-12(fp)
	fake._file = fp->_file;
 4007998:	8080038b 	ldhu	r2,14(r16)
 400799c:	e0bfe78d 	sth	r2,-98(fp)
	fake._cookie = fp->_cookie;
 40079a0:	80800717 	ldw	r2,28(r16)
 40079a4:	e0bfeb15 	stw	r2,-84(fp)
	fake._write = fp->_write;
 40079a8:	80800917 	ldw	r2,36(r16)
 40079ac:	e0bfed15 	stw	r2,-76(fp)

	/* set up the buffer */
	fake._bf._base = fake._p = buf;
 40079b0:	e0bee404 	addi	r2,fp,-1136
 40079b4:	e0bfe415 	stw	r2,-112(fp)
 40079b8:	e0bfe417 	ldw	r2,-112(fp)
 40079bc:	e0bfe815 	stw	r2,-96(fp)
	fake._bf._size = fake._w = sizeof (buf);
 40079c0:	00810004 	movi	r2,1024
 40079c4:	e0bfe615 	stw	r2,-104(fp)
 40079c8:	e0bfe617 	ldw	r2,-104(fp)
 40079cc:	e0bfe915 	stw	r2,-92(fp)
	fake._lbfsize = 0;	/* not actually used, but Just In Case */
 40079d0:	e03fea15 	stw	zero,-88(fp)
#ifndef __SINGLE_THREAD__
	__lock_init_recursive (fake._lock);
#endif

	/* do the work, then copy any error status */
	ret = _VFPRINTF_R (rptr, &fake, fmt, ap);
 40079d4:	e0bfe404 	addi	r2,fp,-112
 40079d8:	e1fee117 	ldw	r7,-1148(fp)
 40079dc:	e1bee217 	ldw	r6,-1144(fp)
 40079e0:	100b883a 	mov	r5,r2
 40079e4:	e13ee317 	ldw	r4,-1140(fp)
 40079e8:	4007a9c0 	call	4007a9c <___vfprintf_internal_r>
 40079ec:	e0bffe15 	stw	r2,-8(fp)
	if (ret >= 0 && _fflush_r (rptr, &fake))
 40079f0:	e0bffe17 	ldw	r2,-8(fp)
 40079f4:	10000716 	blt	r2,zero,4007a14 <__sbprintf+0xb8>
 40079f8:	e0bfe404 	addi	r2,fp,-112
 40079fc:	100b883a 	mov	r5,r2
 4007a00:	e13ee317 	ldw	r4,-1140(fp)
 4007a04:	400c3c80 	call	400c3c8 <_fflush_r>
 4007a08:	10000226 	beq	r2,zero,4007a14 <__sbprintf+0xb8>
		ret = EOF;
 4007a0c:	00bfffc4 	movi	r2,-1
 4007a10:	e0bffe15 	stw	r2,-8(fp)
	if (fake._flags & __SERR)
 4007a14:	e0bfe70b 	ldhu	r2,-100(fp)
 4007a18:	10bfffcc 	andi	r2,r2,65535
 4007a1c:	1080100c 	andi	r2,r2,64
 4007a20:	10000326 	beq	r2,zero,4007a30 <__sbprintf+0xd4>
		fp->_flags |= __SERR;
 4007a24:	8080030b 	ldhu	r2,12(r16)
 4007a28:	10801014 	ori	r2,r2,64
 4007a2c:	8080030d 	sth	r2,12(r16)

#ifndef __SINGLE_THREAD__
	__lock_close_recursive (fake._lock);
#endif
	return (ret);
 4007a30:	e0bffe17 	ldw	r2,-8(fp)
}
 4007a34:	e6ffff04 	addi	sp,fp,-4
 4007a38:	dfc00217 	ldw	ra,8(sp)
 4007a3c:	df000117 	ldw	fp,4(sp)
 4007a40:	dc000017 	ldw	r16,0(sp)
 4007a44:	dec00304 	addi	sp,sp,12
 4007a48:	f800283a 	ret

04007a4c <__vfprintf_internal>:
#ifndef STRING_ONLY
int
VFPRINTF (FILE * fp,
       const char *fmt0,
       va_list ap)
{
 4007a4c:	defffa04 	addi	sp,sp,-24
 4007a50:	dfc00515 	stw	ra,20(sp)
 4007a54:	df000415 	stw	fp,16(sp)
 4007a58:	df000404 	addi	fp,sp,16
 4007a5c:	e13ffe15 	stw	r4,-8(fp)
 4007a60:	e17ffd15 	stw	r5,-12(fp)
 4007a64:	e1bffc15 	stw	r6,-16(fp)
  int result;
  result = _VFPRINTF_R (_REENT, fp, fmt0, ap);
 4007a68:	d0a00117 	ldw	r2,-32764(gp)
 4007a6c:	e1fffc17 	ldw	r7,-16(fp)
 4007a70:	e1bffd17 	ldw	r6,-12(fp)
 4007a74:	e17ffe17 	ldw	r5,-8(fp)
 4007a78:	1009883a 	mov	r4,r2
 4007a7c:	4007a9c0 	call	4007a9c <___vfprintf_internal_r>
 4007a80:	e0bfff15 	stw	r2,-4(fp)
  return result;
 4007a84:	e0bfff17 	ldw	r2,-4(fp)
}
 4007a88:	e037883a 	mov	sp,fp
 4007a8c:	dfc00117 	ldw	ra,4(sp)
 4007a90:	df000017 	ldw	fp,0(sp)
 4007a94:	dec00204 	addi	sp,sp,8
 4007a98:	f800283a 	ret

04007a9c <___vfprintf_internal_r>:
int
_VFPRINTF_R (struct _reent *data,
       FILE * fp,
       const char *fmt0,
       va_list ap)
{
 4007a9c:	deffa804 	addi	sp,sp,-352
 4007aa0:	dfc05715 	stw	ra,348(sp)
 4007aa4:	df005615 	stw	fp,344(sp)
 4007aa8:	ddc05515 	stw	r23,340(sp)
 4007aac:	dd805415 	stw	r22,336(sp)
 4007ab0:	dd405315 	stw	r21,332(sp)
 4007ab4:	dd005215 	stw	r20,328(sp)
 4007ab8:	dcc05115 	stw	r19,324(sp)
 4007abc:	dc805015 	stw	r18,320(sp)
 4007ac0:	dc404f15 	stw	r17,316(sp)
 4007ac4:	dc004e15 	stw	r16,312(sp)
 4007ac8:	df005604 	addi	fp,sp,344
 4007acc:	e13fbd15 	stw	r4,-268(fp)
 4007ad0:	e17fbc15 	stw	r5,-272(fp)
 4007ad4:	e1bfbb15 	stw	r6,-276(fp)
 4007ad8:	e1ffba15 	stw	r7,-280(fp)
	char *thousands_sep = NULL;
	size_t thsnd_len = 0;
	const char *grouping = NULL;
#endif
#ifdef FLOATING_POINT
	char *decimal_point = _localeconv_r (data)->decimal_point;
 4007adc:	e13fbd17 	ldw	r4,-268(fp)
 4007ae0:	400da880 	call	400da88 <_localeconv_r>
 4007ae4:	10800017 	ldw	r2,0(r2)
 4007ae8:	e0bfe815 	stw	r2,-96(fp)
	size_t decp_len = strlen (decimal_point);
 4007aec:	e13fe817 	ldw	r4,-96(fp)
 4007af0:	40078680 	call	4007868 <strlen>
 4007af4:	e0bfe715 	stw	r2,-100(fp)
	char softsign;		/* temporary negative sign for floats */
	union { int i; _PRINTF_FLOAT_TYPE fp; } _double_ = {0};
 4007af8:	e03fe015 	stw	zero,-128(fp)
 4007afc:	e03fe115 	stw	zero,-124(fp)
# define _fpvalue (_double_.fp)
	int expt;		/* integer value of exponent */
	int expsize = 0;	/* character count for expstr */
 4007b00:	e03ff415 	stw	zero,-48(fp)
	char expstr[MAXEXPLEN];	/* buffer for exponent string */
	int lead;		/* sig figs before decimal or group sep */
#endif /* FLOATING_POINT */
#if defined (FLOATING_POINT) || defined (_WANT_IO_C99_FORMATS)
	int ndig = 0;		/* actual number of digits returned by cvt */
 4007b04:	e03fdc15 	stw	zero,-144(fp)
	u_quad_t _uquad;	/* integer arguments %[diouxX] */
	enum { OCT, DEC, HEX } base;/* base for [diouxX] conversion */
	int dprec;		/* a copy of prec if [diouxX], 0 otherwise */
	int realsz;		/* field size expanded by dprec */
	int size;		/* size of converted field or string */
	char *xdigs = NULL;	/* digits for [xX] conversion */
 4007b08:	e03fec15 	stw	zero,-80(fp)
	char ox[2];		/* space for 0x hex-prefix */
#ifdef _MB_CAPABLE
	wchar_t wc;
	mbstate_t state;        /* mbtowc calls from library must not change state */
#endif
	char *malloc_buf = NULL;/* handy pointer for malloced buffers */
 4007b0c:	e03feb15 	stw	zero,-84(fp)
	    (u_long)GET_ARG (N, ap, u_int))
#endif

#ifndef STRING_ONLY
	/* Initialize std streams if not dealing with sprintf family.  */
	CHECK_INIT (data, fp);
 4007b10:	e0bfbd17 	ldw	r2,-268(fp)
 4007b14:	e0bfe615 	stw	r2,-104(fp)
 4007b18:	e0bfe617 	ldw	r2,-104(fp)
 4007b1c:	10000526 	beq	r2,zero,4007b34 <___vfprintf_internal_r+0x98>
 4007b20:	e0bfe617 	ldw	r2,-104(fp)
 4007b24:	10800e17 	ldw	r2,56(r2)
 4007b28:	1000021e 	bne	r2,zero,4007b34 <___vfprintf_internal_r+0x98>
 4007b2c:	e13fe617 	ldw	r4,-104(fp)
 4007b30:	400c9100 	call	400c910 <__sinit>
	_newlib_flockfile_start (fp);

	ORIENT(fp, -1);
 4007b34:	e0bfbc17 	ldw	r2,-272(fp)
 4007b38:	1080030b 	ldhu	r2,12(r2)
 4007b3c:	10bfffcc 	andi	r2,r2,65535
 4007b40:	1088000c 	andi	r2,r2,8192
 4007b44:	10000c1e 	bne	r2,zero,4007b78 <___vfprintf_internal_r+0xdc>
 4007b48:	e0bfbc17 	ldw	r2,-272(fp)
 4007b4c:	1080030b 	ldhu	r2,12(r2)
 4007b50:	10880014 	ori	r2,r2,8192
 4007b54:	1007883a 	mov	r3,r2
 4007b58:	e0bfbc17 	ldw	r2,-272(fp)
 4007b5c:	10c0030d 	sth	r3,12(r2)
 4007b60:	e0bfbc17 	ldw	r2,-272(fp)
 4007b64:	10c01917 	ldw	r3,100(r2)
 4007b68:	00b7ffc4 	movi	r2,-8193
 4007b6c:	1886703a 	and	r3,r3,r2
 4007b70:	e0bfbc17 	ldw	r2,-272(fp)
 4007b74:	10c01915 	stw	r3,100(r2)

	/* sorry, fprintf(read_only_file, "") returns EOF, not 0 */
	if (cantwrite (data, fp)) {
 4007b78:	e0bfbc17 	ldw	r2,-272(fp)
 4007b7c:	1080030b 	ldhu	r2,12(r2)
 4007b80:	10bfffcc 	andi	r2,r2,65535
 4007b84:	1080020c 	andi	r2,r2,8
 4007b88:	10000326 	beq	r2,zero,4007b98 <___vfprintf_internal_r+0xfc>
 4007b8c:	e0bfbc17 	ldw	r2,-272(fp)
 4007b90:	10800417 	ldw	r2,16(r2)
 4007b94:	1000061e 	bne	r2,zero,4007bb0 <___vfprintf_internal_r+0x114>
 4007b98:	e17fbc17 	ldw	r5,-272(fp)
 4007b9c:	e13fbd17 	ldw	r4,-268(fp)
 4007ba0:	4009f4c0 	call	4009f4c <__swsetup_r>
 4007ba4:	10000226 	beq	r2,zero,4007bb0 <___vfprintf_internal_r+0x114>
		_newlib_flockfile_exit (fp);
		return (EOF);
 4007ba8:	00bfffc4 	movi	r2,-1
 4007bac:	00080606 	br	4009bc8 <___vfprintf_internal_r+0x212c>
	}

#ifdef _UNBUF_STREAM_OPT
	/* optimise fprintf(stderr) (and other unbuffered Unix files) */
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
 4007bb0:	e0bfbc17 	ldw	r2,-272(fp)
 4007bb4:	1080030b 	ldhu	r2,12(r2)
 4007bb8:	10bfffcc 	andi	r2,r2,65535
 4007bbc:	1080068c 	andi	r2,r2,26
 4007bc0:	10800298 	cmpnei	r2,r2,10
 4007bc4:	10000d1e 	bne	r2,zero,4007bfc <___vfprintf_internal_r+0x160>
	    fp->_file >= 0) {
 4007bc8:	e0bfbc17 	ldw	r2,-272(fp)
 4007bcc:	1080038b 	ldhu	r2,14(r2)
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
 4007bd0:	10bfffcc 	andi	r2,r2,65535
 4007bd4:	10a0001c 	xori	r2,r2,32768
 4007bd8:	10a00004 	addi	r2,r2,-32768
 4007bdc:	10000716 	blt	r2,zero,4007bfc <___vfprintf_internal_r+0x160>
		_newlib_flockfile_exit (fp);
		return (__sbprintf (data, fp, fmt0, ap));
 4007be0:	e0bfba17 	ldw	r2,-280(fp)
 4007be4:	100f883a 	mov	r7,r2
 4007be8:	e1bfbb17 	ldw	r6,-276(fp)
 4007bec:	e17fbc17 	ldw	r5,-272(fp)
 4007bf0:	e13fbd17 	ldw	r4,-268(fp)
 4007bf4:	400795c0 	call	400795c <__sbprintf>
 4007bf8:	0007f306 	br	4009bc8 <___vfprintf_internal_r+0x212c>
		}
		fp->_bf._size = 64;
        }
#endif /* STRING_ONLY */

	fmt = (char *)fmt0;
 4007bfc:	e57fbb17 	ldw	r21,-276(fp)
#ifdef _FVWRITE_IN_STREAMIO
	uio.uio_iov = iovp = iov;
 4007c00:	e43fc904 	addi	r16,fp,-220
 4007c04:	e43fd915 	stw	r16,-156(fp)
	uio.uio_resid = 0;
 4007c08:	e03fdb15 	stw	zero,-148(fp)
	uio.uio_iovcnt = 0;
 4007c0c:	e03fda15 	stw	zero,-152(fp)
#endif
	ret = 0;
 4007c10:	e03ff715 	stw	zero,-36(fp)

	/*
	 * Scan the format for conversions (`%' character).
	 */
	for (;;) {
	        cp = fmt;
 4007c14:	a825883a 	mov	r18,r21
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
 4007c18:	00000106 	br	4007c20 <___vfprintf_internal_r+0x184>
                    fmt += 1;
 4007c1c:	ad400044 	addi	r21,r21,1
                while (*fmt != '\0' && *fmt != '%')
 4007c20:	a8800003 	ldbu	r2,0(r21)
 4007c24:	10803fcc 	andi	r2,r2,255
 4007c28:	1080201c 	xori	r2,r2,128
 4007c2c:	10bfe004 	addi	r2,r2,-128
 4007c30:	10000626 	beq	r2,zero,4007c4c <___vfprintf_internal_r+0x1b0>
 4007c34:	a8800003 	ldbu	r2,0(r21)
 4007c38:	10803fcc 	andi	r2,r2,255
 4007c3c:	1080201c 	xori	r2,r2,128
 4007c40:	10bfe004 	addi	r2,r2,-128
 4007c44:	10800958 	cmpnei	r2,r2,37
 4007c48:	103ff41e 	bne	r2,zero,4007c1c <___vfprintf_internal_r+0x180>
#endif
		if ((m = fmt - cp) != 0) {
 4007c4c:	aca3c83a 	sub	r17,r21,r18
 4007c50:	88001826 	beq	r17,zero,4007cb4 <___vfprintf_internal_r+0x218>
			PRINT (cp, m);
 4007c54:	84800015 	stw	r18,0(r16)
 4007c58:	8805883a 	mov	r2,r17
 4007c5c:	80800115 	stw	r2,4(r16)
 4007c60:	e0bfdb17 	ldw	r2,-148(fp)
 4007c64:	8807883a 	mov	r3,r17
 4007c68:	10c5883a 	add	r2,r2,r3
 4007c6c:	e0bfdb15 	stw	r2,-148(fp)
 4007c70:	84000204 	addi	r16,r16,8
 4007c74:	e0bfda17 	ldw	r2,-152(fp)
 4007c78:	10800044 	addi	r2,r2,1
 4007c7c:	e0bfda15 	stw	r2,-152(fp)
 4007c80:	e0bfda17 	ldw	r2,-152(fp)
 4007c84:	10800210 	cmplti	r2,r2,8
 4007c88:	1000071e 	bne	r2,zero,4007ca8 <___vfprintf_internal_r+0x20c>
 4007c8c:	e0bfd904 	addi	r2,fp,-156
 4007c90:	100d883a 	mov	r6,r2
 4007c94:	e17fbc17 	ldw	r5,-272(fp)
 4007c98:	e13fbd17 	ldw	r4,-268(fp)
 4007c9c:	4011aac0 	call	4011aac <__sprint_r>
 4007ca0:	1007731e 	bne	r2,zero,4009a70 <___vfprintf_internal_r+0x1fd4>
 4007ca4:	e43fc904 	addi	r16,fp,-220
			ret += m;
 4007ca8:	e0bff717 	ldw	r2,-36(fp)
 4007cac:	1445883a 	add	r2,r2,r17
 4007cb0:	e0bff715 	stw	r2,-36(fp)
		}
#ifdef _MB_CAPABLE
		if (n <= 0)
                    goto done;
#else
                if (*fmt == '\0')
 4007cb4:	a8800003 	ldbu	r2,0(r21)
 4007cb8:	10803fcc 	andi	r2,r2,255
 4007cbc:	1080201c 	xori	r2,r2,128
 4007cc0:	10bfe004 	addi	r2,r2,-128
 4007cc4:	10075c26 	beq	r2,zero,4009a38 <___vfprintf_internal_r+0x1f9c>
                    goto done;
#endif
		fmt_anchor = fmt;
 4007cc8:	e57fe515 	stw	r21,-108(fp)
		fmt++;		/* skip over '%' */
 4007ccc:	ad400044 	addi	r21,r21,1

		flags = 0;
 4007cd0:	0023883a 	mov	r17,zero
		dprec = 0;
 4007cd4:	e03fef15 	stw	zero,-68(fp)
		width = 0;
 4007cd8:	e03ff615 	stw	zero,-40(fp)
		prec = -1;
 4007cdc:	00bfffc4 	movi	r2,-1
 4007ce0:	e0bff515 	stw	r2,-44(fp)
		sign = '\0';
 4007ce4:	e03fe2c5 	stb	zero,-117(fp)
#ifdef FLOATING_POINT
		lead = 0;
 4007ce8:	e03ff315 	stw	zero,-52(fp)
#ifndef _NO_POS_ARGS
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
 4007cec:	a805883a 	mov	r2,r21
 4007cf0:	15400044 	addi	r21,r2,1
 4007cf4:	10800003 	ldbu	r2,0(r2)
 4007cf8:	15003fcc 	andi	r20,r2,255
 4007cfc:	a500201c 	xori	r20,r20,128
 4007d00:	a53fe004 	addi	r20,r20,-128
 4007d04:	a0bff804 	addi	r2,r20,-32
 4007d08:	10c01668 	cmpgeui	r3,r2,89
 4007d0c:	1803731e 	bne	r3,zero,4008adc <___vfprintf_internal_r+0x1040>
 4007d10:	100690ba 	slli	r3,r2,2
 4007d14:	00810034 	movhi	r2,1024
 4007d18:	1885883a 	add	r2,r3,r2
 4007d1c:	109f4917 	ldw	r2,32036(r2)
 4007d20:	1000683a 	jmp	r2
 4007d24:	04007e88 	cmpgei	r16,zero,506
 4007d28:	04008adc 	xori	r16,zero,555
 4007d2c:	04008adc 	xori	r16,zero,555
 4007d30:	04007ea8 	cmpgeui	r16,zero,506
 4007d34:	04008adc 	xori	r16,zero,555
 4007d38:	04008adc 	xori	r16,zero,555
 4007d3c:	04008adc 	xori	r16,zero,555
 4007d40:	04008adc 	xori	r16,zero,555
 4007d44:	04008adc 	xori	r16,zero,555
 4007d48:	04008adc 	xori	r16,zero,555
 4007d4c:	04007eb0 	cmpltui	r16,zero,506
 4007d50:	04007ee4 	muli	r16,zero,507
 4007d54:	04008adc 	xori	r16,zero,555
 4007d58:	04007edc 	xori	r16,zero,507
 4007d5c:	04007ef0 	cmpltui	r16,zero,507
 4007d60:	04008adc 	xori	r16,zero,555
 4007d64:	04007f94 	movui	r16,510
 4007d68:	04007f9c 	xori	r16,zero,510
 4007d6c:	04007f9c 	xori	r16,zero,510
 4007d70:	04007f9c 	xori	r16,zero,510
 4007d74:	04007f9c 	xori	r16,zero,510
 4007d78:	04007f9c 	xori	r16,zero,510
 4007d7c:	04007f9c 	xori	r16,zero,510
 4007d80:	04007f9c 	xori	r16,zero,510
 4007d84:	04007f9c 	xori	r16,zero,510
 4007d88:	04007f9c 	xori	r16,zero,510
 4007d8c:	04008adc 	xori	r16,zero,555
 4007d90:	04008adc 	xori	r16,zero,555
 4007d94:	04008adc 	xori	r16,zero,555
 4007d98:	04008adc 	xori	r16,zero,555
 4007d9c:	04008adc 	xori	r16,zero,555
 4007da0:	04008adc 	xori	r16,zero,555
 4007da4:	04008adc 	xori	r16,zero,555
 4007da8:	04008adc 	xori	r16,zero,555
 4007dac:	04008adc 	xori	r16,zero,555
 4007db0:	04008adc 	xori	r16,zero,555
 4007db4:	04008054 	movui	r16,513
 4007db8:	04008154 	movui	r16,517
 4007dbc:	04008adc 	xori	r16,zero,555
 4007dc0:	04008154 	movui	r16,517
 4007dc4:	04008adc 	xori	r16,zero,555
 4007dc8:	04008adc 	xori	r16,zero,555
 4007dcc:	04008adc 	xori	r16,zero,555
 4007dd0:	04008adc 	xori	r16,zero,555
 4007dd4:	04007fe8 	cmpgeui	r16,zero,511
 4007dd8:	04008adc 	xori	r16,zero,555
 4007ddc:	04008adc 	xori	r16,zero,555
 4007de0:	04008594 	movui	r16,534
 4007de4:	04008adc 	xori	r16,zero,555
 4007de8:	04008adc 	xori	r16,zero,555
 4007dec:	04008adc 	xori	r16,zero,555
 4007df0:	04008adc 	xori	r16,zero,555
 4007df4:	04008adc 	xori	r16,zero,555
 4007df8:	04008700 	call	400870 <__alt_mem_dram-0x3bff790>
 4007dfc:	04008adc 	xori	r16,zero,555
 4007e00:	04008adc 	xori	r16,zero,555
 4007e04:	040087ac 	andhi	r16,zero,542
 4007e08:	04008adc 	xori	r16,zero,555
 4007e0c:	04008adc 	xori	r16,zero,555
 4007e10:	04008adc 	xori	r16,zero,555
 4007e14:	04008adc 	xori	r16,zero,555
 4007e18:	04008adc 	xori	r16,zero,555
 4007e1c:	04008adc 	xori	r16,zero,555
 4007e20:	04008adc 	xori	r16,zero,555
 4007e24:	04008adc 	xori	r16,zero,555
 4007e28:	04008adc 	xori	r16,zero,555
 4007e2c:	04008adc 	xori	r16,zero,555
 4007e30:	0400802c 	andhi	r16,zero,512
 4007e34:	04008058 	cmpnei	r16,zero,513
 4007e38:	04008154 	movui	r16,517
 4007e3c:	04008154 	movui	r16,517
 4007e40:	04008154 	movui	r16,517
 4007e44:	04007ff0 	cmpltui	r16,zero,511
 4007e48:	04008058 	cmpnei	r16,zero,513
 4007e4c:	04008adc 	xori	r16,zero,555
 4007e50:	04008adc 	xori	r16,zero,555
 4007e54:	04007ff8 	rdprs	r16,zero,511
 4007e58:	04008adc 	xori	r16,zero,555
 4007e5c:	040084f4 	movhi	r16,531
 4007e60:	04008598 	cmpnei	r16,zero,534
 4007e64:	0400862c 	andhi	r16,zero,536
 4007e68:	04008024 	muli	r16,zero,512
 4007e6c:	04008adc 	xori	r16,zero,555
 4007e70:	04008674 	movhi	r16,537
 4007e74:	04008adc 	xori	r16,zero,555
 4007e78:	04008704 	movi	r16,540
 4007e7c:	04008adc 	xori	r16,zero,555
 4007e80:	04008adc 	xori	r16,zero,555
 4007e84:	040087bc 	xorhi	r16,zero,542
			/*
			 * ``If the space and + flags both appear, the space
			 * flag will be ignored.''
			 *	-- ANSI X3J11
			 */
			if (!sign)
 4007e88:	e0bfe2c3 	ldbu	r2,-117(fp)
 4007e8c:	10803fcc 	andi	r2,r2,255
 4007e90:	1080201c 	xori	r2,r2,128
 4007e94:	10bfe004 	addi	r2,r2,-128
 4007e98:	103f941e 	bne	r2,zero,4007cec <___vfprintf_internal_r+0x250>
				sign = ' ';
 4007e9c:	00800804 	movi	r2,32
 4007ea0:	e0bfe2c5 	stb	r2,-117(fp)
			goto rflag;
 4007ea4:	003f9106 	br	4007cec <___vfprintf_internal_r+0x250>
		case '#':
			flags |= ALT;
 4007ea8:	8c400054 	ori	r17,r17,1
			goto rflag;
 4007eac:	003f8f06 	br	4007cec <___vfprintf_internal_r+0x250>
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
 4007eb0:	e0bfba17 	ldw	r2,-280(fp)
 4007eb4:	10c00104 	addi	r3,r2,4
 4007eb8:	e0ffba15 	stw	r3,-280(fp)
 4007ebc:	10800017 	ldw	r2,0(r2)
 4007ec0:	e0bff615 	stw	r2,-40(fp)
#ifndef _NO_POS_ARGS
			is_pos_arg = old_is_pos_arg;
#endif
			if (width >= 0)
 4007ec4:	e0bff617 	ldw	r2,-40(fp)
 4007ec8:	10000116 	blt	r2,zero,4007ed0 <___vfprintf_internal_r+0x434>
				goto rflag;
 4007ecc:	003f8706 	br	4007cec <___vfprintf_internal_r+0x250>
			width = -width;
 4007ed0:	e0bff617 	ldw	r2,-40(fp)
 4007ed4:	0085c83a 	sub	r2,zero,r2
 4007ed8:	e0bff615 	stw	r2,-40(fp)
			/* FALLTHROUGH */
		case '-':
			flags |= LADJUST;
 4007edc:	8c400114 	ori	r17,r17,4
			goto rflag;
 4007ee0:	003f8206 	br	4007cec <___vfprintf_internal_r+0x250>
		case '+':
			sign = '+';
 4007ee4:	00800ac4 	movi	r2,43
 4007ee8:	e0bfe2c5 	stb	r2,-117(fp)
			goto rflag;
 4007eec:	003f7f06 	br	4007cec <___vfprintf_internal_r+0x250>
		case '.':
			if ((ch = *fmt++) == '*') {
 4007ef0:	a805883a 	mov	r2,r21
 4007ef4:	15400044 	addi	r21,r2,1
 4007ef8:	10800003 	ldbu	r2,0(r2)
 4007efc:	15003fcc 	andi	r20,r2,255
 4007f00:	a500201c 	xori	r20,r20,128
 4007f04:	a53fe004 	addi	r20,r20,-128
 4007f08:	a0800a98 	cmpnei	r2,r20,42
 4007f0c:	10000a1e 	bne	r2,zero,4007f38 <___vfprintf_internal_r+0x49c>
						fmt = old_fmt;
						goto rflag;
					}
				}
#endif /* !_NO_POS_ARGS */
				prec = GET_ARG (n, ap, int);
 4007f10:	e0bfba17 	ldw	r2,-280(fp)
 4007f14:	10c00104 	addi	r3,r2,4
 4007f18:	e0ffba15 	stw	r3,-280(fp)
 4007f1c:	10800017 	ldw	r2,0(r2)
 4007f20:	e0bff515 	stw	r2,-44(fp)
#ifndef _NO_POS_ARGS
				is_pos_arg = old_is_pos_arg;
#endif
				if (prec < 0)
 4007f24:	e0bff517 	ldw	r2,-44(fp)
 4007f28:	103f700e 	bge	r2,zero,4007cec <___vfprintf_internal_r+0x250>
					prec = -1;
 4007f2c:	00bfffc4 	movi	r2,-1
 4007f30:	e0bff515 	stw	r2,-44(fp)
				goto rflag;
 4007f34:	003f6d06 	br	4007cec <___vfprintf_internal_r+0x250>
			}
			n = 0;
 4007f38:	0027883a 	mov	r19,zero
			while (is_digit (ch)) {
 4007f3c:	00000d06 	br	4007f74 <___vfprintf_internal_r+0x4d8>
				n = 10 * n + to_digit (ch);
 4007f40:	9805883a 	mov	r2,r19
 4007f44:	100490ba 	slli	r2,r2,2
 4007f48:	14c5883a 	add	r2,r2,r19
 4007f4c:	1085883a 	add	r2,r2,r2
 4007f50:	1007883a 	mov	r3,r2
 4007f54:	a0bff404 	addi	r2,r20,-48
 4007f58:	18a7883a 	add	r19,r3,r2
				ch = *fmt++;
 4007f5c:	a805883a 	mov	r2,r21
 4007f60:	15400044 	addi	r21,r2,1
 4007f64:	10800003 	ldbu	r2,0(r2)
 4007f68:	15003fcc 	andi	r20,r2,255
 4007f6c:	a500201c 	xori	r20,r20,128
 4007f70:	a53fe004 	addi	r20,r20,-128
			while (is_digit (ch)) {
 4007f74:	a0bff404 	addi	r2,r20,-48
 4007f78:	108002b0 	cmpltui	r2,r2,10
 4007f7c:	103ff01e 	bne	r2,zero,4007f40 <___vfprintf_internal_r+0x4a4>
			}
			prec = n < 0 ? -1 : n;
 4007f80:	9805883a 	mov	r2,r19
 4007f84:	1000010e 	bge	r2,zero,4007f8c <___vfprintf_internal_r+0x4f0>
 4007f88:	00bfffc4 	movi	r2,-1
 4007f8c:	e0bff515 	stw	r2,-44(fp)
			goto reswitch;
 4007f90:	003f5c06 	br	4007d04 <___vfprintf_internal_r+0x268>
			/*
			 * ``Note that 0 is taken as a flag, not as the
			 * beginning of a field width.''
			 *	-- ANSI X3J11
			 */
			flags |= ZEROPAD;
 4007f94:	8c402014 	ori	r17,r17,128
			goto rflag;
 4007f98:	003f5406 	br	4007cec <___vfprintf_internal_r+0x250>
		case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
 4007f9c:	0027883a 	mov	r19,zero
			do {
				n = 10 * n + to_digit (ch);
 4007fa0:	9805883a 	mov	r2,r19
 4007fa4:	100490ba 	slli	r2,r2,2
 4007fa8:	14c5883a 	add	r2,r2,r19
 4007fac:	1085883a 	add	r2,r2,r2
 4007fb0:	1007883a 	mov	r3,r2
 4007fb4:	a0bff404 	addi	r2,r20,-48
 4007fb8:	18a7883a 	add	r19,r3,r2
				ch = *fmt++;
 4007fbc:	a805883a 	mov	r2,r21
 4007fc0:	15400044 	addi	r21,r2,1
 4007fc4:	10800003 	ldbu	r2,0(r2)
 4007fc8:	15003fcc 	andi	r20,r2,255
 4007fcc:	a500201c 	xori	r20,r20,128
 4007fd0:	a53fe004 	addi	r20,r20,-128
			} while (is_digit (ch));
 4007fd4:	a0bff404 	addi	r2,r20,-48
 4007fd8:	108002b0 	cmpltui	r2,r2,10
 4007fdc:	103ff01e 	bne	r2,zero,4007fa0 <___vfprintf_internal_r+0x504>
				}
				else
					goto error;
			}
#endif /* !_NO_POS_ARGS */
			width = n;
 4007fe0:	e4fff615 	stw	r19,-40(fp)
			goto reswitch;
 4007fe4:	003f4706 	br	4007d04 <___vfprintf_internal_r+0x268>
#ifdef FLOATING_POINT
		case 'L':
			flags |= LONGDBL;
 4007fe8:	8c400214 	ori	r17,r17,8
			goto rflag;
 4007fec:	003f3f06 	br	4007cec <___vfprintf_internal_r+0x250>
			if (*fmt == 'h') {
				fmt++;
				flags |= CHARINT;
			} else
#endif
				flags |= SHORTINT;
 4007ff0:	8c401014 	ori	r17,r17,64
			goto rflag;
 4007ff4:	003f3d06 	br	4007cec <___vfprintf_internal_r+0x250>
		case 'l':
#if defined _WANT_IO_C99_FORMATS || !defined _NO_LONGLONG
			if (*fmt == 'l') {
 4007ff8:	a8800003 	ldbu	r2,0(r21)
 4007ffc:	10803fcc 	andi	r2,r2,255
 4008000:	1080201c 	xori	r2,r2,128
 4008004:	10bfe004 	addi	r2,r2,-128
 4008008:	10801b18 	cmpnei	r2,r2,108
 400800c:	1000031e 	bne	r2,zero,400801c <___vfprintf_internal_r+0x580>
				fmt++;
 4008010:	ad400044 	addi	r21,r21,1
				flags |= QUADINT;
 4008014:	8c400814 	ori	r17,r17,32
 4008018:	003f3406 	br	4007cec <___vfprintf_internal_r+0x250>
			} else
#endif
				flags |= LONGINT;
 400801c:	8c400414 	ori	r17,r17,16
			goto rflag;
 4008020:	003f3206 	br	4007cec <___vfprintf_internal_r+0x250>
		case 'q': /* extension */
			flags |= QUADINT;
 4008024:	8c400814 	ori	r17,r17,32
			goto rflag;
 4008028:	003f3006 	br	4007cec <___vfprintf_internal_r+0x250>
		    flags |= QUADINT;
		  goto rflag;
		case 'C':
#endif /* _WANT_IO_C99_FORMATS */
		case 'c':
			cp = buf;
 400802c:	e4bfbf04 	addi	r18,fp,-260
				}
			}
			else
#endif /* _MB_CAPABLE */
			{
				*cp = GET_ARG (N, ap, int);
 4008030:	e0bfba17 	ldw	r2,-280(fp)
 4008034:	10c00104 	addi	r3,r2,4
 4008038:	e0ffba15 	stw	r3,-280(fp)
 400803c:	10800017 	ldw	r2,0(r2)
 4008040:	90800005 	stb	r2,0(r18)
				size = 1;
 4008044:	00800044 	movi	r2,1
 4008048:	e0bfed15 	stw	r2,-76(fp)
			}
			sign = '\0';
 400804c:	e03fe2c5 	stb	zero,-117(fp)
			break;
 4008050:	0002ab06 	br	4008b00 <___vfprintf_internal_r+0x1064>
		case 'D':  /* extension */
			flags |= LONGINT;
 4008054:	8c400414 	ori	r17,r17,16
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			_uquad = SARG ();
 4008058:	8880080c 	andi	r2,r17,32
 400805c:	10000826 	beq	r2,zero,4008080 <___vfprintf_internal_r+0x5e4>
 4008060:	e13fba17 	ldw	r4,-280(fp)
 4008064:	20800204 	addi	r2,r4,8
 4008068:	e0bfba15 	stw	r2,-280(fp)
 400806c:	20800017 	ldw	r2,0(r4)
 4008070:	20c00117 	ldw	r3,4(r4)
 4008074:	e0bfb815 	stw	r2,-288(fp)
 4008078:	e0ffb915 	stw	r3,-284(fp)
 400807c:	00001e06 	br	40080f8 <___vfprintf_internal_r+0x65c>
 4008080:	8880040c 	andi	r2,r17,16
 4008084:	10000826 	beq	r2,zero,40080a8 <___vfprintf_internal_r+0x60c>
 4008088:	e0bfba17 	ldw	r2,-280(fp)
 400808c:	10c00104 	addi	r3,r2,4
 4008090:	e0ffba15 	stw	r3,-280(fp)
 4008094:	10800017 	ldw	r2,0(r2)
 4008098:	e0bfb815 	stw	r2,-288(fp)
 400809c:	1005d7fa 	srai	r2,r2,31
 40080a0:	e0bfb915 	stw	r2,-284(fp)
 40080a4:	00001406 	br	40080f8 <___vfprintf_internal_r+0x65c>
 40080a8:	8880100c 	andi	r2,r17,64
 40080ac:	10000b26 	beq	r2,zero,40080dc <___vfprintf_internal_r+0x640>
 40080b0:	e0bfba17 	ldw	r2,-280(fp)
 40080b4:	10c00104 	addi	r3,r2,4
 40080b8:	e0ffba15 	stw	r3,-280(fp)
 40080bc:	10800017 	ldw	r2,0(r2)
 40080c0:	10bfffcc 	andi	r2,r2,65535
 40080c4:	10a0001c 	xori	r2,r2,32768
 40080c8:	10a00004 	addi	r2,r2,-32768
 40080cc:	e0bfb815 	stw	r2,-288(fp)
 40080d0:	1005d7fa 	srai	r2,r2,31
 40080d4:	e0bfb915 	stw	r2,-284(fp)
 40080d8:	00000706 	br	40080f8 <___vfprintf_internal_r+0x65c>
 40080dc:	e0bfba17 	ldw	r2,-280(fp)
 40080e0:	10c00104 	addi	r3,r2,4
 40080e4:	e0ffba15 	stw	r3,-280(fp)
 40080e8:	10800017 	ldw	r2,0(r2)
 40080ec:	e0bfb815 	stw	r2,-288(fp)
 40080f0:	1005d7fa 	srai	r2,r2,31
 40080f4:	e0bfb915 	stw	r2,-284(fp)
 40080f8:	e0bfb817 	ldw	r2,-288(fp)
 40080fc:	e0bff115 	stw	r2,-60(fp)
 4008100:	e0bfb917 	ldw	r2,-284(fp)
 4008104:	e0bff215 	stw	r2,-56(fp)
#ifndef _NO_LONGLONG
			if ((quad_t)_uquad < 0)
 4008108:	e0bff117 	ldw	r2,-60(fp)
 400810c:	e0fff217 	ldw	r3,-56(fp)
 4008110:	18000d0e 	bge	r3,zero,4008148 <___vfprintf_internal_r+0x6ac>
#else
			if ((long) _uquad < 0)
#endif
			{

				_uquad = -_uquad;
 4008114:	000d883a 	mov	r6,zero
 4008118:	000f883a 	mov	r7,zero
 400811c:	e13ff117 	ldw	r4,-60(fp)
 4008120:	e17ff217 	ldw	r5,-56(fp)
 4008124:	3105c83a 	sub	r2,r6,r4
 4008128:	3091803a 	cmpltu	r8,r6,r2
 400812c:	3947c83a 	sub	r3,r7,r5
 4008130:	1a09c83a 	sub	r4,r3,r8
 4008134:	2007883a 	mov	r3,r4
 4008138:	e0bff115 	stw	r2,-60(fp)
 400813c:	e0fff215 	stw	r3,-56(fp)
				sign = '-';
 4008140:	00800b44 	movi	r2,45
 4008144:	e0bfe2c5 	stb	r2,-117(fp)
			}
			base = DEC;
 4008148:	00800044 	movi	r2,1
 400814c:	e0bff015 	stw	r2,-64(fp)
			goto number;
 4008150:	0001d406 	br	40088a4 <___vfprintf_internal_r+0xe08>
		case 'E':
		case 'f':
		case 'g':
		case 'G':
# ifdef _NO_LONGDBL
			if (flags & LONGDBL) {
 4008154:	8880020c 	andi	r2,r17,8
 4008158:	10000826 	beq	r2,zero,400817c <___vfprintf_internal_r+0x6e0>
				_fpvalue = (double) GET_ARG (N, ap, _LONG_DOUBLE);
 400815c:	e13fba17 	ldw	r4,-280(fp)
 4008160:	20800204 	addi	r2,r4,8
 4008164:	e0bfba15 	stw	r2,-280(fp)
 4008168:	20800017 	ldw	r2,0(r4)
 400816c:	20c00117 	ldw	r3,4(r4)
 4008170:	e0bfe015 	stw	r2,-128(fp)
 4008174:	e0ffe115 	stw	r3,-124(fp)
 4008178:	00000706 	br	4008198 <___vfprintf_internal_r+0x6fc>
			} else {
				_fpvalue = GET_ARG (N, ap, double);
 400817c:	e13fba17 	ldw	r4,-280(fp)
 4008180:	20800204 	addi	r2,r4,8
 4008184:	e0bfba15 	stw	r2,-280(fp)
 4008188:	20800017 	ldw	r2,0(r4)
 400818c:	20c00117 	ldw	r3,4(r4)
 4008190:	e0bfe015 	stw	r2,-128(fp)
 4008194:	e0ffe115 	stw	r3,-124(fp)

			   If the output is infinite or NaN, leading
			   zeros are not permitted.  Otherwise, scanf
			   could not read what printf wrote.
			 */
			if (isinf (_fpvalue)) {
 4008198:	e0bfe017 	ldw	r2,-128(fp)
 400819c:	e0ffe117 	ldw	r3,-124(fp)
 40081a0:	e0bfb215 	stw	r2,-312(fp)
 40081a4:	01200034 	movhi	r4,32768
 40081a8:	213fffc4 	addi	r4,r4,-1
 40081ac:	1904703a 	and	r2,r3,r4
 40081b0:	e0bfb315 	stw	r2,-308(fp)
 40081b4:	04c00044 	movi	r19,1
 40081b8:	01bfffc4 	movi	r6,-1
 40081bc:	01dffc34 	movhi	r7,32752
 40081c0:	39ffffc4 	addi	r7,r7,-1
 40081c4:	e13fb217 	ldw	r4,-312(fp)
 40081c8:	e17fb317 	ldw	r5,-308(fp)
 40081cc:	4017a280 	call	4017a28 <__unorddf2>
 40081d0:	1000081e 	bne	r2,zero,40081f4 <___vfprintf_internal_r+0x758>
 40081d4:	01bfffc4 	movi	r6,-1
 40081d8:	01dffc34 	movhi	r7,32752
 40081dc:	39ffffc4 	addi	r7,r7,-1
 40081e0:	e13fb217 	ldw	r4,-312(fp)
 40081e4:	e17fb317 	ldw	r5,-308(fp)
 40081e8:	401685c0 	call	401685c <__ledf2>
 40081ec:	0080010e 	bge	zero,r2,40081f4 <___vfprintf_internal_r+0x758>
 40081f0:	0027883a 	mov	r19,zero
 40081f4:	9880005c 	xori	r2,r19,1
 40081f8:	10803fcc 	andi	r2,r2,255
 40081fc:	10000226 	beq	r2,zero,4008208 <___vfprintf_internal_r+0x76c>
 4008200:	00800044 	movi	r2,1
 4008204:	00000106 	br	400820c <___vfprintf_internal_r+0x770>
 4008208:	0005883a 	mov	r2,zero
 400820c:	10803fcc 	andi	r2,r2,255
 4008210:	10001626 	beq	r2,zero,400826c <___vfprintf_internal_r+0x7d0>
				if (_fpvalue < 0)
 4008214:	e0bfe017 	ldw	r2,-128(fp)
 4008218:	e0ffe117 	ldw	r3,-124(fp)
 400821c:	000d883a 	mov	r6,zero
 4008220:	000f883a 	mov	r7,zero
 4008224:	1009883a 	mov	r4,r2
 4008228:	180b883a 	mov	r5,r3
 400822c:	401685c0 	call	401685c <__ledf2>
 4008230:	1000020e 	bge	r2,zero,400823c <___vfprintf_internal_r+0x7a0>
					sign = '-';
 4008234:	00800b44 	movi	r2,45
 4008238:	e0bfe2c5 	stb	r2,-117(fp)
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
 400823c:	a0801208 	cmpgei	r2,r20,72
 4008240:	1000031e 	bne	r2,zero,4008250 <___vfprintf_internal_r+0x7b4>
					cp = "INF";
 4008244:	048100b4 	movhi	r18,1026
 4008248:	94aac004 	addi	r18,r18,-21760
 400824c:	00000206 	br	4008258 <___vfprintf_internal_r+0x7bc>
				else
					cp = "inf";
 4008250:	048100b4 	movhi	r18,1026
 4008254:	94aac104 	addi	r18,r18,-21756
				size = 3;
 4008258:	008000c4 	movi	r2,3
 400825c:	e0bfed15 	stw	r2,-76(fp)
				flags &= ~ZEROPAD;
 4008260:	00bfdfc4 	movi	r2,-129
 4008264:	88a2703a 	and	r17,r17,r2
				break;
 4008268:	00022506 	br	4008b00 <___vfprintf_internal_r+0x1064>
			}
			if (isnan (_fpvalue)) {
 400826c:	e0bfe017 	ldw	r2,-128(fp)
 4008270:	e0ffe117 	ldw	r3,-124(fp)
 4008274:	100d883a 	mov	r6,r2
 4008278:	180f883a 	mov	r7,r3
 400827c:	1009883a 	mov	r4,r2
 4008280:	180b883a 	mov	r5,r3
 4008284:	4017a280 	call	4017a28 <__unorddf2>
 4008288:	10001326 	beq	r2,zero,40082d8 <___vfprintf_internal_r+0x83c>
				if (signbit (_fpvalue))
 400828c:	e0bfe017 	ldw	r2,-128(fp)
 4008290:	e0ffe117 	ldw	r3,-124(fp)
 4008294:	1805883a 	mov	r2,r3
 4008298:	10a0002c 	andhi	r2,r2,32768
 400829c:	10000226 	beq	r2,zero,40082a8 <___vfprintf_internal_r+0x80c>
					sign = '-';
 40082a0:	00800b44 	movi	r2,45
 40082a4:	e0bfe2c5 	stb	r2,-117(fp)
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
 40082a8:	a0801208 	cmpgei	r2,r20,72
 40082ac:	1000031e 	bne	r2,zero,40082bc <___vfprintf_internal_r+0x820>
					cp = "NAN";
 40082b0:	048100b4 	movhi	r18,1026
 40082b4:	94aac204 	addi	r18,r18,-21752
 40082b8:	00000206 	br	40082c4 <___vfprintf_internal_r+0x828>
				else
					cp = "nan";
 40082bc:	048100b4 	movhi	r18,1026
 40082c0:	94aac304 	addi	r18,r18,-21748
				size = 3;
 40082c4:	008000c4 	movi	r2,3
 40082c8:	e0bfed15 	stw	r2,-76(fp)
				flags &= ~ZEROPAD;
 40082cc:	00bfdfc4 	movi	r2,-129
 40082d0:	88a2703a 	and	r17,r17,r2
				break;
 40082d4:	00020a06 	br	4008b00 <___vfprintf_internal_r+0x1064>
				  }
				else
				  cp = buf;
			} else
# endif /* _WANT_IO_C99_FORMATS */
			if (prec == -1) {
 40082d8:	e0bff517 	ldw	r2,-44(fp)
 40082dc:	10bfffd8 	cmpnei	r2,r2,-1
 40082e0:	1000031e 	bne	r2,zero,40082f0 <___vfprintf_internal_r+0x854>
				prec = DEFPREC;
 40082e4:	00800184 	movi	r2,6
 40082e8:	e0bff515 	stw	r2,-44(fp)
 40082ec:	00000806 	br	4008310 <___vfprintf_internal_r+0x874>
			} else if ((ch == 'g' || ch == 'G') && prec == 0) {
 40082f0:	a08019e0 	cmpeqi	r2,r20,103
 40082f4:	1000021e 	bne	r2,zero,4008300 <___vfprintf_internal_r+0x864>
 40082f8:	a08011d8 	cmpnei	r2,r20,71
 40082fc:	1000041e 	bne	r2,zero,4008310 <___vfprintf_internal_r+0x874>
 4008300:	e0bff517 	ldw	r2,-44(fp)
 4008304:	1000021e 	bne	r2,zero,4008310 <___vfprintf_internal_r+0x874>
				prec = 1;
 4008308:	00800044 	movi	r2,1
 400830c:	e0bff515 	stw	r2,-44(fp)
			}

			flags |= FPT;
 4008310:	8c404014 	ori	r17,r17,256

			cp = cvt (data, _fpvalue, prec, flags, &softsign,
 4008314:	e0bfe017 	ldw	r2,-128(fp)
 4008318:	e0ffe117 	ldw	r3,-124(fp)
 400831c:	dc800515 	stw	r18,20(sp)
 4008320:	e13fdc04 	addi	r4,fp,-144
 4008324:	d9000415 	stw	r4,16(sp)
 4008328:	dd000315 	stw	r20,12(sp)
 400832c:	e13fdf04 	addi	r4,fp,-132
 4008330:	d9000215 	stw	r4,8(sp)
 4008334:	e13fe284 	addi	r4,fp,-118
 4008338:	d9000115 	stw	r4,4(sp)
 400833c:	dc400015 	stw	r17,0(sp)
 4008340:	e1fff517 	ldw	r7,-44(fp)
 4008344:	100b883a 	mov	r5,r2
 4008348:	180d883a 	mov	r6,r3
 400834c:	e13fbd17 	ldw	r4,-268(fp)
 4008350:	4009bfc0 	call	4009bfc <cvt>
 4008354:	1025883a 	mov	r18,r2
				  &expt, ch, &ndig, cp);

			if (ch == 'g' || ch == 'G') {
 4008358:	a08019e0 	cmpeqi	r2,r20,103
 400835c:	1000021e 	bne	r2,zero,4008368 <___vfprintf_internal_r+0x8cc>
 4008360:	a08011d8 	cmpnei	r2,r20,71
 4008364:	1000091e 	bne	r2,zero,400838c <___vfprintf_internal_r+0x8f0>
				if (expt <= -4 || expt > prec)
 4008368:	e0bfdf17 	ldw	r2,-132(fp)
 400836c:	10bfff50 	cmplti	r2,r2,-3
 4008370:	1000031e 	bne	r2,zero,4008380 <___vfprintf_internal_r+0x8e4>
 4008374:	e0bfdf17 	ldw	r2,-132(fp)
 4008378:	e0fff517 	ldw	r3,-44(fp)
 400837c:	1880020e 	bge	r3,r2,4008388 <___vfprintf_internal_r+0x8ec>
					ch -= 2; /* 'e' or 'E' */
 4008380:	a53fff84 	addi	r20,r20,-2
 4008384:	00000106 	br	400838c <___vfprintf_internal_r+0x8f0>
				else
					ch = 'g';
 4008388:	050019c4 	movi	r20,103
			}
# ifdef _WANT_IO_C99_FORMATS
			else if (ch == 'F')
				ch = 'f';
# endif
			if (ch <= 'e') {	/* 'a', 'A', 'e', or 'E' fmt */
 400838c:	a0801988 	cmpgei	r2,r20,102
 4008390:	1000181e 	bne	r2,zero,40083f4 <___vfprintf_internal_r+0x958>
				--expt;
 4008394:	e0bfdf17 	ldw	r2,-132(fp)
 4008398:	10bfffc4 	addi	r2,r2,-1
 400839c:	e0bfdf15 	stw	r2,-132(fp)
				expsize = exponent (expstr, expt, ch);
 40083a0:	e0ffdf17 	ldw	r3,-132(fp)
 40083a4:	e0bfdd44 	addi	r2,fp,-139
 40083a8:	a00d883a 	mov	r6,r20
 40083ac:	180b883a 	mov	r5,r3
 40083b0:	1009883a 	mov	r4,r2
 40083b4:	4009e040 	call	4009e04 <exponent>
 40083b8:	e0bff415 	stw	r2,-48(fp)
				size = expsize + ndig;
 40083bc:	e0bfdc17 	ldw	r2,-144(fp)
 40083c0:	e0fff417 	ldw	r3,-48(fp)
 40083c4:	1885883a 	add	r2,r3,r2
 40083c8:	e0bfed15 	stw	r2,-76(fp)
				if (ndig > 1 || flags & ALT)
 40083cc:	e0bfdc17 	ldw	r2,-144(fp)
 40083d0:	10800088 	cmpgei	r2,r2,2
 40083d4:	1000021e 	bne	r2,zero,40083e0 <___vfprintf_internal_r+0x944>
 40083d8:	8880004c 	andi	r2,r17,1
 40083dc:	10003d26 	beq	r2,zero,40084d4 <___vfprintf_internal_r+0xa38>
					size += decp_len;
 40083e0:	e0ffed17 	ldw	r3,-76(fp)
 40083e4:	e0bfe717 	ldw	r2,-100(fp)
 40083e8:	1885883a 	add	r2,r3,r2
 40083ec:	e0bfed15 	stw	r2,-76(fp)
 40083f0:	00003806 	br	40084d4 <___vfprintf_internal_r+0xa38>
# ifdef _WANT_IO_C99_FORMATS
				flags &= ~GROUPING;
# endif
			} else {
				if (ch == 'f') {		/* f fmt */
 40083f4:	a0801998 	cmpnei	r2,r20,102
 40083f8:	10001b1e 	bne	r2,zero,4008468 <___vfprintf_internal_r+0x9cc>
					if (expt > 0) {
 40083fc:	e0bfdf17 	ldw	r2,-132(fp)
 4008400:	00800d0e 	bge	zero,r2,4008438 <___vfprintf_internal_r+0x99c>
						size = expt;
 4008404:	e0bfdf17 	ldw	r2,-132(fp)
 4008408:	e0bfed15 	stw	r2,-76(fp)
						if (prec || flags & ALT)
 400840c:	e0bff517 	ldw	r2,-44(fp)
 4008410:	1000021e 	bne	r2,zero,400841c <___vfprintf_internal_r+0x980>
 4008414:	8880004c 	andi	r2,r17,1
 4008418:	10002c26 	beq	r2,zero,40084cc <___vfprintf_internal_r+0xa30>
							size += prec + decp_len;
 400841c:	e0fff517 	ldw	r3,-44(fp)
 4008420:	e0bfe717 	ldw	r2,-100(fp)
 4008424:	1887883a 	add	r3,r3,r2
 4008428:	e0bfed17 	ldw	r2,-76(fp)
 400842c:	1885883a 	add	r2,r3,r2
 4008430:	e0bfed15 	stw	r2,-76(fp)
 4008434:	00002506 	br	40084cc <___vfprintf_internal_r+0xa30>
					} else	/* "0.X" */
						size = (prec || flags & ALT)
							  ? prec + 1 + decp_len
							  : 1;
 4008438:	e0bff517 	ldw	r2,-44(fp)
 400843c:	1000021e 	bne	r2,zero,4008448 <___vfprintf_internal_r+0x9ac>
						size = (prec || flags & ALT)
 4008440:	8880004c 	andi	r2,r17,1
 4008444:	10000526 	beq	r2,zero,400845c <___vfprintf_internal_r+0x9c0>
							  ? prec + 1 + decp_len
 4008448:	e0fff517 	ldw	r3,-44(fp)
 400844c:	e0bfe717 	ldw	r2,-100(fp)
 4008450:	1885883a 	add	r2,r3,r2
 4008454:	10800044 	addi	r2,r2,1
							  : 1;
 4008458:	00000106 	br	4008460 <___vfprintf_internal_r+0x9c4>
 400845c:	00800044 	movi	r2,1
						size = (prec || flags & ALT)
 4008460:	e0bfed15 	stw	r2,-76(fp)
 4008464:	00001906 	br	40084cc <___vfprintf_internal_r+0xa30>
				} else if (expt >= ndig) { /* fixed g fmt */
 4008468:	e0ffdf17 	ldw	r3,-132(fp)
 400846c:	e0bfdc17 	ldw	r2,-144(fp)
 4008470:	18800916 	blt	r3,r2,4008498 <___vfprintf_internal_r+0x9fc>
					size = expt;
 4008474:	e0bfdf17 	ldw	r2,-132(fp)
 4008478:	e0bfed15 	stw	r2,-76(fp)
					if (flags & ALT)
 400847c:	8880004c 	andi	r2,r17,1
 4008480:	10001226 	beq	r2,zero,40084cc <___vfprintf_internal_r+0xa30>
						size += decp_len;
 4008484:	e0ffed17 	ldw	r3,-76(fp)
 4008488:	e0bfe717 	ldw	r2,-100(fp)
 400848c:	1885883a 	add	r2,r3,r2
 4008490:	e0bfed15 	stw	r2,-76(fp)
 4008494:	00000d06 	br	40084cc <___vfprintf_internal_r+0xa30>
				} else {
					size = ndig + decp_len;
 4008498:	e0bfdc17 	ldw	r2,-144(fp)
 400849c:	1007883a 	mov	r3,r2
 40084a0:	e0bfe717 	ldw	r2,-100(fp)
 40084a4:	1885883a 	add	r2,r3,r2
 40084a8:	e0bfed15 	stw	r2,-76(fp)
					if (expt <= 0)
 40084ac:	e0bfdf17 	ldw	r2,-132(fp)
 40084b0:	00800616 	blt	zero,r2,40084cc <___vfprintf_internal_r+0xa30>
						size += 1 - expt;
 40084b4:	e0bfdf17 	ldw	r2,-132(fp)
 40084b8:	00c00044 	movi	r3,1
 40084bc:	1885c83a 	sub	r2,r3,r2
 40084c0:	e0ffed17 	ldw	r3,-76(fp)
 40084c4:	1885883a 	add	r2,r3,r2
 40084c8:	e0bfed15 	stw	r2,-76(fp)
							nrepeats++;
					}
					size += (nseps + nrepeats) * thsnd_len;
				} else
# endif
					lead = expt;
 40084cc:	e0bfdf17 	ldw	r2,-132(fp)
 40084d0:	e0bff315 	stw	r2,-52(fp)
			}

			if (softsign)
 40084d4:	e0bfe283 	ldbu	r2,-118(fp)
 40084d8:	10803fcc 	andi	r2,r2,255
 40084dc:	1080201c 	xori	r2,r2,128
 40084e0:	10bfe004 	addi	r2,r2,-128
 40084e4:	10018526 	beq	r2,zero,4008afc <___vfprintf_internal_r+0x1060>
				sign = '-';
 40084e8:	00800b44 	movi	r2,45
 40084ec:	e0bfe2c5 	stb	r2,-117(fp)
			break;
 40084f0:	00018206 	br	4008afc <___vfprintf_internal_r+0x1060>
			flags &= ~LONGINT;
			goto string;
#endif
		case 'n':
#ifndef _NO_LONGLONG
			if (flags & QUADINT)
 40084f4:	8880080c 	andi	r2,r17,32
 40084f8:	10000d26 	beq	r2,zero,4008530 <___vfprintf_internal_r+0xa94>
				*GET_ARG (N, ap, quad_ptr_t) = ret;
 40084fc:	e0bfba17 	ldw	r2,-280(fp)
 4008500:	10c00104 	addi	r3,r2,4
 4008504:	e0ffba15 	stw	r3,-280(fp)
 4008508:	10800017 	ldw	r2,0(r2)
 400850c:	e0fff717 	ldw	r3,-36(fp)
 4008510:	e0ffb015 	stw	r3,-320(fp)
 4008514:	1807d7fa 	srai	r3,r3,31
 4008518:	e0ffb115 	stw	r3,-316(fp)
 400851c:	e0ffb017 	ldw	r3,-320(fp)
 4008520:	10c00015 	stw	r3,0(r2)
 4008524:	e0ffb117 	ldw	r3,-316(fp)
 4008528:	10c00115 	stw	r3,4(r2)
			else if (flags & CHARINT)
				*GET_ARG (N, ap, char_ptr_t) = ret;
#endif
			else
				*GET_ARG (N, ap, int_ptr_t) = ret;
			continue;	/* no output */
 400852c:	00054106 	br	4009a34 <___vfprintf_internal_r+0x1f98>
			if (flags & LONGINT)
 4008530:	8880040c 	andi	r2,r17,16
 4008534:	10000726 	beq	r2,zero,4008554 <___vfprintf_internal_r+0xab8>
				*GET_ARG (N, ap, long_ptr_t) = ret;
 4008538:	e0bfba17 	ldw	r2,-280(fp)
 400853c:	10c00104 	addi	r3,r2,4
 4008540:	e0ffba15 	stw	r3,-280(fp)
 4008544:	10800017 	ldw	r2,0(r2)
 4008548:	e0fff717 	ldw	r3,-36(fp)
 400854c:	10c00015 	stw	r3,0(r2)
			continue;	/* no output */
 4008550:	00053806 	br	4009a34 <___vfprintf_internal_r+0x1f98>
			else if (flags & SHORTINT)
 4008554:	8880100c 	andi	r2,r17,64
 4008558:	10000726 	beq	r2,zero,4008578 <___vfprintf_internal_r+0xadc>
				*GET_ARG (N, ap, short_ptr_t) = ret;
 400855c:	e0bfba17 	ldw	r2,-280(fp)
 4008560:	10c00104 	addi	r3,r2,4
 4008564:	e0ffba15 	stw	r3,-280(fp)
 4008568:	10800017 	ldw	r2,0(r2)
 400856c:	e0fff717 	ldw	r3,-36(fp)
 4008570:	10c0000d 	sth	r3,0(r2)
			continue;	/* no output */
 4008574:	00052f06 	br	4009a34 <___vfprintf_internal_r+0x1f98>
				*GET_ARG (N, ap, int_ptr_t) = ret;
 4008578:	e0bfba17 	ldw	r2,-280(fp)
 400857c:	10c00104 	addi	r3,r2,4
 4008580:	e0ffba15 	stw	r3,-280(fp)
 4008584:	10800017 	ldw	r2,0(r2)
 4008588:	e0fff717 	ldw	r3,-36(fp)
 400858c:	10c00015 	stw	r3,0(r2)
			continue;	/* no output */
 4008590:	00052806 	br	4009a34 <___vfprintf_internal_r+0x1f98>
		case 'O': /* extension */
			flags |= LONGINT;
 4008594:	8c400414 	ori	r17,r17,16
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
 4008598:	8880080c 	andi	r2,r17,32
 400859c:	10000626 	beq	r2,zero,40085b8 <___vfprintf_internal_r+0xb1c>
 40085a0:	e0bfba17 	ldw	r2,-280(fp)
 40085a4:	10c00204 	addi	r3,r2,8
 40085a8:	e0ffba15 	stw	r3,-280(fp)
 40085ac:	15800017 	ldw	r22,0(r2)
 40085b0:	15c00117 	ldw	r23,4(r2)
 40085b4:	00001906 	br	400861c <___vfprintf_internal_r+0xb80>
 40085b8:	8880040c 	andi	r2,r17,16
 40085bc:	10000726 	beq	r2,zero,40085dc <___vfprintf_internal_r+0xb40>
 40085c0:	e0bfba17 	ldw	r2,-280(fp)
 40085c4:	10c00104 	addi	r3,r2,4
 40085c8:	e0ffba15 	stw	r3,-280(fp)
 40085cc:	10800017 	ldw	r2,0(r2)
 40085d0:	102d883a 	mov	r22,r2
 40085d4:	002f883a 	mov	r23,zero
 40085d8:	00001006 	br	400861c <___vfprintf_internal_r+0xb80>
 40085dc:	8880100c 	andi	r2,r17,64
 40085e0:	10000826 	beq	r2,zero,4008604 <___vfprintf_internal_r+0xb68>
 40085e4:	e0bfba17 	ldw	r2,-280(fp)
 40085e8:	10c00104 	addi	r3,r2,4
 40085ec:	e0ffba15 	stw	r3,-280(fp)
 40085f0:	10800017 	ldw	r2,0(r2)
 40085f4:	10bfffcc 	andi	r2,r2,65535
 40085f8:	102d883a 	mov	r22,r2
 40085fc:	002f883a 	mov	r23,zero
 4008600:	00000606 	br	400861c <___vfprintf_internal_r+0xb80>
 4008604:	e0bfba17 	ldw	r2,-280(fp)
 4008608:	10c00104 	addi	r3,r2,4
 400860c:	e0ffba15 	stw	r3,-280(fp)
 4008610:	10800017 	ldw	r2,0(r2)
 4008614:	102d883a 	mov	r22,r2
 4008618:	002f883a 	mov	r23,zero
 400861c:	e5bff115 	stw	r22,-60(fp)
 4008620:	e5fff215 	stw	r23,-56(fp)
			base = OCT;
 4008624:	e03ff015 	stw	zero,-64(fp)
#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			goto nosign;
 4008628:	00009d06 	br	40088a0 <___vfprintf_internal_r+0xe04>
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
 400862c:	e0bfba17 	ldw	r2,-280(fp)
 4008630:	10c00104 	addi	r3,r2,4
 4008634:	e0ffba15 	stw	r3,-280(fp)
 4008638:	10800017 	ldw	r2,0(r2)
 400863c:	e0bff115 	stw	r2,-60(fp)
 4008640:	e03ff215 	stw	zero,-56(fp)
			base = HEX;
 4008644:	00800084 	movi	r2,2
 4008648:	e0bff015 	stw	r2,-64(fp)
			xdigs = "0123456789abcdef";
 400864c:	008100b4 	movhi	r2,1026
 4008650:	10aac404 	addi	r2,r2,-21744
 4008654:	e0bfec15 	stw	r2,-80(fp)
			flags |= HEXPREFIX;
 4008658:	8c400094 	ori	r17,r17,2
			ox[0] = '0';
 400865c:	00800c04 	movi	r2,48
 4008660:	e0bfbe85 	stb	r2,-262(fp)
			ox[1] = ch = 'x';
 4008664:	05001e04 	movi	r20,120
 4008668:	00801e04 	movi	r2,120
 400866c:	e0bfbec5 	stb	r2,-261(fp)
			goto nosign;
 4008670:	00008b06 	br	40088a0 <___vfprintf_internal_r+0xe04>
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
 4008674:	e0bfba17 	ldw	r2,-280(fp)
 4008678:	10c00104 	addi	r3,r2,4
 400867c:	e0ffba15 	stw	r3,-280(fp)
 4008680:	14800017 	ldw	r18,0(r2)
#ifdef _GLIBC_EXTENSION
string:
#endif
			sign = '\0';
 4008684:	e03fe2c5 	stb	zero,-117(fp)
#ifndef __OPTIMIZE_SIZE__
			/* Behavior is undefined if the user passed a
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
 4008688:	9000081e 	bne	r18,zero,40086ac <___vfprintf_internal_r+0xc10>
				cp = "(null)";
 400868c:	048100b4 	movhi	r18,1026
 4008690:	94aac904 	addi	r18,r18,-21724
				size = ((unsigned) prec > 6U) ? 6 : prec;
 4008694:	e0bff517 	ldw	r2,-44(fp)
 4008698:	10c001f0 	cmpltui	r3,r2,7
 400869c:	1800011e 	bne	r3,zero,40086a4 <___vfprintf_internal_r+0xc08>
 40086a0:	00800184 	movi	r2,6
 40086a4:	e0bfed15 	stw	r2,-76(fp)
				else
					size = prec;
			} else
				size = strlen (cp);

			break;
 40086a8:	00011506 	br	4008b00 <___vfprintf_internal_r+0x1064>
			if (prec >= 0) {
 40086ac:	e0bff517 	ldw	r2,-44(fp)
 40086b0:	10000f16 	blt	r2,zero,40086f0 <___vfprintf_internal_r+0xc54>
				char *p = memchr (cp, 0, prec);
 40086b4:	e0bff517 	ldw	r2,-44(fp)
 40086b8:	100d883a 	mov	r6,r2
 40086bc:	000b883a 	mov	r5,zero
 40086c0:	9009883a 	mov	r4,r18
 40086c4:	400eca80 	call	400eca8 <memchr>
 40086c8:	e0bfe415 	stw	r2,-112(fp)
				if (p != NULL)
 40086cc:	e0bfe417 	ldw	r2,-112(fp)
 40086d0:	10000426 	beq	r2,zero,40086e4 <___vfprintf_internal_r+0xc48>
					size = p - cp;
 40086d4:	e0bfe417 	ldw	r2,-112(fp)
 40086d8:	1485c83a 	sub	r2,r2,r18
 40086dc:	e0bfed15 	stw	r2,-76(fp)
			break;
 40086e0:	00010706 	br	4008b00 <___vfprintf_internal_r+0x1064>
					size = prec;
 40086e4:	e0bff517 	ldw	r2,-44(fp)
 40086e8:	e0bfed15 	stw	r2,-76(fp)
			break;
 40086ec:	00010406 	br	4008b00 <___vfprintf_internal_r+0x1064>
				size = strlen (cp);
 40086f0:	9009883a 	mov	r4,r18
 40086f4:	40078680 	call	4007868 <strlen>
 40086f8:	e0bfed15 	stw	r2,-76(fp)
			break;
 40086fc:	00010006 	br	4008b00 <___vfprintf_internal_r+0x1064>
		case 'U': /* extension */
			flags |= LONGINT;
 4008700:	8c400414 	ori	r17,r17,16
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
 4008704:	8880080c 	andi	r2,r17,32
 4008708:	10000826 	beq	r2,zero,400872c <___vfprintf_internal_r+0xc90>
 400870c:	e0bfba17 	ldw	r2,-280(fp)
 4008710:	10c00204 	addi	r3,r2,8
 4008714:	e0ffba15 	stw	r3,-280(fp)
 4008718:	10c00017 	ldw	r3,0(r2)
 400871c:	e0ffb615 	stw	r3,-296(fp)
 4008720:	10800117 	ldw	r2,4(r2)
 4008724:	e0bfb715 	stw	r2,-292(fp)
 4008728:	00001906 	br	4008790 <___vfprintf_internal_r+0xcf4>
 400872c:	8880040c 	andi	r2,r17,16
 4008730:	10000726 	beq	r2,zero,4008750 <___vfprintf_internal_r+0xcb4>
 4008734:	e0bfba17 	ldw	r2,-280(fp)
 4008738:	10c00104 	addi	r3,r2,4
 400873c:	e0ffba15 	stw	r3,-280(fp)
 4008740:	10800017 	ldw	r2,0(r2)
 4008744:	e0bfb615 	stw	r2,-296(fp)
 4008748:	e03fb715 	stw	zero,-292(fp)
 400874c:	00001006 	br	4008790 <___vfprintf_internal_r+0xcf4>
 4008750:	8880100c 	andi	r2,r17,64
 4008754:	10000826 	beq	r2,zero,4008778 <___vfprintf_internal_r+0xcdc>
 4008758:	e0bfba17 	ldw	r2,-280(fp)
 400875c:	10c00104 	addi	r3,r2,4
 4008760:	e0ffba15 	stw	r3,-280(fp)
 4008764:	10800017 	ldw	r2,0(r2)
 4008768:	10bfffcc 	andi	r2,r2,65535
 400876c:	e0bfb615 	stw	r2,-296(fp)
 4008770:	e03fb715 	stw	zero,-292(fp)
 4008774:	00000606 	br	4008790 <___vfprintf_internal_r+0xcf4>
 4008778:	e0bfba17 	ldw	r2,-280(fp)
 400877c:	10c00104 	addi	r3,r2,4
 4008780:	e0ffba15 	stw	r3,-280(fp)
 4008784:	10800017 	ldw	r2,0(r2)
 4008788:	e0bfb615 	stw	r2,-296(fp)
 400878c:	e03fb715 	stw	zero,-292(fp)
 4008790:	e0bfb617 	ldw	r2,-296(fp)
 4008794:	e0bff115 	stw	r2,-60(fp)
 4008798:	e0bfb717 	ldw	r2,-292(fp)
 400879c:	e0bff215 	stw	r2,-56(fp)
			base = DEC;
 40087a0:	00800044 	movi	r2,1
 40087a4:	e0bff015 	stw	r2,-64(fp)
			goto nosign;
 40087a8:	00003d06 	br	40088a0 <___vfprintf_internal_r+0xe04>
		case 'X':
			xdigs = "0123456789ABCDEF";
 40087ac:	008100b4 	movhi	r2,1026
 40087b0:	10aacb04 	addi	r2,r2,-21716
 40087b4:	e0bfec15 	stw	r2,-80(fp)
			goto hex;
 40087b8:	00000306 	br	40087c8 <___vfprintf_internal_r+0xd2c>
		case 'x':
			xdigs = "0123456789abcdef";
 40087bc:	008100b4 	movhi	r2,1026
 40087c0:	10aac404 	addi	r2,r2,-21744
 40087c4:	e0bfec15 	stw	r2,-80(fp)
hex:			_uquad = UARG ();
 40087c8:	8880080c 	andi	r2,r17,32
 40087cc:	10000826 	beq	r2,zero,40087f0 <___vfprintf_internal_r+0xd54>
 40087d0:	e0bfba17 	ldw	r2,-280(fp)
 40087d4:	10c00204 	addi	r3,r2,8
 40087d8:	e0ffba15 	stw	r3,-280(fp)
 40087dc:	10c00017 	ldw	r3,0(r2)
 40087e0:	e0ffb415 	stw	r3,-304(fp)
 40087e4:	10800117 	ldw	r2,4(r2)
 40087e8:	e0bfb515 	stw	r2,-300(fp)
 40087ec:	00001906 	br	4008854 <___vfprintf_internal_r+0xdb8>
 40087f0:	8880040c 	andi	r2,r17,16
 40087f4:	10000726 	beq	r2,zero,4008814 <___vfprintf_internal_r+0xd78>
 40087f8:	e0bfba17 	ldw	r2,-280(fp)
 40087fc:	10c00104 	addi	r3,r2,4
 4008800:	e0ffba15 	stw	r3,-280(fp)
 4008804:	10800017 	ldw	r2,0(r2)
 4008808:	e0bfb415 	stw	r2,-304(fp)
 400880c:	e03fb515 	stw	zero,-300(fp)
 4008810:	00001006 	br	4008854 <___vfprintf_internal_r+0xdb8>
 4008814:	8880100c 	andi	r2,r17,64
 4008818:	10000826 	beq	r2,zero,400883c <___vfprintf_internal_r+0xda0>
 400881c:	e0bfba17 	ldw	r2,-280(fp)
 4008820:	10c00104 	addi	r3,r2,4
 4008824:	e0ffba15 	stw	r3,-280(fp)
 4008828:	10800017 	ldw	r2,0(r2)
 400882c:	10bfffcc 	andi	r2,r2,65535
 4008830:	e0bfb415 	stw	r2,-304(fp)
 4008834:	e03fb515 	stw	zero,-300(fp)
 4008838:	00000606 	br	4008854 <___vfprintf_internal_r+0xdb8>
 400883c:	e0bfba17 	ldw	r2,-280(fp)
 4008840:	10c00104 	addi	r3,r2,4
 4008844:	e0ffba15 	stw	r3,-280(fp)
 4008848:	10800017 	ldw	r2,0(r2)
 400884c:	e0bfb415 	stw	r2,-304(fp)
 4008850:	e03fb515 	stw	zero,-300(fp)
 4008854:	e0bfb417 	ldw	r2,-304(fp)
 4008858:	e0bff115 	stw	r2,-60(fp)
 400885c:	e0bfb517 	ldw	r2,-300(fp)
 4008860:	e0bff215 	stw	r2,-56(fp)
			base = HEX;
 4008864:	00800084 	movi	r2,2
 4008868:	e0bff015 	stw	r2,-64(fp)
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _uquad != 0) {
 400886c:	8880004c 	andi	r2,r17,1
 4008870:	10000a26 	beq	r2,zero,400889c <___vfprintf_internal_r+0xe00>
 4008874:	e0bff117 	ldw	r2,-60(fp)
 4008878:	e0fff217 	ldw	r3,-56(fp)
 400887c:	10c4b03a 	or	r2,r2,r3
 4008880:	10000726 	beq	r2,zero,40088a0 <___vfprintf_internal_r+0xe04>
				ox[0] = '0';
 4008884:	00800c04 	movi	r2,48
 4008888:	e0bfbe85 	stb	r2,-262(fp)
				ox[1] = ch;
 400888c:	a005883a 	mov	r2,r20
 4008890:	e0bfbec5 	stb	r2,-261(fp)
				flags |= HEXPREFIX;
 4008894:	8c400094 	ori	r17,r17,2
 4008898:	00000106 	br	40088a0 <___vfprintf_internal_r+0xe04>

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
 400889c:	0001883a 	nop
 40088a0:	e03fe2c5 	stb	zero,-117(fp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
 40088a4:	e0bff517 	ldw	r2,-44(fp)
 40088a8:	e0bfef15 	stw	r2,-68(fp)
 40088ac:	e0bfef17 	ldw	r2,-68(fp)
 40088b0:	10000216 	blt	r2,zero,40088bc <___vfprintf_internal_r+0xe20>
				flags &= ~ZEROPAD;
 40088b4:	00bfdfc4 	movi	r2,-129
 40088b8:	88a2703a 	and	r17,r17,r2
			/*
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
 40088bc:	e4bfbf04 	addi	r18,fp,-260
 40088c0:	94800a04 	addi	r18,r18,40
			if (_uquad != 0 || prec != 0) {
 40088c4:	e0bff117 	ldw	r2,-60(fp)
 40088c8:	e0fff217 	ldw	r3,-56(fp)
 40088cc:	10c4b03a 	or	r2,r2,r3
 40088d0:	1000021e 	bne	r2,zero,40088dc <___vfprintf_internal_r+0xe40>
 40088d4:	e0bff517 	ldw	r2,-44(fp)
 40088d8:	10007426 	beq	r2,zero,4008aac <___vfprintf_internal_r+0x1010>
 40088dc:	e0bff017 	ldw	r2,-64(fp)
 40088e0:	108000a0 	cmpeqi	r2,r2,2
 40088e4:	1000531e 	bne	r2,zero,4008a34 <___vfprintf_internal_r+0xf98>
 40088e8:	e0bff017 	ldw	r2,-64(fp)
 40088ec:	108000e8 	cmpgeui	r2,r2,3
 40088f0:	1000651e 	bne	r2,zero,4008a88 <___vfprintf_internal_r+0xfec>
 40088f4:	e0bff017 	ldw	r2,-64(fp)
 40088f8:	10000526 	beq	r2,zero,4008910 <___vfprintf_internal_r+0xe74>
 40088fc:	e0bff017 	ldw	r2,-64(fp)
 4008900:	10800060 	cmpeqi	r2,r2,1
 4008904:	1000201e 	bne	r2,zero,4008988 <___vfprintf_internal_r+0xeec>
 4008908:	00005f06 	br	4008a88 <___vfprintf_internal_r+0xfec>
				 * Unsigned mod is hard, and unsigned mod
				 * by a constant is easier than that by
				 * a variable; hence this switch.
				 */
				switch (base) {
				case OCT:
 400890c:	0001883a 	nop
					do {
						*--cp = to_char (_uquad & 7);
 4008910:	e0bff117 	ldw	r2,-60(fp)
 4008914:	108001cc 	andi	r2,r2,7
 4008918:	10800c04 	addi	r2,r2,48
 400891c:	94bfffc4 	addi	r18,r18,-1
 4008920:	90800005 	stb	r2,0(r18)
						_uquad >>= 3;
 4008924:	e0bff217 	ldw	r2,-56(fp)
 4008928:	1004977a 	slli	r2,r2,29
 400892c:	e0fff117 	ldw	r3,-60(fp)
 4008930:	1806d0fa 	srli	r3,r3,3
 4008934:	1884b03a 	or	r2,r3,r2
 4008938:	e0bff115 	stw	r2,-60(fp)
 400893c:	e0bff217 	ldw	r2,-56(fp)
 4008940:	1004d0fa 	srli	r2,r2,3
 4008944:	e0bff215 	stw	r2,-56(fp)
					} while (_uquad);
 4008948:	e0bff117 	ldw	r2,-60(fp)
 400894c:	e0fff217 	ldw	r3,-56(fp)
 4008950:	10c4b03a 	or	r2,r2,r3
 4008954:	103fed1e 	bne	r2,zero,400890c <___vfprintf_internal_r+0xe70>
					/* handle octal leading 0 */
					if (flags & ALT && *cp != '0')
 4008958:	8880004c 	andi	r2,r17,1
 400895c:	10005126 	beq	r2,zero,4008aa4 <___vfprintf_internal_r+0x1008>
 4008960:	90800003 	ldbu	r2,0(r18)
 4008964:	10803fcc 	andi	r2,r2,255
 4008968:	1080201c 	xori	r2,r2,128
 400896c:	10bfe004 	addi	r2,r2,-128
 4008970:	10800c20 	cmpeqi	r2,r2,48
 4008974:	10004b1e 	bne	r2,zero,4008aa4 <___vfprintf_internal_r+0x1008>
						*--cp = '0';
 4008978:	94bfffc4 	addi	r18,r18,-1
 400897c:	00800c04 	movi	r2,48
 4008980:	90800005 	stb	r2,0(r18)
					break;
 4008984:	00004706 	br	4008aa4 <___vfprintf_internal_r+0x1008>

				case DEC:
					/* many numbers are 1 digit */
					if (_uquad < 10) {
 4008988:	e0bff217 	ldw	r2,-56(fp)
 400898c:	10000a1e 	bne	r2,zero,40089b8 <___vfprintf_internal_r+0xf1c>
 4008990:	e0bff217 	ldw	r2,-56(fp)
 4008994:	1000031e 	bne	r2,zero,40089a4 <___vfprintf_internal_r+0xf08>
 4008998:	e0bff117 	ldw	r2,-60(fp)
 400899c:	108002a8 	cmpgeui	r2,r2,10
 40089a0:	1000051e 	bne	r2,zero,40089b8 <___vfprintf_internal_r+0xf1c>
						*--cp = to_char(_uquad);
 40089a4:	e0bff117 	ldw	r2,-60(fp)
 40089a8:	10800c04 	addi	r2,r2,48
 40089ac:	94bfffc4 	addi	r18,r18,-1
 40089b0:	90800005 	stb	r2,0(r18)
						break;
 40089b4:	00003c06 	br	4008aa8 <___vfprintf_internal_r+0x100c>
					}
#ifdef _WANT_IO_C99_FORMATS
					ndig = 0;
#endif
					do {
					  *--cp = to_char (_uquad % 10);
 40089b8:	e0bff117 	ldw	r2,-60(fp)
 40089bc:	e0fff217 	ldw	r3,-56(fp)
 40089c0:	01800284 	movi	r6,10
 40089c4:	000f883a 	mov	r7,zero
 40089c8:	1009883a 	mov	r4,r2
 40089cc:	180b883a 	mov	r5,r3
 40089d0:	4014cc80 	call	4014cc8 <__umoddi3>
 40089d4:	1009883a 	mov	r4,r2
 40089d8:	180b883a 	mov	r5,r3
 40089dc:	2005883a 	mov	r2,r4
 40089e0:	2807883a 	mov	r3,r5
 40089e4:	10800c04 	addi	r2,r2,48
 40089e8:	94bfffc4 	addi	r18,r18,-1
 40089ec:	90800005 	stb	r2,0(r18)
					       next cases. */
					    if (grouping[1] != '\0')
					      grouping++;
					  }
#endif
					  _uquad /= 10;
 40089f0:	e0bff117 	ldw	r2,-60(fp)
 40089f4:	e0fff217 	ldw	r3,-56(fp)
 40089f8:	01800284 	movi	r6,10
 40089fc:	000f883a 	mov	r7,zero
 4008a00:	1009883a 	mov	r4,r2
 4008a04:	180b883a 	mov	r5,r3
 4008a08:	40146ac0 	call	40146ac <__udivdi3>
 4008a0c:	1009883a 	mov	r4,r2
 4008a10:	180b883a 	mov	r5,r3
 4008a14:	e13ff115 	stw	r4,-60(fp)
 4008a18:	e17ff215 	stw	r5,-56(fp)
					} while (_uquad != 0);
 4008a1c:	e0bff117 	ldw	r2,-60(fp)
 4008a20:	e0fff217 	ldw	r3,-56(fp)
 4008a24:	10c4b03a 	or	r2,r2,r3
 4008a28:	103fe31e 	bne	r2,zero,40089b8 <___vfprintf_internal_r+0xf1c>
					break;
 4008a2c:	00001e06 	br	4008aa8 <___vfprintf_internal_r+0x100c>

				case HEX:
 4008a30:	0001883a 	nop
					do {
						*--cp = xdigs[_uquad & 15];
 4008a34:	e0bff117 	ldw	r2,-60(fp)
 4008a38:	108003cc 	andi	r2,r2,15
 4008a3c:	e0ffec17 	ldw	r3,-80(fp)
 4008a40:	1885883a 	add	r2,r3,r2
 4008a44:	94bfffc4 	addi	r18,r18,-1
 4008a48:	10800003 	ldbu	r2,0(r2)
 4008a4c:	90800005 	stb	r2,0(r18)
						_uquad >>= 4;
 4008a50:	e0bff217 	ldw	r2,-56(fp)
 4008a54:	1004973a 	slli	r2,r2,28
 4008a58:	e0fff117 	ldw	r3,-60(fp)
 4008a5c:	1806d13a 	srli	r3,r3,4
 4008a60:	1884b03a 	or	r2,r3,r2
 4008a64:	e0bff115 	stw	r2,-60(fp)
 4008a68:	e0bff217 	ldw	r2,-56(fp)
 4008a6c:	1004d13a 	srli	r2,r2,4
 4008a70:	e0bff215 	stw	r2,-56(fp)
					} while (_uquad);
 4008a74:	e0bff117 	ldw	r2,-60(fp)
 4008a78:	e0fff217 	ldw	r3,-56(fp)
 4008a7c:	10c4b03a 	or	r2,r2,r3
 4008a80:	103feb1e 	bne	r2,zero,4008a30 <___vfprintf_internal_r+0xf94>
					break;
 4008a84:	00000806 	br	4008aa8 <___vfprintf_internal_r+0x100c>

				default:
					cp = "bug in vfprintf: bad base";
 4008a88:	048100b4 	movhi	r18,1026
 4008a8c:	94aad004 	addi	r18,r18,-21696
					size = strlen (cp);
 4008a90:	9009883a 	mov	r4,r18
 4008a94:	40078680 	call	4007868 <strlen>
 4008a98:	e0bfed15 	stw	r2,-76(fp)
					goto skipsize;
 4008a9c:	0001883a 	nop
                       else if (base == OCT && (flags & ALT))
                         *--cp = '0';

			size = buf + BUF - cp;
		skipsize:
			break;
 4008aa0:	00001706 	br	4008b00 <___vfprintf_internal_r+0x1064>
					break;
 4008aa4:	0001883a 	nop
				switch (base) {
 4008aa8:	00000706 	br	4008ac8 <___vfprintf_internal_r+0x102c>
                       else if (base == OCT && (flags & ALT))
 4008aac:	e0bff017 	ldw	r2,-64(fp)
 4008ab0:	1000051e 	bne	r2,zero,4008ac8 <___vfprintf_internal_r+0x102c>
 4008ab4:	8880004c 	andi	r2,r17,1
 4008ab8:	10000326 	beq	r2,zero,4008ac8 <___vfprintf_internal_r+0x102c>
                         *--cp = '0';
 4008abc:	94bfffc4 	addi	r18,r18,-1
 4008ac0:	00800c04 	movi	r2,48
 4008ac4:	90800005 	stb	r2,0(r18)
			size = buf + BUF - cp;
 4008ac8:	e0bfbf04 	addi	r2,fp,-260
 4008acc:	10800a04 	addi	r2,r2,40
 4008ad0:	1485c83a 	sub	r2,r2,r18
 4008ad4:	e0bfed15 	stw	r2,-76(fp)
			break;
 4008ad8:	00000906 	br	4008b00 <___vfprintf_internal_r+0x1064>
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
 4008adc:	a003d826 	beq	r20,zero,4009a40 <___vfprintf_internal_r+0x1fa4>
				goto done;
			/* pretend it was %c with argument ch */
			cp = buf;
 4008ae0:	e4bfbf04 	addi	r18,fp,-260
			*cp = ch;
 4008ae4:	a005883a 	mov	r2,r20
 4008ae8:	90800005 	stb	r2,0(r18)
			size = 1;
 4008aec:	00800044 	movi	r2,1
 4008af0:	e0bfed15 	stw	r2,-76(fp)
			sign = '\0';
 4008af4:	e03fe2c5 	stb	zero,-117(fp)
			break;
 4008af8:	00000106 	br	4008b00 <___vfprintf_internal_r+0x1064>
			break;
 4008afc:	0001883a 	nop
		 * If flags&FPT, ch must be in [aAeEfg].
		 *
		 * Compute actual size, so we know how much to pad.
		 * size excludes decimal prec; realsz includes it.
		 */
		realsz = dprec > size ? dprec : size;
 4008b00:	e0ffef17 	ldw	r3,-68(fp)
 4008b04:	e0bfed17 	ldw	r2,-76(fp)
 4008b08:	10c0010e 	bge	r2,r3,4008b10 <___vfprintf_internal_r+0x1074>
 4008b0c:	1805883a 	mov	r2,r3
 4008b10:	e0bfee15 	stw	r2,-72(fp)
		if (sign)
 4008b14:	e0bfe2c3 	ldbu	r2,-117(fp)
 4008b18:	10803fcc 	andi	r2,r2,255
 4008b1c:	1080201c 	xori	r2,r2,128
 4008b20:	10bfe004 	addi	r2,r2,-128
 4008b24:	10000326 	beq	r2,zero,4008b34 <___vfprintf_internal_r+0x1098>
			realsz++;
 4008b28:	e0bfee17 	ldw	r2,-72(fp)
 4008b2c:	10800044 	addi	r2,r2,1
 4008b30:	e0bfee15 	stw	r2,-72(fp)
		if (flags & HEXPREFIX)
 4008b34:	8880008c 	andi	r2,r17,2
 4008b38:	10000326 	beq	r2,zero,4008b48 <___vfprintf_internal_r+0x10ac>
			realsz+= 2;
 4008b3c:	e0bfee17 	ldw	r2,-72(fp)
 4008b40:	10800084 	addi	r2,r2,2
 4008b44:	e0bfee15 	stw	r2,-72(fp)

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
 4008b48:	8880210c 	andi	r2,r17,132
 4008b4c:	1000351e 	bne	r2,zero,4008c24 <___vfprintf_internal_r+0x1188>
			PAD (width - realsz, blanks);
 4008b50:	e0fff617 	ldw	r3,-40(fp)
 4008b54:	e0bfee17 	ldw	r2,-72(fp)
 4008b58:	18a7c83a 	sub	r19,r3,r2
 4008b5c:	04c0310e 	bge	zero,r19,4008c24 <___vfprintf_internal_r+0x1188>
 4008b60:	00001706 	br	4008bc0 <___vfprintf_internal_r+0x1124>
 4008b64:	008100b4 	movhi	r2,1026
 4008b68:	10aad804 	addi	r2,r2,-21664
 4008b6c:	80800015 	stw	r2,0(r16)
 4008b70:	00800404 	movi	r2,16
 4008b74:	80800115 	stw	r2,4(r16)
 4008b78:	e0bfdb17 	ldw	r2,-148(fp)
 4008b7c:	10800404 	addi	r2,r2,16
 4008b80:	e0bfdb15 	stw	r2,-148(fp)
 4008b84:	84000204 	addi	r16,r16,8
 4008b88:	e0bfda17 	ldw	r2,-152(fp)
 4008b8c:	10800044 	addi	r2,r2,1
 4008b90:	e0bfda15 	stw	r2,-152(fp)
 4008b94:	e0bfda17 	ldw	r2,-152(fp)
 4008b98:	10800210 	cmplti	r2,r2,8
 4008b9c:	1000071e 	bne	r2,zero,4008bbc <___vfprintf_internal_r+0x1120>
 4008ba0:	e0bfd904 	addi	r2,fp,-156
 4008ba4:	100d883a 	mov	r6,r2
 4008ba8:	e17fbc17 	ldw	r5,-272(fp)
 4008bac:	e13fbd17 	ldw	r4,-268(fp)
 4008bb0:	4011aac0 	call	4011aac <__sprint_r>
 4008bb4:	1003b01e 	bne	r2,zero,4009a78 <___vfprintf_internal_r+0x1fdc>
 4008bb8:	e43fc904 	addi	r16,fp,-220
 4008bbc:	9cfffc04 	addi	r19,r19,-16
 4008bc0:	98800448 	cmpgei	r2,r19,17
 4008bc4:	103fe71e 	bne	r2,zero,4008b64 <___vfprintf_internal_r+0x10c8>
 4008bc8:	008100b4 	movhi	r2,1026
 4008bcc:	10aad804 	addi	r2,r2,-21664
 4008bd0:	80800015 	stw	r2,0(r16)
 4008bd4:	9805883a 	mov	r2,r19
 4008bd8:	80800115 	stw	r2,4(r16)
 4008bdc:	e0bfdb17 	ldw	r2,-148(fp)
 4008be0:	9807883a 	mov	r3,r19
 4008be4:	10c5883a 	add	r2,r2,r3
 4008be8:	e0bfdb15 	stw	r2,-148(fp)
 4008bec:	84000204 	addi	r16,r16,8
 4008bf0:	e0bfda17 	ldw	r2,-152(fp)
 4008bf4:	10800044 	addi	r2,r2,1
 4008bf8:	e0bfda15 	stw	r2,-152(fp)
 4008bfc:	e0bfda17 	ldw	r2,-152(fp)
 4008c00:	10800210 	cmplti	r2,r2,8
 4008c04:	1000071e 	bne	r2,zero,4008c24 <___vfprintf_internal_r+0x1188>
 4008c08:	e0bfd904 	addi	r2,fp,-156
 4008c0c:	100d883a 	mov	r6,r2
 4008c10:	e17fbc17 	ldw	r5,-272(fp)
 4008c14:	e13fbd17 	ldw	r4,-268(fp)
 4008c18:	4011aac0 	call	4011aac <__sprint_r>
 4008c1c:	1003981e 	bne	r2,zero,4009a80 <___vfprintf_internal_r+0x1fe4>
 4008c20:	e43fc904 	addi	r16,fp,-220

		/* prefix */
		if (sign)
 4008c24:	e0bfe2c3 	ldbu	r2,-117(fp)
 4008c28:	10803fcc 	andi	r2,r2,255
 4008c2c:	1080201c 	xori	r2,r2,128
 4008c30:	10bfe004 	addi	r2,r2,-128
 4008c34:	10001526 	beq	r2,zero,4008c8c <___vfprintf_internal_r+0x11f0>
			PRINT (&sign, 1);
 4008c38:	e0bfe2c4 	addi	r2,fp,-117
 4008c3c:	80800015 	stw	r2,0(r16)
 4008c40:	00800044 	movi	r2,1
 4008c44:	80800115 	stw	r2,4(r16)
 4008c48:	e0bfdb17 	ldw	r2,-148(fp)
 4008c4c:	10800044 	addi	r2,r2,1
 4008c50:	e0bfdb15 	stw	r2,-148(fp)
 4008c54:	84000204 	addi	r16,r16,8
 4008c58:	e0bfda17 	ldw	r2,-152(fp)
 4008c5c:	10800044 	addi	r2,r2,1
 4008c60:	e0bfda15 	stw	r2,-152(fp)
 4008c64:	e0bfda17 	ldw	r2,-152(fp)
 4008c68:	10800210 	cmplti	r2,r2,8
 4008c6c:	1000071e 	bne	r2,zero,4008c8c <___vfprintf_internal_r+0x11f0>
 4008c70:	e0bfd904 	addi	r2,fp,-156
 4008c74:	100d883a 	mov	r6,r2
 4008c78:	e17fbc17 	ldw	r5,-272(fp)
 4008c7c:	e13fbd17 	ldw	r4,-268(fp)
 4008c80:	4011aac0 	call	4011aac <__sprint_r>
 4008c84:	1003801e 	bne	r2,zero,4009a88 <___vfprintf_internal_r+0x1fec>
 4008c88:	e43fc904 	addi	r16,fp,-220
		if (flags & HEXPREFIX)
 4008c8c:	8880008c 	andi	r2,r17,2
 4008c90:	10001526 	beq	r2,zero,4008ce8 <___vfprintf_internal_r+0x124c>
			PRINT (ox, 2);
 4008c94:	e0bfbe84 	addi	r2,fp,-262
 4008c98:	80800015 	stw	r2,0(r16)
 4008c9c:	00800084 	movi	r2,2
 4008ca0:	80800115 	stw	r2,4(r16)
 4008ca4:	e0bfdb17 	ldw	r2,-148(fp)
 4008ca8:	10800084 	addi	r2,r2,2
 4008cac:	e0bfdb15 	stw	r2,-148(fp)
 4008cb0:	84000204 	addi	r16,r16,8
 4008cb4:	e0bfda17 	ldw	r2,-152(fp)
 4008cb8:	10800044 	addi	r2,r2,1
 4008cbc:	e0bfda15 	stw	r2,-152(fp)
 4008cc0:	e0bfda17 	ldw	r2,-152(fp)
 4008cc4:	10800210 	cmplti	r2,r2,8
 4008cc8:	1000071e 	bne	r2,zero,4008ce8 <___vfprintf_internal_r+0x124c>
 4008ccc:	e0bfd904 	addi	r2,fp,-156
 4008cd0:	100d883a 	mov	r6,r2
 4008cd4:	e17fbc17 	ldw	r5,-272(fp)
 4008cd8:	e13fbd17 	ldw	r4,-268(fp)
 4008cdc:	4011aac0 	call	4011aac <__sprint_r>
 4008ce0:	10036b1e 	bne	r2,zero,4009a90 <___vfprintf_internal_r+0x1ff4>
 4008ce4:	e43fc904 	addi	r16,fp,-220

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
 4008ce8:	8880210c 	andi	r2,r17,132
 4008cec:	10802018 	cmpnei	r2,r2,128
 4008cf0:	1000351e 	bne	r2,zero,4008dc8 <___vfprintf_internal_r+0x132c>
			PAD (width - realsz, zeroes);
 4008cf4:	e0fff617 	ldw	r3,-40(fp)
 4008cf8:	e0bfee17 	ldw	r2,-72(fp)
 4008cfc:	18a7c83a 	sub	r19,r3,r2
 4008d00:	04c0310e 	bge	zero,r19,4008dc8 <___vfprintf_internal_r+0x132c>
 4008d04:	00001706 	br	4008d64 <___vfprintf_internal_r+0x12c8>
 4008d08:	008100b4 	movhi	r2,1026
 4008d0c:	10aadc04 	addi	r2,r2,-21648
 4008d10:	80800015 	stw	r2,0(r16)
 4008d14:	00800404 	movi	r2,16
 4008d18:	80800115 	stw	r2,4(r16)
 4008d1c:	e0bfdb17 	ldw	r2,-148(fp)
 4008d20:	10800404 	addi	r2,r2,16
 4008d24:	e0bfdb15 	stw	r2,-148(fp)
 4008d28:	84000204 	addi	r16,r16,8
 4008d2c:	e0bfda17 	ldw	r2,-152(fp)
 4008d30:	10800044 	addi	r2,r2,1
 4008d34:	e0bfda15 	stw	r2,-152(fp)
 4008d38:	e0bfda17 	ldw	r2,-152(fp)
 4008d3c:	10800210 	cmplti	r2,r2,8
 4008d40:	1000071e 	bne	r2,zero,4008d60 <___vfprintf_internal_r+0x12c4>
 4008d44:	e0bfd904 	addi	r2,fp,-156
 4008d48:	100d883a 	mov	r6,r2
 4008d4c:	e17fbc17 	ldw	r5,-272(fp)
 4008d50:	e13fbd17 	ldw	r4,-268(fp)
 4008d54:	4011aac0 	call	4011aac <__sprint_r>
 4008d58:	10034f1e 	bne	r2,zero,4009a98 <___vfprintf_internal_r+0x1ffc>
 4008d5c:	e43fc904 	addi	r16,fp,-220
 4008d60:	9cfffc04 	addi	r19,r19,-16
 4008d64:	98800448 	cmpgei	r2,r19,17
 4008d68:	103fe71e 	bne	r2,zero,4008d08 <___vfprintf_internal_r+0x126c>
 4008d6c:	008100b4 	movhi	r2,1026
 4008d70:	10aadc04 	addi	r2,r2,-21648
 4008d74:	80800015 	stw	r2,0(r16)
 4008d78:	9805883a 	mov	r2,r19
 4008d7c:	80800115 	stw	r2,4(r16)
 4008d80:	e0bfdb17 	ldw	r2,-148(fp)
 4008d84:	9807883a 	mov	r3,r19
 4008d88:	10c5883a 	add	r2,r2,r3
 4008d8c:	e0bfdb15 	stw	r2,-148(fp)
 4008d90:	84000204 	addi	r16,r16,8
 4008d94:	e0bfda17 	ldw	r2,-152(fp)
 4008d98:	10800044 	addi	r2,r2,1
 4008d9c:	e0bfda15 	stw	r2,-152(fp)
 4008da0:	e0bfda17 	ldw	r2,-152(fp)
 4008da4:	10800210 	cmplti	r2,r2,8
 4008da8:	1000071e 	bne	r2,zero,4008dc8 <___vfprintf_internal_r+0x132c>
 4008dac:	e0bfd904 	addi	r2,fp,-156
 4008db0:	100d883a 	mov	r6,r2
 4008db4:	e17fbc17 	ldw	r5,-272(fp)
 4008db8:	e13fbd17 	ldw	r4,-268(fp)
 4008dbc:	4011aac0 	call	4011aac <__sprint_r>
 4008dc0:	1003371e 	bne	r2,zero,4009aa0 <___vfprintf_internal_r+0x2004>
 4008dc4:	e43fc904 	addi	r16,fp,-220

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
 4008dc8:	e0ffef17 	ldw	r3,-68(fp)
 4008dcc:	e0bfed17 	ldw	r2,-76(fp)
 4008dd0:	18a7c83a 	sub	r19,r3,r2
 4008dd4:	04c0310e 	bge	zero,r19,4008e9c <___vfprintf_internal_r+0x1400>
 4008dd8:	00001706 	br	4008e38 <___vfprintf_internal_r+0x139c>
 4008ddc:	008100b4 	movhi	r2,1026
 4008de0:	10aadc04 	addi	r2,r2,-21648
 4008de4:	80800015 	stw	r2,0(r16)
 4008de8:	00800404 	movi	r2,16
 4008dec:	80800115 	stw	r2,4(r16)
 4008df0:	e0bfdb17 	ldw	r2,-148(fp)
 4008df4:	10800404 	addi	r2,r2,16
 4008df8:	e0bfdb15 	stw	r2,-148(fp)
 4008dfc:	84000204 	addi	r16,r16,8
 4008e00:	e0bfda17 	ldw	r2,-152(fp)
 4008e04:	10800044 	addi	r2,r2,1
 4008e08:	e0bfda15 	stw	r2,-152(fp)
 4008e0c:	e0bfda17 	ldw	r2,-152(fp)
 4008e10:	10800210 	cmplti	r2,r2,8
 4008e14:	1000071e 	bne	r2,zero,4008e34 <___vfprintf_internal_r+0x1398>
 4008e18:	e0bfd904 	addi	r2,fp,-156
 4008e1c:	100d883a 	mov	r6,r2
 4008e20:	e17fbc17 	ldw	r5,-272(fp)
 4008e24:	e13fbd17 	ldw	r4,-268(fp)
 4008e28:	4011aac0 	call	4011aac <__sprint_r>
 4008e2c:	10031e1e 	bne	r2,zero,4009aa8 <___vfprintf_internal_r+0x200c>
 4008e30:	e43fc904 	addi	r16,fp,-220
 4008e34:	9cfffc04 	addi	r19,r19,-16
 4008e38:	98800448 	cmpgei	r2,r19,17
 4008e3c:	103fe71e 	bne	r2,zero,4008ddc <___vfprintf_internal_r+0x1340>
 4008e40:	008100b4 	movhi	r2,1026
 4008e44:	10aadc04 	addi	r2,r2,-21648
 4008e48:	80800015 	stw	r2,0(r16)
 4008e4c:	9805883a 	mov	r2,r19
 4008e50:	80800115 	stw	r2,4(r16)
 4008e54:	e0bfdb17 	ldw	r2,-148(fp)
 4008e58:	9807883a 	mov	r3,r19
 4008e5c:	10c5883a 	add	r2,r2,r3
 4008e60:	e0bfdb15 	stw	r2,-148(fp)
 4008e64:	84000204 	addi	r16,r16,8
 4008e68:	e0bfda17 	ldw	r2,-152(fp)
 4008e6c:	10800044 	addi	r2,r2,1
 4008e70:	e0bfda15 	stw	r2,-152(fp)
 4008e74:	e0bfda17 	ldw	r2,-152(fp)
 4008e78:	10800210 	cmplti	r2,r2,8
 4008e7c:	1000071e 	bne	r2,zero,4008e9c <___vfprintf_internal_r+0x1400>
 4008e80:	e0bfd904 	addi	r2,fp,-156
 4008e84:	100d883a 	mov	r6,r2
 4008e88:	e17fbc17 	ldw	r5,-272(fp)
 4008e8c:	e13fbd17 	ldw	r4,-268(fp)
 4008e90:	4011aac0 	call	4011aac <__sprint_r>
 4008e94:	1003061e 	bne	r2,zero,4009ab0 <___vfprintf_internal_r+0x2014>
 4008e98:	e43fc904 	addi	r16,fp,-220

		/* the string or number proper */
#ifdef FLOATING_POINT
		if ((flags & FPT) == 0) {
 4008e9c:	8880400c 	andi	r2,r17,256
 4008ea0:	1000161e 	bne	r2,zero,4008efc <___vfprintf_internal_r+0x1460>
			PRINT (cp, size);
 4008ea4:	84800015 	stw	r18,0(r16)
 4008ea8:	e0bfed17 	ldw	r2,-76(fp)
 4008eac:	80800115 	stw	r2,4(r16)
 4008eb0:	e0ffdb17 	ldw	r3,-148(fp)
 4008eb4:	e0bfed17 	ldw	r2,-76(fp)
 4008eb8:	1885883a 	add	r2,r3,r2
 4008ebc:	e0bfdb15 	stw	r2,-148(fp)
 4008ec0:	84000204 	addi	r16,r16,8
 4008ec4:	e0bfda17 	ldw	r2,-152(fp)
 4008ec8:	10800044 	addi	r2,r2,1
 4008ecc:	e0bfda15 	stw	r2,-152(fp)
 4008ed0:	e0bfda17 	ldw	r2,-152(fp)
 4008ed4:	10800210 	cmplti	r2,r2,8
 4008ed8:	1002881e 	bne	r2,zero,40098fc <___vfprintf_internal_r+0x1e60>
 4008edc:	e0bfd904 	addi	r2,fp,-156
 4008ee0:	100d883a 	mov	r6,r2
 4008ee4:	e17fbc17 	ldw	r5,-272(fp)
 4008ee8:	e13fbd17 	ldw	r4,-268(fp)
 4008eec:	4011aac0 	call	4011aac <__sprint_r>
 4008ef0:	1002f11e 	bne	r2,zero,4009ab8 <___vfprintf_internal_r+0x201c>
 4008ef4:	e43fc904 	addi	r16,fp,-220
 4008ef8:	00028006 	br	40098fc <___vfprintf_internal_r+0x1e60>
		} else {	/* glue together f_p fragments */
			if (ch >= 'f') {	/* 'f' or 'g' */
 4008efc:	a0801990 	cmplti	r2,r20,102
 4008f00:	1001cd1e 	bne	r2,zero,4009638 <___vfprintf_internal_r+0x1b9c>
				if (_fpvalue == 0) {
 4008f04:	e0bfe017 	ldw	r2,-128(fp)
 4008f08:	e0ffe117 	ldw	r3,-124(fp)
 4008f0c:	000d883a 	mov	r6,zero
 4008f10:	000f883a 	mov	r7,zero
 4008f14:	1009883a 	mov	r4,r2
 4008f18:	180b883a 	mov	r5,r3
 4008f1c:	40166ec0 	call	40166ec <__eqdf2>
 4008f20:	1000661e 	bne	r2,zero,40090bc <___vfprintf_internal_r+0x1620>
					/* kludge for __dtoa irregularity */
					PRINT ("0", 1);
 4008f24:	008100b4 	movhi	r2,1026
 4008f28:	10aad704 	addi	r2,r2,-21668
 4008f2c:	80800015 	stw	r2,0(r16)
 4008f30:	00800044 	movi	r2,1
 4008f34:	80800115 	stw	r2,4(r16)
 4008f38:	e0bfdb17 	ldw	r2,-148(fp)
 4008f3c:	10800044 	addi	r2,r2,1
 4008f40:	e0bfdb15 	stw	r2,-148(fp)
 4008f44:	84000204 	addi	r16,r16,8
 4008f48:	e0bfda17 	ldw	r2,-152(fp)
 4008f4c:	10800044 	addi	r2,r2,1
 4008f50:	e0bfda15 	stw	r2,-152(fp)
 4008f54:	e0bfda17 	ldw	r2,-152(fp)
 4008f58:	10800210 	cmplti	r2,r2,8
 4008f5c:	1000071e 	bne	r2,zero,4008f7c <___vfprintf_internal_r+0x14e0>
 4008f60:	e0bfd904 	addi	r2,fp,-156
 4008f64:	100d883a 	mov	r6,r2
 4008f68:	e17fbc17 	ldw	r5,-272(fp)
 4008f6c:	e13fbd17 	ldw	r4,-268(fp)
 4008f70:	4011aac0 	call	4011aac <__sprint_r>
 4008f74:	1002d21e 	bne	r2,zero,4009ac0 <___vfprintf_internal_r+0x2024>
 4008f78:	e43fc904 	addi	r16,fp,-220
					if (expt < ndig || flags & ALT) {
 4008f7c:	e0ffdf17 	ldw	r3,-132(fp)
 4008f80:	e0bfdc17 	ldw	r2,-144(fp)
 4008f84:	18800216 	blt	r3,r2,4008f90 <___vfprintf_internal_r+0x14f4>
 4008f88:	8880004c 	andi	r2,r17,1
 4008f8c:	10025b26 	beq	r2,zero,40098fc <___vfprintf_internal_r+0x1e60>
						PRINT (decimal_point, decp_len);
 4008f90:	e0bfe817 	ldw	r2,-96(fp)
 4008f94:	80800015 	stw	r2,0(r16)
 4008f98:	e0bfe717 	ldw	r2,-100(fp)
 4008f9c:	80800115 	stw	r2,4(r16)
 4008fa0:	e0ffdb17 	ldw	r3,-148(fp)
 4008fa4:	e0bfe717 	ldw	r2,-100(fp)
 4008fa8:	1885883a 	add	r2,r3,r2
 4008fac:	e0bfdb15 	stw	r2,-148(fp)
 4008fb0:	84000204 	addi	r16,r16,8
 4008fb4:	e0bfda17 	ldw	r2,-152(fp)
 4008fb8:	10800044 	addi	r2,r2,1
 4008fbc:	e0bfda15 	stw	r2,-152(fp)
 4008fc0:	e0bfda17 	ldw	r2,-152(fp)
 4008fc4:	10800210 	cmplti	r2,r2,8
 4008fc8:	1000071e 	bne	r2,zero,4008fe8 <___vfprintf_internal_r+0x154c>
 4008fcc:	e0bfd904 	addi	r2,fp,-156
 4008fd0:	100d883a 	mov	r6,r2
 4008fd4:	e17fbc17 	ldw	r5,-272(fp)
 4008fd8:	e13fbd17 	ldw	r4,-268(fp)
 4008fdc:	4011aac0 	call	4011aac <__sprint_r>
 4008fe0:	1002b91e 	bne	r2,zero,4009ac8 <___vfprintf_internal_r+0x202c>
 4008fe4:	e43fc904 	addi	r16,fp,-220
						PAD (ndig - 1, zeroes);
 4008fe8:	e0bfdc17 	ldw	r2,-144(fp)
 4008fec:	14ffffc4 	addi	r19,r2,-1
 4008ff0:	04c2420e 	bge	zero,r19,40098fc <___vfprintf_internal_r+0x1e60>
 4008ff4:	00001706 	br	4009054 <___vfprintf_internal_r+0x15b8>
 4008ff8:	008100b4 	movhi	r2,1026
 4008ffc:	10aadc04 	addi	r2,r2,-21648
 4009000:	80800015 	stw	r2,0(r16)
 4009004:	00800404 	movi	r2,16
 4009008:	80800115 	stw	r2,4(r16)
 400900c:	e0bfdb17 	ldw	r2,-148(fp)
 4009010:	10800404 	addi	r2,r2,16
 4009014:	e0bfdb15 	stw	r2,-148(fp)
 4009018:	84000204 	addi	r16,r16,8
 400901c:	e0bfda17 	ldw	r2,-152(fp)
 4009020:	10800044 	addi	r2,r2,1
 4009024:	e0bfda15 	stw	r2,-152(fp)
 4009028:	e0bfda17 	ldw	r2,-152(fp)
 400902c:	10800210 	cmplti	r2,r2,8
 4009030:	1000071e 	bne	r2,zero,4009050 <___vfprintf_internal_r+0x15b4>
 4009034:	e0bfd904 	addi	r2,fp,-156
 4009038:	100d883a 	mov	r6,r2
 400903c:	e17fbc17 	ldw	r5,-272(fp)
 4009040:	e13fbd17 	ldw	r4,-268(fp)
 4009044:	4011aac0 	call	4011aac <__sprint_r>
 4009048:	1002a11e 	bne	r2,zero,4009ad0 <___vfprintf_internal_r+0x2034>
 400904c:	e43fc904 	addi	r16,fp,-220
 4009050:	9cfffc04 	addi	r19,r19,-16
 4009054:	98800448 	cmpgei	r2,r19,17
 4009058:	103fe71e 	bne	r2,zero,4008ff8 <___vfprintf_internal_r+0x155c>
 400905c:	008100b4 	movhi	r2,1026
 4009060:	10aadc04 	addi	r2,r2,-21648
 4009064:	80800015 	stw	r2,0(r16)
 4009068:	9805883a 	mov	r2,r19
 400906c:	80800115 	stw	r2,4(r16)
 4009070:	e0bfdb17 	ldw	r2,-148(fp)
 4009074:	9807883a 	mov	r3,r19
 4009078:	10c5883a 	add	r2,r2,r3
 400907c:	e0bfdb15 	stw	r2,-148(fp)
 4009080:	84000204 	addi	r16,r16,8
 4009084:	e0bfda17 	ldw	r2,-152(fp)
 4009088:	10800044 	addi	r2,r2,1
 400908c:	e0bfda15 	stw	r2,-152(fp)
 4009090:	e0bfda17 	ldw	r2,-152(fp)
 4009094:	10800210 	cmplti	r2,r2,8
 4009098:	1002181e 	bne	r2,zero,40098fc <___vfprintf_internal_r+0x1e60>
 400909c:	e0bfd904 	addi	r2,fp,-156
 40090a0:	100d883a 	mov	r6,r2
 40090a4:	e17fbc17 	ldw	r5,-272(fp)
 40090a8:	e13fbd17 	ldw	r4,-268(fp)
 40090ac:	4011aac0 	call	4011aac <__sprint_r>
 40090b0:	1002891e 	bne	r2,zero,4009ad8 <___vfprintf_internal_r+0x203c>
 40090b4:	e43fc904 	addi	r16,fp,-220
 40090b8:	00021006 	br	40098fc <___vfprintf_internal_r+0x1e60>
					}
				} else if (expt <= 0) {
 40090bc:	e0bfdf17 	ldw	r2,-132(fp)
 40090c0:	00807c16 	blt	zero,r2,40092b4 <___vfprintf_internal_r+0x1818>
					PRINT ("0", 1);
 40090c4:	008100b4 	movhi	r2,1026
 40090c8:	10aad704 	addi	r2,r2,-21668
 40090cc:	80800015 	stw	r2,0(r16)
 40090d0:	00800044 	movi	r2,1
 40090d4:	80800115 	stw	r2,4(r16)
 40090d8:	e0bfdb17 	ldw	r2,-148(fp)
 40090dc:	10800044 	addi	r2,r2,1
 40090e0:	e0bfdb15 	stw	r2,-148(fp)
 40090e4:	84000204 	addi	r16,r16,8
 40090e8:	e0bfda17 	ldw	r2,-152(fp)
 40090ec:	10800044 	addi	r2,r2,1
 40090f0:	e0bfda15 	stw	r2,-152(fp)
 40090f4:	e0bfda17 	ldw	r2,-152(fp)
 40090f8:	10800210 	cmplti	r2,r2,8
 40090fc:	1000071e 	bne	r2,zero,400911c <___vfprintf_internal_r+0x1680>
 4009100:	e0bfd904 	addi	r2,fp,-156
 4009104:	100d883a 	mov	r6,r2
 4009108:	e17fbc17 	ldw	r5,-272(fp)
 400910c:	e13fbd17 	ldw	r4,-268(fp)
 4009110:	4011aac0 	call	4011aac <__sprint_r>
 4009114:	1002721e 	bne	r2,zero,4009ae0 <___vfprintf_internal_r+0x2044>
 4009118:	e43fc904 	addi	r16,fp,-220
					if (expt || ndig || flags & ALT) {
 400911c:	e0bfdf17 	ldw	r2,-132(fp)
 4009120:	1000041e 	bne	r2,zero,4009134 <___vfprintf_internal_r+0x1698>
 4009124:	e0bfdc17 	ldw	r2,-144(fp)
 4009128:	1000021e 	bne	r2,zero,4009134 <___vfprintf_internal_r+0x1698>
 400912c:	8880004c 	andi	r2,r17,1
 4009130:	1001f226 	beq	r2,zero,40098fc <___vfprintf_internal_r+0x1e60>
						PRINT (decimal_point, decp_len);
 4009134:	e0bfe817 	ldw	r2,-96(fp)
 4009138:	80800015 	stw	r2,0(r16)
 400913c:	e0bfe717 	ldw	r2,-100(fp)
 4009140:	80800115 	stw	r2,4(r16)
 4009144:	e0ffdb17 	ldw	r3,-148(fp)
 4009148:	e0bfe717 	ldw	r2,-100(fp)
 400914c:	1885883a 	add	r2,r3,r2
 4009150:	e0bfdb15 	stw	r2,-148(fp)
 4009154:	84000204 	addi	r16,r16,8
 4009158:	e0bfda17 	ldw	r2,-152(fp)
 400915c:	10800044 	addi	r2,r2,1
 4009160:	e0bfda15 	stw	r2,-152(fp)
 4009164:	e0bfda17 	ldw	r2,-152(fp)
 4009168:	10800210 	cmplti	r2,r2,8
 400916c:	1000071e 	bne	r2,zero,400918c <___vfprintf_internal_r+0x16f0>
 4009170:	e0bfd904 	addi	r2,fp,-156
 4009174:	100d883a 	mov	r6,r2
 4009178:	e17fbc17 	ldw	r5,-272(fp)
 400917c:	e13fbd17 	ldw	r4,-268(fp)
 4009180:	4011aac0 	call	4011aac <__sprint_r>
 4009184:	1002581e 	bne	r2,zero,4009ae8 <___vfprintf_internal_r+0x204c>
 4009188:	e43fc904 	addi	r16,fp,-220
						PAD (-expt, zeroes);
 400918c:	e0bfdf17 	ldw	r2,-132(fp)
 4009190:	00a7c83a 	sub	r19,zero,r2
 4009194:	04c0310e 	bge	zero,r19,400925c <___vfprintf_internal_r+0x17c0>
 4009198:	00001706 	br	40091f8 <___vfprintf_internal_r+0x175c>
 400919c:	008100b4 	movhi	r2,1026
 40091a0:	10aadc04 	addi	r2,r2,-21648
 40091a4:	80800015 	stw	r2,0(r16)
 40091a8:	00800404 	movi	r2,16
 40091ac:	80800115 	stw	r2,4(r16)
 40091b0:	e0bfdb17 	ldw	r2,-148(fp)
 40091b4:	10800404 	addi	r2,r2,16
 40091b8:	e0bfdb15 	stw	r2,-148(fp)
 40091bc:	84000204 	addi	r16,r16,8
 40091c0:	e0bfda17 	ldw	r2,-152(fp)
 40091c4:	10800044 	addi	r2,r2,1
 40091c8:	e0bfda15 	stw	r2,-152(fp)
 40091cc:	e0bfda17 	ldw	r2,-152(fp)
 40091d0:	10800210 	cmplti	r2,r2,8
 40091d4:	1000071e 	bne	r2,zero,40091f4 <___vfprintf_internal_r+0x1758>
 40091d8:	e0bfd904 	addi	r2,fp,-156
 40091dc:	100d883a 	mov	r6,r2
 40091e0:	e17fbc17 	ldw	r5,-272(fp)
 40091e4:	e13fbd17 	ldw	r4,-268(fp)
 40091e8:	4011aac0 	call	4011aac <__sprint_r>
 40091ec:	1002401e 	bne	r2,zero,4009af0 <___vfprintf_internal_r+0x2054>
 40091f0:	e43fc904 	addi	r16,fp,-220
 40091f4:	9cfffc04 	addi	r19,r19,-16
 40091f8:	98800448 	cmpgei	r2,r19,17
 40091fc:	103fe71e 	bne	r2,zero,400919c <___vfprintf_internal_r+0x1700>
 4009200:	008100b4 	movhi	r2,1026
 4009204:	10aadc04 	addi	r2,r2,-21648
 4009208:	80800015 	stw	r2,0(r16)
 400920c:	9805883a 	mov	r2,r19
 4009210:	80800115 	stw	r2,4(r16)
 4009214:	e0bfdb17 	ldw	r2,-148(fp)
 4009218:	9807883a 	mov	r3,r19
 400921c:	10c5883a 	add	r2,r2,r3
 4009220:	e0bfdb15 	stw	r2,-148(fp)
 4009224:	84000204 	addi	r16,r16,8
 4009228:	e0bfda17 	ldw	r2,-152(fp)
 400922c:	10800044 	addi	r2,r2,1
 4009230:	e0bfda15 	stw	r2,-152(fp)
 4009234:	e0bfda17 	ldw	r2,-152(fp)
 4009238:	10800210 	cmplti	r2,r2,8
 400923c:	1000071e 	bne	r2,zero,400925c <___vfprintf_internal_r+0x17c0>
 4009240:	e0bfd904 	addi	r2,fp,-156
 4009244:	100d883a 	mov	r6,r2
 4009248:	e17fbc17 	ldw	r5,-272(fp)
 400924c:	e13fbd17 	ldw	r4,-268(fp)
 4009250:	4011aac0 	call	4011aac <__sprint_r>
 4009254:	1002281e 	bne	r2,zero,4009af8 <___vfprintf_internal_r+0x205c>
 4009258:	e43fc904 	addi	r16,fp,-220
						PRINT (cp, ndig);
 400925c:	84800015 	stw	r18,0(r16)
 4009260:	e0bfdc17 	ldw	r2,-144(fp)
 4009264:	80800115 	stw	r2,4(r16)
 4009268:	e0bfdb17 	ldw	r2,-148(fp)
 400926c:	e0ffdc17 	ldw	r3,-144(fp)
 4009270:	10c5883a 	add	r2,r2,r3
 4009274:	e0bfdb15 	stw	r2,-148(fp)
 4009278:	84000204 	addi	r16,r16,8
 400927c:	e0bfda17 	ldw	r2,-152(fp)
 4009280:	10800044 	addi	r2,r2,1
 4009284:	e0bfda15 	stw	r2,-152(fp)
 4009288:	e0bfda17 	ldw	r2,-152(fp)
 400928c:	10800210 	cmplti	r2,r2,8
 4009290:	10019a1e 	bne	r2,zero,40098fc <___vfprintf_internal_r+0x1e60>
 4009294:	e0bfd904 	addi	r2,fp,-156
 4009298:	100d883a 	mov	r6,r2
 400929c:	e17fbc17 	ldw	r5,-272(fp)
 40092a0:	e13fbd17 	ldw	r4,-268(fp)
 40092a4:	4011aac0 	call	4011aac <__sprint_r>
 40092a8:	1002151e 	bne	r2,zero,4009b00 <___vfprintf_internal_r+0x2064>
 40092ac:	e43fc904 	addi	r16,fp,-220
 40092b0:	00019206 	br	40098fc <___vfprintf_internal_r+0x1e60>
					}
				} else {
					char *convbuf = cp;
 40092b4:	e4bfe315 	stw	r18,-116(fp)
					PRINTANDPAD(cp, convbuf + ndig,
 40092b8:	e0bfdc17 	ldw	r2,-144(fp)
 40092bc:	1007883a 	mov	r3,r2
 40092c0:	e0bfe317 	ldw	r2,-116(fp)
 40092c4:	10c5883a 	add	r2,r2,r3
 40092c8:	1485c83a 	sub	r2,r2,r18
 40092cc:	e0bfea15 	stw	r2,-88(fp)
 40092d0:	e0bfea17 	ldw	r2,-88(fp)
 40092d4:	e0fff317 	ldw	r3,-52(fp)
 40092d8:	1880020e 	bge	r3,r2,40092e4 <___vfprintf_internal_r+0x1848>
 40092dc:	e0bff317 	ldw	r2,-52(fp)
 40092e0:	e0bfea15 	stw	r2,-88(fp)
 40092e4:	e0bfea17 	ldw	r2,-88(fp)
 40092e8:	0080150e 	bge	zero,r2,4009340 <___vfprintf_internal_r+0x18a4>
 40092ec:	84800015 	stw	r18,0(r16)
 40092f0:	e0bfea17 	ldw	r2,-88(fp)
 40092f4:	80800115 	stw	r2,4(r16)
 40092f8:	e0ffdb17 	ldw	r3,-148(fp)
 40092fc:	e0bfea17 	ldw	r2,-88(fp)
 4009300:	1885883a 	add	r2,r3,r2
 4009304:	e0bfdb15 	stw	r2,-148(fp)
 4009308:	84000204 	addi	r16,r16,8
 400930c:	e0bfda17 	ldw	r2,-152(fp)
 4009310:	10800044 	addi	r2,r2,1
 4009314:	e0bfda15 	stw	r2,-152(fp)
 4009318:	e0bfda17 	ldw	r2,-152(fp)
 400931c:	10800210 	cmplti	r2,r2,8
 4009320:	1000071e 	bne	r2,zero,4009340 <___vfprintf_internal_r+0x18a4>
 4009324:	e0bfd904 	addi	r2,fp,-156
 4009328:	100d883a 	mov	r6,r2
 400932c:	e17fbc17 	ldw	r5,-272(fp)
 4009330:	e13fbd17 	ldw	r4,-268(fp)
 4009334:	4011aac0 	call	4011aac <__sprint_r>
 4009338:	1001f31e 	bne	r2,zero,4009b08 <___vfprintf_internal_r+0x206c>
 400933c:	e43fc904 	addi	r16,fp,-220
 4009340:	e0bfea17 	ldw	r2,-88(fp)
 4009344:	1000010e 	bge	r2,zero,400934c <___vfprintf_internal_r+0x18b0>
 4009348:	0005883a 	mov	r2,zero
 400934c:	e0fff317 	ldw	r3,-52(fp)
 4009350:	1885c83a 	sub	r2,r3,r2
 4009354:	e0bfea15 	stw	r2,-88(fp)
 4009358:	e0bfea17 	ldw	r2,-88(fp)
 400935c:	0080340e 	bge	zero,r2,4009430 <___vfprintf_internal_r+0x1994>
 4009360:	00001906 	br	40093c8 <___vfprintf_internal_r+0x192c>
 4009364:	008100b4 	movhi	r2,1026
 4009368:	10aadc04 	addi	r2,r2,-21648
 400936c:	80800015 	stw	r2,0(r16)
 4009370:	00800404 	movi	r2,16
 4009374:	80800115 	stw	r2,4(r16)
 4009378:	e0bfdb17 	ldw	r2,-148(fp)
 400937c:	10800404 	addi	r2,r2,16
 4009380:	e0bfdb15 	stw	r2,-148(fp)
 4009384:	84000204 	addi	r16,r16,8
 4009388:	e0bfda17 	ldw	r2,-152(fp)
 400938c:	10800044 	addi	r2,r2,1
 4009390:	e0bfda15 	stw	r2,-152(fp)
 4009394:	e0bfda17 	ldw	r2,-152(fp)
 4009398:	10800210 	cmplti	r2,r2,8
 400939c:	1000071e 	bne	r2,zero,40093bc <___vfprintf_internal_r+0x1920>
 40093a0:	e0bfd904 	addi	r2,fp,-156
 40093a4:	100d883a 	mov	r6,r2
 40093a8:	e17fbc17 	ldw	r5,-272(fp)
 40093ac:	e13fbd17 	ldw	r4,-268(fp)
 40093b0:	4011aac0 	call	4011aac <__sprint_r>
 40093b4:	1001d61e 	bne	r2,zero,4009b10 <___vfprintf_internal_r+0x2074>
 40093b8:	e43fc904 	addi	r16,fp,-220
 40093bc:	e0bfea17 	ldw	r2,-88(fp)
 40093c0:	10bffc04 	addi	r2,r2,-16
 40093c4:	e0bfea15 	stw	r2,-88(fp)
 40093c8:	e0bfea17 	ldw	r2,-88(fp)
 40093cc:	10800448 	cmpgei	r2,r2,17
 40093d0:	103fe41e 	bne	r2,zero,4009364 <___vfprintf_internal_r+0x18c8>
 40093d4:	008100b4 	movhi	r2,1026
 40093d8:	10aadc04 	addi	r2,r2,-21648
 40093dc:	80800015 	stw	r2,0(r16)
 40093e0:	e0bfea17 	ldw	r2,-88(fp)
 40093e4:	80800115 	stw	r2,4(r16)
 40093e8:	e0ffdb17 	ldw	r3,-148(fp)
 40093ec:	e0bfea17 	ldw	r2,-88(fp)
 40093f0:	1885883a 	add	r2,r3,r2
 40093f4:	e0bfdb15 	stw	r2,-148(fp)
 40093f8:	84000204 	addi	r16,r16,8
 40093fc:	e0bfda17 	ldw	r2,-152(fp)
 4009400:	10800044 	addi	r2,r2,1
 4009404:	e0bfda15 	stw	r2,-152(fp)
 4009408:	e0bfda17 	ldw	r2,-152(fp)
 400940c:	10800210 	cmplti	r2,r2,8
 4009410:	1000071e 	bne	r2,zero,4009430 <___vfprintf_internal_r+0x1994>
 4009414:	e0bfd904 	addi	r2,fp,-156
 4009418:	100d883a 	mov	r6,r2
 400941c:	e17fbc17 	ldw	r5,-272(fp)
 4009420:	e13fbd17 	ldw	r4,-268(fp)
 4009424:	4011aac0 	call	4011aac <__sprint_r>
 4009428:	1001bb1e 	bne	r2,zero,4009b18 <___vfprintf_internal_r+0x207c>
 400942c:	e43fc904 	addi	r16,fp,-220
						    lead, zeroes);
					cp += lead;
 4009430:	e0bff317 	ldw	r2,-52(fp)
 4009434:	90a5883a 	add	r18,r18,r2
					    }
					    if (cp > convbuf + ndig)
						cp = convbuf + ndig;
					}
#endif
					if (expt < ndig || flags & ALT)
 4009438:	e0ffdf17 	ldw	r3,-132(fp)
 400943c:	e0bfdc17 	ldw	r2,-144(fp)
 4009440:	18800216 	blt	r3,r2,400944c <___vfprintf_internal_r+0x19b0>
 4009444:	8880004c 	andi	r2,r17,1
 4009448:	10001626 	beq	r2,zero,40094a4 <___vfprintf_internal_r+0x1a08>
					    PRINT (decimal_point, decp_len);
 400944c:	e0bfe817 	ldw	r2,-96(fp)
 4009450:	80800015 	stw	r2,0(r16)
 4009454:	e0bfe717 	ldw	r2,-100(fp)
 4009458:	80800115 	stw	r2,4(r16)
 400945c:	e0ffdb17 	ldw	r3,-148(fp)
 4009460:	e0bfe717 	ldw	r2,-100(fp)
 4009464:	1885883a 	add	r2,r3,r2
 4009468:	e0bfdb15 	stw	r2,-148(fp)
 400946c:	84000204 	addi	r16,r16,8
 4009470:	e0bfda17 	ldw	r2,-152(fp)
 4009474:	10800044 	addi	r2,r2,1
 4009478:	e0bfda15 	stw	r2,-152(fp)
 400947c:	e0bfda17 	ldw	r2,-152(fp)
 4009480:	10800210 	cmplti	r2,r2,8
 4009484:	1000071e 	bne	r2,zero,40094a4 <___vfprintf_internal_r+0x1a08>
 4009488:	e0bfd904 	addi	r2,fp,-156
 400948c:	100d883a 	mov	r6,r2
 4009490:	e17fbc17 	ldw	r5,-272(fp)
 4009494:	e13fbd17 	ldw	r4,-268(fp)
 4009498:	4011aac0 	call	4011aac <__sprint_r>
 400949c:	1001a01e 	bne	r2,zero,4009b20 <___vfprintf_internal_r+0x2084>
 40094a0:	e43fc904 	addi	r16,fp,-220
					PRINTANDPAD (cp, convbuf + ndig,
 40094a4:	e0bfdc17 	ldw	r2,-144(fp)
 40094a8:	1007883a 	mov	r3,r2
 40094ac:	e0bfe317 	ldw	r2,-116(fp)
 40094b0:	10c5883a 	add	r2,r2,r3
 40094b4:	1485c83a 	sub	r2,r2,r18
 40094b8:	e0bfe915 	stw	r2,-92(fp)
 40094bc:	e0ffdc17 	ldw	r3,-144(fp)
 40094c0:	e0bfdf17 	ldw	r2,-132(fp)
 40094c4:	1887c83a 	sub	r3,r3,r2
 40094c8:	e0bfe917 	ldw	r2,-92(fp)
 40094cc:	1880040e 	bge	r3,r2,40094e0 <___vfprintf_internal_r+0x1a44>
 40094d0:	e0ffdc17 	ldw	r3,-144(fp)
 40094d4:	e0bfdf17 	ldw	r2,-132(fp)
 40094d8:	1885c83a 	sub	r2,r3,r2
 40094dc:	e0bfe915 	stw	r2,-92(fp)
 40094e0:	e0bfe917 	ldw	r2,-92(fp)
 40094e4:	0080150e 	bge	zero,r2,400953c <___vfprintf_internal_r+0x1aa0>
 40094e8:	84800015 	stw	r18,0(r16)
 40094ec:	e0bfe917 	ldw	r2,-92(fp)
 40094f0:	80800115 	stw	r2,4(r16)
 40094f4:	e0ffdb17 	ldw	r3,-148(fp)
 40094f8:	e0bfe917 	ldw	r2,-92(fp)
 40094fc:	1885883a 	add	r2,r3,r2
 4009500:	e0bfdb15 	stw	r2,-148(fp)
 4009504:	84000204 	addi	r16,r16,8
 4009508:	e0bfda17 	ldw	r2,-152(fp)
 400950c:	10800044 	addi	r2,r2,1
 4009510:	e0bfda15 	stw	r2,-152(fp)
 4009514:	e0bfda17 	ldw	r2,-152(fp)
 4009518:	10800210 	cmplti	r2,r2,8
 400951c:	1000071e 	bne	r2,zero,400953c <___vfprintf_internal_r+0x1aa0>
 4009520:	e0bfd904 	addi	r2,fp,-156
 4009524:	100d883a 	mov	r6,r2
 4009528:	e17fbc17 	ldw	r5,-272(fp)
 400952c:	e13fbd17 	ldw	r4,-268(fp)
 4009530:	4011aac0 	call	4011aac <__sprint_r>
 4009534:	10017c1e 	bne	r2,zero,4009b28 <___vfprintf_internal_r+0x208c>
 4009538:	e43fc904 	addi	r16,fp,-220
 400953c:	e0ffdc17 	ldw	r3,-144(fp)
 4009540:	e0bfdf17 	ldw	r2,-132(fp)
 4009544:	1887c83a 	sub	r3,r3,r2
 4009548:	e0bfe917 	ldw	r2,-92(fp)
 400954c:	1000010e 	bge	r2,zero,4009554 <___vfprintf_internal_r+0x1ab8>
 4009550:	0005883a 	mov	r2,zero
 4009554:	1885c83a 	sub	r2,r3,r2
 4009558:	e0bfe915 	stw	r2,-92(fp)
 400955c:	e0bfe917 	ldw	r2,-92(fp)
 4009560:	0080e60e 	bge	zero,r2,40098fc <___vfprintf_internal_r+0x1e60>
 4009564:	00001906 	br	40095cc <___vfprintf_internal_r+0x1b30>
 4009568:	008100b4 	movhi	r2,1026
 400956c:	10aadc04 	addi	r2,r2,-21648
 4009570:	80800015 	stw	r2,0(r16)
 4009574:	00800404 	movi	r2,16
 4009578:	80800115 	stw	r2,4(r16)
 400957c:	e0bfdb17 	ldw	r2,-148(fp)
 4009580:	10800404 	addi	r2,r2,16
 4009584:	e0bfdb15 	stw	r2,-148(fp)
 4009588:	84000204 	addi	r16,r16,8
 400958c:	e0bfda17 	ldw	r2,-152(fp)
 4009590:	10800044 	addi	r2,r2,1
 4009594:	e0bfda15 	stw	r2,-152(fp)
 4009598:	e0bfda17 	ldw	r2,-152(fp)
 400959c:	10800210 	cmplti	r2,r2,8
 40095a0:	1000071e 	bne	r2,zero,40095c0 <___vfprintf_internal_r+0x1b24>
 40095a4:	e0bfd904 	addi	r2,fp,-156
 40095a8:	100d883a 	mov	r6,r2
 40095ac:	e17fbc17 	ldw	r5,-272(fp)
 40095b0:	e13fbd17 	ldw	r4,-268(fp)
 40095b4:	4011aac0 	call	4011aac <__sprint_r>
 40095b8:	10015d1e 	bne	r2,zero,4009b30 <___vfprintf_internal_r+0x2094>
 40095bc:	e43fc904 	addi	r16,fp,-220
 40095c0:	e0bfe917 	ldw	r2,-92(fp)
 40095c4:	10bffc04 	addi	r2,r2,-16
 40095c8:	e0bfe915 	stw	r2,-92(fp)
 40095cc:	e0bfe917 	ldw	r2,-92(fp)
 40095d0:	10800448 	cmpgei	r2,r2,17
 40095d4:	103fe41e 	bne	r2,zero,4009568 <___vfprintf_internal_r+0x1acc>
 40095d8:	008100b4 	movhi	r2,1026
 40095dc:	10aadc04 	addi	r2,r2,-21648
 40095e0:	80800015 	stw	r2,0(r16)
 40095e4:	e0bfe917 	ldw	r2,-92(fp)
 40095e8:	80800115 	stw	r2,4(r16)
 40095ec:	e0ffdb17 	ldw	r3,-148(fp)
 40095f0:	e0bfe917 	ldw	r2,-92(fp)
 40095f4:	1885883a 	add	r2,r3,r2
 40095f8:	e0bfdb15 	stw	r2,-148(fp)
 40095fc:	84000204 	addi	r16,r16,8
 4009600:	e0bfda17 	ldw	r2,-152(fp)
 4009604:	10800044 	addi	r2,r2,1
 4009608:	e0bfda15 	stw	r2,-152(fp)
 400960c:	e0bfda17 	ldw	r2,-152(fp)
 4009610:	10800210 	cmplti	r2,r2,8
 4009614:	1000b91e 	bne	r2,zero,40098fc <___vfprintf_internal_r+0x1e60>
 4009618:	e0bfd904 	addi	r2,fp,-156
 400961c:	100d883a 	mov	r6,r2
 4009620:	e17fbc17 	ldw	r5,-272(fp)
 4009624:	e13fbd17 	ldw	r4,-268(fp)
 4009628:	4011aac0 	call	4011aac <__sprint_r>
 400962c:	1001421e 	bne	r2,zero,4009b38 <___vfprintf_internal_r+0x209c>
 4009630:	e43fc904 	addi	r16,fp,-220
 4009634:	0000b106 	br	40098fc <___vfprintf_internal_r+0x1e60>
						     ndig - expt, zeroes);
				}
			} else {	/* 'a', 'A', 'e', or 'E' */
				if (ndig > 1 || flags & ALT) {
 4009638:	e0bfdc17 	ldw	r2,-144(fp)
 400963c:	10800088 	cmpgei	r2,r2,2
 4009640:	1000021e 	bne	r2,zero,400964c <___vfprintf_internal_r+0x1bb0>
 4009644:	8880004c 	andi	r2,r17,1
 4009648:	10008026 	beq	r2,zero,400984c <___vfprintf_internal_r+0x1db0>
					PRINT (cp, 1);
 400964c:	84800015 	stw	r18,0(r16)
 4009650:	00800044 	movi	r2,1
 4009654:	80800115 	stw	r2,4(r16)
 4009658:	e0bfdb17 	ldw	r2,-148(fp)
 400965c:	10800044 	addi	r2,r2,1
 4009660:	e0bfdb15 	stw	r2,-148(fp)
 4009664:	84000204 	addi	r16,r16,8
 4009668:	e0bfda17 	ldw	r2,-152(fp)
 400966c:	10800044 	addi	r2,r2,1
 4009670:	e0bfda15 	stw	r2,-152(fp)
 4009674:	e0bfda17 	ldw	r2,-152(fp)
 4009678:	10800210 	cmplti	r2,r2,8
 400967c:	1000071e 	bne	r2,zero,400969c <___vfprintf_internal_r+0x1c00>
 4009680:	e0bfd904 	addi	r2,fp,-156
 4009684:	100d883a 	mov	r6,r2
 4009688:	e17fbc17 	ldw	r5,-272(fp)
 400968c:	e13fbd17 	ldw	r4,-268(fp)
 4009690:	4011aac0 	call	4011aac <__sprint_r>
 4009694:	10012a1e 	bne	r2,zero,4009b40 <___vfprintf_internal_r+0x20a4>
 4009698:	e43fc904 	addi	r16,fp,-220
					cp++;
 400969c:	94800044 	addi	r18,r18,1
					PRINT (decimal_point, decp_len);
 40096a0:	e0bfe817 	ldw	r2,-96(fp)
 40096a4:	80800015 	stw	r2,0(r16)
 40096a8:	e0bfe717 	ldw	r2,-100(fp)
 40096ac:	80800115 	stw	r2,4(r16)
 40096b0:	e0ffdb17 	ldw	r3,-148(fp)
 40096b4:	e0bfe717 	ldw	r2,-100(fp)
 40096b8:	1885883a 	add	r2,r3,r2
 40096bc:	e0bfdb15 	stw	r2,-148(fp)
 40096c0:	84000204 	addi	r16,r16,8
 40096c4:	e0bfda17 	ldw	r2,-152(fp)
 40096c8:	10800044 	addi	r2,r2,1
 40096cc:	e0bfda15 	stw	r2,-152(fp)
 40096d0:	e0bfda17 	ldw	r2,-152(fp)
 40096d4:	10800210 	cmplti	r2,r2,8
 40096d8:	1000071e 	bne	r2,zero,40096f8 <___vfprintf_internal_r+0x1c5c>
 40096dc:	e0bfd904 	addi	r2,fp,-156
 40096e0:	100d883a 	mov	r6,r2
 40096e4:	e17fbc17 	ldw	r5,-272(fp)
 40096e8:	e13fbd17 	ldw	r4,-268(fp)
 40096ec:	4011aac0 	call	4011aac <__sprint_r>
 40096f0:	1001151e 	bne	r2,zero,4009b48 <___vfprintf_internal_r+0x20ac>
 40096f4:	e43fc904 	addi	r16,fp,-220
					if (_fpvalue) {
 40096f8:	e0bfe017 	ldw	r2,-128(fp)
 40096fc:	e0ffe117 	ldw	r3,-124(fp)
 4009700:	000d883a 	mov	r6,zero
 4009704:	000f883a 	mov	r7,zero
 4009708:	1009883a 	mov	r4,r2
 400970c:	180b883a 	mov	r5,r3
 4009710:	40166ec0 	call	40166ec <__eqdf2>
 4009714:	10001826 	beq	r2,zero,4009778 <___vfprintf_internal_r+0x1cdc>
						PRINT (cp, ndig - 1);
 4009718:	84800015 	stw	r18,0(r16)
 400971c:	e0bfdc17 	ldw	r2,-144(fp)
 4009720:	10bfffc4 	addi	r2,r2,-1
 4009724:	80800115 	stw	r2,4(r16)
 4009728:	e0bfdb17 	ldw	r2,-148(fp)
 400972c:	e0ffdc17 	ldw	r3,-144(fp)
 4009730:	10c5883a 	add	r2,r2,r3
 4009734:	10bfffc4 	addi	r2,r2,-1
 4009738:	e0bfdb15 	stw	r2,-148(fp)
 400973c:	84000204 	addi	r16,r16,8
 4009740:	e0bfda17 	ldw	r2,-152(fp)
 4009744:	10800044 	addi	r2,r2,1
 4009748:	e0bfda15 	stw	r2,-152(fp)
 400974c:	e0bfda17 	ldw	r2,-152(fp)
 4009750:	10800210 	cmplti	r2,r2,8
 4009754:	1000521e 	bne	r2,zero,40098a0 <___vfprintf_internal_r+0x1e04>
 4009758:	e0bfd904 	addi	r2,fp,-156
 400975c:	100d883a 	mov	r6,r2
 4009760:	e17fbc17 	ldw	r5,-272(fp)
 4009764:	e13fbd17 	ldw	r4,-268(fp)
 4009768:	4011aac0 	call	4011aac <__sprint_r>
 400976c:	1000f81e 	bne	r2,zero,4009b50 <___vfprintf_internal_r+0x20b4>
 4009770:	e43fc904 	addi	r16,fp,-220
					if (_fpvalue) {
 4009774:	00004a06 	br	40098a0 <___vfprintf_internal_r+0x1e04>
					} else	/* 0.[0..] */
						/* __dtoa irregularity */
						PAD (ndig - 1, zeroes);
 4009778:	e0bfdc17 	ldw	r2,-144(fp)
 400977c:	14ffffc4 	addi	r19,r2,-1
 4009780:	04c0470e 	bge	zero,r19,40098a0 <___vfprintf_internal_r+0x1e04>
 4009784:	00001706 	br	40097e4 <___vfprintf_internal_r+0x1d48>
 4009788:	008100b4 	movhi	r2,1026
 400978c:	10aadc04 	addi	r2,r2,-21648
 4009790:	80800015 	stw	r2,0(r16)
 4009794:	00800404 	movi	r2,16
 4009798:	80800115 	stw	r2,4(r16)
 400979c:	e0bfdb17 	ldw	r2,-148(fp)
 40097a0:	10800404 	addi	r2,r2,16
 40097a4:	e0bfdb15 	stw	r2,-148(fp)
 40097a8:	84000204 	addi	r16,r16,8
 40097ac:	e0bfda17 	ldw	r2,-152(fp)
 40097b0:	10800044 	addi	r2,r2,1
 40097b4:	e0bfda15 	stw	r2,-152(fp)
 40097b8:	e0bfda17 	ldw	r2,-152(fp)
 40097bc:	10800210 	cmplti	r2,r2,8
 40097c0:	1000071e 	bne	r2,zero,40097e0 <___vfprintf_internal_r+0x1d44>
 40097c4:	e0bfd904 	addi	r2,fp,-156
 40097c8:	100d883a 	mov	r6,r2
 40097cc:	e17fbc17 	ldw	r5,-272(fp)
 40097d0:	e13fbd17 	ldw	r4,-268(fp)
 40097d4:	4011aac0 	call	4011aac <__sprint_r>
 40097d8:	1000df1e 	bne	r2,zero,4009b58 <___vfprintf_internal_r+0x20bc>
 40097dc:	e43fc904 	addi	r16,fp,-220
 40097e0:	9cfffc04 	addi	r19,r19,-16
 40097e4:	98800448 	cmpgei	r2,r19,17
 40097e8:	103fe71e 	bne	r2,zero,4009788 <___vfprintf_internal_r+0x1cec>
 40097ec:	008100b4 	movhi	r2,1026
 40097f0:	10aadc04 	addi	r2,r2,-21648
 40097f4:	80800015 	stw	r2,0(r16)
 40097f8:	9805883a 	mov	r2,r19
 40097fc:	80800115 	stw	r2,4(r16)
 4009800:	e0bfdb17 	ldw	r2,-148(fp)
 4009804:	9807883a 	mov	r3,r19
 4009808:	10c5883a 	add	r2,r2,r3
 400980c:	e0bfdb15 	stw	r2,-148(fp)
 4009810:	84000204 	addi	r16,r16,8
 4009814:	e0bfda17 	ldw	r2,-152(fp)
 4009818:	10800044 	addi	r2,r2,1
 400981c:	e0bfda15 	stw	r2,-152(fp)
 4009820:	e0bfda17 	ldw	r2,-152(fp)
 4009824:	10800210 	cmplti	r2,r2,8
 4009828:	10001d1e 	bne	r2,zero,40098a0 <___vfprintf_internal_r+0x1e04>
 400982c:	e0bfd904 	addi	r2,fp,-156
 4009830:	100d883a 	mov	r6,r2
 4009834:	e17fbc17 	ldw	r5,-272(fp)
 4009838:	e13fbd17 	ldw	r4,-268(fp)
 400983c:	4011aac0 	call	4011aac <__sprint_r>
 4009840:	1000c71e 	bne	r2,zero,4009b60 <___vfprintf_internal_r+0x20c4>
 4009844:	e43fc904 	addi	r16,fp,-220
					if (_fpvalue) {
 4009848:	00001506 	br	40098a0 <___vfprintf_internal_r+0x1e04>
				} else	/* XeYYY */
					PRINT (cp, 1);
 400984c:	84800015 	stw	r18,0(r16)
 4009850:	00800044 	movi	r2,1
 4009854:	80800115 	stw	r2,4(r16)
 4009858:	e0bfdb17 	ldw	r2,-148(fp)
 400985c:	10800044 	addi	r2,r2,1
 4009860:	e0bfdb15 	stw	r2,-148(fp)
 4009864:	84000204 	addi	r16,r16,8
 4009868:	e0bfda17 	ldw	r2,-152(fp)
 400986c:	10800044 	addi	r2,r2,1
 4009870:	e0bfda15 	stw	r2,-152(fp)
 4009874:	e0bfda17 	ldw	r2,-152(fp)
 4009878:	10800210 	cmplti	r2,r2,8
 400987c:	1000091e 	bne	r2,zero,40098a4 <___vfprintf_internal_r+0x1e08>
 4009880:	e0bfd904 	addi	r2,fp,-156
 4009884:	100d883a 	mov	r6,r2
 4009888:	e17fbc17 	ldw	r5,-272(fp)
 400988c:	e13fbd17 	ldw	r4,-268(fp)
 4009890:	4011aac0 	call	4011aac <__sprint_r>
 4009894:	1000b41e 	bne	r2,zero,4009b68 <___vfprintf_internal_r+0x20cc>
 4009898:	e43fc904 	addi	r16,fp,-220
 400989c:	00000106 	br	40098a4 <___vfprintf_internal_r+0x1e08>
					if (_fpvalue) {
 40098a0:	0001883a 	nop
				PRINT (expstr, expsize);
 40098a4:	e0bfdd44 	addi	r2,fp,-139
 40098a8:	80800015 	stw	r2,0(r16)
 40098ac:	e0bff417 	ldw	r2,-48(fp)
 40098b0:	80800115 	stw	r2,4(r16)
 40098b4:	e0ffdb17 	ldw	r3,-148(fp)
 40098b8:	e0bff417 	ldw	r2,-48(fp)
 40098bc:	1885883a 	add	r2,r3,r2
 40098c0:	e0bfdb15 	stw	r2,-148(fp)
 40098c4:	84000204 	addi	r16,r16,8
 40098c8:	e0bfda17 	ldw	r2,-152(fp)
 40098cc:	10800044 	addi	r2,r2,1
 40098d0:	e0bfda15 	stw	r2,-152(fp)
 40098d4:	e0bfda17 	ldw	r2,-152(fp)
 40098d8:	10800210 	cmplti	r2,r2,8
 40098dc:	1000071e 	bne	r2,zero,40098fc <___vfprintf_internal_r+0x1e60>
 40098e0:	e0bfd904 	addi	r2,fp,-156
 40098e4:	100d883a 	mov	r6,r2
 40098e8:	e17fbc17 	ldw	r5,-272(fp)
 40098ec:	e13fbd17 	ldw	r4,-268(fp)
 40098f0:	4011aac0 	call	4011aac <__sprint_r>
 40098f4:	10009e1e 	bne	r2,zero,4009b70 <___vfprintf_internal_r+0x20d4>
 40098f8:	e43fc904 	addi	r16,fp,-220
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
 40098fc:	8880010c 	andi	r2,r17,4
 4009900:	10003526 	beq	r2,zero,40099d8 <___vfprintf_internal_r+0x1f3c>
			PAD (width - realsz, blanks);
 4009904:	e0fff617 	ldw	r3,-40(fp)
 4009908:	e0bfee17 	ldw	r2,-72(fp)
 400990c:	18a7c83a 	sub	r19,r3,r2
 4009910:	04c0310e 	bge	zero,r19,40099d8 <___vfprintf_internal_r+0x1f3c>
 4009914:	00001706 	br	4009974 <___vfprintf_internal_r+0x1ed8>
 4009918:	008100b4 	movhi	r2,1026
 400991c:	10aad804 	addi	r2,r2,-21664
 4009920:	80800015 	stw	r2,0(r16)
 4009924:	00800404 	movi	r2,16
 4009928:	80800115 	stw	r2,4(r16)
 400992c:	e0bfdb17 	ldw	r2,-148(fp)
 4009930:	10800404 	addi	r2,r2,16
 4009934:	e0bfdb15 	stw	r2,-148(fp)
 4009938:	84000204 	addi	r16,r16,8
 400993c:	e0bfda17 	ldw	r2,-152(fp)
 4009940:	10800044 	addi	r2,r2,1
 4009944:	e0bfda15 	stw	r2,-152(fp)
 4009948:	e0bfda17 	ldw	r2,-152(fp)
 400994c:	10800210 	cmplti	r2,r2,8
 4009950:	1000071e 	bne	r2,zero,4009970 <___vfprintf_internal_r+0x1ed4>
 4009954:	e0bfd904 	addi	r2,fp,-156
 4009958:	100d883a 	mov	r6,r2
 400995c:	e17fbc17 	ldw	r5,-272(fp)
 4009960:	e13fbd17 	ldw	r4,-268(fp)
 4009964:	4011aac0 	call	4011aac <__sprint_r>
 4009968:	1000831e 	bne	r2,zero,4009b78 <___vfprintf_internal_r+0x20dc>
 400996c:	e43fc904 	addi	r16,fp,-220
 4009970:	9cfffc04 	addi	r19,r19,-16
 4009974:	98800448 	cmpgei	r2,r19,17
 4009978:	103fe71e 	bne	r2,zero,4009918 <___vfprintf_internal_r+0x1e7c>
 400997c:	008100b4 	movhi	r2,1026
 4009980:	10aad804 	addi	r2,r2,-21664
 4009984:	80800015 	stw	r2,0(r16)
 4009988:	9805883a 	mov	r2,r19
 400998c:	80800115 	stw	r2,4(r16)
 4009990:	e0bfdb17 	ldw	r2,-148(fp)
 4009994:	9807883a 	mov	r3,r19
 4009998:	10c5883a 	add	r2,r2,r3
 400999c:	e0bfdb15 	stw	r2,-148(fp)
 40099a0:	84000204 	addi	r16,r16,8
 40099a4:	e0bfda17 	ldw	r2,-152(fp)
 40099a8:	10800044 	addi	r2,r2,1
 40099ac:	e0bfda15 	stw	r2,-152(fp)
 40099b0:	e0bfda17 	ldw	r2,-152(fp)
 40099b4:	10800210 	cmplti	r2,r2,8
 40099b8:	1000071e 	bne	r2,zero,40099d8 <___vfprintf_internal_r+0x1f3c>
 40099bc:	e0bfd904 	addi	r2,fp,-156
 40099c0:	100d883a 	mov	r6,r2
 40099c4:	e17fbc17 	ldw	r5,-272(fp)
 40099c8:	e13fbd17 	ldw	r4,-268(fp)
 40099cc:	4011aac0 	call	4011aac <__sprint_r>
 40099d0:	10006b1e 	bne	r2,zero,4009b80 <___vfprintf_internal_r+0x20e4>
 40099d4:	e43fc904 	addi	r16,fp,-220

		/* finally, adjust ret */
		ret += width > realsz ? width : realsz;
 40099d8:	e0fff617 	ldw	r3,-40(fp)
 40099dc:	e0bfee17 	ldw	r2,-72(fp)
 40099e0:	10c0010e 	bge	r2,r3,40099e8 <___vfprintf_internal_r+0x1f4c>
 40099e4:	1805883a 	mov	r2,r3
 40099e8:	e0fff717 	ldw	r3,-36(fp)
 40099ec:	1885883a 	add	r2,r3,r2
 40099f0:	e0bff715 	stw	r2,-36(fp)

		FLUSH ();	/* copy out the I/O vectors */
 40099f4:	e0bfdb17 	ldw	r2,-148(fp)
 40099f8:	10000626 	beq	r2,zero,4009a14 <___vfprintf_internal_r+0x1f78>
 40099fc:	e0bfd904 	addi	r2,fp,-156
 4009a00:	100d883a 	mov	r6,r2
 4009a04:	e17fbc17 	ldw	r5,-272(fp)
 4009a08:	e13fbd17 	ldw	r4,-268(fp)
 4009a0c:	4011aac0 	call	4011aac <__sprint_r>
 4009a10:	10005d1e 	bne	r2,zero,4009b88 <___vfprintf_internal_r+0x20ec>
 4009a14:	e03fda15 	stw	zero,-152(fp)
 4009a18:	e43fc904 	addi	r16,fp,-220

                if (malloc_buf != NULL) {
 4009a1c:	e0bfeb17 	ldw	r2,-84(fp)
 4009a20:	10387c26 	beq	r2,zero,4007c14 <___vfprintf_internal_r+0x178>
			_free_r (data, malloc_buf);
 4009a24:	e17feb17 	ldw	r5,-84(fp)
 4009a28:	e13fbd17 	ldw	r4,-268(fp)
 4009a2c:	400cb0c0 	call	400cb0c <_free_r>
			malloc_buf = NULL;
 4009a30:	e03feb15 	stw	zero,-84(fp)
	        cp = fmt;
 4009a34:	00387706 	br	4007c14 <___vfprintf_internal_r+0x178>
                    goto done;
 4009a38:	0001883a 	nop
 4009a3c:	00000106 	br	4009a44 <___vfprintf_internal_r+0x1fa8>
				goto done;
 4009a40:	0001883a 	nop
		}
	}
done:
	FLUSH ();
 4009a44:	e0bfdb17 	ldw	r2,-148(fp)
 4009a48:	10000626 	beq	r2,zero,4009a64 <___vfprintf_internal_r+0x1fc8>
 4009a4c:	e0bfd904 	addi	r2,fp,-156
 4009a50:	100d883a 	mov	r6,r2
 4009a54:	e17fbc17 	ldw	r5,-272(fp)
 4009a58:	e13fbd17 	ldw	r4,-268(fp)
 4009a5c:	4011aac0 	call	4011aac <__sprint_r>
 4009a60:	10004b1e 	bne	r2,zero,4009b90 <___vfprintf_internal_r+0x20f4>
 4009a64:	e03fda15 	stw	zero,-152(fp)
 4009a68:	e43fc904 	addi	r16,fp,-220
 4009a6c:	00004906 	br	4009b94 <___vfprintf_internal_r+0x20f8>
			PRINT (cp, m);
 4009a70:	0001883a 	nop
 4009a74:	00004706 	br	4009b94 <___vfprintf_internal_r+0x20f8>
			PAD (width - realsz, blanks);
 4009a78:	0001883a 	nop
 4009a7c:	00004506 	br	4009b94 <___vfprintf_internal_r+0x20f8>
 4009a80:	0001883a 	nop
 4009a84:	00004306 	br	4009b94 <___vfprintf_internal_r+0x20f8>
			PRINT (&sign, 1);
 4009a88:	0001883a 	nop
 4009a8c:	00004106 	br	4009b94 <___vfprintf_internal_r+0x20f8>
			PRINT (ox, 2);
 4009a90:	0001883a 	nop
 4009a94:	00003f06 	br	4009b94 <___vfprintf_internal_r+0x20f8>
			PAD (width - realsz, zeroes);
 4009a98:	0001883a 	nop
 4009a9c:	00003d06 	br	4009b94 <___vfprintf_internal_r+0x20f8>
 4009aa0:	0001883a 	nop
 4009aa4:	00003b06 	br	4009b94 <___vfprintf_internal_r+0x20f8>
		PAD (dprec - size, zeroes);
 4009aa8:	0001883a 	nop
 4009aac:	00003906 	br	4009b94 <___vfprintf_internal_r+0x20f8>
 4009ab0:	0001883a 	nop
 4009ab4:	00003706 	br	4009b94 <___vfprintf_internal_r+0x20f8>
			PRINT (cp, size);
 4009ab8:	0001883a 	nop
 4009abc:	00003506 	br	4009b94 <___vfprintf_internal_r+0x20f8>
					PRINT ("0", 1);
 4009ac0:	0001883a 	nop
 4009ac4:	00003306 	br	4009b94 <___vfprintf_internal_r+0x20f8>
						PRINT (decimal_point, decp_len);
 4009ac8:	0001883a 	nop
 4009acc:	00003106 	br	4009b94 <___vfprintf_internal_r+0x20f8>
						PAD (ndig - 1, zeroes);
 4009ad0:	0001883a 	nop
 4009ad4:	00002f06 	br	4009b94 <___vfprintf_internal_r+0x20f8>
 4009ad8:	0001883a 	nop
 4009adc:	00002d06 	br	4009b94 <___vfprintf_internal_r+0x20f8>
					PRINT ("0", 1);
 4009ae0:	0001883a 	nop
 4009ae4:	00002b06 	br	4009b94 <___vfprintf_internal_r+0x20f8>
						PRINT (decimal_point, decp_len);
 4009ae8:	0001883a 	nop
 4009aec:	00002906 	br	4009b94 <___vfprintf_internal_r+0x20f8>
						PAD (-expt, zeroes);
 4009af0:	0001883a 	nop
 4009af4:	00002706 	br	4009b94 <___vfprintf_internal_r+0x20f8>
 4009af8:	0001883a 	nop
 4009afc:	00002506 	br	4009b94 <___vfprintf_internal_r+0x20f8>
						PRINT (cp, ndig);
 4009b00:	0001883a 	nop
 4009b04:	00002306 	br	4009b94 <___vfprintf_internal_r+0x20f8>
					PRINTANDPAD(cp, convbuf + ndig,
 4009b08:	0001883a 	nop
 4009b0c:	00002106 	br	4009b94 <___vfprintf_internal_r+0x20f8>
 4009b10:	0001883a 	nop
 4009b14:	00001f06 	br	4009b94 <___vfprintf_internal_r+0x20f8>
 4009b18:	0001883a 	nop
 4009b1c:	00001d06 	br	4009b94 <___vfprintf_internal_r+0x20f8>
					    PRINT (decimal_point, decp_len);
 4009b20:	0001883a 	nop
 4009b24:	00001b06 	br	4009b94 <___vfprintf_internal_r+0x20f8>
					PRINTANDPAD (cp, convbuf + ndig,
 4009b28:	0001883a 	nop
 4009b2c:	00001906 	br	4009b94 <___vfprintf_internal_r+0x20f8>
 4009b30:	0001883a 	nop
 4009b34:	00001706 	br	4009b94 <___vfprintf_internal_r+0x20f8>
 4009b38:	0001883a 	nop
 4009b3c:	00001506 	br	4009b94 <___vfprintf_internal_r+0x20f8>
					PRINT (cp, 1);
 4009b40:	0001883a 	nop
 4009b44:	00001306 	br	4009b94 <___vfprintf_internal_r+0x20f8>
					PRINT (decimal_point, decp_len);
 4009b48:	0001883a 	nop
 4009b4c:	00001106 	br	4009b94 <___vfprintf_internal_r+0x20f8>
						PRINT (cp, ndig - 1);
 4009b50:	0001883a 	nop
 4009b54:	00000f06 	br	4009b94 <___vfprintf_internal_r+0x20f8>
						PAD (ndig - 1, zeroes);
 4009b58:	0001883a 	nop
 4009b5c:	00000d06 	br	4009b94 <___vfprintf_internal_r+0x20f8>
 4009b60:	0001883a 	nop
 4009b64:	00000b06 	br	4009b94 <___vfprintf_internal_r+0x20f8>
					PRINT (cp, 1);
 4009b68:	0001883a 	nop
 4009b6c:	00000906 	br	4009b94 <___vfprintf_internal_r+0x20f8>
				PRINT (expstr, expsize);
 4009b70:	0001883a 	nop
 4009b74:	00000706 	br	4009b94 <___vfprintf_internal_r+0x20f8>
			PAD (width - realsz, blanks);
 4009b78:	0001883a 	nop
 4009b7c:	00000506 	br	4009b94 <___vfprintf_internal_r+0x20f8>
 4009b80:	0001883a 	nop
 4009b84:	00000306 	br	4009b94 <___vfprintf_internal_r+0x20f8>
		FLUSH ();	/* copy out the I/O vectors */
 4009b88:	0001883a 	nop
 4009b8c:	00000106 	br	4009b94 <___vfprintf_internal_r+0x20f8>
	FLUSH ();
 4009b90:	0001883a 	nop
error:
	if (malloc_buf != NULL)
 4009b94:	e0bfeb17 	ldw	r2,-84(fp)
 4009b98:	10000326 	beq	r2,zero,4009ba8 <___vfprintf_internal_r+0x210c>
		_free_r (data, malloc_buf);
 4009b9c:	e17feb17 	ldw	r5,-84(fp)
 4009ba0:	e13fbd17 	ldw	r4,-268(fp)
 4009ba4:	400cb0c0 	call	400cb0c <_free_r>
#ifndef STRING_ONLY
	_newlib_flockfile_end (fp);
#endif
	return (__sferror (fp) ? EOF : ret);
 4009ba8:	e0bfbc17 	ldw	r2,-272(fp)
 4009bac:	1080030b 	ldhu	r2,12(r2)
 4009bb0:	10bfffcc 	andi	r2,r2,65535
 4009bb4:	1080100c 	andi	r2,r2,64
 4009bb8:	1000021e 	bne	r2,zero,4009bc4 <___vfprintf_internal_r+0x2128>
 4009bbc:	e0bff717 	ldw	r2,-36(fp)
 4009bc0:	00000106 	br	4009bc8 <___vfprintf_internal_r+0x212c>
 4009bc4:	00bfffc4 	movi	r2,-1
	/* NOTREACHED */
}
 4009bc8:	e6fff804 	addi	sp,fp,-32
 4009bcc:	dfc00917 	ldw	ra,36(sp)
 4009bd0:	df000817 	ldw	fp,32(sp)
 4009bd4:	ddc00717 	ldw	r23,28(sp)
 4009bd8:	dd800617 	ldw	r22,24(sp)
 4009bdc:	dd400517 	ldw	r21,20(sp)
 4009be0:	dd000417 	ldw	r20,16(sp)
 4009be4:	dcc00317 	ldw	r19,12(sp)
 4009be8:	dc800217 	ldw	r18,8(sp)
 4009bec:	dc400117 	ldw	r17,4(sp)
 4009bf0:	dc000017 	ldw	r16,0(sp)
 4009bf4:	dec00a04 	addi	sp,sp,40
 4009bf8:	f800283a 	ret

04009bfc <cvt>:
   [aAeEfFgG]; if it is [aA], then the return string lives in BUF,
   otherwise the return value shares the mprec reentrant storage.  */
static char *
cvt(struct _reent *data, _PRINTF_FLOAT_TYPE value, int ndigits, int flags,
    char *sign, int *decpt, int ch, int *length, char *buf)
{
 4009bfc:	deffef04 	addi	sp,sp,-68
 4009c00:	dfc01015 	stw	ra,64(sp)
 4009c04:	df000f15 	stw	fp,60(sp)
 4009c08:	df000f04 	addi	fp,sp,60
 4009c0c:	e13ff815 	stw	r4,-32(fp)
 4009c10:	e17ff615 	stw	r5,-40(fp)
 4009c14:	e1bff715 	stw	r6,-36(fp)
 4009c18:	e1fff515 	stw	r7,-44(fp)
	int mode, dsgn;
	char *digits, *bp, *rve;
# ifdef _NO_LONGDBL
	union double_union tmp;

	tmp.d = value;
 4009c1c:	e0bff617 	ldw	r2,-40(fp)
 4009c20:	e0bff915 	stw	r2,-28(fp)
 4009c24:	e0bff717 	ldw	r2,-36(fp)
 4009c28:	e0bffa15 	stw	r2,-24(fp)
	if (word0 (tmp) & Sign_bit) { /* this will check for < 0 and -0.0 */
 4009c2c:	e0bffa17 	ldw	r2,-24(fp)
 4009c30:	1000090e 	bge	r2,zero,4009c58 <cvt+0x5c>
		value = -value;
 4009c34:	e0bff617 	ldw	r2,-40(fp)
 4009c38:	e0bff615 	stw	r2,-40(fp)
 4009c3c:	e0bff717 	ldw	r2,-36(fp)
 4009c40:	10a0003c 	xorhi	r2,r2,32768
 4009c44:	e0bff715 	stw	r2,-36(fp)
		*sign = '-';
 4009c48:	e0800317 	ldw	r2,12(fp)
 4009c4c:	00c00b44 	movi	r3,45
 4009c50:	10c00005 	stb	r3,0(r2)
 4009c54:	00000206 	br	4009c60 <cvt+0x64>
	} else
		*sign = '\000';
 4009c58:	e0800317 	ldw	r2,12(fp)
 4009c5c:	10000005 	stb	zero,0(r2)
		}
		*length = bp - buf;
		return buf;
	}
# endif /* _WANT_IO_C99_FORMATS */
	if (ch == 'f' || ch == 'F') {
 4009c60:	e0800517 	ldw	r2,20(fp)
 4009c64:	108019a0 	cmpeqi	r2,r2,102
 4009c68:	1000031e 	bne	r2,zero,4009c78 <cvt+0x7c>
 4009c6c:	e0800517 	ldw	r2,20(fp)
 4009c70:	10801198 	cmpnei	r2,r2,70
 4009c74:	1000031e 	bne	r2,zero,4009c84 <cvt+0x88>
		mode = 3;		/* ndigits after the decimal point */
 4009c78:	008000c4 	movi	r2,3
 4009c7c:	e0bfff15 	stw	r2,-4(fp)
 4009c80:	00000b06 	br	4009cb0 <cvt+0xb4>
	} else {
		/* To obtain ndigits after the decimal point for the 'e'
		 * and 'E' formats, round to ndigits + 1 significant
		 * figures.
		 */
		if (ch == 'e' || ch == 'E') {
 4009c84:	e0800517 	ldw	r2,20(fp)
 4009c88:	10801960 	cmpeqi	r2,r2,101
 4009c8c:	1000031e 	bne	r2,zero,4009c9c <cvt+0xa0>
 4009c90:	e0800517 	ldw	r2,20(fp)
 4009c94:	10801158 	cmpnei	r2,r2,69
 4009c98:	1000031e 	bne	r2,zero,4009ca8 <cvt+0xac>
			ndigits++;
 4009c9c:	e0bff517 	ldw	r2,-44(fp)
 4009ca0:	10800044 	addi	r2,r2,1
 4009ca4:	e0bff515 	stw	r2,-44(fp)
		}
		mode = 2;		/* ndigits significant digits */
 4009ca8:	00800084 	movi	r2,2
 4009cac:	e0bfff15 	stw	r2,-4(fp)
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
 4009cb0:	e0bffb04 	addi	r2,fp,-20
 4009cb4:	d8800315 	stw	r2,12(sp)
 4009cb8:	e0bffc04 	addi	r2,fp,-16
 4009cbc:	d8800215 	stw	r2,8(sp)
 4009cc0:	e0800417 	ldw	r2,16(fp)
 4009cc4:	d8800115 	stw	r2,4(sp)
 4009cc8:	e0bff517 	ldw	r2,-44(fp)
 4009ccc:	d8800015 	stw	r2,0(sp)
 4009cd0:	e1ffff17 	ldw	r7,-4(fp)
 4009cd4:	e17ff617 	ldw	r5,-40(fp)
 4009cd8:	e1bff717 	ldw	r6,-36(fp)
 4009cdc:	e13ff817 	ldw	r4,-32(fp)
 4009ce0:	400a4a00 	call	400a4a0 <_dtoa_r>
 4009ce4:	e0bffd15 	stw	r2,-12(fp)

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
 4009ce8:	e0800517 	ldw	r2,20(fp)
 4009cec:	108019e0 	cmpeqi	r2,r2,103
 4009cf0:	1000031e 	bne	r2,zero,4009d00 <cvt+0x104>
 4009cf4:	e0800517 	ldw	r2,20(fp)
 4009cf8:	108011d8 	cmpnei	r2,r2,71
 4009cfc:	1000031e 	bne	r2,zero,4009d0c <cvt+0x110>
 4009d00:	e0800217 	ldw	r2,8(fp)
 4009d04:	1080004c 	andi	r2,r2,1
 4009d08:	10003326 	beq	r2,zero,4009dd8 <cvt+0x1dc>
		bp = digits + ndigits;
 4009d0c:	e0bff517 	ldw	r2,-44(fp)
 4009d10:	e0fffd17 	ldw	r3,-12(fp)
 4009d14:	1885883a 	add	r2,r3,r2
 4009d18:	e0bffe15 	stw	r2,-8(fp)
		if (ch == 'f' || ch == 'F') {
 4009d1c:	e0800517 	ldw	r2,20(fp)
 4009d20:	108019a0 	cmpeqi	r2,r2,102
 4009d24:	1000031e 	bne	r2,zero,4009d34 <cvt+0x138>
 4009d28:	e0800517 	ldw	r2,20(fp)
 4009d2c:	10801198 	cmpnei	r2,r2,70
 4009d30:	1000181e 	bne	r2,zero,4009d94 <cvt+0x198>
			if (*digits == '0' && value)
 4009d34:	e0bffd17 	ldw	r2,-12(fp)
 4009d38:	10800003 	ldbu	r2,0(r2)
 4009d3c:	10803fcc 	andi	r2,r2,255
 4009d40:	1080201c 	xori	r2,r2,128
 4009d44:	10bfe004 	addi	r2,r2,-128
 4009d48:	10800c18 	cmpnei	r2,r2,48
 4009d4c:	10000b1e 	bne	r2,zero,4009d7c <cvt+0x180>
 4009d50:	000d883a 	mov	r6,zero
 4009d54:	000f883a 	mov	r7,zero
 4009d58:	e13ff617 	ldw	r4,-40(fp)
 4009d5c:	e17ff717 	ldw	r5,-36(fp)
 4009d60:	40166ec0 	call	40166ec <__eqdf2>
 4009d64:	10000526 	beq	r2,zero,4009d7c <cvt+0x180>
				*decpt = -ndigits + 1;
 4009d68:	00c00044 	movi	r3,1
 4009d6c:	e0bff517 	ldw	r2,-44(fp)
 4009d70:	1887c83a 	sub	r3,r3,r2
 4009d74:	e0800417 	ldw	r2,16(fp)
 4009d78:	10c00015 	stw	r3,0(r2)
			bp += *decpt;
 4009d7c:	e0800417 	ldw	r2,16(fp)
 4009d80:	10800017 	ldw	r2,0(r2)
 4009d84:	1007883a 	mov	r3,r2
 4009d88:	e0bffe17 	ldw	r2,-8(fp)
 4009d8c:	10c5883a 	add	r2,r2,r3
 4009d90:	e0bffe15 	stw	r2,-8(fp)
		}
		if (value == 0)	/* kludge for __dtoa irregularity */
 4009d94:	000d883a 	mov	r6,zero
 4009d98:	000f883a 	mov	r7,zero
 4009d9c:	e13ff617 	ldw	r4,-40(fp)
 4009da0:	e17ff717 	ldw	r5,-36(fp)
 4009da4:	40166ec0 	call	40166ec <__eqdf2>
 4009da8:	1000081e 	bne	r2,zero,4009dcc <cvt+0x1d0>
			rve = bp;
 4009dac:	e0bffe17 	ldw	r2,-8(fp)
 4009db0:	e0bffb15 	stw	r2,-20(fp)
		while (rve < bp)
 4009db4:	00000506 	br	4009dcc <cvt+0x1d0>
			*rve++ = '0';
 4009db8:	e0bffb17 	ldw	r2,-20(fp)
 4009dbc:	10c00044 	addi	r3,r2,1
 4009dc0:	e0fffb15 	stw	r3,-20(fp)
 4009dc4:	00c00c04 	movi	r3,48
 4009dc8:	10c00005 	stb	r3,0(r2)
		while (rve < bp)
 4009dcc:	e0fffb17 	ldw	r3,-20(fp)
 4009dd0:	e0bffe17 	ldw	r2,-8(fp)
 4009dd4:	18bff836 	bltu	r3,r2,4009db8 <cvt+0x1bc>
	}
	*length = rve - digits;
 4009dd8:	e0fffb17 	ldw	r3,-20(fp)
 4009ddc:	e0bffd17 	ldw	r2,-12(fp)
 4009de0:	1887c83a 	sub	r3,r3,r2
 4009de4:	e0800617 	ldw	r2,24(fp)
 4009de8:	10c00015 	stw	r3,0(r2)
	return (digits);
 4009dec:	e0bffd17 	ldw	r2,-12(fp)
}
 4009df0:	e037883a 	mov	sp,fp
 4009df4:	dfc00117 	ldw	ra,4(sp)
 4009df8:	df000017 	ldw	fp,0(sp)
 4009dfc:	dec00204 	addi	sp,sp,8
 4009e00:	f800283a 	ret

04009e04 <exponent>:

static int
exponent(char *p0, int exp, int fmtch)
{
 4009e04:	defff704 	addi	sp,sp,-36
 4009e08:	dfc00815 	stw	ra,32(sp)
 4009e0c:	df000715 	stw	fp,28(sp)
 4009e10:	dc400615 	stw	r17,24(sp)
 4009e14:	dc000515 	stw	r16,20(sp)
 4009e18:	df000704 	addi	fp,sp,28
 4009e1c:	e13ffb15 	stw	r4,-20(fp)
 4009e20:	e17ffa15 	stw	r5,-24(fp)
 4009e24:	e1bff915 	stw	r6,-28(fp)
	int isa = fmtch == 'a' || fmtch == 'A';
# else
#  define isa 0
# endif

	p = p0;
 4009e28:	e47ffb17 	ldw	r17,-20(fp)
	*p++ = isa ? 'p' - 'a' + fmtch : fmtch;
 4009e2c:	8805883a 	mov	r2,r17
 4009e30:	14400044 	addi	r17,r2,1
 4009e34:	e0fff917 	ldw	r3,-28(fp)
 4009e38:	10c00005 	stb	r3,0(r2)
	if (exp < 0) {
 4009e3c:	e0bffa17 	ldw	r2,-24(fp)
 4009e40:	1000080e 	bge	r2,zero,4009e64 <exponent+0x60>
		exp = -exp;
 4009e44:	e0bffa17 	ldw	r2,-24(fp)
 4009e48:	0085c83a 	sub	r2,zero,r2
 4009e4c:	e0bffa15 	stw	r2,-24(fp)
		*p++ = '-';
 4009e50:	8805883a 	mov	r2,r17
 4009e54:	14400044 	addi	r17,r2,1
 4009e58:	00c00b44 	movi	r3,45
 4009e5c:	10c00005 	stb	r3,0(r2)
 4009e60:	00000406 	br	4009e74 <exponent+0x70>
	}
	else
		*p++ = '+';
 4009e64:	8805883a 	mov	r2,r17
 4009e68:	14400044 	addi	r17,r2,1
 4009e6c:	00c00ac4 	movi	r3,43
 4009e70:	10c00005 	stb	r3,0(r2)
	t = expbuf + MAXEXPLEN;
 4009e74:	e43ffc44 	addi	r16,fp,-15
 4009e78:	840001c4 	addi	r16,r16,7
	if (exp > 9) {
 4009e7c:	e0bffa17 	ldw	r2,-24(fp)
 4009e80:	10800290 	cmplti	r2,r2,10
 4009e84:	10001e1e 	bne	r2,zero,4009f00 <exponent+0xfc>
		do {
			*--t = to_char (exp % 10);
 4009e88:	e0bffa17 	ldw	r2,-24(fp)
 4009e8c:	01400284 	movi	r5,10
 4009e90:	1009883a 	mov	r4,r2
 4009e94:	401530c0 	call	401530c <__modsi3>
 4009e98:	10800c04 	addi	r2,r2,48
 4009e9c:	843fffc4 	addi	r16,r16,-1
 4009ea0:	80800005 	stb	r2,0(r16)
		} while ((exp /= 10) > 9);
 4009ea4:	e0bffa17 	ldw	r2,-24(fp)
 4009ea8:	01400284 	movi	r5,10
 4009eac:	1009883a 	mov	r4,r2
 4009eb0:	401528c0 	call	401528c <__divsi3>
 4009eb4:	e0bffa15 	stw	r2,-24(fp)
 4009eb8:	e0bffa17 	ldw	r2,-24(fp)
 4009ebc:	10800288 	cmpgei	r2,r2,10
 4009ec0:	103ff11e 	bne	r2,zero,4009e88 <exponent+0x84>
		*--t = to_char (exp);
 4009ec4:	e0bffa17 	ldw	r2,-24(fp)
 4009ec8:	10800c04 	addi	r2,r2,48
 4009ecc:	843fffc4 	addi	r16,r16,-1
 4009ed0:	80800005 	stb	r2,0(r16)
		for (; t < expbuf + MAXEXPLEN; *p++ = *t++);
 4009ed4:	00000606 	br	4009ef0 <exponent+0xec>
 4009ed8:	8007883a 	mov	r3,r16
 4009edc:	1c000044 	addi	r16,r3,1
 4009ee0:	8805883a 	mov	r2,r17
 4009ee4:	14400044 	addi	r17,r2,1
 4009ee8:	18c00003 	ldbu	r3,0(r3)
 4009eec:	10c00005 	stb	r3,0(r2)
 4009ef0:	e0bffc44 	addi	r2,fp,-15
 4009ef4:	108001c4 	addi	r2,r2,7
 4009ef8:	80bff736 	bltu	r16,r2,4009ed8 <exponent+0xd4>
 4009efc:	00000a06 	br	4009f28 <exponent+0x124>
	}
	else {
		if (!isa)
			*p++ = '0';
 4009f00:	8805883a 	mov	r2,r17
 4009f04:	14400044 	addi	r17,r2,1
 4009f08:	00c00c04 	movi	r3,48
 4009f0c:	10c00005 	stb	r3,0(r2)
		*p++ = to_char (exp);
 4009f10:	e0bffa17 	ldw	r2,-24(fp)
 4009f14:	10800c04 	addi	r2,r2,48
 4009f18:	1007883a 	mov	r3,r2
 4009f1c:	8805883a 	mov	r2,r17
 4009f20:	14400044 	addi	r17,r2,1
 4009f24:	10c00005 	stb	r3,0(r2)
	}
	return (p - p0);
 4009f28:	e0bffb17 	ldw	r2,-20(fp)
 4009f2c:	8885c83a 	sub	r2,r17,r2
}
 4009f30:	e6fffe04 	addi	sp,fp,-8
 4009f34:	dfc00317 	ldw	ra,12(sp)
 4009f38:	df000217 	ldw	fp,8(sp)
 4009f3c:	dc400117 	ldw	r17,4(sp)
 4009f40:	dc000017 	ldw	r16,0(sp)
 4009f44:	dec00404 	addi	sp,sp,16
 4009f48:	f800283a 	ret

04009f4c <__swsetup_r>:
 */

int
__swsetup_r (struct _reent *ptr,
       register FILE * fp)
{
 4009f4c:	defffb04 	addi	sp,sp,-20
 4009f50:	dfc00415 	stw	ra,16(sp)
 4009f54:	df000315 	stw	fp,12(sp)
 4009f58:	dc000215 	stw	r16,8(sp)
 4009f5c:	df000304 	addi	fp,sp,12
 4009f60:	e13ffd15 	stw	r4,-12(fp)
 4009f64:	2821883a 	mov	r16,r5
  /* Make sure stdio is set up.  */

  CHECK_INIT (_REENT, fp);
 4009f68:	d0a00117 	ldw	r2,-32764(gp)
 4009f6c:	e0bffe15 	stw	r2,-8(fp)
 4009f70:	e0bffe17 	ldw	r2,-8(fp)
 4009f74:	10000526 	beq	r2,zero,4009f8c <__swsetup_r+0x40>
 4009f78:	e0bffe17 	ldw	r2,-8(fp)
 4009f7c:	10800e17 	ldw	r2,56(r2)
 4009f80:	1000021e 	bne	r2,zero,4009f8c <__swsetup_r+0x40>
 4009f84:	e13ffe17 	ldw	r4,-8(fp)
 4009f88:	400c9100 	call	400c910 <__sinit>

  /*
   * If we are not writing, we had better be reading and writing.
   */

  if ((fp->_flags & __SWR) == 0)
 4009f8c:	8080030b 	ldhu	r2,12(r16)
 4009f90:	10bfffcc 	andi	r2,r2,65535
 4009f94:	1080020c 	andi	r2,r2,8
 4009f98:	1000241e 	bne	r2,zero,400a02c <__swsetup_r+0xe0>
    {
      if ((fp->_flags & __SRW) == 0)
 4009f9c:	8080030b 	ldhu	r2,12(r16)
 4009fa0:	10bfffcc 	andi	r2,r2,65535
 4009fa4:	1080040c 	andi	r2,r2,16
 4009fa8:	1000081e 	bne	r2,zero,4009fcc <__swsetup_r+0x80>
        {
	  ptr->_errno = EBADF;
 4009fac:	e0bffd17 	ldw	r2,-12(fp)
 4009fb0:	00c00244 	movi	r3,9
 4009fb4:	10c00015 	stw	r3,0(r2)
	  fp->_flags |= __SERR;
 4009fb8:	8080030b 	ldhu	r2,12(r16)
 4009fbc:	10801014 	ori	r2,r2,64
 4009fc0:	8080030d 	sth	r2,12(r16)
	  return EOF;
 4009fc4:	00bfffc4 	movi	r2,-1
 4009fc8:	00004206 	br	400a0d4 <__swsetup_r+0x188>
        }
      if (fp->_flags & __SRD)
 4009fcc:	8080030b 	ldhu	r2,12(r16)
 4009fd0:	10bfffcc 	andi	r2,r2,65535
 4009fd4:	1080010c 	andi	r2,r2,4
 4009fd8:	10001126 	beq	r2,zero,400a020 <__swsetup_r+0xd4>
	{
	  /* clobber any ungetc data */
	  if (HASUB (fp))
 4009fdc:	80800c17 	ldw	r2,48(r16)
 4009fe0:	10000826 	beq	r2,zero,400a004 <__swsetup_r+0xb8>
	    FREEUB (ptr, fp);
 4009fe4:	80c00c17 	ldw	r3,48(r16)
 4009fe8:	80801004 	addi	r2,r16,64
 4009fec:	18800426 	beq	r3,r2,400a000 <__swsetup_r+0xb4>
 4009ff0:	80800c17 	ldw	r2,48(r16)
 4009ff4:	100b883a 	mov	r5,r2
 4009ff8:	e13ffd17 	ldw	r4,-12(fp)
 4009ffc:	400cb0c0 	call	400cb0c <_free_r>
 400a000:	80000c15 	stw	zero,48(r16)
	  fp->_flags &= ~(__SRD | __SEOF);
 400a004:	80c0030b 	ldhu	r3,12(r16)
 400a008:	00bff6c4 	movi	r2,-37
 400a00c:	1884703a 	and	r2,r3,r2
 400a010:	8080030d 	sth	r2,12(r16)
	  fp->_r = 0;
 400a014:	80000115 	stw	zero,4(r16)
	  fp->_p = fp->_bf._base;
 400a018:	80800417 	ldw	r2,16(r16)
 400a01c:	80800015 	stw	r2,0(r16)
	}
      fp->_flags |= __SWR;
 400a020:	8080030b 	ldhu	r2,12(r16)
 400a024:	10800214 	ori	r2,r2,8
 400a028:	8080030d 	sth	r2,12(r16)
  /*
   * Make a buffer if necessary, then set _w.
   * A string I/O file should not explicitly allocate a buffer
   * unless asprintf is being used.
   */
  if (fp->_bf._base == NULL
 400a02c:	80800417 	ldw	r2,16(r16)
 400a030:	10000b1e 	bne	r2,zero,400a060 <__swsetup_r+0x114>
        && (!(fp->_flags & __SSTR) || (fp->_flags & __SMBF)))
 400a034:	8080030b 	ldhu	r2,12(r16)
 400a038:	10bfffcc 	andi	r2,r2,65535
 400a03c:	1080800c 	andi	r2,r2,512
 400a040:	10000426 	beq	r2,zero,400a054 <__swsetup_r+0x108>
 400a044:	8080030b 	ldhu	r2,12(r16)
 400a048:	10bfffcc 	andi	r2,r2,65535
 400a04c:	1080200c 	andi	r2,r2,128
 400a050:	10000326 	beq	r2,zero,400a060 <__swsetup_r+0x114>
    __smakebuf_r (ptr, fp);
 400a054:	800b883a 	mov	r5,r16
 400a058:	e13ffd17 	ldw	r4,-12(fp)
 400a05c:	400daec0 	call	400daec <__smakebuf_r>

  if (fp->_flags & __SLBF)
 400a060:	8080030b 	ldhu	r2,12(r16)
 400a064:	10bfffcc 	andi	r2,r2,65535
 400a068:	1080004c 	andi	r2,r2,1
 400a06c:	10000526 	beq	r2,zero,400a084 <__swsetup_r+0x138>
      /*
       * It is line buffered, so make _lbfsize be -_bufsize
       * for the putc() macro.  We will change _lbfsize back
       * to 0 whenever we turn off __SWR.
       */
      fp->_w = 0;
 400a070:	80000215 	stw	zero,8(r16)
      fp->_lbfsize = -fp->_bf._size;
 400a074:	80800517 	ldw	r2,20(r16)
 400a078:	0085c83a 	sub	r2,zero,r2
 400a07c:	80800615 	stw	r2,24(r16)
 400a080:	00000806 	br	400a0a4 <__swsetup_r+0x158>
    }
  else
    fp->_w = fp->_flags & __SNBF ? 0 : fp->_bf._size;
 400a084:	8080030b 	ldhu	r2,12(r16)
 400a088:	10bfffcc 	andi	r2,r2,65535
 400a08c:	1080008c 	andi	r2,r2,2
 400a090:	1000021e 	bne	r2,zero,400a09c <__swsetup_r+0x150>
 400a094:	80800517 	ldw	r2,20(r16)
 400a098:	00000106 	br	400a0a0 <__swsetup_r+0x154>
 400a09c:	0005883a 	mov	r2,zero
 400a0a0:	80800215 	stw	r2,8(r16)

  if (!fp->_bf._base && (fp->_flags & __SMBF))
 400a0a4:	80800417 	ldw	r2,16(r16)
 400a0a8:	1000091e 	bne	r2,zero,400a0d0 <__swsetup_r+0x184>
 400a0ac:	8080030b 	ldhu	r2,12(r16)
 400a0b0:	10bfffcc 	andi	r2,r2,65535
 400a0b4:	1080200c 	andi	r2,r2,128
 400a0b8:	10000526 	beq	r2,zero,400a0d0 <__swsetup_r+0x184>
    {
      /* __smakebuf_r set errno, but not flag */
      fp->_flags |= __SERR;
 400a0bc:	8080030b 	ldhu	r2,12(r16)
 400a0c0:	10801014 	ori	r2,r2,64
 400a0c4:	8080030d 	sth	r2,12(r16)
      return EOF;
 400a0c8:	00bfffc4 	movi	r2,-1
 400a0cc:	00000106 	br	400a0d4 <__swsetup_r+0x188>
    }
  return 0;
 400a0d0:	0005883a 	mov	r2,zero
}
 400a0d4:	e6ffff04 	addi	sp,fp,-4
 400a0d8:	dfc00217 	ldw	ra,8(sp)
 400a0dc:	df000117 	ldw	fp,4(sp)
 400a0e0:	dc000017 	ldw	r16,0(sp)
 400a0e4:	dec00304 	addi	sp,sp,12
 400a0e8:	f800283a 	ret

0400a0ec <quorem>:
#include <string.h>
#include "mprec.h"

static int
quorem (_Bigint * b, _Bigint * S)
{
 400a0ec:	deffef04 	addi	sp,sp,-68
 400a0f0:	dfc01015 	stw	ra,64(sp)
 400a0f4:	df000f15 	stw	fp,60(sp)
 400a0f8:	df000f04 	addi	fp,sp,60
 400a0fc:	e13ff215 	stw	r4,-56(fp)
 400a100:	e17ff115 	stw	r5,-60(fp)
#ifdef Pack_32
  __Long z;
  __ULong si, zs;
#endif

  n = S->_wds;
 400a104:	e0bff117 	ldw	r2,-60(fp)
 400a108:	10800417 	ldw	r2,16(r2)
 400a10c:	e0bfff15 	stw	r2,-4(fp)
#ifdef DEBUG
  /*debug*/ if (b->_wds > n)
    /*debug*/ Bug ("oversize b in quorem");
#endif
  if (b->_wds < n)
 400a110:	e0bff217 	ldw	r2,-56(fp)
 400a114:	10c00417 	ldw	r3,16(r2)
 400a118:	e0bfff17 	ldw	r2,-4(fp)
 400a11c:	1880020e 	bge	r3,r2,400a128 <quorem+0x3c>
    return 0;
 400a120:	0005883a 	mov	r2,zero
 400a124:	0000d906 	br	400a48c <quorem+0x3a0>
  sx = S->_x;
 400a128:	e0bff117 	ldw	r2,-60(fp)
 400a12c:	10800504 	addi	r2,r2,20
 400a130:	e0bff915 	stw	r2,-28(fp)
  sxe = sx + --n;
 400a134:	e0bfff17 	ldw	r2,-4(fp)
 400a138:	10bfffc4 	addi	r2,r2,-1
 400a13c:	e0bfff15 	stw	r2,-4(fp)
 400a140:	e0bfff17 	ldw	r2,-4(fp)
 400a144:	100490ba 	slli	r2,r2,2
 400a148:	e0fff917 	ldw	r3,-28(fp)
 400a14c:	1885883a 	add	r2,r3,r2
 400a150:	e0bff815 	stw	r2,-32(fp)
  bx = b->_x;
 400a154:	e0bff217 	ldw	r2,-56(fp)
 400a158:	10800504 	addi	r2,r2,20
 400a15c:	e0bffb15 	stw	r2,-20(fp)
  bxe = bx + n;
 400a160:	e0bfff17 	ldw	r2,-4(fp)
 400a164:	100490ba 	slli	r2,r2,2
 400a168:	e0fffb17 	ldw	r3,-20(fp)
 400a16c:	1885883a 	add	r2,r3,r2
 400a170:	e0bffa15 	stw	r2,-24(fp)
  q = *bxe / (*sxe + 1);	/* ensure q <= true quotient */
 400a174:	e0bffa17 	ldw	r2,-24(fp)
 400a178:	10c00017 	ldw	r3,0(r2)
 400a17c:	e0bff817 	ldw	r2,-32(fp)
 400a180:	10800017 	ldw	r2,0(r2)
 400a184:	10800044 	addi	r2,r2,1
 400a188:	100b883a 	mov	r5,r2
 400a18c:	1809883a 	mov	r4,r3
 400a190:	40153800 	call	4015380 <__udivsi3>
 400a194:	e0bffc15 	stw	r2,-16(fp)
#ifdef DEBUG
  /*debug*/ if (q > 9)
    /*debug*/ Bug ("oversized quotient in quorem");
#endif
  if (q)
 400a198:	e0bffc17 	ldw	r2,-16(fp)
 400a19c:	10005826 	beq	r2,zero,400a300 <quorem+0x214>
    {
      borrow = 0;
 400a1a0:	e03ffe15 	stw	zero,-8(fp)
      carry = 0;
 400a1a4:	e03ffd15 	stw	zero,-12(fp)
      do
	{
#ifdef Pack_32
	  si = *sx++;
 400a1a8:	e0bff917 	ldw	r2,-28(fp)
 400a1ac:	10c00104 	addi	r3,r2,4
 400a1b0:	e0fff915 	stw	r3,-28(fp)
 400a1b4:	10800017 	ldw	r2,0(r2)
 400a1b8:	e0bff715 	stw	r2,-36(fp)
	  ys = (si & 0xffff) * q + carry;
 400a1bc:	e0bff717 	ldw	r2,-36(fp)
 400a1c0:	10bfffcc 	andi	r2,r2,65535
 400a1c4:	e17ffc17 	ldw	r5,-16(fp)
 400a1c8:	1009883a 	mov	r4,r2
 400a1cc:	40072d80 	call	40072d8 <__mulsi3>
 400a1d0:	1007883a 	mov	r3,r2
 400a1d4:	e0bffd17 	ldw	r2,-12(fp)
 400a1d8:	10c5883a 	add	r2,r2,r3
 400a1dc:	e0bff615 	stw	r2,-40(fp)
	  zs = (si >> 16) * q + (ys >> 16);
 400a1e0:	e0bff717 	ldw	r2,-36(fp)
 400a1e4:	1004d43a 	srli	r2,r2,16
 400a1e8:	e17ffc17 	ldw	r5,-16(fp)
 400a1ec:	1009883a 	mov	r4,r2
 400a1f0:	40072d80 	call	40072d8 <__mulsi3>
 400a1f4:	1007883a 	mov	r3,r2
 400a1f8:	e0bff617 	ldw	r2,-40(fp)
 400a1fc:	1004d43a 	srli	r2,r2,16
 400a200:	1885883a 	add	r2,r3,r2
 400a204:	e0bff515 	stw	r2,-44(fp)
	  carry = zs >> 16;
 400a208:	e0bff517 	ldw	r2,-44(fp)
 400a20c:	1004d43a 	srli	r2,r2,16
 400a210:	e0bffd15 	stw	r2,-12(fp)
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
 400a214:	e0bffb17 	ldw	r2,-20(fp)
 400a218:	10800017 	ldw	r2,0(r2)
 400a21c:	10ffffcc 	andi	r3,r2,65535
 400a220:	e0bff617 	ldw	r2,-40(fp)
 400a224:	10bfffcc 	andi	r2,r2,65535
 400a228:	1887c83a 	sub	r3,r3,r2
 400a22c:	e0bffe17 	ldw	r2,-8(fp)
 400a230:	1885883a 	add	r2,r3,r2
 400a234:	e0bff415 	stw	r2,-48(fp)
	  borrow = y >> 16;
 400a238:	e0bff417 	ldw	r2,-48(fp)
 400a23c:	1005d43a 	srai	r2,r2,16
 400a240:	e0bffe15 	stw	r2,-8(fp)
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
 400a244:	e0bffb17 	ldw	r2,-20(fp)
 400a248:	10800017 	ldw	r2,0(r2)
 400a24c:	1006d43a 	srli	r3,r2,16
 400a250:	e0bff517 	ldw	r2,-44(fp)
 400a254:	10bfffcc 	andi	r2,r2,65535
 400a258:	1887c83a 	sub	r3,r3,r2
 400a25c:	e0bffe17 	ldw	r2,-8(fp)
 400a260:	1885883a 	add	r2,r3,r2
 400a264:	e0bff315 	stw	r2,-52(fp)
	  borrow = z >> 16;
 400a268:	e0bff317 	ldw	r2,-52(fp)
 400a26c:	1005d43a 	srai	r2,r2,16
 400a270:	e0bffe15 	stw	r2,-8(fp)
	  Sign_Extend (borrow, z);
	  Storeinc (bx, z, y);
 400a274:	e0bff317 	ldw	r2,-52(fp)
 400a278:	1006943a 	slli	r3,r2,16
 400a27c:	e0bff417 	ldw	r2,-48(fp)
 400a280:	10bfffcc 	andi	r2,r2,65535
 400a284:	1888b03a 	or	r4,r3,r2
 400a288:	e0bffb17 	ldw	r2,-20(fp)
 400a28c:	10c00104 	addi	r3,r2,4
 400a290:	e0fffb15 	stw	r3,-20(fp)
 400a294:	2007883a 	mov	r3,r4
 400a298:	10c00015 	stw	r3,0(r2)
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  *bx++ = y & 0xffff;
#endif
	}
      while (sx <= sxe);
 400a29c:	e0bff917 	ldw	r2,-28(fp)
 400a2a0:	e0fff817 	ldw	r3,-32(fp)
 400a2a4:	18bfc02e 	bgeu	r3,r2,400a1a8 <quorem+0xbc>
      if (!*bxe)
 400a2a8:	e0bffa17 	ldw	r2,-24(fp)
 400a2ac:	10800017 	ldw	r2,0(r2)
 400a2b0:	1000131e 	bne	r2,zero,400a300 <quorem+0x214>
	{
	  bx = b->_x;
 400a2b4:	e0bff217 	ldw	r2,-56(fp)
 400a2b8:	10800504 	addi	r2,r2,20
 400a2bc:	e0bffb15 	stw	r2,-20(fp)
	  while (--bxe > bx && !*bxe)
 400a2c0:	00000306 	br	400a2d0 <quorem+0x1e4>
	    --n;
 400a2c4:	e0bfff17 	ldw	r2,-4(fp)
 400a2c8:	10bfffc4 	addi	r2,r2,-1
 400a2cc:	e0bfff15 	stw	r2,-4(fp)
	  while (--bxe > bx && !*bxe)
 400a2d0:	e0bffa17 	ldw	r2,-24(fp)
 400a2d4:	10bfff04 	addi	r2,r2,-4
 400a2d8:	e0bffa15 	stw	r2,-24(fp)
 400a2dc:	e0bffa17 	ldw	r2,-24(fp)
 400a2e0:	e0fffb17 	ldw	r3,-20(fp)
 400a2e4:	1880032e 	bgeu	r3,r2,400a2f4 <quorem+0x208>
 400a2e8:	e0bffa17 	ldw	r2,-24(fp)
 400a2ec:	10800017 	ldw	r2,0(r2)
 400a2f0:	103ff426 	beq	r2,zero,400a2c4 <quorem+0x1d8>
	  b->_wds = n;
 400a2f4:	e0bff217 	ldw	r2,-56(fp)
 400a2f8:	e0ffff17 	ldw	r3,-4(fp)
 400a2fc:	10c00415 	stw	r3,16(r2)
	}
    }
  if (cmp (b, S) >= 0)
 400a300:	e17ff117 	ldw	r5,-60(fp)
 400a304:	e13ff217 	ldw	r4,-56(fp)
 400a308:	400ff100 	call	400ff10 <__mcmp>
 400a30c:	10005e16 	blt	r2,zero,400a488 <quorem+0x39c>
    {
      q++;
 400a310:	e0bffc17 	ldw	r2,-16(fp)
 400a314:	10800044 	addi	r2,r2,1
 400a318:	e0bffc15 	stw	r2,-16(fp)
      borrow = 0;
 400a31c:	e03ffe15 	stw	zero,-8(fp)
      carry = 0;
 400a320:	e03ffd15 	stw	zero,-12(fp)
      bx = b->_x;
 400a324:	e0bff217 	ldw	r2,-56(fp)
 400a328:	10800504 	addi	r2,r2,20
 400a32c:	e0bffb15 	stw	r2,-20(fp)
      sx = S->_x;
 400a330:	e0bff117 	ldw	r2,-60(fp)
 400a334:	10800504 	addi	r2,r2,20
 400a338:	e0bff915 	stw	r2,-28(fp)
      do
	{
#ifdef Pack_32
	  si = *sx++;
 400a33c:	e0bff917 	ldw	r2,-28(fp)
 400a340:	10c00104 	addi	r3,r2,4
 400a344:	e0fff915 	stw	r3,-28(fp)
 400a348:	10800017 	ldw	r2,0(r2)
 400a34c:	e0bff715 	stw	r2,-36(fp)
	  ys = (si & 0xffff) + carry;
 400a350:	e0bff717 	ldw	r2,-36(fp)
 400a354:	10bfffcc 	andi	r2,r2,65535
 400a358:	e0fffd17 	ldw	r3,-12(fp)
 400a35c:	1885883a 	add	r2,r3,r2
 400a360:	e0bff615 	stw	r2,-40(fp)
	  zs = (si >> 16) + (ys >> 16);
 400a364:	e0bff717 	ldw	r2,-36(fp)
 400a368:	1006d43a 	srli	r3,r2,16
 400a36c:	e0bff617 	ldw	r2,-40(fp)
 400a370:	1004d43a 	srli	r2,r2,16
 400a374:	1885883a 	add	r2,r3,r2
 400a378:	e0bff515 	stw	r2,-44(fp)
	  carry = zs >> 16;
 400a37c:	e0bff517 	ldw	r2,-44(fp)
 400a380:	1004d43a 	srli	r2,r2,16
 400a384:	e0bffd15 	stw	r2,-12(fp)
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
 400a388:	e0bffb17 	ldw	r2,-20(fp)
 400a38c:	10800017 	ldw	r2,0(r2)
 400a390:	10ffffcc 	andi	r3,r2,65535
 400a394:	e0bff617 	ldw	r2,-40(fp)
 400a398:	10bfffcc 	andi	r2,r2,65535
 400a39c:	1887c83a 	sub	r3,r3,r2
 400a3a0:	e0bffe17 	ldw	r2,-8(fp)
 400a3a4:	1885883a 	add	r2,r3,r2
 400a3a8:	e0bff415 	stw	r2,-48(fp)
	  borrow = y >> 16;
 400a3ac:	e0bff417 	ldw	r2,-48(fp)
 400a3b0:	1005d43a 	srai	r2,r2,16
 400a3b4:	e0bffe15 	stw	r2,-8(fp)
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
 400a3b8:	e0bffb17 	ldw	r2,-20(fp)
 400a3bc:	10800017 	ldw	r2,0(r2)
 400a3c0:	1006d43a 	srli	r3,r2,16
 400a3c4:	e0bff517 	ldw	r2,-44(fp)
 400a3c8:	10bfffcc 	andi	r2,r2,65535
 400a3cc:	1887c83a 	sub	r3,r3,r2
 400a3d0:	e0bffe17 	ldw	r2,-8(fp)
 400a3d4:	1885883a 	add	r2,r3,r2
 400a3d8:	e0bff315 	stw	r2,-52(fp)
	  borrow = z >> 16;
 400a3dc:	e0bff317 	ldw	r2,-52(fp)
 400a3e0:	1005d43a 	srai	r2,r2,16
 400a3e4:	e0bffe15 	stw	r2,-8(fp)
	  Sign_Extend (borrow, z);
	  Storeinc (bx, z, y);
 400a3e8:	e0bff317 	ldw	r2,-52(fp)
 400a3ec:	1006943a 	slli	r3,r2,16
 400a3f0:	e0bff417 	ldw	r2,-48(fp)
 400a3f4:	10bfffcc 	andi	r2,r2,65535
 400a3f8:	1888b03a 	or	r4,r3,r2
 400a3fc:	e0bffb17 	ldw	r2,-20(fp)
 400a400:	10c00104 	addi	r3,r2,4
 400a404:	e0fffb15 	stw	r3,-20(fp)
 400a408:	2007883a 	mov	r3,r4
 400a40c:	10c00015 	stw	r3,0(r2)
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  *bx++ = y & 0xffff;
#endif
	}
      while (sx <= sxe);
 400a410:	e0bff917 	ldw	r2,-28(fp)
 400a414:	e0fff817 	ldw	r3,-32(fp)
 400a418:	18bfc82e 	bgeu	r3,r2,400a33c <quorem+0x250>
      bx = b->_x;
 400a41c:	e0bff217 	ldw	r2,-56(fp)
 400a420:	10800504 	addi	r2,r2,20
 400a424:	e0bffb15 	stw	r2,-20(fp)
      bxe = bx + n;
 400a428:	e0bfff17 	ldw	r2,-4(fp)
 400a42c:	100490ba 	slli	r2,r2,2
 400a430:	e0fffb17 	ldw	r3,-20(fp)
 400a434:	1885883a 	add	r2,r3,r2
 400a438:	e0bffa15 	stw	r2,-24(fp)
      if (!*bxe)
 400a43c:	e0bffa17 	ldw	r2,-24(fp)
 400a440:	10800017 	ldw	r2,0(r2)
 400a444:	1000101e 	bne	r2,zero,400a488 <quorem+0x39c>
	{
	  while (--bxe > bx && !*bxe)
 400a448:	00000306 	br	400a458 <quorem+0x36c>
	    --n;
 400a44c:	e0bfff17 	ldw	r2,-4(fp)
 400a450:	10bfffc4 	addi	r2,r2,-1
 400a454:	e0bfff15 	stw	r2,-4(fp)
	  while (--bxe > bx && !*bxe)
 400a458:	e0bffa17 	ldw	r2,-24(fp)
 400a45c:	10bfff04 	addi	r2,r2,-4
 400a460:	e0bffa15 	stw	r2,-24(fp)
 400a464:	e0bffa17 	ldw	r2,-24(fp)
 400a468:	e0fffb17 	ldw	r3,-20(fp)
 400a46c:	1880032e 	bgeu	r3,r2,400a47c <quorem+0x390>
 400a470:	e0bffa17 	ldw	r2,-24(fp)
 400a474:	10800017 	ldw	r2,0(r2)
 400a478:	103ff426 	beq	r2,zero,400a44c <quorem+0x360>
	  b->_wds = n;
 400a47c:	e0bff217 	ldw	r2,-56(fp)
 400a480:	e0ffff17 	ldw	r3,-4(fp)
 400a484:	10c00415 	stw	r3,16(r2)
	}
    }
  return q;
 400a488:	e0bffc17 	ldw	r2,-16(fp)
}
 400a48c:	e037883a 	mov	sp,fp
 400a490:	dfc00117 	ldw	ra,4(sp)
 400a494:	df000017 	ldw	fp,0(sp)
 400a498:	dec00204 	addi	sp,sp,8
 400a49c:	f800283a 	ret

0400a4a0 <_dtoa_r>:
	int mode,
	int ndigits,
	int *decpt,
	int *sign,
	char **rve)
{
 400a4a0:	deffca04 	addi	sp,sp,-216
 400a4a4:	dfc03515 	stw	ra,212(sp)
 400a4a8:	df003415 	stw	fp,208(sp)
 400a4ac:	dcc03315 	stw	r19,204(sp)
 400a4b0:	dc803215 	stw	r18,200(sp)
 400a4b4:	dc403115 	stw	r17,196(sp)
 400a4b8:	dc003015 	stw	r16,192(sp)
 400a4bc:	df003404 	addi	fp,sp,208
 400a4c0:	e13fd015 	stw	r4,-192(fp)
 400a4c4:	e17fce15 	stw	r5,-200(fp)
 400a4c8:	e1bfcf15 	stw	r6,-196(fp)
 400a4cc:	e1ffcd15 	stw	r7,-204(fp)
  __Long L;
#ifndef Sudden_Underflow
  int denorm;
  __ULong x;
#endif
  _Bigint *b, *b1, *delta, *mlo = NULL, *mhi, *S;
 400a4d0:	e03fe815 	stw	zero,-96(fp)
  double ds;
  char *s, *s0;

  d.d = _d;
 400a4d4:	e0bfce17 	ldw	r2,-200(fp)
 400a4d8:	e0bfd515 	stw	r2,-172(fp)
 400a4dc:	e0bfcf17 	ldw	r2,-196(fp)
 400a4e0:	e0bfd615 	stw	r2,-168(fp)

  _REENT_CHECK_MP(ptr);
  if (_REENT_MP_RESULT(ptr))
 400a4e4:	e0bfd017 	ldw	r2,-192(fp)
 400a4e8:	10801017 	ldw	r2,64(r2)
 400a4ec:	10001326 	beq	r2,zero,400a53c <_dtoa_r+0x9c>
    {
      _REENT_MP_RESULT(ptr)->_k = _REENT_MP_RESULT_K(ptr);
 400a4f0:	e0bfd017 	ldw	r2,-192(fp)
 400a4f4:	10801017 	ldw	r2,64(r2)
 400a4f8:	e0ffd017 	ldw	r3,-192(fp)
 400a4fc:	18c01117 	ldw	r3,68(r3)
 400a500:	10c00115 	stw	r3,4(r2)
      _REENT_MP_RESULT(ptr)->_maxwds = 1 << _REENT_MP_RESULT_K(ptr);
 400a504:	e0bfd017 	ldw	r2,-192(fp)
 400a508:	10c01117 	ldw	r3,68(r2)
 400a50c:	e0bfd017 	ldw	r2,-192(fp)
 400a510:	10801017 	ldw	r2,64(r2)
 400a514:	01000044 	movi	r4,1
 400a518:	20c6983a 	sll	r3,r4,r3
 400a51c:	10c00215 	stw	r3,8(r2)
      Bfree (ptr, _REENT_MP_RESULT(ptr));
 400a520:	e0bfd017 	ldw	r2,-192(fp)
 400a524:	10801017 	ldw	r2,64(r2)
 400a528:	100b883a 	mov	r5,r2
 400a52c:	e13fd017 	ldw	r4,-192(fp)
 400a530:	400f1900 	call	400f190 <_Bfree>
      _REENT_MP_RESULT(ptr) = 0;
 400a534:	e0bfd017 	ldw	r2,-192(fp)
 400a538:	10001015 	stw	zero,64(r2)
    }

  if (word0 (d) & Sign_bit)
 400a53c:	e0bfd617 	ldw	r2,-168(fp)
 400a540:	1000090e 	bge	r2,zero,400a568 <_dtoa_r+0xc8>
    {
      /* set sign for everything, including 0's and NaNs */
      *sign = 1;
 400a544:	e0800417 	ldw	r2,16(fp)
 400a548:	00c00044 	movi	r3,1
 400a54c:	10c00015 	stw	r3,0(r2)
      word0 (d) &= ~Sign_bit;	/* clear sign bit */
 400a550:	e0ffd617 	ldw	r3,-168(fp)
 400a554:	00a00034 	movhi	r2,32768
 400a558:	10bfffc4 	addi	r2,r2,-1
 400a55c:	1884703a 	and	r2,r3,r2
 400a560:	e0bfd615 	stw	r2,-168(fp)
 400a564:	00000206 	br	400a570 <_dtoa_r+0xd0>
    }
  else
    *sign = 0;
 400a568:	e0800417 	ldw	r2,16(fp)
 400a56c:	10000015 	stw	zero,0(r2)

#if defined(IEEE_Arith) + defined(VAX)
#ifdef IEEE_Arith
  if ((word0 (d) & Exp_mask) == Exp_mask)
 400a570:	e0bfd617 	ldw	r2,-168(fp)
 400a574:	10dffc2c 	andhi	r3,r2,32752
 400a578:	009ffc34 	movhi	r2,32752
 400a57c:	1880221e 	bne	r3,r2,400a608 <_dtoa_r+0x168>
#else
  if (word0 (d) == 0x8000)
#endif
    {
      /* Infinity or NaN */
      *decpt = 9999;
 400a580:	e0800317 	ldw	r2,12(fp)
 400a584:	00c9c3c4 	movi	r3,9999
 400a588:	10c00015 	stw	r3,0(r2)
      s =
#ifdef IEEE_Arith
	!word1 (d) && !(word0 (d) & 0xfffff) ? "Infinity" :
 400a58c:	e0bfd517 	ldw	r2,-172(fp)
 400a590:	1000081e 	bne	r2,zero,400a5b4 <_dtoa_r+0x114>
 400a594:	e0ffd617 	ldw	r3,-168(fp)
 400a598:	00800434 	movhi	r2,16
 400a59c:	10bfffc4 	addi	r2,r2,-1
 400a5a0:	1884703a 	and	r2,r3,r2
 400a5a4:	1000031e 	bne	r2,zero,400a5b4 <_dtoa_r+0x114>
 400a5a8:	008100b4 	movhi	r2,1026
 400a5ac:	10aae004 	addi	r2,r2,-21632
 400a5b0:	00000206 	br	400a5bc <_dtoa_r+0x11c>
 400a5b4:	008100b4 	movhi	r2,1026
 400a5b8:	10aae304 	addi	r2,r2,-21620
      s =
 400a5bc:	e0bfe315 	stw	r2,-116(fp)
#endif
	"NaN";
      if (rve)
 400a5c0:	e0800517 	ldw	r2,20(fp)
 400a5c4:	10000e26 	beq	r2,zero,400a600 <_dtoa_r+0x160>
	*rve =
#ifdef IEEE_Arith
	  s[3] ? s + 8 :
 400a5c8:	e0bfe317 	ldw	r2,-116(fp)
 400a5cc:	108000c4 	addi	r2,r2,3
 400a5d0:	10800003 	ldbu	r2,0(r2)
 400a5d4:	10803fcc 	andi	r2,r2,255
 400a5d8:	1080201c 	xori	r2,r2,128
 400a5dc:	10bfe004 	addi	r2,r2,-128
 400a5e0:	10000326 	beq	r2,zero,400a5f0 <_dtoa_r+0x150>
 400a5e4:	e0bfe317 	ldw	r2,-116(fp)
 400a5e8:	10800204 	addi	r2,r2,8
 400a5ec:	00000206 	br	400a5f8 <_dtoa_r+0x158>
 400a5f0:	e0bfe317 	ldw	r2,-116(fp)
 400a5f4:	108000c4 	addi	r2,r2,3
	*rve =
 400a5f8:	e0c00517 	ldw	r3,20(fp)
 400a5fc:	18800015 	stw	r2,0(r3)
#endif
	  s + 3;
      return s;
 400a600:	e0bfe317 	ldw	r2,-116(fp)
 400a604:	0006a806 	br	400c0a8 <_dtoa_r+0x1c08>
    }
#endif
#ifdef IBM
  d.d += 0;			/* normalize */
#endif
  if (!d.d)
 400a608:	e0bfd517 	ldw	r2,-172(fp)
 400a60c:	e0ffd617 	ldw	r3,-168(fp)
 400a610:	000d883a 	mov	r6,zero
 400a614:	000f883a 	mov	r7,zero
 400a618:	1009883a 	mov	r4,r2
 400a61c:	180b883a 	mov	r5,r3
 400a620:	40166ec0 	call	40166ec <__eqdf2>
 400a624:	10000e1e 	bne	r2,zero,400a660 <_dtoa_r+0x1c0>
    {
      *decpt = 1;
 400a628:	e0800317 	ldw	r2,12(fp)
 400a62c:	00c00044 	movi	r3,1
 400a630:	10c00015 	stw	r3,0(r2)
      s = "0";
 400a634:	008100b4 	movhi	r2,1026
 400a638:	10aae404 	addi	r2,r2,-21616
 400a63c:	e0bfe315 	stw	r2,-116(fp)
      if (rve)
 400a640:	e0800517 	ldw	r2,20(fp)
 400a644:	10000426 	beq	r2,zero,400a658 <_dtoa_r+0x1b8>
	*rve = s + 1;
 400a648:	e0bfe317 	ldw	r2,-116(fp)
 400a64c:	10c00044 	addi	r3,r2,1
 400a650:	e0800517 	ldw	r2,20(fp)
 400a654:	10c00015 	stw	r3,0(r2)
      return s;
 400a658:	e0bfe317 	ldw	r2,-116(fp)
 400a65c:	00069206 	br	400c0a8 <_dtoa_r+0x1c08>
    }

  b = d2b (ptr, d.d, &be, &bbits);
 400a660:	e0bfd517 	ldw	r2,-172(fp)
 400a664:	e0ffd617 	ldw	r3,-168(fp)
 400a668:	e17fd704 	addi	r5,fp,-164
 400a66c:	e13fd804 	addi	r4,fp,-160
 400a670:	d9000015 	stw	r4,0(sp)
 400a674:	280f883a 	mov	r7,r5
 400a678:	100b883a 	mov	r5,r2
 400a67c:	180d883a 	mov	r6,r3
 400a680:	e13fd017 	ldw	r4,-192(fp)
 400a684:	40105c80 	call	40105c8 <__d2b>
 400a688:	e0bfe915 	stw	r2,-92(fp)
#ifdef Sudden_Underflow
  i = (int) (word0 (d) >> Exp_shift1 & (Exp_mask >> Exp_shift1));
#else
  if ((i = (int) (word0 (d) >> Exp_shift1 & (Exp_mask >> Exp_shift1))) != 0)
 400a68c:	e0bfd617 	ldw	r2,-168(fp)
 400a690:	1004d53a 	srli	r2,r2,20
 400a694:	1081ffcc 	andi	r2,r2,2047
 400a698:	e0bff815 	stw	r2,-32(fp)
 400a69c:	e0bff817 	ldw	r2,-32(fp)
 400a6a0:	10001126 	beq	r2,zero,400a6e8 <_dtoa_r+0x248>
    {
#endif
      d2.d = d.d;
 400a6a4:	e0bfd517 	ldw	r2,-172(fp)
 400a6a8:	e0ffd617 	ldw	r3,-168(fp)
 400a6ac:	e0bfd315 	stw	r2,-180(fp)
 400a6b0:	e0ffd415 	stw	r3,-176(fp)
      word0 (d2) &= Frac_mask1;
 400a6b4:	e0ffd417 	ldw	r3,-176(fp)
 400a6b8:	00800434 	movhi	r2,16
 400a6bc:	10bfffc4 	addi	r2,r2,-1
 400a6c0:	1884703a 	and	r2,r3,r2
 400a6c4:	e0bfd415 	stw	r2,-176(fp)
      word0 (d2) |= Exp_11;
 400a6c8:	e0bfd417 	ldw	r2,-176(fp)
 400a6cc:	108ffc34 	orhi	r2,r2,16368
 400a6d0:	e0bfd415 	stw	r2,-176(fp)
		 * Hence we adjust the constant term to 0.1760912590558.
		 * (We could get a more accurate k by invoking log10,
		 *  but this is probably not worthwhile.)
		 */

      i -= Bias;
 400a6d4:	e0bff817 	ldw	r2,-32(fp)
 400a6d8:	10bf0044 	addi	r2,r2,-1023
 400a6dc:	e0bff815 	stw	r2,-32(fp)
#ifdef IBM
      i <<= 2;
      i += j;
#endif
#ifndef Sudden_Underflow
      denorm = 0;
 400a6e0:	e03fea15 	stw	zero,-88(fp)
 400a6e4:	00002806 	br	400a788 <_dtoa_r+0x2e8>
    }
  else
    {
      /* d is denormalized */

      i = bbits + be + (Bias + (P - 1) - 1);
 400a6e8:	e0ffd817 	ldw	r3,-160(fp)
 400a6ec:	e0bfd717 	ldw	r2,-164(fp)
 400a6f0:	1885883a 	add	r2,r3,r2
 400a6f4:	10810c84 	addi	r2,r2,1074
 400a6f8:	e0bff815 	stw	r2,-32(fp)
#if defined (_DOUBLE_IS_32BITS)
      x = word0 (d) << (32 - i);
#else
      x = (i > 32) ? (word0 (d) << (64 - i)) | (word1 (d) >> (i - 32))
       : (word1 (d) << (32 - i));
 400a6fc:	e0bff817 	ldw	r2,-32(fp)
 400a700:	10800850 	cmplti	r2,r2,33
 400a704:	10000b1e 	bne	r2,zero,400a734 <_dtoa_r+0x294>
      x = (i > 32) ? (word0 (d) << (64 - i)) | (word1 (d) >> (i - 32))
 400a708:	e0ffd617 	ldw	r3,-168(fp)
 400a70c:	01001004 	movi	r4,64
 400a710:	e0bff817 	ldw	r2,-32(fp)
 400a714:	2085c83a 	sub	r2,r4,r2
 400a718:	1886983a 	sll	r3,r3,r2
 400a71c:	e13fd517 	ldw	r4,-172(fp)
 400a720:	e0bff817 	ldw	r2,-32(fp)
 400a724:	10bff804 	addi	r2,r2,-32
 400a728:	2084d83a 	srl	r2,r4,r2
       : (word1 (d) << (32 - i));
 400a72c:	1884b03a 	or	r2,r3,r2
 400a730:	00000506 	br	400a748 <_dtoa_r+0x2a8>
 400a734:	e0ffd517 	ldw	r3,-172(fp)
 400a738:	01000804 	movi	r4,32
 400a73c:	e0bff817 	ldw	r2,-32(fp)
 400a740:	2085c83a 	sub	r2,r4,r2
 400a744:	1884983a 	sll	r2,r3,r2
      x = (i > 32) ? (word0 (d) << (64 - i)) | (word1 (d) >> (i - 32))
 400a748:	e0bfe215 	stw	r2,-120(fp)
#endif
      d2.d = x;
 400a74c:	e13fe217 	ldw	r4,-120(fp)
 400a750:	4017bb80 	call	4017bb8 <__floatunsidf>
 400a754:	1009883a 	mov	r4,r2
 400a758:	180b883a 	mov	r5,r3
 400a75c:	e13fd315 	stw	r4,-180(fp)
 400a760:	e17fd415 	stw	r5,-176(fp)
      word0 (d2) -= 31 * Exp_msk1;	/* adjust exponent */
 400a764:	e0ffd417 	ldw	r3,-176(fp)
 400a768:	00bf8434 	movhi	r2,65040
 400a76c:	1885883a 	add	r2,r3,r2
 400a770:	e0bfd415 	stw	r2,-176(fp)
      i -= (Bias + (P - 1) - 1) + 1;
 400a774:	e0bff817 	ldw	r2,-32(fp)
 400a778:	10bef344 	addi	r2,r2,-1075
 400a77c:	e0bff815 	stw	r2,-32(fp)
      denorm = 1;
 400a780:	00800044 	movi	r2,1
 400a784:	e0bfea15 	stw	r2,-88(fp)
    }
#endif
#if defined (_DOUBLE_IS_32BITS)
  ds = (d2.d - 1.5) * 0.289529651 + 0.176091269 + i * 0.30103001;
#else
  ds = (d2.d - 1.5) * 0.289529654602168 + 0.1760912590558 + i * 0.301029995663981;
 400a788:	e0bfd317 	ldw	r2,-180(fp)
 400a78c:	e0ffd417 	ldw	r3,-176(fp)
 400a790:	000d883a 	mov	r6,zero
 400a794:	01cffe34 	movhi	r7,16376
 400a798:	1009883a 	mov	r4,r2
 400a79c:	180b883a 	mov	r5,r3
 400a7a0:	40170f40 	call	40170f4 <__subdf3>
 400a7a4:	1009883a 	mov	r4,r2
 400a7a8:	180b883a 	mov	r5,r3
 400a7ac:	2005883a 	mov	r2,r4
 400a7b0:	2807883a 	mov	r3,r5
 400a7b4:	0198dbf4 	movhi	r6,25455
 400a7b8:	3190d844 	addi	r6,r6,17249
 400a7bc:	01cff4f4 	movhi	r7,16339
 400a7c0:	39e1e9c4 	addi	r7,r7,-30809
 400a7c4:	1009883a 	mov	r4,r2
 400a7c8:	180b883a 	mov	r5,r3
 400a7cc:	401694c0 	call	401694c <__muldf3>
 400a7d0:	1009883a 	mov	r4,r2
 400a7d4:	180b883a 	mov	r5,r3
 400a7d8:	2005883a 	mov	r2,r4
 400a7dc:	2807883a 	mov	r3,r5
 400a7e0:	01a2d874 	movhi	r6,35681
 400a7e4:	31b22cc4 	addi	r6,r6,-14157
 400a7e8:	01cff1f4 	movhi	r7,16327
 400a7ec:	39e28a04 	addi	r7,r7,-30168
 400a7f0:	1009883a 	mov	r4,r2
 400a7f4:	180b883a 	mov	r5,r3
 400a7f8:	40154400 	call	4015440 <__adddf3>
 400a7fc:	1009883a 	mov	r4,r2
 400a800:	180b883a 	mov	r5,r3
 400a804:	2025883a 	mov	r18,r4
 400a808:	2827883a 	mov	r19,r5
 400a80c:	e13ff817 	ldw	r4,-32(fp)
 400a810:	4017afc0 	call	4017afc <__floatsidf>
 400a814:	1011883a 	mov	r8,r2
 400a818:	1813883a 	mov	r9,r3
 400a81c:	019427f4 	movhi	r6,20639
 400a820:	319e7ec4 	addi	r6,r6,31227
 400a824:	01cff4f4 	movhi	r7,16339
 400a828:	39d104c4 	addi	r7,r7,17427
 400a82c:	4009883a 	mov	r4,r8
 400a830:	480b883a 	mov	r5,r9
 400a834:	401694c0 	call	401694c <__muldf3>
 400a838:	1009883a 	mov	r4,r2
 400a83c:	180b883a 	mov	r5,r3
 400a840:	2005883a 	mov	r2,r4
 400a844:	2807883a 	mov	r3,r5
 400a848:	100d883a 	mov	r6,r2
 400a84c:	180f883a 	mov	r7,r3
 400a850:	9009883a 	mov	r4,r18
 400a854:	980b883a 	mov	r5,r19
 400a858:	40154400 	call	4015440 <__adddf3>
 400a85c:	1009883a 	mov	r4,r2
 400a860:	180b883a 	mov	r5,r3
 400a864:	e13fe415 	stw	r4,-112(fp)
 400a868:	e17fe515 	stw	r5,-108(fp)
#endif
  k = (int) ds;
 400a86c:	e13fe417 	ldw	r4,-112(fp)
 400a870:	e17fe517 	ldw	r5,-108(fp)
 400a874:	4017a7c0 	call	4017a7c <__fixdfsi>
 400a878:	e0bff315 	stw	r2,-52(fp)
  if (ds < 0. && ds != k)
 400a87c:	000d883a 	mov	r6,zero
 400a880:	000f883a 	mov	r7,zero
 400a884:	e13fe417 	ldw	r4,-112(fp)
 400a888:	e17fe517 	ldw	r5,-108(fp)
 400a88c:	401685c0 	call	401685c <__ledf2>
 400a890:	10000d0e 	bge	r2,zero,400a8c8 <_dtoa_r+0x428>
 400a894:	e13ff317 	ldw	r4,-52(fp)
 400a898:	4017afc0 	call	4017afc <__floatsidf>
 400a89c:	1009883a 	mov	r4,r2
 400a8a0:	180b883a 	mov	r5,r3
 400a8a4:	200d883a 	mov	r6,r4
 400a8a8:	280f883a 	mov	r7,r5
 400a8ac:	e13fe417 	ldw	r4,-112(fp)
 400a8b0:	e17fe517 	ldw	r5,-108(fp)
 400a8b4:	40166ec0 	call	40166ec <__eqdf2>
 400a8b8:	10000326 	beq	r2,zero,400a8c8 <_dtoa_r+0x428>
    k--;			/* want k = floor(ds) */
 400a8bc:	e0bff317 	ldw	r2,-52(fp)
 400a8c0:	10bfffc4 	addi	r2,r2,-1
 400a8c4:	e0bff315 	stw	r2,-52(fp)
  k_check = 1;
 400a8c8:	00800044 	movi	r2,1
 400a8cc:	e0bff215 	stw	r2,-56(fp)
  if (k >= 0 && k <= Ten_pmax)
 400a8d0:	e0bff317 	ldw	r2,-52(fp)
 400a8d4:	10001716 	blt	r2,zero,400a934 <_dtoa_r+0x494>
 400a8d8:	e0bff317 	ldw	r2,-52(fp)
 400a8dc:	108005c8 	cmpgei	r2,r2,23
 400a8e0:	1000141e 	bne	r2,zero,400a934 <_dtoa_r+0x494>
    {
      if (d.d < tens[k])
 400a8e4:	e0bfd517 	ldw	r2,-172(fp)
 400a8e8:	e0ffd617 	ldw	r3,-168(fp)
 400a8ec:	e13ff317 	ldw	r4,-52(fp)
 400a8f0:	200e90fa 	slli	r7,r4,3
 400a8f4:	018100b4 	movhi	r6,1026
 400a8f8:	398d883a 	add	r6,r7,r6
 400a8fc:	312b1d17 	ldw	r4,-21388(r6)
 400a900:	018100b4 	movhi	r6,1026
 400a904:	398d883a 	add	r6,r7,r6
 400a908:	316b1e17 	ldw	r5,-21384(r6)
 400a90c:	200d883a 	mov	r6,r4
 400a910:	280f883a 	mov	r7,r5
 400a914:	1009883a 	mov	r4,r2
 400a918:	180b883a 	mov	r5,r3
 400a91c:	401685c0 	call	401685c <__ledf2>
 400a920:	1000030e 	bge	r2,zero,400a930 <_dtoa_r+0x490>
	k--;
 400a924:	e0bff317 	ldw	r2,-52(fp)
 400a928:	10bfffc4 	addi	r2,r2,-1
 400a92c:	e0bff315 	stw	r2,-52(fp)
      k_check = 0;
 400a930:	e03ff215 	stw	zero,-56(fp)
    }
  j = bbits - i - 1;
 400a934:	e0ffd817 	ldw	r3,-160(fp)
 400a938:	e0bff817 	ldw	r2,-32(fp)
 400a93c:	1885c83a 	sub	r2,r3,r2
 400a940:	10bfffc4 	addi	r2,r2,-1
 400a944:	e0bff415 	stw	r2,-48(fp)
  if (j >= 0)
 400a948:	e0bff417 	ldw	r2,-48(fp)
 400a94c:	10000416 	blt	r2,zero,400a960 <_dtoa_r+0x4c0>
    {
      b2 = 0;
 400a950:	e03ffb15 	stw	zero,-20(fp)
      s2 = j;
 400a954:	e0bff417 	ldw	r2,-48(fp)
 400a958:	e0bfee15 	stw	r2,-72(fp)
 400a95c:	00000406 	br	400a970 <_dtoa_r+0x4d0>
    }
  else
    {
      b2 = -j;
 400a960:	e0bff417 	ldw	r2,-48(fp)
 400a964:	0085c83a 	sub	r2,zero,r2
 400a968:	e0bffb15 	stw	r2,-20(fp)
      s2 = 0;
 400a96c:	e03fee15 	stw	zero,-72(fp)
    }
  if (k >= 0)
 400a970:	e0bff317 	ldw	r2,-52(fp)
 400a974:	10000816 	blt	r2,zero,400a998 <_dtoa_r+0x4f8>
    {
      b5 = 0;
 400a978:	e03ffa15 	stw	zero,-24(fp)
      s5 = k;
 400a97c:	e0bff317 	ldw	r2,-52(fp)
 400a980:	e0bfed15 	stw	r2,-76(fp)
      s2 += k;
 400a984:	e0ffee17 	ldw	r3,-72(fp)
 400a988:	e0bff317 	ldw	r2,-52(fp)
 400a98c:	1885883a 	add	r2,r3,r2
 400a990:	e0bfee15 	stw	r2,-72(fp)
 400a994:	00000806 	br	400a9b8 <_dtoa_r+0x518>
    }
  else
    {
      b2 -= k;
 400a998:	e0fffb17 	ldw	r3,-20(fp)
 400a99c:	e0bff317 	ldw	r2,-52(fp)
 400a9a0:	1885c83a 	sub	r2,r3,r2
 400a9a4:	e0bffb15 	stw	r2,-20(fp)
      b5 = -k;
 400a9a8:	e0bff317 	ldw	r2,-52(fp)
 400a9ac:	0085c83a 	sub	r2,zero,r2
 400a9b0:	e0bffa15 	stw	r2,-24(fp)
      s5 = 0;
 400a9b4:	e03fed15 	stw	zero,-76(fp)
    }
  if (mode < 0 || mode > 9)
 400a9b8:	e0bfcd17 	ldw	r2,-204(fp)
 400a9bc:	10000316 	blt	r2,zero,400a9cc <_dtoa_r+0x52c>
 400a9c0:	e0bfcd17 	ldw	r2,-204(fp)
 400a9c4:	10800290 	cmplti	r2,r2,10
 400a9c8:	1000011e 	bne	r2,zero,400a9d0 <_dtoa_r+0x530>
    mode = 0;
 400a9cc:	e03fcd15 	stw	zero,-204(fp)
  try_quick = 1;
 400a9d0:	00800044 	movi	r2,1
 400a9d4:	e0bfeb15 	stw	r2,-84(fp)
  if (mode > 5)
 400a9d8:	e0bfcd17 	ldw	r2,-204(fp)
 400a9dc:	10800190 	cmplti	r2,r2,6
 400a9e0:	1000041e 	bne	r2,zero,400a9f4 <_dtoa_r+0x554>
    {
      mode -= 4;
 400a9e4:	e0bfcd17 	ldw	r2,-204(fp)
 400a9e8:	10bfff04 	addi	r2,r2,-4
 400a9ec:	e0bfcd15 	stw	r2,-204(fp)
      try_quick = 0;
 400a9f0:	e03feb15 	stw	zero,-84(fp)
    }
  leftright = 1;
 400a9f4:	00800044 	movi	r2,1
 400a9f8:	e0bff115 	stw	r2,-60(fp)
  ilim = ilim1 = -1;
 400a9fc:	00bfffc4 	movi	r2,-1
 400aa00:	e0bff515 	stw	r2,-44(fp)
 400aa04:	e0bff517 	ldw	r2,-44(fp)
 400aa08:	e0bff615 	stw	r2,-40(fp)
 400aa0c:	e0bfcd17 	ldw	r2,-204(fp)
 400aa10:	108001a8 	cmpgeui	r2,r2,6
 400aa14:	10002b1e 	bne	r2,zero,400aac4 <_dtoa_r+0x624>
 400aa18:	e0bfcd17 	ldw	r2,-204(fp)
 400aa1c:	100690ba 	slli	r3,r2,2
 400aa20:	00810074 	movhi	r2,1025
 400aa24:	1885883a 	add	r2,r3,r2
 400aa28:	10aa8c17 	ldw	r2,-21968(r2)
 400aa2c:	1000683a 	jmp	r2
 400aa30:	0400aa48 	cmpgei	r16,zero,681
 400aa34:	0400aa48 	cmpgei	r16,zero,681
 400aa38:	0400aa58 	cmpnei	r16,zero,681
 400aa3c:	0400aa88 	cmpgei	r16,zero,682
 400aa40:	0400aa5c 	xori	r16,zero,681
 400aa44:	0400aa8c 	andi	r16,zero,682
  switch (mode)
    {
    case 0:
    case 1:
      i = 18;
 400aa48:	00800484 	movi	r2,18
 400aa4c:	e0bff815 	stw	r2,-32(fp)
      ndigits = 0;
 400aa50:	e0000215 	stw	zero,8(fp)
      break;
 400aa54:	00001b06 	br	400aac4 <_dtoa_r+0x624>
    case 2:
      leftright = 0;
 400aa58:	e03ff115 	stw	zero,-60(fp)
      /* no break */
    case 4:
      if (ndigits <= 0)
 400aa5c:	e0800217 	ldw	r2,8(fp)
 400aa60:	00800216 	blt	zero,r2,400aa6c <_dtoa_r+0x5cc>
	ndigits = 1;
 400aa64:	00800044 	movi	r2,1
 400aa68:	e0800215 	stw	r2,8(fp)
      ilim = ilim1 = i = ndigits;
 400aa6c:	e0800217 	ldw	r2,8(fp)
 400aa70:	e0bff815 	stw	r2,-32(fp)
 400aa74:	e0bff817 	ldw	r2,-32(fp)
 400aa78:	e0bff515 	stw	r2,-44(fp)
 400aa7c:	e0bff517 	ldw	r2,-44(fp)
 400aa80:	e0bff615 	stw	r2,-40(fp)
      break;
 400aa84:	00000f06 	br	400aac4 <_dtoa_r+0x624>
    case 3:
      leftright = 0;
 400aa88:	e03ff115 	stw	zero,-60(fp)
      /* no break */
    case 5:
      i = ndigits + k + 1;
 400aa8c:	e0c00217 	ldw	r3,8(fp)
 400aa90:	e0bff317 	ldw	r2,-52(fp)
 400aa94:	1885883a 	add	r2,r3,r2
 400aa98:	10800044 	addi	r2,r2,1
 400aa9c:	e0bff815 	stw	r2,-32(fp)
      ilim = i;
 400aaa0:	e0bff817 	ldw	r2,-32(fp)
 400aaa4:	e0bff615 	stw	r2,-40(fp)
      ilim1 = i - 1;
 400aaa8:	e0bff817 	ldw	r2,-32(fp)
 400aaac:	10bfffc4 	addi	r2,r2,-1
 400aab0:	e0bff515 	stw	r2,-44(fp)
      if (i <= 0)
 400aab4:	e0bff817 	ldw	r2,-32(fp)
 400aab8:	00800216 	blt	zero,r2,400aac4 <_dtoa_r+0x624>
	i = 1;
 400aabc:	00800044 	movi	r2,1
 400aac0:	e0bff815 	stw	r2,-32(fp)
    }
  j = sizeof (__ULong);
 400aac4:	00800104 	movi	r2,4
 400aac8:	e0bff415 	stw	r2,-48(fp)
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
 400aacc:	e0bfd017 	ldw	r2,-192(fp)
 400aad0:	10001115 	stw	zero,68(r2)
 400aad4:	00000806 	br	400aaf8 <_dtoa_r+0x658>
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
 400aad8:	e0bfd017 	ldw	r2,-192(fp)
 400aadc:	10801117 	ldw	r2,68(r2)
 400aae0:	10c00044 	addi	r3,r2,1
 400aae4:	e0bfd017 	ldw	r2,-192(fp)
 400aae8:	10c01115 	stw	r3,68(r2)
       j <<= 1)
 400aaec:	e0bff417 	ldw	r2,-48(fp)
 400aaf0:	1085883a 	add	r2,r2,r2
 400aaf4:	e0bff415 	stw	r2,-48(fp)
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
 400aaf8:	e0bff417 	ldw	r2,-48(fp)
 400aafc:	10800504 	addi	r2,r2,20
 400ab00:	e0fff817 	ldw	r3,-32(fp)
 400ab04:	18bff42e 	bgeu	r3,r2,400aad8 <_dtoa_r+0x638>
  _REENT_MP_RESULT(ptr) = eBalloc (ptr, _REENT_MP_RESULT_K(ptr));
 400ab08:	e0bfd017 	ldw	r2,-192(fp)
 400ab0c:	10801117 	ldw	r2,68(r2)
 400ab10:	100b883a 	mov	r5,r2
 400ab14:	e13fd017 	ldw	r4,-192(fp)
 400ab18:	400f06c0 	call	400f06c <_Balloc>
 400ab1c:	e0bfe115 	stw	r2,-124(fp)
 400ab20:	e0bfe117 	ldw	r2,-124(fp)
 400ab24:	1000071e 	bne	r2,zero,400ab44 <_dtoa_r+0x6a4>
 400ab28:	01c100b4 	movhi	r7,1026
 400ab2c:	39eae504 	addi	r7,r7,-21612
 400ab30:	000d883a 	mov	r6,zero
 400ab34:	01406a84 	movi	r5,426
 400ab38:	010100b4 	movhi	r4,1026
 400ab3c:	212aea04 	addi	r4,r4,-21592
 400ab40:	40130ac0 	call	40130ac <__assert_func>
 400ab44:	e0ffe117 	ldw	r3,-124(fp)
 400ab48:	e0bfd017 	ldw	r2,-192(fp)
 400ab4c:	10c01015 	stw	r3,64(r2)
  s = s0 = (char *) _REENT_MP_RESULT(ptr);
 400ab50:	e0bfd017 	ldw	r2,-192(fp)
 400ab54:	10801017 	ldw	r2,64(r2)
 400ab58:	e0bfe015 	stw	r2,-128(fp)
 400ab5c:	e0bfe017 	ldw	r2,-128(fp)
 400ab60:	e0bfe315 	stw	r2,-116(fp)

  if (ilim >= 0 && ilim <= Quick_max && try_quick)
 400ab64:	e0bff617 	ldw	r2,-40(fp)
 400ab68:	10022016 	blt	r2,zero,400b3ec <_dtoa_r+0xf4c>
 400ab6c:	e0bff617 	ldw	r2,-40(fp)
 400ab70:	108003c8 	cmpgei	r2,r2,15
 400ab74:	10021d1e 	bne	r2,zero,400b3ec <_dtoa_r+0xf4c>
 400ab78:	e0bfeb17 	ldw	r2,-84(fp)
 400ab7c:	10021b26 	beq	r2,zero,400b3ec <_dtoa_r+0xf4c>
    {
      /* Try to get by with floating-point arithmetic. */

      i = 0;
 400ab80:	e03ff815 	stw	zero,-32(fp)
      d2.d = d.d;
 400ab84:	e0bfd517 	ldw	r2,-172(fp)
 400ab88:	e0ffd617 	ldw	r3,-168(fp)
 400ab8c:	e0bfd315 	stw	r2,-180(fp)
 400ab90:	e0ffd415 	stw	r3,-176(fp)
      k0 = k;
 400ab94:	e0bff317 	ldw	r2,-52(fp)
 400ab98:	e0bfdf15 	stw	r2,-132(fp)
      ilim0 = ilim;
 400ab9c:	e0bff617 	ldw	r2,-40(fp)
 400aba0:	e0bfde15 	stw	r2,-136(fp)
      ieps = 2;			/* conservative */
 400aba4:	00800084 	movi	r2,2
 400aba8:	e0bff715 	stw	r2,-36(fp)
      if (k > 0)
 400abac:	e0bff317 	ldw	r2,-52(fp)
 400abb0:	0080560e 	bge	zero,r2,400ad0c <_dtoa_r+0x86c>
	{
	  ds = tens[k & 0xf];
 400abb4:	e0bff317 	ldw	r2,-52(fp)
 400abb8:	108003cc 	andi	r2,r2,15
 400abbc:	100690fa 	slli	r3,r2,3
 400abc0:	008100b4 	movhi	r2,1026
 400abc4:	1885883a 	add	r2,r3,r2
 400abc8:	10ab1d17 	ldw	r2,-21388(r2)
 400abcc:	e0bfe415 	stw	r2,-112(fp)
 400abd0:	008100b4 	movhi	r2,1026
 400abd4:	1885883a 	add	r2,r3,r2
 400abd8:	10ab1e17 	ldw	r2,-21384(r2)
 400abdc:	e0bfe515 	stw	r2,-108(fp)
	  j = k >> 4;
 400abe0:	e0bff317 	ldw	r2,-52(fp)
 400abe4:	1005d13a 	srai	r2,r2,4
 400abe8:	e0bff415 	stw	r2,-48(fp)
	  if (j & Bletch)
 400abec:	e0bff417 	ldw	r2,-48(fp)
 400abf0:	1080040c 	andi	r2,r2,16
 400abf4:	10003526 	beq	r2,zero,400accc <_dtoa_r+0x82c>
	    {
	      /* prevent overflows */
	      j &= Bletch - 1;
 400abf8:	e0bff417 	ldw	r2,-48(fp)
 400abfc:	108003cc 	andi	r2,r2,15
 400ac00:	e0bff415 	stw	r2,-48(fp)
	      d.d /= bigtens[n_bigtens - 1];
 400ac04:	e0bfd517 	ldw	r2,-172(fp)
 400ac08:	e0ffd617 	ldw	r3,-168(fp)
 400ac0c:	018100b4 	movhi	r6,1026
 400ac10:	312b5717 	ldw	r4,-21156(r6)
 400ac14:	018100b4 	movhi	r6,1026
 400ac18:	316b5817 	ldw	r5,-21152(r6)
 400ac1c:	200d883a 	mov	r6,r4
 400ac20:	280f883a 	mov	r7,r5
 400ac24:	1009883a 	mov	r4,r2
 400ac28:	180b883a 	mov	r5,r3
 400ac2c:	4015db80 	call	4015db8 <__divdf3>
 400ac30:	1009883a 	mov	r4,r2
 400ac34:	180b883a 	mov	r5,r3
 400ac38:	2005883a 	mov	r2,r4
 400ac3c:	2807883a 	mov	r3,r5
 400ac40:	e0bfd515 	stw	r2,-172(fp)
 400ac44:	e0ffd615 	stw	r3,-168(fp)
	      ieps++;
 400ac48:	e0bff717 	ldw	r2,-36(fp)
 400ac4c:	10800044 	addi	r2,r2,1
 400ac50:	e0bff715 	stw	r2,-36(fp)
	    }
	  for (; j; j >>= 1, i++)
 400ac54:	00001d06 	br	400accc <_dtoa_r+0x82c>
	    if (j & 1)
 400ac58:	e0bff417 	ldw	r2,-48(fp)
 400ac5c:	1080004c 	andi	r2,r2,1
 400ac60:	10001426 	beq	r2,zero,400acb4 <_dtoa_r+0x814>
	      {
		ieps++;
 400ac64:	e0bff717 	ldw	r2,-36(fp)
 400ac68:	10800044 	addi	r2,r2,1
 400ac6c:	e0bff715 	stw	r2,-36(fp)
		ds *= bigtens[i];
 400ac70:	e0bff817 	ldw	r2,-32(fp)
 400ac74:	100a90fa 	slli	r5,r2,3
 400ac78:	010100b4 	movhi	r4,1026
 400ac7c:	2909883a 	add	r4,r5,r4
 400ac80:	20ab4f17 	ldw	r2,-21188(r4)
 400ac84:	010100b4 	movhi	r4,1026
 400ac88:	2909883a 	add	r4,r5,r4
 400ac8c:	20eb5017 	ldw	r3,-21184(r4)
 400ac90:	100d883a 	mov	r6,r2
 400ac94:	180f883a 	mov	r7,r3
 400ac98:	e13fe417 	ldw	r4,-112(fp)
 400ac9c:	e17fe517 	ldw	r5,-108(fp)
 400aca0:	401694c0 	call	401694c <__muldf3>
 400aca4:	1009883a 	mov	r4,r2
 400aca8:	180b883a 	mov	r5,r3
 400acac:	e13fe415 	stw	r4,-112(fp)
 400acb0:	e17fe515 	stw	r5,-108(fp)
	  for (; j; j >>= 1, i++)
 400acb4:	e0bff417 	ldw	r2,-48(fp)
 400acb8:	1005d07a 	srai	r2,r2,1
 400acbc:	e0bff415 	stw	r2,-48(fp)
 400acc0:	e0bff817 	ldw	r2,-32(fp)
 400acc4:	10800044 	addi	r2,r2,1
 400acc8:	e0bff815 	stw	r2,-32(fp)
 400accc:	e0bff417 	ldw	r2,-48(fp)
 400acd0:	103fe11e 	bne	r2,zero,400ac58 <_dtoa_r+0x7b8>
	      }
	  d.d /= ds;
 400acd4:	e0bfd517 	ldw	r2,-172(fp)
 400acd8:	e0ffd617 	ldw	r3,-168(fp)
 400acdc:	e1bfe417 	ldw	r6,-112(fp)
 400ace0:	e1ffe517 	ldw	r7,-108(fp)
 400ace4:	1009883a 	mov	r4,r2
 400ace8:	180b883a 	mov	r5,r3
 400acec:	4015db80 	call	4015db8 <__divdf3>
 400acf0:	1009883a 	mov	r4,r2
 400acf4:	180b883a 	mov	r5,r3
 400acf8:	2005883a 	mov	r2,r4
 400acfc:	2807883a 	mov	r3,r5
 400ad00:	e0bfd515 	stw	r2,-172(fp)
 400ad04:	e0ffd615 	stw	r3,-168(fp)
 400ad08:	00004206 	br	400ae14 <_dtoa_r+0x974>
	}
      else if ((j1 = -k) != 0)
 400ad0c:	e0bff317 	ldw	r2,-52(fp)
 400ad10:	0085c83a 	sub	r2,zero,r2
 400ad14:	e0bfdd15 	stw	r2,-140(fp)
 400ad18:	e0bfdd17 	ldw	r2,-140(fp)
 400ad1c:	10003d26 	beq	r2,zero,400ae14 <_dtoa_r+0x974>
	{
	  d.d *= tens[j1 & 0xf];
 400ad20:	e0bfd517 	ldw	r2,-172(fp)
 400ad24:	e0ffd617 	ldw	r3,-168(fp)
 400ad28:	e13fdd17 	ldw	r4,-140(fp)
 400ad2c:	210003cc 	andi	r4,r4,15
 400ad30:	200e90fa 	slli	r7,r4,3
 400ad34:	018100b4 	movhi	r6,1026
 400ad38:	398d883a 	add	r6,r7,r6
 400ad3c:	312b1d17 	ldw	r4,-21388(r6)
 400ad40:	018100b4 	movhi	r6,1026
 400ad44:	398d883a 	add	r6,r7,r6
 400ad48:	316b1e17 	ldw	r5,-21384(r6)
 400ad4c:	200d883a 	mov	r6,r4
 400ad50:	280f883a 	mov	r7,r5
 400ad54:	1009883a 	mov	r4,r2
 400ad58:	180b883a 	mov	r5,r3
 400ad5c:	401694c0 	call	401694c <__muldf3>
 400ad60:	1009883a 	mov	r4,r2
 400ad64:	180b883a 	mov	r5,r3
 400ad68:	2005883a 	mov	r2,r4
 400ad6c:	2807883a 	mov	r3,r5
 400ad70:	e0bfd515 	stw	r2,-172(fp)
 400ad74:	e0ffd615 	stw	r3,-168(fp)
	  for (j = j1 >> 4; j; j >>= 1, i++)
 400ad78:	e0bfdd17 	ldw	r2,-140(fp)
 400ad7c:	1005d13a 	srai	r2,r2,4
 400ad80:	e0bff415 	stw	r2,-48(fp)
 400ad84:	00002106 	br	400ae0c <_dtoa_r+0x96c>
	    if (j & 1)
 400ad88:	e0bff417 	ldw	r2,-48(fp)
 400ad8c:	1080004c 	andi	r2,r2,1
 400ad90:	10001826 	beq	r2,zero,400adf4 <_dtoa_r+0x954>
	      {
		ieps++;
 400ad94:	e0bff717 	ldw	r2,-36(fp)
 400ad98:	10800044 	addi	r2,r2,1
 400ad9c:	e0bff715 	stw	r2,-36(fp)
		d.d *= bigtens[i];
 400ada0:	e0bfd517 	ldw	r2,-172(fp)
 400ada4:	e0ffd617 	ldw	r3,-168(fp)
 400ada8:	e13ff817 	ldw	r4,-32(fp)
 400adac:	200e90fa 	slli	r7,r4,3
 400adb0:	018100b4 	movhi	r6,1026
 400adb4:	398d883a 	add	r6,r7,r6
 400adb8:	312b4f17 	ldw	r4,-21188(r6)
 400adbc:	018100b4 	movhi	r6,1026
 400adc0:	398d883a 	add	r6,r7,r6
 400adc4:	316b5017 	ldw	r5,-21184(r6)
 400adc8:	200d883a 	mov	r6,r4
 400adcc:	280f883a 	mov	r7,r5
 400add0:	1009883a 	mov	r4,r2
 400add4:	180b883a 	mov	r5,r3
 400add8:	401694c0 	call	401694c <__muldf3>
 400addc:	1009883a 	mov	r4,r2
 400ade0:	180b883a 	mov	r5,r3
 400ade4:	2005883a 	mov	r2,r4
 400ade8:	2807883a 	mov	r3,r5
 400adec:	e0bfd515 	stw	r2,-172(fp)
 400adf0:	e0ffd615 	stw	r3,-168(fp)
	  for (j = j1 >> 4; j; j >>= 1, i++)
 400adf4:	e0bff417 	ldw	r2,-48(fp)
 400adf8:	1005d07a 	srai	r2,r2,1
 400adfc:	e0bff415 	stw	r2,-48(fp)
 400ae00:	e0bff817 	ldw	r2,-32(fp)
 400ae04:	10800044 	addi	r2,r2,1
 400ae08:	e0bff815 	stw	r2,-32(fp)
 400ae0c:	e0bff417 	ldw	r2,-48(fp)
 400ae10:	103fdd1e 	bne	r2,zero,400ad88 <_dtoa_r+0x8e8>
	      }
	}
      if (k_check && d.d < 1. && ilim > 0)
 400ae14:	e0bff217 	ldw	r2,-56(fp)
 400ae18:	10002126 	beq	r2,zero,400aea0 <_dtoa_r+0xa00>
 400ae1c:	e0bfd517 	ldw	r2,-172(fp)
 400ae20:	e0ffd617 	ldw	r3,-168(fp)
 400ae24:	000d883a 	mov	r6,zero
 400ae28:	01cffc34 	movhi	r7,16368
 400ae2c:	1009883a 	mov	r4,r2
 400ae30:	180b883a 	mov	r5,r3
 400ae34:	401685c0 	call	401685c <__ledf2>
 400ae38:	1000190e 	bge	r2,zero,400aea0 <_dtoa_r+0xa00>
 400ae3c:	e0bff617 	ldw	r2,-40(fp)
 400ae40:	0080170e 	bge	zero,r2,400aea0 <_dtoa_r+0xa00>
	{
	  if (ilim1 <= 0)
 400ae44:	e0bff517 	ldw	r2,-44(fp)
 400ae48:	00815b0e 	bge	zero,r2,400b3b8 <_dtoa_r+0xf18>
	    goto fast_failed;
	  ilim = ilim1;
 400ae4c:	e0bff517 	ldw	r2,-44(fp)
 400ae50:	e0bff615 	stw	r2,-40(fp)
	  k--;
 400ae54:	e0bff317 	ldw	r2,-52(fp)
 400ae58:	10bfffc4 	addi	r2,r2,-1
 400ae5c:	e0bff315 	stw	r2,-52(fp)
	  d.d *= 10.;
 400ae60:	e0bfd517 	ldw	r2,-172(fp)
 400ae64:	e0ffd617 	ldw	r3,-168(fp)
 400ae68:	000d883a 	mov	r6,zero
 400ae6c:	01d00934 	movhi	r7,16420
 400ae70:	1009883a 	mov	r4,r2
 400ae74:	180b883a 	mov	r5,r3
 400ae78:	401694c0 	call	401694c <__muldf3>
 400ae7c:	1009883a 	mov	r4,r2
 400ae80:	180b883a 	mov	r5,r3
 400ae84:	2005883a 	mov	r2,r4
 400ae88:	2807883a 	mov	r3,r5
 400ae8c:	e0bfd515 	stw	r2,-172(fp)
 400ae90:	e0ffd615 	stw	r3,-168(fp)
	  ieps++;
 400ae94:	e0bff717 	ldw	r2,-36(fp)
 400ae98:	10800044 	addi	r2,r2,1
 400ae9c:	e0bff715 	stw	r2,-36(fp)
	}
      eps.d = ieps * d.d + 7.;
 400aea0:	e13ff717 	ldw	r4,-36(fp)
 400aea4:	4017afc0 	call	4017afc <__floatsidf>
 400aea8:	1011883a 	mov	r8,r2
 400aeac:	1813883a 	mov	r9,r3
 400aeb0:	e0bfd517 	ldw	r2,-172(fp)
 400aeb4:	e0ffd617 	ldw	r3,-168(fp)
 400aeb8:	100d883a 	mov	r6,r2
 400aebc:	180f883a 	mov	r7,r3
 400aec0:	4009883a 	mov	r4,r8
 400aec4:	480b883a 	mov	r5,r9
 400aec8:	401694c0 	call	401694c <__muldf3>
 400aecc:	1009883a 	mov	r4,r2
 400aed0:	180b883a 	mov	r5,r3
 400aed4:	2005883a 	mov	r2,r4
 400aed8:	2807883a 	mov	r3,r5
 400aedc:	000d883a 	mov	r6,zero
 400aee0:	01d00734 	movhi	r7,16412
 400aee4:	1009883a 	mov	r4,r2
 400aee8:	180b883a 	mov	r5,r3
 400aeec:	40154400 	call	4015440 <__adddf3>
 400aef0:	1009883a 	mov	r4,r2
 400aef4:	180b883a 	mov	r5,r3
 400aef8:	2005883a 	mov	r2,r4
 400aefc:	2807883a 	mov	r3,r5
 400af00:	e0bfd115 	stw	r2,-188(fp)
 400af04:	e0ffd215 	stw	r3,-184(fp)
      word0 (eps) -= (P - 1) * Exp_msk1;
 400af08:	e0ffd217 	ldw	r3,-184(fp)
 400af0c:	00bf3034 	movhi	r2,64704
 400af10:	1885883a 	add	r2,r3,r2
 400af14:	e0bfd215 	stw	r2,-184(fp)
      if (ilim == 0)
 400af18:	e0bff617 	ldw	r2,-40(fp)
 400af1c:	1000271e 	bne	r2,zero,400afbc <_dtoa_r+0xb1c>
	{
	  S = mhi = 0;
 400af20:	e03fe715 	stw	zero,-100(fp)
 400af24:	e0bfe717 	ldw	r2,-100(fp)
 400af28:	e0bfe615 	stw	r2,-104(fp)
	  d.d -= 5.;
 400af2c:	e0bfd517 	ldw	r2,-172(fp)
 400af30:	e0ffd617 	ldw	r3,-168(fp)
 400af34:	000d883a 	mov	r6,zero
 400af38:	01d00534 	movhi	r7,16404
 400af3c:	1009883a 	mov	r4,r2
 400af40:	180b883a 	mov	r5,r3
 400af44:	40170f40 	call	40170f4 <__subdf3>
 400af48:	1009883a 	mov	r4,r2
 400af4c:	180b883a 	mov	r5,r3
 400af50:	2005883a 	mov	r2,r4
 400af54:	2807883a 	mov	r3,r5
 400af58:	e0bfd515 	stw	r2,-172(fp)
 400af5c:	e0ffd615 	stw	r3,-168(fp)
	  if (d.d > eps.d)
 400af60:	e0bfd517 	ldw	r2,-172(fp)
 400af64:	e0ffd617 	ldw	r3,-168(fp)
 400af68:	e13fd117 	ldw	r4,-188(fp)
 400af6c:	e17fd217 	ldw	r5,-184(fp)
 400af70:	200d883a 	mov	r6,r4
 400af74:	280f883a 	mov	r7,r5
 400af78:	1009883a 	mov	r4,r2
 400af7c:	180b883a 	mov	r5,r3
 400af80:	401676c0 	call	401676c <__gedf2>
 400af84:	0082f916 	blt	zero,r2,400bb6c <_dtoa_r+0x16cc>
	    goto one_digit;
	  if (d.d < -eps.d)
 400af88:	e23fd517 	ldw	r8,-172(fp)
 400af8c:	e27fd617 	ldw	r9,-168(fp)
 400af90:	e0bfd117 	ldw	r2,-188(fp)
 400af94:	e0ffd217 	ldw	r3,-184(fp)
 400af98:	1021883a 	mov	r16,r2
 400af9c:	1c60003c 	xorhi	r17,r3,32768
 400afa0:	800d883a 	mov	r6,r16
 400afa4:	880f883a 	mov	r7,r17
 400afa8:	4009883a 	mov	r4,r8
 400afac:	480b883a 	mov	r5,r9
 400afb0:	401685c0 	call	401685c <__ledf2>
 400afb4:	1002e416 	blt	r2,zero,400bb48 <_dtoa_r+0x16a8>
	    goto no_digits;
	  goto fast_failed;
 400afb8:	00010206 	br	400b3c4 <_dtoa_r+0xf24>
	}
#ifndef No_leftright
      if (leftright)
 400afbc:	e0bff117 	ldw	r2,-60(fp)
 400afc0:	10007d26 	beq	r2,zero,400b1b8 <_dtoa_r+0xd18>
	{
	  /* Use Steele & White method of only
	   * generating digits needed.
	   */
	  eps.d = 0.5 / tens[ilim - 1] - eps.d;
 400afc4:	e0bff617 	ldw	r2,-40(fp)
 400afc8:	10bfffc4 	addi	r2,r2,-1
 400afcc:	100a90fa 	slli	r5,r2,3
 400afd0:	010100b4 	movhi	r4,1026
 400afd4:	2909883a 	add	r4,r5,r4
 400afd8:	20ab1d17 	ldw	r2,-21388(r4)
 400afdc:	010100b4 	movhi	r4,1026
 400afe0:	2909883a 	add	r4,r5,r4
 400afe4:	20eb1e17 	ldw	r3,-21384(r4)
 400afe8:	100d883a 	mov	r6,r2
 400afec:	180f883a 	mov	r7,r3
 400aff0:	0009883a 	mov	r4,zero
 400aff4:	014ff834 	movhi	r5,16352
 400aff8:	4015db80 	call	4015db8 <__divdf3>
 400affc:	1009883a 	mov	r4,r2
 400b000:	180b883a 	mov	r5,r3
 400b004:	2011883a 	mov	r8,r4
 400b008:	2813883a 	mov	r9,r5
 400b00c:	e0bfd117 	ldw	r2,-188(fp)
 400b010:	e0ffd217 	ldw	r3,-184(fp)
 400b014:	100d883a 	mov	r6,r2
 400b018:	180f883a 	mov	r7,r3
 400b01c:	4009883a 	mov	r4,r8
 400b020:	480b883a 	mov	r5,r9
 400b024:	40170f40 	call	40170f4 <__subdf3>
 400b028:	1009883a 	mov	r4,r2
 400b02c:	180b883a 	mov	r5,r3
 400b030:	2005883a 	mov	r2,r4
 400b034:	2807883a 	mov	r3,r5
 400b038:	e0bfd115 	stw	r2,-188(fp)
 400b03c:	e0ffd215 	stw	r3,-184(fp)
	  for (i = 0;;)
 400b040:	e03ff815 	stw	zero,-32(fp)
	    {
	      L = d.d;
 400b044:	e0bfd517 	ldw	r2,-172(fp)
 400b048:	e0ffd617 	ldw	r3,-168(fp)
 400b04c:	1009883a 	mov	r4,r2
 400b050:	180b883a 	mov	r5,r3
 400b054:	4017a7c0 	call	4017a7c <__fixdfsi>
 400b058:	e0bfdc15 	stw	r2,-144(fp)
	      d.d -= L;
 400b05c:	e43fd517 	ldw	r16,-172(fp)
 400b060:	e47fd617 	ldw	r17,-168(fp)
 400b064:	e13fdc17 	ldw	r4,-144(fp)
 400b068:	4017afc0 	call	4017afc <__floatsidf>
 400b06c:	1009883a 	mov	r4,r2
 400b070:	180b883a 	mov	r5,r3
 400b074:	200d883a 	mov	r6,r4
 400b078:	280f883a 	mov	r7,r5
 400b07c:	8009883a 	mov	r4,r16
 400b080:	880b883a 	mov	r5,r17
 400b084:	40170f40 	call	40170f4 <__subdf3>
 400b088:	1009883a 	mov	r4,r2
 400b08c:	180b883a 	mov	r5,r3
 400b090:	2005883a 	mov	r2,r4
 400b094:	2807883a 	mov	r3,r5
 400b098:	e0bfd515 	stw	r2,-172(fp)
 400b09c:	e0ffd615 	stw	r3,-168(fp)
	      *s++ = '0' + (int) L;
 400b0a0:	e0bfdc17 	ldw	r2,-144(fp)
 400b0a4:	10800c04 	addi	r2,r2,48
 400b0a8:	1009883a 	mov	r4,r2
 400b0ac:	e0bfe317 	ldw	r2,-116(fp)
 400b0b0:	10c00044 	addi	r3,r2,1
 400b0b4:	e0ffe315 	stw	r3,-116(fp)
 400b0b8:	2007883a 	mov	r3,r4
 400b0bc:	10c00005 	stb	r3,0(r2)
	      if (d.d < eps.d)
 400b0c0:	e0bfd517 	ldw	r2,-172(fp)
 400b0c4:	e0ffd617 	ldw	r3,-168(fp)
 400b0c8:	e13fd117 	ldw	r4,-188(fp)
 400b0cc:	e17fd217 	ldw	r5,-184(fp)
 400b0d0:	200d883a 	mov	r6,r4
 400b0d4:	280f883a 	mov	r7,r5
 400b0d8:	1009883a 	mov	r4,r2
 400b0dc:	180b883a 	mov	r5,r3
 400b0e0:	401685c0 	call	401685c <__ledf2>
 400b0e4:	1003de16 	blt	r2,zero,400c060 <_dtoa_r+0x1bc0>
		goto ret1;
	      if (1. - d.d < eps.d)
 400b0e8:	e0bfd517 	ldw	r2,-172(fp)
 400b0ec:	e0ffd617 	ldw	r3,-168(fp)
 400b0f0:	100d883a 	mov	r6,r2
 400b0f4:	180f883a 	mov	r7,r3
 400b0f8:	0009883a 	mov	r4,zero
 400b0fc:	014ffc34 	movhi	r5,16368
 400b100:	40170f40 	call	40170f4 <__subdf3>
 400b104:	1009883a 	mov	r4,r2
 400b108:	180b883a 	mov	r5,r3
 400b10c:	2011883a 	mov	r8,r4
 400b110:	2813883a 	mov	r9,r5
 400b114:	e0bfd117 	ldw	r2,-188(fp)
 400b118:	e0ffd217 	ldw	r3,-184(fp)
 400b11c:	100d883a 	mov	r6,r2
 400b120:	180f883a 	mov	r7,r3
 400b124:	4009883a 	mov	r4,r8
 400b128:	480b883a 	mov	r5,r9
 400b12c:	401685c0 	call	401685c <__ledf2>
 400b130:	10012f16 	blt	r2,zero,400b5f0 <_dtoa_r+0x1150>
		goto bump_up;
	      if (++i >= ilim)
 400b134:	e0bff817 	ldw	r2,-32(fp)
 400b138:	10800044 	addi	r2,r2,1
 400b13c:	e0bff815 	stw	r2,-32(fp)
 400b140:	e0fff817 	ldw	r3,-32(fp)
 400b144:	e0bff617 	ldw	r2,-40(fp)
 400b148:	18809d0e 	bge	r3,r2,400b3c0 <_dtoa_r+0xf20>
		break;
	      eps.d *= 10.;
 400b14c:	e0bfd117 	ldw	r2,-188(fp)
 400b150:	e0ffd217 	ldw	r3,-184(fp)
 400b154:	000d883a 	mov	r6,zero
 400b158:	01d00934 	movhi	r7,16420
 400b15c:	1009883a 	mov	r4,r2
 400b160:	180b883a 	mov	r5,r3
 400b164:	401694c0 	call	401694c <__muldf3>
 400b168:	1009883a 	mov	r4,r2
 400b16c:	180b883a 	mov	r5,r3
 400b170:	2005883a 	mov	r2,r4
 400b174:	2807883a 	mov	r3,r5
 400b178:	e0bfd115 	stw	r2,-188(fp)
 400b17c:	e0ffd215 	stw	r3,-184(fp)
	      d.d *= 10.;
 400b180:	e0bfd517 	ldw	r2,-172(fp)
 400b184:	e0ffd617 	ldw	r3,-168(fp)
 400b188:	000d883a 	mov	r6,zero
 400b18c:	01d00934 	movhi	r7,16420
 400b190:	1009883a 	mov	r4,r2
 400b194:	180b883a 	mov	r5,r3
 400b198:	401694c0 	call	401694c <__muldf3>
 400b19c:	1009883a 	mov	r4,r2
 400b1a0:	180b883a 	mov	r5,r3
 400b1a4:	2005883a 	mov	r2,r4
 400b1a8:	2807883a 	mov	r3,r5
 400b1ac:	e0bfd515 	stw	r2,-172(fp)
 400b1b0:	e0ffd615 	stw	r3,-168(fp)
	      L = d.d;
 400b1b4:	003fa306 	br	400b044 <_dtoa_r+0xba4>
	}
      else
	{
#endif
	  /* Generate ilim digits, then fix them up. */
	  eps.d *= tens[ilim - 1];
 400b1b8:	e0bfd117 	ldw	r2,-188(fp)
 400b1bc:	e0ffd217 	ldw	r3,-184(fp)
 400b1c0:	e13ff617 	ldw	r4,-40(fp)
 400b1c4:	213fffc4 	addi	r4,r4,-1
 400b1c8:	200e90fa 	slli	r7,r4,3
 400b1cc:	018100b4 	movhi	r6,1026
 400b1d0:	398d883a 	add	r6,r7,r6
 400b1d4:	312b1d17 	ldw	r4,-21388(r6)
 400b1d8:	018100b4 	movhi	r6,1026
 400b1dc:	398d883a 	add	r6,r7,r6
 400b1e0:	316b1e17 	ldw	r5,-21384(r6)
 400b1e4:	200d883a 	mov	r6,r4
 400b1e8:	280f883a 	mov	r7,r5
 400b1ec:	1009883a 	mov	r4,r2
 400b1f0:	180b883a 	mov	r5,r3
 400b1f4:	401694c0 	call	401694c <__muldf3>
 400b1f8:	1009883a 	mov	r4,r2
 400b1fc:	180b883a 	mov	r5,r3
 400b200:	2005883a 	mov	r2,r4
 400b204:	2807883a 	mov	r3,r5
 400b208:	e0bfd115 	stw	r2,-188(fp)
 400b20c:	e0ffd215 	stw	r3,-184(fp)
	  for (i = 1;; i++, d.d *= 10.)
 400b210:	00800044 	movi	r2,1
 400b214:	e0bff815 	stw	r2,-32(fp)
	    {
	      L = d.d;
 400b218:	e0bfd517 	ldw	r2,-172(fp)
 400b21c:	e0ffd617 	ldw	r3,-168(fp)
 400b220:	1009883a 	mov	r4,r2
 400b224:	180b883a 	mov	r5,r3
 400b228:	4017a7c0 	call	4017a7c <__fixdfsi>
 400b22c:	e0bfdc15 	stw	r2,-144(fp)
	      d.d -= L;
 400b230:	e43fd517 	ldw	r16,-172(fp)
 400b234:	e47fd617 	ldw	r17,-168(fp)
 400b238:	e13fdc17 	ldw	r4,-144(fp)
 400b23c:	4017afc0 	call	4017afc <__floatsidf>
 400b240:	1009883a 	mov	r4,r2
 400b244:	180b883a 	mov	r5,r3
 400b248:	200d883a 	mov	r6,r4
 400b24c:	280f883a 	mov	r7,r5
 400b250:	8009883a 	mov	r4,r16
 400b254:	880b883a 	mov	r5,r17
 400b258:	40170f40 	call	40170f4 <__subdf3>
 400b25c:	1009883a 	mov	r4,r2
 400b260:	180b883a 	mov	r5,r3
 400b264:	2005883a 	mov	r2,r4
 400b268:	2807883a 	mov	r3,r5
 400b26c:	e0bfd515 	stw	r2,-172(fp)
 400b270:	e0ffd615 	stw	r3,-168(fp)
	      *s++ = '0' + (int) L;
 400b274:	e0bfdc17 	ldw	r2,-144(fp)
 400b278:	10800c04 	addi	r2,r2,48
 400b27c:	1009883a 	mov	r4,r2
 400b280:	e0bfe317 	ldw	r2,-116(fp)
 400b284:	10c00044 	addi	r3,r2,1
 400b288:	e0ffe315 	stw	r3,-116(fp)
 400b28c:	2007883a 	mov	r3,r4
 400b290:	10c00005 	stb	r3,0(r2)
	      if (i == ilim)
 400b294:	e0fff817 	ldw	r3,-32(fp)
 400b298:	e0bff617 	ldw	r2,-40(fp)
 400b29c:	1880351e 	bne	r3,r2,400b374 <_dtoa_r+0xed4>
		{
		  if (d.d > 0.5 + eps.d)
 400b2a0:	e43fd517 	ldw	r16,-172(fp)
 400b2a4:	e47fd617 	ldw	r17,-168(fp)
 400b2a8:	e0bfd117 	ldw	r2,-188(fp)
 400b2ac:	e0ffd217 	ldw	r3,-184(fp)
 400b2b0:	000d883a 	mov	r6,zero
 400b2b4:	01cff834 	movhi	r7,16352
 400b2b8:	1009883a 	mov	r4,r2
 400b2bc:	180b883a 	mov	r5,r3
 400b2c0:	40154400 	call	4015440 <__adddf3>
 400b2c4:	1009883a 	mov	r4,r2
 400b2c8:	180b883a 	mov	r5,r3
 400b2cc:	2005883a 	mov	r2,r4
 400b2d0:	2807883a 	mov	r3,r5
 400b2d4:	100d883a 	mov	r6,r2
 400b2d8:	180f883a 	mov	r7,r3
 400b2dc:	8009883a 	mov	r4,r16
 400b2e0:	880b883a 	mov	r5,r17
 400b2e4:	401676c0 	call	401676c <__gedf2>
 400b2e8:	0080c316 	blt	zero,r2,400b5f8 <_dtoa_r+0x1158>
		    goto bump_up;
		  else if (d.d < 0.5 - eps.d)
 400b2ec:	e43fd517 	ldw	r16,-172(fp)
 400b2f0:	e47fd617 	ldw	r17,-168(fp)
 400b2f4:	e0bfd117 	ldw	r2,-188(fp)
 400b2f8:	e0ffd217 	ldw	r3,-184(fp)
 400b2fc:	100d883a 	mov	r6,r2
 400b300:	180f883a 	mov	r7,r3
 400b304:	0009883a 	mov	r4,zero
 400b308:	014ff834 	movhi	r5,16352
 400b30c:	40170f40 	call	40170f4 <__subdf3>
 400b310:	1009883a 	mov	r4,r2
 400b314:	180b883a 	mov	r5,r3
 400b318:	2005883a 	mov	r2,r4
 400b31c:	2807883a 	mov	r3,r5
 400b320:	100d883a 	mov	r6,r2
 400b324:	180f883a 	mov	r7,r3
 400b328:	8009883a 	mov	r4,r16
 400b32c:	880b883a 	mov	r5,r17
 400b330:	401685c0 	call	401685c <__ledf2>
 400b334:	10000116 	blt	r2,zero,400b33c <_dtoa_r+0xe9c>
		    {
		      while (*--s == '0');
		      s++;
		      goto ret1;
		    }
		  break;
 400b338:	00002206 	br	400b3c4 <_dtoa_r+0xf24>
		      while (*--s == '0');
 400b33c:	e0bfe317 	ldw	r2,-116(fp)
 400b340:	10bfffc4 	addi	r2,r2,-1
 400b344:	e0bfe315 	stw	r2,-116(fp)
 400b348:	e0bfe317 	ldw	r2,-116(fp)
 400b34c:	10800003 	ldbu	r2,0(r2)
 400b350:	10803fcc 	andi	r2,r2,255
 400b354:	1080201c 	xori	r2,r2,128
 400b358:	10bfe004 	addi	r2,r2,-128
 400b35c:	10800c20 	cmpeqi	r2,r2,48
 400b360:	103ff61e 	bne	r2,zero,400b33c <_dtoa_r+0xe9c>
		      s++;
 400b364:	e0bfe317 	ldw	r2,-116(fp)
 400b368:	10800044 	addi	r2,r2,1
 400b36c:	e0bfe315 	stw	r2,-116(fp)
		      goto ret1;
 400b370:	00033e06 	br	400c06c <_dtoa_r+0x1bcc>
	  for (i = 1;; i++, d.d *= 10.)
 400b374:	e0bff817 	ldw	r2,-32(fp)
 400b378:	10800044 	addi	r2,r2,1
 400b37c:	e0bff815 	stw	r2,-32(fp)
 400b380:	e0bfd517 	ldw	r2,-172(fp)
 400b384:	e0ffd617 	ldw	r3,-168(fp)
 400b388:	000d883a 	mov	r6,zero
 400b38c:	01d00934 	movhi	r7,16420
 400b390:	1009883a 	mov	r4,r2
 400b394:	180b883a 	mov	r5,r3
 400b398:	401694c0 	call	401694c <__muldf3>
 400b39c:	1009883a 	mov	r4,r2
 400b3a0:	180b883a 	mov	r5,r3
 400b3a4:	2005883a 	mov	r2,r4
 400b3a8:	2807883a 	mov	r3,r5
 400b3ac:	e0bfd515 	stw	r2,-172(fp)
 400b3b0:	e0ffd615 	stw	r3,-168(fp)
	      L = d.d;
 400b3b4:	003f9806 	br	400b218 <_dtoa_r+0xd78>
	    goto fast_failed;
 400b3b8:	0001883a 	nop
 400b3bc:	00000106 	br	400b3c4 <_dtoa_r+0xf24>
		break;
 400b3c0:	0001883a 	nop
	    }
#ifndef No_leftright
	}
#endif
    fast_failed:
      s = s0;
 400b3c4:	e0bfe017 	ldw	r2,-128(fp)
 400b3c8:	e0bfe315 	stw	r2,-116(fp)
      d.d = d2.d;
 400b3cc:	e0bfd317 	ldw	r2,-180(fp)
 400b3d0:	e0ffd417 	ldw	r3,-176(fp)
 400b3d4:	e0bfd515 	stw	r2,-172(fp)
 400b3d8:	e0ffd615 	stw	r3,-168(fp)
      k = k0;
 400b3dc:	e0bfdf17 	ldw	r2,-132(fp)
 400b3e0:	e0bff315 	stw	r2,-52(fp)
      ilim = ilim0;
 400b3e4:	e0bfde17 	ldw	r2,-136(fp)
 400b3e8:	e0bff615 	stw	r2,-40(fp)
    }

  /* Do we have a "small" integer? */

  if (be >= 0 && k <= Int_max)
 400b3ec:	e0bfd717 	ldw	r2,-164(fp)
 400b3f0:	1000bd16 	blt	r2,zero,400b6e8 <_dtoa_r+0x1248>
 400b3f4:	e0bff317 	ldw	r2,-52(fp)
 400b3f8:	108003c8 	cmpgei	r2,r2,15
 400b3fc:	1000ba1e 	bne	r2,zero,400b6e8 <_dtoa_r+0x1248>
    {
      /* Yes. */
      ds = tens[k];
 400b400:	e0bff317 	ldw	r2,-52(fp)
 400b404:	100690fa 	slli	r3,r2,3
 400b408:	008100b4 	movhi	r2,1026
 400b40c:	1885883a 	add	r2,r3,r2
 400b410:	10ab1d17 	ldw	r2,-21388(r2)
 400b414:	e0bfe415 	stw	r2,-112(fp)
 400b418:	008100b4 	movhi	r2,1026
 400b41c:	1885883a 	add	r2,r3,r2
 400b420:	10ab1e17 	ldw	r2,-21384(r2)
 400b424:	e0bfe515 	stw	r2,-108(fp)
      if (ndigits < 0 && ilim <= 0)
 400b428:	e0800217 	ldw	r2,8(fp)
 400b42c:	1000190e 	bge	r2,zero,400b494 <_dtoa_r+0xff4>
 400b430:	e0bff617 	ldw	r2,-40(fp)
 400b434:	00801716 	blt	zero,r2,400b494 <_dtoa_r+0xff4>
	{
	  S = mhi = 0;
 400b438:	e03fe715 	stw	zero,-100(fp)
 400b43c:	e0bfe717 	ldw	r2,-100(fp)
 400b440:	e0bfe615 	stw	r2,-104(fp)
	  if (ilim < 0 || d.d <= 5 * ds)
 400b444:	e0bff617 	ldw	r2,-40(fp)
 400b448:	1001c116 	blt	r2,zero,400bb50 <_dtoa_r+0x16b0>
 400b44c:	e43fd517 	ldw	r16,-172(fp)
 400b450:	e47fd617 	ldw	r17,-168(fp)
 400b454:	000d883a 	mov	r6,zero
 400b458:	01d00534 	movhi	r7,16404
 400b45c:	e13fe417 	ldw	r4,-112(fp)
 400b460:	e17fe517 	ldw	r5,-108(fp)
 400b464:	401694c0 	call	401694c <__muldf3>
 400b468:	1009883a 	mov	r4,r2
 400b46c:	180b883a 	mov	r5,r3
 400b470:	2005883a 	mov	r2,r4
 400b474:	2807883a 	mov	r3,r5
 400b478:	100d883a 	mov	r6,r2
 400b47c:	180f883a 	mov	r7,r3
 400b480:	8009883a 	mov	r4,r16
 400b484:	880b883a 	mov	r5,r17
 400b488:	401685c0 	call	401685c <__ledf2>
 400b48c:	0081b00e 	bge	zero,r2,400bb50 <_dtoa_r+0x16b0>
	    goto no_digits;
	  goto one_digit;
 400b490:	0001b906 	br	400bb78 <_dtoa_r+0x16d8>
	}
      for (i = 1;; i++)
 400b494:	00800044 	movi	r2,1
 400b498:	e0bff815 	stw	r2,-32(fp)
	{
	  L = d.d / ds;
 400b49c:	e0bfd517 	ldw	r2,-172(fp)
 400b4a0:	e0ffd617 	ldw	r3,-168(fp)
 400b4a4:	e1bfe417 	ldw	r6,-112(fp)
 400b4a8:	e1ffe517 	ldw	r7,-108(fp)
 400b4ac:	1009883a 	mov	r4,r2
 400b4b0:	180b883a 	mov	r5,r3
 400b4b4:	4015db80 	call	4015db8 <__divdf3>
 400b4b8:	1009883a 	mov	r4,r2
 400b4bc:	180b883a 	mov	r5,r3
 400b4c0:	2005883a 	mov	r2,r4
 400b4c4:	2807883a 	mov	r3,r5
 400b4c8:	1009883a 	mov	r4,r2
 400b4cc:	180b883a 	mov	r5,r3
 400b4d0:	4017a7c0 	call	4017a7c <__fixdfsi>
 400b4d4:	e0bfdc15 	stw	r2,-144(fp)
	  d.d -= L * ds;
 400b4d8:	e43fd517 	ldw	r16,-172(fp)
 400b4dc:	e47fd617 	ldw	r17,-168(fp)
 400b4e0:	e13fdc17 	ldw	r4,-144(fp)
 400b4e4:	4017afc0 	call	4017afc <__floatsidf>
 400b4e8:	1011883a 	mov	r8,r2
 400b4ec:	1813883a 	mov	r9,r3
 400b4f0:	e1bfe417 	ldw	r6,-112(fp)
 400b4f4:	e1ffe517 	ldw	r7,-108(fp)
 400b4f8:	4009883a 	mov	r4,r8
 400b4fc:	480b883a 	mov	r5,r9
 400b500:	401694c0 	call	401694c <__muldf3>
 400b504:	1009883a 	mov	r4,r2
 400b508:	180b883a 	mov	r5,r3
 400b50c:	2005883a 	mov	r2,r4
 400b510:	2807883a 	mov	r3,r5
 400b514:	100d883a 	mov	r6,r2
 400b518:	180f883a 	mov	r7,r3
 400b51c:	8009883a 	mov	r4,r16
 400b520:	880b883a 	mov	r5,r17
 400b524:	40170f40 	call	40170f4 <__subdf3>
 400b528:	1009883a 	mov	r4,r2
 400b52c:	180b883a 	mov	r5,r3
 400b530:	2005883a 	mov	r2,r4
 400b534:	2807883a 	mov	r3,r5
 400b538:	e0bfd515 	stw	r2,-172(fp)
 400b53c:	e0ffd615 	stw	r3,-168(fp)
	    {
	      L--;
	      d.d += ds;
	    }
#endif
	  *s++ = '0' + (int) L;
 400b540:	e0bfdc17 	ldw	r2,-144(fp)
 400b544:	10800c04 	addi	r2,r2,48
 400b548:	1009883a 	mov	r4,r2
 400b54c:	e0bfe317 	ldw	r2,-116(fp)
 400b550:	10c00044 	addi	r3,r2,1
 400b554:	e0ffe315 	stw	r3,-116(fp)
 400b558:	2007883a 	mov	r3,r4
 400b55c:	10c00005 	stb	r3,0(r2)
	  if (i == ilim)
 400b560:	e0fff817 	ldw	r3,-32(fp)
 400b564:	e0bff617 	ldw	r2,-40(fp)
 400b568:	1880421e 	bne	r3,r2,400b674 <_dtoa_r+0x11d4>
	    {
	      d.d += d.d;
 400b56c:	e0bfd517 	ldw	r2,-172(fp)
 400b570:	e0ffd617 	ldw	r3,-168(fp)
 400b574:	100d883a 	mov	r6,r2
 400b578:	180f883a 	mov	r7,r3
 400b57c:	1009883a 	mov	r4,r2
 400b580:	180b883a 	mov	r5,r3
 400b584:	40154400 	call	4015440 <__adddf3>
 400b588:	1009883a 	mov	r4,r2
 400b58c:	180b883a 	mov	r5,r3
 400b590:	2005883a 	mov	r2,r4
 400b594:	2807883a 	mov	r3,r5
 400b598:	e0bfd515 	stw	r2,-172(fp)
 400b59c:	e0ffd615 	stw	r3,-168(fp)
             if ((d.d > ds) || ((d.d == ds) && (L & 1)))
 400b5a0:	e0bfd517 	ldw	r2,-172(fp)
 400b5a4:	e0ffd617 	ldw	r3,-168(fp)
 400b5a8:	100d883a 	mov	r6,r2
 400b5ac:	180f883a 	mov	r7,r3
 400b5b0:	e13fe417 	ldw	r4,-112(fp)
 400b5b4:	e17fe517 	ldw	r5,-108(fp)
 400b5b8:	401685c0 	call	401685c <__ledf2>
 400b5bc:	10001016 	blt	r2,zero,400b600 <_dtoa_r+0x1160>
 400b5c0:	e0bfd517 	ldw	r2,-172(fp)
 400b5c4:	e0ffd617 	ldw	r3,-168(fp)
 400b5c8:	100d883a 	mov	r6,r2
 400b5cc:	180f883a 	mov	r7,r3
 400b5d0:	e13fe417 	ldw	r4,-112(fp)
 400b5d4:	e17fe517 	ldw	r5,-108(fp)
 400b5d8:	40166ec0 	call	40166ec <__eqdf2>
 400b5dc:	10003e1e 	bne	r2,zero,400b6d8 <_dtoa_r+0x1238>
 400b5e0:	e0bfdc17 	ldw	r2,-144(fp)
 400b5e4:	1080004c 	andi	r2,r2,1
 400b5e8:	10003b26 	beq	r2,zero,400b6d8 <_dtoa_r+0x1238>
		{
		bump_up:
 400b5ec:	00000406 	br	400b600 <_dtoa_r+0x1160>
		goto bump_up;
 400b5f0:	0001883a 	nop
 400b5f4:	00000e06 	br	400b630 <_dtoa_r+0x1190>
		    goto bump_up;
 400b5f8:	0001883a 	nop
 400b5fc:	00000c06 	br	400b630 <_dtoa_r+0x1190>
		bump_up:
 400b600:	0001883a 	nop
		  while (*--s == '9')
 400b604:	00000a06 	br	400b630 <_dtoa_r+0x1190>
		    if (s == s0)
 400b608:	e0ffe317 	ldw	r3,-116(fp)
 400b60c:	e0bfe017 	ldw	r2,-128(fp)
 400b610:	1880071e 	bne	r3,r2,400b630 <_dtoa_r+0x1190>
		      {
			k++;
 400b614:	e0bff317 	ldw	r2,-52(fp)
 400b618:	10800044 	addi	r2,r2,1
 400b61c:	e0bff315 	stw	r2,-52(fp)
			*s = '0';
 400b620:	e0bfe317 	ldw	r2,-116(fp)
 400b624:	00c00c04 	movi	r3,48
 400b628:	10c00005 	stb	r3,0(r2)
			break;
 400b62c:	00000a06 	br	400b658 <_dtoa_r+0x11b8>
		  while (*--s == '9')
 400b630:	e0bfe317 	ldw	r2,-116(fp)
 400b634:	10bfffc4 	addi	r2,r2,-1
 400b638:	e0bfe315 	stw	r2,-116(fp)
 400b63c:	e0bfe317 	ldw	r2,-116(fp)
 400b640:	10800003 	ldbu	r2,0(r2)
 400b644:	10803fcc 	andi	r2,r2,255
 400b648:	1080201c 	xori	r2,r2,128
 400b64c:	10bfe004 	addi	r2,r2,-128
 400b650:	10800e60 	cmpeqi	r2,r2,57
 400b654:	103fec1e 	bne	r2,zero,400b608 <_dtoa_r+0x1168>
		      }
		  ++*s++;
 400b658:	e0bfe317 	ldw	r2,-116(fp)
 400b65c:	10c00044 	addi	r3,r2,1
 400b660:	e0ffe315 	stw	r3,-116(fp)
 400b664:	10c00003 	ldbu	r3,0(r2)
 400b668:	18c00044 	addi	r3,r3,1
 400b66c:	10c00005 	stb	r3,0(r2)
		}
	      break;
 400b670:	00001906 	br	400b6d8 <_dtoa_r+0x1238>
	    }
	  if (!(d.d *= 10.))
 400b674:	e0bfd517 	ldw	r2,-172(fp)
 400b678:	e0ffd617 	ldw	r3,-168(fp)
 400b67c:	000d883a 	mov	r6,zero
 400b680:	01d00934 	movhi	r7,16420
 400b684:	1009883a 	mov	r4,r2
 400b688:	180b883a 	mov	r5,r3
 400b68c:	401694c0 	call	401694c <__muldf3>
 400b690:	1009883a 	mov	r4,r2
 400b694:	180b883a 	mov	r5,r3
 400b698:	2005883a 	mov	r2,r4
 400b69c:	2807883a 	mov	r3,r5
 400b6a0:	e0bfd515 	stw	r2,-172(fp)
 400b6a4:	e0ffd615 	stw	r3,-168(fp)
 400b6a8:	e0bfd517 	ldw	r2,-172(fp)
 400b6ac:	e0ffd617 	ldw	r3,-168(fp)
 400b6b0:	000d883a 	mov	r6,zero
 400b6b4:	000f883a 	mov	r7,zero
 400b6b8:	1009883a 	mov	r4,r2
 400b6bc:	180b883a 	mov	r5,r3
 400b6c0:	40166ec0 	call	40166ec <__eqdf2>
 400b6c4:	10000626 	beq	r2,zero,400b6e0 <_dtoa_r+0x1240>
      for (i = 1;; i++)
 400b6c8:	e0bff817 	ldw	r2,-32(fp)
 400b6cc:	10800044 	addi	r2,r2,1
 400b6d0:	e0bff815 	stw	r2,-32(fp)
	  L = d.d / ds;
 400b6d4:	003f7106 	br	400b49c <_dtoa_r+0xffc>
	      break;
 400b6d8:	0001883a 	nop
 400b6dc:	00026306 	br	400c06c <_dtoa_r+0x1bcc>
	    break;
 400b6e0:	0001883a 	nop
	}
      goto ret1;
 400b6e4:	00026106 	br	400c06c <_dtoa_r+0x1bcc>
    }

  m2 = b2;
 400b6e8:	e0bffb17 	ldw	r2,-20(fp)
 400b6ec:	e0bff015 	stw	r2,-64(fp)
  m5 = b5;
 400b6f0:	e0bffa17 	ldw	r2,-24(fp)
 400b6f4:	e0bfef15 	stw	r2,-68(fp)
  mhi = mlo = 0;
 400b6f8:	e03fe815 	stw	zero,-96(fp)
 400b6fc:	e0bfe817 	ldw	r2,-96(fp)
 400b700:	e0bfe715 	stw	r2,-100(fp)
  if (leftright)
 400b704:	e0bff117 	ldw	r2,-60(fp)
 400b708:	10003a26 	beq	r2,zero,400b7f4 <_dtoa_r+0x1354>
    {
      if (mode < 2)
 400b70c:	e0bfcd17 	ldw	r2,-204(fp)
 400b710:	10800088 	cmpgei	r2,r2,2
 400b714:	10000a1e 	bne	r2,zero,400b740 <_dtoa_r+0x12a0>
	{
	  i =
#ifndef Sudden_Underflow
	    denorm ? be + (Bias + (P - 1) - 1 + 1) :
 400b718:	e0bfea17 	ldw	r2,-88(fp)
 400b71c:	10000326 	beq	r2,zero,400b72c <_dtoa_r+0x128c>
 400b720:	e0bfd717 	ldw	r2,-164(fp)
 400b724:	10810cc4 	addi	r2,r2,1075
 400b728:	00000306 	br	400b738 <_dtoa_r+0x1298>
#endif
#ifdef IBM
	    1 + 4 * P - 3 - bbits + ((bbits + be - 1) & 3);
#else
	    1 + P - bbits;
 400b72c:	e0bfd817 	ldw	r2,-160(fp)
	    denorm ? be + (Bias + (P - 1) - 1 + 1) :
 400b730:	00c00d84 	movi	r3,54
 400b734:	1885c83a 	sub	r2,r3,r2
	  i =
 400b738:	e0bff815 	stw	r2,-32(fp)
 400b73c:	00002106 	br	400b7c4 <_dtoa_r+0x1324>
#endif
	}
      else
	{
	  j = ilim - 1;
 400b740:	e0bff617 	ldw	r2,-40(fp)
 400b744:	10bfffc4 	addi	r2,r2,-1
 400b748:	e0bff415 	stw	r2,-48(fp)
	  if (m5 >= j)
 400b74c:	e0ffef17 	ldw	r3,-68(fp)
 400b750:	e0bff417 	ldw	r2,-48(fp)
 400b754:	18800516 	blt	r3,r2,400b76c <_dtoa_r+0x12cc>
	    m5 -= j;
 400b758:	e0ffef17 	ldw	r3,-68(fp)
 400b75c:	e0bff417 	ldw	r2,-48(fp)
 400b760:	1885c83a 	sub	r2,r3,r2
 400b764:	e0bfef15 	stw	r2,-68(fp)
 400b768:	00000d06 	br	400b7a0 <_dtoa_r+0x1300>
	  else
	    {
	      s5 += j -= m5;
 400b76c:	e0fff417 	ldw	r3,-48(fp)
 400b770:	e0bfef17 	ldw	r2,-68(fp)
 400b774:	1885c83a 	sub	r2,r3,r2
 400b778:	e0bff415 	stw	r2,-48(fp)
 400b77c:	e0bff417 	ldw	r2,-48(fp)
 400b780:	e0ffed17 	ldw	r3,-76(fp)
 400b784:	1885883a 	add	r2,r3,r2
 400b788:	e0bfed15 	stw	r2,-76(fp)
	      b5 += j;
 400b78c:	e0fffa17 	ldw	r3,-24(fp)
 400b790:	e0bff417 	ldw	r2,-48(fp)
 400b794:	1885883a 	add	r2,r3,r2
 400b798:	e0bffa15 	stw	r2,-24(fp)
	      m5 = 0;
 400b79c:	e03fef15 	stw	zero,-68(fp)
	    }
	  if ((i = ilim) < 0)
 400b7a0:	e0bff617 	ldw	r2,-40(fp)
 400b7a4:	e0bff815 	stw	r2,-32(fp)
 400b7a8:	e0bff817 	ldw	r2,-32(fp)
 400b7ac:	1000050e 	bge	r2,zero,400b7c4 <_dtoa_r+0x1324>
	    {
	      m2 -= i;
 400b7b0:	e0fff017 	ldw	r3,-64(fp)
 400b7b4:	e0bff817 	ldw	r2,-32(fp)
 400b7b8:	1885c83a 	sub	r2,r3,r2
 400b7bc:	e0bff015 	stw	r2,-64(fp)
	      i = 0;
 400b7c0:	e03ff815 	stw	zero,-32(fp)
	    }
	}
      b2 += i;
 400b7c4:	e0fffb17 	ldw	r3,-20(fp)
 400b7c8:	e0bff817 	ldw	r2,-32(fp)
 400b7cc:	1885883a 	add	r2,r3,r2
 400b7d0:	e0bffb15 	stw	r2,-20(fp)
      s2 += i;
 400b7d4:	e0ffee17 	ldw	r3,-72(fp)
 400b7d8:	e0bff817 	ldw	r2,-32(fp)
 400b7dc:	1885883a 	add	r2,r3,r2
 400b7e0:	e0bfee15 	stw	r2,-72(fp)
      mhi = i2b (ptr, 1);
 400b7e4:	01400044 	movi	r5,1
 400b7e8:	e13fd017 	ldw	r4,-192(fp)
 400b7ec:	400f7040 	call	400f704 <__i2b>
 400b7f0:	e0bfe715 	stw	r2,-100(fp)
    }
  if (m2 > 0 && s2 > 0)
 400b7f4:	e0bff017 	ldw	r2,-64(fp)
 400b7f8:	0080130e 	bge	zero,r2,400b848 <_dtoa_r+0x13a8>
 400b7fc:	e0bfee17 	ldw	r2,-72(fp)
 400b800:	0080110e 	bge	zero,r2,400b848 <_dtoa_r+0x13a8>
    {
      i = m2 < s2 ? m2 : s2;
 400b804:	e0fff017 	ldw	r3,-64(fp)
 400b808:	e0bfee17 	ldw	r2,-72(fp)
 400b80c:	1880010e 	bge	r3,r2,400b814 <_dtoa_r+0x1374>
 400b810:	1805883a 	mov	r2,r3
 400b814:	e0bff815 	stw	r2,-32(fp)
      b2 -= i;
 400b818:	e0fffb17 	ldw	r3,-20(fp)
 400b81c:	e0bff817 	ldw	r2,-32(fp)
 400b820:	1885c83a 	sub	r2,r3,r2
 400b824:	e0bffb15 	stw	r2,-20(fp)
      m2 -= i;
 400b828:	e0fff017 	ldw	r3,-64(fp)
 400b82c:	e0bff817 	ldw	r2,-32(fp)
 400b830:	1885c83a 	sub	r2,r3,r2
 400b834:	e0bff015 	stw	r2,-64(fp)
      s2 -= i;
 400b838:	e0ffee17 	ldw	r3,-72(fp)
 400b83c:	e0bff817 	ldw	r2,-32(fp)
 400b840:	1885c83a 	sub	r2,r3,r2
 400b844:	e0bfee15 	stw	r2,-72(fp)
    }
  if (b5 > 0)
 400b848:	e0bffa17 	ldw	r2,-24(fp)
 400b84c:	0080240e 	bge	zero,r2,400b8e0 <_dtoa_r+0x1440>
    {
      if (leftright)
 400b850:	e0bff117 	ldw	r2,-60(fp)
 400b854:	10001d26 	beq	r2,zero,400b8cc <_dtoa_r+0x142c>
	{
	  if (m5 > 0)
 400b858:	e0bfef17 	ldw	r2,-68(fp)
 400b85c:	00800f0e 	bge	zero,r2,400b89c <_dtoa_r+0x13fc>
	    {
	      mhi = pow5mult (ptr, mhi, m5);
 400b860:	e1bfef17 	ldw	r6,-68(fp)
 400b864:	e17fe717 	ldw	r5,-100(fp)
 400b868:	e13fd017 	ldw	r4,-192(fp)
 400b86c:	400fb840 	call	400fb84 <__pow5mult>
 400b870:	e0bfe715 	stw	r2,-100(fp)
	      b1 = mult (ptr, mhi, b);
 400b874:	e1bfe917 	ldw	r6,-92(fp)
 400b878:	e17fe717 	ldw	r5,-100(fp)
 400b87c:	e13fd017 	ldw	r4,-192(fp)
 400b880:	400f7880 	call	400f788 <__multiply>
 400b884:	e0bfdb15 	stw	r2,-148(fp)
	      Bfree (ptr, b);
 400b888:	e17fe917 	ldw	r5,-92(fp)
 400b88c:	e13fd017 	ldw	r4,-192(fp)
 400b890:	400f1900 	call	400f190 <_Bfree>
	      b = b1;
 400b894:	e0bfdb17 	ldw	r2,-148(fp)
 400b898:	e0bfe915 	stw	r2,-92(fp)
	    }
         if ((j = b5 - m5) != 0)
 400b89c:	e0fffa17 	ldw	r3,-24(fp)
 400b8a0:	e0bfef17 	ldw	r2,-68(fp)
 400b8a4:	1885c83a 	sub	r2,r3,r2
 400b8a8:	e0bff415 	stw	r2,-48(fp)
 400b8ac:	e0bff417 	ldw	r2,-48(fp)
 400b8b0:	10000b26 	beq	r2,zero,400b8e0 <_dtoa_r+0x1440>
	    b = pow5mult (ptr, b, j);
 400b8b4:	e1bff417 	ldw	r6,-48(fp)
 400b8b8:	e17fe917 	ldw	r5,-92(fp)
 400b8bc:	e13fd017 	ldw	r4,-192(fp)
 400b8c0:	400fb840 	call	400fb84 <__pow5mult>
 400b8c4:	e0bfe915 	stw	r2,-92(fp)
 400b8c8:	00000506 	br	400b8e0 <_dtoa_r+0x1440>
	}
      else
	b = pow5mult (ptr, b, b5);
 400b8cc:	e1bffa17 	ldw	r6,-24(fp)
 400b8d0:	e17fe917 	ldw	r5,-92(fp)
 400b8d4:	e13fd017 	ldw	r4,-192(fp)
 400b8d8:	400fb840 	call	400fb84 <__pow5mult>
 400b8dc:	e0bfe915 	stw	r2,-92(fp)
    }
  S = i2b (ptr, 1);
 400b8e0:	01400044 	movi	r5,1
 400b8e4:	e13fd017 	ldw	r4,-192(fp)
 400b8e8:	400f7040 	call	400f704 <__i2b>
 400b8ec:	e0bfe615 	stw	r2,-104(fp)
  if (s5 > 0)
 400b8f0:	e0bfed17 	ldw	r2,-76(fp)
 400b8f4:	0080050e 	bge	zero,r2,400b90c <_dtoa_r+0x146c>
    S = pow5mult (ptr, S, s5);
 400b8f8:	e1bfed17 	ldw	r6,-76(fp)
 400b8fc:	e17fe617 	ldw	r5,-104(fp)
 400b900:	e13fd017 	ldw	r4,-192(fp)
 400b904:	400fb840 	call	400fb84 <__pow5mult>
 400b908:	e0bfe615 	stw	r2,-104(fp)

  /* Check for special case that d is a normalized power of 2. */

  spec_case = 0;
 400b90c:	e03fec15 	stw	zero,-80(fp)
  if (mode < 2)
 400b910:	e0bfcd17 	ldw	r2,-204(fp)
 400b914:	10800088 	cmpgei	r2,r2,2
 400b918:	1000121e 	bne	r2,zero,400b964 <_dtoa_r+0x14c4>
    {
      if (!word1 (d) && !(word0 (d) & Bndry_mask)
 400b91c:	e0bfd517 	ldw	r2,-172(fp)
 400b920:	1000101e 	bne	r2,zero,400b964 <_dtoa_r+0x14c4>
 400b924:	e0ffd617 	ldw	r3,-168(fp)
 400b928:	00800434 	movhi	r2,16
 400b92c:	10bfffc4 	addi	r2,r2,-1
 400b930:	1884703a 	and	r2,r3,r2
 400b934:	10000b1e 	bne	r2,zero,400b964 <_dtoa_r+0x14c4>
#ifndef Sudden_Underflow
	  && word0 (d) & Exp_mask
 400b938:	e0bfd617 	ldw	r2,-168(fp)
 400b93c:	109ffc2c 	andhi	r2,r2,32752
 400b940:	10000826 	beq	r2,zero,400b964 <_dtoa_r+0x14c4>
#endif
	)
	{
	  /* The special case */
	  b2 += Log2P;
 400b944:	e0bffb17 	ldw	r2,-20(fp)
 400b948:	10800044 	addi	r2,r2,1
 400b94c:	e0bffb15 	stw	r2,-20(fp)
	  s2 += Log2P;
 400b950:	e0bfee17 	ldw	r2,-72(fp)
 400b954:	10800044 	addi	r2,r2,1
 400b958:	e0bfee15 	stw	r2,-72(fp)
	  spec_case = 1;
 400b95c:	00800044 	movi	r2,1
 400b960:	e0bfec15 	stw	r2,-80(fp)
   * and for all and pass them and a shift to quorem, so it
   * can do shifts and ors to compute the numerator for q.
   */

#ifdef Pack_32
  if ((i = ((s5 ? 32 - hi0bits (S->_x[S->_wds - 1]) : 1) + s2) & 0x1f) != 0)
 400b964:	e0bfed17 	ldw	r2,-76(fp)
 400b968:	10000e26 	beq	r2,zero,400b9a4 <_dtoa_r+0x1504>
 400b96c:	e0bfe617 	ldw	r2,-104(fp)
 400b970:	10800417 	ldw	r2,16(r2)
 400b974:	10bfffc4 	addi	r2,r2,-1
 400b978:	e0ffe617 	ldw	r3,-104(fp)
 400b97c:	10800144 	addi	r2,r2,5
 400b980:	100490ba 	slli	r2,r2,2
 400b984:	1885883a 	add	r2,r3,r2
 400b988:	10800017 	ldw	r2,0(r2)
 400b98c:	1009883a 	mov	r4,r2
 400b990:	400f58c0 	call	400f58c <__hi0bits>
 400b994:	1007883a 	mov	r3,r2
 400b998:	00800804 	movi	r2,32
 400b99c:	10c5c83a 	sub	r2,r2,r3
 400b9a0:	00000106 	br	400b9a8 <_dtoa_r+0x1508>
 400b9a4:	00800044 	movi	r2,1
 400b9a8:	e0ffee17 	ldw	r3,-72(fp)
 400b9ac:	10c5883a 	add	r2,r2,r3
 400b9b0:	108007cc 	andi	r2,r2,31
 400b9b4:	e0bff815 	stw	r2,-32(fp)
 400b9b8:	e0bff817 	ldw	r2,-32(fp)
 400b9bc:	10000426 	beq	r2,zero,400b9d0 <_dtoa_r+0x1530>
    i = 32 - i;
 400b9c0:	00c00804 	movi	r3,32
 400b9c4:	e0bff817 	ldw	r2,-32(fp)
 400b9c8:	1885c83a 	sub	r2,r3,r2
 400b9cc:	e0bff815 	stw	r2,-32(fp)
#else
  if ((i = ((s5 ? 32 - hi0bits (S->_x[S->_wds - 1]) : 1) + s2) & 0xf) != 0)
    i = 16 - i;
#endif
  if (i > 4)
 400b9d0:	e0bff817 	ldw	r2,-32(fp)
 400b9d4:	10800150 	cmplti	r2,r2,5
 400b9d8:	1000101e 	bne	r2,zero,400ba1c <_dtoa_r+0x157c>
    {
      i -= 4;
 400b9dc:	e0bff817 	ldw	r2,-32(fp)
 400b9e0:	10bfff04 	addi	r2,r2,-4
 400b9e4:	e0bff815 	stw	r2,-32(fp)
      b2 += i;
 400b9e8:	e0fffb17 	ldw	r3,-20(fp)
 400b9ec:	e0bff817 	ldw	r2,-32(fp)
 400b9f0:	1885883a 	add	r2,r3,r2
 400b9f4:	e0bffb15 	stw	r2,-20(fp)
      m2 += i;
 400b9f8:	e0fff017 	ldw	r3,-64(fp)
 400b9fc:	e0bff817 	ldw	r2,-32(fp)
 400ba00:	1885883a 	add	r2,r3,r2
 400ba04:	e0bff015 	stw	r2,-64(fp)
      s2 += i;
 400ba08:	e0ffee17 	ldw	r3,-72(fp)
 400ba0c:	e0bff817 	ldw	r2,-32(fp)
 400ba10:	1885883a 	add	r2,r3,r2
 400ba14:	e0bfee15 	stw	r2,-72(fp)
 400ba18:	00001206 	br	400ba64 <_dtoa_r+0x15c4>
    }
  else if (i < 4)
 400ba1c:	e0bff817 	ldw	r2,-32(fp)
 400ba20:	10800108 	cmpgei	r2,r2,4
 400ba24:	10000f1e 	bne	r2,zero,400ba64 <_dtoa_r+0x15c4>
    {
      i += 28;
 400ba28:	e0bff817 	ldw	r2,-32(fp)
 400ba2c:	10800704 	addi	r2,r2,28
 400ba30:	e0bff815 	stw	r2,-32(fp)
      b2 += i;
 400ba34:	e0fffb17 	ldw	r3,-20(fp)
 400ba38:	e0bff817 	ldw	r2,-32(fp)
 400ba3c:	1885883a 	add	r2,r3,r2
 400ba40:	e0bffb15 	stw	r2,-20(fp)
      m2 += i;
 400ba44:	e0fff017 	ldw	r3,-64(fp)
 400ba48:	e0bff817 	ldw	r2,-32(fp)
 400ba4c:	1885883a 	add	r2,r3,r2
 400ba50:	e0bff015 	stw	r2,-64(fp)
      s2 += i;
 400ba54:	e0ffee17 	ldw	r3,-72(fp)
 400ba58:	e0bff817 	ldw	r2,-32(fp)
 400ba5c:	1885883a 	add	r2,r3,r2
 400ba60:	e0bfee15 	stw	r2,-72(fp)
    }
  if (b2 > 0)
 400ba64:	e0bffb17 	ldw	r2,-20(fp)
 400ba68:	0080050e 	bge	zero,r2,400ba80 <_dtoa_r+0x15e0>
    b = lshift (ptr, b, b2);
 400ba6c:	e1bffb17 	ldw	r6,-20(fp)
 400ba70:	e17fe917 	ldw	r5,-92(fp)
 400ba74:	e13fd017 	ldw	r4,-192(fp)
 400ba78:	400fcf40 	call	400fcf4 <__lshift>
 400ba7c:	e0bfe915 	stw	r2,-92(fp)
  if (s2 > 0)
 400ba80:	e0bfee17 	ldw	r2,-72(fp)
 400ba84:	0080050e 	bge	zero,r2,400ba9c <_dtoa_r+0x15fc>
    S = lshift (ptr, S, s2);
 400ba88:	e1bfee17 	ldw	r6,-72(fp)
 400ba8c:	e17fe617 	ldw	r5,-104(fp)
 400ba90:	e13fd017 	ldw	r4,-192(fp)
 400ba94:	400fcf40 	call	400fcf4 <__lshift>
 400ba98:	e0bfe615 	stw	r2,-104(fp)
  if (k_check)
 400ba9c:	e0bff217 	ldw	r2,-56(fp)
 400baa0:	10001726 	beq	r2,zero,400bb00 <_dtoa_r+0x1660>
    {
      if (cmp (b, S) < 0)
 400baa4:	e17fe617 	ldw	r5,-104(fp)
 400baa8:	e13fe917 	ldw	r4,-92(fp)
 400baac:	400ff100 	call	400ff10 <__mcmp>
 400bab0:	1000130e 	bge	r2,zero,400bb00 <_dtoa_r+0x1660>
	{
	  k--;
 400bab4:	e0bff317 	ldw	r2,-52(fp)
 400bab8:	10bfffc4 	addi	r2,r2,-1
 400babc:	e0bff315 	stw	r2,-52(fp)
	  b = multadd (ptr, b, 10, 0);	/* we botched the k estimate */
 400bac0:	000f883a 	mov	r7,zero
 400bac4:	01800284 	movi	r6,10
 400bac8:	e17fe917 	ldw	r5,-92(fp)
 400bacc:	e13fd017 	ldw	r4,-192(fp)
 400bad0:	400f2040 	call	400f204 <__multadd>
 400bad4:	e0bfe915 	stw	r2,-92(fp)
	  if (leftright)
 400bad8:	e0bff117 	ldw	r2,-60(fp)
 400badc:	10000626 	beq	r2,zero,400baf8 <_dtoa_r+0x1658>
	    mhi = multadd (ptr, mhi, 10, 0);
 400bae0:	000f883a 	mov	r7,zero
 400bae4:	01800284 	movi	r6,10
 400bae8:	e17fe717 	ldw	r5,-100(fp)
 400baec:	e13fd017 	ldw	r4,-192(fp)
 400baf0:	400f2040 	call	400f204 <__multadd>
 400baf4:	e0bfe715 	stw	r2,-100(fp)
	  ilim = ilim1;
 400baf8:	e0bff517 	ldw	r2,-44(fp)
 400bafc:	e0bff615 	stw	r2,-40(fp)
	}
    }
  if (ilim <= 0 && mode > 2)
 400bb00:	e0bff617 	ldw	r2,-40(fp)
 400bb04:	00802516 	blt	zero,r2,400bb9c <_dtoa_r+0x16fc>
 400bb08:	e0bfcd17 	ldw	r2,-204(fp)
 400bb0c:	108000d0 	cmplti	r2,r2,3
 400bb10:	1000221e 	bne	r2,zero,400bb9c <_dtoa_r+0x16fc>
    {
      if (ilim < 0 || cmp (b, S = multadd (ptr, S, 5, 0)) <= 0)
 400bb14:	e0bff617 	ldw	r2,-40(fp)
 400bb18:	10000f16 	blt	r2,zero,400bb58 <_dtoa_r+0x16b8>
 400bb1c:	000f883a 	mov	r7,zero
 400bb20:	01800144 	movi	r6,5
 400bb24:	e17fe617 	ldw	r5,-104(fp)
 400bb28:	e13fd017 	ldw	r4,-192(fp)
 400bb2c:	400f2040 	call	400f204 <__multadd>
 400bb30:	e0bfe615 	stw	r2,-104(fp)
 400bb34:	e17fe617 	ldw	r5,-104(fp)
 400bb38:	e13fe917 	ldw	r4,-92(fp)
 400bb3c:	400ff100 	call	400ff10 <__mcmp>
 400bb40:	00800c16 	blt	zero,r2,400bb74 <_dtoa_r+0x16d4>
	{
	  /* no digits, fcvt style */
	no_digits:
 400bb44:	00000406 	br	400bb58 <_dtoa_r+0x16b8>
	    goto no_digits;
 400bb48:	0001883a 	nop
 400bb4c:	00000306 	br	400bb5c <_dtoa_r+0x16bc>
	    goto no_digits;
 400bb50:	0001883a 	nop
 400bb54:	00000106 	br	400bb5c <_dtoa_r+0x16bc>
	no_digits:
 400bb58:	0001883a 	nop
	  k = -1 - ndigits;
 400bb5c:	e0800217 	ldw	r2,8(fp)
 400bb60:	0084303a 	nor	r2,zero,r2
 400bb64:	e0bff315 	stw	r2,-52(fp)
	  goto ret;
 400bb68:	00012c06 	br	400c01c <_dtoa_r+0x1b7c>
	    goto one_digit;
 400bb6c:	0001883a 	nop
 400bb70:	00000106 	br	400bb78 <_dtoa_r+0x16d8>
	}
    one_digit:
 400bb74:	0001883a 	nop
      *s++ = '1';
 400bb78:	e0bfe317 	ldw	r2,-116(fp)
 400bb7c:	10c00044 	addi	r3,r2,1
 400bb80:	e0ffe315 	stw	r3,-116(fp)
 400bb84:	00c00c44 	movi	r3,49
 400bb88:	10c00005 	stb	r3,0(r2)
      k++;
 400bb8c:	e0bff317 	ldw	r2,-52(fp)
 400bb90:	10800044 	addi	r2,r2,1
 400bb94:	e0bff315 	stw	r2,-52(fp)
      goto ret;
 400bb98:	00012006 	br	400c01c <_dtoa_r+0x1b7c>
    }
  if (leftright)
 400bb9c:	e0bff117 	ldw	r2,-60(fp)
 400bba0:	1000c626 	beq	r2,zero,400bebc <_dtoa_r+0x1a1c>
    {
      if (m2 > 0)
 400bba4:	e0bff017 	ldw	r2,-64(fp)
 400bba8:	0080050e 	bge	zero,r2,400bbc0 <_dtoa_r+0x1720>
	mhi = lshift (ptr, mhi, m2);
 400bbac:	e1bff017 	ldw	r6,-64(fp)
 400bbb0:	e17fe717 	ldw	r5,-100(fp)
 400bbb4:	e13fd017 	ldw	r4,-192(fp)
 400bbb8:	400fcf40 	call	400fcf4 <__lshift>
 400bbbc:	e0bfe715 	stw	r2,-100(fp)

      /* Compute mlo -- check for special case
       * that d is a normalized power of 2.
       */

      mlo = mhi;
 400bbc0:	e0bfe717 	ldw	r2,-100(fp)
 400bbc4:	e0bfe815 	stw	r2,-96(fp)
      if (spec_case)
 400bbc8:	e0bfec17 	ldw	r2,-80(fp)
 400bbcc:	10002226 	beq	r2,zero,400bc58 <_dtoa_r+0x17b8>
	{
	  mhi = eBalloc (ptr, mhi->_k);
 400bbd0:	e0bfe717 	ldw	r2,-100(fp)
 400bbd4:	10800117 	ldw	r2,4(r2)
 400bbd8:	100b883a 	mov	r5,r2
 400bbdc:	e13fd017 	ldw	r4,-192(fp)
 400bbe0:	400f06c0 	call	400f06c <_Balloc>
 400bbe4:	e0bfda15 	stw	r2,-152(fp)
 400bbe8:	e0bfda17 	ldw	r2,-152(fp)
 400bbec:	1000071e 	bne	r2,zero,400bc0c <_dtoa_r+0x176c>
 400bbf0:	01c100b4 	movhi	r7,1026
 400bbf4:	39eae504 	addi	r7,r7,-21612
 400bbf8:	000d883a 	mov	r6,zero
 400bbfc:	0140ba84 	movi	r5,746
 400bc00:	010100b4 	movhi	r4,1026
 400bc04:	212aea04 	addi	r4,r4,-21592
 400bc08:	40130ac0 	call	40130ac <__assert_func>
 400bc0c:	e0bfda17 	ldw	r2,-152(fp)
 400bc10:	e0bfe715 	stw	r2,-100(fp)
	  Bcopy (mhi, mlo);
 400bc14:	e0bfe717 	ldw	r2,-100(fp)
 400bc18:	10c00304 	addi	r3,r2,12
 400bc1c:	e0bfe817 	ldw	r2,-96(fp)
 400bc20:	11000304 	addi	r4,r2,12
 400bc24:	e0bfe817 	ldw	r2,-96(fp)
 400bc28:	10800417 	ldw	r2,16(r2)
 400bc2c:	10800084 	addi	r2,r2,2
 400bc30:	100490ba 	slli	r2,r2,2
 400bc34:	100d883a 	mov	r6,r2
 400bc38:	200b883a 	mov	r5,r4
 400bc3c:	1809883a 	mov	r4,r3
 400bc40:	40073000 	call	4007300 <memcpy>
	  mhi = lshift (ptr, mhi, Log2P);
 400bc44:	01800044 	movi	r6,1
 400bc48:	e17fe717 	ldw	r5,-100(fp)
 400bc4c:	e13fd017 	ldw	r4,-192(fp)
 400bc50:	400fcf40 	call	400fcf4 <__lshift>
 400bc54:	e0bfe715 	stw	r2,-100(fp)
	}

      for (i = 1;; i++)
 400bc58:	00800044 	movi	r2,1
 400bc5c:	e0bff815 	stw	r2,-32(fp)
	{
	  dig = quorem (b, S) + '0';
 400bc60:	e17fe617 	ldw	r5,-104(fp)
 400bc64:	e13fe917 	ldw	r4,-92(fp)
 400bc68:	400a0ec0 	call	400a0ec <quorem>
 400bc6c:	10800c04 	addi	r2,r2,48
 400bc70:	e0bff915 	stw	r2,-28(fp)
	  /* Do we yet have the shortest decimal string
	   * that will round to d?
	   */
	  j = cmp (b, mlo);
 400bc74:	e17fe817 	ldw	r5,-96(fp)
 400bc78:	e13fe917 	ldw	r4,-92(fp)
 400bc7c:	400ff100 	call	400ff10 <__mcmp>
 400bc80:	e0bff415 	stw	r2,-48(fp)
	  delta = diff (ptr, S, mhi);
 400bc84:	e1bfe717 	ldw	r6,-100(fp)
 400bc88:	e17fe617 	ldw	r5,-104(fp)
 400bc8c:	e13fd017 	ldw	r4,-192(fp)
 400bc90:	40100140 	call	4010014 <__mdiff>
 400bc94:	e0bfd915 	stw	r2,-156(fp)
	  j1 = delta->_sign ? 1 : cmp (b, delta);
 400bc98:	e0bfd917 	ldw	r2,-156(fp)
 400bc9c:	10800317 	ldw	r2,12(r2)
 400bca0:	1000041e 	bne	r2,zero,400bcb4 <_dtoa_r+0x1814>
 400bca4:	e17fd917 	ldw	r5,-156(fp)
 400bca8:	e13fe917 	ldw	r4,-92(fp)
 400bcac:	400ff100 	call	400ff10 <__mcmp>
 400bcb0:	00000106 	br	400bcb8 <_dtoa_r+0x1818>
 400bcb4:	00800044 	movi	r2,1
 400bcb8:	e0bfdd15 	stw	r2,-140(fp)
	  Bfree (ptr, delta);
 400bcbc:	e17fd917 	ldw	r5,-156(fp)
 400bcc0:	e13fd017 	ldw	r4,-192(fp)
 400bcc4:	400f1900 	call	400f190 <_Bfree>
#ifndef ROUND_BIASED
	  if (j1 == 0 && !mode && !(word1 (d) & 1))
 400bcc8:	e0bfdd17 	ldw	r2,-140(fp)
 400bccc:	1000131e 	bne	r2,zero,400bd1c <_dtoa_r+0x187c>
 400bcd0:	e0bfcd17 	ldw	r2,-204(fp)
 400bcd4:	1000111e 	bne	r2,zero,400bd1c <_dtoa_r+0x187c>
 400bcd8:	e0bfd517 	ldw	r2,-172(fp)
 400bcdc:	1080004c 	andi	r2,r2,1
 400bce0:	10000e1e 	bne	r2,zero,400bd1c <_dtoa_r+0x187c>
	    {
	      if (dig == '9')
 400bce4:	e0bff917 	ldw	r2,-28(fp)
 400bce8:	10800e58 	cmpnei	r2,r2,57
 400bcec:	10003726 	beq	r2,zero,400bdcc <_dtoa_r+0x192c>
		goto round_9_up;
	      if (j > 0)
 400bcf0:	e0bff417 	ldw	r2,-48(fp)
 400bcf4:	0080030e 	bge	zero,r2,400bd04 <_dtoa_r+0x1864>
		dig++;
 400bcf8:	e0bff917 	ldw	r2,-28(fp)
 400bcfc:	10800044 	addi	r2,r2,1
 400bd00:	e0bff915 	stw	r2,-28(fp)
	      *s++ = dig;
 400bd04:	e0bfe317 	ldw	r2,-116(fp)
 400bd08:	10c00044 	addi	r3,r2,1
 400bd0c:	e0ffe315 	stw	r3,-116(fp)
 400bd10:	e0fff917 	ldw	r3,-28(fp)
 400bd14:	10c00005 	stb	r3,0(r2)
	      goto ret;
 400bd18:	0000c006 	br	400c01c <_dtoa_r+0x1b7c>
	    }
#endif
         if ((j < 0) || ((j == 0) && !mode
 400bd1c:	e0bff417 	ldw	r2,-48(fp)
 400bd20:	10000716 	blt	r2,zero,400bd40 <_dtoa_r+0x18a0>
 400bd24:	e0bff417 	ldw	r2,-48(fp)
 400bd28:	1000221e 	bne	r2,zero,400bdb4 <_dtoa_r+0x1914>
 400bd2c:	e0bfcd17 	ldw	r2,-204(fp)
 400bd30:	1000201e 	bne	r2,zero,400bdb4 <_dtoa_r+0x1914>
#ifndef ROUND_BIASED
	      && !(word1 (d) & 1)
 400bd34:	e0bfd517 	ldw	r2,-172(fp)
 400bd38:	1080004c 	andi	r2,r2,1
 400bd3c:	10001d1e 	bne	r2,zero,400bdb4 <_dtoa_r+0x1914>
#endif
           ))
	    {
	      if (j1 > 0)
 400bd40:	e0bfdd17 	ldw	r2,-140(fp)
 400bd44:	0080150e 	bge	zero,r2,400bd9c <_dtoa_r+0x18fc>
		{
		  b = lshift (ptr, b, 1);
 400bd48:	01800044 	movi	r6,1
 400bd4c:	e17fe917 	ldw	r5,-92(fp)
 400bd50:	e13fd017 	ldw	r4,-192(fp)
 400bd54:	400fcf40 	call	400fcf4 <__lshift>
 400bd58:	e0bfe915 	stw	r2,-92(fp)
		  j1 = cmp (b, S);
 400bd5c:	e17fe617 	ldw	r5,-104(fp)
 400bd60:	e13fe917 	ldw	r4,-92(fp)
 400bd64:	400ff100 	call	400ff10 <__mcmp>
 400bd68:	e0bfdd15 	stw	r2,-140(fp)
                 if (((j1 > 0) || ((j1 == 0) && (dig & 1)))
 400bd6c:	e0bfdd17 	ldw	r2,-140(fp)
 400bd70:	00800516 	blt	zero,r2,400bd88 <_dtoa_r+0x18e8>
 400bd74:	e0bfdd17 	ldw	r2,-140(fp)
 400bd78:	1000081e 	bne	r2,zero,400bd9c <_dtoa_r+0x18fc>
 400bd7c:	e0bff917 	ldw	r2,-28(fp)
 400bd80:	1080004c 	andi	r2,r2,1
 400bd84:	10000526 	beq	r2,zero,400bd9c <_dtoa_r+0x18fc>
		      && dig++ == '9')
 400bd88:	e0bff917 	ldw	r2,-28(fp)
 400bd8c:	10c00044 	addi	r3,r2,1
 400bd90:	e0fff915 	stw	r3,-28(fp)
 400bd94:	10800e58 	cmpnei	r2,r2,57
 400bd98:	10000e26 	beq	r2,zero,400bdd4 <_dtoa_r+0x1934>
		    goto round_9_up;
		}
	      *s++ = dig;
 400bd9c:	e0bfe317 	ldw	r2,-116(fp)
 400bda0:	10c00044 	addi	r3,r2,1
 400bda4:	e0ffe315 	stw	r3,-116(fp)
 400bda8:	e0fff917 	ldw	r3,-28(fp)
 400bdac:	10c00005 	stb	r3,0(r2)
	      goto ret;
 400bdb0:	00009a06 	br	400c01c <_dtoa_r+0x1b7c>
	    }
	  if (j1 > 0)
 400bdb4:	e0bfdd17 	ldw	r2,-140(fp)
 400bdb8:	0080160e 	bge	zero,r2,400be14 <_dtoa_r+0x1974>
	    {
	      if (dig == '9')
 400bdbc:	e0bff917 	ldw	r2,-28(fp)
 400bdc0:	10800e58 	cmpnei	r2,r2,57
 400bdc4:	10000a1e 	bne	r2,zero,400bdf0 <_dtoa_r+0x1950>
		{		/* possible if i == 1 */
		round_9_up:
 400bdc8:	00000306 	br	400bdd8 <_dtoa_r+0x1938>
		goto round_9_up;
 400bdcc:	0001883a 	nop
 400bdd0:	00000106 	br	400bdd8 <_dtoa_r+0x1938>
		    goto round_9_up;
 400bdd4:	0001883a 	nop
		  *s++ = '9';
 400bdd8:	e0bfe317 	ldw	r2,-116(fp)
 400bddc:	10c00044 	addi	r3,r2,1
 400bde0:	e0ffe315 	stw	r3,-116(fp)
 400bde4:	00c00e44 	movi	r3,57
 400bde8:	10c00005 	stb	r3,0(r2)
		  goto roundoff;
 400bdec:	00006006 	br	400bf70 <_dtoa_r+0x1ad0>
		}
	      *s++ = dig + 1;
 400bdf0:	e0bff917 	ldw	r2,-28(fp)
 400bdf4:	10800044 	addi	r2,r2,1
 400bdf8:	1009883a 	mov	r4,r2
 400bdfc:	e0bfe317 	ldw	r2,-116(fp)
 400be00:	10c00044 	addi	r3,r2,1
 400be04:	e0ffe315 	stw	r3,-116(fp)
 400be08:	2007883a 	mov	r3,r4
 400be0c:	10c00005 	stb	r3,0(r2)
	      goto ret;
 400be10:	00008206 	br	400c01c <_dtoa_r+0x1b7c>
	    }
	  *s++ = dig;
 400be14:	e0bfe317 	ldw	r2,-116(fp)
 400be18:	10c00044 	addi	r3,r2,1
 400be1c:	e0ffe315 	stw	r3,-116(fp)
 400be20:	e0fff917 	ldw	r3,-28(fp)
 400be24:	10c00005 	stb	r3,0(r2)
	  if (i == ilim)
 400be28:	e0fff817 	ldw	r3,-32(fp)
 400be2c:	e0bff617 	ldw	r2,-40(fp)
 400be30:	18803b26 	beq	r3,r2,400bf20 <_dtoa_r+0x1a80>
	    break;
	  b = multadd (ptr, b, 10, 0);
 400be34:	000f883a 	mov	r7,zero
 400be38:	01800284 	movi	r6,10
 400be3c:	e17fe917 	ldw	r5,-92(fp)
 400be40:	e13fd017 	ldw	r4,-192(fp)
 400be44:	400f2040 	call	400f204 <__multadd>
 400be48:	e0bfe915 	stw	r2,-92(fp)
	  if (mlo == mhi)
 400be4c:	e0ffe817 	ldw	r3,-96(fp)
 400be50:	e0bfe717 	ldw	r2,-100(fp)
 400be54:	1880091e 	bne	r3,r2,400be7c <_dtoa_r+0x19dc>
	    mlo = mhi = multadd (ptr, mhi, 10, 0);
 400be58:	000f883a 	mov	r7,zero
 400be5c:	01800284 	movi	r6,10
 400be60:	e17fe717 	ldw	r5,-100(fp)
 400be64:	e13fd017 	ldw	r4,-192(fp)
 400be68:	400f2040 	call	400f204 <__multadd>
 400be6c:	e0bfe715 	stw	r2,-100(fp)
 400be70:	e0bfe717 	ldw	r2,-100(fp)
 400be74:	e0bfe815 	stw	r2,-96(fp)
 400be78:	00000c06 	br	400beac <_dtoa_r+0x1a0c>
	  else
	    {
	      mlo = multadd (ptr, mlo, 10, 0);
 400be7c:	000f883a 	mov	r7,zero
 400be80:	01800284 	movi	r6,10
 400be84:	e17fe817 	ldw	r5,-96(fp)
 400be88:	e13fd017 	ldw	r4,-192(fp)
 400be8c:	400f2040 	call	400f204 <__multadd>
 400be90:	e0bfe815 	stw	r2,-96(fp)
	      mhi = multadd (ptr, mhi, 10, 0);
 400be94:	000f883a 	mov	r7,zero
 400be98:	01800284 	movi	r6,10
 400be9c:	e17fe717 	ldw	r5,-100(fp)
 400bea0:	e13fd017 	ldw	r4,-192(fp)
 400bea4:	400f2040 	call	400f204 <__multadd>
 400bea8:	e0bfe715 	stw	r2,-100(fp)
      for (i = 1;; i++)
 400beac:	e0bff817 	ldw	r2,-32(fp)
 400beb0:	10800044 	addi	r2,r2,1
 400beb4:	e0bff815 	stw	r2,-32(fp)
	  dig = quorem (b, S) + '0';
 400beb8:	003f6906 	br	400bc60 <_dtoa_r+0x17c0>
	    }
	}
    }
  else
    for (i = 1;; i++)
 400bebc:	00800044 	movi	r2,1
 400bec0:	e0bff815 	stw	r2,-32(fp)
      {
	*s++ = dig = quorem (b, S) + '0';
 400bec4:	e17fe617 	ldw	r5,-104(fp)
 400bec8:	e13fe917 	ldw	r4,-92(fp)
 400becc:	400a0ec0 	call	400a0ec <quorem>
 400bed0:	10800c04 	addi	r2,r2,48
 400bed4:	e0bff915 	stw	r2,-28(fp)
 400bed8:	e0bfe317 	ldw	r2,-116(fp)
 400bedc:	10c00044 	addi	r3,r2,1
 400bee0:	e0ffe315 	stw	r3,-116(fp)
 400bee4:	e0fff917 	ldw	r3,-28(fp)
 400bee8:	10c00005 	stb	r3,0(r2)
	if (i >= ilim)
 400beec:	e0fff817 	ldw	r3,-32(fp)
 400bef0:	e0bff617 	ldw	r2,-40(fp)
 400bef4:	18800c0e 	bge	r3,r2,400bf28 <_dtoa_r+0x1a88>
	  break;
	b = multadd (ptr, b, 10, 0);
 400bef8:	000f883a 	mov	r7,zero
 400befc:	01800284 	movi	r6,10
 400bf00:	e17fe917 	ldw	r5,-92(fp)
 400bf04:	e13fd017 	ldw	r4,-192(fp)
 400bf08:	400f2040 	call	400f204 <__multadd>
 400bf0c:	e0bfe915 	stw	r2,-92(fp)
    for (i = 1;; i++)
 400bf10:	e0bff817 	ldw	r2,-32(fp)
 400bf14:	10800044 	addi	r2,r2,1
 400bf18:	e0bff815 	stw	r2,-32(fp)
	*s++ = dig = quorem (b, S) + '0';
 400bf1c:	003fe906 	br	400bec4 <_dtoa_r+0x1a24>
	    break;
 400bf20:	0001883a 	nop
 400bf24:	00000106 	br	400bf2c <_dtoa_r+0x1a8c>
	  break;
 400bf28:	0001883a 	nop
      }

  /* Round off last digit */

  b = lshift (ptr, b, 1);
 400bf2c:	01800044 	movi	r6,1
 400bf30:	e17fe917 	ldw	r5,-92(fp)
 400bf34:	e13fd017 	ldw	r4,-192(fp)
 400bf38:	400fcf40 	call	400fcf4 <__lshift>
 400bf3c:	e0bfe915 	stw	r2,-92(fp)
  j = cmp (b, S);
 400bf40:	e17fe617 	ldw	r5,-104(fp)
 400bf44:	e13fe917 	ldw	r4,-92(fp)
 400bf48:	400ff100 	call	400ff10 <__mcmp>
 400bf4c:	e0bff415 	stw	r2,-48(fp)
  if ((j > 0) || ((j == 0) && (dig & 1)))
 400bf50:	e0bff417 	ldw	r2,-48(fp)
 400bf54:	00800516 	blt	zero,r2,400bf6c <_dtoa_r+0x1acc>
 400bf58:	e0bff417 	ldw	r2,-48(fp)
 400bf5c:	1000221e 	bne	r2,zero,400bfe8 <_dtoa_r+0x1b48>
 400bf60:	e0bff917 	ldw	r2,-28(fp)
 400bf64:	1080004c 	andi	r2,r2,1
 400bf68:	10001f26 	beq	r2,zero,400bfe8 <_dtoa_r+0x1b48>
    {
    roundoff:
 400bf6c:	0001883a 	nop
      while (*--s == '9')
 400bf70:	00000c06 	br	400bfa4 <_dtoa_r+0x1b04>
	if (s == s0)
 400bf74:	e0ffe317 	ldw	r3,-116(fp)
 400bf78:	e0bfe017 	ldw	r2,-128(fp)
 400bf7c:	1880091e 	bne	r3,r2,400bfa4 <_dtoa_r+0x1b04>
	  {
	    k++;
 400bf80:	e0bff317 	ldw	r2,-52(fp)
 400bf84:	10800044 	addi	r2,r2,1
 400bf88:	e0bff315 	stw	r2,-52(fp)
	    *s++ = '1';
 400bf8c:	e0bfe317 	ldw	r2,-116(fp)
 400bf90:	10c00044 	addi	r3,r2,1
 400bf94:	e0ffe315 	stw	r3,-116(fp)
 400bf98:	00c00c44 	movi	r3,49
 400bf9c:	10c00005 	stb	r3,0(r2)
	    goto ret;
 400bfa0:	00001e06 	br	400c01c <_dtoa_r+0x1b7c>
      while (*--s == '9')
 400bfa4:	e0bfe317 	ldw	r2,-116(fp)
 400bfa8:	10bfffc4 	addi	r2,r2,-1
 400bfac:	e0bfe315 	stw	r2,-116(fp)
 400bfb0:	e0bfe317 	ldw	r2,-116(fp)
 400bfb4:	10800003 	ldbu	r2,0(r2)
 400bfb8:	10803fcc 	andi	r2,r2,255
 400bfbc:	1080201c 	xori	r2,r2,128
 400bfc0:	10bfe004 	addi	r2,r2,-128
 400bfc4:	10800e60 	cmpeqi	r2,r2,57
 400bfc8:	103fea1e 	bne	r2,zero,400bf74 <_dtoa_r+0x1ad4>
	  }
      ++*s++;
 400bfcc:	e0bfe317 	ldw	r2,-116(fp)
 400bfd0:	10c00044 	addi	r3,r2,1
 400bfd4:	e0ffe315 	stw	r3,-116(fp)
 400bfd8:	10c00003 	ldbu	r3,0(r2)
 400bfdc:	18c00044 	addi	r3,r3,1
 400bfe0:	10c00005 	stb	r3,0(r2)
 400bfe4:	00000d06 	br	400c01c <_dtoa_r+0x1b7c>
    }
  else
    {
      while (*--s == '0');
 400bfe8:	e0bfe317 	ldw	r2,-116(fp)
 400bfec:	10bfffc4 	addi	r2,r2,-1
 400bff0:	e0bfe315 	stw	r2,-116(fp)
 400bff4:	e0bfe317 	ldw	r2,-116(fp)
 400bff8:	10800003 	ldbu	r2,0(r2)
 400bffc:	10803fcc 	andi	r2,r2,255
 400c000:	1080201c 	xori	r2,r2,128
 400c004:	10bfe004 	addi	r2,r2,-128
 400c008:	10800c20 	cmpeqi	r2,r2,48
 400c00c:	103ff61e 	bne	r2,zero,400bfe8 <_dtoa_r+0x1b48>
      s++;
 400c010:	e0bfe317 	ldw	r2,-116(fp)
 400c014:	10800044 	addi	r2,r2,1
 400c018:	e0bfe315 	stw	r2,-116(fp)
    }
ret:
  Bfree (ptr, S);
 400c01c:	e17fe617 	ldw	r5,-104(fp)
 400c020:	e13fd017 	ldw	r4,-192(fp)
 400c024:	400f1900 	call	400f190 <_Bfree>
  if (mhi)
 400c028:	e0bfe717 	ldw	r2,-100(fp)
 400c02c:	10000e26 	beq	r2,zero,400c068 <_dtoa_r+0x1bc8>
    {
      if (mlo && mlo != mhi)
 400c030:	e0bfe817 	ldw	r2,-96(fp)
 400c034:	10000626 	beq	r2,zero,400c050 <_dtoa_r+0x1bb0>
 400c038:	e0ffe817 	ldw	r3,-96(fp)
 400c03c:	e0bfe717 	ldw	r2,-100(fp)
 400c040:	18800326 	beq	r3,r2,400c050 <_dtoa_r+0x1bb0>
	Bfree (ptr, mlo);
 400c044:	e17fe817 	ldw	r5,-96(fp)
 400c048:	e13fd017 	ldw	r4,-192(fp)
 400c04c:	400f1900 	call	400f190 <_Bfree>
      Bfree (ptr, mhi);
 400c050:	e17fe717 	ldw	r5,-100(fp)
 400c054:	e13fd017 	ldw	r4,-192(fp)
 400c058:	400f1900 	call	400f190 <_Bfree>
 400c05c:	00000306 	br	400c06c <_dtoa_r+0x1bcc>
		goto ret1;
 400c060:	0001883a 	nop
 400c064:	00000106 	br	400c06c <_dtoa_r+0x1bcc>
    }
ret1:
 400c068:	0001883a 	nop
  Bfree (ptr, b);
 400c06c:	e17fe917 	ldw	r5,-92(fp)
 400c070:	e13fd017 	ldw	r4,-192(fp)
 400c074:	400f1900 	call	400f190 <_Bfree>
  *s = 0;
 400c078:	e0bfe317 	ldw	r2,-116(fp)
 400c07c:	10000005 	stb	zero,0(r2)
  *decpt = k + 1;
 400c080:	e0bff317 	ldw	r2,-52(fp)
 400c084:	10c00044 	addi	r3,r2,1
 400c088:	e0800317 	ldw	r2,12(fp)
 400c08c:	10c00015 	stw	r3,0(r2)
  if (rve)
 400c090:	e0800517 	ldw	r2,20(fp)
 400c094:	10000326 	beq	r2,zero,400c0a4 <_dtoa_r+0x1c04>
    *rve = s;
 400c098:	e0800517 	ldw	r2,20(fp)
 400c09c:	e0ffe317 	ldw	r3,-116(fp)
 400c0a0:	10c00015 	stw	r3,0(r2)
  return s0;
 400c0a4:	e0bfe017 	ldw	r2,-128(fp)
}
 400c0a8:	e6fffc04 	addi	sp,fp,-16
 400c0ac:	dfc00517 	ldw	ra,20(sp)
 400c0b0:	df000417 	ldw	fp,16(sp)
 400c0b4:	dcc00317 	ldw	r19,12(sp)
 400c0b8:	dc800217 	ldw	r18,8(sp)
 400c0bc:	dc400117 	ldw	r17,4(sp)
 400c0c0:	dc000017 	ldw	r16,0(sp)
 400c0c4:	dec00604 	addi	sp,sp,24
 400c0c8:	f800283a 	ret

0400c0cc <__sflush_r>:
/* Core function which does not lock file pointer.  This gets called
   directly from __srefill. */
int
__sflush_r (struct _reent *ptr,
       register FILE * fp)
{
 400c0cc:	defff504 	addi	sp,sp,-44
 400c0d0:	dfc00a15 	stw	ra,40(sp)
 400c0d4:	df000915 	stw	fp,36(sp)
 400c0d8:	dcc00815 	stw	r19,32(sp)
 400c0dc:	dc800715 	stw	r18,28(sp)
 400c0e0:	dc400615 	stw	r17,24(sp)
 400c0e4:	dc000515 	stw	r16,20(sp)
 400c0e8:	df000904 	addi	fp,sp,36
 400c0ec:	e13ff715 	stw	r4,-36(fp)
 400c0f0:	2821883a 	mov	r16,r5
  register unsigned char *p;
  register _READ_WRITE_BUFSIZE_TYPE n;
  register _READ_WRITE_RETURN_TYPE t;
  short flags;

  flags = fp->_flags;
 400c0f4:	8080030b 	ldhu	r2,12(r16)
 400c0f8:	e0bff98d 	sth	r2,-26(fp)
  if ((flags & __SWR) == 0)
 400c0fc:	e0bff98b 	ldhu	r2,-26(fp)
 400c100:	10bfffcc 	andi	r2,r2,65535
 400c104:	1080020c 	andi	r2,r2,8
 400c108:	1000831e 	bne	r2,zero,400c318 <__sflush_r+0x24c>
    {
#ifdef _FSEEK_OPTIMIZATION
      /* For a read stream, an fflush causes the next seek to be
         unoptimized (i.e. forces a system-level seek).  This conforms
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;
 400c10c:	8080030b 	ldhu	r2,12(r16)
 400c110:	10820014 	ori	r2,r2,2048
 400c114:	8080030d 	sth	r2,12(r16)
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && fp->_seek != NULL)
 400c118:	80800117 	ldw	r2,4(r16)
 400c11c:	00800216 	blt	zero,r2,400c128 <__sflush_r+0x5c>
 400c120:	80800f17 	ldw	r2,60(r16)
 400c124:	00807a0e 	bge	zero,r2,400c310 <__sflush_r+0x244>
 400c128:	80800a17 	ldw	r2,40(r16)
 400c12c:	10007826 	beq	r2,zero,400c310 <__sflush_r+0x244>
#endif

	  /* Save last errno and set errno to 0, so we can check if a device
	     returns with a valid position -1.  We restore the last errno if
	     no other error condition has been encountered. */
	  tmp_errno = ptr->_errno;
 400c130:	e0bff717 	ldw	r2,-36(fp)
 400c134:	10800017 	ldw	r2,0(r2)
 400c138:	e0bff815 	stw	r2,-32(fp)
	  ptr->_errno = 0;
 400c13c:	e0bff717 	ldw	r2,-36(fp)
 400c140:	10000015 	stw	zero,0(r2)
	  /* Get the physical position we are at in the file.  */
	  if (fp->_flags & __SOFF)
 400c144:	8080030b 	ldhu	r2,12(r16)
 400c148:	10bfffcc 	andi	r2,r2,65535
 400c14c:	1084000c 	andi	r2,r2,4096
 400c150:	10000326 	beq	r2,zero,400c160 <__sflush_r+0x94>
	    curoff = fp->_offset;
 400c154:	80801417 	ldw	r2,80(r16)
 400c158:	e0bffb15 	stw	r2,-20(fp)
 400c15c:	00002206 	br	400c1e8 <__sflush_r+0x11c>
#ifdef __LARGE64_FILES
	      if (fp->_flags & __SL64)
		curoff = fp->_seek64 (ptr, fp->_cookie, 0, SEEK_CUR);
	      else
#endif
		curoff = fp->_seek (ptr, fp->_cookie, 0, SEEK_CUR);
 400c160:	80800a17 	ldw	r2,40(r16)
 400c164:	80c00717 	ldw	r3,28(r16)
 400c168:	01c00044 	movi	r7,1
 400c16c:	000d883a 	mov	r6,zero
 400c170:	180b883a 	mov	r5,r3
 400c174:	e13ff717 	ldw	r4,-36(fp)
 400c178:	103ee83a 	callr	r2
 400c17c:	e0bffb15 	stw	r2,-20(fp)
	      if (curoff == -1L && ptr->_errno != 0)
 400c180:	e0bffb17 	ldw	r2,-20(fp)
 400c184:	10bfffd8 	cmpnei	r2,r2,-1
 400c188:	1000171e 	bne	r2,zero,400c1e8 <__sflush_r+0x11c>
 400c18c:	e0bff717 	ldw	r2,-36(fp)
 400c190:	10800017 	ldw	r2,0(r2)
 400c194:	10001426 	beq	r2,zero,400c1e8 <__sflush_r+0x11c>
		{
		  int result = EOF;
 400c198:	00bfffc4 	movi	r2,-1
 400c19c:	e0bffa15 	stw	r2,-24(fp)
		  if (ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
 400c1a0:	e0bff717 	ldw	r2,-36(fp)
 400c1a4:	10800017 	ldw	r2,0(r2)
 400c1a8:	10800760 	cmpeqi	r2,r2,29
 400c1ac:	1000041e 	bne	r2,zero,400c1c0 <__sflush_r+0xf4>
 400c1b0:	e0bff717 	ldw	r2,-36(fp)
 400c1b4:	10800017 	ldw	r2,0(r2)
 400c1b8:	10800598 	cmpnei	r2,r2,22
 400c1bc:	1000051e 	bne	r2,zero,400c1d4 <__sflush_r+0x108>
		    {
		      result = 0;
 400c1c0:	e03ffa15 	stw	zero,-24(fp)
		      ptr->_errno = tmp_errno;
 400c1c4:	e0bff717 	ldw	r2,-36(fp)
 400c1c8:	e0fff817 	ldw	r3,-32(fp)
 400c1cc:	10c00015 	stw	r3,0(r2)
 400c1d0:	00000306 	br	400c1e0 <__sflush_r+0x114>
		    }
		  else
		    fp->_flags |= __SERR;
 400c1d4:	8080030b 	ldhu	r2,12(r16)
 400c1d8:	10801014 	ori	r2,r2,64
 400c1dc:	8080030d 	sth	r2,12(r16)
		  return result;
 400c1e0:	e0bffa17 	ldw	r2,-24(fp)
 400c1e4:	00006f06 	br	400c3a4 <__sflush_r+0x2d8>
		}
            }
          if (fp->_flags & __SRD)
 400c1e8:	8080030b 	ldhu	r2,12(r16)
 400c1ec:	10bfffcc 	andi	r2,r2,65535
 400c1f0:	1080010c 	andi	r2,r2,4
 400c1f4:	10000a26 	beq	r2,zero,400c220 <__sflush_r+0x154>
            {
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
              curoff -= fp->_r;
 400c1f8:	80800117 	ldw	r2,4(r16)
 400c1fc:	e0fffb17 	ldw	r3,-20(fp)
 400c200:	1885c83a 	sub	r2,r3,r2
 400c204:	e0bffb15 	stw	r2,-20(fp)
              if (HASUB (fp))
 400c208:	80800c17 	ldw	r2,48(r16)
 400c20c:	10000426 	beq	r2,zero,400c220 <__sflush_r+0x154>
                curoff -= fp->_ur;
 400c210:	80800f17 	ldw	r2,60(r16)
 400c214:	e0fffb17 	ldw	r3,-20(fp)
 400c218:	1885c83a 	sub	r2,r3,r2
 400c21c:	e0bffb15 	stw	r2,-20(fp)
#ifdef __LARGE64_FILES
	  if (fp->_flags & __SL64)
	    curoff = fp->_seek64 (ptr, fp->_cookie, curoff, SEEK_SET);
	  else
#endif
	    curoff = fp->_seek (ptr, fp->_cookie, curoff, SEEK_SET);
 400c220:	80800a17 	ldw	r2,40(r16)
 400c224:	80c00717 	ldw	r3,28(r16)
 400c228:	000f883a 	mov	r7,zero
 400c22c:	e1bffb17 	ldw	r6,-20(fp)
 400c230:	180b883a 	mov	r5,r3
 400c234:	e13ff717 	ldw	r4,-36(fp)
 400c238:	103ee83a 	callr	r2
 400c23c:	e0bffb15 	stw	r2,-20(fp)
	  if (curoff != -1 || ptr->_errno == 0
 400c240:	e0bffb17 	ldw	r2,-20(fp)
 400c244:	10bfffd8 	cmpnei	r2,r2,-1
 400c248:	10000b1e 	bne	r2,zero,400c278 <__sflush_r+0x1ac>
 400c24c:	e0bff717 	ldw	r2,-36(fp)
 400c250:	10800017 	ldw	r2,0(r2)
 400c254:	10000826 	beq	r2,zero,400c278 <__sflush_r+0x1ac>
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
 400c258:	e0bff717 	ldw	r2,-36(fp)
 400c25c:	10800017 	ldw	r2,0(r2)
 400c260:	10800760 	cmpeqi	r2,r2,29
 400c264:	1000041e 	bne	r2,zero,400c278 <__sflush_r+0x1ac>
 400c268:	e0bff717 	ldw	r2,-36(fp)
 400c26c:	10800017 	ldw	r2,0(r2)
 400c270:	10800598 	cmpnei	r2,r2,22
 400c274:	1000211e 	bne	r2,zero,400c2fc <__sflush_r+0x230>
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
 400c278:	80c0030b 	ldhu	r3,12(r16)
 400c27c:	00bdffc4 	movi	r2,-2049
 400c280:	1884703a 	and	r2,r3,r2
 400c284:	8080030d 	sth	r2,12(r16)
#endif
	      fp->_r = 0;
 400c288:	80000115 	stw	zero,4(r16)
	      fp->_p = fp->_bf._base;
 400c28c:	80800417 	ldw	r2,16(r16)
 400c290:	80800015 	stw	r2,0(r16)
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
 400c294:	8080030b 	ldhu	r2,12(r16)
 400c298:	10bfffcc 	andi	r2,r2,65535
 400c29c:	1084000c 	andi	r2,r2,4096
 400c2a0:	10000826 	beq	r2,zero,400c2c4 <__sflush_r+0x1f8>
 400c2a4:	e0bffb17 	ldw	r2,-20(fp)
 400c2a8:	10bfffd8 	cmpnei	r2,r2,-1
 400c2ac:	1000031e 	bne	r2,zero,400c2bc <__sflush_r+0x1f0>
 400c2b0:	e0bff717 	ldw	r2,-36(fp)
 400c2b4:	10800017 	ldw	r2,0(r2)
 400c2b8:	1000021e 	bne	r2,zero,400c2c4 <__sflush_r+0x1f8>
		fp->_offset = curoff;
 400c2bc:	e0bffb17 	ldw	r2,-20(fp)
 400c2c0:	80801415 	stw	r2,80(r16)
	      ptr->_errno = tmp_errno;
 400c2c4:	e0bff717 	ldw	r2,-36(fp)
 400c2c8:	e0fff817 	ldw	r3,-32(fp)
 400c2cc:	10c00015 	stw	r3,0(r2)
	      if (HASUB (fp))
 400c2d0:	80800c17 	ldw	r2,48(r16)
 400c2d4:	10000e26 	beq	r2,zero,400c310 <__sflush_r+0x244>
		FREEUB (ptr, fp);
 400c2d8:	80c00c17 	ldw	r3,48(r16)
 400c2dc:	80801004 	addi	r2,r16,64
 400c2e0:	18800426 	beq	r3,r2,400c2f4 <__sflush_r+0x228>
 400c2e4:	80800c17 	ldw	r2,48(r16)
 400c2e8:	100b883a 	mov	r5,r2
 400c2ec:	e13ff717 	ldw	r4,-36(fp)
 400c2f0:	400cb0c0 	call	400cb0c <_free_r>
 400c2f4:	80000c15 	stw	zero,48(r16)
	      if (HASUB (fp))
 400c2f8:	00000506 	br	400c310 <__sflush_r+0x244>
	    }
	  else
	    {
	      fp->_flags |= __SERR;
 400c2fc:	8080030b 	ldhu	r2,12(r16)
 400c300:	10801014 	ori	r2,r2,64
 400c304:	8080030d 	sth	r2,12(r16)
	      return EOF;
 400c308:	00bfffc4 	movi	r2,-1
 400c30c:	00002506 	br	400c3a4 <__sflush_r+0x2d8>
	    }
	}
      return 0;
 400c310:	0005883a 	mov	r2,zero
 400c314:	00002306 	br	400c3a4 <__sflush_r+0x2d8>
    }
  if ((p = fp->_bf._base) == NULL)
 400c318:	84400417 	ldw	r17,16(r16)
 400c31c:	8800021e 	bne	r17,zero,400c328 <__sflush_r+0x25c>
    {
      /* Nothing to flush.  */
      return 0;
 400c320:	0005883a 	mov	r2,zero
 400c324:	00001f06 	br	400c3a4 <__sflush_r+0x2d8>
    }
  n = fp->_p - p;		/* write this much */
 400c328:	80800017 	ldw	r2,0(r16)
 400c32c:	1465c83a 	sub	r18,r2,r17
  /*
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
   */
  fp->_p = p;
 400c330:	84400015 	stw	r17,0(r16)
  fp->_w = flags & (__SLBF | __SNBF) ? 0 : fp->_bf._size;
 400c334:	e0bff98b 	ldhu	r2,-26(fp)
 400c338:	10bfffcc 	andi	r2,r2,65535
 400c33c:	108000cc 	andi	r2,r2,3
 400c340:	1000021e 	bne	r2,zero,400c34c <__sflush_r+0x280>
 400c344:	80800517 	ldw	r2,20(r16)
 400c348:	00000106 	br	400c350 <__sflush_r+0x284>
 400c34c:	0005883a 	mov	r2,zero
 400c350:	80800215 	stw	r2,8(r16)

  while (n > 0)
 400c354:	00001106 	br	400c39c <__sflush_r+0x2d0>
    {
      t = fp->_write (ptr, fp->_cookie, (char *) p, n);
 400c358:	80800917 	ldw	r2,36(r16)
 400c35c:	80c00717 	ldw	r3,28(r16)
 400c360:	900f883a 	mov	r7,r18
 400c364:	880d883a 	mov	r6,r17
 400c368:	180b883a 	mov	r5,r3
 400c36c:	e13ff717 	ldw	r4,-36(fp)
 400c370:	103ee83a 	callr	r2
 400c374:	1027883a 	mov	r19,r2
      if (t <= 0)
 400c378:	04c00516 	blt	zero,r19,400c390 <__sflush_r+0x2c4>
	{
          fp->_flags |= __SERR;
 400c37c:	8080030b 	ldhu	r2,12(r16)
 400c380:	10801014 	ori	r2,r2,64
 400c384:	8080030d 	sth	r2,12(r16)
          return EOF;
 400c388:	00bfffc4 	movi	r2,-1
 400c38c:	00000506 	br	400c3a4 <__sflush_r+0x2d8>
	}
      p += t;
 400c390:	9805883a 	mov	r2,r19
 400c394:	88a3883a 	add	r17,r17,r2
      n -= t;
 400c398:	94e5c83a 	sub	r18,r18,r19
  while (n > 0)
 400c39c:	04bfee16 	blt	zero,r18,400c358 <__sflush_r+0x28c>
    }
  return 0;
 400c3a0:	0005883a 	mov	r2,zero
}
 400c3a4:	e6fffc04 	addi	sp,fp,-16
 400c3a8:	dfc00517 	ldw	ra,20(sp)
 400c3ac:	df000417 	ldw	fp,16(sp)
 400c3b0:	dcc00317 	ldw	r19,12(sp)
 400c3b4:	dc800217 	ldw	r18,8(sp)
 400c3b8:	dc400117 	ldw	r17,4(sp)
 400c3bc:	dc000017 	ldw	r16,0(sp)
 400c3c0:	dec00604 	addi	sp,sp,24
 400c3c4:	f800283a 	ret

0400c3c8 <_fflush_r>:
#endif /* __IMPL_UNLOCKED__ */

int
_fflush_r (struct _reent *ptr,
       register FILE * fp)
{
 400c3c8:	defffa04 	addi	sp,sp,-24
 400c3cc:	dfc00515 	stw	ra,20(sp)
 400c3d0:	df000415 	stw	fp,16(sp)
 400c3d4:	dc000315 	stw	r16,12(sp)
 400c3d8:	df000404 	addi	fp,sp,16
 400c3dc:	e13ffc15 	stw	r4,-16(fp)
 400c3e0:	2821883a 	mov	r16,r5
     2 is implemented here due to its simplicity.  */
  if (fp->_bf._base == NULL)
    return 0;
#endif /* _REENT_SMALL  */

  CHECK_INIT (ptr, fp);
 400c3e4:	e0bffc17 	ldw	r2,-16(fp)
 400c3e8:	e0bffe15 	stw	r2,-8(fp)
 400c3ec:	e0bffe17 	ldw	r2,-8(fp)
 400c3f0:	10000526 	beq	r2,zero,400c408 <_fflush_r+0x40>
 400c3f4:	e0bffe17 	ldw	r2,-8(fp)
 400c3f8:	10800e17 	ldw	r2,56(r2)
 400c3fc:	1000021e 	bne	r2,zero,400c408 <_fflush_r+0x40>
 400c400:	e13ffe17 	ldw	r4,-8(fp)
 400c404:	400c9100 	call	400c910 <__sinit>

  if (!fp->_flags)
 400c408:	8080030b 	ldhu	r2,12(r16)
 400c40c:	10bfffcc 	andi	r2,r2,65535
 400c410:	10a0001c 	xori	r2,r2,32768
 400c414:	10a00004 	addi	r2,r2,-32768
 400c418:	1000021e 	bne	r2,zero,400c424 <_fflush_r+0x5c>
    return 0;
 400c41c:	0005883a 	mov	r2,zero
 400c420:	00000506 	br	400c438 <_fflush_r+0x70>

  _newlib_flockfile_start (fp);
  ret = __sflush_r (ptr, fp);
 400c424:	800b883a 	mov	r5,r16
 400c428:	e13ffc17 	ldw	r4,-16(fp)
 400c42c:	400c0cc0 	call	400c0cc <__sflush_r>
 400c430:	e0bffd15 	stw	r2,-12(fp)
  _newlib_flockfile_end (fp);
  return ret;
 400c434:	e0bffd17 	ldw	r2,-12(fp)
}
 400c438:	e6ffff04 	addi	sp,fp,-4
 400c43c:	dfc00217 	ldw	ra,8(sp)
 400c440:	df000117 	ldw	fp,4(sp)
 400c444:	dc000017 	ldw	r16,0(sp)
 400c448:	dec00304 	addi	sp,sp,12
 400c44c:	f800283a 	ret

0400c450 <fflush>:

#ifndef _REENT_ONLY

int
fflush (register FILE * fp)
{
 400c450:	defffe04 	addi	sp,sp,-8
 400c454:	dfc00115 	stw	ra,4(sp)
 400c458:	df000015 	stw	fp,0(sp)
 400c45c:	d839883a 	mov	fp,sp
 400c460:	2005883a 	mov	r2,r4
  if (fp == NULL)
 400c464:	1000061e 	bne	r2,zero,400c480 <fflush+0x30>
    return _fwalk_reent (_GLOBAL_REENT, _fflush_r);
 400c468:	d0a00217 	ldw	r2,-32760(gp)
 400c46c:	01410074 	movhi	r5,1025
 400c470:	2970f204 	addi	r5,r5,-15416
 400c474:	1009883a 	mov	r4,r2
 400c478:	400d8e80 	call	400d8e8 <_fwalk_reent>
 400c47c:	00000406 	br	400c490 <fflush+0x40>

  return _fflush_r (_REENT, fp);
 400c480:	d0e00117 	ldw	r3,-32764(gp)
 400c484:	100b883a 	mov	r5,r2
 400c488:	1809883a 	mov	r4,r3
 400c48c:	400c3c80 	call	400c3c8 <_fflush_r>
}
 400c490:	e037883a 	mov	sp,fp
 400c494:	dfc00117 	ldw	ra,4(sp)
 400c498:	df000017 	ldw	fp,0(sp)
 400c49c:	dec00204 	addi	sp,sp,8
 400c4a0:	f800283a 	ret

0400c4a4 <std>:
static void
#endif
std (FILE *ptr,
            int flags,
            int file)
{
 400c4a4:	defffb04 	addi	sp,sp,-20
 400c4a8:	dfc00415 	stw	ra,16(sp)
 400c4ac:	df000315 	stw	fp,12(sp)
 400c4b0:	df000304 	addi	fp,sp,12
 400c4b4:	e13fff15 	stw	r4,-4(fp)
 400c4b8:	e17ffe15 	stw	r5,-8(fp)
 400c4bc:	e1bffd15 	stw	r6,-12(fp)
  ptr->_p = 0;
 400c4c0:	e0bfff17 	ldw	r2,-4(fp)
 400c4c4:	10000015 	stw	zero,0(r2)
  ptr->_r = 0;
 400c4c8:	e0bfff17 	ldw	r2,-4(fp)
 400c4cc:	10000115 	stw	zero,4(r2)
  ptr->_w = 0;
 400c4d0:	e0bfff17 	ldw	r2,-4(fp)
 400c4d4:	10000215 	stw	zero,8(r2)
  ptr->_flags = flags;
 400c4d8:	e0bffe17 	ldw	r2,-8(fp)
 400c4dc:	1007883a 	mov	r3,r2
 400c4e0:	e0bfff17 	ldw	r2,-4(fp)
 400c4e4:	10c0030d 	sth	r3,12(r2)
  ptr->_flags2 = 0;
 400c4e8:	e0bfff17 	ldw	r2,-4(fp)
 400c4ec:	10001915 	stw	zero,100(r2)
  ptr->_file = file;
 400c4f0:	e0bffd17 	ldw	r2,-12(fp)
 400c4f4:	1007883a 	mov	r3,r2
 400c4f8:	e0bfff17 	ldw	r2,-4(fp)
 400c4fc:	10c0038d 	sth	r3,14(r2)
  ptr->_bf._base = 0;
 400c500:	e0bfff17 	ldw	r2,-4(fp)
 400c504:	10000415 	stw	zero,16(r2)
  ptr->_bf._size = 0;
 400c508:	e0bfff17 	ldw	r2,-4(fp)
 400c50c:	10000515 	stw	zero,20(r2)
  ptr->_lbfsize = 0;
 400c510:	e0bfff17 	ldw	r2,-4(fp)
 400c514:	10000615 	stw	zero,24(r2)
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
 400c518:	e0bfff17 	ldw	r2,-4(fp)
 400c51c:	10801704 	addi	r2,r2,92
 400c520:	01800204 	movi	r6,8
 400c524:	000b883a 	mov	r5,zero
 400c528:	1009883a 	mov	r4,r2
 400c52c:	40074880 	call	4007488 <memset>
  ptr->_cookie = ptr;
 400c530:	e0bfff17 	ldw	r2,-4(fp)
 400c534:	e0ffff17 	ldw	r3,-4(fp)
 400c538:	10c00715 	stw	r3,28(r2)
  ptr->_read = __sread;
 400c53c:	e0ffff17 	ldw	r3,-4(fp)
 400c540:	00810074 	movhi	r2,1025
 400c544:	10860e04 	addi	r2,r2,6200
 400c548:	18800815 	stw	r2,32(r3)
#ifndef __LARGE64_FILES
  ptr->_write = __swrite;
 400c54c:	e0ffff17 	ldw	r3,-4(fp)
 400c550:	00810074 	movhi	r2,1025
 400c554:	10864104 	addi	r2,r2,6404
 400c558:	18800915 	stw	r2,36(r3)
#else /* __LARGE64_FILES */
  ptr->_write = __swrite64;
  ptr->_seek64 = __sseek64;
  ptr->_flags |= __SL64;
#endif /* __LARGE64_FILES */
  ptr->_seek = __sseek;
 400c55c:	e0ffff17 	ldw	r3,-4(fp)
 400c560:	00810074 	movhi	r2,1025
 400c564:	10866e04 	addi	r2,r2,6584
 400c568:	18800a15 	stw	r2,40(r3)
#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
  ptr->_close = __sclose;
 400c56c:	e0ffff17 	ldw	r3,-4(fp)
 400c570:	00810074 	movhi	r2,1025
 400c574:	10869604 	addi	r2,r2,6744
 400c578:	18800b15 	stw	r2,44(r3)

#ifdef __SCLE
  if (__stextmode (ptr->_file))
    ptr->_flags |= __SCLE;
#endif
}
 400c57c:	0001883a 	nop
 400c580:	e037883a 	mov	sp,fp
 400c584:	dfc00117 	ldw	ra,4(sp)
 400c588:	df000017 	ldw	fp,0(sp)
 400c58c:	dec00204 	addi	sp,sp,8
 400c590:	f800283a 	ret

0400c594 <stdin_init>:

static inline void
stdin_init(FILE *ptr)
{
 400c594:	defffd04 	addi	sp,sp,-12
 400c598:	dfc00215 	stw	ra,8(sp)
 400c59c:	df000115 	stw	fp,4(sp)
 400c5a0:	df000104 	addi	fp,sp,4
 400c5a4:	e13fff15 	stw	r4,-4(fp)
  std (ptr,  __SRD, 0);
 400c5a8:	000d883a 	mov	r6,zero
 400c5ac:	01400104 	movi	r5,4
 400c5b0:	e13fff17 	ldw	r4,-4(fp)
 400c5b4:	400c4a40 	call	400c4a4 <std>
}
 400c5b8:	0001883a 	nop
 400c5bc:	e037883a 	mov	sp,fp
 400c5c0:	dfc00117 	ldw	ra,4(sp)
 400c5c4:	df000017 	ldw	fp,0(sp)
 400c5c8:	dec00204 	addi	sp,sp,8
 400c5cc:	f800283a 	ret

0400c5d0 <stdout_init>:

static inline void
stdout_init(FILE *ptr)
{
 400c5d0:	defffd04 	addi	sp,sp,-12
 400c5d4:	dfc00215 	stw	ra,8(sp)
 400c5d8:	df000115 	stw	fp,4(sp)
 400c5dc:	df000104 	addi	fp,sp,4
 400c5e0:	e13fff15 	stw	r4,-4(fp)
#ifdef HAVE_FCNTL
/*std (ptr, __SWR, 1); */
  std (ptr, __SWR | __SNBF, 1);	/* IntelSpecific: Change to have no buffering on stdout. */
#else
/*std (ptr, __SWR | __SLBF, 1); */
  std (ptr, __SWR | __SNBF, 1);	/* IntelSpecific: Change to have no buffering on stdout. */
 400c5e4:	01800044 	movi	r6,1
 400c5e8:	01400284 	movi	r5,10
 400c5ec:	e13fff17 	ldw	r4,-4(fp)
 400c5f0:	400c4a40 	call	400c4a4 <std>
#endif
}
 400c5f4:	0001883a 	nop
 400c5f8:	e037883a 	mov	sp,fp
 400c5fc:	dfc00117 	ldw	ra,4(sp)
 400c600:	df000017 	ldw	fp,0(sp)
 400c604:	dec00204 	addi	sp,sp,8
 400c608:	f800283a 	ret

0400c60c <stderr_init>:

static inline void
stderr_init(FILE *ptr)
{
 400c60c:	defffd04 	addi	sp,sp,-12
 400c610:	dfc00215 	stw	ra,8(sp)
 400c614:	df000115 	stw	fp,4(sp)
 400c618:	df000104 	addi	fp,sp,4
 400c61c:	e13fff15 	stw	r4,-4(fp)
  /* POSIX requires stderr to be opened for reading and writing, even
     when the underlying fd 2 is write-only.  */
  std (ptr, __SRW | __SNBF, 2);
 400c620:	01800084 	movi	r6,2
 400c624:	01400484 	movi	r5,18
 400c628:	e13fff17 	ldw	r4,-4(fp)
 400c62c:	400c4a40 	call	400c4a4 <std>
}
 400c630:	0001883a 	nop
 400c634:	e037883a 	mov	sp,fp
 400c638:	dfc00117 	ldw	ra,4(sp)
 400c63c:	df000017 	ldw	fp,0(sp)
 400c640:	dec00204 	addi	sp,sp,8
 400c644:	f800283a 	ret

0400c648 <__sfmoreglue>:
};

struct _glue *
__sfmoreglue (struct _reent *d,
       register int n)
{
 400c648:	defffa04 	addi	sp,sp,-24
 400c64c:	dfc00515 	stw	ra,20(sp)
 400c650:	df000415 	stw	fp,16(sp)
 400c654:	dc400315 	stw	r17,12(sp)
 400c658:	dc000215 	stw	r16,8(sp)
 400c65c:	df000404 	addi	fp,sp,16
 400c660:	e13ffc15 	stw	r4,-16(fp)
 400c664:	2821883a 	mov	r16,r5
  struct glue_with_file *g;

  g = (struct glue_with_file *)
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
 400c668:	80bfffc4 	addi	r2,r16,-1
 400c66c:	01401a04 	movi	r5,104
 400c670:	1009883a 	mov	r4,r2
 400c674:	40072d80 	call	40072d8 <__mulsi3>
 400c678:	10801d04 	addi	r2,r2,116
 400c67c:	100b883a 	mov	r5,r2
 400c680:	e13ffc17 	ldw	r4,-16(fp)
 400c684:	400e1400 	call	400e140 <_malloc_r>
 400c688:	e0bffd15 	stw	r2,-12(fp)
  if (g == NULL)
 400c68c:	e0bffd17 	ldw	r2,-12(fp)
 400c690:	1000021e 	bne	r2,zero,400c69c <__sfmoreglue+0x54>
    return NULL;
 400c694:	0005883a 	mov	r2,zero
 400c698:	00001306 	br	400c6e8 <__sfmoreglue+0xa0>
  g->glue._next = NULL;
 400c69c:	e0bffd17 	ldw	r2,-12(fp)
 400c6a0:	10000015 	stw	zero,0(r2)
  g->glue._niobs = n;
 400c6a4:	e0bffd17 	ldw	r2,-12(fp)
 400c6a8:	14000115 	stw	r16,4(r2)
  g->glue._iobs = &g->file;
 400c6ac:	e0bffd17 	ldw	r2,-12(fp)
 400c6b0:	10c00304 	addi	r3,r2,12
 400c6b4:	e0bffd17 	ldw	r2,-12(fp)
 400c6b8:	10c00215 	stw	r3,8(r2)
  memset (&g->file, 0, n * sizeof (FILE));
 400c6bc:	e0bffd17 	ldw	r2,-12(fp)
 400c6c0:	14400304 	addi	r17,r2,12
 400c6c4:	8005883a 	mov	r2,r16
 400c6c8:	01401a04 	movi	r5,104
 400c6cc:	1009883a 	mov	r4,r2
 400c6d0:	40072d80 	call	40072d8 <__mulsi3>
 400c6d4:	100d883a 	mov	r6,r2
 400c6d8:	000b883a 	mov	r5,zero
 400c6dc:	8809883a 	mov	r4,r17
 400c6e0:	40074880 	call	4007488 <memset>
  return &g->glue;
 400c6e4:	e0bffd17 	ldw	r2,-12(fp)
}
 400c6e8:	e6fffe04 	addi	sp,fp,-8
 400c6ec:	dfc00317 	ldw	ra,12(sp)
 400c6f0:	df000217 	ldw	fp,8(sp)
 400c6f4:	dc400117 	ldw	r17,4(sp)
 400c6f8:	dc000017 	ldw	r16,0(sp)
 400c6fc:	dec00404 	addi	sp,sp,16
 400c700:	f800283a 	ret

0400c704 <__sfp>:
 * Find a free FILE for fopen et al.
 */

FILE *
__sfp (struct _reent *d)
{
 400c704:	defffa04 	addi	sp,sp,-24
 400c708:	dfc00515 	stw	ra,20(sp)
 400c70c:	df000415 	stw	fp,16(sp)
 400c710:	df000404 	addi	fp,sp,16
 400c714:	e13ffc15 	stw	r4,-16(fp)
  FILE *fp;
  int n;
  struct _glue *g;

  _newlib_sfp_lock_start ();
 400c718:	400c9c40 	call	400c9c4 <__sfp_lock_acquire>

  if (!_GLOBAL_REENT->__sdidinit)
 400c71c:	d0a00217 	ldw	r2,-32760(gp)
 400c720:	10800e17 	ldw	r2,56(r2)
 400c724:	1000031e 	bne	r2,zero,400c734 <__sfp+0x30>
    __sinit (_GLOBAL_REENT);
 400c728:	d0a00217 	ldw	r2,-32760(gp)
 400c72c:	1009883a 	mov	r4,r2
 400c730:	400c9100 	call	400c910 <__sinit>
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
 400c734:	d0a00217 	ldw	r2,-32760(gp)
 400c738:	1080b804 	addi	r2,r2,736
 400c73c:	e0bffd15 	stw	r2,-12(fp)
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
 400c740:	e0bffd17 	ldw	r2,-12(fp)
 400c744:	10800217 	ldw	r2,8(r2)
 400c748:	e0bfff15 	stw	r2,-4(fp)
 400c74c:	e0bffd17 	ldw	r2,-12(fp)
 400c750:	10800117 	ldw	r2,4(r2)
 400c754:	e0bffe15 	stw	r2,-8(fp)
 400c758:	00000906 	br	400c780 <__sfp+0x7c>
	if (fp->_flags == 0)
 400c75c:	e0bfff17 	ldw	r2,-4(fp)
 400c760:	1080030b 	ldhu	r2,12(r2)
 400c764:	10bfffcc 	andi	r2,r2,65535
 400c768:	10a0001c 	xori	r2,r2,32768
 400c76c:	10a00004 	addi	r2,r2,-32768
 400c770:	10001f26 	beq	r2,zero,400c7f0 <__sfp+0xec>
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
 400c774:	e0bfff17 	ldw	r2,-4(fp)
 400c778:	10801a04 	addi	r2,r2,104
 400c77c:	e0bfff15 	stw	r2,-4(fp)
 400c780:	e0bffe17 	ldw	r2,-8(fp)
 400c784:	10bfffc4 	addi	r2,r2,-1
 400c788:	e0bffe15 	stw	r2,-8(fp)
 400c78c:	e0bffe17 	ldw	r2,-8(fp)
 400c790:	103ff20e 	bge	r2,zero,400c75c <__sfp+0x58>
	  goto found;
      if (g->_next == NULL &&
 400c794:	e0bffd17 	ldw	r2,-12(fp)
 400c798:	10800017 	ldw	r2,0(r2)
 400c79c:	1000091e 	bne	r2,zero,400c7c4 <__sfp+0xc0>
	  (g->_next = __sfmoreglue (d, NDYNAMIC)) == NULL)
 400c7a0:	01400104 	movi	r5,4
 400c7a4:	e13ffc17 	ldw	r4,-16(fp)
 400c7a8:	400c6480 	call	400c648 <__sfmoreglue>
 400c7ac:	1007883a 	mov	r3,r2
 400c7b0:	e0bffd17 	ldw	r2,-12(fp)
 400c7b4:	10c00015 	stw	r3,0(r2)
 400c7b8:	e0bffd17 	ldw	r2,-12(fp)
 400c7bc:	10800017 	ldw	r2,0(r2)
      if (g->_next == NULL &&
 400c7c0:	10000426 	beq	r2,zero,400c7d4 <__sfp+0xd0>
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
 400c7c4:	e0bffd17 	ldw	r2,-12(fp)
 400c7c8:	10800017 	ldw	r2,0(r2)
 400c7cc:	e0bffd15 	stw	r2,-12(fp)
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
 400c7d0:	003fdb06 	br	400c740 <__sfp+0x3c>
	break;
 400c7d4:	0001883a 	nop
    }
  _newlib_sfp_lock_exit ();
 400c7d8:	400c9e40 	call	400c9e4 <__sfp_lock_release>
  d->_errno = ENOMEM;
 400c7dc:	e0bffc17 	ldw	r2,-16(fp)
 400c7e0:	00c00304 	movi	r3,12
 400c7e4:	10c00015 	stw	r3,0(r2)
  return NULL;
 400c7e8:	0005883a 	mov	r2,zero
 400c7ec:	00002506 	br	400c884 <__sfp+0x180>
	  goto found;
 400c7f0:	0001883a 	nop

found:
  fp->_file = -1;		/* no file */
 400c7f4:	e0bfff17 	ldw	r2,-4(fp)
 400c7f8:	00ffffc4 	movi	r3,-1
 400c7fc:	10c0038d 	sth	r3,14(r2)
  fp->_flags = 1;		/* reserve this slot; caller sets real flags */
 400c800:	e0bfff17 	ldw	r2,-4(fp)
 400c804:	00c00044 	movi	r3,1
 400c808:	10c0030d 	sth	r3,12(r2)
  fp->_flags2 = 0;
 400c80c:	e0bfff17 	ldw	r2,-4(fp)
 400c810:	10001915 	stw	zero,100(r2)
#ifndef __SINGLE_THREAD__
  __lock_init_recursive (fp->_lock);
#endif
  _newlib_sfp_lock_end ();
 400c814:	400c9e40 	call	400c9e4 <__sfp_lock_release>

  fp->_p = NULL;		/* no current pointer */
 400c818:	e0bfff17 	ldw	r2,-4(fp)
 400c81c:	10000015 	stw	zero,0(r2)
  fp->_w = 0;			/* nothing to read or write */
 400c820:	e0bfff17 	ldw	r2,-4(fp)
 400c824:	10000215 	stw	zero,8(r2)
  fp->_r = 0;
 400c828:	e0bfff17 	ldw	r2,-4(fp)
 400c82c:	10000115 	stw	zero,4(r2)
  fp->_bf._base = NULL;		/* no buffer */
 400c830:	e0bfff17 	ldw	r2,-4(fp)
 400c834:	10000415 	stw	zero,16(r2)
  fp->_bf._size = 0;
 400c838:	e0bfff17 	ldw	r2,-4(fp)
 400c83c:	10000515 	stw	zero,20(r2)
  fp->_lbfsize = 0;		/* not line buffered */
 400c840:	e0bfff17 	ldw	r2,-4(fp)
 400c844:	10000615 	stw	zero,24(r2)
  memset (&fp->_mbstate, 0, sizeof (_mbstate_t));
 400c848:	e0bfff17 	ldw	r2,-4(fp)
 400c84c:	10801704 	addi	r2,r2,92
 400c850:	01800204 	movi	r6,8
 400c854:	000b883a 	mov	r5,zero
 400c858:	1009883a 	mov	r4,r2
 400c85c:	40074880 	call	4007488 <memset>
  /* fp->_cookie = <any>; */	/* caller sets cookie, _read/_write etc */
  fp->_ub._base = NULL;		/* no ungetc buffer */
 400c860:	e0bfff17 	ldw	r2,-4(fp)
 400c864:	10000c15 	stw	zero,48(r2)
  fp->_ub._size = 0;
 400c868:	e0bfff17 	ldw	r2,-4(fp)
 400c86c:	10000d15 	stw	zero,52(r2)
  fp->_lb._base = NULL;		/* no line buffer */
 400c870:	e0bfff17 	ldw	r2,-4(fp)
 400c874:	10001115 	stw	zero,68(r2)
  fp->_lb._size = 0;
 400c878:	e0bfff17 	ldw	r2,-4(fp)
 400c87c:	10001215 	stw	zero,72(r2)

  return fp;
 400c880:	e0bfff17 	ldw	r2,-4(fp)
}
 400c884:	e037883a 	mov	sp,fp
 400c888:	dfc00117 	ldw	ra,4(sp)
 400c88c:	df000017 	ldw	fp,0(sp)
 400c890:	dec00204 	addi	sp,sp,8
 400c894:	f800283a 	ret

0400c898 <_cleanup_r>:
 * The name `_cleanup' is, alas, fairly well known outside stdio.
 */

void
_cleanup_r (struct _reent *ptr)
{
 400c898:	defffc04 	addi	sp,sp,-16
 400c89c:	dfc00315 	stw	ra,12(sp)
 400c8a0:	df000215 	stw	fp,8(sp)
 400c8a4:	df000204 	addi	fp,sp,8
 400c8a8:	e13ffe15 	stw	r4,-8(fp)
  /* Otherwise close files and flush read streams, too.
     Note we call flush directly if "--enable-lite-exit" is in effect.  */
#ifdef _LITE_EXIT
  cleanup_func = _fflush_r;
#else
  cleanup_func = _fclose_r;
 400c8ac:	00810074 	movhi	r2,1025
 400c8b0:	108cb104 	addi	r2,r2,12996
 400c8b4:	e0bfff15 	stw	r2,-4(fp)
  if (ptr->_stdout != &__sf[1])
    (*cleanup_func) (ptr, ptr->_stdout);
  if (ptr->_stderr != &__sf[2])
    (*cleanup_func) (ptr, ptr->_stderr);
#endif
  (void) _fwalk_reent (ptr, cleanup_func);
 400c8b8:	e17fff17 	ldw	r5,-4(fp)
 400c8bc:	e13ffe17 	ldw	r4,-8(fp)
 400c8c0:	400d8e80 	call	400d8e8 <_fwalk_reent>
}
 400c8c4:	0001883a 	nop
 400c8c8:	e037883a 	mov	sp,fp
 400c8cc:	dfc00117 	ldw	ra,4(sp)
 400c8d0:	df000017 	ldw	fp,0(sp)
 400c8d4:	dec00204 	addi	sp,sp,8
 400c8d8:	f800283a 	ret

0400c8dc <_cleanup>:

#ifndef _REENT_ONLY
void
_cleanup (void)
{
 400c8dc:	defffe04 	addi	sp,sp,-8
 400c8e0:	dfc00115 	stw	ra,4(sp)
 400c8e4:	df000015 	stw	fp,0(sp)
 400c8e8:	d839883a 	mov	fp,sp
  _cleanup_r (_GLOBAL_REENT);
 400c8ec:	d0a00217 	ldw	r2,-32760(gp)
 400c8f0:	1009883a 	mov	r4,r2
 400c8f4:	400c8980 	call	400c898 <_cleanup_r>
}
 400c8f8:	0001883a 	nop
 400c8fc:	e037883a 	mov	sp,fp
 400c900:	dfc00117 	ldw	ra,4(sp)
 400c904:	df000017 	ldw	fp,0(sp)
 400c908:	dec00204 	addi	sp,sp,8
 400c90c:	f800283a 	ret

0400c910 <__sinit>:
 * __sinit() is called whenever stdio's internal variables must be set up.
 */

void
__sinit (struct _reent *s)
{
 400c910:	defffd04 	addi	sp,sp,-12
 400c914:	dfc00215 	stw	ra,8(sp)
 400c918:	df000115 	stw	fp,4(sp)
 400c91c:	df000104 	addi	fp,sp,4
 400c920:	e13fff15 	stw	r4,-4(fp)
  __sinit_lock_acquire ();
 400c924:	400ca040 	call	400ca04 <__sinit_lock_acquire>

  if (s->__sdidinit)
 400c928:	e0bfff17 	ldw	r2,-4(fp)
 400c92c:	10800e17 	ldw	r2,56(r2)
 400c930:	10000226 	beq	r2,zero,400c93c <__sinit+0x2c>
    {
      __sinit_lock_release ();
 400c934:	400ca240 	call	400ca24 <__sinit_lock_release>
      return;
 400c938:	00001d06 	br	400c9b0 <__sinit+0xa0>
    }

  /* make sure we clean up on exit */
  s->__cleanup = _cleanup_r;	/* conservative */
 400c93c:	e0ffff17 	ldw	r3,-4(fp)
 400c940:	00810074 	movhi	r2,1025
 400c944:	10b22604 	addi	r2,r2,-14184
 400c948:	18800f15 	stw	r2,60(r3)

  s->__sglue._next = NULL;
 400c94c:	e0bfff17 	ldw	r2,-4(fp)
 400c950:	1000b815 	stw	zero,736(r2)
#ifndef _REENT_SMALL
# ifndef _REENT_GLOBAL_STDIO_STREAMS
  s->__sglue._niobs = 3;
 400c954:	e0bfff17 	ldw	r2,-4(fp)
 400c958:	00c000c4 	movi	r3,3
 400c95c:	10c0b915 	stw	r3,740(r2)
  s->__sglue._iobs = &s->__sf[0];
 400c960:	e0bfff17 	ldw	r2,-4(fp)
 400c964:	10c0bb04 	addi	r3,r2,748
 400c968:	e0bfff17 	ldw	r2,-4(fp)
 400c96c:	10c0ba15 	stw	r3,744(r2)
    stdin_init (&__sf[0]);
    stdout_init (&__sf[1]);
    stderr_init (&__sf[2]);
  }
#else /* _REENT_GLOBAL_STDIO_STREAMS */
  stdin_init (s->_stdin);
 400c970:	e0bfff17 	ldw	r2,-4(fp)
 400c974:	10800117 	ldw	r2,4(r2)
 400c978:	1009883a 	mov	r4,r2
 400c97c:	400c5940 	call	400c594 <stdin_init>
  stdout_init (s->_stdout);
 400c980:	e0bfff17 	ldw	r2,-4(fp)
 400c984:	10800217 	ldw	r2,8(r2)
 400c988:	1009883a 	mov	r4,r2
 400c98c:	400c5d00 	call	400c5d0 <stdout_init>
  stderr_init (s->_stderr);
 400c990:	e0bfff17 	ldw	r2,-4(fp)
 400c994:	10800317 	ldw	r2,12(r2)
 400c998:	1009883a 	mov	r4,r2
 400c99c:	400c60c0 	call	400c60c <stderr_init>
#endif /* _REENT_GLOBAL_STDIO_STREAMS */

  s->__sdidinit = 1;
 400c9a0:	e0bfff17 	ldw	r2,-4(fp)
 400c9a4:	00c00044 	movi	r3,1
 400c9a8:	10c00e15 	stw	r3,56(r2)

  __sinit_lock_release ();
 400c9ac:	400ca240 	call	400ca24 <__sinit_lock_release>
}
 400c9b0:	e037883a 	mov	sp,fp
 400c9b4:	dfc00117 	ldw	ra,4(sp)
 400c9b8:	df000017 	ldw	fp,0(sp)
 400c9bc:	dec00204 	addi	sp,sp,8
 400c9c0:	f800283a 	ret

0400c9c4 <__sfp_lock_acquire>:
__LOCK_INIT_RECURSIVE(static, __sfp_recursive_mutex);
__LOCK_INIT_RECURSIVE(static, __sinit_recursive_mutex);

void
__sfp_lock_acquire (void)
{
 400c9c4:	deffff04 	addi	sp,sp,-4
 400c9c8:	df000015 	stw	fp,0(sp)
 400c9cc:	d839883a 	mov	fp,sp
  __lock_acquire_recursive (__sfp_recursive_mutex);
}
 400c9d0:	0001883a 	nop
 400c9d4:	e037883a 	mov	sp,fp
 400c9d8:	df000017 	ldw	fp,0(sp)
 400c9dc:	dec00104 	addi	sp,sp,4
 400c9e0:	f800283a 	ret

0400c9e4 <__sfp_lock_release>:

void
__sfp_lock_release (void)
{
 400c9e4:	deffff04 	addi	sp,sp,-4
 400c9e8:	df000015 	stw	fp,0(sp)
 400c9ec:	d839883a 	mov	fp,sp
  __lock_release_recursive (__sfp_recursive_mutex);
}
 400c9f0:	0001883a 	nop
 400c9f4:	e037883a 	mov	sp,fp
 400c9f8:	df000017 	ldw	fp,0(sp)
 400c9fc:	dec00104 	addi	sp,sp,4
 400ca00:	f800283a 	ret

0400ca04 <__sinit_lock_acquire>:

void
__sinit_lock_acquire (void)
{
 400ca04:	deffff04 	addi	sp,sp,-4
 400ca08:	df000015 	stw	fp,0(sp)
 400ca0c:	d839883a 	mov	fp,sp
  __lock_acquire_recursive (__sinit_recursive_mutex);
}
 400ca10:	0001883a 	nop
 400ca14:	e037883a 	mov	sp,fp
 400ca18:	df000017 	ldw	fp,0(sp)
 400ca1c:	dec00104 	addi	sp,sp,4
 400ca20:	f800283a 	ret

0400ca24 <__sinit_lock_release>:

void
__sinit_lock_release (void)
{
 400ca24:	deffff04 	addi	sp,sp,-4
 400ca28:	df000015 	stw	fp,0(sp)
 400ca2c:	d839883a 	mov	fp,sp
  __lock_release_recursive (__sinit_recursive_mutex);
}
 400ca30:	0001883a 	nop
 400ca34:	e037883a 	mov	sp,fp
 400ca38:	df000017 	ldw	fp,0(sp)
 400ca3c:	dec00104 	addi	sp,sp,4
 400ca40:	f800283a 	ret

0400ca44 <__fp_lock>:

/* Walkable file locking routine.  */
static int
__fp_lock (FILE * ptr)
{
 400ca44:	defffe04 	addi	sp,sp,-8
 400ca48:	df000115 	stw	fp,4(sp)
 400ca4c:	df000104 	addi	fp,sp,4
 400ca50:	e13fff15 	stw	r4,-4(fp)
  if (!(ptr->_flags2 & __SNLK))
    _flockfile (ptr);

  return 0;
 400ca54:	0005883a 	mov	r2,zero
}
 400ca58:	e037883a 	mov	sp,fp
 400ca5c:	df000017 	ldw	fp,0(sp)
 400ca60:	dec00104 	addi	sp,sp,4
 400ca64:	f800283a 	ret

0400ca68 <__fp_unlock>:

/* Walkable file unlocking routine.  */
static int
__fp_unlock (FILE * ptr)
{
 400ca68:	defffe04 	addi	sp,sp,-8
 400ca6c:	df000115 	stw	fp,4(sp)
 400ca70:	df000104 	addi	fp,sp,4
 400ca74:	e13fff15 	stw	r4,-4(fp)
  if (!(ptr->_flags2 & __SNLK))
    _funlockfile (ptr);

  return 0;
 400ca78:	0005883a 	mov	r2,zero
}
 400ca7c:	e037883a 	mov	sp,fp
 400ca80:	df000017 	ldw	fp,0(sp)
 400ca84:	dec00104 	addi	sp,sp,4
 400ca88:	f800283a 	ret

0400ca8c <__fp_lock_all>:

void
__fp_lock_all (void)
{
 400ca8c:	defffe04 	addi	sp,sp,-8
 400ca90:	dfc00115 	stw	ra,4(sp)
 400ca94:	df000015 	stw	fp,0(sp)
 400ca98:	d839883a 	mov	fp,sp
  __sfp_lock_acquire ();
 400ca9c:	400c9c40 	call	400c9c4 <__sfp_lock_acquire>

  (void) _fwalk (_REENT, __fp_lock);
 400caa0:	d0a00117 	ldw	r2,-32764(gp)
 400caa4:	01410074 	movhi	r5,1025
 400caa8:	29729104 	addi	r5,r5,-13756
 400caac:	1009883a 	mov	r4,r2
 400cab0:	400d8100 	call	400d810 <_fwalk>
}
 400cab4:	0001883a 	nop
 400cab8:	e037883a 	mov	sp,fp
 400cabc:	dfc00117 	ldw	ra,4(sp)
 400cac0:	df000017 	ldw	fp,0(sp)
 400cac4:	dec00204 	addi	sp,sp,8
 400cac8:	f800283a 	ret

0400cacc <__fp_unlock_all>:

void
__fp_unlock_all (void)
{
 400cacc:	defffe04 	addi	sp,sp,-8
 400cad0:	dfc00115 	stw	ra,4(sp)
 400cad4:	df000015 	stw	fp,0(sp)
 400cad8:	d839883a 	mov	fp,sp
  (void) _fwalk (_REENT, __fp_unlock);
 400cadc:	d0a00117 	ldw	r2,-32764(gp)
 400cae0:	01410074 	movhi	r5,1025
 400cae4:	29729a04 	addi	r5,r5,-13720
 400cae8:	1009883a 	mov	r4,r2
 400caec:	400d8100 	call	400d810 <_fwalk>

  __sfp_lock_release ();
 400caf0:	400c9e40 	call	400c9e4 <__sfp_lock_release>
}
 400caf4:	0001883a 	nop
 400caf8:	e037883a 	mov	sp,fp
 400cafc:	dfc00117 	ldw	ra,4(sp)
 400cb00:	df000017 	ldw	fp,0(sp)
 400cb04:	dec00204 	addi	sp,sp,8
 400cb08:	f800283a 	ret

0400cb0c <_free_r>:
#if __STD_C
void fREe(RARG Void_t* mem)
#else
void fREe(RARG mem) RDECL Void_t* mem;
#endif
{
 400cb0c:	defff204 	addi	sp,sp,-56
 400cb10:	dfc00d15 	stw	ra,52(sp)
 400cb14:	df000c15 	stw	fp,48(sp)
 400cb18:	df000c04 	addi	fp,sp,48
 400cb1c:	e13ff515 	stw	r4,-44(fp)
 400cb20:	e17ff415 	stw	r5,-48(fp)
  INTERNAL_SIZE_T prevsz; /* size of previous contiguous chunk */
  mchunkptr bck;       /* misc temp for linking */
  mchunkptr fwd;       /* misc temp for linking */
  int       islr;      /* track whether merging with last_remainder */

  if (mem == 0)                              /* free(0) has no effect */
 400cb24:	e0bff417 	ldw	r2,-48(fp)
 400cb28:	10014826 	beq	r2,zero,400d04c <_free_r+0x540>
    return;

  MALLOC_LOCK;
 400cb2c:	e13ff517 	ldw	r4,-44(fp)
 400cb30:	40186a00 	call	40186a0 <__malloc_lock>

  p = mem2chunk(mem);
 400cb34:	e0bff417 	ldw	r2,-48(fp)
 400cb38:	10bffe04 	addi	r2,r2,-8
 400cb3c:	e0bfff15 	stw	r2,-4(fp)
  hd = p->size;
 400cb40:	e0bfff17 	ldw	r2,-4(fp)
 400cb44:	10800117 	ldw	r2,4(r2)
 400cb48:	e0bffa15 	stw	r2,-24(fp)
  }
#endif
  
  check_inuse_chunk(p);
  
  sz = hd & ~PREV_INUSE;
 400cb4c:	e0fffa17 	ldw	r3,-24(fp)
 400cb50:	00bfff84 	movi	r2,-2
 400cb54:	1884703a 	and	r2,r3,r2
 400cb58:	e0bffe15 	stw	r2,-8(fp)
  next = chunk_at_offset(p, sz);
 400cb5c:	e0ffff17 	ldw	r3,-4(fp)
 400cb60:	e0bffe17 	ldw	r2,-8(fp)
 400cb64:	1885883a 	add	r2,r3,r2
 400cb68:	e0bff915 	stw	r2,-28(fp)
  nextsz = chunksize(next);
 400cb6c:	e0bff917 	ldw	r2,-28(fp)
 400cb70:	10c00117 	ldw	r3,4(r2)
 400cb74:	00bfff04 	movi	r2,-4
 400cb78:	1884703a 	and	r2,r3,r2
 400cb7c:	e0bff815 	stw	r2,-32(fp)
  
  if (next == top)                            /* merge with top */
 400cb80:	008100b4 	movhi	r2,1026
 400cb84:	10ad9404 	addi	r2,r2,-18864
 400cb88:	10800217 	ldw	r2,8(r2)
 400cb8c:	e0fff917 	ldw	r3,-28(fp)
 400cb90:	1880311e 	bne	r3,r2,400cc58 <_free_r+0x14c>
  {
    sz += nextsz;
 400cb94:	e0fffe17 	ldw	r3,-8(fp)
 400cb98:	e0bff817 	ldw	r2,-32(fp)
 400cb9c:	1885883a 	add	r2,r3,r2
 400cba0:	e0bffe15 	stw	r2,-8(fp)

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
 400cba4:	e0bffa17 	ldw	r2,-24(fp)
 400cba8:	1080004c 	andi	r2,r2,1
 400cbac:	1000181e 	bne	r2,zero,400cc10 <_free_r+0x104>
    {
      prevsz = p->prev_size;
 400cbb0:	e0bfff17 	ldw	r2,-4(fp)
 400cbb4:	10800017 	ldw	r2,0(r2)
 400cbb8:	e0bff715 	stw	r2,-36(fp)
      p = chunk_at_offset(p, -prevsz);
 400cbbc:	e0bff717 	ldw	r2,-36(fp)
 400cbc0:	0085c83a 	sub	r2,zero,r2
 400cbc4:	e0ffff17 	ldw	r3,-4(fp)
 400cbc8:	1885883a 	add	r2,r3,r2
 400cbcc:	e0bfff15 	stw	r2,-4(fp)
      sz += prevsz;
 400cbd0:	e0fffe17 	ldw	r3,-8(fp)
 400cbd4:	e0bff717 	ldw	r2,-36(fp)
 400cbd8:	1885883a 	add	r2,r3,r2
 400cbdc:	e0bffe15 	stw	r2,-8(fp)
      unlink(p, bck, fwd);
 400cbe0:	e0bfff17 	ldw	r2,-4(fp)
 400cbe4:	10800317 	ldw	r2,12(r2)
 400cbe8:	e0bffd15 	stw	r2,-12(fp)
 400cbec:	e0bfff17 	ldw	r2,-4(fp)
 400cbf0:	10800217 	ldw	r2,8(r2)
 400cbf4:	e0bffc15 	stw	r2,-16(fp)
 400cbf8:	e0bffc17 	ldw	r2,-16(fp)
 400cbfc:	e0fffd17 	ldw	r3,-12(fp)
 400cc00:	10c00315 	stw	r3,12(r2)
 400cc04:	e0bffd17 	ldw	r2,-12(fp)
 400cc08:	e0fffc17 	ldw	r3,-16(fp)
 400cc0c:	10c00215 	stw	r3,8(r2)
    }

    set_head(p, sz | PREV_INUSE);
 400cc10:	e0bffe17 	ldw	r2,-8(fp)
 400cc14:	10c00054 	ori	r3,r2,1
 400cc18:	e0bfff17 	ldw	r2,-4(fp)
 400cc1c:	10c00115 	stw	r3,4(r2)
    top = p;
 400cc20:	008100b4 	movhi	r2,1026
 400cc24:	10ad9404 	addi	r2,r2,-18864
 400cc28:	e0ffff17 	ldw	r3,-4(fp)
 400cc2c:	10c00215 	stw	r3,8(r2)
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold) 
 400cc30:	d0a00317 	ldw	r2,-32756(gp)
 400cc34:	e0fffe17 	ldw	r3,-8(fp)
 400cc38:	18800436 	bltu	r3,r2,400cc4c <_free_r+0x140>
      malloc_trim(RCALL top_pad); 
 400cc3c:	d0a72417 	ldw	r2,-25456(gp)
 400cc40:	100b883a 	mov	r5,r2
 400cc44:	e13ff517 	ldw	r4,-44(fp)
 400cc48:	400d0640 	call	400d064 <_malloc_trim_r>
    MALLOC_UNLOCK;
 400cc4c:	e13ff517 	ldw	r4,-44(fp)
 400cc50:	40186c40 	call	40186c4 <__malloc_unlock>
    return;
 400cc54:	0000fe06 	br	400d050 <_free_r+0x544>
  }

  set_head(next, nextsz);                    /* clear inuse bit */
 400cc58:	e0bff917 	ldw	r2,-28(fp)
 400cc5c:	e0fff817 	ldw	r3,-32(fp)
 400cc60:	10c00115 	stw	r3,4(r2)

  islr = 0;
 400cc64:	e03ffb15 	stw	zero,-20(fp)

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
 400cc68:	e0bffa17 	ldw	r2,-24(fp)
 400cc6c:	1080004c 	andi	r2,r2,1
 400cc70:	1000201e 	bne	r2,zero,400ccf4 <_free_r+0x1e8>
  {
    prevsz = p->prev_size;
 400cc74:	e0bfff17 	ldw	r2,-4(fp)
 400cc78:	10800017 	ldw	r2,0(r2)
 400cc7c:	e0bff715 	stw	r2,-36(fp)
    p = chunk_at_offset(p, -prevsz);
 400cc80:	e0bff717 	ldw	r2,-36(fp)
 400cc84:	0085c83a 	sub	r2,zero,r2
 400cc88:	e0ffff17 	ldw	r3,-4(fp)
 400cc8c:	1885883a 	add	r2,r3,r2
 400cc90:	e0bfff15 	stw	r2,-4(fp)
    sz += prevsz;
 400cc94:	e0fffe17 	ldw	r3,-8(fp)
 400cc98:	e0bff717 	ldw	r2,-36(fp)
 400cc9c:	1885883a 	add	r2,r3,r2
 400cca0:	e0bffe15 	stw	r2,-8(fp)
    
    if (p->fd == last_remainder)             /* keep as last_remainder */
 400cca4:	e0bfff17 	ldw	r2,-4(fp)
 400cca8:	10c00217 	ldw	r3,8(r2)
 400ccac:	008100b4 	movhi	r2,1026
 400ccb0:	10ad9604 	addi	r2,r2,-18856
 400ccb4:	1880031e 	bne	r3,r2,400ccc4 <_free_r+0x1b8>
      islr = 1;
 400ccb8:	00800044 	movi	r2,1
 400ccbc:	e0bffb15 	stw	r2,-20(fp)
 400ccc0:	00000c06 	br	400ccf4 <_free_r+0x1e8>
    else
      unlink(p, bck, fwd);
 400ccc4:	e0bfff17 	ldw	r2,-4(fp)
 400ccc8:	10800317 	ldw	r2,12(r2)
 400cccc:	e0bffd15 	stw	r2,-12(fp)
 400ccd0:	e0bfff17 	ldw	r2,-4(fp)
 400ccd4:	10800217 	ldw	r2,8(r2)
 400ccd8:	e0bffc15 	stw	r2,-16(fp)
 400ccdc:	e0bffc17 	ldw	r2,-16(fp)
 400cce0:	e0fffd17 	ldw	r3,-12(fp)
 400cce4:	10c00315 	stw	r3,12(r2)
 400cce8:	e0bffd17 	ldw	r2,-12(fp)
 400ccec:	e0fffc17 	ldw	r3,-16(fp)
 400ccf0:	10c00215 	stw	r3,8(r2)
  }
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
 400ccf4:	e0fff917 	ldw	r3,-28(fp)
 400ccf8:	e0bff817 	ldw	r2,-32(fp)
 400ccfc:	1885883a 	add	r2,r3,r2
 400cd00:	10800117 	ldw	r2,4(r2)
 400cd04:	1080004c 	andi	r2,r2,1
 400cd08:	10002a1e 	bne	r2,zero,400cdb4 <_free_r+0x2a8>
  {
    sz += nextsz;
 400cd0c:	e0fffe17 	ldw	r3,-8(fp)
 400cd10:	e0bff817 	ldw	r2,-32(fp)
 400cd14:	1885883a 	add	r2,r3,r2
 400cd18:	e0bffe15 	stw	r2,-8(fp)
    
    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
 400cd1c:	e0bffb17 	ldw	r2,-20(fp)
 400cd20:	1000181e 	bne	r2,zero,400cd84 <_free_r+0x278>
 400cd24:	e0bff917 	ldw	r2,-28(fp)
 400cd28:	10c00217 	ldw	r3,8(r2)
 400cd2c:	008100b4 	movhi	r2,1026
 400cd30:	10ad9604 	addi	r2,r2,-18856
 400cd34:	1880131e 	bne	r3,r2,400cd84 <_free_r+0x278>
    {
      islr = 1;
 400cd38:	00800044 	movi	r2,1
 400cd3c:	e0bffb15 	stw	r2,-20(fp)
      link_last_remainder(p);   
 400cd40:	008100b4 	movhi	r2,1026
 400cd44:	10ad9604 	addi	r2,r2,-18856
 400cd48:	e0ffff17 	ldw	r3,-4(fp)
 400cd4c:	10c00315 	stw	r3,12(r2)
 400cd50:	00c100b4 	movhi	r3,1026
 400cd54:	18ed9604 	addi	r3,r3,-18856
 400cd58:	10800317 	ldw	r2,12(r2)
 400cd5c:	18800215 	stw	r2,8(r3)
 400cd60:	008100b4 	movhi	r2,1026
 400cd64:	10ad9604 	addi	r2,r2,-18856
 400cd68:	e0ffff17 	ldw	r3,-4(fp)
 400cd6c:	18800315 	stw	r2,12(r3)
 400cd70:	e0bfff17 	ldw	r2,-4(fp)
 400cd74:	10c00317 	ldw	r3,12(r2)
 400cd78:	e0bfff17 	ldw	r2,-4(fp)
 400cd7c:	10c00215 	stw	r3,8(r2)
 400cd80:	00000c06 	br	400cdb4 <_free_r+0x2a8>
    }
    else
      unlink(next, bck, fwd);
 400cd84:	e0bff917 	ldw	r2,-28(fp)
 400cd88:	10800317 	ldw	r2,12(r2)
 400cd8c:	e0bffd15 	stw	r2,-12(fp)
 400cd90:	e0bff917 	ldw	r2,-28(fp)
 400cd94:	10800217 	ldw	r2,8(r2)
 400cd98:	e0bffc15 	stw	r2,-16(fp)
 400cd9c:	e0bffc17 	ldw	r2,-16(fp)
 400cda0:	e0fffd17 	ldw	r3,-12(fp)
 400cda4:	10c00315 	stw	r3,12(r2)
 400cda8:	e0bffd17 	ldw	r2,-12(fp)
 400cdac:	e0fffc17 	ldw	r3,-16(fp)
 400cdb0:	10c00215 	stw	r3,8(r2)
  }


  set_head(p, sz | PREV_INUSE);
 400cdb4:	e0bffe17 	ldw	r2,-8(fp)
 400cdb8:	10c00054 	ori	r3,r2,1
 400cdbc:	e0bfff17 	ldw	r2,-4(fp)
 400cdc0:	10c00115 	stw	r3,4(r2)
  set_foot(p, sz);
 400cdc4:	e0ffff17 	ldw	r3,-4(fp)
 400cdc8:	e0bffe17 	ldw	r2,-8(fp)
 400cdcc:	1885883a 	add	r2,r3,r2
 400cdd0:	e0fffe17 	ldw	r3,-8(fp)
 400cdd4:	10c00015 	stw	r3,0(r2)
  if (!islr)
 400cdd8:	e0bffb17 	ldw	r2,-20(fp)
 400cddc:	1000981e 	bne	r2,zero,400d040 <_free_r+0x534>
    frontlink(p, sz, idx, bck, fwd);  
 400cde0:	e0bffe17 	ldw	r2,-8(fp)
 400cde4:	10808028 	cmpgeui	r2,r2,512
 400cde8:	10002b1e 	bne	r2,zero,400ce98 <_free_r+0x38c>
 400cdec:	e0bffe17 	ldw	r2,-8(fp)
 400cdf0:	1004d0fa 	srli	r2,r2,3
 400cdf4:	e0bff615 	stw	r2,-40(fp)
 400cdf8:	008100b4 	movhi	r2,1026
 400cdfc:	10ad9404 	addi	r2,r2,-18864
 400ce00:	11000117 	ldw	r4,4(r2)
 400ce04:	e0bff617 	ldw	r2,-40(fp)
 400ce08:	1000010e 	bge	r2,zero,400ce10 <_free_r+0x304>
 400ce0c:	108000c4 	addi	r2,r2,3
 400ce10:	1005d0ba 	srai	r2,r2,2
 400ce14:	1007883a 	mov	r3,r2
 400ce18:	00800044 	movi	r2,1
 400ce1c:	10c6983a 	sll	r3,r2,r3
 400ce20:	008100b4 	movhi	r2,1026
 400ce24:	10ad9404 	addi	r2,r2,-18864
 400ce28:	20c6b03a 	or	r3,r4,r3
 400ce2c:	10c00115 	stw	r3,4(r2)
 400ce30:	e0bff617 	ldw	r2,-40(fp)
 400ce34:	10800044 	addi	r2,r2,1
 400ce38:	1085883a 	add	r2,r2,r2
 400ce3c:	100690ba 	slli	r3,r2,2
 400ce40:	008100b4 	movhi	r2,1026
 400ce44:	10ad9404 	addi	r2,r2,-18864
 400ce48:	1885883a 	add	r2,r3,r2
 400ce4c:	10bffe04 	addi	r2,r2,-8
 400ce50:	e0bffd15 	stw	r2,-12(fp)
 400ce54:	e0bffd17 	ldw	r2,-12(fp)
 400ce58:	10800217 	ldw	r2,8(r2)
 400ce5c:	e0bffc15 	stw	r2,-16(fp)
 400ce60:	e0bfff17 	ldw	r2,-4(fp)
 400ce64:	e0fffd17 	ldw	r3,-12(fp)
 400ce68:	10c00315 	stw	r3,12(r2)
 400ce6c:	e0bfff17 	ldw	r2,-4(fp)
 400ce70:	e0fffc17 	ldw	r3,-16(fp)
 400ce74:	10c00215 	stw	r3,8(r2)
 400ce78:	e0bffd17 	ldw	r2,-12(fp)
 400ce7c:	e0ffff17 	ldw	r3,-4(fp)
 400ce80:	10c00215 	stw	r3,8(r2)
 400ce84:	e0bffd17 	ldw	r2,-12(fp)
 400ce88:	10c00217 	ldw	r3,8(r2)
 400ce8c:	e0bffc17 	ldw	r2,-16(fp)
 400ce90:	10c00315 	stw	r3,12(r2)
 400ce94:	00006a06 	br	400d040 <_free_r+0x534>
 400ce98:	e0bffe17 	ldw	r2,-8(fp)
 400ce9c:	1004d27a 	srli	r2,r2,9
 400cea0:	1000031e 	bne	r2,zero,400ceb0 <_free_r+0x3a4>
 400cea4:	e0bffe17 	ldw	r2,-8(fp)
 400cea8:	1004d0fa 	srli	r2,r2,3
 400ceac:	00002906 	br	400cf54 <_free_r+0x448>
 400ceb0:	e0bffe17 	ldw	r2,-8(fp)
 400ceb4:	1004d27a 	srli	r2,r2,9
 400ceb8:	10800168 	cmpgeui	r2,r2,5
 400cebc:	1000041e 	bne	r2,zero,400ced0 <_free_r+0x3c4>
 400cec0:	e0bffe17 	ldw	r2,-8(fp)
 400cec4:	1004d1ba 	srli	r2,r2,6
 400cec8:	10800e04 	addi	r2,r2,56
 400cecc:	00002106 	br	400cf54 <_free_r+0x448>
 400ced0:	e0bffe17 	ldw	r2,-8(fp)
 400ced4:	1004d27a 	srli	r2,r2,9
 400ced8:	10800568 	cmpgeui	r2,r2,21
 400cedc:	1000041e 	bne	r2,zero,400cef0 <_free_r+0x3e4>
 400cee0:	e0bffe17 	ldw	r2,-8(fp)
 400cee4:	1004d27a 	srli	r2,r2,9
 400cee8:	108016c4 	addi	r2,r2,91
 400ceec:	00001906 	br	400cf54 <_free_r+0x448>
 400cef0:	e0bffe17 	ldw	r2,-8(fp)
 400cef4:	1004d27a 	srli	r2,r2,9
 400cef8:	10801568 	cmpgeui	r2,r2,85
 400cefc:	1000041e 	bne	r2,zero,400cf10 <_free_r+0x404>
 400cf00:	e0bffe17 	ldw	r2,-8(fp)
 400cf04:	1004d33a 	srli	r2,r2,12
 400cf08:	10801b84 	addi	r2,r2,110
 400cf0c:	00001106 	br	400cf54 <_free_r+0x448>
 400cf10:	e0bffe17 	ldw	r2,-8(fp)
 400cf14:	1004d27a 	srli	r2,r2,9
 400cf18:	10805568 	cmpgeui	r2,r2,341
 400cf1c:	1000041e 	bne	r2,zero,400cf30 <_free_r+0x424>
 400cf20:	e0bffe17 	ldw	r2,-8(fp)
 400cf24:	1004d3fa 	srli	r2,r2,15
 400cf28:	10801dc4 	addi	r2,r2,119
 400cf2c:	00000906 	br	400cf54 <_free_r+0x448>
 400cf30:	e0bffe17 	ldw	r2,-8(fp)
 400cf34:	1004d27a 	srli	r2,r2,9
 400cf38:	10815568 	cmpgeui	r2,r2,1365
 400cf3c:	1000041e 	bne	r2,zero,400cf50 <_free_r+0x444>
 400cf40:	e0bffe17 	ldw	r2,-8(fp)
 400cf44:	1004d4ba 	srli	r2,r2,18
 400cf48:	10801f04 	addi	r2,r2,124
 400cf4c:	00000106 	br	400cf54 <_free_r+0x448>
 400cf50:	00801f84 	movi	r2,126
 400cf54:	e0bff615 	stw	r2,-40(fp)
 400cf58:	e0bff617 	ldw	r2,-40(fp)
 400cf5c:	10800044 	addi	r2,r2,1
 400cf60:	1085883a 	add	r2,r2,r2
 400cf64:	100690ba 	slli	r3,r2,2
 400cf68:	008100b4 	movhi	r2,1026
 400cf6c:	10ad9404 	addi	r2,r2,-18864
 400cf70:	1885883a 	add	r2,r3,r2
 400cf74:	10bffe04 	addi	r2,r2,-8
 400cf78:	e0bffd15 	stw	r2,-12(fp)
 400cf7c:	e0bffd17 	ldw	r2,-12(fp)
 400cf80:	10800217 	ldw	r2,8(r2)
 400cf84:	e0bffc15 	stw	r2,-16(fp)
 400cf88:	e0fffc17 	ldw	r3,-16(fp)
 400cf8c:	e0bffd17 	ldw	r2,-12(fp)
 400cf90:	1880121e 	bne	r3,r2,400cfdc <_free_r+0x4d0>
 400cf94:	008100b4 	movhi	r2,1026
 400cf98:	10ad9404 	addi	r2,r2,-18864
 400cf9c:	11000117 	ldw	r4,4(r2)
 400cfa0:	e0bff617 	ldw	r2,-40(fp)
 400cfa4:	1000010e 	bge	r2,zero,400cfac <_free_r+0x4a0>
 400cfa8:	108000c4 	addi	r2,r2,3
 400cfac:	1005d0ba 	srai	r2,r2,2
 400cfb0:	1007883a 	mov	r3,r2
 400cfb4:	00800044 	movi	r2,1
 400cfb8:	10c6983a 	sll	r3,r2,r3
 400cfbc:	008100b4 	movhi	r2,1026
 400cfc0:	10ad9404 	addi	r2,r2,-18864
 400cfc4:	20c6b03a 	or	r3,r4,r3
 400cfc8:	10c00115 	stw	r3,4(r2)
 400cfcc:	00000f06 	br	400d00c <_free_r+0x500>
 400cfd0:	e0bffc17 	ldw	r2,-16(fp)
 400cfd4:	10800217 	ldw	r2,8(r2)
 400cfd8:	e0bffc15 	stw	r2,-16(fp)
 400cfdc:	e0fffc17 	ldw	r3,-16(fp)
 400cfe0:	e0bffd17 	ldw	r2,-12(fp)
 400cfe4:	18800626 	beq	r3,r2,400d000 <_free_r+0x4f4>
 400cfe8:	e0bffc17 	ldw	r2,-16(fp)
 400cfec:	10c00117 	ldw	r3,4(r2)
 400cff0:	00bfff04 	movi	r2,-4
 400cff4:	1884703a 	and	r2,r3,r2
 400cff8:	e0fffe17 	ldw	r3,-8(fp)
 400cffc:	18bff436 	bltu	r3,r2,400cfd0 <_free_r+0x4c4>
 400d000:	e0bffc17 	ldw	r2,-16(fp)
 400d004:	10800317 	ldw	r2,12(r2)
 400d008:	e0bffd15 	stw	r2,-12(fp)
 400d00c:	e0bfff17 	ldw	r2,-4(fp)
 400d010:	e0fffd17 	ldw	r3,-12(fp)
 400d014:	10c00315 	stw	r3,12(r2)
 400d018:	e0bfff17 	ldw	r2,-4(fp)
 400d01c:	e0fffc17 	ldw	r3,-16(fp)
 400d020:	10c00215 	stw	r3,8(r2)
 400d024:	e0bffd17 	ldw	r2,-12(fp)
 400d028:	e0ffff17 	ldw	r3,-4(fp)
 400d02c:	10c00215 	stw	r3,8(r2)
 400d030:	e0bffd17 	ldw	r2,-12(fp)
 400d034:	10c00217 	ldw	r3,8(r2)
 400d038:	e0bffc17 	ldw	r2,-16(fp)
 400d03c:	10c00315 	stw	r3,12(r2)

  MALLOC_UNLOCK;
 400d040:	e13ff517 	ldw	r4,-44(fp)
 400d044:	40186c40 	call	40186c4 <__malloc_unlock>
 400d048:	00000106 	br	400d050 <_free_r+0x544>
    return;
 400d04c:	0001883a 	nop

#endif /* MALLOC_PROVIDED */
}
 400d050:	e037883a 	mov	sp,fp
 400d054:	dfc00117 	ldw	ra,4(sp)
 400d058:	df000017 	ldw	fp,0(sp)
 400d05c:	dec00204 	addi	sp,sp,8
 400d060:	f800283a 	ret

0400d064 <_malloc_trim_r>:
#if __STD_C
int malloc_trim(RARG size_t pad)
#else
int malloc_trim(RARG pad) RDECL size_t pad;
#endif
{
 400d064:	defff704 	addi	sp,sp,-36
 400d068:	dfc00815 	stw	ra,32(sp)
 400d06c:	df000715 	stw	fp,28(sp)
 400d070:	df000704 	addi	fp,sp,28
 400d074:	e13ffa15 	stw	r4,-24(fp)
 400d078:	e17ff915 	stw	r5,-28(fp)
  long  top_size;        /* Amount of top-most memory */
  long  extra;           /* Amount to release */
  char* current_brk;     /* address returned by pre-check sbrk call */
  char* new_brk;         /* address returned by negative sbrk call */

  unsigned long pagesz = malloc_getpagesize;
 400d07c:	00840004 	movi	r2,4096
 400d080:	e0bfff15 	stw	r2,-4(fp)

  MALLOC_LOCK;
 400d084:	e13ffa17 	ldw	r4,-24(fp)
 400d088:	40186a00 	call	40186a0 <__malloc_lock>

  top_size = chunksize(top);
 400d08c:	008100b4 	movhi	r2,1026
 400d090:	10ad9404 	addi	r2,r2,-18864
 400d094:	10800217 	ldw	r2,8(r2)
 400d098:	10800117 	ldw	r2,4(r2)
 400d09c:	1007883a 	mov	r3,r2
 400d0a0:	00bfff04 	movi	r2,-4
 400d0a4:	1884703a 	and	r2,r3,r2
 400d0a8:	e0bffe15 	stw	r2,-8(fp)
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;
 400d0ac:	e0fffe17 	ldw	r3,-8(fp)
 400d0b0:	e0bff917 	ldw	r2,-28(fp)
 400d0b4:	1887c83a 	sub	r3,r3,r2
 400d0b8:	e0bfff17 	ldw	r2,-4(fp)
 400d0bc:	1885883a 	add	r2,r3,r2
 400d0c0:	10bffbc4 	addi	r2,r2,-17
 400d0c4:	e17fff17 	ldw	r5,-4(fp)
 400d0c8:	1009883a 	mov	r4,r2
 400d0cc:	40153800 	call	4015380 <__udivsi3>
 400d0d0:	10bfffc4 	addi	r2,r2,-1
 400d0d4:	e17fff17 	ldw	r5,-4(fp)
 400d0d8:	1009883a 	mov	r4,r2
 400d0dc:	40072d80 	call	40072d8 <__mulsi3>
 400d0e0:	e0bffd15 	stw	r2,-12(fp)

  if (extra < (long)pagesz)  /* Not enough memory to release */
 400d0e4:	e0bfff17 	ldw	r2,-4(fp)
 400d0e8:	e0fffd17 	ldw	r3,-12(fp)
 400d0ec:	1880040e 	bge	r3,r2,400d100 <_malloc_trim_r+0x9c>
  {
    MALLOC_UNLOCK;
 400d0f0:	e13ffa17 	ldw	r4,-24(fp)
 400d0f4:	40186c40 	call	40186c4 <__malloc_unlock>
    return 0;
 400d0f8:	0005883a 	mov	r2,zero
 400d0fc:	00004506 	br	400d214 <_malloc_trim_r+0x1b0>
  }

  else
  {
    /* Test to make sure no one else called sbrk */
    current_brk = (char*)(MORECORE (0));
 400d100:	000b883a 	mov	r5,zero
 400d104:	e13ffa17 	ldw	r4,-24(fp)
 400d108:	40117d80 	call	40117d8 <_sbrk_r>
 400d10c:	e0bffc15 	stw	r2,-16(fp)
    if (current_brk != (char*)(top) + top_size)
 400d110:	008100b4 	movhi	r2,1026
 400d114:	10ad9404 	addi	r2,r2,-18864
 400d118:	10c00217 	ldw	r3,8(r2)
 400d11c:	e0bffe17 	ldw	r2,-8(fp)
 400d120:	1885883a 	add	r2,r3,r2
 400d124:	e0fffc17 	ldw	r3,-16(fp)
 400d128:	18800426 	beq	r3,r2,400d13c <_malloc_trim_r+0xd8>
    {
      MALLOC_UNLOCK;
 400d12c:	e13ffa17 	ldw	r4,-24(fp)
 400d130:	40186c40 	call	40186c4 <__malloc_unlock>
      return 0;     /* Apparently we don't own memory; must fail */
 400d134:	0005883a 	mov	r2,zero
 400d138:	00003606 	br	400d214 <_malloc_trim_r+0x1b0>
    }

    else
    {
      new_brk = (char*)(MORECORE (-extra));
 400d13c:	e0bffd17 	ldw	r2,-12(fp)
 400d140:	0085c83a 	sub	r2,zero,r2
 400d144:	100b883a 	mov	r5,r2
 400d148:	e13ffa17 	ldw	r4,-24(fp)
 400d14c:	40117d80 	call	40117d8 <_sbrk_r>
 400d150:	e0bffb15 	stw	r2,-20(fp)
      
      if (new_brk == (char*)(MORECORE_FAILURE)) /* sbrk failed? */
 400d154:	e0bffb17 	ldw	r2,-20(fp)
 400d158:	10bfffd8 	cmpnei	r2,r2,-1
 400d15c:	10001c1e 	bne	r2,zero,400d1d0 <_malloc_trim_r+0x16c>
      {
        /* Try to figure out what we have */
        current_brk = (char*)(MORECORE (0));
 400d160:	000b883a 	mov	r5,zero
 400d164:	e13ffa17 	ldw	r4,-24(fp)
 400d168:	40117d80 	call	40117d8 <_sbrk_r>
 400d16c:	e0bffc15 	stw	r2,-16(fp)
        top_size = current_brk - (char*)top;
 400d170:	008100b4 	movhi	r2,1026
 400d174:	10ad9404 	addi	r2,r2,-18864
 400d178:	10800217 	ldw	r2,8(r2)
 400d17c:	e0fffc17 	ldw	r3,-16(fp)
 400d180:	1885c83a 	sub	r2,r3,r2
 400d184:	e0bffe15 	stw	r2,-8(fp)
        if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
 400d188:	e0bffe17 	ldw	r2,-8(fp)
 400d18c:	10800410 	cmplti	r2,r2,16
 400d190:	10000b1e 	bne	r2,zero,400d1c0 <_malloc_trim_r+0x15c>
        {
          sbrked_mem = current_brk - sbrk_base;
 400d194:	d0a00417 	ldw	r2,-32752(gp)
 400d198:	e0fffc17 	ldw	r3,-16(fp)
 400d19c:	1887c83a 	sub	r3,r3,r2
 400d1a0:	008120b4 	movhi	r2,1154
 400d1a4:	10fae115 	stw	r3,-5244(r2)
          set_head(top, top_size | PREV_INUSE);
 400d1a8:	e0bffe17 	ldw	r2,-8(fp)
 400d1ac:	10c00054 	ori	r3,r2,1
 400d1b0:	008100b4 	movhi	r2,1026
 400d1b4:	10ad9404 	addi	r2,r2,-18864
 400d1b8:	10800217 	ldw	r2,8(r2)
 400d1bc:	10c00115 	stw	r3,4(r2)
        }
        check_chunk(top);
	MALLOC_UNLOCK;
 400d1c0:	e13ffa17 	ldw	r4,-24(fp)
 400d1c4:	40186c40 	call	40186c4 <__malloc_unlock>
        return 0; 
 400d1c8:	0005883a 	mov	r2,zero
 400d1cc:	00001106 	br	400d214 <_malloc_trim_r+0x1b0>
      }

      else
      {
        /* Success. Adjust top accordingly. */
        set_head(top, (top_size - extra) | PREV_INUSE);
 400d1d0:	e0fffe17 	ldw	r3,-8(fp)
 400d1d4:	e0bffd17 	ldw	r2,-12(fp)
 400d1d8:	1885c83a 	sub	r2,r3,r2
 400d1dc:	10c00054 	ori	r3,r2,1
 400d1e0:	008100b4 	movhi	r2,1026
 400d1e4:	10ad9404 	addi	r2,r2,-18864
 400d1e8:	10800217 	ldw	r2,8(r2)
 400d1ec:	10c00115 	stw	r3,4(r2)
        sbrked_mem -= extra;
 400d1f0:	008120b4 	movhi	r2,1154
 400d1f4:	10fae117 	ldw	r3,-5244(r2)
 400d1f8:	e0bffd17 	ldw	r2,-12(fp)
 400d1fc:	1887c83a 	sub	r3,r3,r2
 400d200:	008120b4 	movhi	r2,1154
 400d204:	10fae115 	stw	r3,-5244(r2)
        check_chunk(top);
	MALLOC_UNLOCK;
 400d208:	e13ffa17 	ldw	r4,-24(fp)
 400d20c:	40186c40 	call	40186c4 <__malloc_unlock>
        return 1;
 400d210:	00800044 	movi	r2,1
      }
    }
  }
}
 400d214:	e037883a 	mov	sp,fp
 400d218:	dfc00117 	ldw	ra,4(sp)
 400d21c:	df000017 	ldw	fp,0(sp)
 400d220:	dec00204 	addi	sp,sp,8
 400d224:	f800283a 	ret

0400d228 <__sfvwrite_r>:

int
__sfvwrite_r (struct _reent *ptr,
       register FILE *fp,
       register struct __suio *uio)
{
 400d228:	defff004 	addi	sp,sp,-64
 400d22c:	dfc00f15 	stw	ra,60(sp)
 400d230:	df000e15 	stw	fp,56(sp)
 400d234:	dd800d15 	stw	r22,52(sp)
 400d238:	dd400c15 	stw	r21,48(sp)
 400d23c:	dd000b15 	stw	r20,44(sp)
 400d240:	dcc00a15 	stw	r19,40(sp)
 400d244:	dc800915 	stw	r18,36(sp)
 400d248:	dc400815 	stw	r17,32(sp)
 400d24c:	dc000715 	stw	r16,28(sp)
 400d250:	df000e04 	addi	fp,sp,56
 400d254:	e13ff215 	stw	r4,-56(fp)
 400d258:	2821883a 	mov	r16,r5
 400d25c:	302b883a 	mov	r21,r6
  register size_t len;
  register const char *p = NULL;
 400d260:	0027883a 	mov	r19,zero
  register struct __siov *iov;
  register _READ_WRITE_RETURN_TYPE w, s;
  char *nl;
  int nlknown, nldist;

  if ((len = uio->uio_resid) == 0)
 400d264:	ac800217 	ldw	r18,8(r21)
 400d268:	9000021e 	bne	r18,zero,400d274 <__sfvwrite_r+0x4c>
    return 0;
 400d26c:	0005883a 	mov	r2,zero
 400d270:	00015b06 	br	400d7e0 <__sfvwrite_r+0x5b8>

  /* make sure we can write */
  if (cantwrite (ptr, fp))
 400d274:	8080030b 	ldhu	r2,12(r16)
 400d278:	10bfffcc 	andi	r2,r2,65535
 400d27c:	1080020c 	andi	r2,r2,8
 400d280:	10000226 	beq	r2,zero,400d28c <__sfvwrite_r+0x64>
 400d284:	80800417 	ldw	r2,16(r16)
 400d288:	1000061e 	bne	r2,zero,400d2a4 <__sfvwrite_r+0x7c>
 400d28c:	800b883a 	mov	r5,r16
 400d290:	e13ff217 	ldw	r4,-56(fp)
 400d294:	4009f4c0 	call	4009f4c <__swsetup_r>
 400d298:	10000226 	beq	r2,zero,400d2a4 <__sfvwrite_r+0x7c>
    return EOF;
 400d29c:	00bfffc4 	movi	r2,-1
 400d2a0:	00014f06 	br	400d7e0 <__sfvwrite_r+0x5b8>

  iov = uio->uio_iov;
 400d2a4:	ad000017 	ldw	r20,0(r21)
  len = 0;
 400d2a8:	0025883a 	mov	r18,zero
      while (uio->uio_resid > 0);
      return 0;
    }
#endif

  if (fp->_flags & __SNBF)
 400d2ac:	8080030b 	ldhu	r2,12(r16)
 400d2b0:	10bfffcc 	andi	r2,r2,65535
 400d2b4:	1080008c 	andi	r2,r2,2
 400d2b8:	10001f26 	beq	r2,zero,400d338 <__sfvwrite_r+0x110>
       * Unbuffered: Split buffer in the largest multiple of BUFSIZ < INT_MAX
       * as some legacy code may expect int instead of size_t.
       */
      do
	{
	  GETIOV (;);
 400d2bc:	00000306 	br	400d2cc <__sfvwrite_r+0xa4>
 400d2c0:	a4c00017 	ldw	r19,0(r20)
 400d2c4:	a4800117 	ldw	r18,4(r20)
 400d2c8:	a5000204 	addi	r20,r20,8
 400d2cc:	903ffc26 	beq	r18,zero,400d2c0 <__sfvwrite_r+0x98>
	  w = fp->_write (ptr, fp->_cookie, p,
 400d2d0:	82000917 	ldw	r8,36(r16)
 400d2d4:	81000717 	ldw	r4,28(r16)
			  MIN (len, INT_MAX - INT_MAX % BUFSIZ));
 400d2d8:	9005883a 	mov	r2,r18
 400d2dc:	00e00034 	movhi	r3,32768
 400d2e0:	18ff0004 	addi	r3,r3,-1024
 400d2e4:	1880022e 	bgeu	r3,r2,400d2f0 <__sfvwrite_r+0xc8>
 400d2e8:	00a00034 	movhi	r2,32768
 400d2ec:	10bf0004 	addi	r2,r2,-1024
	  w = fp->_write (ptr, fp->_cookie, p,
 400d2f0:	100f883a 	mov	r7,r2
 400d2f4:	980d883a 	mov	r6,r19
 400d2f8:	200b883a 	mov	r5,r4
 400d2fc:	e13ff217 	ldw	r4,-56(fp)
 400d300:	403ee83a 	callr	r8
 400d304:	1023883a 	mov	r17,r2
	  if (w <= 0)
 400d308:	04412c0e 	bge	zero,r17,400d7bc <__sfvwrite_r+0x594>
	    goto err;
	  p += w;
 400d30c:	8805883a 	mov	r2,r17
 400d310:	98a7883a 	add	r19,r19,r2
	  len -= w;
 400d314:	8805883a 	mov	r2,r17
 400d318:	90a5c83a 	sub	r18,r18,r2
	}
      while ((uio->uio_resid -= w) != 0);
 400d31c:	a8800217 	ldw	r2,8(r21)
 400d320:	8807883a 	mov	r3,r17
 400d324:	10c5c83a 	sub	r2,r2,r3
 400d328:	a8800215 	stw	r2,8(r21)
 400d32c:	a8800217 	ldw	r2,8(r21)
 400d330:	103fe61e 	bne	r2,zero,400d2cc <__sfvwrite_r+0xa4>
 400d334:	00011f06 	br	400d7b4 <__sfvwrite_r+0x58c>
    }
  else if ((fp->_flags & __SLBF) == 0)
 400d338:	8080030b 	ldhu	r2,12(r16)
 400d33c:	10bfffcc 	andi	r2,r2,65535
 400d340:	1080004c 	andi	r2,r2,1
 400d344:	1000b91e 	bne	r2,zero,400d62c <__sfvwrite_r+0x404>
       * we are dealing with the asprintf routines, we will
       * dynamically increase the buffer size as needed.
       */
      do
	{
	  GETIOV (;);
 400d348:	00000306 	br	400d358 <__sfvwrite_r+0x130>
 400d34c:	a4c00017 	ldw	r19,0(r20)
 400d350:	a4800117 	ldw	r18,4(r20)
 400d354:	a5000204 	addi	r20,r20,8
 400d358:	903ffc26 	beq	r18,zero,400d34c <__sfvwrite_r+0x124>
	  w = fp->_w;
 400d35c:	84400217 	ldw	r17,8(r16)
	  if (fp->_flags & __SSTR)
 400d360:	8080030b 	ldhu	r2,12(r16)
 400d364:	10bfffcc 	andi	r2,r2,65535
 400d368:	1080800c 	andi	r2,r2,512
 400d36c:	10006a26 	beq	r2,zero,400d518 <__sfvwrite_r+0x2f0>
	    {
	      if (len >= w && fp->_flags & (__SMBF | __SOPT))
 400d370:	8805883a 	mov	r2,r17
 400d374:	90805636 	bltu	r18,r2,400d4d0 <__sfvwrite_r+0x2a8>
 400d378:	8080030b 	ldhu	r2,12(r16)
 400d37c:	10bfffcc 	andi	r2,r2,65535
 400d380:	1081200c 	andi	r2,r2,1152
 400d384:	10005226 	beq	r2,zero,400d4d0 <__sfvwrite_r+0x2a8>
		{ /* must be asprintf family */
		  unsigned char *str;
		  int curpos = (fp->_p - fp->_bf._base);
 400d388:	80c00017 	ldw	r3,0(r16)
 400d38c:	80800417 	ldw	r2,16(r16)
 400d390:	1885c83a 	sub	r2,r3,r2
 400d394:	e0bff315 	stw	r2,-52(fp)
		     than (1+sqrt(5))/2 to accomodate malloc
		     overhead. asprintf EXPECTS us to overallocate, so
		     that it can add a trailing \0 without
		     reallocating.  The new allocation should thus be
		     max(prev_size*1.5, curpos+len+1). */
		  int newsize = fp->_bf._size * 3 / 2;
 400d398:	80c00517 	ldw	r3,20(r16)
 400d39c:	1805883a 	mov	r2,r3
 400d3a0:	1085883a 	add	r2,r2,r2
 400d3a4:	10c5883a 	add	r2,r2,r3
 400d3a8:	1006d7fa 	srli	r3,r2,31
 400d3ac:	1885883a 	add	r2,r3,r2
 400d3b0:	1005d07a 	srai	r2,r2,1
 400d3b4:	e0bff515 	stw	r2,-44(fp)
		  if (newsize < curpos + len + 1)
 400d3b8:	e0bff317 	ldw	r2,-52(fp)
 400d3bc:	9085883a 	add	r2,r18,r2
 400d3c0:	10800044 	addi	r2,r2,1
 400d3c4:	e0fff517 	ldw	r3,-44(fp)
 400d3c8:	1880042e 	bgeu	r3,r2,400d3dc <__sfvwrite_r+0x1b4>
		    newsize = curpos + len + 1;
 400d3cc:	e0bff317 	ldw	r2,-52(fp)
 400d3d0:	9085883a 	add	r2,r18,r2
 400d3d4:	10800044 	addi	r2,r2,1
 400d3d8:	e0bff515 	stw	r2,-44(fp)
		  if (fp->_flags & __SOPT)
 400d3dc:	8080030b 	ldhu	r2,12(r16)
 400d3e0:	10bfffcc 	andi	r2,r2,65535
 400d3e4:	1081000c 	andi	r2,r2,1024
 400d3e8:	10001726 	beq	r2,zero,400d448 <__sfvwrite_r+0x220>
		    {
		      /* asnprintf leaves original buffer alone.  */
		      str = (unsigned char *)_malloc_r (ptr, newsize);
 400d3ec:	e0bff517 	ldw	r2,-44(fp)
 400d3f0:	100b883a 	mov	r5,r2
 400d3f4:	e13ff217 	ldw	r4,-56(fp)
 400d3f8:	400e1400 	call	400e140 <_malloc_r>
 400d3fc:	e0bff615 	stw	r2,-40(fp)
		      if (!str)
 400d400:	e0bff617 	ldw	r2,-40(fp)
 400d404:	1000041e 	bne	r2,zero,400d418 <__sfvwrite_r+0x1f0>
			{
			  ptr->_errno = ENOMEM;
 400d408:	e0bff217 	ldw	r2,-56(fp)
 400d40c:	00c00304 	movi	r3,12
 400d410:	10c00015 	stw	r3,0(r2)
			  goto err;
 400d414:	0000ee06 	br	400d7d0 <__sfvwrite_r+0x5a8>
			}
		      memcpy (str, fp->_bf._base, curpos);
 400d418:	80800417 	ldw	r2,16(r16)
 400d41c:	e0fff317 	ldw	r3,-52(fp)
 400d420:	180d883a 	mov	r6,r3
 400d424:	100b883a 	mov	r5,r2
 400d428:	e13ff617 	ldw	r4,-40(fp)
 400d42c:	40073000 	call	4007300 <memcpy>
		      fp->_flags = (fp->_flags & ~__SOPT) | __SMBF;
 400d430:	80c0030b 	ldhu	r3,12(r16)
 400d434:	00bedfc4 	movi	r2,-1153
 400d438:	1884703a 	and	r2,r3,r2
 400d43c:	10802014 	ori	r2,r2,128
 400d440:	8080030d 	sth	r2,12(r16)
 400d444:	00001506 	br	400d49c <__sfvwrite_r+0x274>
		    }
		  else
		    {
		      str = (unsigned char *)_realloc_r (ptr, fp->_bf._base,
 400d448:	80800417 	ldw	r2,16(r16)
 400d44c:	e0fff517 	ldw	r3,-44(fp)
 400d450:	180d883a 	mov	r6,r3
 400d454:	100b883a 	mov	r5,r2
 400d458:	e13ff217 	ldw	r4,-56(fp)
 400d45c:	4010be40 	call	4010be4 <_realloc_r>
 400d460:	e0bff615 	stw	r2,-40(fp)
							 newsize);
		      if (!str)
 400d464:	e0bff617 	ldw	r2,-40(fp)
 400d468:	10000c1e 	bne	r2,zero,400d49c <__sfvwrite_r+0x274>
			{
			  /* Free buffer which is no longer used and clear
			     __SMBF flag to avoid double free in fclose.  */
			  _free_r (ptr, fp->_bf._base);
 400d46c:	80800417 	ldw	r2,16(r16)
 400d470:	100b883a 	mov	r5,r2
 400d474:	e13ff217 	ldw	r4,-56(fp)
 400d478:	400cb0c0 	call	400cb0c <_free_r>
			  fp->_flags &=  ~__SMBF;
 400d47c:	80c0030b 	ldhu	r3,12(r16)
 400d480:	00bfdfc4 	movi	r2,-129
 400d484:	1884703a 	and	r2,r3,r2
 400d488:	8080030d 	sth	r2,12(r16)
			  /* Ensure correct errno, even if free changed it.  */
			  ptr->_errno = ENOMEM;
 400d48c:	e0bff217 	ldw	r2,-56(fp)
 400d490:	00c00304 	movi	r3,12
 400d494:	10c00015 	stw	r3,0(r2)
			  goto err;
 400d498:	0000cd06 	br	400d7d0 <__sfvwrite_r+0x5a8>
			}
		    }
		  fp->_bf._base = str;
 400d49c:	e0bff617 	ldw	r2,-40(fp)
 400d4a0:	80800415 	stw	r2,16(r16)
		  fp->_p = str + curpos;
 400d4a4:	e0bff317 	ldw	r2,-52(fp)
 400d4a8:	e0fff617 	ldw	r3,-40(fp)
 400d4ac:	1885883a 	add	r2,r3,r2
 400d4b0:	80800015 	stw	r2,0(r16)
		  fp->_bf._size = newsize;
 400d4b4:	e0bff517 	ldw	r2,-44(fp)
 400d4b8:	80800515 	stw	r2,20(r16)
		  w = len;
 400d4bc:	9023883a 	mov	r17,r18
		  fp->_w = newsize - curpos;
 400d4c0:	e0fff517 	ldw	r3,-44(fp)
 400d4c4:	e0bff317 	ldw	r2,-52(fp)
 400d4c8:	1885c83a 	sub	r2,r3,r2
 400d4cc:	80800215 	stw	r2,8(r16)
		}
	      if (len < w)
 400d4d0:	8805883a 	mov	r2,r17
 400d4d4:	9080012e 	bgeu	r18,r2,400d4dc <__sfvwrite_r+0x2b4>
		w = len;
 400d4d8:	9023883a 	mov	r17,r18
	      COPY (w);		/* copy MIN(fp->_w,len), */
 400d4dc:	80800017 	ldw	r2,0(r16)
 400d4e0:	8807883a 	mov	r3,r17
 400d4e4:	180d883a 	mov	r6,r3
 400d4e8:	980b883a 	mov	r5,r19
 400d4ec:	1009883a 	mov	r4,r2
 400d4f0:	400ee640 	call	400ee64 <memmove>
	      fp->_w -= w;
 400d4f4:	80800217 	ldw	r2,8(r16)
 400d4f8:	1445c83a 	sub	r2,r2,r17
 400d4fc:	80800215 	stw	r2,8(r16)
	      fp->_p += w;
 400d500:	80800017 	ldw	r2,0(r16)
 400d504:	8807883a 	mov	r3,r17
 400d508:	10c5883a 	add	r2,r2,r3
 400d50c:	80800015 	stw	r2,0(r16)
	      w = len;		/* but pretend copied all */
 400d510:	9023883a 	mov	r17,r18
 400d514:	00003a06 	br	400d600 <__sfvwrite_r+0x3d8>
	    }
	  else if (fp->_p > fp->_bf._base || len < fp->_bf._size)
 400d518:	80800017 	ldw	r2,0(r16)
 400d51c:	80c00417 	ldw	r3,16(r16)
 400d520:	18800236 	bltu	r3,r2,400d52c <__sfvwrite_r+0x304>
 400d524:	80800517 	ldw	r2,20(r16)
 400d528:	9080192e 	bgeu	r18,r2,400d590 <__sfvwrite_r+0x368>
	    {
	      /* pass through the buffer */
	      w = MIN (len, w);
 400d52c:	8807883a 	mov	r3,r17
 400d530:	9005883a 	mov	r2,r18
 400d534:	1880012e 	bgeu	r3,r2,400d53c <__sfvwrite_r+0x314>
 400d538:	1805883a 	mov	r2,r3
 400d53c:	1023883a 	mov	r17,r2
	      COPY (w);
 400d540:	80800017 	ldw	r2,0(r16)
 400d544:	8807883a 	mov	r3,r17
 400d548:	180d883a 	mov	r6,r3
 400d54c:	980b883a 	mov	r5,r19
 400d550:	1009883a 	mov	r4,r2
 400d554:	400ee640 	call	400ee64 <memmove>
	      fp->_w -= w;
 400d558:	80800217 	ldw	r2,8(r16)
 400d55c:	1445c83a 	sub	r2,r2,r17
 400d560:	80800215 	stw	r2,8(r16)
	      fp->_p += w;
 400d564:	80800017 	ldw	r2,0(r16)
 400d568:	8807883a 	mov	r3,r17
 400d56c:	10c5883a 	add	r2,r2,r3
 400d570:	80800015 	stw	r2,0(r16)
	      if (fp->_w == 0 && _fflush_r (ptr, fp))
 400d574:	80800217 	ldw	r2,8(r16)
 400d578:	1000201e 	bne	r2,zero,400d5fc <__sfvwrite_r+0x3d4>
 400d57c:	800b883a 	mov	r5,r16
 400d580:	e13ff217 	ldw	r4,-56(fp)
 400d584:	400c3c80 	call	400c3c8 <_fflush_r>
 400d588:	10001c26 	beq	r2,zero,400d5fc <__sfvwrite_r+0x3d4>
		goto err;
 400d58c:	00009006 	br	400d7d0 <__sfvwrite_r+0x5a8>
	    }
	  else
	    {
	      /* write directly */
	      w = ((int)MIN (len, INT_MAX)) / fp->_bf._size * fp->_bf._size;
 400d590:	00a00034 	movhi	r2,32768
 400d594:	10bfff84 	addi	r2,r2,-2
 400d598:	14800236 	bltu	r2,r18,400d5a4 <__sfvwrite_r+0x37c>
 400d59c:	9005883a 	mov	r2,r18
 400d5a0:	00000206 	br	400d5ac <__sfvwrite_r+0x384>
 400d5a4:	00a00034 	movhi	r2,32768
 400d5a8:	10bfffc4 	addi	r2,r2,-1
 400d5ac:	80c00517 	ldw	r3,20(r16)
 400d5b0:	180b883a 	mov	r5,r3
 400d5b4:	1009883a 	mov	r4,r2
 400d5b8:	401528c0 	call	401528c <__divsi3>
 400d5bc:	1007883a 	mov	r3,r2
 400d5c0:	80800517 	ldw	r2,20(r16)
 400d5c4:	100b883a 	mov	r5,r2
 400d5c8:	1809883a 	mov	r4,r3
 400d5cc:	40072d80 	call	40072d8 <__mulsi3>
 400d5d0:	1023883a 	mov	r17,r2
	      w = fp->_write (ptr, fp->_cookie, p, w);
 400d5d4:	80800917 	ldw	r2,36(r16)
 400d5d8:	80c00717 	ldw	r3,28(r16)
 400d5dc:	880f883a 	mov	r7,r17
 400d5e0:	980d883a 	mov	r6,r19
 400d5e4:	180b883a 	mov	r5,r3
 400d5e8:	e13ff217 	ldw	r4,-56(fp)
 400d5ec:	103ee83a 	callr	r2
 400d5f0:	1023883a 	mov	r17,r2
	      if (w <= 0)
 400d5f4:	0440730e 	bge	zero,r17,400d7c4 <__sfvwrite_r+0x59c>
 400d5f8:	00000106 	br	400d600 <__sfvwrite_r+0x3d8>
	      if (fp->_w == 0 && _fflush_r (ptr, fp))
 400d5fc:	0001883a 	nop
		goto err;
	    }
	  p += w;
 400d600:	8805883a 	mov	r2,r17
 400d604:	98a7883a 	add	r19,r19,r2
	  len -= w;
 400d608:	8805883a 	mov	r2,r17
 400d60c:	90a5c83a 	sub	r18,r18,r2
	}
      while ((uio->uio_resid -= w) != 0);
 400d610:	a8800217 	ldw	r2,8(r21)
 400d614:	8807883a 	mov	r3,r17
 400d618:	10c5c83a 	sub	r2,r2,r3
 400d61c:	a8800215 	stw	r2,8(r21)
 400d620:	a8800217 	ldw	r2,8(r21)
 400d624:	103f4c1e 	bne	r2,zero,400d358 <__sfvwrite_r+0x130>
 400d628:	00006206 	br	400d7b4 <__sfvwrite_r+0x58c>
       * must check for newlines.  Compute the distance
       * to the first newline (including the newline),
       * or `infinity' if there is none, then pretend
       * that the amount to write is MIN(len,nldist).
       */
      nlknown = 0;
 400d62c:	e03ff815 	stw	zero,-32(fp)
      nldist = 0;
 400d630:	e03ff715 	stw	zero,-36(fp)
      do
	{
	  GETIOV (nlknown = 0);
 400d634:	00000406 	br	400d648 <__sfvwrite_r+0x420>
 400d638:	e03ff815 	stw	zero,-32(fp)
 400d63c:	a4c00017 	ldw	r19,0(r20)
 400d640:	a4800117 	ldw	r18,4(r20)
 400d644:	a5000204 	addi	r20,r20,8
 400d648:	903ffb26 	beq	r18,zero,400d638 <__sfvwrite_r+0x410>
	  if (!nlknown)
 400d64c:	e0bff817 	ldw	r2,-32(fp)
 400d650:	10000f1e 	bne	r2,zero,400d690 <__sfvwrite_r+0x468>
	    {
	      nl = memchr ((void *) p, '\n', len);
 400d654:	900d883a 	mov	r6,r18
 400d658:	01400284 	movi	r5,10
 400d65c:	9809883a 	mov	r4,r19
 400d660:	400eca80 	call	400eca8 <memchr>
 400d664:	e0bff415 	stw	r2,-48(fp)
	      nldist = nl ? nl + 1 - p : len + 1;
 400d668:	e0bff417 	ldw	r2,-48(fp)
 400d66c:	10000426 	beq	r2,zero,400d680 <__sfvwrite_r+0x458>
 400d670:	e0bff417 	ldw	r2,-48(fp)
 400d674:	10800044 	addi	r2,r2,1
 400d678:	14c5c83a 	sub	r2,r2,r19
 400d67c:	00000106 	br	400d684 <__sfvwrite_r+0x45c>
 400d680:	90800044 	addi	r2,r18,1
 400d684:	e0bff715 	stw	r2,-36(fp)
	      nlknown = 1;
 400d688:	00800044 	movi	r2,1
 400d68c:	e0bff815 	stw	r2,-32(fp)
	    }
	  s = MIN (len, nldist);
 400d690:	e0fff717 	ldw	r3,-36(fp)
 400d694:	9005883a 	mov	r2,r18
 400d698:	1880012e 	bgeu	r3,r2,400d6a0 <__sfvwrite_r+0x478>
 400d69c:	1805883a 	mov	r2,r3
 400d6a0:	102d883a 	mov	r22,r2
	  w = fp->_w + fp->_bf._size;
 400d6a4:	80c00217 	ldw	r3,8(r16)
 400d6a8:	80800517 	ldw	r2,20(r16)
 400d6ac:	18a3883a 	add	r17,r3,r2
	  if (fp->_p > fp->_bf._base && s > w)
 400d6b0:	80800017 	ldw	r2,0(r16)
 400d6b4:	80c00417 	ldw	r3,16(r16)
 400d6b8:	1880102e 	bgeu	r3,r2,400d6fc <__sfvwrite_r+0x4d4>
 400d6bc:	8d800f0e 	bge	r17,r22,400d6fc <__sfvwrite_r+0x4d4>
	    {
	      COPY (w);
 400d6c0:	80800017 	ldw	r2,0(r16)
 400d6c4:	8807883a 	mov	r3,r17
 400d6c8:	180d883a 	mov	r6,r3
 400d6cc:	980b883a 	mov	r5,r19
 400d6d0:	1009883a 	mov	r4,r2
 400d6d4:	400ee640 	call	400ee64 <memmove>
	      /* fp->_w -= w; */
	      fp->_p += w;
 400d6d8:	80800017 	ldw	r2,0(r16)
 400d6dc:	8807883a 	mov	r3,r17
 400d6e0:	10c5883a 	add	r2,r2,r3
 400d6e4:	80800015 	stw	r2,0(r16)
	      if (_fflush_r (ptr, fp))
 400d6e8:	800b883a 	mov	r5,r16
 400d6ec:	e13ff217 	ldw	r4,-56(fp)
 400d6f0:	400c3c80 	call	400c3c8 <_fflush_r>
 400d6f4:	10001b26 	beq	r2,zero,400d764 <__sfvwrite_r+0x53c>
		goto err;
 400d6f8:	00003506 	br	400d7d0 <__sfvwrite_r+0x5a8>
	    }
	  else if (s >= (w = fp->_bf._size))
 400d6fc:	84400517 	ldw	r17,20(r16)
 400d700:	b4400a16 	blt	r22,r17,400d72c <__sfvwrite_r+0x504>
	    {
	      w = fp->_write (ptr, fp->_cookie, p, w);
 400d704:	80800917 	ldw	r2,36(r16)
 400d708:	80c00717 	ldw	r3,28(r16)
 400d70c:	880f883a 	mov	r7,r17
 400d710:	980d883a 	mov	r6,r19
 400d714:	180b883a 	mov	r5,r3
 400d718:	e13ff217 	ldw	r4,-56(fp)
 400d71c:	103ee83a 	callr	r2
 400d720:	1023883a 	mov	r17,r2
	      if (w <= 0)
 400d724:	04400f16 	blt	zero,r17,400d764 <__sfvwrite_r+0x53c>
		goto err;
 400d728:	00002906 	br	400d7d0 <__sfvwrite_r+0x5a8>
	    }
	  else
	    {
	      w = s;
 400d72c:	b023883a 	mov	r17,r22
	      COPY (w);
 400d730:	80800017 	ldw	r2,0(r16)
 400d734:	8807883a 	mov	r3,r17
 400d738:	180d883a 	mov	r6,r3
 400d73c:	980b883a 	mov	r5,r19
 400d740:	1009883a 	mov	r4,r2
 400d744:	400ee640 	call	400ee64 <memmove>
	      fp->_w -= w;
 400d748:	80800217 	ldw	r2,8(r16)
 400d74c:	1445c83a 	sub	r2,r2,r17
 400d750:	80800215 	stw	r2,8(r16)
	      fp->_p += w;
 400d754:	80800017 	ldw	r2,0(r16)
 400d758:	8807883a 	mov	r3,r17
 400d75c:	10c5883a 	add	r2,r2,r3
 400d760:	80800015 	stw	r2,0(r16)
	    }
	  if ((nldist -= w) == 0)
 400d764:	e0bff717 	ldw	r2,-36(fp)
 400d768:	1445c83a 	sub	r2,r2,r17
 400d76c:	e0bff715 	stw	r2,-36(fp)
 400d770:	e0bff717 	ldw	r2,-36(fp)
 400d774:	1000051e 	bne	r2,zero,400d78c <__sfvwrite_r+0x564>
	    {
	      /* copied the newline: flush and forget */
	      if (_fflush_r (ptr, fp))
 400d778:	800b883a 	mov	r5,r16
 400d77c:	e13ff217 	ldw	r4,-56(fp)
 400d780:	400c3c80 	call	400c3c8 <_fflush_r>
 400d784:	1000111e 	bne	r2,zero,400d7cc <__sfvwrite_r+0x5a4>
		goto err;
	      nlknown = 0;
 400d788:	e03ff815 	stw	zero,-32(fp)
	    }
	  p += w;
 400d78c:	8805883a 	mov	r2,r17
 400d790:	98a7883a 	add	r19,r19,r2
	  len -= w;
 400d794:	8805883a 	mov	r2,r17
 400d798:	90a5c83a 	sub	r18,r18,r2
	}
      while ((uio->uio_resid -= w) != 0);
 400d79c:	a8800217 	ldw	r2,8(r21)
 400d7a0:	8807883a 	mov	r3,r17
 400d7a4:	10c5c83a 	sub	r2,r2,r3
 400d7a8:	a8800215 	stw	r2,8(r21)
 400d7ac:	a8800217 	ldw	r2,8(r21)
 400d7b0:	103fa51e 	bne	r2,zero,400d648 <__sfvwrite_r+0x420>
    }
  return 0;
 400d7b4:	0005883a 	mov	r2,zero
 400d7b8:	00000906 	br	400d7e0 <__sfvwrite_r+0x5b8>
	    goto err;
 400d7bc:	0001883a 	nop
 400d7c0:	00000306 	br	400d7d0 <__sfvwrite_r+0x5a8>
		goto err;
 400d7c4:	0001883a 	nop
 400d7c8:	00000106 	br	400d7d0 <__sfvwrite_r+0x5a8>
		goto err;
 400d7cc:	0001883a 	nop

err:
  fp->_flags |= __SERR;
 400d7d0:	8080030b 	ldhu	r2,12(r16)
 400d7d4:	10801014 	ori	r2,r2,64
 400d7d8:	8080030d 	sth	r2,12(r16)
  return EOF;
 400d7dc:	00bfffc4 	movi	r2,-1
}
 400d7e0:	e6fff904 	addi	sp,fp,-28
 400d7e4:	dfc00817 	ldw	ra,32(sp)
 400d7e8:	df000717 	ldw	fp,28(sp)
 400d7ec:	dd800617 	ldw	r22,24(sp)
 400d7f0:	dd400517 	ldw	r21,20(sp)
 400d7f4:	dd000417 	ldw	r20,16(sp)
 400d7f8:	dcc00317 	ldw	r19,12(sp)
 400d7fc:	dc800217 	ldw	r18,8(sp)
 400d800:	dc400117 	ldw	r17,4(sp)
 400d804:	dc000017 	ldw	r16,0(sp)
 400d808:	dec00904 	addi	sp,sp,36
 400d80c:	f800283a 	ret

0400d810 <_fwalk>:
#include "local.h"

int
_fwalk (struct _reent *ptr,
       register int (*function) (FILE *))
{
 400d810:	defff804 	addi	sp,sp,-32
 400d814:	dfc00715 	stw	ra,28(sp)
 400d818:	df000615 	stw	fp,24(sp)
 400d81c:	dd000515 	stw	r20,20(sp)
 400d820:	dcc00415 	stw	r19,16(sp)
 400d824:	dc800315 	stw	r18,12(sp)
 400d828:	dc400215 	stw	r17,8(sp)
 400d82c:	dc000115 	stw	r16,4(sp)
 400d830:	df000604 	addi	fp,sp,24
 400d834:	e13ffa15 	stw	r4,-24(fp)
 400d838:	2829883a 	mov	r20,r5
  register FILE *fp;
  register int n, ret = 0;
 400d83c:	0027883a 	mov	r19,zero
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
 400d840:	e0bffa17 	ldw	r2,-24(fp)
 400d844:	1440b804 	addi	r17,r2,736
 400d848:	00001b06 	br	400d8b8 <_fwalk+0xa8>
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
 400d84c:	8c000217 	ldw	r16,8(r17)
 400d850:	8c800117 	ldw	r18,4(r17)
 400d854:	00001506 	br	400d8ac <_fwalk+0x9c>
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
 400d858:	8080030b 	ldhu	r2,12(r16)
 400d85c:	10bfffcc 	andi	r2,r2,65535
 400d860:	10a0001c 	xori	r2,r2,32768
 400d864:	10a00004 	addi	r2,r2,-32768
 400d868:	10000f26 	beq	r2,zero,400d8a8 <_fwalk+0x98>
 400d86c:	8080030b 	ldhu	r2,12(r16)
 400d870:	10bfffcc 	andi	r2,r2,65535
 400d874:	10a0001c 	xori	r2,r2,32768
 400d878:	10a00004 	addi	r2,r2,-32768
 400d87c:	10800060 	cmpeqi	r2,r2,1
 400d880:	1000091e 	bne	r2,zero,400d8a8 <_fwalk+0x98>
 400d884:	8080038b 	ldhu	r2,14(r16)
 400d888:	10bfffcc 	andi	r2,r2,65535
 400d88c:	10a0001c 	xori	r2,r2,32768
 400d890:	10a00004 	addi	r2,r2,-32768
 400d894:	10bfffe0 	cmpeqi	r2,r2,-1
 400d898:	1000031e 	bne	r2,zero,400d8a8 <_fwalk+0x98>
	ret |= (*function) (fp);
 400d89c:	8009883a 	mov	r4,r16
 400d8a0:	a03ee83a 	callr	r20
 400d8a4:	98a6b03a 	or	r19,r19,r2
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
 400d8a8:	84001a04 	addi	r16,r16,104
 400d8ac:	94bfffc4 	addi	r18,r18,-1
 400d8b0:	903fe90e 	bge	r18,zero,400d858 <_fwalk+0x48>
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
 400d8b4:	8c400017 	ldw	r17,0(r17)
 400d8b8:	883fe41e 	bne	r17,zero,400d84c <_fwalk+0x3c>

  return ret;
 400d8bc:	9805883a 	mov	r2,r19
}
 400d8c0:	e6fffb04 	addi	sp,fp,-20
 400d8c4:	dfc00617 	ldw	ra,24(sp)
 400d8c8:	df000517 	ldw	fp,20(sp)
 400d8cc:	dd000417 	ldw	r20,16(sp)
 400d8d0:	dcc00317 	ldw	r19,12(sp)
 400d8d4:	dc800217 	ldw	r18,8(sp)
 400d8d8:	dc400117 	ldw	r17,4(sp)
 400d8dc:	dc000017 	ldw	r16,0(sp)
 400d8e0:	dec00704 	addi	sp,sp,28
 400d8e4:	f800283a 	ret

0400d8e8 <_fwalk_reent>:
/* Special version of __fwalk where the function pointer is a reentrant
   I/O function (e.g. _fclose_r).  */
int
_fwalk_reent (struct _reent *ptr,
       register int (*reent_function) (struct _reent *, FILE *))
{
 400d8e8:	defff804 	addi	sp,sp,-32
 400d8ec:	dfc00715 	stw	ra,28(sp)
 400d8f0:	df000615 	stw	fp,24(sp)
 400d8f4:	dd000515 	stw	r20,20(sp)
 400d8f8:	dcc00415 	stw	r19,16(sp)
 400d8fc:	dc800315 	stw	r18,12(sp)
 400d900:	dc400215 	stw	r17,8(sp)
 400d904:	dc000115 	stw	r16,4(sp)
 400d908:	df000604 	addi	fp,sp,24
 400d90c:	e13ffa15 	stw	r4,-24(fp)
 400d910:	2829883a 	mov	r20,r5
  register FILE *fp;
  register int n, ret = 0;
 400d914:	0027883a 	mov	r19,zero
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
 400d918:	e0bffa17 	ldw	r2,-24(fp)
 400d91c:	1440b804 	addi	r17,r2,736
 400d920:	00001c06 	br	400d994 <_fwalk_reent+0xac>
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
 400d924:	8c000217 	ldw	r16,8(r17)
 400d928:	8c800117 	ldw	r18,4(r17)
 400d92c:	00001606 	br	400d988 <_fwalk_reent+0xa0>
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
 400d930:	8080030b 	ldhu	r2,12(r16)
 400d934:	10bfffcc 	andi	r2,r2,65535
 400d938:	10a0001c 	xori	r2,r2,32768
 400d93c:	10a00004 	addi	r2,r2,-32768
 400d940:	10001026 	beq	r2,zero,400d984 <_fwalk_reent+0x9c>
 400d944:	8080030b 	ldhu	r2,12(r16)
 400d948:	10bfffcc 	andi	r2,r2,65535
 400d94c:	10a0001c 	xori	r2,r2,32768
 400d950:	10a00004 	addi	r2,r2,-32768
 400d954:	10800060 	cmpeqi	r2,r2,1
 400d958:	10000a1e 	bne	r2,zero,400d984 <_fwalk_reent+0x9c>
 400d95c:	8080038b 	ldhu	r2,14(r16)
 400d960:	10bfffcc 	andi	r2,r2,65535
 400d964:	10a0001c 	xori	r2,r2,32768
 400d968:	10a00004 	addi	r2,r2,-32768
 400d96c:	10bfffe0 	cmpeqi	r2,r2,-1
 400d970:	1000041e 	bne	r2,zero,400d984 <_fwalk_reent+0x9c>
	ret |= (*reent_function) (ptr, fp);
 400d974:	800b883a 	mov	r5,r16
 400d978:	e13ffa17 	ldw	r4,-24(fp)
 400d97c:	a03ee83a 	callr	r20
 400d980:	98a6b03a 	or	r19,r19,r2
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
 400d984:	84001a04 	addi	r16,r16,104
 400d988:	94bfffc4 	addi	r18,r18,-1
 400d98c:	903fe80e 	bge	r18,zero,400d930 <_fwalk_reent+0x48>
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
 400d990:	8c400017 	ldw	r17,0(r17)
 400d994:	883fe31e 	bne	r17,zero,400d924 <_fwalk_reent+0x3c>

  return ret;
 400d998:	9805883a 	mov	r2,r19
}
 400d99c:	e6fffb04 	addi	sp,fp,-20
 400d9a0:	dfc00617 	ldw	ra,24(sp)
 400d9a4:	df000517 	ldw	fp,20(sp)
 400d9a8:	dd000417 	ldw	r20,16(sp)
 400d9ac:	dcc00317 	ldw	r19,12(sp)
 400d9b0:	dc800217 	ldw	r18,8(sp)
 400d9b4:	dc400117 	ldw	r17,4(sp)
 400d9b8:	dc000017 	ldw	r16,0(sp)
 400d9bc:	dec00704 	addi	sp,sp,28
 400d9c0:	f800283a 	ret

0400d9c4 <__get_global_locale>:

/* In POSIX terms the global locale is the process-wide locale.  Use this
   function to always refer to the global locale. */
_ELIDABLE_INLINE struct __locale_t *
__get_global_locale ()
{
 400d9c4:	deffff04 	addi	sp,sp,-4
 400d9c8:	df000015 	stw	fp,0(sp)
 400d9cc:	d839883a 	mov	fp,sp
  extern struct __locale_t __global_locale;
  return &__global_locale;
 400d9d0:	008100b4 	movhi	r2,1026
 400d9d4:	10ae9604 	addi	r2,r2,-17832
}
 400d9d8:	e037883a 	mov	sp,fp
 400d9dc:	df000017 	ldw	fp,0(sp)
 400d9e0:	dec00104 	addi	sp,sp,4
 400d9e4:	f800283a 	ret

0400d9e8 <__get_current_locale>:
   using locale info without providing a locale as parameter (*_l functions).
   The current locale is either the locale of the current thread, if the
   thread called uselocale, or the global locale if not. */
_ELIDABLE_INLINE struct __locale_t *
__get_current_locale (void)
{
 400d9e8:	defffe04 	addi	sp,sp,-8
 400d9ec:	dfc00115 	stw	ra,4(sp)
 400d9f0:	df000015 	stw	fp,0(sp)
 400d9f4:	d839883a 	mov	fp,sp
#ifdef __HAVE_LOCALE_INFO__
  return _REENT->_locale ?: __get_global_locale ();
#else
  return __get_global_locale();
 400d9f8:	400d9c40 	call	400d9c4 <__get_global_locale>
#endif
}
 400d9fc:	e037883a 	mov	sp,fp
 400da00:	dfc00117 	ldw	ra,4(sp)
 400da04:	df000017 	ldw	fp,0(sp)
 400da08:	dec00204 	addi	sp,sp,8
 400da0c:	f800283a 	ret

0400da10 <__get_C_locale>:

/* Only access fixed "C" locale using this function.  Fake for !_MB_CAPABLE
   targets by returning ptr to globale locale. */
_ELIDABLE_INLINE struct __locale_t *
__get_C_locale (void)
{
 400da10:	defffe04 	addi	sp,sp,-8
 400da14:	dfc00115 	stw	ra,4(sp)
 400da18:	df000015 	stw	fp,0(sp)
 400da1c:	d839883a 	mov	fp,sp
#ifndef _MB_CAPABLE
  return __get_global_locale ();
 400da20:	400d9c40 	call	400d9c4 <__get_global_locale>
#else
  extern const struct __locale_t __C_locale;
  return (struct __locale_t *) &__C_locale;
#endif
}
 400da24:	e037883a 	mov	sp,fp
 400da28:	dfc00117 	ldw	ra,4(sp)
 400da2c:	df000017 	ldw	fp,0(sp)
 400da30:	dec00204 	addi	sp,sp,8
 400da34:	f800283a 	ret

0400da38 <__localeconv_l>:
#include <reent.h>
#include "setlocale.h"

struct lconv *
__localeconv_l (struct __locale_t *locale)
{
 400da38:	defffc04 	addi	sp,sp,-16
 400da3c:	dfc00315 	stw	ra,12(sp)
 400da40:	df000215 	stw	fp,8(sp)
 400da44:	df000204 	addi	fp,sp,8
 400da48:	e13ffe15 	stw	r4,-8(fp)
  struct lconv *lconv = &locale->lconv;
 400da4c:	e0bffe17 	ldw	r2,-8(fp)
 400da50:	10803c04 	addi	r2,r2,240
 400da54:	e0bfff15 	stw	r2,-4(fp)
  if (locale == __get_C_locale ())
 400da58:	400da100 	call	400da10 <__get_C_locale>
 400da5c:	1007883a 	mov	r3,r2
 400da60:	e0bffe17 	ldw	r2,-8(fp)
 400da64:	10c0021e 	bne	r2,r3,400da70 <__localeconv_l+0x38>
    return lconv;
 400da68:	e0bfff17 	ldw	r2,-4(fp)
 400da6c:	00000106 	br	400da74 <__localeconv_l+0x3c>
  lconv->int_n_sep_by_space = m->n_sep_by_space[0];
  lconv->int_n_sign_posn = m->n_sign_posn[0];
  lconv->int_p_sign_posn = m->p_sign_posn[0];
#endif /* !__HAVE_LOCALE_INFO_EXTENDED__ */
#endif /* __HAVE_LOCALE_INFO__ */
  return lconv;
 400da70:	e0bfff17 	ldw	r2,-4(fp)
}
 400da74:	e037883a 	mov	sp,fp
 400da78:	dfc00117 	ldw	ra,4(sp)
 400da7c:	df000017 	ldw	fp,0(sp)
 400da80:	dec00204 	addi	sp,sp,8
 400da84:	f800283a 	ret

0400da88 <_localeconv_r>:

struct lconv *
_localeconv_r (struct _reent *data)
{
 400da88:	defffd04 	addi	sp,sp,-12
 400da8c:	dfc00215 	stw	ra,8(sp)
 400da90:	df000115 	stw	fp,4(sp)
 400da94:	df000104 	addi	fp,sp,4
 400da98:	e13fff15 	stw	r4,-4(fp)
  /* Note that we always fall back to the global locale, even in case
     of specifying a reent.  Otherwise a call to _localeconv_r would just
     crash if the reent locale pointer is NULL. */
  return __localeconv_l (__get_current_locale ());
 400da9c:	400d9e80 	call	400d9e8 <__get_current_locale>
 400daa0:	1009883a 	mov	r4,r2
 400daa4:	400da380 	call	400da38 <__localeconv_l>
}
 400daa8:	e037883a 	mov	sp,fp
 400daac:	dfc00117 	ldw	ra,4(sp)
 400dab0:	df000017 	ldw	fp,0(sp)
 400dab4:	dec00204 	addi	sp,sp,8
 400dab8:	f800283a 	ret

0400dabc <localeconv>:

#ifndef _REENT_ONLY
struct lconv *
localeconv (void)
{
 400dabc:	defffe04 	addi	sp,sp,-8
 400dac0:	dfc00115 	stw	ra,4(sp)
 400dac4:	df000015 	stw	fp,0(sp)
 400dac8:	d839883a 	mov	fp,sp
  return __localeconv_l (__get_current_locale ());
 400dacc:	400d9e80 	call	400d9e8 <__get_current_locale>
 400dad0:	1009883a 	mov	r4,r2
 400dad4:	400da380 	call	400da38 <__localeconv_l>
}
 400dad8:	e037883a 	mov	sp,fp
 400dadc:	dfc00117 	ldw	ra,4(sp)
 400dae0:	df000017 	ldw	fp,0(sp)
 400dae4:	dec00204 	addi	sp,sp,8
 400dae8:	f800283a 	ret

0400daec <__smakebuf_r>:
 */

void
__smakebuf_r (struct _reent *ptr,
       register FILE *fp)
{
 400daec:	defff804 	addi	sp,sp,-32
 400daf0:	dfc00715 	stw	ra,28(sp)
 400daf4:	df000615 	stw	fp,24(sp)
 400daf8:	dc400515 	stw	r17,20(sp)
 400dafc:	dc000415 	stw	r16,16(sp)
 400db00:	df000604 	addi	fp,sp,24
 400db04:	e13ffa15 	stw	r4,-24(fp)
 400db08:	2821883a 	mov	r16,r5
  register void *p;
  int flags;
  size_t size;
  int couldbetty;

  if (fp->_flags & __SNBF)
 400db0c:	8080030b 	ldhu	r2,12(r16)
 400db10:	10bfffcc 	andi	r2,r2,65535
 400db14:	1080008c 	andi	r2,r2,2
 400db18:	10000726 	beq	r2,zero,400db38 <__smakebuf_r+0x4c>
    {
      fp->_bf._base = fp->_p = fp->_nbuf;
 400db1c:	808010c4 	addi	r2,r16,67
 400db20:	80800015 	stw	r2,0(r16)
 400db24:	80800017 	ldw	r2,0(r16)
 400db28:	80800415 	stw	r2,16(r16)
      fp->_bf._size = 1;
 400db2c:	00800044 	movi	r2,1
 400db30:	80800515 	stw	r2,20(r16)
 400db34:	00005006 	br	400dc78 <__smakebuf_r+0x18c>
      return;
    }
  flags = __swhatbuf_r (ptr, fp, &size, &couldbetty);
 400db38:	e0fffb04 	addi	r3,fp,-20
 400db3c:	e0bffc04 	addi	r2,fp,-16
 400db40:	180f883a 	mov	r7,r3
 400db44:	100d883a 	mov	r6,r2
 400db48:	800b883a 	mov	r5,r16
 400db4c:	e13ffa17 	ldw	r4,-24(fp)
 400db50:	400dc940 	call	400dc94 <__swhatbuf_r>
 400db54:	e0bffd15 	stw	r2,-12(fp)
  /* Make unbuffered by default: */                /* IntelSpecific */
  if (couldbetty && _isatty_r (ptr, fp->_file))    /* IntelSpecific */
 400db58:	e0bffb17 	ldw	r2,-20(fp)
 400db5c:	10001126 	beq	r2,zero,400dba4 <__smakebuf_r+0xb8>
 400db60:	8080038b 	ldhu	r2,14(r16)
 400db64:	10bfffcc 	andi	r2,r2,65535
 400db68:	10a0001c 	xori	r2,r2,32768
 400db6c:	10a00004 	addi	r2,r2,-32768
 400db70:	100b883a 	mov	r5,r2
 400db74:	e13ffa17 	ldw	r4,-24(fp)
 400db78:	40138140 	call	4013814 <_isatty_r>
 400db7c:	10000926 	beq	r2,zero,400dba4 <__smakebuf_r+0xb8>
  {                                                /* IntelSpecific */
    fp->_flags |= __SLBF;                          /* IntelSpecific __SLBF == "line buffered */
 400db80:	8080030b 	ldhu	r2,12(r16)
 400db84:	10800054 	ori	r2,r2,1
 400db88:	8080030d 	sth	r2,12(r16)
    fp->_bf._base = fp->_p = fp->_nbuf;            /* IntelSpecific (see newlib/libc/include/stdio.h) */
 400db8c:	808010c4 	addi	r2,r16,67
 400db90:	80800015 	stw	r2,0(r16)
 400db94:	80800017 	ldw	r2,0(r16)
 400db98:	80800415 	stw	r2,16(r16)
    fp->_bf._size = 1;                             /* IntelSpecific */
 400db9c:	00800044 	movi	r2,1
 400dba0:	80800515 	stw	r2,20(r16)
  }                                                /* IntelSpecific */
  if ((p = _malloc_r (ptr, size)) == NULL)
 400dba4:	e0bffc17 	ldw	r2,-16(fp)
 400dba8:	100b883a 	mov	r5,r2
 400dbac:	e13ffa17 	ldw	r4,-24(fp)
 400dbb0:	400e1400 	call	400e140 <_malloc_r>
 400dbb4:	1023883a 	mov	r17,r2
 400dbb8:	8800101e 	bne	r17,zero,400dbfc <__smakebuf_r+0x110>
    {
      if (!(fp->_flags & __SSTR))
 400dbbc:	8080030b 	ldhu	r2,12(r16)
 400dbc0:	10bfffcc 	andi	r2,r2,65535
 400dbc4:	1080800c 	andi	r2,r2,512
 400dbc8:	10002b1e 	bne	r2,zero,400dc78 <__smakebuf_r+0x18c>
	{
	  fp->_flags = (fp->_flags & ~__SLBF) | __SNBF;
 400dbcc:	80c0030b 	ldhu	r3,12(r16)
 400dbd0:	00bfff04 	movi	r2,-4
 400dbd4:	1884703a 	and	r2,r3,r2
 400dbd8:	10800094 	ori	r2,r2,2
 400dbdc:	8080030d 	sth	r2,12(r16)
	  fp->_bf._base = fp->_p = fp->_nbuf;
 400dbe0:	808010c4 	addi	r2,r16,67
 400dbe4:	80800015 	stw	r2,0(r16)
 400dbe8:	80800017 	ldw	r2,0(r16)
 400dbec:	80800415 	stw	r2,16(r16)
	  fp->_bf._size = 1;
 400dbf0:	00800044 	movi	r2,1
 400dbf4:	80800515 	stw	r2,20(r16)
 400dbf8:	00001f06 	br	400dc78 <__smakebuf_r+0x18c>
	}
    }
  else
    {
      ptr->__cleanup = _cleanup_r;
 400dbfc:	e0fffa17 	ldw	r3,-24(fp)
 400dc00:	00810074 	movhi	r2,1025
 400dc04:	10b22604 	addi	r2,r2,-14184
 400dc08:	18800f15 	stw	r2,60(r3)
      fp->_flags |= __SMBF;
 400dc0c:	8080030b 	ldhu	r2,12(r16)
 400dc10:	10802014 	ori	r2,r2,128
 400dc14:	8080030d 	sth	r2,12(r16)
      fp->_bf._base = fp->_p = (unsigned char *) p;
 400dc18:	84400015 	stw	r17,0(r16)
 400dc1c:	80800017 	ldw	r2,0(r16)
 400dc20:	80800415 	stw	r2,16(r16)
      fp->_bf._size = size;
 400dc24:	e0bffc17 	ldw	r2,-16(fp)
 400dc28:	80800515 	stw	r2,20(r16)
      if (couldbetty && _isatty_r (ptr, fp->_file))
 400dc2c:	e0bffb17 	ldw	r2,-20(fp)
 400dc30:	10000d26 	beq	r2,zero,400dc68 <__smakebuf_r+0x17c>
 400dc34:	8080038b 	ldhu	r2,14(r16)
 400dc38:	10bfffcc 	andi	r2,r2,65535
 400dc3c:	10a0001c 	xori	r2,r2,32768
 400dc40:	10a00004 	addi	r2,r2,-32768
 400dc44:	100b883a 	mov	r5,r2
 400dc48:	e13ffa17 	ldw	r4,-24(fp)
 400dc4c:	40138140 	call	4013814 <_isatty_r>
 400dc50:	10000526 	beq	r2,zero,400dc68 <__smakebuf_r+0x17c>
	fp->_flags = (fp->_flags & ~__SNBF) | __SLBF;
 400dc54:	80c0030b 	ldhu	r3,12(r16)
 400dc58:	00bfff04 	movi	r2,-4
 400dc5c:	1884703a 	and	r2,r3,r2
 400dc60:	10800054 	ori	r2,r2,1
 400dc64:	8080030d 	sth	r2,12(r16)
      fp->_flags |= flags;
 400dc68:	8080030b 	ldhu	r2,12(r16)
 400dc6c:	e0fffd17 	ldw	r3,-12(fp)
 400dc70:	10c4b03a 	or	r2,r2,r3
 400dc74:	8080030d 	sth	r2,12(r16)
    }
}
 400dc78:	e6fffe04 	addi	sp,fp,-8
 400dc7c:	dfc00317 	ldw	ra,12(sp)
 400dc80:	df000217 	ldw	fp,8(sp)
 400dc84:	dc400117 	ldw	r17,4(sp)
 400dc88:	dc000017 	ldw	r16,0(sp)
 400dc8c:	dec00404 	addi	sp,sp,16
 400dc90:	f800283a 	ret

0400dc94 <__swhatbuf_r>:
int
__swhatbuf_r (struct _reent *ptr,
	FILE *fp,
	size_t *bufsize,
	int *couldbetty)
{
 400dc94:	deffe704 	addi	sp,sp,-100
 400dc98:	dfc01815 	stw	ra,96(sp)
 400dc9c:	df001715 	stw	fp,92(sp)
 400dca0:	df001704 	addi	fp,sp,92
 400dca4:	e13fec15 	stw	r4,-80(fp)
 400dca8:	e17feb15 	stw	r5,-84(fp)
 400dcac:	e1bfea15 	stw	r6,-88(fp)
 400dcb0:	e1ffe915 	stw	r7,-92(fp)
#ifdef _FSEEK_OPTIMIZATION
  const int snpt = __SNPT;
 400dcb4:	00820004 	movi	r2,2048
 400dcb8:	e0bfff15 	stw	r2,-4(fp)

  if (fp->_file < 0 || _fstat64_r (ptr, fp->_file, &st) < 0)
#else
  struct stat st;

  if (fp->_file < 0 || _fstat_r (ptr, fp->_file, &st) < 0)
 400dcbc:	e0bfeb17 	ldw	r2,-84(fp)
 400dcc0:	1080038b 	ldhu	r2,14(r2)
 400dcc4:	10bfffcc 	andi	r2,r2,65535
 400dcc8:	10a0001c 	xori	r2,r2,32768
 400dccc:	10a00004 	addi	r2,r2,-32768
 400dcd0:	10000b16 	blt	r2,zero,400dd00 <__swhatbuf_r+0x6c>
 400dcd4:	e0bfeb17 	ldw	r2,-84(fp)
 400dcd8:	1080038b 	ldhu	r2,14(r2)
 400dcdc:	10bfffcc 	andi	r2,r2,65535
 400dce0:	10a0001c 	xori	r2,r2,32768
 400dce4:	10a00004 	addi	r2,r2,-32768
 400dce8:	e0ffed04 	addi	r3,fp,-76
 400dcec:	180d883a 	mov	r6,r3
 400dcf0:	100b883a 	mov	r5,r2
 400dcf4:	e13fec17 	ldw	r4,-80(fp)
 400dcf8:	40137ac0 	call	40137ac <_fstat_r>
 400dcfc:	1000100e 	bge	r2,zero,400dd40 <__swhatbuf_r+0xac>
#endif
    {
      *couldbetty = 0;
 400dd00:	e0bfe917 	ldw	r2,-92(fp)
 400dd04:	10000015 	stw	zero,0(r2)
      /* Check if we are be called by asprintf family for initial buffer.  */
      if (fp->_flags & __SMBF)
 400dd08:	e0bfeb17 	ldw	r2,-84(fp)
 400dd0c:	1080030b 	ldhu	r2,12(r2)
 400dd10:	10bfffcc 	andi	r2,r2,65535
 400dd14:	1080200c 	andi	r2,r2,128
 400dd18:	10000426 	beq	r2,zero,400dd2c <__swhatbuf_r+0x98>
        *bufsize = _DEFAULT_ASPRINTF_BUFSIZE;
 400dd1c:	e0bfea17 	ldw	r2,-88(fp)
 400dd20:	00c01004 	movi	r3,64
 400dd24:	10c00015 	stw	r3,0(r2)
 400dd28:	00000306 	br	400dd38 <__swhatbuf_r+0xa4>
      else
        *bufsize = BUFSIZ;
 400dd2c:	e0bfea17 	ldw	r2,-88(fp)
 400dd30:	00c10004 	movi	r3,1024
 400dd34:	10c00015 	stw	r3,0(r2)
      return (0);
 400dd38:	0005883a 	mov	r2,zero
 400dd3c:	00000a06 	br	400dd68 <__swhatbuf_r+0xd4>
    }

  /* could be a tty iff it is a character device */
  *couldbetty = S_ISCHR(st.st_mode);
 400dd40:	e0bfee17 	ldw	r2,-72(fp)
 400dd44:	10bc000c 	andi	r2,r2,61440
 400dd48:	10880020 	cmpeqi	r2,r2,8192
 400dd4c:	10c03fcc 	andi	r3,r2,255
 400dd50:	e0bfe917 	ldw	r2,-92(fp)
 400dd54:	10c00015 	stw	r3,0(r2)
      *bufsize = st.st_blksize;
      fp->_blksize = st.st_blksize;
      return ((st.st_mode & S_IFMT) == S_IFREG ?  __SOPT : snpt);
    }
#endif
  *bufsize = BUFSIZ;
 400dd58:	e0bfea17 	ldw	r2,-88(fp)
 400dd5c:	00c10004 	movi	r3,1024
 400dd60:	10c00015 	stw	r3,0(r2)
  return (snpt);
 400dd64:	e0bfff17 	ldw	r2,-4(fp)
}
 400dd68:	e037883a 	mov	sp,fp
 400dd6c:	dfc00117 	ldw	ra,4(sp)
 400dd70:	df000017 	ldw	fp,0(sp)
 400dd74:	dec00204 	addi	sp,sp,8
 400dd78:	f800283a 	ret

0400dd7c <malloc_extend_top>:
{
 400dd7c:	defff104 	addi	sp,sp,-60
 400dd80:	dfc00e15 	stw	ra,56(sp)
 400dd84:	df000d15 	stw	fp,52(sp)
 400dd88:	df000d04 	addi	fp,sp,52
 400dd8c:	e13ff415 	stw	r4,-48(fp)
 400dd90:	e17ff315 	stw	r5,-52(fp)
  int correction_failed = 0;      /* whether we should relax the assertion */
 400dd94:	e03ffb15 	stw	zero,-20(fp)
  mchunkptr old_top     = top;  /* Record state of old top */
 400dd98:	008100b4 	movhi	r2,1026
 400dd9c:	10ad9404 	addi	r2,r2,-18864
 400dda0:	10800217 	ldw	r2,8(r2)
 400dda4:	e0bffa15 	stw	r2,-24(fp)
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
 400dda8:	e0bffa17 	ldw	r2,-24(fp)
 400ddac:	10c00117 	ldw	r3,4(r2)
 400ddb0:	00bfff04 	movi	r2,-4
 400ddb4:	1884703a 	and	r2,r3,r2
 400ddb8:	e0bff915 	stw	r2,-28(fp)
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));
 400ddbc:	e0fffa17 	ldw	r3,-24(fp)
 400ddc0:	e0bff917 	ldw	r2,-28(fp)
 400ddc4:	1885883a 	add	r2,r3,r2
 400ddc8:	e0bff815 	stw	r2,-32(fp)
  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
 400ddcc:	d0e72417 	ldw	r3,-25456(gp)
 400ddd0:	e0bff317 	ldw	r2,-52(fp)
 400ddd4:	1885883a 	add	r2,r3,r2
 400ddd8:	10800404 	addi	r2,r2,16
 400dddc:	e0bffc15 	stw	r2,-16(fp)
  unsigned long pagesz    = malloc_getpagesize;
 400dde0:	00840004 	movi	r2,4096
 400dde4:	e0bff715 	stw	r2,-36(fp)
  if (sbrk_base != (char*)(-1))
 400dde8:	d0a00417 	ldw	r2,-32752(gp)
 400ddec:	10bfffe0 	cmpeqi	r2,r2,-1
 400ddf0:	1000081e 	bne	r2,zero,400de14 <malloc_extend_top+0x98>
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);
 400ddf4:	e0fff717 	ldw	r3,-36(fp)
 400ddf8:	e0bffc17 	ldw	r2,-16(fp)
 400ddfc:	1885883a 	add	r2,r3,r2
 400de00:	10ffffc4 	addi	r3,r2,-1
 400de04:	e0bff717 	ldw	r2,-36(fp)
 400de08:	0085c83a 	sub	r2,zero,r2
 400de0c:	1884703a 	and	r2,r3,r2
 400de10:	e0bffc15 	stw	r2,-16(fp)
  brk = (char*)(MORECORE (sbrk_size));
 400de14:	e0bffc17 	ldw	r2,-16(fp)
 400de18:	100b883a 	mov	r5,r2
 400de1c:	e13ff417 	ldw	r4,-48(fp)
 400de20:	40117d80 	call	40117d8 <_sbrk_r>
 400de24:	e0bfff15 	stw	r2,-4(fp)
  if (brk == (char*)(MORECORE_FAILURE) || 
 400de28:	e0bfff17 	ldw	r2,-4(fp)
 400de2c:	10bfffe0 	cmpeqi	r2,r2,-1
 400de30:	1000bd1e 	bne	r2,zero,400e128 <malloc_extend_top+0x3ac>
 400de34:	e0ffff17 	ldw	r3,-4(fp)
 400de38:	e0bff817 	ldw	r2,-32(fp)
 400de3c:	1880042e 	bgeu	r3,r2,400de50 <malloc_extend_top+0xd4>
      (brk < old_end && old_top != initial_top))
 400de40:	008100b4 	movhi	r2,1026
 400de44:	10ad9404 	addi	r2,r2,-18864
 400de48:	e0fffa17 	ldw	r3,-24(fp)
 400de4c:	1880b61e 	bne	r3,r2,400e128 <malloc_extend_top+0x3ac>
  sbrked_mem += sbrk_size;
 400de50:	008120b4 	movhi	r2,1154
 400de54:	10bae117 	ldw	r2,-5244(r2)
 400de58:	1007883a 	mov	r3,r2
 400de5c:	e0bffc17 	ldw	r2,-16(fp)
 400de60:	1885883a 	add	r2,r3,r2
 400de64:	1007883a 	mov	r3,r2
 400de68:	008120b4 	movhi	r2,1154
 400de6c:	10fae115 	stw	r3,-5244(r2)
  if (brk == old_end /* can just add bytes to current top, unless
 400de70:	e0ffff17 	ldw	r3,-4(fp)
 400de74:	e0bff817 	ldw	r2,-32(fp)
 400de78:	1880101e 	bne	r3,r2,400debc <malloc_extend_top+0x140>
      && ((POINTER_UINT)old_end & (pagesz - 1)) == 0)
 400de7c:	e0bff717 	ldw	r2,-36(fp)
 400de80:	10ffffc4 	addi	r3,r2,-1
 400de84:	e0bff817 	ldw	r2,-32(fp)
 400de88:	1884703a 	and	r2,r3,r2
 400de8c:	10000b1e 	bne	r2,zero,400debc <malloc_extend_top+0x140>
    top_size = sbrk_size + old_top_size;
 400de90:	e0fffc17 	ldw	r3,-16(fp)
 400de94:	e0bff917 	ldw	r2,-28(fp)
 400de98:	1885883a 	add	r2,r3,r2
 400de9c:	e0bff615 	stw	r2,-40(fp)
    set_head(top, top_size | PREV_INUSE);
 400dea0:	008100b4 	movhi	r2,1026
 400dea4:	10ad9404 	addi	r2,r2,-18864
 400dea8:	10800217 	ldw	r2,8(r2)
 400deac:	e0fff617 	ldw	r3,-40(fp)
 400deb0:	18c00054 	ori	r3,r3,1
 400deb4:	10c00115 	stw	r3,4(r2)
 400deb8:	00008a06 	br	400e0e4 <malloc_extend_top+0x368>
    if (sbrk_base == (char*)(-1))  /* First time through. Record base */
 400debc:	d0a00417 	ldw	r2,-32752(gp)
 400dec0:	10bfffd8 	cmpnei	r2,r2,-1
 400dec4:	1000031e 	bne	r2,zero,400ded4 <malloc_extend_top+0x158>
      sbrk_base = brk;
 400dec8:	e0bfff17 	ldw	r2,-4(fp)
 400decc:	d0a00415 	stw	r2,-32752(gp)
 400ded0:	00000806 	br	400def4 <malloc_extend_top+0x178>
      sbrked_mem += brk - (char*)old_end;
 400ded4:	008120b4 	movhi	r2,1154
 400ded8:	10fae117 	ldw	r3,-5244(r2)
 400dedc:	e13fff17 	ldw	r4,-4(fp)
 400dee0:	e0bff817 	ldw	r2,-32(fp)
 400dee4:	2085c83a 	sub	r2,r4,r2
 400dee8:	1887883a 	add	r3,r3,r2
 400deec:	008120b4 	movhi	r2,1154
 400def0:	10fae115 	stw	r3,-5244(r2)
    front_misalign = (POINTER_UINT)chunk2mem(brk) & MALLOC_ALIGN_MASK;
 400def4:	e0bfff17 	ldw	r2,-4(fp)
 400def8:	10800204 	addi	r2,r2,8
 400defc:	108001cc 	andi	r2,r2,7
 400df00:	e0bff515 	stw	r2,-44(fp)
    if (front_misalign > 0) 
 400df04:	e0bff517 	ldw	r2,-44(fp)
 400df08:	10000926 	beq	r2,zero,400df30 <malloc_extend_top+0x1b4>
      correction = (MALLOC_ALIGNMENT) - front_misalign;
 400df0c:	00c00204 	movi	r3,8
 400df10:	e0bff517 	ldw	r2,-44(fp)
 400df14:	1885c83a 	sub	r2,r3,r2
 400df18:	e0bffe15 	stw	r2,-8(fp)
      brk += correction;
 400df1c:	e0ffff17 	ldw	r3,-4(fp)
 400df20:	e0bffe17 	ldw	r2,-8(fp)
 400df24:	1885883a 	add	r2,r3,r2
 400df28:	e0bfff15 	stw	r2,-4(fp)
 400df2c:	00000106 	br	400df34 <malloc_extend_top+0x1b8>
      correction = 0;
 400df30:	e03ffe15 	stw	zero,-8(fp)
    correction += pagesz - ((POINTER_UINT)(brk + sbrk_size) & (pagesz - 1));
 400df34:	e0ffff17 	ldw	r3,-4(fp)
 400df38:	e0bffc17 	ldw	r2,-16(fp)
 400df3c:	1885883a 	add	r2,r3,r2
 400df40:	1007883a 	mov	r3,r2
 400df44:	e0bff717 	ldw	r2,-36(fp)
 400df48:	10bfffc4 	addi	r2,r2,-1
 400df4c:	1884703a 	and	r2,r3,r2
 400df50:	e0fff717 	ldw	r3,-36(fp)
 400df54:	1885c83a 	sub	r2,r3,r2
 400df58:	e0fffe17 	ldw	r3,-8(fp)
 400df5c:	1885883a 	add	r2,r3,r2
 400df60:	e0bffe15 	stw	r2,-8(fp)
    correction &= (pagesz - 1);
 400df64:	e0bff717 	ldw	r2,-36(fp)
 400df68:	10bfffc4 	addi	r2,r2,-1
 400df6c:	e0fffe17 	ldw	r3,-8(fp)
 400df70:	1884703a 	and	r2,r3,r2
 400df74:	e0bffe15 	stw	r2,-8(fp)
    new_brk = (char*)(MORECORE (correction));
 400df78:	e0bffe17 	ldw	r2,-8(fp)
 400df7c:	100b883a 	mov	r5,r2
 400df80:	e13ff417 	ldw	r4,-48(fp)
 400df84:	40117d80 	call	40117d8 <_sbrk_r>
 400df88:	e0bffd15 	stw	r2,-12(fp)
    if (new_brk == (char*)(MORECORE_FAILURE))
 400df8c:	e0bffd17 	ldw	r2,-12(fp)
 400df90:	10bfffd8 	cmpnei	r2,r2,-1
 400df94:	10000e1e 	bne	r2,zero,400dfd0 <malloc_extend_top+0x254>
	correction = 0;
 400df98:	e03ffe15 	stw	zero,-8(fp)
	correction_failed = 1;
 400df9c:	00800044 	movi	r2,1
 400dfa0:	e0bffb15 	stw	r2,-20(fp)
	new_brk = brk + sbrk_size;
 400dfa4:	e0ffff17 	ldw	r3,-4(fp)
 400dfa8:	e0bffc17 	ldw	r2,-16(fp)
 400dfac:	1885883a 	add	r2,r3,r2
 400dfb0:	e0bffd15 	stw	r2,-12(fp)
	if (front_misalign > 0)
 400dfb4:	e0bff517 	ldw	r2,-44(fp)
 400dfb8:	10000526 	beq	r2,zero,400dfd0 <malloc_extend_top+0x254>
	  new_brk -= (MALLOC_ALIGNMENT) - front_misalign;
 400dfbc:	e0bff517 	ldw	r2,-44(fp)
 400dfc0:	10bffe04 	addi	r2,r2,-8
 400dfc4:	e0fffd17 	ldw	r3,-12(fp)
 400dfc8:	1885883a 	add	r2,r3,r2
 400dfcc:	e0bffd15 	stw	r2,-12(fp)
    sbrked_mem += correction;
 400dfd0:	008120b4 	movhi	r2,1154
 400dfd4:	10bae117 	ldw	r2,-5244(r2)
 400dfd8:	1007883a 	mov	r3,r2
 400dfdc:	e0bffe17 	ldw	r2,-8(fp)
 400dfe0:	1885883a 	add	r2,r3,r2
 400dfe4:	1007883a 	mov	r3,r2
 400dfe8:	008120b4 	movhi	r2,1154
 400dfec:	10fae115 	stw	r3,-5244(r2)
    top = (mchunkptr)brk;
 400dff0:	008100b4 	movhi	r2,1026
 400dff4:	10ad9404 	addi	r2,r2,-18864
 400dff8:	e0ffff17 	ldw	r3,-4(fp)
 400dffc:	10c00215 	stw	r3,8(r2)
    top_size = new_brk - brk + correction;
 400e000:	e0fffd17 	ldw	r3,-12(fp)
 400e004:	e0bfff17 	ldw	r2,-4(fp)
 400e008:	1885c83a 	sub	r2,r3,r2
 400e00c:	1007883a 	mov	r3,r2
 400e010:	e0bffe17 	ldw	r2,-8(fp)
 400e014:	10c5883a 	add	r2,r2,r3
 400e018:	e0bff615 	stw	r2,-40(fp)
    set_head(top, top_size | PREV_INUSE);
 400e01c:	008100b4 	movhi	r2,1026
 400e020:	10ad9404 	addi	r2,r2,-18864
 400e024:	10800217 	ldw	r2,8(r2)
 400e028:	e0fff617 	ldw	r3,-40(fp)
 400e02c:	18c00054 	ori	r3,r3,1
 400e030:	10c00115 	stw	r3,4(r2)
    if (old_top != initial_top)
 400e034:	008100b4 	movhi	r2,1026
 400e038:	10ad9404 	addi	r2,r2,-18864
 400e03c:	e0fffa17 	ldw	r3,-24(fp)
 400e040:	18802826 	beq	r3,r2,400e0e4 <malloc_extend_top+0x368>
      if (old_top_size < MINSIZE) 
 400e044:	e0bff917 	ldw	r2,-28(fp)
 400e048:	10800428 	cmpgeui	r2,r2,16
 400e04c:	1000061e 	bne	r2,zero,400e068 <malloc_extend_top+0x2ec>
        set_head(top, PREV_INUSE); /* will force null return from malloc */
 400e050:	008100b4 	movhi	r2,1026
 400e054:	10ad9404 	addi	r2,r2,-18864
 400e058:	10800217 	ldw	r2,8(r2)
 400e05c:	00c00044 	movi	r3,1
 400e060:	10c00115 	stw	r3,4(r2)
        return;
 400e064:	00003106 	br	400e12c <malloc_extend_top+0x3b0>
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
 400e068:	e0bff917 	ldw	r2,-28(fp)
 400e06c:	10fffd04 	addi	r3,r2,-12
 400e070:	00bffe04 	movi	r2,-8
 400e074:	1884703a 	and	r2,r3,r2
 400e078:	e0bff915 	stw	r2,-28(fp)
      set_head_size(old_top, old_top_size);
 400e07c:	e0bffa17 	ldw	r2,-24(fp)
 400e080:	10800117 	ldw	r2,4(r2)
 400e084:	10c0004c 	andi	r3,r2,1
 400e088:	e0bff917 	ldw	r2,-28(fp)
 400e08c:	1886b03a 	or	r3,r3,r2
 400e090:	e0bffa17 	ldw	r2,-24(fp)
 400e094:	10c00115 	stw	r3,4(r2)
      chunk_at_offset(old_top, old_top_size          )->size =
 400e098:	e0fffa17 	ldw	r3,-24(fp)
 400e09c:	e0bff917 	ldw	r2,-28(fp)
 400e0a0:	1885883a 	add	r2,r3,r2
 400e0a4:	00c00144 	movi	r3,5
 400e0a8:	10c00115 	stw	r3,4(r2)
      chunk_at_offset(old_top, old_top_size + SIZE_SZ)->size =
 400e0ac:	e0bff917 	ldw	r2,-28(fp)
 400e0b0:	10800104 	addi	r2,r2,4
 400e0b4:	e0fffa17 	ldw	r3,-24(fp)
 400e0b8:	1885883a 	add	r2,r3,r2
 400e0bc:	00c00144 	movi	r3,5
 400e0c0:	10c00115 	stw	r3,4(r2)
      if (old_top_size >= MINSIZE) 
 400e0c4:	e0bff917 	ldw	r2,-28(fp)
 400e0c8:	10800430 	cmpltui	r2,r2,16
 400e0cc:	1000051e 	bne	r2,zero,400e0e4 <malloc_extend_top+0x368>
        fREe(RCALL chunk2mem(old_top));
 400e0d0:	e0bffa17 	ldw	r2,-24(fp)
 400e0d4:	10800204 	addi	r2,r2,8
 400e0d8:	100b883a 	mov	r5,r2
 400e0dc:	e13ff417 	ldw	r4,-48(fp)
 400e0e0:	400cb0c0 	call	400cb0c <_free_r>
  if ((unsigned long)sbrked_mem > (unsigned long)max_sbrked_mem) 
 400e0e4:	008120b4 	movhi	r2,1154
 400e0e8:	10bae117 	ldw	r2,-5244(r2)
 400e0ec:	1007883a 	mov	r3,r2
 400e0f0:	d0a72517 	ldw	r2,-25452(gp)
 400e0f4:	10c0032e 	bgeu	r2,r3,400e104 <malloc_extend_top+0x388>
    max_sbrked_mem = sbrked_mem;
 400e0f8:	008120b4 	movhi	r2,1154
 400e0fc:	10bae117 	ldw	r2,-5244(r2)
 400e100:	d0a72515 	stw	r2,-25452(gp)
  if ((unsigned long)(sbrked_mem) > (unsigned long)max_total_mem) 
 400e104:	008120b4 	movhi	r2,1154
 400e108:	10bae117 	ldw	r2,-5244(r2)
 400e10c:	1007883a 	mov	r3,r2
 400e110:	d0a72617 	ldw	r2,-25448(gp)
 400e114:	10c0052e 	bgeu	r2,r3,400e12c <malloc_extend_top+0x3b0>
    max_total_mem = sbrked_mem;
 400e118:	008120b4 	movhi	r2,1154
 400e11c:	10bae117 	ldw	r2,-5244(r2)
 400e120:	d0a72615 	stw	r2,-25448(gp)
 400e124:	00000106 	br	400e12c <malloc_extend_top+0x3b0>
    return;
 400e128:	0001883a 	nop
}
 400e12c:	e037883a 	mov	sp,fp
 400e130:	dfc00117 	ldw	ra,4(sp)
 400e134:	df000017 	ldw	fp,0(sp)
 400e138:	dec00204 	addi	sp,sp,8
 400e13c:	f800283a 	ret

0400e140 <_malloc_r>:
{
 400e140:	deffef04 	addi	sp,sp,-68
 400e144:	dfc01015 	stw	ra,64(sp)
 400e148:	df000f15 	stw	fp,60(sp)
 400e14c:	df000f04 	addi	fp,sp,60
 400e150:	e13ff215 	stw	r4,-56(fp)
 400e154:	e17ff115 	stw	r5,-60(fp)
  INTERNAL_SIZE_T nb  = request2size(bytes);  /* padded request size; */
 400e158:	e0bff117 	ldw	r2,-60(fp)
 400e15c:	108002c4 	addi	r2,r2,11
 400e160:	108005f0 	cmpltui	r2,r2,23
 400e164:	1000051e 	bne	r2,zero,400e17c <_malloc_r+0x3c>
 400e168:	e0bff117 	ldw	r2,-60(fp)
 400e16c:	10c002c4 	addi	r3,r2,11
 400e170:	00bffe04 	movi	r2,-8
 400e174:	1884703a 	and	r2,r3,r2
 400e178:	00000106 	br	400e180 <_malloc_r+0x40>
 400e17c:	00800404 	movi	r2,16
 400e180:	e0bff615 	stw	r2,-40(fp)
  if (nb > INT_MAX || nb < bytes)
 400e184:	e0bff617 	ldw	r2,-40(fp)
 400e188:	10000316 	blt	r2,zero,400e198 <_malloc_r+0x58>
 400e18c:	e0fff617 	ldw	r3,-40(fp)
 400e190:	e0bff117 	ldw	r2,-60(fp)
 400e194:	1880052e 	bgeu	r3,r2,400e1ac <_malloc_r+0x6c>
    RERRNO = ENOMEM;
 400e198:	e0bff217 	ldw	r2,-56(fp)
 400e19c:	00c00304 	movi	r3,12
 400e1a0:	10c00015 	stw	r3,0(r2)
    return 0;
 400e1a4:	0005883a 	mov	r2,zero
 400e1a8:	0002ba06 	br	400ec94 <_malloc_r+0xb54>
  MALLOC_LOCK;
 400e1ac:	e13ff217 	ldw	r4,-56(fp)
 400e1b0:	40186a00 	call	40186a0 <__malloc_lock>
  if (is_small_request(nb))  /* Faster version for small requests */
 400e1b4:	e0bff617 	ldw	r2,-40(fp)
 400e1b8:	10807e28 	cmpgeui	r2,r2,504
 400e1bc:	10003e1e 	bne	r2,zero,400e2b8 <_malloc_r+0x178>
    idx = smallbin_index(nb); 
 400e1c0:	e0bff617 	ldw	r2,-40(fp)
 400e1c4:	1004d0fa 	srli	r2,r2,3
 400e1c8:	e0bffe15 	stw	r2,-8(fp)
    q = bin_at(idx);
 400e1cc:	e0bffe17 	ldw	r2,-8(fp)
 400e1d0:	10800044 	addi	r2,r2,1
 400e1d4:	1085883a 	add	r2,r2,r2
 400e1d8:	100690ba 	slli	r3,r2,2
 400e1dc:	008100b4 	movhi	r2,1026
 400e1e0:	10ad9404 	addi	r2,r2,-18864
 400e1e4:	1885883a 	add	r2,r3,r2
 400e1e8:	10bffe04 	addi	r2,r2,-8
 400e1ec:	e0bff715 	stw	r2,-36(fp)
    victim = last(q);
 400e1f0:	e0bff717 	ldw	r2,-36(fp)
 400e1f4:	10800317 	ldw	r2,12(r2)
 400e1f8:	e0bfff15 	stw	r2,-4(fp)
    if (victim == q)
 400e1fc:	e0ffff17 	ldw	r3,-4(fp)
 400e200:	e0bff717 	ldw	r2,-36(fp)
 400e204:	1880061e 	bne	r3,r2,400e220 <_malloc_r+0xe0>
      q = next_bin(q);
 400e208:	e0bff717 	ldw	r2,-36(fp)
 400e20c:	10800204 	addi	r2,r2,8
 400e210:	e0bff715 	stw	r2,-36(fp)
      victim = last(q);
 400e214:	e0bff717 	ldw	r2,-36(fp)
 400e218:	10800317 	ldw	r2,12(r2)
 400e21c:	e0bfff15 	stw	r2,-4(fp)
    if (victim != q)
 400e220:	e0ffff17 	ldw	r3,-4(fp)
 400e224:	e0bff717 	ldw	r2,-36(fp)
 400e228:	18801f26 	beq	r3,r2,400e2a8 <_malloc_r+0x168>
      victim_size = chunksize(victim);
 400e22c:	e0bfff17 	ldw	r2,-4(fp)
 400e230:	10c00117 	ldw	r3,4(r2)
 400e234:	00bfff04 	movi	r2,-4
 400e238:	1884703a 	and	r2,r3,r2
 400e23c:	e0bff515 	stw	r2,-44(fp)
      unlink(victim, bck, fwd);
 400e240:	e0bfff17 	ldw	r2,-4(fp)
 400e244:	10800317 	ldw	r2,12(r2)
 400e248:	e0bff815 	stw	r2,-32(fp)
 400e24c:	e0bfff17 	ldw	r2,-4(fp)
 400e250:	10800217 	ldw	r2,8(r2)
 400e254:	e0bff915 	stw	r2,-28(fp)
 400e258:	e0bff917 	ldw	r2,-28(fp)
 400e25c:	e0fff817 	ldw	r3,-32(fp)
 400e260:	10c00315 	stw	r3,12(r2)
 400e264:	e0bff817 	ldw	r2,-32(fp)
 400e268:	e0fff917 	ldw	r3,-28(fp)
 400e26c:	10c00215 	stw	r3,8(r2)
      set_inuse_bit_at_offset(victim, victim_size);
 400e270:	e0ffff17 	ldw	r3,-4(fp)
 400e274:	e0bff517 	ldw	r2,-44(fp)
 400e278:	1885883a 	add	r2,r3,r2
 400e27c:	10c00117 	ldw	r3,4(r2)
 400e280:	e13fff17 	ldw	r4,-4(fp)
 400e284:	e0bff517 	ldw	r2,-44(fp)
 400e288:	2085883a 	add	r2,r4,r2
 400e28c:	18c00054 	ori	r3,r3,1
 400e290:	10c00115 	stw	r3,4(r2)
      MALLOC_UNLOCK;
 400e294:	e13ff217 	ldw	r4,-56(fp)
 400e298:	40186c40 	call	40186c4 <__malloc_unlock>
      return chunk2mem(victim);
 400e29c:	e0bfff17 	ldw	r2,-4(fp)
 400e2a0:	10800204 	addi	r2,r2,8
 400e2a4:	00027b06 	br	400ec94 <_malloc_r+0xb54>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */
 400e2a8:	e0bffe17 	ldw	r2,-8(fp)
 400e2ac:	10800084 	addi	r2,r2,2
 400e2b0:	e0bffe15 	stw	r2,-8(fp)
 400e2b4:	00007206 	br	400e480 <_malloc_r+0x340>
    idx = bin_index(nb);
 400e2b8:	e0bff617 	ldw	r2,-40(fp)
 400e2bc:	1004d27a 	srli	r2,r2,9
 400e2c0:	1000031e 	bne	r2,zero,400e2d0 <_malloc_r+0x190>
 400e2c4:	e0bff617 	ldw	r2,-40(fp)
 400e2c8:	1004d0fa 	srli	r2,r2,3
 400e2cc:	00002906 	br	400e374 <_malloc_r+0x234>
 400e2d0:	e0bff617 	ldw	r2,-40(fp)
 400e2d4:	1004d27a 	srli	r2,r2,9
 400e2d8:	10800168 	cmpgeui	r2,r2,5
 400e2dc:	1000041e 	bne	r2,zero,400e2f0 <_malloc_r+0x1b0>
 400e2e0:	e0bff617 	ldw	r2,-40(fp)
 400e2e4:	1004d1ba 	srli	r2,r2,6
 400e2e8:	10800e04 	addi	r2,r2,56
 400e2ec:	00002106 	br	400e374 <_malloc_r+0x234>
 400e2f0:	e0bff617 	ldw	r2,-40(fp)
 400e2f4:	1004d27a 	srli	r2,r2,9
 400e2f8:	10800568 	cmpgeui	r2,r2,21
 400e2fc:	1000041e 	bne	r2,zero,400e310 <_malloc_r+0x1d0>
 400e300:	e0bff617 	ldw	r2,-40(fp)
 400e304:	1004d27a 	srli	r2,r2,9
 400e308:	108016c4 	addi	r2,r2,91
 400e30c:	00001906 	br	400e374 <_malloc_r+0x234>
 400e310:	e0bff617 	ldw	r2,-40(fp)
 400e314:	1004d27a 	srli	r2,r2,9
 400e318:	10801568 	cmpgeui	r2,r2,85
 400e31c:	1000041e 	bne	r2,zero,400e330 <_malloc_r+0x1f0>
 400e320:	e0bff617 	ldw	r2,-40(fp)
 400e324:	1004d33a 	srli	r2,r2,12
 400e328:	10801b84 	addi	r2,r2,110
 400e32c:	00001106 	br	400e374 <_malloc_r+0x234>
 400e330:	e0bff617 	ldw	r2,-40(fp)
 400e334:	1004d27a 	srli	r2,r2,9
 400e338:	10805568 	cmpgeui	r2,r2,341
 400e33c:	1000041e 	bne	r2,zero,400e350 <_malloc_r+0x210>
 400e340:	e0bff617 	ldw	r2,-40(fp)
 400e344:	1004d3fa 	srli	r2,r2,15
 400e348:	10801dc4 	addi	r2,r2,119
 400e34c:	00000906 	br	400e374 <_malloc_r+0x234>
 400e350:	e0bff617 	ldw	r2,-40(fp)
 400e354:	1004d27a 	srli	r2,r2,9
 400e358:	10815568 	cmpgeui	r2,r2,1365
 400e35c:	1000041e 	bne	r2,zero,400e370 <_malloc_r+0x230>
 400e360:	e0bff617 	ldw	r2,-40(fp)
 400e364:	1004d4ba 	srli	r2,r2,18
 400e368:	10801f04 	addi	r2,r2,124
 400e36c:	00000106 	br	400e374 <_malloc_r+0x234>
 400e370:	00801f84 	movi	r2,126
 400e374:	e0bffe15 	stw	r2,-8(fp)
    bin = bin_at(idx);
 400e378:	e0bffe17 	ldw	r2,-8(fp)
 400e37c:	10800044 	addi	r2,r2,1
 400e380:	1085883a 	add	r2,r2,r2
 400e384:	100690ba 	slli	r3,r2,2
 400e388:	008100b4 	movhi	r2,1026
 400e38c:	10ad9404 	addi	r2,r2,-18864
 400e390:	1885883a 	add	r2,r3,r2
 400e394:	10bffe04 	addi	r2,r2,-8
 400e398:	e0bffd15 	stw	r2,-12(fp)
    for (victim = last(bin); victim != bin; victim = victim->bk)
 400e39c:	e0bffd17 	ldw	r2,-12(fp)
 400e3a0:	10800317 	ldw	r2,12(r2)
 400e3a4:	e0bfff15 	stw	r2,-4(fp)
 400e3a8:	00002f06 	br	400e468 <_malloc_r+0x328>
      victim_size = chunksize(victim);
 400e3ac:	e0bfff17 	ldw	r2,-4(fp)
 400e3b0:	10c00117 	ldw	r3,4(r2)
 400e3b4:	00bfff04 	movi	r2,-4
 400e3b8:	1884703a 	and	r2,r3,r2
 400e3bc:	e0bff515 	stw	r2,-44(fp)
      remainder_size = long_sub_size_t(victim_size, nb);
 400e3c0:	e0fff517 	ldw	r3,-44(fp)
 400e3c4:	e0bff617 	ldw	r2,-40(fp)
 400e3c8:	1885c83a 	sub	r2,r3,r2
 400e3cc:	e0bffc15 	stw	r2,-16(fp)
      if (remainder_size >= (long)MINSIZE) /* too big */
 400e3d0:	e0bffc17 	ldw	r2,-16(fp)
 400e3d4:	10800410 	cmplti	r2,r2,16
 400e3d8:	1000041e 	bne	r2,zero,400e3ec <_malloc_r+0x2ac>
        --idx; /* adjust to rescan below after checking last remainder */
 400e3dc:	e0bffe17 	ldw	r2,-8(fp)
 400e3e0:	10bfffc4 	addi	r2,r2,-1
 400e3e4:	e0bffe15 	stw	r2,-8(fp)
        break;   
 400e3e8:	00002206 	br	400e474 <_malloc_r+0x334>
      else if (remainder_size >= 0) /* exact fit */
 400e3ec:	e0bffc17 	ldw	r2,-16(fp)
 400e3f0:	10001a16 	blt	r2,zero,400e45c <_malloc_r+0x31c>
        unlink(victim, bck, fwd);
 400e3f4:	e0bfff17 	ldw	r2,-4(fp)
 400e3f8:	10800317 	ldw	r2,12(r2)
 400e3fc:	e0bff815 	stw	r2,-32(fp)
 400e400:	e0bfff17 	ldw	r2,-4(fp)
 400e404:	10800217 	ldw	r2,8(r2)
 400e408:	e0bff915 	stw	r2,-28(fp)
 400e40c:	e0bff917 	ldw	r2,-28(fp)
 400e410:	e0fff817 	ldw	r3,-32(fp)
 400e414:	10c00315 	stw	r3,12(r2)
 400e418:	e0bff817 	ldw	r2,-32(fp)
 400e41c:	e0fff917 	ldw	r3,-28(fp)
 400e420:	10c00215 	stw	r3,8(r2)
        set_inuse_bit_at_offset(victim, victim_size);
 400e424:	e0ffff17 	ldw	r3,-4(fp)
 400e428:	e0bff517 	ldw	r2,-44(fp)
 400e42c:	1885883a 	add	r2,r3,r2
 400e430:	10c00117 	ldw	r3,4(r2)
 400e434:	e13fff17 	ldw	r4,-4(fp)
 400e438:	e0bff517 	ldw	r2,-44(fp)
 400e43c:	2085883a 	add	r2,r4,r2
 400e440:	18c00054 	ori	r3,r3,1
 400e444:	10c00115 	stw	r3,4(r2)
	MALLOC_UNLOCK;
 400e448:	e13ff217 	ldw	r4,-56(fp)
 400e44c:	40186c40 	call	40186c4 <__malloc_unlock>
        return chunk2mem(victim);
 400e450:	e0bfff17 	ldw	r2,-4(fp)
 400e454:	10800204 	addi	r2,r2,8
 400e458:	00020e06 	br	400ec94 <_malloc_r+0xb54>
    for (victim = last(bin); victim != bin; victim = victim->bk)
 400e45c:	e0bfff17 	ldw	r2,-4(fp)
 400e460:	10800317 	ldw	r2,12(r2)
 400e464:	e0bfff15 	stw	r2,-4(fp)
 400e468:	e0ffff17 	ldw	r3,-4(fp)
 400e46c:	e0bffd17 	ldw	r2,-12(fp)
 400e470:	18bfce1e 	bne	r3,r2,400e3ac <_malloc_r+0x26c>
    ++idx; 
 400e474:	e0bffe17 	ldw	r2,-8(fp)
 400e478:	10800044 	addi	r2,r2,1
 400e47c:	e0bffe15 	stw	r2,-8(fp)
  if ( (victim = last_remainder->fd) != last_remainder)
 400e480:	008100b4 	movhi	r2,1026
 400e484:	10ad9604 	addi	r2,r2,-18856
 400e488:	10800217 	ldw	r2,8(r2)
 400e48c:	e0bfff15 	stw	r2,-4(fp)
 400e490:	008100b4 	movhi	r2,1026
 400e494:	10ad9604 	addi	r2,r2,-18856
 400e498:	e0ffff17 	ldw	r3,-4(fp)
 400e49c:	1880e426 	beq	r3,r2,400e830 <_malloc_r+0x6f0>
    victim_size = chunksize(victim);
 400e4a0:	e0bfff17 	ldw	r2,-4(fp)
 400e4a4:	10c00117 	ldw	r3,4(r2)
 400e4a8:	00bfff04 	movi	r2,-4
 400e4ac:	1884703a 	and	r2,r3,r2
 400e4b0:	e0bff515 	stw	r2,-44(fp)
    remainder_size = long_sub_size_t(victim_size, nb);
 400e4b4:	e0fff517 	ldw	r3,-44(fp)
 400e4b8:	e0bff617 	ldw	r2,-40(fp)
 400e4bc:	1885c83a 	sub	r2,r3,r2
 400e4c0:	e0bffc15 	stw	r2,-16(fp)
    if (remainder_size >= (long)MINSIZE) /* re-split */
 400e4c4:	e0bffc17 	ldw	r2,-16(fp)
 400e4c8:	10800410 	cmplti	r2,r2,16
 400e4cc:	1000271e 	bne	r2,zero,400e56c <_malloc_r+0x42c>
      remainder = chunk_at_offset(victim, nb);
 400e4d0:	e0ffff17 	ldw	r3,-4(fp)
 400e4d4:	e0bff617 	ldw	r2,-40(fp)
 400e4d8:	1885883a 	add	r2,r3,r2
 400e4dc:	e0bff315 	stw	r2,-52(fp)
      set_head(victim, nb | PREV_INUSE);
 400e4e0:	e0bff617 	ldw	r2,-40(fp)
 400e4e4:	10c00054 	ori	r3,r2,1
 400e4e8:	e0bfff17 	ldw	r2,-4(fp)
 400e4ec:	10c00115 	stw	r3,4(r2)
      link_last_remainder(remainder);
 400e4f0:	008100b4 	movhi	r2,1026
 400e4f4:	10ad9604 	addi	r2,r2,-18856
 400e4f8:	e0fff317 	ldw	r3,-52(fp)
 400e4fc:	10c00315 	stw	r3,12(r2)
 400e500:	00c100b4 	movhi	r3,1026
 400e504:	18ed9604 	addi	r3,r3,-18856
 400e508:	10800317 	ldw	r2,12(r2)
 400e50c:	18800215 	stw	r2,8(r3)
 400e510:	008100b4 	movhi	r2,1026
 400e514:	10ad9604 	addi	r2,r2,-18856
 400e518:	e0fff317 	ldw	r3,-52(fp)
 400e51c:	18800315 	stw	r2,12(r3)
 400e520:	e0bff317 	ldw	r2,-52(fp)
 400e524:	10c00317 	ldw	r3,12(r2)
 400e528:	e0bff317 	ldw	r2,-52(fp)
 400e52c:	10c00215 	stw	r3,8(r2)
      set_head(remainder, remainder_size | PREV_INUSE);
 400e530:	e0bffc17 	ldw	r2,-16(fp)
 400e534:	10800054 	ori	r2,r2,1
 400e538:	1007883a 	mov	r3,r2
 400e53c:	e0bff317 	ldw	r2,-52(fp)
 400e540:	10c00115 	stw	r3,4(r2)
      set_foot(remainder, remainder_size);
 400e544:	e0bffc17 	ldw	r2,-16(fp)
 400e548:	e0fff317 	ldw	r3,-52(fp)
 400e54c:	1885883a 	add	r2,r3,r2
 400e550:	e0fffc17 	ldw	r3,-16(fp)
 400e554:	10c00015 	stw	r3,0(r2)
      MALLOC_UNLOCK;
 400e558:	e13ff217 	ldw	r4,-56(fp)
 400e55c:	40186c40 	call	40186c4 <__malloc_unlock>
      return chunk2mem(victim);
 400e560:	e0bfff17 	ldw	r2,-4(fp)
 400e564:	10800204 	addi	r2,r2,8
 400e568:	0001ca06 	br	400ec94 <_malloc_r+0xb54>
    clear_last_remainder;
 400e56c:	008100b4 	movhi	r2,1026
 400e570:	10ad9604 	addi	r2,r2,-18856
 400e574:	00c100b4 	movhi	r3,1026
 400e578:	18ed9604 	addi	r3,r3,-18856
 400e57c:	10c00315 	stw	r3,12(r2)
 400e580:	00c100b4 	movhi	r3,1026
 400e584:	18ed9604 	addi	r3,r3,-18856
 400e588:	10800317 	ldw	r2,12(r2)
 400e58c:	18800215 	stw	r2,8(r3)
    if (remainder_size >= 0)  /* exhaust */
 400e590:	e0bffc17 	ldw	r2,-16(fp)
 400e594:	10000e16 	blt	r2,zero,400e5d0 <_malloc_r+0x490>
      set_inuse_bit_at_offset(victim, victim_size);
 400e598:	e0ffff17 	ldw	r3,-4(fp)
 400e59c:	e0bff517 	ldw	r2,-44(fp)
 400e5a0:	1885883a 	add	r2,r3,r2
 400e5a4:	10c00117 	ldw	r3,4(r2)
 400e5a8:	e13fff17 	ldw	r4,-4(fp)
 400e5ac:	e0bff517 	ldw	r2,-44(fp)
 400e5b0:	2085883a 	add	r2,r4,r2
 400e5b4:	18c00054 	ori	r3,r3,1
 400e5b8:	10c00115 	stw	r3,4(r2)
      MALLOC_UNLOCK;
 400e5bc:	e13ff217 	ldw	r4,-56(fp)
 400e5c0:	40186c40 	call	40186c4 <__malloc_unlock>
      return chunk2mem(victim);
 400e5c4:	e0bfff17 	ldw	r2,-4(fp)
 400e5c8:	10800204 	addi	r2,r2,8
 400e5cc:	0001b106 	br	400ec94 <_malloc_r+0xb54>
    frontlink(victim, victim_size, remainder_index, bck, fwd);
 400e5d0:	e0bff517 	ldw	r2,-44(fp)
 400e5d4:	10808028 	cmpgeui	r2,r2,512
 400e5d8:	10002b1e 	bne	r2,zero,400e688 <_malloc_r+0x548>
 400e5dc:	e0bff517 	ldw	r2,-44(fp)
 400e5e0:	1004d0fa 	srli	r2,r2,3
 400e5e4:	e0bff415 	stw	r2,-48(fp)
 400e5e8:	008100b4 	movhi	r2,1026
 400e5ec:	10ad9404 	addi	r2,r2,-18864
 400e5f0:	11000117 	ldw	r4,4(r2)
 400e5f4:	e0bff417 	ldw	r2,-48(fp)
 400e5f8:	1000010e 	bge	r2,zero,400e600 <_malloc_r+0x4c0>
 400e5fc:	108000c4 	addi	r2,r2,3
 400e600:	1005d0ba 	srai	r2,r2,2
 400e604:	1007883a 	mov	r3,r2
 400e608:	00800044 	movi	r2,1
 400e60c:	10c6983a 	sll	r3,r2,r3
 400e610:	008100b4 	movhi	r2,1026
 400e614:	10ad9404 	addi	r2,r2,-18864
 400e618:	20c6b03a 	or	r3,r4,r3
 400e61c:	10c00115 	stw	r3,4(r2)
 400e620:	e0bff417 	ldw	r2,-48(fp)
 400e624:	10800044 	addi	r2,r2,1
 400e628:	1085883a 	add	r2,r2,r2
 400e62c:	100690ba 	slli	r3,r2,2
 400e630:	008100b4 	movhi	r2,1026
 400e634:	10ad9404 	addi	r2,r2,-18864
 400e638:	1885883a 	add	r2,r3,r2
 400e63c:	10bffe04 	addi	r2,r2,-8
 400e640:	e0bff815 	stw	r2,-32(fp)
 400e644:	e0bff817 	ldw	r2,-32(fp)
 400e648:	10800217 	ldw	r2,8(r2)
 400e64c:	e0bff915 	stw	r2,-28(fp)
 400e650:	e0bfff17 	ldw	r2,-4(fp)
 400e654:	e0fff817 	ldw	r3,-32(fp)
 400e658:	10c00315 	stw	r3,12(r2)
 400e65c:	e0bfff17 	ldw	r2,-4(fp)
 400e660:	e0fff917 	ldw	r3,-28(fp)
 400e664:	10c00215 	stw	r3,8(r2)
 400e668:	e0bff817 	ldw	r2,-32(fp)
 400e66c:	e0ffff17 	ldw	r3,-4(fp)
 400e670:	10c00215 	stw	r3,8(r2)
 400e674:	e0bff817 	ldw	r2,-32(fp)
 400e678:	10c00217 	ldw	r3,8(r2)
 400e67c:	e0bff917 	ldw	r2,-28(fp)
 400e680:	10c00315 	stw	r3,12(r2)
 400e684:	00006a06 	br	400e830 <_malloc_r+0x6f0>
 400e688:	e0bff517 	ldw	r2,-44(fp)
 400e68c:	1004d27a 	srli	r2,r2,9
 400e690:	1000031e 	bne	r2,zero,400e6a0 <_malloc_r+0x560>
 400e694:	e0bff517 	ldw	r2,-44(fp)
 400e698:	1004d0fa 	srli	r2,r2,3
 400e69c:	00002906 	br	400e744 <_malloc_r+0x604>
 400e6a0:	e0bff517 	ldw	r2,-44(fp)
 400e6a4:	1004d27a 	srli	r2,r2,9
 400e6a8:	10800168 	cmpgeui	r2,r2,5
 400e6ac:	1000041e 	bne	r2,zero,400e6c0 <_malloc_r+0x580>
 400e6b0:	e0bff517 	ldw	r2,-44(fp)
 400e6b4:	1004d1ba 	srli	r2,r2,6
 400e6b8:	10800e04 	addi	r2,r2,56
 400e6bc:	00002106 	br	400e744 <_malloc_r+0x604>
 400e6c0:	e0bff517 	ldw	r2,-44(fp)
 400e6c4:	1004d27a 	srli	r2,r2,9
 400e6c8:	10800568 	cmpgeui	r2,r2,21
 400e6cc:	1000041e 	bne	r2,zero,400e6e0 <_malloc_r+0x5a0>
 400e6d0:	e0bff517 	ldw	r2,-44(fp)
 400e6d4:	1004d27a 	srli	r2,r2,9
 400e6d8:	108016c4 	addi	r2,r2,91
 400e6dc:	00001906 	br	400e744 <_malloc_r+0x604>
 400e6e0:	e0bff517 	ldw	r2,-44(fp)
 400e6e4:	1004d27a 	srli	r2,r2,9
 400e6e8:	10801568 	cmpgeui	r2,r2,85
 400e6ec:	1000041e 	bne	r2,zero,400e700 <_malloc_r+0x5c0>
 400e6f0:	e0bff517 	ldw	r2,-44(fp)
 400e6f4:	1004d33a 	srli	r2,r2,12
 400e6f8:	10801b84 	addi	r2,r2,110
 400e6fc:	00001106 	br	400e744 <_malloc_r+0x604>
 400e700:	e0bff517 	ldw	r2,-44(fp)
 400e704:	1004d27a 	srli	r2,r2,9
 400e708:	10805568 	cmpgeui	r2,r2,341
 400e70c:	1000041e 	bne	r2,zero,400e720 <_malloc_r+0x5e0>
 400e710:	e0bff517 	ldw	r2,-44(fp)
 400e714:	1004d3fa 	srli	r2,r2,15
 400e718:	10801dc4 	addi	r2,r2,119
 400e71c:	00000906 	br	400e744 <_malloc_r+0x604>
 400e720:	e0bff517 	ldw	r2,-44(fp)
 400e724:	1004d27a 	srli	r2,r2,9
 400e728:	10815568 	cmpgeui	r2,r2,1365
 400e72c:	1000041e 	bne	r2,zero,400e740 <_malloc_r+0x600>
 400e730:	e0bff517 	ldw	r2,-44(fp)
 400e734:	1004d4ba 	srli	r2,r2,18
 400e738:	10801f04 	addi	r2,r2,124
 400e73c:	00000106 	br	400e744 <_malloc_r+0x604>
 400e740:	00801f84 	movi	r2,126
 400e744:	e0bff415 	stw	r2,-48(fp)
 400e748:	e0bff417 	ldw	r2,-48(fp)
 400e74c:	10800044 	addi	r2,r2,1
 400e750:	1085883a 	add	r2,r2,r2
 400e754:	100690ba 	slli	r3,r2,2
 400e758:	008100b4 	movhi	r2,1026
 400e75c:	10ad9404 	addi	r2,r2,-18864
 400e760:	1885883a 	add	r2,r3,r2
 400e764:	10bffe04 	addi	r2,r2,-8
 400e768:	e0bff815 	stw	r2,-32(fp)
 400e76c:	e0bff817 	ldw	r2,-32(fp)
 400e770:	10800217 	ldw	r2,8(r2)
 400e774:	e0bff915 	stw	r2,-28(fp)
 400e778:	e0fff917 	ldw	r3,-28(fp)
 400e77c:	e0bff817 	ldw	r2,-32(fp)
 400e780:	1880121e 	bne	r3,r2,400e7cc <_malloc_r+0x68c>
 400e784:	008100b4 	movhi	r2,1026
 400e788:	10ad9404 	addi	r2,r2,-18864
 400e78c:	11000117 	ldw	r4,4(r2)
 400e790:	e0bff417 	ldw	r2,-48(fp)
 400e794:	1000010e 	bge	r2,zero,400e79c <_malloc_r+0x65c>
 400e798:	108000c4 	addi	r2,r2,3
 400e79c:	1005d0ba 	srai	r2,r2,2
 400e7a0:	1007883a 	mov	r3,r2
 400e7a4:	00800044 	movi	r2,1
 400e7a8:	10c6983a 	sll	r3,r2,r3
 400e7ac:	008100b4 	movhi	r2,1026
 400e7b0:	10ad9404 	addi	r2,r2,-18864
 400e7b4:	20c6b03a 	or	r3,r4,r3
 400e7b8:	10c00115 	stw	r3,4(r2)
 400e7bc:	00000f06 	br	400e7fc <_malloc_r+0x6bc>
 400e7c0:	e0bff917 	ldw	r2,-28(fp)
 400e7c4:	10800217 	ldw	r2,8(r2)
 400e7c8:	e0bff915 	stw	r2,-28(fp)
 400e7cc:	e0fff917 	ldw	r3,-28(fp)
 400e7d0:	e0bff817 	ldw	r2,-32(fp)
 400e7d4:	18800626 	beq	r3,r2,400e7f0 <_malloc_r+0x6b0>
 400e7d8:	e0bff917 	ldw	r2,-28(fp)
 400e7dc:	10c00117 	ldw	r3,4(r2)
 400e7e0:	00bfff04 	movi	r2,-4
 400e7e4:	1884703a 	and	r2,r3,r2
 400e7e8:	e0fff517 	ldw	r3,-44(fp)
 400e7ec:	18bff436 	bltu	r3,r2,400e7c0 <_malloc_r+0x680>
 400e7f0:	e0bff917 	ldw	r2,-28(fp)
 400e7f4:	10800317 	ldw	r2,12(r2)
 400e7f8:	e0bff815 	stw	r2,-32(fp)
 400e7fc:	e0bfff17 	ldw	r2,-4(fp)
 400e800:	e0fff817 	ldw	r3,-32(fp)
 400e804:	10c00315 	stw	r3,12(r2)
 400e808:	e0bfff17 	ldw	r2,-4(fp)
 400e80c:	e0fff917 	ldw	r3,-28(fp)
 400e810:	10c00215 	stw	r3,8(r2)
 400e814:	e0bff817 	ldw	r2,-32(fp)
 400e818:	e0ffff17 	ldw	r3,-4(fp)
 400e81c:	10c00215 	stw	r3,8(r2)
 400e820:	e0bff817 	ldw	r2,-32(fp)
 400e824:	10c00217 	ldw	r3,8(r2)
 400e828:	e0bff917 	ldw	r2,-28(fp)
 400e82c:	10c00315 	stw	r3,12(r2)
  if ( (block = idx2binblock(idx)) <= binblocks)  
 400e830:	e0bffe17 	ldw	r2,-8(fp)
 400e834:	1000010e 	bge	r2,zero,400e83c <_malloc_r+0x6fc>
 400e838:	108000c4 	addi	r2,r2,3
 400e83c:	1005d0ba 	srai	r2,r2,2
 400e840:	1007883a 	mov	r3,r2
 400e844:	00800044 	movi	r2,1
 400e848:	10c4983a 	sll	r2,r2,r3
 400e84c:	e0bffb15 	stw	r2,-20(fp)
 400e850:	008100b4 	movhi	r2,1026
 400e854:	10ad9404 	addi	r2,r2,-18864
 400e858:	10c00117 	ldw	r3,4(r2)
 400e85c:	e0bffb17 	ldw	r2,-20(fp)
 400e860:	1880c536 	bltu	r3,r2,400eb78 <_malloc_r+0xa38>
    if ( (block & binblocks) == 0) 
 400e864:	008100b4 	movhi	r2,1026
 400e868:	10ad9404 	addi	r2,r2,-18864
 400e86c:	10c00117 	ldw	r3,4(r2)
 400e870:	e0bffb17 	ldw	r2,-20(fp)
 400e874:	1884703a 	and	r2,r3,r2
 400e878:	1000151e 	bne	r2,zero,400e8d0 <_malloc_r+0x790>
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
 400e87c:	e0fffe17 	ldw	r3,-8(fp)
 400e880:	00bfff04 	movi	r2,-4
 400e884:	1884703a 	and	r2,r3,r2
 400e888:	10800104 	addi	r2,r2,4
 400e88c:	e0bffe15 	stw	r2,-8(fp)
      block <<= 1;
 400e890:	e0bffb17 	ldw	r2,-20(fp)
 400e894:	1085883a 	add	r2,r2,r2
 400e898:	e0bffb15 	stw	r2,-20(fp)
      while ((block & binblocks) == 0)
 400e89c:	00000606 	br	400e8b8 <_malloc_r+0x778>
        idx += BINBLOCKWIDTH;
 400e8a0:	e0bffe17 	ldw	r2,-8(fp)
 400e8a4:	10800104 	addi	r2,r2,4
 400e8a8:	e0bffe15 	stw	r2,-8(fp)
        block <<= 1;
 400e8ac:	e0bffb17 	ldw	r2,-20(fp)
 400e8b0:	1085883a 	add	r2,r2,r2
 400e8b4:	e0bffb15 	stw	r2,-20(fp)
      while ((block & binblocks) == 0)
 400e8b8:	008100b4 	movhi	r2,1026
 400e8bc:	10ad9404 	addi	r2,r2,-18864
 400e8c0:	10c00117 	ldw	r3,4(r2)
 400e8c4:	e0bffb17 	ldw	r2,-20(fp)
 400e8c8:	1884703a 	and	r2,r3,r2
 400e8cc:	103ff426 	beq	r2,zero,400e8a0 <_malloc_r+0x760>
      startidx = idx;          /* (track incomplete blocks) */
 400e8d0:	e0bffe17 	ldw	r2,-8(fp)
 400e8d4:	e0bffa15 	stw	r2,-24(fp)
      q = bin = bin_at(idx);
 400e8d8:	e0bffe17 	ldw	r2,-8(fp)
 400e8dc:	10800044 	addi	r2,r2,1
 400e8e0:	1085883a 	add	r2,r2,r2
 400e8e4:	100690ba 	slli	r3,r2,2
 400e8e8:	008100b4 	movhi	r2,1026
 400e8ec:	10ad9404 	addi	r2,r2,-18864
 400e8f0:	1885883a 	add	r2,r3,r2
 400e8f4:	10bffe04 	addi	r2,r2,-8
 400e8f8:	e0bffd15 	stw	r2,-12(fp)
 400e8fc:	e0bffd17 	ldw	r2,-12(fp)
 400e900:	e0bff715 	stw	r2,-36(fp)
        for (victim = last(bin); victim != bin; victim = victim->bk)
 400e904:	e0bffd17 	ldw	r2,-12(fp)
 400e908:	10800317 	ldw	r2,12(r2)
 400e90c:	e0bfff15 	stw	r2,-4(fp)
 400e910:	00005e06 	br	400ea8c <_malloc_r+0x94c>
          victim_size = chunksize(victim);
 400e914:	e0bfff17 	ldw	r2,-4(fp)
 400e918:	10c00117 	ldw	r3,4(r2)
 400e91c:	00bfff04 	movi	r2,-4
 400e920:	1884703a 	and	r2,r3,r2
 400e924:	e0bff515 	stw	r2,-44(fp)
          remainder_size = long_sub_size_t(victim_size, nb);
 400e928:	e0fff517 	ldw	r3,-44(fp)
 400e92c:	e0bff617 	ldw	r2,-40(fp)
 400e930:	1885c83a 	sub	r2,r3,r2
 400e934:	e0bffc15 	stw	r2,-16(fp)
          if (remainder_size >= (long)MINSIZE) /* split */
 400e938:	e0bffc17 	ldw	r2,-16(fp)
 400e93c:	10800410 	cmplti	r2,r2,16
 400e940:	1000331e 	bne	r2,zero,400ea10 <_malloc_r+0x8d0>
            remainder = chunk_at_offset(victim, nb);
 400e944:	e0ffff17 	ldw	r3,-4(fp)
 400e948:	e0bff617 	ldw	r2,-40(fp)
 400e94c:	1885883a 	add	r2,r3,r2
 400e950:	e0bff315 	stw	r2,-52(fp)
            set_head(victim, nb | PREV_INUSE);
 400e954:	e0bff617 	ldw	r2,-40(fp)
 400e958:	10c00054 	ori	r3,r2,1
 400e95c:	e0bfff17 	ldw	r2,-4(fp)
 400e960:	10c00115 	stw	r3,4(r2)
            unlink(victim, bck, fwd);
 400e964:	e0bfff17 	ldw	r2,-4(fp)
 400e968:	10800317 	ldw	r2,12(r2)
 400e96c:	e0bff815 	stw	r2,-32(fp)
 400e970:	e0bfff17 	ldw	r2,-4(fp)
 400e974:	10800217 	ldw	r2,8(r2)
 400e978:	e0bff915 	stw	r2,-28(fp)
 400e97c:	e0bff917 	ldw	r2,-28(fp)
 400e980:	e0fff817 	ldw	r3,-32(fp)
 400e984:	10c00315 	stw	r3,12(r2)
 400e988:	e0bff817 	ldw	r2,-32(fp)
 400e98c:	e0fff917 	ldw	r3,-28(fp)
 400e990:	10c00215 	stw	r3,8(r2)
            link_last_remainder(remainder);
 400e994:	008100b4 	movhi	r2,1026
 400e998:	10ad9604 	addi	r2,r2,-18856
 400e99c:	e0fff317 	ldw	r3,-52(fp)
 400e9a0:	10c00315 	stw	r3,12(r2)
 400e9a4:	00c100b4 	movhi	r3,1026
 400e9a8:	18ed9604 	addi	r3,r3,-18856
 400e9ac:	10800317 	ldw	r2,12(r2)
 400e9b0:	18800215 	stw	r2,8(r3)
 400e9b4:	008100b4 	movhi	r2,1026
 400e9b8:	10ad9604 	addi	r2,r2,-18856
 400e9bc:	e0fff317 	ldw	r3,-52(fp)
 400e9c0:	18800315 	stw	r2,12(r3)
 400e9c4:	e0bff317 	ldw	r2,-52(fp)
 400e9c8:	10c00317 	ldw	r3,12(r2)
 400e9cc:	e0bff317 	ldw	r2,-52(fp)
 400e9d0:	10c00215 	stw	r3,8(r2)
            set_head(remainder, remainder_size | PREV_INUSE);
 400e9d4:	e0bffc17 	ldw	r2,-16(fp)
 400e9d8:	10800054 	ori	r2,r2,1
 400e9dc:	1007883a 	mov	r3,r2
 400e9e0:	e0bff317 	ldw	r2,-52(fp)
 400e9e4:	10c00115 	stw	r3,4(r2)
            set_foot(remainder, remainder_size);
 400e9e8:	e0bffc17 	ldw	r2,-16(fp)
 400e9ec:	e0fff317 	ldw	r3,-52(fp)
 400e9f0:	1885883a 	add	r2,r3,r2
 400e9f4:	e0fffc17 	ldw	r3,-16(fp)
 400e9f8:	10c00015 	stw	r3,0(r2)
	    MALLOC_UNLOCK;
 400e9fc:	e13ff217 	ldw	r4,-56(fp)
 400ea00:	40186c40 	call	40186c4 <__malloc_unlock>
            return chunk2mem(victim);
 400ea04:	e0bfff17 	ldw	r2,-4(fp)
 400ea08:	10800204 	addi	r2,r2,8
 400ea0c:	0000a106 	br	400ec94 <_malloc_r+0xb54>
          else if (remainder_size >= 0)  /* take */
 400ea10:	e0bffc17 	ldw	r2,-16(fp)
 400ea14:	10001a16 	blt	r2,zero,400ea80 <_malloc_r+0x940>
            set_inuse_bit_at_offset(victim, victim_size);
 400ea18:	e0ffff17 	ldw	r3,-4(fp)
 400ea1c:	e0bff517 	ldw	r2,-44(fp)
 400ea20:	1885883a 	add	r2,r3,r2
 400ea24:	10c00117 	ldw	r3,4(r2)
 400ea28:	e13fff17 	ldw	r4,-4(fp)
 400ea2c:	e0bff517 	ldw	r2,-44(fp)
 400ea30:	2085883a 	add	r2,r4,r2
 400ea34:	18c00054 	ori	r3,r3,1
 400ea38:	10c00115 	stw	r3,4(r2)
            unlink(victim, bck, fwd);
 400ea3c:	e0bfff17 	ldw	r2,-4(fp)
 400ea40:	10800317 	ldw	r2,12(r2)
 400ea44:	e0bff815 	stw	r2,-32(fp)
 400ea48:	e0bfff17 	ldw	r2,-4(fp)
 400ea4c:	10800217 	ldw	r2,8(r2)
 400ea50:	e0bff915 	stw	r2,-28(fp)
 400ea54:	e0bff917 	ldw	r2,-28(fp)
 400ea58:	e0fff817 	ldw	r3,-32(fp)
 400ea5c:	10c00315 	stw	r3,12(r2)
 400ea60:	e0bff817 	ldw	r2,-32(fp)
 400ea64:	e0fff917 	ldw	r3,-28(fp)
 400ea68:	10c00215 	stw	r3,8(r2)
	    MALLOC_UNLOCK;
 400ea6c:	e13ff217 	ldw	r4,-56(fp)
 400ea70:	40186c40 	call	40186c4 <__malloc_unlock>
            return chunk2mem(victim);
 400ea74:	e0bfff17 	ldw	r2,-4(fp)
 400ea78:	10800204 	addi	r2,r2,8
 400ea7c:	00008506 	br	400ec94 <_malloc_r+0xb54>
        for (victim = last(bin); victim != bin; victim = victim->bk)
 400ea80:	e0bfff17 	ldw	r2,-4(fp)
 400ea84:	10800317 	ldw	r2,12(r2)
 400ea88:	e0bfff15 	stw	r2,-4(fp)
 400ea8c:	e0ffff17 	ldw	r3,-4(fp)
 400ea90:	e0bffd17 	ldw	r2,-12(fp)
 400ea94:	18bf9f1e 	bne	r3,r2,400e914 <_malloc_r+0x7d4>
       bin = next_bin(bin);
 400ea98:	e0bffd17 	ldw	r2,-12(fp)
 400ea9c:	10800204 	addi	r2,r2,8
 400eaa0:	e0bffd15 	stw	r2,-12(fp)
      } while ((++idx & (BINBLOCKWIDTH - 1)) != 0);
 400eaa4:	e0bffe17 	ldw	r2,-8(fp)
 400eaa8:	10800044 	addi	r2,r2,1
 400eaac:	e0bffe15 	stw	r2,-8(fp)
 400eab0:	e0bffe17 	ldw	r2,-8(fp)
 400eab4:	108000cc 	andi	r2,r2,3
 400eab8:	103f921e 	bne	r2,zero,400e904 <_malloc_r+0x7c4>
        if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
 400eabc:	e0bffa17 	ldw	r2,-24(fp)
 400eac0:	108000cc 	andi	r2,r2,3
 400eac4:	10000a1e 	bne	r2,zero,400eaf0 <_malloc_r+0x9b0>
          binblocks &= ~block;
 400eac8:	008100b4 	movhi	r2,1026
 400eacc:	10ad9404 	addi	r2,r2,-18864
 400ead0:	11000117 	ldw	r4,4(r2)
 400ead4:	e0bffb17 	ldw	r2,-20(fp)
 400ead8:	0086303a 	nor	r3,zero,r2
 400eadc:	008100b4 	movhi	r2,1026
 400eae0:	10ad9404 	addi	r2,r2,-18864
 400eae4:	20c6703a 	and	r3,r4,r3
 400eae8:	10c00115 	stw	r3,4(r2)
          break;
 400eaec:	00000a06 	br	400eb18 <_malloc_r+0x9d8>
        --startidx;
 400eaf0:	e0bffa17 	ldw	r2,-24(fp)
 400eaf4:	10bfffc4 	addi	r2,r2,-1
 400eaf8:	e0bffa15 	stw	r2,-24(fp)
       q = prev_bin(q);
 400eafc:	e0bff717 	ldw	r2,-36(fp)
 400eb00:	10bffe04 	addi	r2,r2,-8
 400eb04:	e0bff715 	stw	r2,-36(fp)
      } while (first(q) == q);
 400eb08:	e0bff717 	ldw	r2,-36(fp)
 400eb0c:	10800217 	ldw	r2,8(r2)
 400eb10:	e0fff717 	ldw	r3,-36(fp)
 400eb14:	18bfe926 	beq	r3,r2,400eabc <_malloc_r+0x97c>
      if ( (block <<= 1) <= binblocks && (block != 0) ) 
 400eb18:	e0bffb17 	ldw	r2,-20(fp)
 400eb1c:	1085883a 	add	r2,r2,r2
 400eb20:	e0bffb15 	stw	r2,-20(fp)
 400eb24:	008100b4 	movhi	r2,1026
 400eb28:	10ad9404 	addi	r2,r2,-18864
 400eb2c:	10c00117 	ldw	r3,4(r2)
 400eb30:	e0bffb17 	ldw	r2,-20(fp)
 400eb34:	18801036 	bltu	r3,r2,400eb78 <_malloc_r+0xa38>
 400eb38:	e0bffb17 	ldw	r2,-20(fp)
 400eb3c:	10000e26 	beq	r2,zero,400eb78 <_malloc_r+0xa38>
        while ((block & binblocks) == 0)
 400eb40:	00000606 	br	400eb5c <_malloc_r+0xa1c>
          idx += BINBLOCKWIDTH;
 400eb44:	e0bffe17 	ldw	r2,-8(fp)
 400eb48:	10800104 	addi	r2,r2,4
 400eb4c:	e0bffe15 	stw	r2,-8(fp)
          block <<= 1;
 400eb50:	e0bffb17 	ldw	r2,-20(fp)
 400eb54:	1085883a 	add	r2,r2,r2
 400eb58:	e0bffb15 	stw	r2,-20(fp)
        while ((block & binblocks) == 0)
 400eb5c:	008100b4 	movhi	r2,1026
 400eb60:	10ad9404 	addi	r2,r2,-18864
 400eb64:	10c00117 	ldw	r3,4(r2)
 400eb68:	e0bffb17 	ldw	r2,-20(fp)
 400eb6c:	1884703a 	and	r2,r3,r2
 400eb70:	103ff426 	beq	r2,zero,400eb44 <_malloc_r+0xa04>
      startidx = idx;          /* (track incomplete blocks) */
 400eb74:	003f5606 	br	400e8d0 <_malloc_r+0x790>
  remainder_size = long_sub_size_t(chunksize(top), nb);
 400eb78:	008100b4 	movhi	r2,1026
 400eb7c:	10ad9404 	addi	r2,r2,-18864
 400eb80:	10800217 	ldw	r2,8(r2)
 400eb84:	10c00117 	ldw	r3,4(r2)
 400eb88:	00bfff04 	movi	r2,-4
 400eb8c:	1886703a 	and	r3,r3,r2
 400eb90:	e0bff617 	ldw	r2,-40(fp)
 400eb94:	1885c83a 	sub	r2,r3,r2
 400eb98:	e0bffc15 	stw	r2,-16(fp)
  if (chunksize(top) < nb || remainder_size < (long)MINSIZE)
 400eb9c:	008100b4 	movhi	r2,1026
 400eba0:	10ad9404 	addi	r2,r2,-18864
 400eba4:	10800217 	ldw	r2,8(r2)
 400eba8:	10c00117 	ldw	r3,4(r2)
 400ebac:	00bfff04 	movi	r2,-4
 400ebb0:	1886703a 	and	r3,r3,r2
 400ebb4:	e0bff617 	ldw	r2,-40(fp)
 400ebb8:	18800336 	bltu	r3,r2,400ebc8 <_malloc_r+0xa88>
 400ebbc:	e0bffc17 	ldw	r2,-16(fp)
 400ebc0:	10800408 	cmpgei	r2,r2,16
 400ebc4:	10001b1e 	bne	r2,zero,400ec34 <_malloc_r+0xaf4>
    malloc_extend_top(RCALL nb);
 400ebc8:	e17ff617 	ldw	r5,-40(fp)
 400ebcc:	e13ff217 	ldw	r4,-56(fp)
 400ebd0:	400dd7c0 	call	400dd7c <malloc_extend_top>
    remainder_size = long_sub_size_t(chunksize(top), nb);
 400ebd4:	008100b4 	movhi	r2,1026
 400ebd8:	10ad9404 	addi	r2,r2,-18864
 400ebdc:	10800217 	ldw	r2,8(r2)
 400ebe0:	10c00117 	ldw	r3,4(r2)
 400ebe4:	00bfff04 	movi	r2,-4
 400ebe8:	1886703a 	and	r3,r3,r2
 400ebec:	e0bff617 	ldw	r2,-40(fp)
 400ebf0:	1885c83a 	sub	r2,r3,r2
 400ebf4:	e0bffc15 	stw	r2,-16(fp)
    if (chunksize(top) < nb || remainder_size < (long)MINSIZE)
 400ebf8:	008100b4 	movhi	r2,1026
 400ebfc:	10ad9404 	addi	r2,r2,-18864
 400ec00:	10800217 	ldw	r2,8(r2)
 400ec04:	10c00117 	ldw	r3,4(r2)
 400ec08:	00bfff04 	movi	r2,-4
 400ec0c:	1886703a 	and	r3,r3,r2
 400ec10:	e0bff617 	ldw	r2,-40(fp)
 400ec14:	18800336 	bltu	r3,r2,400ec24 <_malloc_r+0xae4>
 400ec18:	e0bffc17 	ldw	r2,-16(fp)
 400ec1c:	10800408 	cmpgei	r2,r2,16
 400ec20:	1000041e 	bne	r2,zero,400ec34 <_malloc_r+0xaf4>
      MALLOC_UNLOCK;
 400ec24:	e13ff217 	ldw	r4,-56(fp)
 400ec28:	40186c40 	call	40186c4 <__malloc_unlock>
      return 0; /* propagate failure */
 400ec2c:	0005883a 	mov	r2,zero
 400ec30:	00001806 	br	400ec94 <_malloc_r+0xb54>
  victim = top;
 400ec34:	008100b4 	movhi	r2,1026
 400ec38:	10ad9404 	addi	r2,r2,-18864
 400ec3c:	10800217 	ldw	r2,8(r2)
 400ec40:	e0bfff15 	stw	r2,-4(fp)
  set_head(victim, nb | PREV_INUSE);
 400ec44:	e0bff617 	ldw	r2,-40(fp)
 400ec48:	10c00054 	ori	r3,r2,1
 400ec4c:	e0bfff17 	ldw	r2,-4(fp)
 400ec50:	10c00115 	stw	r3,4(r2)
  top = chunk_at_offset(victim, nb);
 400ec54:	008100b4 	movhi	r2,1026
 400ec58:	10ad9404 	addi	r2,r2,-18864
 400ec5c:	e13fff17 	ldw	r4,-4(fp)
 400ec60:	e0fff617 	ldw	r3,-40(fp)
 400ec64:	20c7883a 	add	r3,r4,r3
 400ec68:	10c00215 	stw	r3,8(r2)
  set_head(top, remainder_size | PREV_INUSE);
 400ec6c:	e0bffc17 	ldw	r2,-16(fp)
 400ec70:	10c00054 	ori	r3,r2,1
 400ec74:	008100b4 	movhi	r2,1026
 400ec78:	10ad9404 	addi	r2,r2,-18864
 400ec7c:	10800217 	ldw	r2,8(r2)
 400ec80:	10c00115 	stw	r3,4(r2)
  MALLOC_UNLOCK;
 400ec84:	e13ff217 	ldw	r4,-56(fp)
 400ec88:	40186c40 	call	40186c4 <__malloc_unlock>
  return chunk2mem(victim);
 400ec8c:	e0bfff17 	ldw	r2,-4(fp)
 400ec90:	10800204 	addi	r2,r2,8
}
 400ec94:	e037883a 	mov	sp,fp
 400ec98:	dfc00117 	ldw	ra,4(sp)
 400ec9c:	df000017 	ldw	fp,0(sp)
 400eca0:	dec00204 	addi	sp,sp,8
 400eca4:	f800283a 	ret

0400eca8 <memchr>:

void *
memchr (const void *src_void,
	int c,
	size_t length)
{
 400eca8:	defff704 	addi	sp,sp,-36
 400ecac:	df000815 	stw	fp,32(sp)
 400ecb0:	df000804 	addi	fp,sp,32
 400ecb4:	e13ffa15 	stw	r4,-24(fp)
 400ecb8:	e17ff915 	stw	r5,-28(fp)
 400ecbc:	e1bff815 	stw	r6,-32(fp)
  const unsigned char *src = (const unsigned char *) src_void;
 400ecc0:	e0bffa17 	ldw	r2,-24(fp)
 400ecc4:	e0bfff15 	stw	r2,-4(fp)
  unsigned char d = c;
 400ecc8:	e0bff917 	ldw	r2,-28(fp)
 400eccc:	e0bffbc5 	stb	r2,-17(fp)
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *asrc;
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
 400ecd0:	00001006 	br	400ed14 <memchr+0x6c>
    {
      if (!length--)
 400ecd4:	e0bff817 	ldw	r2,-32(fp)
 400ecd8:	10ffffc4 	addi	r3,r2,-1
 400ecdc:	e0fff815 	stw	r3,-32(fp)
 400ece0:	1000021e 	bne	r2,zero,400ecec <memchr+0x44>
        return NULL;
 400ece4:	0005883a 	mov	r2,zero
 400ece8:	00005a06 	br	400ee54 <memchr+0x1ac>
      if (*src == d)
 400ecec:	e0bfff17 	ldw	r2,-4(fp)
 400ecf0:	10800003 	ldbu	r2,0(r2)
 400ecf4:	e0fffbc3 	ldbu	r3,-17(fp)
 400ecf8:	10803fcc 	andi	r2,r2,255
 400ecfc:	1880021e 	bne	r3,r2,400ed08 <memchr+0x60>
        return (void *) src;
 400ed00:	e0bfff17 	ldw	r2,-4(fp)
 400ed04:	00005306 	br	400ee54 <memchr+0x1ac>
      src++;
 400ed08:	e0bfff17 	ldw	r2,-4(fp)
 400ed0c:	10800044 	addi	r2,r2,1
 400ed10:	e0bfff15 	stw	r2,-4(fp)
  while (UNALIGNED (src))
 400ed14:	e0bfff17 	ldw	r2,-4(fp)
 400ed18:	108000cc 	andi	r2,r2,3
 400ed1c:	103fed1e 	bne	r2,zero,400ecd4 <memchr+0x2c>
    }

  if (!TOO_SMALL (length))
 400ed20:	e0bff817 	ldw	r2,-32(fp)
 400ed24:	10800130 	cmpltui	r2,r2,4
 400ed28:	1000451e 	bne	r2,zero,400ee40 <memchr+0x198>
         performs the bytewise search on word-sized segments if they
         contain the search character, which is detected by XORing
         the word-sized segment with a word-sized block of the search
         character and then detecting for the presence of NUL in the
         result.  */
      asrc = (unsigned long *) src;
 400ed2c:	e0bfff17 	ldw	r2,-4(fp)
 400ed30:	e0bffe15 	stw	r2,-8(fp)
      mask = d << 8 | d;
 400ed34:	e0bffbc3 	ldbu	r2,-17(fp)
 400ed38:	1006923a 	slli	r3,r2,8
 400ed3c:	e0bffbc3 	ldbu	r2,-17(fp)
 400ed40:	1884b03a 	or	r2,r3,r2
 400ed44:	e0bffd15 	stw	r2,-12(fp)
      mask = mask << 16 | mask;
 400ed48:	e0bffd17 	ldw	r2,-12(fp)
 400ed4c:	1004943a 	slli	r2,r2,16
 400ed50:	e0fffd17 	ldw	r3,-12(fp)
 400ed54:	1884b03a 	or	r2,r3,r2
 400ed58:	e0bffd15 	stw	r2,-12(fp)
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
 400ed5c:	00800804 	movi	r2,32
 400ed60:	e0bffc15 	stw	r2,-16(fp)
 400ed64:	00000906 	br	400ed8c <memchr+0xe4>
        mask = (mask << i) | mask;
 400ed68:	e0fffd17 	ldw	r3,-12(fp)
 400ed6c:	e0bffc17 	ldw	r2,-16(fp)
 400ed70:	1884983a 	sll	r2,r3,r2
 400ed74:	e0fffd17 	ldw	r3,-12(fp)
 400ed78:	1884b03a 	or	r2,r3,r2
 400ed7c:	e0bffd15 	stw	r2,-12(fp)
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
 400ed80:	e0bffc17 	ldw	r2,-16(fp)
 400ed84:	1085883a 	add	r2,r2,r2
 400ed88:	e0bffc15 	stw	r2,-16(fp)
 400ed8c:	e0bffc17 	ldw	r2,-16(fp)
 400ed90:	10800830 	cmpltui	r2,r2,32
 400ed94:	103ff41e 	bne	r2,zero,400ed68 <memchr+0xc0>

      while (length >= LBLOCKSIZE)
 400ed98:	00001706 	br	400edf8 <memchr+0x150>
        {
          if (DETECTCHAR (*asrc, mask))
 400ed9c:	e0bffe17 	ldw	r2,-8(fp)
 400eda0:	10c00017 	ldw	r3,0(r2)
 400eda4:	e0bffd17 	ldw	r2,-12(fp)
 400eda8:	1886f03a 	xor	r3,r3,r2
 400edac:	00bfbff4 	movhi	r2,65279
 400edb0:	10bfbfc4 	addi	r2,r2,-257
 400edb4:	1887883a 	add	r3,r3,r2
 400edb8:	e0bffe17 	ldw	r2,-8(fp)
 400edbc:	11000017 	ldw	r4,0(r2)
 400edc0:	e0bffd17 	ldw	r2,-12(fp)
 400edc4:	2084f03a 	xor	r2,r4,r2
 400edc8:	0084303a 	nor	r2,zero,r2
 400edcc:	1886703a 	and	r3,r3,r2
 400edd0:	00a02074 	movhi	r2,32897
 400edd4:	10a02004 	addi	r2,r2,-32640
 400edd8:	1884703a 	and	r2,r3,r2
 400eddc:	10000a1e 	bne	r2,zero,400ee08 <memchr+0x160>
            break;
          length -= LBLOCKSIZE;
 400ede0:	e0bff817 	ldw	r2,-32(fp)
 400ede4:	10bfff04 	addi	r2,r2,-4
 400ede8:	e0bff815 	stw	r2,-32(fp)
          asrc++;
 400edec:	e0bffe17 	ldw	r2,-8(fp)
 400edf0:	10800104 	addi	r2,r2,4
 400edf4:	e0bffe15 	stw	r2,-8(fp)
      while (length >= LBLOCKSIZE)
 400edf8:	e0bff817 	ldw	r2,-32(fp)
 400edfc:	10800128 	cmpgeui	r2,r2,4
 400ee00:	103fe61e 	bne	r2,zero,400ed9c <memchr+0xf4>
 400ee04:	00000106 	br	400ee0c <memchr+0x164>
            break;
 400ee08:	0001883a 	nop
        }

      /* If there are fewer than LBLOCKSIZE characters left,
         then we resort to the bytewise loop.  */

      src = (unsigned char *) asrc;
 400ee0c:	e0bffe17 	ldw	r2,-8(fp)
 400ee10:	e0bfff15 	stw	r2,-4(fp)
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (length--)
 400ee14:	00000a06 	br	400ee40 <memchr+0x198>
    {
      if (*src == d)
 400ee18:	e0bfff17 	ldw	r2,-4(fp)
 400ee1c:	10800003 	ldbu	r2,0(r2)
 400ee20:	e0fffbc3 	ldbu	r3,-17(fp)
 400ee24:	10803fcc 	andi	r2,r2,255
 400ee28:	1880021e 	bne	r3,r2,400ee34 <memchr+0x18c>
        return (void *) src;
 400ee2c:	e0bfff17 	ldw	r2,-4(fp)
 400ee30:	00000806 	br	400ee54 <memchr+0x1ac>
      src++;
 400ee34:	e0bfff17 	ldw	r2,-4(fp)
 400ee38:	10800044 	addi	r2,r2,1
 400ee3c:	e0bfff15 	stw	r2,-4(fp)
  while (length--)
 400ee40:	e0bff817 	ldw	r2,-32(fp)
 400ee44:	10ffffc4 	addi	r3,r2,-1
 400ee48:	e0fff815 	stw	r3,-32(fp)
 400ee4c:	103ff21e 	bne	r2,zero,400ee18 <memchr+0x170>
    }

  return NULL;
 400ee50:	0005883a 	mov	r2,zero
}
 400ee54:	e037883a 	mov	sp,fp
 400ee58:	df000017 	ldw	fp,0(sp)
 400ee5c:	dec00104 	addi	sp,sp,4
 400ee60:	f800283a 	ret

0400ee64 <memmove>:
void *
__inhibit_loop_to_libcall
memmove (void *dst_void,
	const void *src_void,
	size_t length)
{
 400ee64:	defff804 	addi	sp,sp,-32
 400ee68:	df000715 	stw	fp,28(sp)
 400ee6c:	df000704 	addi	fp,sp,28
 400ee70:	e13ffb15 	stw	r4,-20(fp)
 400ee74:	e17ffa15 	stw	r5,-24(fp)
 400ee78:	e1bff915 	stw	r6,-28(fp)
	}
    }

  return dst_void;
#else
  char *dst = dst_void;
 400ee7c:	e0bffb17 	ldw	r2,-20(fp)
 400ee80:	e0bfff15 	stw	r2,-4(fp)
  const char *src = src_void;
 400ee84:	e0bffa17 	ldw	r2,-24(fp)
 400ee88:	e0bffe15 	stw	r2,-8(fp)
  long *aligned_dst;
  const long *aligned_src;

  if (src < dst && dst < src + length)
 400ee8c:	e0fffe17 	ldw	r3,-8(fp)
 400ee90:	e0bfff17 	ldw	r2,-4(fp)
 400ee94:	18801d2e 	bgeu	r3,r2,400ef0c <memmove+0xa8>
 400ee98:	e0fffe17 	ldw	r3,-8(fp)
 400ee9c:	e0bff917 	ldw	r2,-28(fp)
 400eea0:	1885883a 	add	r2,r3,r2
 400eea4:	e0ffff17 	ldw	r3,-4(fp)
 400eea8:	1880182e 	bgeu	r3,r2,400ef0c <memmove+0xa8>
    {
      /* Destructive overlap...have to copy backwards */
      src += length;
 400eeac:	e0fffe17 	ldw	r3,-8(fp)
 400eeb0:	e0bff917 	ldw	r2,-28(fp)
 400eeb4:	1885883a 	add	r2,r3,r2
 400eeb8:	e0bffe15 	stw	r2,-8(fp)
      dst += length;
 400eebc:	e0ffff17 	ldw	r3,-4(fp)
 400eec0:	e0bff917 	ldw	r2,-28(fp)
 400eec4:	1885883a 	add	r2,r3,r2
 400eec8:	e0bfff15 	stw	r2,-4(fp)
      while (length--)
 400eecc:	00000a06 	br	400eef8 <memmove+0x94>
	{
	  *--dst = *--src;
 400eed0:	e0bffe17 	ldw	r2,-8(fp)
 400eed4:	10bfffc4 	addi	r2,r2,-1
 400eed8:	e0bffe15 	stw	r2,-8(fp)
 400eedc:	e0bfff17 	ldw	r2,-4(fp)
 400eee0:	10bfffc4 	addi	r2,r2,-1
 400eee4:	e0bfff15 	stw	r2,-4(fp)
 400eee8:	e0bffe17 	ldw	r2,-8(fp)
 400eeec:	10c00003 	ldbu	r3,0(r2)
 400eef0:	e0bfff17 	ldw	r2,-4(fp)
 400eef4:	10c00005 	stb	r3,0(r2)
      while (length--)
 400eef8:	e0bff917 	ldw	r2,-28(fp)
 400eefc:	10ffffc4 	addi	r3,r2,-1
 400ef00:	e0fff915 	stw	r3,-28(fp)
 400ef04:	103ff21e 	bne	r2,zero,400eed0 <memmove+0x6c>
  if (src < dst && dst < src + length)
 400ef08:	00005306 	br	400f058 <memmove+0x1f4>
  else
    {
      /* Use optimizing algorithm for a non-destructive copy to closely 
         match memcpy. If the size is small or either SRC or DST is unaligned,
         then punt into the byte copy loop.  This should be rare.  */
      if (!TOO_SMALL(length) && !UNALIGNED (src, dst))
 400ef0c:	e0bff917 	ldw	r2,-28(fp)
 400ef10:	10800430 	cmpltui	r2,r2,16
 400ef14:	10004c1e 	bne	r2,zero,400f048 <memmove+0x1e4>
 400ef18:	e0fffe17 	ldw	r3,-8(fp)
 400ef1c:	e0bfff17 	ldw	r2,-4(fp)
 400ef20:	1884b03a 	or	r2,r3,r2
 400ef24:	108000cc 	andi	r2,r2,3
 400ef28:	1000471e 	bne	r2,zero,400f048 <memmove+0x1e4>
        {
          aligned_dst = (long*)dst;
 400ef2c:	e0bfff17 	ldw	r2,-4(fp)
 400ef30:	e0bffd15 	stw	r2,-12(fp)
          aligned_src = (long*)src;
 400ef34:	e0bffe17 	ldw	r2,-8(fp)
 400ef38:	e0bffc15 	stw	r2,-16(fp)

          /* Copy 4X long words at a time if possible.  */
          while (length >= BIGBLOCKSIZE)
 400ef3c:	00002306 	br	400efcc <memmove+0x168>
            {
              *aligned_dst++ = *aligned_src++;
 400ef40:	e0fffc17 	ldw	r3,-16(fp)
 400ef44:	18800104 	addi	r2,r3,4
 400ef48:	e0bffc15 	stw	r2,-16(fp)
 400ef4c:	e0bffd17 	ldw	r2,-12(fp)
 400ef50:	11000104 	addi	r4,r2,4
 400ef54:	e13ffd15 	stw	r4,-12(fp)
 400ef58:	18c00017 	ldw	r3,0(r3)
 400ef5c:	10c00015 	stw	r3,0(r2)
              *aligned_dst++ = *aligned_src++;
 400ef60:	e0fffc17 	ldw	r3,-16(fp)
 400ef64:	18800104 	addi	r2,r3,4
 400ef68:	e0bffc15 	stw	r2,-16(fp)
 400ef6c:	e0bffd17 	ldw	r2,-12(fp)
 400ef70:	11000104 	addi	r4,r2,4
 400ef74:	e13ffd15 	stw	r4,-12(fp)
 400ef78:	18c00017 	ldw	r3,0(r3)
 400ef7c:	10c00015 	stw	r3,0(r2)
              *aligned_dst++ = *aligned_src++;
 400ef80:	e0fffc17 	ldw	r3,-16(fp)
 400ef84:	18800104 	addi	r2,r3,4
 400ef88:	e0bffc15 	stw	r2,-16(fp)
 400ef8c:	e0bffd17 	ldw	r2,-12(fp)
 400ef90:	11000104 	addi	r4,r2,4
 400ef94:	e13ffd15 	stw	r4,-12(fp)
 400ef98:	18c00017 	ldw	r3,0(r3)
 400ef9c:	10c00015 	stw	r3,0(r2)
              *aligned_dst++ = *aligned_src++;
 400efa0:	e0fffc17 	ldw	r3,-16(fp)
 400efa4:	18800104 	addi	r2,r3,4
 400efa8:	e0bffc15 	stw	r2,-16(fp)
 400efac:	e0bffd17 	ldw	r2,-12(fp)
 400efb0:	11000104 	addi	r4,r2,4
 400efb4:	e13ffd15 	stw	r4,-12(fp)
 400efb8:	18c00017 	ldw	r3,0(r3)
 400efbc:	10c00015 	stw	r3,0(r2)
              length -= BIGBLOCKSIZE;
 400efc0:	e0bff917 	ldw	r2,-28(fp)
 400efc4:	10bffc04 	addi	r2,r2,-16
 400efc8:	e0bff915 	stw	r2,-28(fp)
          while (length >= BIGBLOCKSIZE)
 400efcc:	e0bff917 	ldw	r2,-28(fp)
 400efd0:	10800428 	cmpgeui	r2,r2,16
 400efd4:	103fda1e 	bne	r2,zero,400ef40 <memmove+0xdc>
            }

          /* Copy one long word at a time if possible.  */
          while (length >= LITTLEBLOCKSIZE)
 400efd8:	00000b06 	br	400f008 <memmove+0x1a4>
            {
              *aligned_dst++ = *aligned_src++;
 400efdc:	e0fffc17 	ldw	r3,-16(fp)
 400efe0:	18800104 	addi	r2,r3,4
 400efe4:	e0bffc15 	stw	r2,-16(fp)
 400efe8:	e0bffd17 	ldw	r2,-12(fp)
 400efec:	11000104 	addi	r4,r2,4
 400eff0:	e13ffd15 	stw	r4,-12(fp)
 400eff4:	18c00017 	ldw	r3,0(r3)
 400eff8:	10c00015 	stw	r3,0(r2)
              length -= LITTLEBLOCKSIZE;
 400effc:	e0bff917 	ldw	r2,-28(fp)
 400f000:	10bfff04 	addi	r2,r2,-4
 400f004:	e0bff915 	stw	r2,-28(fp)
          while (length >= LITTLEBLOCKSIZE)
 400f008:	e0bff917 	ldw	r2,-28(fp)
 400f00c:	10800128 	cmpgeui	r2,r2,4
 400f010:	103ff21e 	bne	r2,zero,400efdc <memmove+0x178>
            }

          /* Pick up any residual with a byte copier.  */
          dst = (char*)aligned_dst;
 400f014:	e0bffd17 	ldw	r2,-12(fp)
 400f018:	e0bfff15 	stw	r2,-4(fp)
          src = (char*)aligned_src;
 400f01c:	e0bffc17 	ldw	r2,-16(fp)
 400f020:	e0bffe15 	stw	r2,-8(fp)
        }

      while (length--)
 400f024:	00000806 	br	400f048 <memmove+0x1e4>
        {
          *dst++ = *src++;
 400f028:	e0fffe17 	ldw	r3,-8(fp)
 400f02c:	18800044 	addi	r2,r3,1
 400f030:	e0bffe15 	stw	r2,-8(fp)
 400f034:	e0bfff17 	ldw	r2,-4(fp)
 400f038:	11000044 	addi	r4,r2,1
 400f03c:	e13fff15 	stw	r4,-4(fp)
 400f040:	18c00003 	ldbu	r3,0(r3)
 400f044:	10c00005 	stb	r3,0(r2)
      while (length--)
 400f048:	e0bff917 	ldw	r2,-28(fp)
 400f04c:	10ffffc4 	addi	r3,r2,-1
 400f050:	e0fff915 	stw	r3,-28(fp)
 400f054:	103ff41e 	bne	r2,zero,400f028 <memmove+0x1c4>
        }
    }

  return dst_void;
 400f058:	e0bffb17 	ldw	r2,-20(fp)
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 400f05c:	e037883a 	mov	sp,fp
 400f060:	df000017 	ldw	fp,0(sp)
 400f064:	dec00104 	addi	sp,sp,4
 400f068:	f800283a 	ret

0400f06c <_Balloc>:
#define _Kmax 15
*/

_Bigint *
Balloc (struct _reent *ptr, int k)
{
 400f06c:	defffa04 	addi	sp,sp,-24
 400f070:	dfc00515 	stw	ra,20(sp)
 400f074:	df000415 	stw	fp,16(sp)
 400f078:	df000404 	addi	fp,sp,16
 400f07c:	e13ffd15 	stw	r4,-12(fp)
 400f080:	e17ffc15 	stw	r5,-16(fp)
  int x;
  _Bigint *rv ;

  _REENT_CHECK_MP(ptr);
  if (_REENT_MP_FREELIST(ptr) == NULL)
 400f084:	e0bffd17 	ldw	r2,-12(fp)
 400f088:	10801317 	ldw	r2,76(r2)
 400f08c:	10000c1e 	bne	r2,zero,400f0c0 <_Balloc+0x54>
    {
      /* Allocate a list of pointers to the mprec objects */
      _REENT_MP_FREELIST(ptr) = (struct _Bigint **) _calloc_r (ptr, 
 400f090:	01800844 	movi	r6,33
 400f094:	01400104 	movi	r5,4
 400f098:	e13ffd17 	ldw	r4,-12(fp)
 400f09c:	40131600 	call	4013160 <_calloc_r>
 400f0a0:	1007883a 	mov	r3,r2
 400f0a4:	e0bffd17 	ldw	r2,-12(fp)
 400f0a8:	10c01315 	stw	r3,76(r2)
						      sizeof (struct _Bigint *),
						      _Kmax + 1);
      if (_REENT_MP_FREELIST(ptr) == NULL)
 400f0ac:	e0bffd17 	ldw	r2,-12(fp)
 400f0b0:	10801317 	ldw	r2,76(r2)
 400f0b4:	1000021e 	bne	r2,zero,400f0c0 <_Balloc+0x54>
	{
	  return NULL;
 400f0b8:	0005883a 	mov	r2,zero
 400f0bc:	00002f06 	br	400f17c <_Balloc+0x110>
	}
    }

  if ((rv = _REENT_MP_FREELIST(ptr)[k]) != 0)
 400f0c0:	e0bffd17 	ldw	r2,-12(fp)
 400f0c4:	10c01317 	ldw	r3,76(r2)
 400f0c8:	e0bffc17 	ldw	r2,-16(fp)
 400f0cc:	100490ba 	slli	r2,r2,2
 400f0d0:	1885883a 	add	r2,r3,r2
 400f0d4:	10800017 	ldw	r2,0(r2)
 400f0d8:	e0bfff15 	stw	r2,-4(fp)
 400f0dc:	e0bfff17 	ldw	r2,-4(fp)
 400f0e0:	10000926 	beq	r2,zero,400f108 <_Balloc+0x9c>
    {
      _REENT_MP_FREELIST(ptr)[k] = rv->_next;
 400f0e4:	e0bffd17 	ldw	r2,-12(fp)
 400f0e8:	10c01317 	ldw	r3,76(r2)
 400f0ec:	e0bffc17 	ldw	r2,-16(fp)
 400f0f0:	100490ba 	slli	r2,r2,2
 400f0f4:	1885883a 	add	r2,r3,r2
 400f0f8:	e0ffff17 	ldw	r3,-4(fp)
 400f0fc:	18c00017 	ldw	r3,0(r3)
 400f100:	10c00015 	stw	r3,0(r2)
 400f104:	00001606 	br	400f160 <_Balloc+0xf4>
    }
  else
    {
      x = 1 << k;
 400f108:	00c00044 	movi	r3,1
 400f10c:	e0bffc17 	ldw	r2,-16(fp)
 400f110:	1884983a 	sll	r2,r3,r2
 400f114:	e0bffe15 	stw	r2,-8(fp)
      /* Allocate an mprec Bigint and stick in in the freelist */
      rv = (_Bigint *) _calloc_r (ptr,
				  1,
				  sizeof (_Bigint) +
 400f118:	e0bffe17 	ldw	r2,-8(fp)
 400f11c:	10800144 	addi	r2,r2,5
      rv = (_Bigint *) _calloc_r (ptr,
 400f120:	100490ba 	slli	r2,r2,2
 400f124:	100d883a 	mov	r6,r2
 400f128:	01400044 	movi	r5,1
 400f12c:	e13ffd17 	ldw	r4,-12(fp)
 400f130:	40131600 	call	4013160 <_calloc_r>
 400f134:	e0bfff15 	stw	r2,-4(fp)
				  (x-1) * sizeof(rv->_x));
      if (rv == NULL) return NULL;
 400f138:	e0bfff17 	ldw	r2,-4(fp)
 400f13c:	1000021e 	bne	r2,zero,400f148 <_Balloc+0xdc>
 400f140:	0005883a 	mov	r2,zero
 400f144:	00000d06 	br	400f17c <_Balloc+0x110>
      rv->_k = k;
 400f148:	e0bfff17 	ldw	r2,-4(fp)
 400f14c:	e0fffc17 	ldw	r3,-16(fp)
 400f150:	10c00115 	stw	r3,4(r2)
      rv->_maxwds = x;
 400f154:	e0bfff17 	ldw	r2,-4(fp)
 400f158:	e0fffe17 	ldw	r3,-8(fp)
 400f15c:	10c00215 	stw	r3,8(r2)
    }
  rv->_sign = rv->_wds = 0;
 400f160:	e0bfff17 	ldw	r2,-4(fp)
 400f164:	10000415 	stw	zero,16(r2)
 400f168:	e0bfff17 	ldw	r2,-4(fp)
 400f16c:	10c00417 	ldw	r3,16(r2)
 400f170:	e0bfff17 	ldw	r2,-4(fp)
 400f174:	10c00315 	stw	r3,12(r2)
  return rv;
 400f178:	e0bfff17 	ldw	r2,-4(fp)
}
 400f17c:	e037883a 	mov	sp,fp
 400f180:	dfc00117 	ldw	ra,4(sp)
 400f184:	df000017 	ldw	fp,0(sp)
 400f188:	dec00204 	addi	sp,sp,8
 400f18c:	f800283a 	ret

0400f190 <_Bfree>:

void
Bfree (struct _reent *ptr, _Bigint * v)
{
 400f190:	defffd04 	addi	sp,sp,-12
 400f194:	df000215 	stw	fp,8(sp)
 400f198:	df000204 	addi	fp,sp,8
 400f19c:	e13fff15 	stw	r4,-4(fp)
 400f1a0:	e17ffe15 	stw	r5,-8(fp)
  _REENT_CHECK_MP(ptr);
  if (v)
 400f1a4:	e0bffe17 	ldw	r2,-8(fp)
 400f1a8:	10001126 	beq	r2,zero,400f1f0 <_Bfree+0x60>
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
 400f1ac:	e0bfff17 	ldw	r2,-4(fp)
 400f1b0:	10c01317 	ldw	r3,76(r2)
 400f1b4:	e0bffe17 	ldw	r2,-8(fp)
 400f1b8:	10800117 	ldw	r2,4(r2)
 400f1bc:	100490ba 	slli	r2,r2,2
 400f1c0:	1885883a 	add	r2,r3,r2
 400f1c4:	10c00017 	ldw	r3,0(r2)
 400f1c8:	e0bffe17 	ldw	r2,-8(fp)
 400f1cc:	10c00015 	stw	r3,0(r2)
      _REENT_MP_FREELIST(ptr)[v->_k] = v;
 400f1d0:	e0bfff17 	ldw	r2,-4(fp)
 400f1d4:	10c01317 	ldw	r3,76(r2)
 400f1d8:	e0bffe17 	ldw	r2,-8(fp)
 400f1dc:	10800117 	ldw	r2,4(r2)
 400f1e0:	100490ba 	slli	r2,r2,2
 400f1e4:	1885883a 	add	r2,r3,r2
 400f1e8:	e0fffe17 	ldw	r3,-8(fp)
 400f1ec:	10c00015 	stw	r3,0(r2)
    }
}
 400f1f0:	0001883a 	nop
 400f1f4:	e037883a 	mov	sp,fp
 400f1f8:	df000017 	ldw	fp,0(sp)
 400f1fc:	dec00104 	addi	sp,sp,4
 400f200:	f800283a 	ret

0400f204 <__multadd>:
_Bigint *
multadd (struct _reent *ptr,
	_Bigint * b,
	int m,
	int a)
{
 400f204:	defff204 	addi	sp,sp,-56
 400f208:	dfc00d15 	stw	ra,52(sp)
 400f20c:	df000c15 	stw	fp,48(sp)
 400f210:	df000c04 	addi	fp,sp,48
 400f214:	e13ff715 	stw	r4,-36(fp)
 400f218:	e17ff615 	stw	r5,-40(fp)
 400f21c:	e1bff515 	stw	r6,-44(fp)
 400f220:	e1fff415 	stw	r7,-48(fp)
#ifdef Pack_32
  __ULong xi, z;
#endif
  _Bigint *b1;

  wds = b->_wds;
 400f224:	e0bff617 	ldw	r2,-40(fp)
 400f228:	10800417 	ldw	r2,16(r2)
 400f22c:	e0bffd15 	stw	r2,-12(fp)
  x = b->_x;
 400f230:	e0bff617 	ldw	r2,-40(fp)
 400f234:	10800504 	addi	r2,r2,20
 400f238:	e0bffe15 	stw	r2,-8(fp)
  i = 0;
 400f23c:	e03fff15 	stw	zero,-4(fp)
  do
    {
#ifdef Pack_32
      xi = *x;
 400f240:	e0bffe17 	ldw	r2,-8(fp)
 400f244:	10800017 	ldw	r2,0(r2)
 400f248:	e0bffc15 	stw	r2,-16(fp)
      y = (xi & 0xffff) * m + a;
 400f24c:	e0bffc17 	ldw	r2,-16(fp)
 400f250:	10bfffcc 	andi	r2,r2,65535
 400f254:	e0fff517 	ldw	r3,-44(fp)
 400f258:	180b883a 	mov	r5,r3
 400f25c:	1009883a 	mov	r4,r2
 400f260:	40072d80 	call	40072d8 <__mulsi3>
 400f264:	1007883a 	mov	r3,r2
 400f268:	e0bff417 	ldw	r2,-48(fp)
 400f26c:	1885883a 	add	r2,r3,r2
 400f270:	e0bffb15 	stw	r2,-20(fp)
      z = (xi >> 16) * m + (y >> 16);
 400f274:	e0bffc17 	ldw	r2,-16(fp)
 400f278:	1004d43a 	srli	r2,r2,16
 400f27c:	e0fff517 	ldw	r3,-44(fp)
 400f280:	180b883a 	mov	r5,r3
 400f284:	1009883a 	mov	r4,r2
 400f288:	40072d80 	call	40072d8 <__mulsi3>
 400f28c:	1007883a 	mov	r3,r2
 400f290:	e0bffb17 	ldw	r2,-20(fp)
 400f294:	1004d43a 	srli	r2,r2,16
 400f298:	1885883a 	add	r2,r3,r2
 400f29c:	e0bffa15 	stw	r2,-24(fp)
      a = (int) (z >> 16);
 400f2a0:	e0bffa17 	ldw	r2,-24(fp)
 400f2a4:	1004d43a 	srli	r2,r2,16
 400f2a8:	e0bff415 	stw	r2,-48(fp)
      *x++ = (z << 16) + (y & 0xffff);
 400f2ac:	e0bffa17 	ldw	r2,-24(fp)
 400f2b0:	1008943a 	slli	r4,r2,16
 400f2b4:	e0bffb17 	ldw	r2,-20(fp)
 400f2b8:	10ffffcc 	andi	r3,r2,65535
 400f2bc:	e0bffe17 	ldw	r2,-8(fp)
 400f2c0:	11400104 	addi	r5,r2,4
 400f2c4:	e17ffe15 	stw	r5,-8(fp)
 400f2c8:	20c7883a 	add	r3,r4,r3
 400f2cc:	10c00015 	stw	r3,0(r2)
      y = *x * m + a;
      a = (int) (y >> 16);
      *x++ = y & 0xffff;
#endif
    }
  while (++i < wds);
 400f2d0:	e0bfff17 	ldw	r2,-4(fp)
 400f2d4:	10800044 	addi	r2,r2,1
 400f2d8:	e0bfff15 	stw	r2,-4(fp)
 400f2dc:	e0ffff17 	ldw	r3,-4(fp)
 400f2e0:	e0bffd17 	ldw	r2,-12(fp)
 400f2e4:	18bfd616 	blt	r3,r2,400f240 <__multadd+0x3c>
  if (a)
 400f2e8:	e0bff417 	ldw	r2,-48(fp)
 400f2ec:	10003326 	beq	r2,zero,400f3bc <__multadd+0x1b8>
    {
      if (wds >= b->_maxwds)
 400f2f0:	e0bff617 	ldw	r2,-40(fp)
 400f2f4:	10800217 	ldw	r2,8(r2)
 400f2f8:	e0fffd17 	ldw	r3,-12(fp)
 400f2fc:	18802316 	blt	r3,r2,400f38c <__multadd+0x188>
	{
	  b1 = eBalloc (ptr, b->_k + 1);
 400f300:	e0bff617 	ldw	r2,-40(fp)
 400f304:	10800117 	ldw	r2,4(r2)
 400f308:	10800044 	addi	r2,r2,1
 400f30c:	100b883a 	mov	r5,r2
 400f310:	e13ff717 	ldw	r4,-36(fp)
 400f314:	400f06c0 	call	400f06c <_Balloc>
 400f318:	e0bff915 	stw	r2,-28(fp)
 400f31c:	e0bff917 	ldw	r2,-28(fp)
 400f320:	1000071e 	bne	r2,zero,400f340 <__multadd+0x13c>
 400f324:	01c100b4 	movhi	r7,1026
 400f328:	39eb0104 	addi	r7,r7,-21500
 400f32c:	000d883a 	mov	r6,zero
 400f330:	01402d44 	movi	r5,181
 400f334:	010100b4 	movhi	r4,1026
 400f338:	212b0604 	addi	r4,r4,-21480
 400f33c:	40130ac0 	call	40130ac <__assert_func>
 400f340:	e0bff917 	ldw	r2,-28(fp)
 400f344:	e0bff815 	stw	r2,-32(fp)
	  Bcopy (b1, b);
 400f348:	e0bff817 	ldw	r2,-32(fp)
 400f34c:	10c00304 	addi	r3,r2,12
 400f350:	e0bff617 	ldw	r2,-40(fp)
 400f354:	11000304 	addi	r4,r2,12
 400f358:	e0bff617 	ldw	r2,-40(fp)
 400f35c:	10800417 	ldw	r2,16(r2)
 400f360:	10800084 	addi	r2,r2,2
 400f364:	100490ba 	slli	r2,r2,2
 400f368:	100d883a 	mov	r6,r2
 400f36c:	200b883a 	mov	r5,r4
 400f370:	1809883a 	mov	r4,r3
 400f374:	40073000 	call	4007300 <memcpy>
	  Bfree (ptr, b);
 400f378:	e17ff617 	ldw	r5,-40(fp)
 400f37c:	e13ff717 	ldw	r4,-36(fp)
 400f380:	400f1900 	call	400f190 <_Bfree>
	  b = b1;
 400f384:	e0bff817 	ldw	r2,-32(fp)
 400f388:	e0bff615 	stw	r2,-40(fp)
	}
      b->_x[wds++] = a;
 400f38c:	e0bffd17 	ldw	r2,-12(fp)
 400f390:	10c00044 	addi	r3,r2,1
 400f394:	e0fffd15 	stw	r3,-12(fp)
 400f398:	e0fff417 	ldw	r3,-48(fp)
 400f39c:	e13ff617 	ldw	r4,-40(fp)
 400f3a0:	10800144 	addi	r2,r2,5
 400f3a4:	100490ba 	slli	r2,r2,2
 400f3a8:	2085883a 	add	r2,r4,r2
 400f3ac:	10c00015 	stw	r3,0(r2)
      b->_wds = wds;
 400f3b0:	e0bff617 	ldw	r2,-40(fp)
 400f3b4:	e0fffd17 	ldw	r3,-12(fp)
 400f3b8:	10c00415 	stw	r3,16(r2)
    }
  return b;
 400f3bc:	e0bff617 	ldw	r2,-40(fp)
}
 400f3c0:	e037883a 	mov	sp,fp
 400f3c4:	dfc00117 	ldw	ra,4(sp)
 400f3c8:	df000017 	ldw	fp,0(sp)
 400f3cc:	dec00204 	addi	sp,sp,8
 400f3d0:	f800283a 	ret

0400f3d4 <__s2b>:
s2b (struct _reent * ptr,
	const char *s,
	int nd0,
	int nd,
	__ULong y9)
{
 400f3d4:	defff404 	addi	sp,sp,-48
 400f3d8:	dfc00b15 	stw	ra,44(sp)
 400f3dc:	df000a15 	stw	fp,40(sp)
 400f3e0:	df000a04 	addi	fp,sp,40
 400f3e4:	e13ff915 	stw	r4,-28(fp)
 400f3e8:	e17ff815 	stw	r5,-32(fp)
 400f3ec:	e1bff715 	stw	r6,-36(fp)
 400f3f0:	e1fff615 	stw	r7,-40(fp)
  _Bigint *b;
  int i, k;
  __Long x, y;

  x = (nd + 8) / 9;
 400f3f4:	e0bff617 	ldw	r2,-40(fp)
 400f3f8:	10800204 	addi	r2,r2,8
 400f3fc:	01400244 	movi	r5,9
 400f400:	1009883a 	mov	r4,r2
 400f404:	401528c0 	call	401528c <__divsi3>
 400f408:	e0bffb15 	stw	r2,-20(fp)
  for (k = 0, y = 1; x > y; y <<= 1, k++);
 400f40c:	e03ffd15 	stw	zero,-12(fp)
 400f410:	00800044 	movi	r2,1
 400f414:	e0bffc15 	stw	r2,-16(fp)
 400f418:	00000606 	br	400f434 <__s2b+0x60>
 400f41c:	e0bffc17 	ldw	r2,-16(fp)
 400f420:	1085883a 	add	r2,r2,r2
 400f424:	e0bffc15 	stw	r2,-16(fp)
 400f428:	e0bffd17 	ldw	r2,-12(fp)
 400f42c:	10800044 	addi	r2,r2,1
 400f430:	e0bffd15 	stw	r2,-12(fp)
 400f434:	e0bffb17 	ldw	r2,-20(fp)
 400f438:	e0fffc17 	ldw	r3,-16(fp)
 400f43c:	18bff716 	blt	r3,r2,400f41c <__s2b+0x48>
#ifdef Pack_32
  b = eBalloc (ptr, k);
 400f440:	e17ffd17 	ldw	r5,-12(fp)
 400f444:	e13ff917 	ldw	r4,-28(fp)
 400f448:	400f06c0 	call	400f06c <_Balloc>
 400f44c:	e0bffa15 	stw	r2,-24(fp)
 400f450:	e0bffa17 	ldw	r2,-24(fp)
 400f454:	1000071e 	bne	r2,zero,400f474 <__s2b+0xa0>
 400f458:	01c100b4 	movhi	r7,1026
 400f45c:	39eb0104 	addi	r7,r7,-21500
 400f460:	000d883a 	mov	r6,zero
 400f464:	01403384 	movi	r5,206
 400f468:	010100b4 	movhi	r4,1026
 400f46c:	212b0604 	addi	r4,r4,-21480
 400f470:	40130ac0 	call	40130ac <__assert_func>
 400f474:	e0bffa17 	ldw	r2,-24(fp)
 400f478:	e0bfff15 	stw	r2,-4(fp)
  b->_x[0] = y9;
 400f47c:	e0bfff17 	ldw	r2,-4(fp)
 400f480:	e0c00217 	ldw	r3,8(fp)
 400f484:	10c00515 	stw	r3,20(r2)
  b->_wds = 1;
 400f488:	e0bfff17 	ldw	r2,-4(fp)
 400f48c:	00c00044 	movi	r3,1
 400f490:	10c00415 	stw	r3,16(r2)
  b = eBalloc (ptr, k + 1);
  b->_x[0] = y9 & 0xffff;
  b->_wds = (b->_x[1] = y9 >> 16) ? 2 : 1;
#endif

  i = 9;
 400f494:	00800244 	movi	r2,9
 400f498:	e0bffe15 	stw	r2,-8(fp)
  if (9 < nd0)
 400f49c:	e0bff717 	ldw	r2,-36(fp)
 400f4a0:	10800290 	cmplti	r2,r2,10
 400f4a4:	10001b1e 	bne	r2,zero,400f514 <__s2b+0x140>
    {
      s += 9;
 400f4a8:	e0bff817 	ldw	r2,-32(fp)
 400f4ac:	10800244 	addi	r2,r2,9
 400f4b0:	e0bff815 	stw	r2,-32(fp)
      do
	b = multadd (ptr, b, 10, *s++ - '0');
 400f4b4:	e0bff817 	ldw	r2,-32(fp)
 400f4b8:	10c00044 	addi	r3,r2,1
 400f4bc:	e0fff815 	stw	r3,-32(fp)
 400f4c0:	10800003 	ldbu	r2,0(r2)
 400f4c4:	10803fcc 	andi	r2,r2,255
 400f4c8:	1080201c 	xori	r2,r2,128
 400f4cc:	10bfe004 	addi	r2,r2,-128
 400f4d0:	10bff404 	addi	r2,r2,-48
 400f4d4:	100f883a 	mov	r7,r2
 400f4d8:	01800284 	movi	r6,10
 400f4dc:	e17fff17 	ldw	r5,-4(fp)
 400f4e0:	e13ff917 	ldw	r4,-28(fp)
 400f4e4:	400f2040 	call	400f204 <__multadd>
 400f4e8:	e0bfff15 	stw	r2,-4(fp)
      while (++i < nd0);
 400f4ec:	e0bffe17 	ldw	r2,-8(fp)
 400f4f0:	10800044 	addi	r2,r2,1
 400f4f4:	e0bffe15 	stw	r2,-8(fp)
 400f4f8:	e0fffe17 	ldw	r3,-8(fp)
 400f4fc:	e0bff717 	ldw	r2,-36(fp)
 400f500:	18bfec16 	blt	r3,r2,400f4b4 <__s2b+0xe0>
      s++;
 400f504:	e0bff817 	ldw	r2,-32(fp)
 400f508:	10800044 	addi	r2,r2,1
 400f50c:	e0bff815 	stw	r2,-32(fp)
 400f510:	00001506 	br	400f568 <__s2b+0x194>
    }
  else
    s += 10;
 400f514:	e0bff817 	ldw	r2,-32(fp)
 400f518:	10800284 	addi	r2,r2,10
 400f51c:	e0bff815 	stw	r2,-32(fp)
  for (; i < nd; i++)
 400f520:	00001106 	br	400f568 <__s2b+0x194>
    b = multadd (ptr, b, 10, *s++ - '0');
 400f524:	e0bff817 	ldw	r2,-32(fp)
 400f528:	10c00044 	addi	r3,r2,1
 400f52c:	e0fff815 	stw	r3,-32(fp)
 400f530:	10800003 	ldbu	r2,0(r2)
 400f534:	10803fcc 	andi	r2,r2,255
 400f538:	1080201c 	xori	r2,r2,128
 400f53c:	10bfe004 	addi	r2,r2,-128
 400f540:	10bff404 	addi	r2,r2,-48
 400f544:	100f883a 	mov	r7,r2
 400f548:	01800284 	movi	r6,10
 400f54c:	e17fff17 	ldw	r5,-4(fp)
 400f550:	e13ff917 	ldw	r4,-28(fp)
 400f554:	400f2040 	call	400f204 <__multadd>
 400f558:	e0bfff15 	stw	r2,-4(fp)
  for (; i < nd; i++)
 400f55c:	e0bffe17 	ldw	r2,-8(fp)
 400f560:	10800044 	addi	r2,r2,1
 400f564:	e0bffe15 	stw	r2,-8(fp)
 400f568:	e0fffe17 	ldw	r3,-8(fp)
 400f56c:	e0bff617 	ldw	r2,-40(fp)
 400f570:	18bfec16 	blt	r3,r2,400f524 <__s2b+0x150>
  return b;
 400f574:	e0bfff17 	ldw	r2,-4(fp)
}
 400f578:	e037883a 	mov	sp,fp
 400f57c:	dfc00117 	ldw	ra,4(sp)
 400f580:	df000017 	ldw	fp,0(sp)
 400f584:	dec00204 	addi	sp,sp,8
 400f588:	f800283a 	ret

0400f58c <__hi0bits>:

int
hi0bits (register __ULong x)
{
 400f58c:	defffe04 	addi	sp,sp,-8
 400f590:	df000115 	stw	fp,4(sp)
 400f594:	dc000015 	stw	r16,0(sp)
 400f598:	df000104 	addi	fp,sp,4
 400f59c:	2005883a 	mov	r2,r4
  register int k = 0;
 400f5a0:	0021883a 	mov	r16,zero

  if (!(x & 0xffff0000))
 400f5a4:	10ffffec 	andhi	r3,r2,65535
 400f5a8:	1800021e 	bne	r3,zero,400f5b4 <__hi0bits+0x28>
    {
      k = 16;
 400f5ac:	04000404 	movi	r16,16
      x <<= 16;
 400f5b0:	1004943a 	slli	r2,r2,16
    }
  if (!(x & 0xff000000))
 400f5b4:	10ffc02c 	andhi	r3,r2,65280
 400f5b8:	1800021e 	bne	r3,zero,400f5c4 <__hi0bits+0x38>
    {
      k += 8;
 400f5bc:	84000204 	addi	r16,r16,8
      x <<= 8;
 400f5c0:	1004923a 	slli	r2,r2,8
    }
  if (!(x & 0xf0000000))
 400f5c4:	10fc002c 	andhi	r3,r2,61440
 400f5c8:	1800021e 	bne	r3,zero,400f5d4 <__hi0bits+0x48>
    {
      k += 4;
 400f5cc:	84000104 	addi	r16,r16,4
      x <<= 4;
 400f5d0:	1004913a 	slli	r2,r2,4
    }
  if (!(x & 0xc0000000))
 400f5d4:	10f0002c 	andhi	r3,r2,49152
 400f5d8:	1800021e 	bne	r3,zero,400f5e4 <__hi0bits+0x58>
    {
      k += 2;
 400f5dc:	84000084 	addi	r16,r16,2
      x <<= 2;
 400f5e0:	100490ba 	slli	r2,r2,2
    }
  if (!(x & 0x80000000))
 400f5e4:	1007883a 	mov	r3,r2
 400f5e8:	18000516 	blt	r3,zero,400f600 <__hi0bits+0x74>
    {
      k++;
 400f5ec:	84000044 	addi	r16,r16,1
      if (!(x & 0x40000000))
 400f5f0:	1090002c 	andhi	r2,r2,16384
 400f5f4:	1000021e 	bne	r2,zero,400f600 <__hi0bits+0x74>
	return 32;
 400f5f8:	00800804 	movi	r2,32
 400f5fc:	00000106 	br	400f604 <__hi0bits+0x78>
    }
  return k;
 400f600:	8005883a 	mov	r2,r16
}
 400f604:	e6ffff04 	addi	sp,fp,-4
 400f608:	df000117 	ldw	fp,4(sp)
 400f60c:	dc000017 	ldw	r16,0(sp)
 400f610:	dec00204 	addi	sp,sp,8
 400f614:	f800283a 	ret

0400f618 <__lo0bits>:

int
lo0bits (__ULong *y)
{
 400f618:	defffc04 	addi	sp,sp,-16
 400f61c:	df000315 	stw	fp,12(sp)
 400f620:	dc400215 	stw	r17,8(sp)
 400f624:	dc000115 	stw	r16,4(sp)
 400f628:	df000304 	addi	fp,sp,12
 400f62c:	e13ffd15 	stw	r4,-12(fp)
  register int k;
  register __ULong x = *y;
 400f630:	e0bffd17 	ldw	r2,-12(fp)
 400f634:	14000017 	ldw	r16,0(r2)

  if (x & 7)
 400f638:	808001cc 	andi	r2,r16,7
 400f63c:	10001026 	beq	r2,zero,400f680 <__lo0bits+0x68>
    {
      if (x & 1)
 400f640:	8080004c 	andi	r2,r16,1
 400f644:	10000226 	beq	r2,zero,400f650 <__lo0bits+0x38>
	return 0;
 400f648:	0005883a 	mov	r2,zero
 400f64c:	00002706 	br	400f6ec <__lo0bits+0xd4>
      if (x & 2)
 400f650:	8080008c 	andi	r2,r16,2
 400f654:	10000526 	beq	r2,zero,400f66c <__lo0bits+0x54>
	{
	  *y = x >> 1;
 400f658:	8006d07a 	srli	r3,r16,1
 400f65c:	e0bffd17 	ldw	r2,-12(fp)
 400f660:	10c00015 	stw	r3,0(r2)
	  return 1;
 400f664:	00800044 	movi	r2,1
 400f668:	00002006 	br	400f6ec <__lo0bits+0xd4>
	}
      *y = x >> 2;
 400f66c:	8006d0ba 	srli	r3,r16,2
 400f670:	e0bffd17 	ldw	r2,-12(fp)
 400f674:	10c00015 	stw	r3,0(r2)
      return 2;
 400f678:	00800084 	movi	r2,2
 400f67c:	00001b06 	br	400f6ec <__lo0bits+0xd4>
    }
  k = 0;
 400f680:	0023883a 	mov	r17,zero
  if (!(x & 0xffff))
 400f684:	80bfffcc 	andi	r2,r16,65535
 400f688:	1000021e 	bne	r2,zero,400f694 <__lo0bits+0x7c>
    {
      k = 16;
 400f68c:	04400404 	movi	r17,16
      x >>= 16;
 400f690:	8020d43a 	srli	r16,r16,16
    }
  if (!(x & 0xff))
 400f694:	80803fcc 	andi	r2,r16,255
 400f698:	1000021e 	bne	r2,zero,400f6a4 <__lo0bits+0x8c>
    {
      k += 8;
 400f69c:	8c400204 	addi	r17,r17,8
      x >>= 8;
 400f6a0:	8020d23a 	srli	r16,r16,8
    }
  if (!(x & 0xf))
 400f6a4:	808003cc 	andi	r2,r16,15
 400f6a8:	1000021e 	bne	r2,zero,400f6b4 <__lo0bits+0x9c>
    {
      k += 4;
 400f6ac:	8c400104 	addi	r17,r17,4
      x >>= 4;
 400f6b0:	8020d13a 	srli	r16,r16,4
    }
  if (!(x & 0x3))
 400f6b4:	808000cc 	andi	r2,r16,3
 400f6b8:	1000021e 	bne	r2,zero,400f6c4 <__lo0bits+0xac>
    {
      k += 2;
 400f6bc:	8c400084 	addi	r17,r17,2
      x >>= 2;
 400f6c0:	8020d0ba 	srli	r16,r16,2
    }
  if (!(x & 1))
 400f6c4:	8080004c 	andi	r2,r16,1
 400f6c8:	1000051e 	bne	r2,zero,400f6e0 <__lo0bits+0xc8>
    {
      k++;
 400f6cc:	8c400044 	addi	r17,r17,1
      x >>= 1;
 400f6d0:	8020d07a 	srli	r16,r16,1
      if (!x & 1)
 400f6d4:	8000021e 	bne	r16,zero,400f6e0 <__lo0bits+0xc8>
	return 32;
 400f6d8:	00800804 	movi	r2,32
 400f6dc:	00000306 	br	400f6ec <__lo0bits+0xd4>
    }
  *y = x;
 400f6e0:	e0bffd17 	ldw	r2,-12(fp)
 400f6e4:	14000015 	stw	r16,0(r2)
  return k;
 400f6e8:	8805883a 	mov	r2,r17
}
 400f6ec:	e6fffe04 	addi	sp,fp,-8
 400f6f0:	df000217 	ldw	fp,8(sp)
 400f6f4:	dc400117 	ldw	r17,4(sp)
 400f6f8:	dc000017 	ldw	r16,0(sp)
 400f6fc:	dec00304 	addi	sp,sp,12
 400f700:	f800283a 	ret

0400f704 <__i2b>:

_Bigint *
i2b (struct _reent * ptr, int i)
{
 400f704:	defffa04 	addi	sp,sp,-24
 400f708:	dfc00515 	stw	ra,20(sp)
 400f70c:	df000415 	stw	fp,16(sp)
 400f710:	df000404 	addi	fp,sp,16
 400f714:	e13ffd15 	stw	r4,-12(fp)
 400f718:	e17ffc15 	stw	r5,-16(fp)
  _Bigint *b;

  b = eBalloc (ptr, 1);
 400f71c:	01400044 	movi	r5,1
 400f720:	e13ffd17 	ldw	r4,-12(fp)
 400f724:	400f06c0 	call	400f06c <_Balloc>
 400f728:	e0bfff15 	stw	r2,-4(fp)
 400f72c:	e0bfff17 	ldw	r2,-4(fp)
 400f730:	1000071e 	bne	r2,zero,400f750 <__i2b+0x4c>
 400f734:	01c100b4 	movhi	r7,1026
 400f738:	39eb0104 	addi	r7,r7,-21500
 400f73c:	000d883a 	mov	r6,zero
 400f740:	01405004 	movi	r5,320
 400f744:	010100b4 	movhi	r4,1026
 400f748:	212b0604 	addi	r4,r4,-21480
 400f74c:	40130ac0 	call	40130ac <__assert_func>
 400f750:	e0bfff17 	ldw	r2,-4(fp)
 400f754:	e0bffe15 	stw	r2,-8(fp)
  b->_x[0] = i;
 400f758:	e0fffc17 	ldw	r3,-16(fp)
 400f75c:	e0bffe17 	ldw	r2,-8(fp)
 400f760:	10c00515 	stw	r3,20(r2)
  b->_wds = 1;
 400f764:	e0bffe17 	ldw	r2,-8(fp)
 400f768:	00c00044 	movi	r3,1
 400f76c:	10c00415 	stw	r3,16(r2)
  return b;
 400f770:	e0bffe17 	ldw	r2,-8(fp)
}
 400f774:	e037883a 	mov	sp,fp
 400f778:	dfc00117 	ldw	ra,4(sp)
 400f77c:	df000017 	ldw	fp,0(sp)
 400f780:	dec00204 	addi	sp,sp,8
 400f784:	f800283a 	ret

0400f788 <__multiply>:

_Bigint *
mult (struct _reent * ptr, _Bigint * a, _Bigint * b)
{
 400f788:	deffea04 	addi	sp,sp,-88
 400f78c:	dfc01515 	stw	ra,84(sp)
 400f790:	df001415 	stw	fp,80(sp)
 400f794:	df001404 	addi	fp,sp,80
 400f798:	e13fee15 	stw	r4,-72(fp)
 400f79c:	e17fed15 	stw	r5,-76(fp)
 400f7a0:	e1bfec15 	stw	r6,-80(fp)
  __ULong *x, *xa, *xae, *xb, *xbe, *xc, *xc0;
#ifdef Pack_32
  __ULong z2;
#endif

  if (a->_wds < b->_wds)
 400f7a4:	e0bfed17 	ldw	r2,-76(fp)
 400f7a8:	10c00417 	ldw	r3,16(r2)
 400f7ac:	e0bfec17 	ldw	r2,-80(fp)
 400f7b0:	10800417 	ldw	r2,16(r2)
 400f7b4:	1880060e 	bge	r3,r2,400f7d0 <__multiply+0x48>
    {
      c = a;
 400f7b8:	e0bfed17 	ldw	r2,-76(fp)
 400f7bc:	e0bff715 	stw	r2,-36(fp)
      a = b;
 400f7c0:	e0bfec17 	ldw	r2,-80(fp)
 400f7c4:	e0bfed15 	stw	r2,-76(fp)
      b = c;
 400f7c8:	e0bff717 	ldw	r2,-36(fp)
 400f7cc:	e0bfec15 	stw	r2,-80(fp)
    }
  k = a->_k;
 400f7d0:	e0bfed17 	ldw	r2,-76(fp)
 400f7d4:	10800117 	ldw	r2,4(r2)
 400f7d8:	e0bfff15 	stw	r2,-4(fp)
  wa = a->_wds;
 400f7dc:	e0bfed17 	ldw	r2,-76(fp)
 400f7e0:	10800417 	ldw	r2,16(r2)
 400f7e4:	e0bff615 	stw	r2,-40(fp)
  wb = b->_wds;
 400f7e8:	e0bfec17 	ldw	r2,-80(fp)
 400f7ec:	10800417 	ldw	r2,16(r2)
 400f7f0:	e0bff515 	stw	r2,-44(fp)
  wc = wa + wb;
 400f7f4:	e0fff617 	ldw	r3,-40(fp)
 400f7f8:	e0bff517 	ldw	r2,-44(fp)
 400f7fc:	1885883a 	add	r2,r3,r2
 400f800:	e0bffe15 	stw	r2,-8(fp)
  if (wc > a->_maxwds)
 400f804:	e0bfed17 	ldw	r2,-76(fp)
 400f808:	10c00217 	ldw	r3,8(r2)
 400f80c:	e0bffe17 	ldw	r2,-8(fp)
 400f810:	1880030e 	bge	r3,r2,400f820 <__multiply+0x98>
    k++;
 400f814:	e0bfff17 	ldw	r2,-4(fp)
 400f818:	10800044 	addi	r2,r2,1
 400f81c:	e0bfff15 	stw	r2,-4(fp)
  c = eBalloc (ptr, k);
 400f820:	e17fff17 	ldw	r5,-4(fp)
 400f824:	e13fee17 	ldw	r4,-72(fp)
 400f828:	400f06c0 	call	400f06c <_Balloc>
 400f82c:	e0bff415 	stw	r2,-48(fp)
 400f830:	e0bff417 	ldw	r2,-48(fp)
 400f834:	1000071e 	bne	r2,zero,400f854 <__multiply+0xcc>
 400f838:	01c100b4 	movhi	r7,1026
 400f83c:	39eb0104 	addi	r7,r7,-21500
 400f840:	000d883a 	mov	r6,zero
 400f844:	01405744 	movi	r5,349
 400f848:	010100b4 	movhi	r4,1026
 400f84c:	212b0604 	addi	r4,r4,-21480
 400f850:	40130ac0 	call	40130ac <__assert_func>
 400f854:	e0bff417 	ldw	r2,-48(fp)
 400f858:	e0bff715 	stw	r2,-36(fp)
  for (x = c->_x, xa = x + wc; x < xa; x++)
 400f85c:	e0bff717 	ldw	r2,-36(fp)
 400f860:	10800504 	addi	r2,r2,20
 400f864:	e0bffc15 	stw	r2,-16(fp)
 400f868:	e0bffe17 	ldw	r2,-8(fp)
 400f86c:	100490ba 	slli	r2,r2,2
 400f870:	e0fffc17 	ldw	r3,-16(fp)
 400f874:	1885883a 	add	r2,r3,r2
 400f878:	e0bff315 	stw	r2,-52(fp)
 400f87c:	00000506 	br	400f894 <__multiply+0x10c>
    *x = 0;
 400f880:	e0bffc17 	ldw	r2,-16(fp)
 400f884:	10000015 	stw	zero,0(r2)
  for (x = c->_x, xa = x + wc; x < xa; x++)
 400f888:	e0bffc17 	ldw	r2,-16(fp)
 400f88c:	10800104 	addi	r2,r2,4
 400f890:	e0bffc15 	stw	r2,-16(fp)
 400f894:	e0fffc17 	ldw	r3,-16(fp)
 400f898:	e0bff317 	ldw	r2,-52(fp)
 400f89c:	18bff836 	bltu	r3,r2,400f880 <__multiply+0xf8>
  xa = a->_x;
 400f8a0:	e0bfed17 	ldw	r2,-76(fp)
 400f8a4:	10800504 	addi	r2,r2,20
 400f8a8:	e0bff315 	stw	r2,-52(fp)
  xae = xa + wa;
 400f8ac:	e0bff617 	ldw	r2,-40(fp)
 400f8b0:	100490ba 	slli	r2,r2,2
 400f8b4:	e0fff317 	ldw	r3,-52(fp)
 400f8b8:	1885883a 	add	r2,r3,r2
 400f8bc:	e0bff215 	stw	r2,-56(fp)
  xb = b->_x;
 400f8c0:	e0bfec17 	ldw	r2,-80(fp)
 400f8c4:	10800504 	addi	r2,r2,20
 400f8c8:	e0bffb15 	stw	r2,-20(fp)
  xbe = xb + wb;
 400f8cc:	e0bff517 	ldw	r2,-44(fp)
 400f8d0:	100490ba 	slli	r2,r2,2
 400f8d4:	e0fffb17 	ldw	r3,-20(fp)
 400f8d8:	1885883a 	add	r2,r3,r2
 400f8dc:	e0bff115 	stw	r2,-60(fp)
  xc0 = c->_x;
 400f8e0:	e0bff717 	ldw	r2,-36(fp)
 400f8e4:	10800504 	addi	r2,r2,20
 400f8e8:	e0bff915 	stw	r2,-28(fp)
#ifdef Pack_32
  for (; xb < xbe; xb++, xc0++)
 400f8ec:	00008506 	br	400fb04 <__multiply+0x37c>
    {
      if ((y = *xb & 0xffff) != 0)
 400f8f0:	e0bffb17 	ldw	r2,-20(fp)
 400f8f4:	10800017 	ldw	r2,0(r2)
 400f8f8:	10bfffcc 	andi	r2,r2,65535
 400f8fc:	e0bff015 	stw	r2,-64(fp)
 400f900:	e0bff017 	ldw	r2,-64(fp)
 400f904:	10003826 	beq	r2,zero,400f9e8 <__multiply+0x260>
	{
	  x = xa;
 400f908:	e0bff317 	ldw	r2,-52(fp)
 400f90c:	e0bffc15 	stw	r2,-16(fp)
	  xc = xc0;
 400f910:	e0bff917 	ldw	r2,-28(fp)
 400f914:	e0bffa15 	stw	r2,-24(fp)
	  carry = 0;
 400f918:	e03ffd15 	stw	zero,-12(fp)
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
 400f91c:	e0bffc17 	ldw	r2,-16(fp)
 400f920:	10800017 	ldw	r2,0(r2)
 400f924:	10bfffcc 	andi	r2,r2,65535
 400f928:	e17ff017 	ldw	r5,-64(fp)
 400f92c:	1009883a 	mov	r4,r2
 400f930:	40072d80 	call	40072d8 <__mulsi3>
 400f934:	1007883a 	mov	r3,r2
 400f938:	e0bffa17 	ldw	r2,-24(fp)
 400f93c:	10800017 	ldw	r2,0(r2)
 400f940:	10bfffcc 	andi	r2,r2,65535
 400f944:	1885883a 	add	r2,r3,r2
 400f948:	e0fffd17 	ldw	r3,-12(fp)
 400f94c:	1885883a 	add	r2,r3,r2
 400f950:	e0bfef15 	stw	r2,-68(fp)
	      carry = z >> 16;
 400f954:	e0bfef17 	ldw	r2,-68(fp)
 400f958:	1004d43a 	srli	r2,r2,16
 400f95c:	e0bffd15 	stw	r2,-12(fp)
	      z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;
 400f960:	e0bffc17 	ldw	r2,-16(fp)
 400f964:	10c00104 	addi	r3,r2,4
 400f968:	e0fffc15 	stw	r3,-16(fp)
 400f96c:	10800017 	ldw	r2,0(r2)
 400f970:	1004d43a 	srli	r2,r2,16
 400f974:	e17ff017 	ldw	r5,-64(fp)
 400f978:	1009883a 	mov	r4,r2
 400f97c:	40072d80 	call	40072d8 <__mulsi3>
 400f980:	1007883a 	mov	r3,r2
 400f984:	e0bffa17 	ldw	r2,-24(fp)
 400f988:	10800017 	ldw	r2,0(r2)
 400f98c:	1004d43a 	srli	r2,r2,16
 400f990:	1885883a 	add	r2,r3,r2
 400f994:	e0fffd17 	ldw	r3,-12(fp)
 400f998:	1885883a 	add	r2,r3,r2
 400f99c:	e0bff815 	stw	r2,-32(fp)
	      carry = z2 >> 16;
 400f9a0:	e0bff817 	ldw	r2,-32(fp)
 400f9a4:	1004d43a 	srli	r2,r2,16
 400f9a8:	e0bffd15 	stw	r2,-12(fp)
	      Storeinc (xc, z2, z);
 400f9ac:	e0bff817 	ldw	r2,-32(fp)
 400f9b0:	1008943a 	slli	r4,r2,16
 400f9b4:	e0bfef17 	ldw	r2,-68(fp)
 400f9b8:	10ffffcc 	andi	r3,r2,65535
 400f9bc:	e0bffa17 	ldw	r2,-24(fp)
 400f9c0:	11400104 	addi	r5,r2,4
 400f9c4:	e17ffa15 	stw	r5,-24(fp)
 400f9c8:	20c6b03a 	or	r3,r4,r3
 400f9cc:	10c00015 	stw	r3,0(r2)
	    }
	  while (x < xae);
 400f9d0:	e0fffc17 	ldw	r3,-16(fp)
 400f9d4:	e0bff217 	ldw	r2,-56(fp)
 400f9d8:	18bfd036 	bltu	r3,r2,400f91c <__multiply+0x194>
	  *xc = carry;
 400f9dc:	e0bffa17 	ldw	r2,-24(fp)
 400f9e0:	e0fffd17 	ldw	r3,-12(fp)
 400f9e4:	10c00015 	stw	r3,0(r2)
	}
      if ((y = *xb >> 16) != 0)
 400f9e8:	e0bffb17 	ldw	r2,-20(fp)
 400f9ec:	10800017 	ldw	r2,0(r2)
 400f9f0:	1004d43a 	srli	r2,r2,16
 400f9f4:	e0bff015 	stw	r2,-64(fp)
 400f9f8:	e0bff017 	ldw	r2,-64(fp)
 400f9fc:	10003b26 	beq	r2,zero,400faec <__multiply+0x364>
	{
	  x = xa;
 400fa00:	e0bff317 	ldw	r2,-52(fp)
 400fa04:	e0bffc15 	stw	r2,-16(fp)
	  xc = xc0;
 400fa08:	e0bff917 	ldw	r2,-28(fp)
 400fa0c:	e0bffa15 	stw	r2,-24(fp)
	  carry = 0;
 400fa10:	e03ffd15 	stw	zero,-12(fp)
	  z2 = *xc;
 400fa14:	e0bffa17 	ldw	r2,-24(fp)
 400fa18:	10800017 	ldw	r2,0(r2)
 400fa1c:	e0bff815 	stw	r2,-32(fp)
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc >> 16) + carry;
 400fa20:	e0bffc17 	ldw	r2,-16(fp)
 400fa24:	10800017 	ldw	r2,0(r2)
 400fa28:	10bfffcc 	andi	r2,r2,65535
 400fa2c:	e17ff017 	ldw	r5,-64(fp)
 400fa30:	1009883a 	mov	r4,r2
 400fa34:	40072d80 	call	40072d8 <__mulsi3>
 400fa38:	1007883a 	mov	r3,r2
 400fa3c:	e0bffa17 	ldw	r2,-24(fp)
 400fa40:	10800017 	ldw	r2,0(r2)
 400fa44:	1004d43a 	srli	r2,r2,16
 400fa48:	1885883a 	add	r2,r3,r2
 400fa4c:	e0fffd17 	ldw	r3,-12(fp)
 400fa50:	1885883a 	add	r2,r3,r2
 400fa54:	e0bfef15 	stw	r2,-68(fp)
	      carry = z >> 16;
 400fa58:	e0bfef17 	ldw	r2,-68(fp)
 400fa5c:	1004d43a 	srli	r2,r2,16
 400fa60:	e0bffd15 	stw	r2,-12(fp)
	      Storeinc (xc, z, z2);
 400fa64:	e0bfef17 	ldw	r2,-68(fp)
 400fa68:	1008943a 	slli	r4,r2,16
 400fa6c:	e0bff817 	ldw	r2,-32(fp)
 400fa70:	10ffffcc 	andi	r3,r2,65535
 400fa74:	e0bffa17 	ldw	r2,-24(fp)
 400fa78:	11400104 	addi	r5,r2,4
 400fa7c:	e17ffa15 	stw	r5,-24(fp)
 400fa80:	20c6b03a 	or	r3,r4,r3
 400fa84:	10c00015 	stw	r3,0(r2)
	      z2 = (*x++ >> 16) * y + (*xc & 0xffff) + carry;
 400fa88:	e0bffc17 	ldw	r2,-16(fp)
 400fa8c:	10c00104 	addi	r3,r2,4
 400fa90:	e0fffc15 	stw	r3,-16(fp)
 400fa94:	10800017 	ldw	r2,0(r2)
 400fa98:	1004d43a 	srli	r2,r2,16
 400fa9c:	e17ff017 	ldw	r5,-64(fp)
 400faa0:	1009883a 	mov	r4,r2
 400faa4:	40072d80 	call	40072d8 <__mulsi3>
 400faa8:	1007883a 	mov	r3,r2
 400faac:	e0bffa17 	ldw	r2,-24(fp)
 400fab0:	10800017 	ldw	r2,0(r2)
 400fab4:	10bfffcc 	andi	r2,r2,65535
 400fab8:	1885883a 	add	r2,r3,r2
 400fabc:	e0fffd17 	ldw	r3,-12(fp)
 400fac0:	1885883a 	add	r2,r3,r2
 400fac4:	e0bff815 	stw	r2,-32(fp)
	      carry = z2 >> 16;
 400fac8:	e0bff817 	ldw	r2,-32(fp)
 400facc:	1004d43a 	srli	r2,r2,16
 400fad0:	e0bffd15 	stw	r2,-12(fp)
	    }
	  while (x < xae);
 400fad4:	e0fffc17 	ldw	r3,-16(fp)
 400fad8:	e0bff217 	ldw	r2,-56(fp)
 400fadc:	18bfd036 	bltu	r3,r2,400fa20 <__multiply+0x298>
	  *xc = z2;
 400fae0:	e0bffa17 	ldw	r2,-24(fp)
 400fae4:	e0fff817 	ldw	r3,-32(fp)
 400fae8:	10c00015 	stw	r3,0(r2)
  for (; xb < xbe; xb++, xc0++)
 400faec:	e0bffb17 	ldw	r2,-20(fp)
 400faf0:	10800104 	addi	r2,r2,4
 400faf4:	e0bffb15 	stw	r2,-20(fp)
 400faf8:	e0bff917 	ldw	r2,-28(fp)
 400fafc:	10800104 	addi	r2,r2,4
 400fb00:	e0bff915 	stw	r2,-28(fp)
 400fb04:	e0fffb17 	ldw	r3,-20(fp)
 400fb08:	e0bff117 	ldw	r2,-60(fp)
 400fb0c:	18bf7836 	bltu	r3,r2,400f8f0 <__multiply+0x168>
	  while (x < xae);
	  *xc = carry;
	}
    }
#endif
  for (xc0 = c->_x, xc = xc0 + wc; wc > 0 && !*--xc; --wc);
 400fb10:	e0bff717 	ldw	r2,-36(fp)
 400fb14:	10800504 	addi	r2,r2,20
 400fb18:	e0bff915 	stw	r2,-28(fp)
 400fb1c:	e0bffe17 	ldw	r2,-8(fp)
 400fb20:	100490ba 	slli	r2,r2,2
 400fb24:	e0fff917 	ldw	r3,-28(fp)
 400fb28:	1885883a 	add	r2,r3,r2
 400fb2c:	e0bffa15 	stw	r2,-24(fp)
 400fb30:	00000306 	br	400fb40 <__multiply+0x3b8>
 400fb34:	e0bffe17 	ldw	r2,-8(fp)
 400fb38:	10bfffc4 	addi	r2,r2,-1
 400fb3c:	e0bffe15 	stw	r2,-8(fp)
 400fb40:	e0bffe17 	ldw	r2,-8(fp)
 400fb44:	0080060e 	bge	zero,r2,400fb60 <__multiply+0x3d8>
 400fb48:	e0bffa17 	ldw	r2,-24(fp)
 400fb4c:	10bfff04 	addi	r2,r2,-4
 400fb50:	e0bffa15 	stw	r2,-24(fp)
 400fb54:	e0bffa17 	ldw	r2,-24(fp)
 400fb58:	10800017 	ldw	r2,0(r2)
 400fb5c:	103ff526 	beq	r2,zero,400fb34 <__multiply+0x3ac>
  c->_wds = wc;
 400fb60:	e0bff717 	ldw	r2,-36(fp)
 400fb64:	e0fffe17 	ldw	r3,-8(fp)
 400fb68:	10c00415 	stw	r3,16(r2)
  return c;
 400fb6c:	e0bff717 	ldw	r2,-36(fp)
}
 400fb70:	e037883a 	mov	sp,fp
 400fb74:	dfc00117 	ldw	ra,4(sp)
 400fb78:	df000017 	ldw	fp,0(sp)
 400fb7c:	dec00204 	addi	sp,sp,8
 400fb80:	f800283a 	ret

0400fb84 <__pow5mult>:

_Bigint *
pow5mult (struct _reent * ptr, _Bigint * b, int k)
{
 400fb84:	defff704 	addi	sp,sp,-36
 400fb88:	dfc00815 	stw	ra,32(sp)
 400fb8c:	df000715 	stw	fp,28(sp)
 400fb90:	df000704 	addi	fp,sp,28
 400fb94:	e13ffb15 	stw	r4,-20(fp)
 400fb98:	e17ffa15 	stw	r5,-24(fp)
 400fb9c:	e1bff915 	stw	r6,-28(fp)
  _Bigint *b1, *p5, *p51;
  int i;
  static const int p05[3] = {5, 25, 125};

  if ((i = k & 3) != 0)
 400fba0:	e0bff917 	ldw	r2,-28(fp)
 400fba4:	108000cc 	andi	r2,r2,3
 400fba8:	e0bffd15 	stw	r2,-12(fp)
 400fbac:	e0bffd17 	ldw	r2,-12(fp)
 400fbb0:	10000c26 	beq	r2,zero,400fbe4 <__pow5mult+0x60>
    b = multadd (ptr, b, p05[i - 1], 0);
 400fbb4:	e0bffd17 	ldw	r2,-12(fp)
 400fbb8:	10bfffc4 	addi	r2,r2,-1
 400fbbc:	100690ba 	slli	r3,r2,2
 400fbc0:	008100b4 	movhi	r2,1026
 400fbc4:	1885883a 	add	r2,r3,r2
 400fbc8:	10ab6317 	ldw	r2,-21108(r2)
 400fbcc:	000f883a 	mov	r7,zero
 400fbd0:	100d883a 	mov	r6,r2
 400fbd4:	e17ffa17 	ldw	r5,-24(fp)
 400fbd8:	e13ffb17 	ldw	r4,-20(fp)
 400fbdc:	400f2040 	call	400f204 <__multadd>
 400fbe0:	e0bffa15 	stw	r2,-24(fp)

  if (!(k >>= 2))
 400fbe4:	e0bff917 	ldw	r2,-28(fp)
 400fbe8:	1005d0ba 	srai	r2,r2,2
 400fbec:	e0bff915 	stw	r2,-28(fp)
 400fbf0:	e0bff917 	ldw	r2,-28(fp)
 400fbf4:	1000021e 	bne	r2,zero,400fc00 <__pow5mult+0x7c>
    return b;
 400fbf8:	e0bffa17 	ldw	r2,-24(fp)
 400fbfc:	00003806 	br	400fce0 <__pow5mult+0x15c>
  _REENT_CHECK_MP(ptr);
  if (!(p5 = _REENT_MP_P5S(ptr)))
 400fc00:	e0bffb17 	ldw	r2,-20(fp)
 400fc04:	10801217 	ldw	r2,72(r2)
 400fc08:	e0bfff15 	stw	r2,-4(fp)
 400fc0c:	e0bfff17 	ldw	r2,-4(fp)
 400fc10:	10000b1e 	bne	r2,zero,400fc40 <__pow5mult+0xbc>
    {
      /* first time */
      p5 = _REENT_MP_P5S(ptr) = i2b (ptr, 625);
 400fc14:	01409c44 	movi	r5,625
 400fc18:	e13ffb17 	ldw	r4,-20(fp)
 400fc1c:	400f7040 	call	400f704 <__i2b>
 400fc20:	1007883a 	mov	r3,r2
 400fc24:	e0bffb17 	ldw	r2,-20(fp)
 400fc28:	10c01215 	stw	r3,72(r2)
 400fc2c:	e0bffb17 	ldw	r2,-20(fp)
 400fc30:	10801217 	ldw	r2,72(r2)
 400fc34:	e0bfff15 	stw	r2,-4(fp)
      p5->_next = 0;
 400fc38:	e0bfff17 	ldw	r2,-4(fp)
 400fc3c:	10000015 	stw	zero,0(r2)
    }
  for (;;)
    {
      if (k & 1)
 400fc40:	e0bff917 	ldw	r2,-28(fp)
 400fc44:	1080004c 	andi	r2,r2,1
 400fc48:	10000a26 	beq	r2,zero,400fc74 <__pow5mult+0xf0>
	{
	  b1 = mult (ptr, b, p5);
 400fc4c:	e1bfff17 	ldw	r6,-4(fp)
 400fc50:	e17ffa17 	ldw	r5,-24(fp)
 400fc54:	e13ffb17 	ldw	r4,-20(fp)
 400fc58:	400f7880 	call	400f788 <__multiply>
 400fc5c:	e0bffc15 	stw	r2,-16(fp)
	  Bfree (ptr, b);
 400fc60:	e17ffa17 	ldw	r5,-24(fp)
 400fc64:	e13ffb17 	ldw	r4,-20(fp)
 400fc68:	400f1900 	call	400f190 <_Bfree>
	  b = b1;
 400fc6c:	e0bffc17 	ldw	r2,-16(fp)
 400fc70:	e0bffa15 	stw	r2,-24(fp)
	}
      if (!(k >>= 1))
 400fc74:	e0bff917 	ldw	r2,-28(fp)
 400fc78:	1005d07a 	srai	r2,r2,1
 400fc7c:	e0bff915 	stw	r2,-28(fp)
 400fc80:	e0bff917 	ldw	r2,-28(fp)
 400fc84:	10001426 	beq	r2,zero,400fcd8 <__pow5mult+0x154>
	break;
      if (!(p51 = p5->_next))
 400fc88:	e0bfff17 	ldw	r2,-4(fp)
 400fc8c:	10800017 	ldw	r2,0(r2)
 400fc90:	e0bffe15 	stw	r2,-8(fp)
 400fc94:	e0bffe17 	ldw	r2,-8(fp)
 400fc98:	10000c1e 	bne	r2,zero,400fccc <__pow5mult+0x148>
	{
	  p51 = p5->_next = mult (ptr, p5, p5);
 400fc9c:	e1bfff17 	ldw	r6,-4(fp)
 400fca0:	e17fff17 	ldw	r5,-4(fp)
 400fca4:	e13ffb17 	ldw	r4,-20(fp)
 400fca8:	400f7880 	call	400f788 <__multiply>
 400fcac:	1007883a 	mov	r3,r2
 400fcb0:	e0bfff17 	ldw	r2,-4(fp)
 400fcb4:	10c00015 	stw	r3,0(r2)
 400fcb8:	e0bfff17 	ldw	r2,-4(fp)
 400fcbc:	10800017 	ldw	r2,0(r2)
 400fcc0:	e0bffe15 	stw	r2,-8(fp)
	  p51->_next = 0;
 400fcc4:	e0bffe17 	ldw	r2,-8(fp)
 400fcc8:	10000015 	stw	zero,0(r2)
	}
      p5 = p51;
 400fccc:	e0bffe17 	ldw	r2,-8(fp)
 400fcd0:	e0bfff15 	stw	r2,-4(fp)
      if (k & 1)
 400fcd4:	003fda06 	br	400fc40 <__pow5mult+0xbc>
	break;
 400fcd8:	0001883a 	nop
    }
  return b;
 400fcdc:	e0bffa17 	ldw	r2,-24(fp)
}
 400fce0:	e037883a 	mov	sp,fp
 400fce4:	dfc00117 	ldw	ra,4(sp)
 400fce8:	df000017 	ldw	fp,0(sp)
 400fcec:	dec00204 	addi	sp,sp,8
 400fcf0:	f800283a 	ret

0400fcf4 <__lshift>:

_Bigint *
lshift (struct _reent * ptr, _Bigint * b, int k)
{
 400fcf4:	defff104 	addi	sp,sp,-60
 400fcf8:	dfc00e15 	stw	ra,56(sp)
 400fcfc:	df000d15 	stw	fp,52(sp)
 400fd00:	df000d04 	addi	fp,sp,52
 400fd04:	e13ff515 	stw	r4,-44(fp)
 400fd08:	e17ff415 	stw	r5,-48(fp)
 400fd0c:	e1bff315 	stw	r6,-52(fp)
  int i, k1, n, n1;
  _Bigint *b1;
  __ULong *x, *x1, *xe, z;

#ifdef Pack_32
  n = k >> 5;
 400fd10:	e0bff317 	ldw	r2,-52(fp)
 400fd14:	1005d17a 	srai	r2,r2,5
 400fd18:	e0bff915 	stw	r2,-28(fp)
#else
  n = k >> 4;
#endif
  k1 = b->_k;
 400fd1c:	e0bff417 	ldw	r2,-48(fp)
 400fd20:	10800117 	ldw	r2,4(r2)
 400fd24:	e0bffe15 	stw	r2,-8(fp)
  n1 = n + b->_wds + 1;
 400fd28:	e0bff417 	ldw	r2,-48(fp)
 400fd2c:	10c00417 	ldw	r3,16(r2)
 400fd30:	e0bff917 	ldw	r2,-28(fp)
 400fd34:	1885883a 	add	r2,r3,r2
 400fd38:	10800044 	addi	r2,r2,1
 400fd3c:	e0bffd15 	stw	r2,-12(fp)
  for (i = b->_maxwds; n1 > i; i <<= 1)
 400fd40:	e0bff417 	ldw	r2,-48(fp)
 400fd44:	10800217 	ldw	r2,8(r2)
 400fd48:	e0bfff15 	stw	r2,-4(fp)
 400fd4c:	00000606 	br	400fd68 <__lshift+0x74>
    k1++;
 400fd50:	e0bffe17 	ldw	r2,-8(fp)
 400fd54:	10800044 	addi	r2,r2,1
 400fd58:	e0bffe15 	stw	r2,-8(fp)
  for (i = b->_maxwds; n1 > i; i <<= 1)
 400fd5c:	e0bfff17 	ldw	r2,-4(fp)
 400fd60:	1085883a 	add	r2,r2,r2
 400fd64:	e0bfff15 	stw	r2,-4(fp)
 400fd68:	e0bffd17 	ldw	r2,-12(fp)
 400fd6c:	e0ffff17 	ldw	r3,-4(fp)
 400fd70:	18bff716 	blt	r3,r2,400fd50 <__lshift+0x5c>
  b1 = eBalloc (ptr, k1);
 400fd74:	e17ffe17 	ldw	r5,-8(fp)
 400fd78:	e13ff517 	ldw	r4,-44(fp)
 400fd7c:	400f06c0 	call	400f06c <_Balloc>
 400fd80:	e0bff815 	stw	r2,-32(fp)
 400fd84:	e0bff817 	ldw	r2,-32(fp)
 400fd88:	1000071e 	bne	r2,zero,400fda8 <__lshift+0xb4>
 400fd8c:	01c100b4 	movhi	r7,1026
 400fd90:	39eb0104 	addi	r7,r7,-21500
 400fd94:	000d883a 	mov	r6,zero
 400fd98:	01407644 	movi	r5,473
 400fd9c:	010100b4 	movhi	r4,1026
 400fda0:	212b0604 	addi	r4,r4,-21480
 400fda4:	40130ac0 	call	40130ac <__assert_func>
 400fda8:	e0bff817 	ldw	r2,-32(fp)
 400fdac:	e0bff715 	stw	r2,-36(fp)
  x1 = b1->_x;
 400fdb0:	e0bff717 	ldw	r2,-36(fp)
 400fdb4:	10800504 	addi	r2,r2,20
 400fdb8:	e0bffb15 	stw	r2,-20(fp)
  for (i = 0; i < n; i++)
 400fdbc:	e03fff15 	stw	zero,-4(fp)
 400fdc0:	00000706 	br	400fde0 <__lshift+0xec>
    *x1++ = 0;
 400fdc4:	e0bffb17 	ldw	r2,-20(fp)
 400fdc8:	10c00104 	addi	r3,r2,4
 400fdcc:	e0fffb15 	stw	r3,-20(fp)
 400fdd0:	10000015 	stw	zero,0(r2)
  for (i = 0; i < n; i++)
 400fdd4:	e0bfff17 	ldw	r2,-4(fp)
 400fdd8:	10800044 	addi	r2,r2,1
 400fddc:	e0bfff15 	stw	r2,-4(fp)
 400fde0:	e0ffff17 	ldw	r3,-4(fp)
 400fde4:	e0bff917 	ldw	r2,-28(fp)
 400fde8:	18bff616 	blt	r3,r2,400fdc4 <__lshift+0xd0>
  x = b->_x;
 400fdec:	e0bff417 	ldw	r2,-48(fp)
 400fdf0:	10800504 	addi	r2,r2,20
 400fdf4:	e0bffc15 	stw	r2,-16(fp)
  xe = x + b->_wds;
 400fdf8:	e0bff417 	ldw	r2,-48(fp)
 400fdfc:	10800417 	ldw	r2,16(r2)
 400fe00:	100490ba 	slli	r2,r2,2
 400fe04:	e0fffc17 	ldw	r3,-16(fp)
 400fe08:	1885883a 	add	r2,r3,r2
 400fe0c:	e0bff615 	stw	r2,-40(fp)
#ifdef Pack_32
  if (k &= 0x1f)
 400fe10:	e0bff317 	ldw	r2,-52(fp)
 400fe14:	108007cc 	andi	r2,r2,31
 400fe18:	e0bff315 	stw	r2,-52(fp)
 400fe1c:	e0bff317 	ldw	r2,-52(fp)
 400fe20:	10002326 	beq	r2,zero,400feb0 <__lshift+0x1bc>
    {
      k1 = 32 - k;
 400fe24:	00c00804 	movi	r3,32
 400fe28:	e0bff317 	ldw	r2,-52(fp)
 400fe2c:	1885c83a 	sub	r2,r3,r2
 400fe30:	e0bffe15 	stw	r2,-8(fp)
      z = 0;
 400fe34:	e03ffa15 	stw	zero,-24(fp)
      do
	{
	  *x1++ = *x << k | z;
 400fe38:	e0bffc17 	ldw	r2,-16(fp)
 400fe3c:	10c00017 	ldw	r3,0(r2)
 400fe40:	e0bff317 	ldw	r2,-52(fp)
 400fe44:	1888983a 	sll	r4,r3,r2
 400fe48:	e0bffb17 	ldw	r2,-20(fp)
 400fe4c:	10c00104 	addi	r3,r2,4
 400fe50:	e0fffb15 	stw	r3,-20(fp)
 400fe54:	e0fffa17 	ldw	r3,-24(fp)
 400fe58:	20c6b03a 	or	r3,r4,r3
 400fe5c:	10c00015 	stw	r3,0(r2)
	  z = *x++ >> k1;
 400fe60:	e0bffc17 	ldw	r2,-16(fp)
 400fe64:	10c00104 	addi	r3,r2,4
 400fe68:	e0fffc15 	stw	r3,-16(fp)
 400fe6c:	10c00017 	ldw	r3,0(r2)
 400fe70:	e0bffe17 	ldw	r2,-8(fp)
 400fe74:	1884d83a 	srl	r2,r3,r2
 400fe78:	e0bffa15 	stw	r2,-24(fp)
	}
      while (x < xe);
 400fe7c:	e0fffc17 	ldw	r3,-16(fp)
 400fe80:	e0bff617 	ldw	r2,-40(fp)
 400fe84:	18bfec36 	bltu	r3,r2,400fe38 <__lshift+0x144>
      if ((*x1 = z) != 0)
 400fe88:	e0bffb17 	ldw	r2,-20(fp)
 400fe8c:	e0fffa17 	ldw	r3,-24(fp)
 400fe90:	10c00015 	stw	r3,0(r2)
 400fe94:	e0bffb17 	ldw	r2,-20(fp)
 400fe98:	10800017 	ldw	r2,0(r2)
 400fe9c:	10000f26 	beq	r2,zero,400fedc <__lshift+0x1e8>
	++n1;
 400fea0:	e0bffd17 	ldw	r2,-12(fp)
 400fea4:	10800044 	addi	r2,r2,1
 400fea8:	e0bffd15 	stw	r2,-12(fp)
 400feac:	00000b06 	br	400fedc <__lshift+0x1e8>
	++n1;
    }
#endif
  else
    do
      *x1++ = *x++;
 400feb0:	e0fffc17 	ldw	r3,-16(fp)
 400feb4:	18800104 	addi	r2,r3,4
 400feb8:	e0bffc15 	stw	r2,-16(fp)
 400febc:	e0bffb17 	ldw	r2,-20(fp)
 400fec0:	11000104 	addi	r4,r2,4
 400fec4:	e13ffb15 	stw	r4,-20(fp)
 400fec8:	18c00017 	ldw	r3,0(r3)
 400fecc:	10c00015 	stw	r3,0(r2)
    while (x < xe);
 400fed0:	e0fffc17 	ldw	r3,-16(fp)
 400fed4:	e0bff617 	ldw	r2,-40(fp)
 400fed8:	18bff536 	bltu	r3,r2,400feb0 <__lshift+0x1bc>
  b1->_wds = n1 - 1;
 400fedc:	e0bffd17 	ldw	r2,-12(fp)
 400fee0:	10ffffc4 	addi	r3,r2,-1
 400fee4:	e0bff717 	ldw	r2,-36(fp)
 400fee8:	10c00415 	stw	r3,16(r2)
  Bfree (ptr, b);
 400feec:	e17ff417 	ldw	r5,-48(fp)
 400fef0:	e13ff517 	ldw	r4,-44(fp)
 400fef4:	400f1900 	call	400f190 <_Bfree>
  return b1;
 400fef8:	e0bff717 	ldw	r2,-36(fp)
}
 400fefc:	e037883a 	mov	sp,fp
 400ff00:	dfc00117 	ldw	ra,4(sp)
 400ff04:	df000017 	ldw	fp,0(sp)
 400ff08:	dec00204 	addi	sp,sp,8
 400ff0c:	f800283a 	ret

0400ff10 <__mcmp>:

int
cmp (_Bigint * a, _Bigint * b)
{
 400ff10:	defff704 	addi	sp,sp,-36
 400ff14:	df000815 	stw	fp,32(sp)
 400ff18:	df000804 	addi	fp,sp,32
 400ff1c:	e13ff915 	stw	r4,-28(fp)
 400ff20:	e17ff815 	stw	r5,-32(fp)
  __ULong *xa, *xa0, *xb, *xb0;
  int i, j;

  i = a->_wds;
 400ff24:	e0bff917 	ldw	r2,-28(fp)
 400ff28:	10800417 	ldw	r2,16(r2)
 400ff2c:	e0bffd15 	stw	r2,-12(fp)
  j = b->_wds;
 400ff30:	e0bff817 	ldw	r2,-32(fp)
 400ff34:	10800417 	ldw	r2,16(r2)
 400ff38:	e0bffc15 	stw	r2,-16(fp)
  if (i > 1 && !a->_x[i - 1])
    Bug ("cmp called with a->_x[a->_wds-1] == 0");
  if (j > 1 && !b->_x[j - 1])
    Bug ("cmp called with b->_x[b->_wds-1] == 0");
#endif
  if (i -= j)
 400ff3c:	e0fffd17 	ldw	r3,-12(fp)
 400ff40:	e0bffc17 	ldw	r2,-16(fp)
 400ff44:	1885c83a 	sub	r2,r3,r2
 400ff48:	e0bffd15 	stw	r2,-12(fp)
 400ff4c:	e0bffd17 	ldw	r2,-12(fp)
 400ff50:	10000226 	beq	r2,zero,400ff5c <__mcmp+0x4c>
    return i;
 400ff54:	e0bffd17 	ldw	r2,-12(fp)
 400ff58:	00002a06 	br	4010004 <__mcmp+0xf4>
  xa0 = a->_x;
 400ff5c:	e0bff917 	ldw	r2,-28(fp)
 400ff60:	10800504 	addi	r2,r2,20
 400ff64:	e0bffb15 	stw	r2,-20(fp)
  xa = xa0 + j;
 400ff68:	e0bffc17 	ldw	r2,-16(fp)
 400ff6c:	100490ba 	slli	r2,r2,2
 400ff70:	e0fffb17 	ldw	r3,-20(fp)
 400ff74:	1885883a 	add	r2,r3,r2
 400ff78:	e0bfff15 	stw	r2,-4(fp)
  xb0 = b->_x;
 400ff7c:	e0bff817 	ldw	r2,-32(fp)
 400ff80:	10800504 	addi	r2,r2,20
 400ff84:	e0bffa15 	stw	r2,-24(fp)
  xb = xb0 + j;
 400ff88:	e0bffc17 	ldw	r2,-16(fp)
 400ff8c:	100490ba 	slli	r2,r2,2
 400ff90:	e0fffa17 	ldw	r3,-24(fp)
 400ff94:	1885883a 	add	r2,r3,r2
 400ff98:	e0bffe15 	stw	r2,-8(fp)
  for (;;)
    {
      if (*--xa != *--xb)
 400ff9c:	e0bfff17 	ldw	r2,-4(fp)
 400ffa0:	10bfff04 	addi	r2,r2,-4
 400ffa4:	e0bfff15 	stw	r2,-4(fp)
 400ffa8:	e0bfff17 	ldw	r2,-4(fp)
 400ffac:	10c00017 	ldw	r3,0(r2)
 400ffb0:	e0bffe17 	ldw	r2,-8(fp)
 400ffb4:	10bfff04 	addi	r2,r2,-4
 400ffb8:	e0bffe15 	stw	r2,-8(fp)
 400ffbc:	e0bffe17 	ldw	r2,-8(fp)
 400ffc0:	10800017 	ldw	r2,0(r2)
 400ffc4:	18800926 	beq	r3,r2,400ffec <__mcmp+0xdc>
	return *xa < *xb ? -1 : 1;
 400ffc8:	e0bfff17 	ldw	r2,-4(fp)
 400ffcc:	10c00017 	ldw	r3,0(r2)
 400ffd0:	e0bffe17 	ldw	r2,-8(fp)
 400ffd4:	10800017 	ldw	r2,0(r2)
 400ffd8:	1880022e 	bgeu	r3,r2,400ffe4 <__mcmp+0xd4>
 400ffdc:	00bfffc4 	movi	r2,-1
 400ffe0:	00000806 	br	4010004 <__mcmp+0xf4>
 400ffe4:	00800044 	movi	r2,1
 400ffe8:	00000606 	br	4010004 <__mcmp+0xf4>
      if (xa <= xa0)
 400ffec:	e0bfff17 	ldw	r2,-4(fp)
 400fff0:	e0fffb17 	ldw	r3,-20(fp)
 400fff4:	1880012e 	bgeu	r3,r2,400fffc <__mcmp+0xec>
      if (*--xa != *--xb)
 400fff8:	003fe806 	br	400ff9c <__mcmp+0x8c>
	break;
 400fffc:	0001883a 	nop
    }
  return 0;
 4010000:	0005883a 	mov	r2,zero
}
 4010004:	e037883a 	mov	sp,fp
 4010008:	df000017 	ldw	fp,0(sp)
 401000c:	dec00104 	addi	sp,sp,4
 4010010:	f800283a 	ret

04010014 <__mdiff>:

_Bigint *
diff (struct _reent * ptr,
	_Bigint * a, _Bigint * b)
{
 4010014:	deffed04 	addi	sp,sp,-76
 4010018:	dfc01215 	stw	ra,72(sp)
 401001c:	df001115 	stw	fp,68(sp)
 4010020:	df001104 	addi	fp,sp,68
 4010024:	e13ff115 	stw	r4,-60(fp)
 4010028:	e17ff015 	stw	r5,-64(fp)
 401002c:	e1bfef15 	stw	r6,-68(fp)
  __ULong *xa, *xae, *xb, *xbe, *xc;
#ifdef Pack_32
  __Long z;
#endif

  i = cmp (a, b);
 4010030:	e17fef17 	ldw	r5,-68(fp)
 4010034:	e13ff017 	ldw	r4,-64(fp)
 4010038:	400ff100 	call	400ff10 <__mcmp>
 401003c:	e0bfff15 	stw	r2,-4(fp)
  if (!i)
 4010040:	e0bfff17 	ldw	r2,-4(fp)
 4010044:	1000161e 	bne	r2,zero,40100a0 <__mdiff+0x8c>
    {
      c = eBalloc (ptr, 0);
 4010048:	000b883a 	mov	r5,zero
 401004c:	e13ff117 	ldw	r4,-60(fp)
 4010050:	400f06c0 	call	400f06c <_Balloc>
 4010054:	e0bff215 	stw	r2,-56(fp)
 4010058:	e0bff217 	ldw	r2,-56(fp)
 401005c:	1000071e 	bne	r2,zero,401007c <__mdiff+0x68>
 4010060:	01c100b4 	movhi	r7,1026
 4010064:	39eb0104 	addi	r7,r7,-21500
 4010068:	000d883a 	mov	r6,zero
 401006c:	01408c84 	movi	r5,562
 4010070:	010100b4 	movhi	r4,1026
 4010074:	212b0604 	addi	r4,r4,-21480
 4010078:	40130ac0 	call	40130ac <__assert_func>
 401007c:	e0bff217 	ldw	r2,-56(fp)
 4010080:	e0bff915 	stw	r2,-28(fp)
      c->_wds = 1;
 4010084:	e0bff917 	ldw	r2,-28(fp)
 4010088:	00c00044 	movi	r3,1
 401008c:	10c00415 	stw	r3,16(r2)
      c->_x[0] = 0;
 4010090:	e0bff917 	ldw	r2,-28(fp)
 4010094:	10000515 	stw	zero,20(r2)
      return c;
 4010098:	e0bff917 	ldw	r2,-28(fp)
 401009c:	00009506 	br	40102f4 <__mdiff+0x2e0>
    }
  if (i < 0)
 40100a0:	e0bfff17 	ldw	r2,-4(fp)
 40100a4:	1000090e 	bge	r2,zero,40100cc <__mdiff+0xb8>
    {
      c = a;
 40100a8:	e0bff017 	ldw	r2,-64(fp)
 40100ac:	e0bff915 	stw	r2,-28(fp)
      a = b;
 40100b0:	e0bfef17 	ldw	r2,-68(fp)
 40100b4:	e0bff015 	stw	r2,-64(fp)
      b = c;
 40100b8:	e0bff917 	ldw	r2,-28(fp)
 40100bc:	e0bfef15 	stw	r2,-68(fp)
      i = 1;
 40100c0:	00800044 	movi	r2,1
 40100c4:	e0bfff15 	stw	r2,-4(fp)
 40100c8:	00000106 	br	40100d0 <__mdiff+0xbc>
    }
  else
    i = 0;
 40100cc:	e03fff15 	stw	zero,-4(fp)
  c = eBalloc (ptr, a->_k);
 40100d0:	e0bff017 	ldw	r2,-64(fp)
 40100d4:	10800117 	ldw	r2,4(r2)
 40100d8:	100b883a 	mov	r5,r2
 40100dc:	e13ff117 	ldw	r4,-60(fp)
 40100e0:	400f06c0 	call	400f06c <_Balloc>
 40100e4:	e0bff815 	stw	r2,-32(fp)
 40100e8:	e0bff817 	ldw	r2,-32(fp)
 40100ec:	1000071e 	bne	r2,zero,401010c <__mdiff+0xf8>
 40100f0:	01c100b4 	movhi	r7,1026
 40100f4:	39eb0104 	addi	r7,r7,-21500
 40100f8:	000d883a 	mov	r6,zero
 40100fc:	01409004 	movi	r5,576
 4010100:	010100b4 	movhi	r4,1026
 4010104:	212b0604 	addi	r4,r4,-21480
 4010108:	40130ac0 	call	40130ac <__assert_func>
 401010c:	e0bff817 	ldw	r2,-32(fp)
 4010110:	e0bff915 	stw	r2,-28(fp)
  c->_sign = i;
 4010114:	e0bff917 	ldw	r2,-28(fp)
 4010118:	e0ffff17 	ldw	r3,-4(fp)
 401011c:	10c00315 	stw	r3,12(r2)
  wa = a->_wds;
 4010120:	e0bff017 	ldw	r2,-64(fp)
 4010124:	10800417 	ldw	r2,16(r2)
 4010128:	e0bffe15 	stw	r2,-8(fp)
  xa = a->_x;
 401012c:	e0bff017 	ldw	r2,-64(fp)
 4010130:	10800504 	addi	r2,r2,20
 4010134:	e0bffc15 	stw	r2,-16(fp)
  xae = xa + wa;
 4010138:	e0bffe17 	ldw	r2,-8(fp)
 401013c:	100490ba 	slli	r2,r2,2
 4010140:	e0fffc17 	ldw	r3,-16(fp)
 4010144:	1885883a 	add	r2,r3,r2
 4010148:	e0bff715 	stw	r2,-36(fp)
  wb = b->_wds;
 401014c:	e0bfef17 	ldw	r2,-68(fp)
 4010150:	10800417 	ldw	r2,16(r2)
 4010154:	e0bff615 	stw	r2,-40(fp)
  xb = b->_x;
 4010158:	e0bfef17 	ldw	r2,-68(fp)
 401015c:	10800504 	addi	r2,r2,20
 4010160:	e0bffb15 	stw	r2,-20(fp)
  xbe = xb + wb;
 4010164:	e0bff617 	ldw	r2,-40(fp)
 4010168:	100490ba 	slli	r2,r2,2
 401016c:	e0fffb17 	ldw	r3,-20(fp)
 4010170:	1885883a 	add	r2,r3,r2
 4010174:	e0bff515 	stw	r2,-44(fp)
  xc = c->_x;
 4010178:	e0bff917 	ldw	r2,-28(fp)
 401017c:	10800504 	addi	r2,r2,20
 4010180:	e0bffa15 	stw	r2,-24(fp)
  borrow = 0;
 4010184:	e03ffd15 	stw	zero,-12(fp)
#ifdef Pack_32
  do
    {
      y = (*xa & 0xffff) - (*xb & 0xffff) + borrow;
 4010188:	e0bffc17 	ldw	r2,-16(fp)
 401018c:	10800017 	ldw	r2,0(r2)
 4010190:	10ffffcc 	andi	r3,r2,65535
 4010194:	e0bffb17 	ldw	r2,-20(fp)
 4010198:	10800017 	ldw	r2,0(r2)
 401019c:	10bfffcc 	andi	r2,r2,65535
 40101a0:	1887c83a 	sub	r3,r3,r2
 40101a4:	e0bffd17 	ldw	r2,-12(fp)
 40101a8:	1885883a 	add	r2,r3,r2
 40101ac:	e0bff415 	stw	r2,-48(fp)
      borrow = y >> 16;
 40101b0:	e0bff417 	ldw	r2,-48(fp)
 40101b4:	1005d43a 	srai	r2,r2,16
 40101b8:	e0bffd15 	stw	r2,-12(fp)
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) - (*xb++ >> 16) + borrow;
 40101bc:	e0bffc17 	ldw	r2,-16(fp)
 40101c0:	10c00104 	addi	r3,r2,4
 40101c4:	e0fffc15 	stw	r3,-16(fp)
 40101c8:	10800017 	ldw	r2,0(r2)
 40101cc:	1006d43a 	srli	r3,r2,16
 40101d0:	e0bffb17 	ldw	r2,-20(fp)
 40101d4:	11000104 	addi	r4,r2,4
 40101d8:	e13ffb15 	stw	r4,-20(fp)
 40101dc:	10800017 	ldw	r2,0(r2)
 40101e0:	1004d43a 	srli	r2,r2,16
 40101e4:	1887c83a 	sub	r3,r3,r2
 40101e8:	e0bffd17 	ldw	r2,-12(fp)
 40101ec:	1885883a 	add	r2,r3,r2
 40101f0:	e0bff315 	stw	r2,-52(fp)
      borrow = z >> 16;
 40101f4:	e0bff317 	ldw	r2,-52(fp)
 40101f8:	1005d43a 	srai	r2,r2,16
 40101fc:	e0bffd15 	stw	r2,-12(fp)
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
 4010200:	e0bff317 	ldw	r2,-52(fp)
 4010204:	1006943a 	slli	r3,r2,16
 4010208:	e0bff417 	ldw	r2,-48(fp)
 401020c:	10bfffcc 	andi	r2,r2,65535
 4010210:	1888b03a 	or	r4,r3,r2
 4010214:	e0bffa17 	ldw	r2,-24(fp)
 4010218:	10c00104 	addi	r3,r2,4
 401021c:	e0fffa15 	stw	r3,-24(fp)
 4010220:	2007883a 	mov	r3,r4
 4010224:	10c00015 	stw	r3,0(r2)
    }
  while (xb < xbe);
 4010228:	e0fffb17 	ldw	r3,-20(fp)
 401022c:	e0bff517 	ldw	r2,-44(fp)
 4010230:	18bfd536 	bltu	r3,r2,4010188 <__mdiff+0x174>
  while (xa < xae)
 4010234:	00001e06 	br	40102b0 <__mdiff+0x29c>
    {
      y = (*xa & 0xffff) + borrow;
 4010238:	e0bffc17 	ldw	r2,-16(fp)
 401023c:	10800017 	ldw	r2,0(r2)
 4010240:	10ffffcc 	andi	r3,r2,65535
 4010244:	e0bffd17 	ldw	r2,-12(fp)
 4010248:	1885883a 	add	r2,r3,r2
 401024c:	e0bff415 	stw	r2,-48(fp)
      borrow = y >> 16;
 4010250:	e0bff417 	ldw	r2,-48(fp)
 4010254:	1005d43a 	srai	r2,r2,16
 4010258:	e0bffd15 	stw	r2,-12(fp)
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) + borrow;
 401025c:	e0bffc17 	ldw	r2,-16(fp)
 4010260:	10c00104 	addi	r3,r2,4
 4010264:	e0fffc15 	stw	r3,-16(fp)
 4010268:	10800017 	ldw	r2,0(r2)
 401026c:	1006d43a 	srli	r3,r2,16
 4010270:	e0bffd17 	ldw	r2,-12(fp)
 4010274:	1885883a 	add	r2,r3,r2
 4010278:	e0bff315 	stw	r2,-52(fp)
      borrow = z >> 16;
 401027c:	e0bff317 	ldw	r2,-52(fp)
 4010280:	1005d43a 	srai	r2,r2,16
 4010284:	e0bffd15 	stw	r2,-12(fp)
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
 4010288:	e0bff317 	ldw	r2,-52(fp)
 401028c:	1006943a 	slli	r3,r2,16
 4010290:	e0bff417 	ldw	r2,-48(fp)
 4010294:	10bfffcc 	andi	r2,r2,65535
 4010298:	1888b03a 	or	r4,r3,r2
 401029c:	e0bffa17 	ldw	r2,-24(fp)
 40102a0:	10c00104 	addi	r3,r2,4
 40102a4:	e0fffa15 	stw	r3,-24(fp)
 40102a8:	2007883a 	mov	r3,r4
 40102ac:	10c00015 	stw	r3,0(r2)
  while (xa < xae)
 40102b0:	e0fffc17 	ldw	r3,-16(fp)
 40102b4:	e0bff717 	ldw	r2,-36(fp)
 40102b8:	18bfdf36 	bltu	r3,r2,4010238 <__mdiff+0x224>
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      *xc++ = y & 0xffff;
    }
#endif
  while (!*--xc)
 40102bc:	00000306 	br	40102cc <__mdiff+0x2b8>
    wa--;
 40102c0:	e0bffe17 	ldw	r2,-8(fp)
 40102c4:	10bfffc4 	addi	r2,r2,-1
 40102c8:	e0bffe15 	stw	r2,-8(fp)
  while (!*--xc)
 40102cc:	e0bffa17 	ldw	r2,-24(fp)
 40102d0:	10bfff04 	addi	r2,r2,-4
 40102d4:	e0bffa15 	stw	r2,-24(fp)
 40102d8:	e0bffa17 	ldw	r2,-24(fp)
 40102dc:	10800017 	ldw	r2,0(r2)
 40102e0:	103ff726 	beq	r2,zero,40102c0 <__mdiff+0x2ac>
  c->_wds = wa;
 40102e4:	e0bff917 	ldw	r2,-28(fp)
 40102e8:	e0fffe17 	ldw	r3,-8(fp)
 40102ec:	10c00415 	stw	r3,16(r2)
  return c;
 40102f0:	e0bff917 	ldw	r2,-28(fp)
}
 40102f4:	e037883a 	mov	sp,fp
 40102f8:	dfc00117 	ldw	ra,4(sp)
 40102fc:	df000017 	ldw	fp,0(sp)
 4010300:	dec00204 	addi	sp,sp,8
 4010304:	f800283a 	ret

04010308 <__ulp>:

double
ulp (double _x)
{
 4010308:	defff804 	addi	sp,sp,-32
 401030c:	df000715 	stw	fp,28(sp)
 4010310:	dc000615 	stw	r16,24(sp)
 4010314:	df000704 	addi	fp,sp,28
 4010318:	e13ff915 	stw	r4,-28(fp)
 401031c:	e17ffa15 	stw	r5,-24(fp)
  union double_union x, a;
  register __Long L;

  x.d = _x;
 4010320:	e0bff917 	ldw	r2,-28(fp)
 4010324:	e0bffd15 	stw	r2,-12(fp)
 4010328:	e0bffa17 	ldw	r2,-24(fp)
 401032c:	e0bffe15 	stw	r2,-8(fp)

  L = (word0 (x) & Exp_mask) - (P - 1) * Exp_msk1;
 4010330:	e0bffe17 	ldw	r2,-8(fp)
 4010334:	10dffc2c 	andhi	r3,r2,32752
 4010338:	00bf3034 	movhi	r2,64704
 401033c:	1885883a 	add	r2,r3,r2
 4010340:	1021883a 	mov	r16,r2
#ifndef Sudden_Underflow
  if (L > 0)
 4010344:	0400040e 	bge	zero,r16,4010358 <__ulp+0x50>
    {
#endif
#ifdef IBM
      L |= Exp_msk1 >> 4;
#endif
      word0 (a) = L;
 4010348:	8005883a 	mov	r2,r16
 401034c:	e0bffc15 	stw	r2,-16(fp)
#ifndef _DOUBLE_IS_32BITS
      word1 (a) = 0;
 4010350:	e03ffb15 	stw	zero,-20(fp)
 4010354:	00001206 	br	40103a0 <__ulp+0x98>

#ifndef Sudden_Underflow
    }
  else
    {
      L = -L >> Exp_shift;
 4010358:	0405c83a 	sub	r2,zero,r16
 401035c:	1021d53a 	srai	r16,r2,20
      if (L < Exp_shift)
 4010360:	80800508 	cmpgei	r2,r16,20
 4010364:	1000051e 	bne	r2,zero,401037c <__ulp+0x74>
	{
	  word0 (a) = 0x80000 >> L;
 4010368:	00800234 	movhi	r2,8
 401036c:	1405d83a 	sra	r2,r2,r16
 4010370:	e0bffc15 	stw	r2,-16(fp)
#ifndef _DOUBLE_IS_32BITS
	  word1 (a) = 0;
 4010374:	e03ffb15 	stw	zero,-20(fp)
 4010378:	00000906 	br	40103a0 <__ulp+0x98>
#endif
	}
      else
	{
	  word0 (a) = 0;
 401037c:	e03ffc15 	stw	zero,-16(fp)
	  L -= Exp_shift;
 4010380:	843ffb04 	addi	r16,r16,-20
#ifndef _DOUBLE_IS_32BITS
         word1 (a) = L >= 31 ? 1 : 1 << (31 - L);
 4010384:	808007c8 	cmpgei	r2,r16,31
 4010388:	1000031e 	bne	r2,zero,4010398 <__ulp+0x90>
 401038c:	00a00034 	movhi	r2,32768
 4010390:	1404d83a 	srl	r2,r2,r16
 4010394:	00000106 	br	401039c <__ulp+0x94>
 4010398:	00800044 	movi	r2,1
 401039c:	e0bffb15 	stw	r2,-20(fp)
#endif
	}
    }
#endif
  return a.d;
 40103a0:	e0bffb17 	ldw	r2,-20(fp)
 40103a4:	e0fffc17 	ldw	r3,-16(fp)
 40103a8:	1009883a 	mov	r4,r2
 40103ac:	180b883a 	mov	r5,r3
}
 40103b0:	2005883a 	mov	r2,r4
 40103b4:	2807883a 	mov	r3,r5
 40103b8:	e6ffff04 	addi	sp,fp,-4
 40103bc:	df000117 	ldw	fp,4(sp)
 40103c0:	dc000017 	ldw	r16,0(sp)
 40103c4:	dec00204 	addi	sp,sp,8
 40103c8:	f800283a 	ret

040103cc <__b2d>:

double
b2d (_Bigint * a, int *e)
{
 40103cc:	defff404 	addi	sp,sp,-48
 40103d0:	dfc00b15 	stw	ra,44(sp)
 40103d4:	df000a15 	stw	fp,40(sp)
 40103d8:	df000a04 	addi	fp,sp,40
 40103dc:	e13ff715 	stw	r4,-36(fp)
 40103e0:	e17ff615 	stw	r5,-40(fp)
#else
#define d0 word0(d)
#define d1 word1(d)
#endif

  xa0 = a->_x;
 40103e4:	e0bff717 	ldw	r2,-36(fp)
 40103e8:	10800504 	addi	r2,r2,20
 40103ec:	e0bffe15 	stw	r2,-8(fp)
  xa = xa0 + a->_wds;
 40103f0:	e0bff717 	ldw	r2,-36(fp)
 40103f4:	10800417 	ldw	r2,16(r2)
 40103f8:	100490ba 	slli	r2,r2,2
 40103fc:	e0fffe17 	ldw	r3,-8(fp)
 4010400:	1885883a 	add	r2,r3,r2
 4010404:	e0bfff15 	stw	r2,-4(fp)
  y = *--xa;
 4010408:	e0bfff17 	ldw	r2,-4(fp)
 401040c:	10bfff04 	addi	r2,r2,-4
 4010410:	e0bfff15 	stw	r2,-4(fp)
 4010414:	e0bfff17 	ldw	r2,-4(fp)
 4010418:	10800017 	ldw	r2,0(r2)
 401041c:	e0bffd15 	stw	r2,-12(fp)
#ifdef DEBUG
  if (!y)
    Bug ("zero y in b2d");
#endif
  k = hi0bits (y);
 4010420:	e13ffd17 	ldw	r4,-12(fp)
 4010424:	400f58c0 	call	400f58c <__hi0bits>
 4010428:	e0bffc15 	stw	r2,-16(fp)
  *e = 32 - k;
 401042c:	00c00804 	movi	r3,32
 4010430:	e0bffc17 	ldw	r2,-16(fp)
 4010434:	1887c83a 	sub	r3,r3,r2
 4010438:	e0bff617 	ldw	r2,-40(fp)
 401043c:	10c00015 	stw	r3,0(r2)
#ifdef Pack_32
  if (k < Ebits)
 4010440:	e0bffc17 	ldw	r2,-16(fp)
 4010444:	108002c8 	cmpgei	r2,r2,11
 4010448:	10001e1e 	bne	r2,zero,40104c4 <__b2d+0xf8>
    {
      d0 = Exp_1 | y >> (Ebits - k);
 401044c:	00c002c4 	movi	r3,11
 4010450:	e0bffc17 	ldw	r2,-16(fp)
 4010454:	1885c83a 	sub	r2,r3,r2
 4010458:	e0fffd17 	ldw	r3,-12(fp)
 401045c:	1884d83a 	srl	r2,r3,r2
 4010460:	108ffc34 	orhi	r2,r2,16368
 4010464:	e0bff915 	stw	r2,-28(fp)
      w = xa > xa0 ? *--xa : 0;
 4010468:	e0bfff17 	ldw	r2,-4(fp)
 401046c:	e0fffe17 	ldw	r3,-8(fp)
 4010470:	1880062e 	bgeu	r3,r2,401048c <__b2d+0xc0>
 4010474:	e0bfff17 	ldw	r2,-4(fp)
 4010478:	10bfff04 	addi	r2,r2,-4
 401047c:	e0bfff15 	stw	r2,-4(fp)
 4010480:	e0bfff17 	ldw	r2,-4(fp)
 4010484:	10800017 	ldw	r2,0(r2)
 4010488:	00000106 	br	4010490 <__b2d+0xc4>
 401048c:	0005883a 	mov	r2,zero
 4010490:	e0bffa15 	stw	r2,-24(fp)
#ifndef _DOUBLE_IS_32BITS
      d1 = y << ((32 - Ebits) + k) | w >> (Ebits - k);
 4010494:	e0bffc17 	ldw	r2,-16(fp)
 4010498:	10800544 	addi	r2,r2,21
 401049c:	e0fffd17 	ldw	r3,-12(fp)
 40104a0:	1886983a 	sll	r3,r3,r2
 40104a4:	010002c4 	movi	r4,11
 40104a8:	e0bffc17 	ldw	r2,-16(fp)
 40104ac:	2085c83a 	sub	r2,r4,r2
 40104b0:	e13ffa17 	ldw	r4,-24(fp)
 40104b4:	2084d83a 	srl	r2,r4,r2
 40104b8:	1884b03a 	or	r2,r3,r2
 40104bc:	e0bff815 	stw	r2,-32(fp)
#endif
      goto ret_d;
 40104c0:	00003606 	br	401059c <__b2d+0x1d0>
    }
  z = xa > xa0 ? *--xa : 0;
 40104c4:	e0bfff17 	ldw	r2,-4(fp)
 40104c8:	e0fffe17 	ldw	r3,-8(fp)
 40104cc:	1880062e 	bgeu	r3,r2,40104e8 <__b2d+0x11c>
 40104d0:	e0bfff17 	ldw	r2,-4(fp)
 40104d4:	10bfff04 	addi	r2,r2,-4
 40104d8:	e0bfff15 	stw	r2,-4(fp)
 40104dc:	e0bfff17 	ldw	r2,-4(fp)
 40104e0:	10800017 	ldw	r2,0(r2)
 40104e4:	00000106 	br	40104ec <__b2d+0x120>
 40104e8:	0005883a 	mov	r2,zero
 40104ec:	e0bffb15 	stw	r2,-20(fp)
  if (k -= Ebits)
 40104f0:	e0bffc17 	ldw	r2,-16(fp)
 40104f4:	10bffd44 	addi	r2,r2,-11
 40104f8:	e0bffc15 	stw	r2,-16(fp)
 40104fc:	e0bffc17 	ldw	r2,-16(fp)
 4010500:	10002126 	beq	r2,zero,4010588 <__b2d+0x1bc>
    {
      d0 = Exp_1 | y << k | z >> (32 - k);
 4010504:	e0fffd17 	ldw	r3,-12(fp)
 4010508:	e0bffc17 	ldw	r2,-16(fp)
 401050c:	1886983a 	sll	r3,r3,r2
 4010510:	01000804 	movi	r4,32
 4010514:	e0bffc17 	ldw	r2,-16(fp)
 4010518:	2085c83a 	sub	r2,r4,r2
 401051c:	e13ffb17 	ldw	r4,-20(fp)
 4010520:	2084d83a 	srl	r2,r4,r2
 4010524:	1884b03a 	or	r2,r3,r2
 4010528:	108ffc34 	orhi	r2,r2,16368
 401052c:	e0bff915 	stw	r2,-28(fp)
      y = xa > xa0 ? *--xa : 0;
 4010530:	e0bfff17 	ldw	r2,-4(fp)
 4010534:	e0fffe17 	ldw	r3,-8(fp)
 4010538:	1880062e 	bgeu	r3,r2,4010554 <__b2d+0x188>
 401053c:	e0bfff17 	ldw	r2,-4(fp)
 4010540:	10bfff04 	addi	r2,r2,-4
 4010544:	e0bfff15 	stw	r2,-4(fp)
 4010548:	e0bfff17 	ldw	r2,-4(fp)
 401054c:	10800017 	ldw	r2,0(r2)
 4010550:	00000106 	br	4010558 <__b2d+0x18c>
 4010554:	0005883a 	mov	r2,zero
 4010558:	e0bffd15 	stw	r2,-12(fp)
#ifndef _DOUBLE_IS_32BITS
      d1 = z << k | y >> (32 - k);
 401055c:	e0fffb17 	ldw	r3,-20(fp)
 4010560:	e0bffc17 	ldw	r2,-16(fp)
 4010564:	1886983a 	sll	r3,r3,r2
 4010568:	01000804 	movi	r4,32
 401056c:	e0bffc17 	ldw	r2,-16(fp)
 4010570:	2085c83a 	sub	r2,r4,r2
 4010574:	e13ffd17 	ldw	r4,-12(fp)
 4010578:	2084d83a 	srl	r2,r4,r2
 401057c:	1884b03a 	or	r2,r3,r2
 4010580:	e0bff815 	stw	r2,-32(fp)
 4010584:	00000506 	br	401059c <__b2d+0x1d0>
#endif
    }
  else
    {
      d0 = Exp_1 | y;
 4010588:	e0bffd17 	ldw	r2,-12(fp)
 401058c:	108ffc34 	orhi	r2,r2,16368
 4010590:	e0bff915 	stw	r2,-28(fp)
#ifndef _DOUBLE_IS_32BITS
      d1 = z;
 4010594:	e0bffb17 	ldw	r2,-20(fp)
 4010598:	e0bff815 	stw	r2,-32(fp)
  word1 (d) = d1 >> 16 | d1 << 16;
#else
#undef d0
#undef d1
#endif
  return d.d;
 401059c:	e0bff817 	ldw	r2,-32(fp)
 40105a0:	e0fff917 	ldw	r3,-28(fp)
 40105a4:	1009883a 	mov	r4,r2
 40105a8:	180b883a 	mov	r5,r3
}
 40105ac:	2005883a 	mov	r2,r4
 40105b0:	2807883a 	mov	r3,r5
 40105b4:	e037883a 	mov	sp,fp
 40105b8:	dfc00117 	ldw	ra,4(sp)
 40105bc:	df000017 	ldw	fp,0(sp)
 40105c0:	dec00204 	addi	sp,sp,8
 40105c4:	f800283a 	ret

040105c8 <__d2b>:
d2b (struct _reent * ptr,
	double _d,
	int *e,
	int *bits)

{
 40105c8:	deffef04 	addi	sp,sp,-68
 40105cc:	dfc01015 	stw	ra,64(sp)
 40105d0:	df000f15 	stw	fp,60(sp)
 40105d4:	dc000e15 	stw	r16,56(sp)
 40105d8:	df000f04 	addi	fp,sp,60
 40105dc:	e13ff415 	stw	r4,-48(fp)
 40105e0:	e17ff215 	stw	r5,-56(fp)
 40105e4:	e1bff315 	stw	r6,-52(fp)
 40105e8:	e1fff115 	stw	r7,-60(fp)
  int de, i, k;
  __ULong *x, y, z;
#ifdef VAX
  __ULong d0, d1;
#endif
  d.d = _d;
 40105ec:	e0bff217 	ldw	r2,-56(fp)
 40105f0:	e0bff715 	stw	r2,-36(fp)
 40105f4:	e0bff317 	ldw	r2,-52(fp)
 40105f8:	e0bff815 	stw	r2,-32(fp)
  d0 = word0 (d) >> 16 | word0 (d) << 16;
  d1 = word1 (d) >> 16 | word1 (d) << 16;
#else
#define d0 word0(d)
#define d1 word1(d)
  d.d = _d;
 40105fc:	e0bff217 	ldw	r2,-56(fp)
 4010600:	e0bff715 	stw	r2,-36(fp)
 4010604:	e0bff317 	ldw	r2,-52(fp)
 4010608:	e0bff815 	stw	r2,-32(fp)
#endif

#ifdef Pack_32
  b = eBalloc (ptr, 1);
 401060c:	01400044 	movi	r5,1
 4010610:	e13ff417 	ldw	r4,-48(fp)
 4010614:	400f06c0 	call	400f06c <_Balloc>
 4010618:	e0bffc15 	stw	r2,-16(fp)
 401061c:	e0bffc17 	ldw	r2,-16(fp)
 4010620:	1000071e 	bne	r2,zero,4010640 <__d2b+0x78>
 4010624:	01c100b4 	movhi	r7,1026
 4010628:	39eb0104 	addi	r7,r7,-21500
 401062c:	000d883a 	mov	r6,zero
 4010630:	0140c284 	movi	r5,778
 4010634:	010100b4 	movhi	r4,1026
 4010638:	212b0604 	addi	r4,r4,-21480
 401063c:	40130ac0 	call	40130ac <__assert_func>
 4010640:	e0bffc17 	ldw	r2,-16(fp)
 4010644:	e0bffb15 	stw	r2,-20(fp)
#else
  b = eBalloc (ptr, 2);
#endif
  x = b->_x;
 4010648:	e0bffb17 	ldw	r2,-20(fp)
 401064c:	10800504 	addi	r2,r2,20
 4010650:	e0bffa15 	stw	r2,-24(fp)

  z = d0 & Frac_mask;
 4010654:	e0fff817 	ldw	r3,-32(fp)
 4010658:	00800434 	movhi	r2,16
 401065c:	10bfffc4 	addi	r2,r2,-1
 4010660:	1884703a 	and	r2,r3,r2
 4010664:	e0bff515 	stw	r2,-44(fp)
  d0 &= 0x7fffffff;		/* clear sign bit, which we ignore */
 4010668:	e0fff817 	ldw	r3,-32(fp)
 401066c:	00a00034 	movhi	r2,32768
 4010670:	10bfffc4 	addi	r2,r2,-1
 4010674:	1884703a 	and	r2,r3,r2
 4010678:	e0bff815 	stw	r2,-32(fp)
  de = (int) (d0 >> Exp_shift);
#ifndef IBM
  z |= Exp_msk11;
#endif
#else
  if ((de = (int) (d0 >> Exp_shift)) != 0)
 401067c:	e0bff817 	ldw	r2,-32(fp)
 4010680:	1004d53a 	srli	r2,r2,20
 4010684:	e0bff915 	stw	r2,-28(fp)
 4010688:	e0bff917 	ldw	r2,-28(fp)
 401068c:	10000326 	beq	r2,zero,401069c <__d2b+0xd4>
    z |= Exp_msk1;
 4010690:	e0bff517 	ldw	r2,-44(fp)
 4010694:	10800434 	orhi	r2,r2,16
 4010698:	e0bff515 	stw	r2,-44(fp)
#endif
#ifdef Pack_32
#ifndef _DOUBLE_IS_32BITS
  if (d1)
 401069c:	e0bff717 	ldw	r2,-36(fp)
 40106a0:	10002826 	beq	r2,zero,4010744 <__d2b+0x17c>
    {
      y = d1;
 40106a4:	e0bff717 	ldw	r2,-36(fp)
 40106a8:	e0bff615 	stw	r2,-40(fp)
      k = lo0bits (&y);
 40106ac:	e0bff604 	addi	r2,fp,-40
 40106b0:	1009883a 	mov	r4,r2
 40106b4:	400f6180 	call	400f618 <__lo0bits>
 40106b8:	e0bffd15 	stw	r2,-12(fp)
      if (k)
 40106bc:	e0bffd17 	ldw	r2,-12(fp)
 40106c0:	10000e26 	beq	r2,zero,40106fc <__d2b+0x134>
	{
         x[0] = y | z << (32 - k);
 40106c4:	e0fff517 	ldw	r3,-44(fp)
 40106c8:	01000804 	movi	r4,32
 40106cc:	e0bffd17 	ldw	r2,-12(fp)
 40106d0:	2085c83a 	sub	r2,r4,r2
 40106d4:	1886983a 	sll	r3,r3,r2
 40106d8:	e0bff617 	ldw	r2,-40(fp)
 40106dc:	1886b03a 	or	r3,r3,r2
 40106e0:	e0bffa17 	ldw	r2,-24(fp)
 40106e4:	10c00015 	stw	r3,0(r2)
	  z >>= k;
 40106e8:	e0fff517 	ldw	r3,-44(fp)
 40106ec:	e0bffd17 	ldw	r2,-12(fp)
 40106f0:	1884d83a 	srl	r2,r3,r2
 40106f4:	e0bff515 	stw	r2,-44(fp)
 40106f8:	00000306 	br	4010708 <__d2b+0x140>
	}
      else
	x[0] = y;
 40106fc:	e0fff617 	ldw	r3,-40(fp)
 4010700:	e0bffa17 	ldw	r2,-24(fp)
 4010704:	10c00015 	stw	r3,0(r2)
      i = b->_wds = (x[1] = z) ? 2 : 1;
 4010708:	e0bffa17 	ldw	r2,-24(fp)
 401070c:	10800104 	addi	r2,r2,4
 4010710:	e0fff517 	ldw	r3,-44(fp)
 4010714:	10c00015 	stw	r3,0(r2)
 4010718:	10800017 	ldw	r2,0(r2)
 401071c:	10000226 	beq	r2,zero,4010728 <__d2b+0x160>
 4010720:	00800084 	movi	r2,2
 4010724:	00000106 	br	401072c <__d2b+0x164>
 4010728:	00800044 	movi	r2,1
 401072c:	e0fffb17 	ldw	r3,-20(fp)
 4010730:	18800415 	stw	r2,16(r3)
 4010734:	e0bffb17 	ldw	r2,-20(fp)
 4010738:	10800417 	ldw	r2,16(r2)
 401073c:	e0bffe15 	stw	r2,-8(fp)
 4010740:	00001006 	br	4010784 <__d2b+0x1bc>
    {
#ifdef DEBUG
      if (!z)
	Bug ("Zero passed to d2b");
#endif
      k = lo0bits (&z);
 4010744:	e0bff504 	addi	r2,fp,-44
 4010748:	1009883a 	mov	r4,r2
 401074c:	400f6180 	call	400f618 <__lo0bits>
 4010750:	e0bffd15 	stw	r2,-12(fp)
      x[0] = z;
 4010754:	e0fff517 	ldw	r3,-44(fp)
 4010758:	e0bffa17 	ldw	r2,-24(fp)
 401075c:	10c00015 	stw	r3,0(r2)
      i = b->_wds = 1;
 4010760:	e0bffb17 	ldw	r2,-20(fp)
 4010764:	00c00044 	movi	r3,1
 4010768:	10c00415 	stw	r3,16(r2)
 401076c:	e0bffb17 	ldw	r2,-20(fp)
 4010770:	10800417 	ldw	r2,16(r2)
 4010774:	e0bffe15 	stw	r2,-8(fp)
#ifndef _DOUBLE_IS_32BITS
      k += 32;
 4010778:	e0bffd17 	ldw	r2,-12(fp)
 401077c:	10800804 	addi	r2,r2,32
 4010780:	e0bffd15 	stw	r2,-12(fp)
  while (!x[i])
    --i;
  b->_wds = i + 1;
#endif
#ifndef Sudden_Underflow
  if (de)
 4010784:	e0bff917 	ldw	r2,-28(fp)
 4010788:	10000c26 	beq	r2,zero,40107bc <__d2b+0x1f4>
#endif
#ifdef IBM
      *e = (de - Bias - (P - 1) << 2) + k;
      *bits = 4 * P + 8 - k - hi0bits (word0 (d) & Frac_mask);
#else
      *e = de - Bias - (P - 1) + k;
 401078c:	e0bff917 	ldw	r2,-28(fp)
 4010790:	10fef344 	addi	r3,r2,-1075
 4010794:	e0bffd17 	ldw	r2,-12(fp)
 4010798:	1887883a 	add	r3,r3,r2
 401079c:	e0bff117 	ldw	r2,-60(fp)
 40107a0:	10c00015 	stw	r3,0(r2)
      *bits = P - k;
 40107a4:	00c00d44 	movi	r3,53
 40107a8:	e0bffd17 	ldw	r2,-12(fp)
 40107ac:	1887c83a 	sub	r3,r3,r2
 40107b0:	e0800217 	ldw	r2,8(fp)
 40107b4:	10c00015 	stw	r3,0(r2)
 40107b8:	00001506 	br	4010810 <__d2b+0x248>
#endif
#ifndef Sudden_Underflow
    }
  else
    {
      *e = de - Bias - (P - 1) + 1 + k;
 40107bc:	e0bff917 	ldw	r2,-28(fp)
 40107c0:	10fef384 	addi	r3,r2,-1074
 40107c4:	e0bffd17 	ldw	r2,-12(fp)
 40107c8:	1887883a 	add	r3,r3,r2
 40107cc:	e0bff117 	ldw	r2,-60(fp)
 40107d0:	10c00015 	stw	r3,0(r2)
#ifdef Pack_32
      *bits = 32 * i - hi0bits (x[i - 1]);
 40107d4:	e0bffe17 	ldw	r2,-8(fp)
 40107d8:	1020917a 	slli	r16,r2,5
 40107dc:	e0fffe17 	ldw	r3,-8(fp)
 40107e0:	00900034 	movhi	r2,16384
 40107e4:	10bfffc4 	addi	r2,r2,-1
 40107e8:	1885883a 	add	r2,r3,r2
 40107ec:	100490ba 	slli	r2,r2,2
 40107f0:	e0fffa17 	ldw	r3,-24(fp)
 40107f4:	1885883a 	add	r2,r3,r2
 40107f8:	10800017 	ldw	r2,0(r2)
 40107fc:	1009883a 	mov	r4,r2
 4010800:	400f58c0 	call	400f58c <__hi0bits>
 4010804:	8087c83a 	sub	r3,r16,r2
 4010808:	e0800217 	ldw	r2,8(fp)
 401080c:	10c00015 	stw	r3,0(r2)
#else
      *bits = (i + 2) * 16 - hi0bits (x[i]);
#endif
    }
#endif
  return b;
 4010810:	e0bffb17 	ldw	r2,-20(fp)
}
 4010814:	e6ffff04 	addi	sp,fp,-4
 4010818:	dfc00217 	ldw	ra,8(sp)
 401081c:	df000117 	ldw	fp,4(sp)
 4010820:	dc000017 	ldw	r16,0(sp)
 4010824:	dec00304 	addi	sp,sp,12
 4010828:	f800283a 	ret

0401082c <__ratio>:
#undef d1

double
ratio (_Bigint * a, _Bigint * b)

{
 401082c:	defff504 	addi	sp,sp,-44
 4010830:	dfc00a15 	stw	ra,40(sp)
 4010834:	df000915 	stw	fp,36(sp)
 4010838:	df000904 	addi	fp,sp,36
 401083c:	e13ff815 	stw	r4,-32(fp)
 4010840:	e17ff715 	stw	r5,-36(fp)
  union double_union da, db;
  int k, ka, kb;

  da.d = b2d (a, &ka);
 4010844:	e0bffa04 	addi	r2,fp,-24
 4010848:	100b883a 	mov	r5,r2
 401084c:	e13ff817 	ldw	r4,-32(fp)
 4010850:	40103cc0 	call	40103cc <__b2d>
 4010854:	1009883a 	mov	r4,r2
 4010858:	180b883a 	mov	r5,r3
 401085c:	e13ffd15 	stw	r4,-12(fp)
 4010860:	e17ffe15 	stw	r5,-8(fp)
  db.d = b2d (b, &kb);
 4010864:	e0bff904 	addi	r2,fp,-28
 4010868:	100b883a 	mov	r5,r2
 401086c:	e13ff717 	ldw	r4,-36(fp)
 4010870:	40103cc0 	call	40103cc <__b2d>
 4010874:	1009883a 	mov	r4,r2
 4010878:	180b883a 	mov	r5,r3
 401087c:	e13ffb15 	stw	r4,-20(fp)
 4010880:	e17ffc15 	stw	r5,-16(fp)
#ifdef Pack_32
  k = ka - kb + 32 * (a->_wds - b->_wds);
 4010884:	e0fffa17 	ldw	r3,-24(fp)
 4010888:	e0bff917 	ldw	r2,-28(fp)
 401088c:	1887c83a 	sub	r3,r3,r2
 4010890:	e0bff817 	ldw	r2,-32(fp)
 4010894:	11000417 	ldw	r4,16(r2)
 4010898:	e0bff717 	ldw	r2,-36(fp)
 401089c:	10800417 	ldw	r2,16(r2)
 40108a0:	2085c83a 	sub	r2,r4,r2
 40108a4:	1004917a 	slli	r2,r2,5
 40108a8:	1885883a 	add	r2,r3,r2
 40108ac:	e0bfff15 	stw	r2,-4(fp)
      word0 (db) += (k >> 2) * Exp_msk1;
      if (k &= 3)
	db.d *= 1 << k;
    }
#else
  if (k > 0)
 40108b0:	e0bfff17 	ldw	r2,-4(fp)
 40108b4:	0080060e 	bge	zero,r2,40108d0 <__ratio+0xa4>
    word0 (da) += k * Exp_msk1;
 40108b8:	e0fffe17 	ldw	r3,-8(fp)
 40108bc:	e0bfff17 	ldw	r2,-4(fp)
 40108c0:	1004953a 	slli	r2,r2,20
 40108c4:	1885883a 	add	r2,r3,r2
 40108c8:	e0bffe15 	stw	r2,-8(fp)
 40108cc:	00000806 	br	40108f0 <__ratio+0xc4>
  else
    {
      k = -k;
 40108d0:	e0bfff17 	ldw	r2,-4(fp)
 40108d4:	0085c83a 	sub	r2,zero,r2
 40108d8:	e0bfff15 	stw	r2,-4(fp)
      word0 (db) += k * Exp_msk1;
 40108dc:	e0fffc17 	ldw	r3,-16(fp)
 40108e0:	e0bfff17 	ldw	r2,-4(fp)
 40108e4:	1004953a 	slli	r2,r2,20
 40108e8:	1885883a 	add	r2,r3,r2
 40108ec:	e0bffc15 	stw	r2,-16(fp)
    }
#endif
  return da.d / db.d;
 40108f0:	e0bffd17 	ldw	r2,-12(fp)
 40108f4:	e0fffe17 	ldw	r3,-8(fp)
 40108f8:	e13ffb17 	ldw	r4,-20(fp)
 40108fc:	e17ffc17 	ldw	r5,-16(fp)
 4010900:	200d883a 	mov	r6,r4
 4010904:	280f883a 	mov	r7,r5
 4010908:	1009883a 	mov	r4,r2
 401090c:	180b883a 	mov	r5,r3
 4010910:	4015db80 	call	4015db8 <__divdf3>
 4010914:	1009883a 	mov	r4,r2
 4010918:	180b883a 	mov	r5,r3
 401091c:	2005883a 	mov	r2,r4
 4010920:	2807883a 	mov	r3,r5
 4010924:	1009883a 	mov	r4,r2
 4010928:	180b883a 	mov	r5,r3
}
 401092c:	2005883a 	mov	r2,r4
 4010930:	2807883a 	mov	r3,r5
 4010934:	e037883a 	mov	sp,fp
 4010938:	dfc00117 	ldw	ra,4(sp)
 401093c:	df000017 	ldw	fp,0(sp)
 4010940:	dec00204 	addi	sp,sp,8
 4010944:	f800283a 	ret

04010948 <_mprec_log10>:
#endif


double
_mprec_log10 (int dig)
{
 4010948:	defffb04 	addi	sp,sp,-20
 401094c:	dfc00415 	stw	ra,16(sp)
 4010950:	df000315 	stw	fp,12(sp)
 4010954:	df000304 	addi	fp,sp,12
 4010958:	e13ffd15 	stw	r4,-12(fp)
  double v = 1.0;
 401095c:	e03ffe15 	stw	zero,-8(fp)
 4010960:	008ffc34 	movhi	r2,16368
 4010964:	e0bfff15 	stw	r2,-4(fp)
  if (dig < 24)
 4010968:	e0bffd17 	ldw	r2,-12(fp)
 401096c:	10800608 	cmpgei	r2,r2,24
 4010970:	1000151e 	bne	r2,zero,40109c8 <_mprec_log10+0x80>
    return tens[dig];
 4010974:	e0bffd17 	ldw	r2,-12(fp)
 4010978:	100a90fa 	slli	r5,r2,3
 401097c:	010100b4 	movhi	r4,1026
 4010980:	2909883a 	add	r4,r5,r4
 4010984:	20ab1d17 	ldw	r2,-21388(r4)
 4010988:	010100b4 	movhi	r4,1026
 401098c:	2909883a 	add	r4,r5,r4
 4010990:	20eb1e17 	ldw	r3,-21384(r4)
 4010994:	00001006 	br	40109d8 <_mprec_log10+0x90>
  while (dig > 0)
    {
      v *= 10;
 4010998:	000d883a 	mov	r6,zero
 401099c:	01d00934 	movhi	r7,16420
 40109a0:	e13ffe17 	ldw	r4,-8(fp)
 40109a4:	e17fff17 	ldw	r5,-4(fp)
 40109a8:	401694c0 	call	401694c <__muldf3>
 40109ac:	1009883a 	mov	r4,r2
 40109b0:	180b883a 	mov	r5,r3
 40109b4:	e13ffe15 	stw	r4,-8(fp)
 40109b8:	e17fff15 	stw	r5,-4(fp)
      dig--;
 40109bc:	e0bffd17 	ldw	r2,-12(fp)
 40109c0:	10bfffc4 	addi	r2,r2,-1
 40109c4:	e0bffd15 	stw	r2,-12(fp)
  while (dig > 0)
 40109c8:	e0bffd17 	ldw	r2,-12(fp)
 40109cc:	00bff216 	blt	zero,r2,4010998 <_mprec_log10+0x50>
    }
  return v;
 40109d0:	e0bffe17 	ldw	r2,-8(fp)
 40109d4:	e0ffff17 	ldw	r3,-4(fp)
 40109d8:	1009883a 	mov	r4,r2
 40109dc:	180b883a 	mov	r5,r3
}
 40109e0:	2005883a 	mov	r2,r4
 40109e4:	2807883a 	mov	r3,r5
 40109e8:	e037883a 	mov	sp,fp
 40109ec:	dfc00117 	ldw	ra,4(sp)
 40109f0:	df000017 	ldw	fp,0(sp)
 40109f4:	dec00204 	addi	sp,sp,8
 40109f8:	f800283a 	ret

040109fc <__copybits>:

void
copybits (__ULong *c,
	int n,
	_Bigint *b)
{
 40109fc:	defff904 	addi	sp,sp,-28
 4010a00:	df000615 	stw	fp,24(sp)
 4010a04:	df000604 	addi	fp,sp,24
 4010a08:	e13ffc15 	stw	r4,-16(fp)
 4010a0c:	e17ffb15 	stw	r5,-20(fp)
 4010a10:	e1bffa15 	stw	r6,-24(fp)
	__ULong *ce, *x, *xe;
#ifdef Pack_16
	int nw, nw1;
#endif

	ce = c + ((n-1) >> kshift) + 1;
 4010a14:	e0bffb17 	ldw	r2,-20(fp)
 4010a18:	10bfffc4 	addi	r2,r2,-1
 4010a1c:	1005d17a 	srai	r2,r2,5
 4010a20:	10800044 	addi	r2,r2,1
 4010a24:	100490ba 	slli	r2,r2,2
 4010a28:	e0fffc17 	ldw	r3,-16(fp)
 4010a2c:	1885883a 	add	r2,r3,r2
 4010a30:	e0bffe15 	stw	r2,-8(fp)
	x = b->_x;
 4010a34:	e0bffa17 	ldw	r2,-24(fp)
 4010a38:	10800504 	addi	r2,r2,20
 4010a3c:	e0bfff15 	stw	r2,-4(fp)
#ifdef Pack_32
	xe = x + b->_wds;
 4010a40:	e0bffa17 	ldw	r2,-24(fp)
 4010a44:	10800417 	ldw	r2,16(r2)
 4010a48:	100490ba 	slli	r2,r2,2
 4010a4c:	e0ffff17 	ldw	r3,-4(fp)
 4010a50:	1885883a 	add	r2,r3,r2
 4010a54:	e0bffd15 	stw	r2,-12(fp)
	while(x < xe)
 4010a58:	00000806 	br	4010a7c <__copybits+0x80>
		*c++ = *x++;
 4010a5c:	e0ffff17 	ldw	r3,-4(fp)
 4010a60:	18800104 	addi	r2,r3,4
 4010a64:	e0bfff15 	stw	r2,-4(fp)
 4010a68:	e0bffc17 	ldw	r2,-16(fp)
 4010a6c:	11000104 	addi	r4,r2,4
 4010a70:	e13ffc15 	stw	r4,-16(fp)
 4010a74:	18c00017 	ldw	r3,0(r3)
 4010a78:	10c00015 	stw	r3,0(r2)
	while(x < xe)
 4010a7c:	e0ffff17 	ldw	r3,-4(fp)
 4010a80:	e0bffd17 	ldw	r2,-12(fp)
 4010a84:	18bff536 	bltu	r3,r2,4010a5c <__copybits+0x60>
	for(xe = x + (nw - nw1); x < xe; x += 2)
		Storeinc(c, x[1], x[0]);
	if (nw1)
		*c++ = *x;
#endif
	while(c < ce)
 4010a88:	00000406 	br	4010a9c <__copybits+0xa0>
		*c++ = 0;
 4010a8c:	e0bffc17 	ldw	r2,-16(fp)
 4010a90:	10c00104 	addi	r3,r2,4
 4010a94:	e0fffc15 	stw	r3,-16(fp)
 4010a98:	10000015 	stw	zero,0(r2)
	while(c < ce)
 4010a9c:	e0fffc17 	ldw	r3,-16(fp)
 4010aa0:	e0bffe17 	ldw	r2,-8(fp)
 4010aa4:	18bff936 	bltu	r3,r2,4010a8c <__copybits+0x90>
}
 4010aa8:	0001883a 	nop
 4010aac:	0001883a 	nop
 4010ab0:	e037883a 	mov	sp,fp
 4010ab4:	df000017 	ldw	fp,0(sp)
 4010ab8:	dec00104 	addi	sp,sp,4
 4010abc:	f800283a 	ret

04010ac0 <__any_on>:

__ULong
any_on (_Bigint *b,
	int k)
{
 4010ac0:	defff704 	addi	sp,sp,-36
 4010ac4:	df000815 	stw	fp,32(sp)
 4010ac8:	df000804 	addi	fp,sp,32
 4010acc:	e13ff915 	stw	r4,-28(fp)
 4010ad0:	e17ff815 	stw	r5,-32(fp)
	int n, nwds;
	__ULong *x, *x0, x1, x2;

	x = b->_x;
 4010ad4:	e0bff917 	ldw	r2,-28(fp)
 4010ad8:	10800504 	addi	r2,r2,20
 4010adc:	e0bffe15 	stw	r2,-8(fp)
	nwds = b->_wds;
 4010ae0:	e0bff917 	ldw	r2,-28(fp)
 4010ae4:	10800417 	ldw	r2,16(r2)
 4010ae8:	e0bffd15 	stw	r2,-12(fp)
	n = k >> kshift;
 4010aec:	e0bff817 	ldw	r2,-32(fp)
 4010af0:	1005d17a 	srai	r2,r2,5
 4010af4:	e0bfff15 	stw	r2,-4(fp)
	if (n > nwds)
 4010af8:	e0bfff17 	ldw	r2,-4(fp)
 4010afc:	e0fffd17 	ldw	r3,-12(fp)
 4010b00:	1880030e 	bge	r3,r2,4010b10 <__any_on+0x50>
		n = nwds;
 4010b04:	e0bffd17 	ldw	r2,-12(fp)
 4010b08:	e0bfff15 	stw	r2,-4(fp)
 4010b0c:	00001d06 	br	4010b84 <__any_on+0xc4>
	else if (n < nwds && (k &= kmask)) {
 4010b10:	e0ffff17 	ldw	r3,-4(fp)
 4010b14:	e0bffd17 	ldw	r2,-12(fp)
 4010b18:	18801a0e 	bge	r3,r2,4010b84 <__any_on+0xc4>
 4010b1c:	e0bff817 	ldw	r2,-32(fp)
 4010b20:	108007cc 	andi	r2,r2,31
 4010b24:	e0bff815 	stw	r2,-32(fp)
 4010b28:	e0bff817 	ldw	r2,-32(fp)
 4010b2c:	10001526 	beq	r2,zero,4010b84 <__any_on+0xc4>
		x1 = x2 = x[n];
 4010b30:	e0bfff17 	ldw	r2,-4(fp)
 4010b34:	100490ba 	slli	r2,r2,2
 4010b38:	e0fffe17 	ldw	r3,-8(fp)
 4010b3c:	1885883a 	add	r2,r3,r2
 4010b40:	10800017 	ldw	r2,0(r2)
 4010b44:	e0bffc15 	stw	r2,-16(fp)
 4010b48:	e0bffc17 	ldw	r2,-16(fp)
 4010b4c:	e0bffb15 	stw	r2,-20(fp)
		x1 >>= k;
 4010b50:	e0fffb17 	ldw	r3,-20(fp)
 4010b54:	e0bff817 	ldw	r2,-32(fp)
 4010b58:	1884d83a 	srl	r2,r3,r2
 4010b5c:	e0bffb15 	stw	r2,-20(fp)
		x1 <<= k;
 4010b60:	e0fffb17 	ldw	r3,-20(fp)
 4010b64:	e0bff817 	ldw	r2,-32(fp)
 4010b68:	1884983a 	sll	r2,r3,r2
 4010b6c:	e0bffb15 	stw	r2,-20(fp)
		if (x1 != x2)
 4010b70:	e0fffb17 	ldw	r3,-20(fp)
 4010b74:	e0bffc17 	ldw	r2,-16(fp)
 4010b78:	18800226 	beq	r3,r2,4010b84 <__any_on+0xc4>
			return 1;
 4010b7c:	00800044 	movi	r2,1
 4010b80:	00001406 	br	4010bd4 <__any_on+0x114>
		}
	x0 = x;
 4010b84:	e0bffe17 	ldw	r2,-8(fp)
 4010b88:	e0bffa15 	stw	r2,-24(fp)
	x += n;
 4010b8c:	e0bfff17 	ldw	r2,-4(fp)
 4010b90:	100490ba 	slli	r2,r2,2
 4010b94:	e0fffe17 	ldw	r3,-8(fp)
 4010b98:	1885883a 	add	r2,r3,r2
 4010b9c:	e0bffe15 	stw	r2,-8(fp)
	while(x > x0)
 4010ba0:	00000806 	br	4010bc4 <__any_on+0x104>
		if (*--x)
 4010ba4:	e0bffe17 	ldw	r2,-8(fp)
 4010ba8:	10bfff04 	addi	r2,r2,-4
 4010bac:	e0bffe15 	stw	r2,-8(fp)
 4010bb0:	e0bffe17 	ldw	r2,-8(fp)
 4010bb4:	10800017 	ldw	r2,0(r2)
 4010bb8:	10000226 	beq	r2,zero,4010bc4 <__any_on+0x104>
			return 1;
 4010bbc:	00800044 	movi	r2,1
 4010bc0:	00000406 	br	4010bd4 <__any_on+0x114>
	while(x > x0)
 4010bc4:	e0bffe17 	ldw	r2,-8(fp)
 4010bc8:	e0fffa17 	ldw	r3,-24(fp)
 4010bcc:	18bff536 	bltu	r3,r2,4010ba4 <__any_on+0xe4>
	return 0;
 4010bd0:	0005883a 	mov	r2,zero
}
 4010bd4:	e037883a 	mov	sp,fp
 4010bd8:	df000017 	ldw	fp,0(sp)
 4010bdc:	dec00104 	addi	sp,sp,4
 4010be0:	f800283a 	ret

04010be4 <_realloc_r>:
{
 4010be4:	deffe104 	addi	sp,sp,-124
 4010be8:	dfc01e15 	stw	ra,120(sp)
 4010bec:	df001d15 	stw	fp,116(sp)
 4010bf0:	df001d04 	addi	fp,sp,116
 4010bf4:	e13fe515 	stw	r4,-108(fp)
 4010bf8:	e17fe415 	stw	r5,-112(fp)
 4010bfc:	e1bfe315 	stw	r6,-116(fp)
  if (oldmem == 0) return mALLOc(RCALL bytes);
 4010c00:	e0bfe417 	ldw	r2,-112(fp)
 4010c04:	1000041e 	bne	r2,zero,4010c18 <_realloc_r+0x34>
 4010c08:	e17fe317 	ldw	r5,-116(fp)
 4010c0c:	e13fe517 	ldw	r4,-108(fp)
 4010c10:	400e1400 	call	400e140 <_malloc_r>
 4010c14:	0002eb06 	br	40117c4 <_realloc_r+0xbe0>
  MALLOC_LOCK;
 4010c18:	e13fe517 	ldw	r4,-108(fp)
 4010c1c:	40186a00 	call	40186a0 <__malloc_lock>
  newp    = oldp    = mem2chunk(oldmem);
 4010c20:	e0bfe417 	ldw	r2,-112(fp)
 4010c24:	10bffe04 	addi	r2,r2,-8
 4010c28:	e0bff315 	stw	r2,-52(fp)
 4010c2c:	e0bff317 	ldw	r2,-52(fp)
 4010c30:	e0bfff15 	stw	r2,-4(fp)
  newsize = oldsize = chunksize(oldp);
 4010c34:	e0bff317 	ldw	r2,-52(fp)
 4010c38:	10c00117 	ldw	r3,4(r2)
 4010c3c:	00bfff04 	movi	r2,-4
 4010c40:	1884703a 	and	r2,r3,r2
 4010c44:	e0bff215 	stw	r2,-56(fp)
 4010c48:	e0bff217 	ldw	r2,-56(fp)
 4010c4c:	e0bffe15 	stw	r2,-8(fp)
  nb = request2size(bytes);
 4010c50:	e0bfe317 	ldw	r2,-116(fp)
 4010c54:	108002c4 	addi	r2,r2,11
 4010c58:	108005f0 	cmpltui	r2,r2,23
 4010c5c:	1000051e 	bne	r2,zero,4010c74 <_realloc_r+0x90>
 4010c60:	e0bfe317 	ldw	r2,-116(fp)
 4010c64:	10c002c4 	addi	r3,r2,11
 4010c68:	00bffe04 	movi	r2,-8
 4010c6c:	1884703a 	and	r2,r3,r2
 4010c70:	00000106 	br	4010c78 <_realloc_r+0x94>
 4010c74:	00800404 	movi	r2,16
 4010c78:	e0bff115 	stw	r2,-60(fp)
  if (nb > INT_MAX || nb < bytes)
 4010c7c:	e0bff117 	ldw	r2,-60(fp)
 4010c80:	10000316 	blt	r2,zero,4010c90 <_realloc_r+0xac>
 4010c84:	e0fff117 	ldw	r3,-60(fp)
 4010c88:	e0bfe317 	ldw	r2,-116(fp)
 4010c8c:	1880052e 	bgeu	r3,r2,4010ca4 <_realloc_r+0xc0>
    RERRNO = ENOMEM;
 4010c90:	e0bfe517 	ldw	r2,-108(fp)
 4010c94:	00c00304 	movi	r3,12
 4010c98:	10c00015 	stw	r3,0(r2)
    return 0;
 4010c9c:	0005883a 	mov	r2,zero
 4010ca0:	0002c806 	br	40117c4 <_realloc_r+0xbe0>
  if ((long)(oldsize) < (long)(nb))  
 4010ca4:	e0fff217 	ldw	r3,-56(fp)
 4010ca8:	e0bff117 	ldw	r2,-60(fp)
 4010cac:	18828b0e 	bge	r3,r2,40116dc <_realloc_r+0xaf8>
    next = chunk_at_offset(oldp, oldsize);
 4010cb0:	e0fff317 	ldw	r3,-52(fp)
 4010cb4:	e0bff217 	ldw	r2,-56(fp)
 4010cb8:	1885883a 	add	r2,r3,r2
 4010cbc:	e0bffd15 	stw	r2,-12(fp)
    if (next == top || !inuse(next)) 
 4010cc0:	008100b4 	movhi	r2,1026
 4010cc4:	10ad9404 	addi	r2,r2,-18864
 4010cc8:	10800217 	ldw	r2,8(r2)
 4010ccc:	e0fffd17 	ldw	r3,-12(fp)
 4010cd0:	18800926 	beq	r3,r2,4010cf8 <_realloc_r+0x114>
 4010cd4:	e0bffd17 	ldw	r2,-12(fp)
 4010cd8:	10c00117 	ldw	r3,4(r2)
 4010cdc:	00bfff84 	movi	r2,-2
 4010ce0:	1884703a 	and	r2,r3,r2
 4010ce4:	e0fffd17 	ldw	r3,-12(fp)
 4010ce8:	1885883a 	add	r2,r3,r2
 4010cec:	10800117 	ldw	r2,4(r2)
 4010cf0:	1080004c 	andi	r2,r2,1
 4010cf4:	1000461e 	bne	r2,zero,4010e10 <_realloc_r+0x22c>
      nextsize = chunksize(next);
 4010cf8:	e0bffd17 	ldw	r2,-12(fp)
 4010cfc:	10c00117 	ldw	r3,4(r2)
 4010d00:	00bfff04 	movi	r2,-4
 4010d04:	1884703a 	and	r2,r3,r2
 4010d08:	e0bffc15 	stw	r2,-16(fp)
      if (next == top)
 4010d0c:	008100b4 	movhi	r2,1026
 4010d10:	10ad9404 	addi	r2,r2,-18864
 4010d14:	10800217 	ldw	r2,8(r2)
 4010d18:	e0fffd17 	ldw	r3,-12(fp)
 4010d1c:	1880251e 	bne	r3,r2,4010db4 <_realloc_r+0x1d0>
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
 4010d20:	e0fffc17 	ldw	r3,-16(fp)
 4010d24:	e0bffe17 	ldw	r2,-8(fp)
 4010d28:	1885883a 	add	r2,r3,r2
 4010d2c:	1007883a 	mov	r3,r2
 4010d30:	e0bff117 	ldw	r2,-60(fp)
 4010d34:	10800404 	addi	r2,r2,16
 4010d38:	18803816 	blt	r3,r2,4010e1c <_realloc_r+0x238>
          newsize += nextsize;
 4010d3c:	e0fffe17 	ldw	r3,-8(fp)
 4010d40:	e0bffc17 	ldw	r2,-16(fp)
 4010d44:	1885883a 	add	r2,r3,r2
 4010d48:	e0bffe15 	stw	r2,-8(fp)
          top = chunk_at_offset(oldp, nb);
 4010d4c:	008100b4 	movhi	r2,1026
 4010d50:	10ad9404 	addi	r2,r2,-18864
 4010d54:	e13ff317 	ldw	r4,-52(fp)
 4010d58:	e0fff117 	ldw	r3,-60(fp)
 4010d5c:	20c7883a 	add	r3,r4,r3
 4010d60:	10c00215 	stw	r3,8(r2)
          set_head(top, (newsize - nb) | PREV_INUSE);
 4010d64:	e0fffe17 	ldw	r3,-8(fp)
 4010d68:	e0bff117 	ldw	r2,-60(fp)
 4010d6c:	1887c83a 	sub	r3,r3,r2
 4010d70:	008100b4 	movhi	r2,1026
 4010d74:	10ad9404 	addi	r2,r2,-18864
 4010d78:	10800217 	ldw	r2,8(r2)
 4010d7c:	18c00054 	ori	r3,r3,1
 4010d80:	10c00115 	stw	r3,4(r2)
          set_head_size(oldp, nb);
 4010d84:	e0bff317 	ldw	r2,-52(fp)
 4010d88:	10800117 	ldw	r2,4(r2)
 4010d8c:	10c0004c 	andi	r3,r2,1
 4010d90:	e0bff117 	ldw	r2,-60(fp)
 4010d94:	1886b03a 	or	r3,r3,r2
 4010d98:	e0bff317 	ldw	r2,-52(fp)
 4010d9c:	10c00115 	stw	r3,4(r2)
	  MALLOC_UNLOCK;
 4010da0:	e13fe517 	ldw	r4,-108(fp)
 4010da4:	40186c40 	call	40186c4 <__malloc_unlock>
          return chunk2mem(oldp);
 4010da8:	e0bff317 	ldw	r2,-52(fp)
 4010dac:	10800204 	addi	r2,r2,8
 4010db0:	00028406 	br	40117c4 <_realloc_r+0xbe0>
      else if (((long)(nextsize + newsize) >= (long)(nb)))
 4010db4:	e0fffc17 	ldw	r3,-16(fp)
 4010db8:	e0bffe17 	ldw	r2,-8(fp)
 4010dbc:	1885883a 	add	r2,r3,r2
 4010dc0:	1007883a 	mov	r3,r2
 4010dc4:	e0bff117 	ldw	r2,-60(fp)
 4010dc8:	18801416 	blt	r3,r2,4010e1c <_realloc_r+0x238>
        unlink(next, bck, fwd);
 4010dcc:	e0bffd17 	ldw	r2,-12(fp)
 4010dd0:	10800317 	ldw	r2,12(r2)
 4010dd4:	e0bff015 	stw	r2,-64(fp)
 4010dd8:	e0bffd17 	ldw	r2,-12(fp)
 4010ddc:	10800217 	ldw	r2,8(r2)
 4010de0:	e0bfef15 	stw	r2,-68(fp)
 4010de4:	e0bfef17 	ldw	r2,-68(fp)
 4010de8:	e0fff017 	ldw	r3,-64(fp)
 4010dec:	10c00315 	stw	r3,12(r2)
 4010df0:	e0bff017 	ldw	r2,-64(fp)
 4010df4:	e0ffef17 	ldw	r3,-68(fp)
 4010df8:	10c00215 	stw	r3,8(r2)
        newsize  += nextsize;
 4010dfc:	e0fffe17 	ldw	r3,-8(fp)
 4010e00:	e0bffc17 	ldw	r2,-16(fp)
 4010e04:	1885883a 	add	r2,r3,r2
 4010e08:	e0bffe15 	stw	r2,-8(fp)
        goto split;
 4010e0c:	00023406 	br	40116e0 <_realloc_r+0xafc>
      next = 0;
 4010e10:	e03ffd15 	stw	zero,-12(fp)
      nextsize = 0;
 4010e14:	e03ffc15 	stw	zero,-16(fp)
 4010e18:	00000106 	br	4010e20 <_realloc_r+0x23c>
      if (next == top)
 4010e1c:	0001883a 	nop
    if (!prev_inuse(oldp))
 4010e20:	e0bff317 	ldw	r2,-52(fp)
 4010e24:	10800117 	ldw	r2,4(r2)
 4010e28:	1080004c 	andi	r2,r2,1
 4010e2c:	1001a91e 	bne	r2,zero,40114d4 <_realloc_r+0x8f0>
      prev = prev_chunk(oldp);
 4010e30:	e0bff317 	ldw	r2,-52(fp)
 4010e34:	10800017 	ldw	r2,0(r2)
 4010e38:	0085c83a 	sub	r2,zero,r2
 4010e3c:	e0fff317 	ldw	r3,-52(fp)
 4010e40:	1885883a 	add	r2,r3,r2
 4010e44:	e0bfee15 	stw	r2,-72(fp)
      prevsize = chunksize(prev);
 4010e48:	e0bfee17 	ldw	r2,-72(fp)
 4010e4c:	10c00117 	ldw	r3,4(r2)
 4010e50:	00bfff04 	movi	r2,-4
 4010e54:	1884703a 	and	r2,r3,r2
 4010e58:	e0bfed15 	stw	r2,-76(fp)
      if (next != 0)
 4010e5c:	e0bffd17 	ldw	r2,-12(fp)
 4010e60:	10012226 	beq	r2,zero,40112ec <_realloc_r+0x708>
        if (next == top)
 4010e64:	008100b4 	movhi	r2,1026
 4010e68:	10ad9404 	addi	r2,r2,-18864
 4010e6c:	10800217 	ldw	r2,8(r2)
 4010e70:	e0fffd17 	ldw	r3,-12(fp)
 4010e74:	1880951e 	bne	r3,r2,40110cc <_realloc_r+0x4e8>
          if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
 4010e78:	e0fffc17 	ldw	r3,-16(fp)
 4010e7c:	e0bfed17 	ldw	r2,-76(fp)
 4010e80:	1887883a 	add	r3,r3,r2
 4010e84:	e0bffe17 	ldw	r2,-8(fp)
 4010e88:	1885883a 	add	r2,r3,r2
 4010e8c:	1007883a 	mov	r3,r2
 4010e90:	e0bff117 	ldw	r2,-60(fp)
 4010e94:	10800404 	addi	r2,r2,16
 4010e98:	18811416 	blt	r3,r2,40112ec <_realloc_r+0x708>
            unlink(prev, bck, fwd);
 4010e9c:	e0bfee17 	ldw	r2,-72(fp)
 4010ea0:	10800317 	ldw	r2,12(r2)
 4010ea4:	e0bff015 	stw	r2,-64(fp)
 4010ea8:	e0bfee17 	ldw	r2,-72(fp)
 4010eac:	10800217 	ldw	r2,8(r2)
 4010eb0:	e0bfef15 	stw	r2,-68(fp)
 4010eb4:	e0bfef17 	ldw	r2,-68(fp)
 4010eb8:	e0fff017 	ldw	r3,-64(fp)
 4010ebc:	10c00315 	stw	r3,12(r2)
 4010ec0:	e0bff017 	ldw	r2,-64(fp)
 4010ec4:	e0ffef17 	ldw	r3,-68(fp)
 4010ec8:	10c00215 	stw	r3,8(r2)
            newp = prev;
 4010ecc:	e0bfee17 	ldw	r2,-72(fp)
 4010ed0:	e0bfff15 	stw	r2,-4(fp)
            newsize += prevsize + nextsize;
 4010ed4:	e0ffed17 	ldw	r3,-76(fp)
 4010ed8:	e0bffc17 	ldw	r2,-16(fp)
 4010edc:	1885883a 	add	r2,r3,r2
 4010ee0:	e0fffe17 	ldw	r3,-8(fp)
 4010ee4:	1885883a 	add	r2,r3,r2
 4010ee8:	e0bffe15 	stw	r2,-8(fp)
            newmem = chunk2mem(newp);
 4010eec:	e0bfff17 	ldw	r2,-4(fp)
 4010ef0:	10800204 	addi	r2,r2,8
 4010ef4:	e0bfec15 	stw	r2,-80(fp)
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
 4010ef8:	e0bff217 	ldw	r2,-56(fp)
 4010efc:	10bfff04 	addi	r2,r2,-4
 4010f00:	e0bfea15 	stw	r2,-88(fp)
 4010f04:	e0bfea17 	ldw	r2,-88(fp)
 4010f08:	10800968 	cmpgeui	r2,r2,37
 4010f0c:	1000521e 	bne	r2,zero,4011058 <_realloc_r+0x474>
 4010f10:	e0bfe417 	ldw	r2,-112(fp)
 4010f14:	e0bffb15 	stw	r2,-20(fp)
 4010f18:	e0bfec17 	ldw	r2,-80(fp)
 4010f1c:	e0bffa15 	stw	r2,-24(fp)
 4010f20:	e0bfea17 	ldw	r2,-88(fp)
 4010f24:	10800530 	cmpltui	r2,r2,20
 4010f28:	1000361e 	bne	r2,zero,4011004 <_realloc_r+0x420>
 4010f2c:	e0fffb17 	ldw	r3,-20(fp)
 4010f30:	18800104 	addi	r2,r3,4
 4010f34:	e0bffb15 	stw	r2,-20(fp)
 4010f38:	e0bffa17 	ldw	r2,-24(fp)
 4010f3c:	11000104 	addi	r4,r2,4
 4010f40:	e13ffa15 	stw	r4,-24(fp)
 4010f44:	18c00017 	ldw	r3,0(r3)
 4010f48:	10c00015 	stw	r3,0(r2)
 4010f4c:	e0fffb17 	ldw	r3,-20(fp)
 4010f50:	18800104 	addi	r2,r3,4
 4010f54:	e0bffb15 	stw	r2,-20(fp)
 4010f58:	e0bffa17 	ldw	r2,-24(fp)
 4010f5c:	11000104 	addi	r4,r2,4
 4010f60:	e13ffa15 	stw	r4,-24(fp)
 4010f64:	18c00017 	ldw	r3,0(r3)
 4010f68:	10c00015 	stw	r3,0(r2)
 4010f6c:	e0bfea17 	ldw	r2,-88(fp)
 4010f70:	10800730 	cmpltui	r2,r2,28
 4010f74:	1000231e 	bne	r2,zero,4011004 <_realloc_r+0x420>
 4010f78:	e0fffb17 	ldw	r3,-20(fp)
 4010f7c:	18800104 	addi	r2,r3,4
 4010f80:	e0bffb15 	stw	r2,-20(fp)
 4010f84:	e0bffa17 	ldw	r2,-24(fp)
 4010f88:	11000104 	addi	r4,r2,4
 4010f8c:	e13ffa15 	stw	r4,-24(fp)
 4010f90:	18c00017 	ldw	r3,0(r3)
 4010f94:	10c00015 	stw	r3,0(r2)
 4010f98:	e0fffb17 	ldw	r3,-20(fp)
 4010f9c:	18800104 	addi	r2,r3,4
 4010fa0:	e0bffb15 	stw	r2,-20(fp)
 4010fa4:	e0bffa17 	ldw	r2,-24(fp)
 4010fa8:	11000104 	addi	r4,r2,4
 4010fac:	e13ffa15 	stw	r4,-24(fp)
 4010fb0:	18c00017 	ldw	r3,0(r3)
 4010fb4:	10c00015 	stw	r3,0(r2)
 4010fb8:	e0bfea17 	ldw	r2,-88(fp)
 4010fbc:	10800930 	cmpltui	r2,r2,36
 4010fc0:	1000101e 	bne	r2,zero,4011004 <_realloc_r+0x420>
 4010fc4:	e0fffb17 	ldw	r3,-20(fp)
 4010fc8:	18800104 	addi	r2,r3,4
 4010fcc:	e0bffb15 	stw	r2,-20(fp)
 4010fd0:	e0bffa17 	ldw	r2,-24(fp)
 4010fd4:	11000104 	addi	r4,r2,4
 4010fd8:	e13ffa15 	stw	r4,-24(fp)
 4010fdc:	18c00017 	ldw	r3,0(r3)
 4010fe0:	10c00015 	stw	r3,0(r2)
 4010fe4:	e0fffb17 	ldw	r3,-20(fp)
 4010fe8:	18800104 	addi	r2,r3,4
 4010fec:	e0bffb15 	stw	r2,-20(fp)
 4010ff0:	e0bffa17 	ldw	r2,-24(fp)
 4010ff4:	11000104 	addi	r4,r2,4
 4010ff8:	e13ffa15 	stw	r4,-24(fp)
 4010ffc:	18c00017 	ldw	r3,0(r3)
 4011000:	10c00015 	stw	r3,0(r2)
 4011004:	e0fffb17 	ldw	r3,-20(fp)
 4011008:	18800104 	addi	r2,r3,4
 401100c:	e0bffb15 	stw	r2,-20(fp)
 4011010:	e0bffa17 	ldw	r2,-24(fp)
 4011014:	11000104 	addi	r4,r2,4
 4011018:	e13ffa15 	stw	r4,-24(fp)
 401101c:	18c00017 	ldw	r3,0(r3)
 4011020:	10c00015 	stw	r3,0(r2)
 4011024:	e0fffb17 	ldw	r3,-20(fp)
 4011028:	18800104 	addi	r2,r3,4
 401102c:	e0bffb15 	stw	r2,-20(fp)
 4011030:	e0bffa17 	ldw	r2,-24(fp)
 4011034:	11000104 	addi	r4,r2,4
 4011038:	e13ffa15 	stw	r4,-24(fp)
 401103c:	18c00017 	ldw	r3,0(r3)
 4011040:	10c00015 	stw	r3,0(r2)
 4011044:	e0bffb17 	ldw	r2,-20(fp)
 4011048:	10c00017 	ldw	r3,0(r2)
 401104c:	e0bffa17 	ldw	r2,-24(fp)
 4011050:	10c00015 	stw	r3,0(r2)
 4011054:	00000406 	br	4011068 <_realloc_r+0x484>
 4011058:	e1bfea17 	ldw	r6,-88(fp)
 401105c:	e17fe417 	ldw	r5,-112(fp)
 4011060:	e13fec17 	ldw	r4,-80(fp)
 4011064:	400ee640 	call	400ee64 <memmove>
            top = chunk_at_offset(newp, nb);
 4011068:	008100b4 	movhi	r2,1026
 401106c:	10ad9404 	addi	r2,r2,-18864
 4011070:	e13fff17 	ldw	r4,-4(fp)
 4011074:	e0fff117 	ldw	r3,-60(fp)
 4011078:	20c7883a 	add	r3,r4,r3
 401107c:	10c00215 	stw	r3,8(r2)
            set_head(top, (newsize - nb) | PREV_INUSE);
 4011080:	e0fffe17 	ldw	r3,-8(fp)
 4011084:	e0bff117 	ldw	r2,-60(fp)
 4011088:	1887c83a 	sub	r3,r3,r2
 401108c:	008100b4 	movhi	r2,1026
 4011090:	10ad9404 	addi	r2,r2,-18864
 4011094:	10800217 	ldw	r2,8(r2)
 4011098:	18c00054 	ori	r3,r3,1
 401109c:	10c00115 	stw	r3,4(r2)
            set_head_size(newp, nb);
 40110a0:	e0bfff17 	ldw	r2,-4(fp)
 40110a4:	10800117 	ldw	r2,4(r2)
 40110a8:	10c0004c 	andi	r3,r2,1
 40110ac:	e0bff117 	ldw	r2,-60(fp)
 40110b0:	1886b03a 	or	r3,r3,r2
 40110b4:	e0bfff17 	ldw	r2,-4(fp)
 40110b8:	10c00115 	stw	r3,4(r2)
	    MALLOC_UNLOCK;
 40110bc:	e13fe517 	ldw	r4,-108(fp)
 40110c0:	40186c40 	call	40186c4 <__malloc_unlock>
            return newmem;
 40110c4:	e0bfec17 	ldw	r2,-80(fp)
 40110c8:	0001be06 	br	40117c4 <_realloc_r+0xbe0>
        else if (((long)(nextsize + prevsize + newsize) >= (long)(nb)))
 40110cc:	e0fffc17 	ldw	r3,-16(fp)
 40110d0:	e0bfed17 	ldw	r2,-76(fp)
 40110d4:	1887883a 	add	r3,r3,r2
 40110d8:	e0bffe17 	ldw	r2,-8(fp)
 40110dc:	1885883a 	add	r2,r3,r2
 40110e0:	1007883a 	mov	r3,r2
 40110e4:	e0bff117 	ldw	r2,-60(fp)
 40110e8:	18808016 	blt	r3,r2,40112ec <_realloc_r+0x708>
          unlink(next, bck, fwd);
 40110ec:	e0bffd17 	ldw	r2,-12(fp)
 40110f0:	10800317 	ldw	r2,12(r2)
 40110f4:	e0bff015 	stw	r2,-64(fp)
 40110f8:	e0bffd17 	ldw	r2,-12(fp)
 40110fc:	10800217 	ldw	r2,8(r2)
 4011100:	e0bfef15 	stw	r2,-68(fp)
 4011104:	e0bfef17 	ldw	r2,-68(fp)
 4011108:	e0fff017 	ldw	r3,-64(fp)
 401110c:	10c00315 	stw	r3,12(r2)
 4011110:	e0bff017 	ldw	r2,-64(fp)
 4011114:	e0ffef17 	ldw	r3,-68(fp)
 4011118:	10c00215 	stw	r3,8(r2)
          unlink(prev, bck, fwd);
 401111c:	e0bfee17 	ldw	r2,-72(fp)
 4011120:	10800317 	ldw	r2,12(r2)
 4011124:	e0bff015 	stw	r2,-64(fp)
 4011128:	e0bfee17 	ldw	r2,-72(fp)
 401112c:	10800217 	ldw	r2,8(r2)
 4011130:	e0bfef15 	stw	r2,-68(fp)
 4011134:	e0bfef17 	ldw	r2,-68(fp)
 4011138:	e0fff017 	ldw	r3,-64(fp)
 401113c:	10c00315 	stw	r3,12(r2)
 4011140:	e0bff017 	ldw	r2,-64(fp)
 4011144:	e0ffef17 	ldw	r3,-68(fp)
 4011148:	10c00215 	stw	r3,8(r2)
          newp = prev;
 401114c:	e0bfee17 	ldw	r2,-72(fp)
 4011150:	e0bfff15 	stw	r2,-4(fp)
          newsize += nextsize + prevsize;
 4011154:	e0fffc17 	ldw	r3,-16(fp)
 4011158:	e0bfed17 	ldw	r2,-76(fp)
 401115c:	1885883a 	add	r2,r3,r2
 4011160:	e0fffe17 	ldw	r3,-8(fp)
 4011164:	1885883a 	add	r2,r3,r2
 4011168:	e0bffe15 	stw	r2,-8(fp)
          newmem = chunk2mem(newp);
 401116c:	e0bfff17 	ldw	r2,-4(fp)
 4011170:	10800204 	addi	r2,r2,8
 4011174:	e0bfec15 	stw	r2,-80(fp)
          MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
 4011178:	e0bff217 	ldw	r2,-56(fp)
 401117c:	10bfff04 	addi	r2,r2,-4
 4011180:	e0bfeb15 	stw	r2,-84(fp)
 4011184:	e0bfeb17 	ldw	r2,-84(fp)
 4011188:	10800968 	cmpgeui	r2,r2,37
 401118c:	1000521e 	bne	r2,zero,40112d8 <_realloc_r+0x6f4>
 4011190:	e0bfe417 	ldw	r2,-112(fp)
 4011194:	e0bff915 	stw	r2,-28(fp)
 4011198:	e0bfec17 	ldw	r2,-80(fp)
 401119c:	e0bff815 	stw	r2,-32(fp)
 40111a0:	e0bfeb17 	ldw	r2,-84(fp)
 40111a4:	10800530 	cmpltui	r2,r2,20
 40111a8:	1000361e 	bne	r2,zero,4011284 <_realloc_r+0x6a0>
 40111ac:	e0fff917 	ldw	r3,-28(fp)
 40111b0:	18800104 	addi	r2,r3,4
 40111b4:	e0bff915 	stw	r2,-28(fp)
 40111b8:	e0bff817 	ldw	r2,-32(fp)
 40111bc:	11000104 	addi	r4,r2,4
 40111c0:	e13ff815 	stw	r4,-32(fp)
 40111c4:	18c00017 	ldw	r3,0(r3)
 40111c8:	10c00015 	stw	r3,0(r2)
 40111cc:	e0fff917 	ldw	r3,-28(fp)
 40111d0:	18800104 	addi	r2,r3,4
 40111d4:	e0bff915 	stw	r2,-28(fp)
 40111d8:	e0bff817 	ldw	r2,-32(fp)
 40111dc:	11000104 	addi	r4,r2,4
 40111e0:	e13ff815 	stw	r4,-32(fp)
 40111e4:	18c00017 	ldw	r3,0(r3)
 40111e8:	10c00015 	stw	r3,0(r2)
 40111ec:	e0bfeb17 	ldw	r2,-84(fp)
 40111f0:	10800730 	cmpltui	r2,r2,28
 40111f4:	1000231e 	bne	r2,zero,4011284 <_realloc_r+0x6a0>
 40111f8:	e0fff917 	ldw	r3,-28(fp)
 40111fc:	18800104 	addi	r2,r3,4
 4011200:	e0bff915 	stw	r2,-28(fp)
 4011204:	e0bff817 	ldw	r2,-32(fp)
 4011208:	11000104 	addi	r4,r2,4
 401120c:	e13ff815 	stw	r4,-32(fp)
 4011210:	18c00017 	ldw	r3,0(r3)
 4011214:	10c00015 	stw	r3,0(r2)
 4011218:	e0fff917 	ldw	r3,-28(fp)
 401121c:	18800104 	addi	r2,r3,4
 4011220:	e0bff915 	stw	r2,-28(fp)
 4011224:	e0bff817 	ldw	r2,-32(fp)
 4011228:	11000104 	addi	r4,r2,4
 401122c:	e13ff815 	stw	r4,-32(fp)
 4011230:	18c00017 	ldw	r3,0(r3)
 4011234:	10c00015 	stw	r3,0(r2)
 4011238:	e0bfeb17 	ldw	r2,-84(fp)
 401123c:	10800930 	cmpltui	r2,r2,36
 4011240:	1000101e 	bne	r2,zero,4011284 <_realloc_r+0x6a0>
 4011244:	e0fff917 	ldw	r3,-28(fp)
 4011248:	18800104 	addi	r2,r3,4
 401124c:	e0bff915 	stw	r2,-28(fp)
 4011250:	e0bff817 	ldw	r2,-32(fp)
 4011254:	11000104 	addi	r4,r2,4
 4011258:	e13ff815 	stw	r4,-32(fp)
 401125c:	18c00017 	ldw	r3,0(r3)
 4011260:	10c00015 	stw	r3,0(r2)
 4011264:	e0fff917 	ldw	r3,-28(fp)
 4011268:	18800104 	addi	r2,r3,4
 401126c:	e0bff915 	stw	r2,-28(fp)
 4011270:	e0bff817 	ldw	r2,-32(fp)
 4011274:	11000104 	addi	r4,r2,4
 4011278:	e13ff815 	stw	r4,-32(fp)
 401127c:	18c00017 	ldw	r3,0(r3)
 4011280:	10c00015 	stw	r3,0(r2)
 4011284:	e0fff917 	ldw	r3,-28(fp)
 4011288:	18800104 	addi	r2,r3,4
 401128c:	e0bff915 	stw	r2,-28(fp)
 4011290:	e0bff817 	ldw	r2,-32(fp)
 4011294:	11000104 	addi	r4,r2,4
 4011298:	e13ff815 	stw	r4,-32(fp)
 401129c:	18c00017 	ldw	r3,0(r3)
 40112a0:	10c00015 	stw	r3,0(r2)
 40112a4:	e0fff917 	ldw	r3,-28(fp)
 40112a8:	18800104 	addi	r2,r3,4
 40112ac:	e0bff915 	stw	r2,-28(fp)
 40112b0:	e0bff817 	ldw	r2,-32(fp)
 40112b4:	11000104 	addi	r4,r2,4
 40112b8:	e13ff815 	stw	r4,-32(fp)
 40112bc:	18c00017 	ldw	r3,0(r3)
 40112c0:	10c00015 	stw	r3,0(r2)
 40112c4:	e0bff917 	ldw	r2,-28(fp)
 40112c8:	10c00017 	ldw	r3,0(r2)
 40112cc:	e0bff817 	ldw	r2,-32(fp)
 40112d0:	10c00015 	stw	r3,0(r2)
          goto split;
 40112d4:	00010206 	br	40116e0 <_realloc_r+0xafc>
          MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
 40112d8:	e1bfeb17 	ldw	r6,-84(fp)
 40112dc:	e17fe417 	ldw	r5,-112(fp)
 40112e0:	e13fec17 	ldw	r4,-80(fp)
 40112e4:	400ee640 	call	400ee64 <memmove>
          goto split;
 40112e8:	0000fd06 	br	40116e0 <_realloc_r+0xafc>
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
 40112ec:	e0bfee17 	ldw	r2,-72(fp)
 40112f0:	10007826 	beq	r2,zero,40114d4 <_realloc_r+0x8f0>
 40112f4:	e0ffed17 	ldw	r3,-76(fp)
 40112f8:	e0bffe17 	ldw	r2,-8(fp)
 40112fc:	1885883a 	add	r2,r3,r2
 4011300:	1007883a 	mov	r3,r2
 4011304:	e0bff117 	ldw	r2,-60(fp)
 4011308:	18807216 	blt	r3,r2,40114d4 <_realloc_r+0x8f0>
        unlink(prev, bck, fwd);
 401130c:	e0bfee17 	ldw	r2,-72(fp)
 4011310:	10800317 	ldw	r2,12(r2)
 4011314:	e0bff015 	stw	r2,-64(fp)
 4011318:	e0bfee17 	ldw	r2,-72(fp)
 401131c:	10800217 	ldw	r2,8(r2)
 4011320:	e0bfef15 	stw	r2,-68(fp)
 4011324:	e0bfef17 	ldw	r2,-68(fp)
 4011328:	e0fff017 	ldw	r3,-64(fp)
 401132c:	10c00315 	stw	r3,12(r2)
 4011330:	e0bff017 	ldw	r2,-64(fp)
 4011334:	e0ffef17 	ldw	r3,-68(fp)
 4011338:	10c00215 	stw	r3,8(r2)
        newp = prev;
 401133c:	e0bfee17 	ldw	r2,-72(fp)
 4011340:	e0bfff15 	stw	r2,-4(fp)
        newsize += prevsize;
 4011344:	e0fffe17 	ldw	r3,-8(fp)
 4011348:	e0bfed17 	ldw	r2,-76(fp)
 401134c:	1885883a 	add	r2,r3,r2
 4011350:	e0bffe15 	stw	r2,-8(fp)
        newmem = chunk2mem(newp);
 4011354:	e0bfff17 	ldw	r2,-4(fp)
 4011358:	10800204 	addi	r2,r2,8
 401135c:	e0bfec15 	stw	r2,-80(fp)
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
 4011360:	e0bff217 	ldw	r2,-56(fp)
 4011364:	10bfff04 	addi	r2,r2,-4
 4011368:	e0bfe915 	stw	r2,-92(fp)
 401136c:	e0bfe917 	ldw	r2,-92(fp)
 4011370:	10800968 	cmpgeui	r2,r2,37
 4011374:	1000521e 	bne	r2,zero,40114c0 <_realloc_r+0x8dc>
 4011378:	e0bfe417 	ldw	r2,-112(fp)
 401137c:	e0bff715 	stw	r2,-36(fp)
 4011380:	e0bfec17 	ldw	r2,-80(fp)
 4011384:	e0bff615 	stw	r2,-40(fp)
 4011388:	e0bfe917 	ldw	r2,-92(fp)
 401138c:	10800530 	cmpltui	r2,r2,20
 4011390:	1000361e 	bne	r2,zero,401146c <_realloc_r+0x888>
 4011394:	e0fff717 	ldw	r3,-36(fp)
 4011398:	18800104 	addi	r2,r3,4
 401139c:	e0bff715 	stw	r2,-36(fp)
 40113a0:	e0bff617 	ldw	r2,-40(fp)
 40113a4:	11000104 	addi	r4,r2,4
 40113a8:	e13ff615 	stw	r4,-40(fp)
 40113ac:	18c00017 	ldw	r3,0(r3)
 40113b0:	10c00015 	stw	r3,0(r2)
 40113b4:	e0fff717 	ldw	r3,-36(fp)
 40113b8:	18800104 	addi	r2,r3,4
 40113bc:	e0bff715 	stw	r2,-36(fp)
 40113c0:	e0bff617 	ldw	r2,-40(fp)
 40113c4:	11000104 	addi	r4,r2,4
 40113c8:	e13ff615 	stw	r4,-40(fp)
 40113cc:	18c00017 	ldw	r3,0(r3)
 40113d0:	10c00015 	stw	r3,0(r2)
 40113d4:	e0bfe917 	ldw	r2,-92(fp)
 40113d8:	10800730 	cmpltui	r2,r2,28
 40113dc:	1000231e 	bne	r2,zero,401146c <_realloc_r+0x888>
 40113e0:	e0fff717 	ldw	r3,-36(fp)
 40113e4:	18800104 	addi	r2,r3,4
 40113e8:	e0bff715 	stw	r2,-36(fp)
 40113ec:	e0bff617 	ldw	r2,-40(fp)
 40113f0:	11000104 	addi	r4,r2,4
 40113f4:	e13ff615 	stw	r4,-40(fp)
 40113f8:	18c00017 	ldw	r3,0(r3)
 40113fc:	10c00015 	stw	r3,0(r2)
 4011400:	e0fff717 	ldw	r3,-36(fp)
 4011404:	18800104 	addi	r2,r3,4
 4011408:	e0bff715 	stw	r2,-36(fp)
 401140c:	e0bff617 	ldw	r2,-40(fp)
 4011410:	11000104 	addi	r4,r2,4
 4011414:	e13ff615 	stw	r4,-40(fp)
 4011418:	18c00017 	ldw	r3,0(r3)
 401141c:	10c00015 	stw	r3,0(r2)
 4011420:	e0bfe917 	ldw	r2,-92(fp)
 4011424:	10800930 	cmpltui	r2,r2,36
 4011428:	1000101e 	bne	r2,zero,401146c <_realloc_r+0x888>
 401142c:	e0fff717 	ldw	r3,-36(fp)
 4011430:	18800104 	addi	r2,r3,4
 4011434:	e0bff715 	stw	r2,-36(fp)
 4011438:	e0bff617 	ldw	r2,-40(fp)
 401143c:	11000104 	addi	r4,r2,4
 4011440:	e13ff615 	stw	r4,-40(fp)
 4011444:	18c00017 	ldw	r3,0(r3)
 4011448:	10c00015 	stw	r3,0(r2)
 401144c:	e0fff717 	ldw	r3,-36(fp)
 4011450:	18800104 	addi	r2,r3,4
 4011454:	e0bff715 	stw	r2,-36(fp)
 4011458:	e0bff617 	ldw	r2,-40(fp)
 401145c:	11000104 	addi	r4,r2,4
 4011460:	e13ff615 	stw	r4,-40(fp)
 4011464:	18c00017 	ldw	r3,0(r3)
 4011468:	10c00015 	stw	r3,0(r2)
 401146c:	e0fff717 	ldw	r3,-36(fp)
 4011470:	18800104 	addi	r2,r3,4
 4011474:	e0bff715 	stw	r2,-36(fp)
 4011478:	e0bff617 	ldw	r2,-40(fp)
 401147c:	11000104 	addi	r4,r2,4
 4011480:	e13ff615 	stw	r4,-40(fp)
 4011484:	18c00017 	ldw	r3,0(r3)
 4011488:	10c00015 	stw	r3,0(r2)
 401148c:	e0fff717 	ldw	r3,-36(fp)
 4011490:	18800104 	addi	r2,r3,4
 4011494:	e0bff715 	stw	r2,-36(fp)
 4011498:	e0bff617 	ldw	r2,-40(fp)
 401149c:	11000104 	addi	r4,r2,4
 40114a0:	e13ff615 	stw	r4,-40(fp)
 40114a4:	18c00017 	ldw	r3,0(r3)
 40114a8:	10c00015 	stw	r3,0(r2)
 40114ac:	e0bff717 	ldw	r2,-36(fp)
 40114b0:	10c00017 	ldw	r3,0(r2)
 40114b4:	e0bff617 	ldw	r2,-40(fp)
 40114b8:	10c00015 	stw	r3,0(r2)
        goto split;
 40114bc:	00008806 	br	40116e0 <_realloc_r+0xafc>
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
 40114c0:	e1bfe917 	ldw	r6,-92(fp)
 40114c4:	e17fe417 	ldw	r5,-112(fp)
 40114c8:	e13fec17 	ldw	r4,-80(fp)
 40114cc:	400ee640 	call	400ee64 <memmove>
        goto split;
 40114d0:	00008306 	br	40116e0 <_realloc_r+0xafc>
    newmem = mALLOc (RCALL bytes);
 40114d4:	e17fe317 	ldw	r5,-116(fp)
 40114d8:	e13fe517 	ldw	r4,-108(fp)
 40114dc:	400e1400 	call	400e140 <_malloc_r>
 40114e0:	e0bfec15 	stw	r2,-80(fp)
    if (newmem == 0)  /* propagate failure */
 40114e4:	e0bfec17 	ldw	r2,-80(fp)
 40114e8:	1000041e 	bne	r2,zero,40114fc <_realloc_r+0x918>
      MALLOC_UNLOCK;
 40114ec:	e13fe517 	ldw	r4,-108(fp)
 40114f0:	40186c40 	call	40186c4 <__malloc_unlock>
      return 0;
 40114f4:	0005883a 	mov	r2,zero
 40114f8:	0000b206 	br	40117c4 <_realloc_r+0xbe0>
    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp)) 
 40114fc:	e0bfec17 	ldw	r2,-80(fp)
 4011500:	10bffe04 	addi	r2,r2,-8
 4011504:	e0bfff15 	stw	r2,-4(fp)
 4011508:	e0bff317 	ldw	r2,-52(fp)
 401150c:	10c00117 	ldw	r3,4(r2)
 4011510:	00bfff84 	movi	r2,-2
 4011514:	1884703a 	and	r2,r3,r2
 4011518:	e0fff317 	ldw	r3,-52(fp)
 401151c:	1885883a 	add	r2,r3,r2
 4011520:	e0ffff17 	ldw	r3,-4(fp)
 4011524:	18800a1e 	bne	r3,r2,4011550 <_realloc_r+0x96c>
      newsize += chunksize(newp);
 4011528:	e0bfff17 	ldw	r2,-4(fp)
 401152c:	10c00117 	ldw	r3,4(r2)
 4011530:	00bfff04 	movi	r2,-4
 4011534:	1884703a 	and	r2,r3,r2
 4011538:	e0fffe17 	ldw	r3,-8(fp)
 401153c:	1885883a 	add	r2,r3,r2
 4011540:	e0bffe15 	stw	r2,-8(fp)
      newp = oldp;
 4011544:	e0bff317 	ldw	r2,-52(fp)
 4011548:	e0bfff15 	stw	r2,-4(fp)
      goto split;
 401154c:	00006406 	br	40116e0 <_realloc_r+0xafc>
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
 4011550:	e0bff217 	ldw	r2,-56(fp)
 4011554:	10bfff04 	addi	r2,r2,-4
 4011558:	e0bfe815 	stw	r2,-96(fp)
 401155c:	e0bfe817 	ldw	r2,-96(fp)
 4011560:	10800968 	cmpgeui	r2,r2,37
 4011564:	1000521e 	bne	r2,zero,40116b0 <_realloc_r+0xacc>
 4011568:	e0bfe417 	ldw	r2,-112(fp)
 401156c:	e0bff515 	stw	r2,-44(fp)
 4011570:	e0bfec17 	ldw	r2,-80(fp)
 4011574:	e0bff415 	stw	r2,-48(fp)
 4011578:	e0bfe817 	ldw	r2,-96(fp)
 401157c:	10800530 	cmpltui	r2,r2,20
 4011580:	1000361e 	bne	r2,zero,401165c <_realloc_r+0xa78>
 4011584:	e0fff517 	ldw	r3,-44(fp)
 4011588:	18800104 	addi	r2,r3,4
 401158c:	e0bff515 	stw	r2,-44(fp)
 4011590:	e0bff417 	ldw	r2,-48(fp)
 4011594:	11000104 	addi	r4,r2,4
 4011598:	e13ff415 	stw	r4,-48(fp)
 401159c:	18c00017 	ldw	r3,0(r3)
 40115a0:	10c00015 	stw	r3,0(r2)
 40115a4:	e0fff517 	ldw	r3,-44(fp)
 40115a8:	18800104 	addi	r2,r3,4
 40115ac:	e0bff515 	stw	r2,-44(fp)
 40115b0:	e0bff417 	ldw	r2,-48(fp)
 40115b4:	11000104 	addi	r4,r2,4
 40115b8:	e13ff415 	stw	r4,-48(fp)
 40115bc:	18c00017 	ldw	r3,0(r3)
 40115c0:	10c00015 	stw	r3,0(r2)
 40115c4:	e0bfe817 	ldw	r2,-96(fp)
 40115c8:	10800730 	cmpltui	r2,r2,28
 40115cc:	1000231e 	bne	r2,zero,401165c <_realloc_r+0xa78>
 40115d0:	e0fff517 	ldw	r3,-44(fp)
 40115d4:	18800104 	addi	r2,r3,4
 40115d8:	e0bff515 	stw	r2,-44(fp)
 40115dc:	e0bff417 	ldw	r2,-48(fp)
 40115e0:	11000104 	addi	r4,r2,4
 40115e4:	e13ff415 	stw	r4,-48(fp)
 40115e8:	18c00017 	ldw	r3,0(r3)
 40115ec:	10c00015 	stw	r3,0(r2)
 40115f0:	e0fff517 	ldw	r3,-44(fp)
 40115f4:	18800104 	addi	r2,r3,4
 40115f8:	e0bff515 	stw	r2,-44(fp)
 40115fc:	e0bff417 	ldw	r2,-48(fp)
 4011600:	11000104 	addi	r4,r2,4
 4011604:	e13ff415 	stw	r4,-48(fp)
 4011608:	18c00017 	ldw	r3,0(r3)
 401160c:	10c00015 	stw	r3,0(r2)
 4011610:	e0bfe817 	ldw	r2,-96(fp)
 4011614:	10800930 	cmpltui	r2,r2,36
 4011618:	1000101e 	bne	r2,zero,401165c <_realloc_r+0xa78>
 401161c:	e0fff517 	ldw	r3,-44(fp)
 4011620:	18800104 	addi	r2,r3,4
 4011624:	e0bff515 	stw	r2,-44(fp)
 4011628:	e0bff417 	ldw	r2,-48(fp)
 401162c:	11000104 	addi	r4,r2,4
 4011630:	e13ff415 	stw	r4,-48(fp)
 4011634:	18c00017 	ldw	r3,0(r3)
 4011638:	10c00015 	stw	r3,0(r2)
 401163c:	e0fff517 	ldw	r3,-44(fp)
 4011640:	18800104 	addi	r2,r3,4
 4011644:	e0bff515 	stw	r2,-44(fp)
 4011648:	e0bff417 	ldw	r2,-48(fp)
 401164c:	11000104 	addi	r4,r2,4
 4011650:	e13ff415 	stw	r4,-48(fp)
 4011654:	18c00017 	ldw	r3,0(r3)
 4011658:	10c00015 	stw	r3,0(r2)
 401165c:	e0fff517 	ldw	r3,-44(fp)
 4011660:	18800104 	addi	r2,r3,4
 4011664:	e0bff515 	stw	r2,-44(fp)
 4011668:	e0bff417 	ldw	r2,-48(fp)
 401166c:	11000104 	addi	r4,r2,4
 4011670:	e13ff415 	stw	r4,-48(fp)
 4011674:	18c00017 	ldw	r3,0(r3)
 4011678:	10c00015 	stw	r3,0(r2)
 401167c:	e0fff517 	ldw	r3,-44(fp)
 4011680:	18800104 	addi	r2,r3,4
 4011684:	e0bff515 	stw	r2,-44(fp)
 4011688:	e0bff417 	ldw	r2,-48(fp)
 401168c:	11000104 	addi	r4,r2,4
 4011690:	e13ff415 	stw	r4,-48(fp)
 4011694:	18c00017 	ldw	r3,0(r3)
 4011698:	10c00015 	stw	r3,0(r2)
 401169c:	e0bff517 	ldw	r2,-44(fp)
 40116a0:	10c00017 	ldw	r3,0(r2)
 40116a4:	e0bff417 	ldw	r2,-48(fp)
 40116a8:	10c00015 	stw	r3,0(r2)
 40116ac:	00000406 	br	40116c0 <_realloc_r+0xadc>
 40116b0:	e1bfe817 	ldw	r6,-96(fp)
 40116b4:	e17fe417 	ldw	r5,-112(fp)
 40116b8:	e13fec17 	ldw	r4,-80(fp)
 40116bc:	400ee640 	call	400ee64 <memmove>
    fREe(RCALL oldmem);
 40116c0:	e17fe417 	ldw	r5,-112(fp)
 40116c4:	e13fe517 	ldw	r4,-108(fp)
 40116c8:	400cb0c0 	call	400cb0c <_free_r>
    MALLOC_UNLOCK;
 40116cc:	e13fe517 	ldw	r4,-108(fp)
 40116d0:	40186c40 	call	40186c4 <__malloc_unlock>
    return newmem;
 40116d4:	e0bfec17 	ldw	r2,-80(fp)
 40116d8:	00003a06 	br	40117c4 <_realloc_r+0xbe0>
 split:  /* split off extra room in old or expanded chunk */
 40116dc:	0001883a 	nop
  remainder_size = long_sub_size_t(newsize, nb);
 40116e0:	e0fffe17 	ldw	r3,-8(fp)
 40116e4:	e0bff117 	ldw	r2,-60(fp)
 40116e8:	1885c83a 	sub	r2,r3,r2
 40116ec:	e0bfe715 	stw	r2,-100(fp)
  if (remainder_size >= (long)MINSIZE) /* split off remainder */
 40116f0:	e0bfe717 	ldw	r2,-100(fp)
 40116f4:	10800430 	cmpltui	r2,r2,16
 40116f8:	10001e1e 	bne	r2,zero,4011774 <_realloc_r+0xb90>
    remainder = chunk_at_offset(newp, nb);
 40116fc:	e0ffff17 	ldw	r3,-4(fp)
 4011700:	e0bff117 	ldw	r2,-60(fp)
 4011704:	1885883a 	add	r2,r3,r2
 4011708:	e0bfe615 	stw	r2,-104(fp)
    set_head_size(newp, nb);
 401170c:	e0bfff17 	ldw	r2,-4(fp)
 4011710:	10800117 	ldw	r2,4(r2)
 4011714:	10c0004c 	andi	r3,r2,1
 4011718:	e0bff117 	ldw	r2,-60(fp)
 401171c:	1886b03a 	or	r3,r3,r2
 4011720:	e0bfff17 	ldw	r2,-4(fp)
 4011724:	10c00115 	stw	r3,4(r2)
    set_head(remainder, remainder_size | PREV_INUSE);
 4011728:	e0bfe717 	ldw	r2,-100(fp)
 401172c:	10c00054 	ori	r3,r2,1
 4011730:	e0bfe617 	ldw	r2,-104(fp)
 4011734:	10c00115 	stw	r3,4(r2)
    set_inuse_bit_at_offset(remainder, remainder_size);
 4011738:	e0ffe617 	ldw	r3,-104(fp)
 401173c:	e0bfe717 	ldw	r2,-100(fp)
 4011740:	1885883a 	add	r2,r3,r2
 4011744:	10c00117 	ldw	r3,4(r2)
 4011748:	e13fe617 	ldw	r4,-104(fp)
 401174c:	e0bfe717 	ldw	r2,-100(fp)
 4011750:	2085883a 	add	r2,r4,r2
 4011754:	18c00054 	ori	r3,r3,1
 4011758:	10c00115 	stw	r3,4(r2)
    fREe(RCALL chunk2mem(remainder)); /* let free() deal with it */
 401175c:	e0bfe617 	ldw	r2,-104(fp)
 4011760:	10800204 	addi	r2,r2,8
 4011764:	100b883a 	mov	r5,r2
 4011768:	e13fe517 	ldw	r4,-108(fp)
 401176c:	400cb0c0 	call	400cb0c <_free_r>
 4011770:	00001006 	br	40117b4 <_realloc_r+0xbd0>
    set_head_size(newp, newsize);
 4011774:	e0bfff17 	ldw	r2,-4(fp)
 4011778:	10800117 	ldw	r2,4(r2)
 401177c:	10c0004c 	andi	r3,r2,1
 4011780:	e0bffe17 	ldw	r2,-8(fp)
 4011784:	1886b03a 	or	r3,r3,r2
 4011788:	e0bfff17 	ldw	r2,-4(fp)
 401178c:	10c00115 	stw	r3,4(r2)
    set_inuse_bit_at_offset(newp, newsize);
 4011790:	e0ffff17 	ldw	r3,-4(fp)
 4011794:	e0bffe17 	ldw	r2,-8(fp)
 4011798:	1885883a 	add	r2,r3,r2
 401179c:	10c00117 	ldw	r3,4(r2)
 40117a0:	e13fff17 	ldw	r4,-4(fp)
 40117a4:	e0bffe17 	ldw	r2,-8(fp)
 40117a8:	2085883a 	add	r2,r4,r2
 40117ac:	18c00054 	ori	r3,r3,1
 40117b0:	10c00115 	stw	r3,4(r2)
  MALLOC_UNLOCK;
 40117b4:	e13fe517 	ldw	r4,-108(fp)
 40117b8:	40186c40 	call	40186c4 <__malloc_unlock>
  return chunk2mem(newp);
 40117bc:	e0bfff17 	ldw	r2,-4(fp)
 40117c0:	10800204 	addi	r2,r2,8
}
 40117c4:	e037883a 	mov	sp,fp
 40117c8:	dfc00117 	ldw	ra,4(sp)
 40117cc:	df000017 	ldw	fp,0(sp)
 40117d0:	dec00204 	addi	sp,sp,8
 40117d4:	f800283a 	ret

040117d8 <_sbrk_r>:
*/

void *
_sbrk_r (struct _reent *ptr,
     ptrdiff_t incr)
{
 40117d8:	defffb04 	addi	sp,sp,-20
 40117dc:	dfc00415 	stw	ra,16(sp)
 40117e0:	df000315 	stw	fp,12(sp)
 40117e4:	df000304 	addi	fp,sp,12
 40117e8:	e13ffe15 	stw	r4,-8(fp)
 40117ec:	e17ffd15 	stw	r5,-12(fp)
  char *ret;
  void *_sbrk(ptrdiff_t);

  errno = 0;
 40117f0:	d0272715 	stw	zero,-25444(gp)
  if ((ret = (char *)(_sbrk (incr))) == (void *) -1 && errno != 0)
 40117f4:	e13ffd17 	ldw	r4,-12(fp)
 40117f8:	401889c0 	call	401889c <sbrk>
 40117fc:	e0bfff15 	stw	r2,-4(fp)
 4011800:	e0bfff17 	ldw	r2,-4(fp)
 4011804:	10bfffd8 	cmpnei	r2,r2,-1
 4011808:	1000051e 	bne	r2,zero,4011820 <_sbrk_r+0x48>
 401180c:	d0a72717 	ldw	r2,-25444(gp)
 4011810:	10000326 	beq	r2,zero,4011820 <_sbrk_r+0x48>
    ptr->_errno = errno;
 4011814:	d0e72717 	ldw	r3,-25444(gp)
 4011818:	e0bffe17 	ldw	r2,-8(fp)
 401181c:	10c00015 	stw	r3,0(r2)
  return ret;
 4011820:	e0bfff17 	ldw	r2,-4(fp)
}
 4011824:	e037883a 	mov	sp,fp
 4011828:	dfc00117 	ldw	ra,4(sp)
 401182c:	df000017 	ldw	fp,0(sp)
 4011830:	dec00204 	addi	sp,sp,8
 4011834:	f800283a 	ret

04011838 <__sread>:
_READ_WRITE_RETURN_TYPE
__sread (struct _reent *ptr,
       void *cookie,
       char *buf,
       _READ_WRITE_BUFSIZE_TYPE n)
{
 4011838:	defff804 	addi	sp,sp,-32
 401183c:	dfc00715 	stw	ra,28(sp)
 4011840:	df000615 	stw	fp,24(sp)
 4011844:	dc400515 	stw	r17,20(sp)
 4011848:	dc000415 	stw	r16,16(sp)
 401184c:	df000604 	addi	fp,sp,24
 4011850:	e13ffd15 	stw	r4,-12(fp)
 4011854:	e17ffc15 	stw	r5,-16(fp)
 4011858:	e1bffb15 	stw	r6,-20(fp)
 401185c:	e1fffa15 	stw	r7,-24(fp)
  register FILE *fp = (FILE *) cookie;
 4011860:	e43ffc17 	ldw	r16,-16(fp)
  int oldmode = 0;
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  ret = _read_r (ptr, fp->_file, buf, n);
 4011864:	8080038b 	ldhu	r2,14(r16)
 4011868:	10bfffcc 	andi	r2,r2,65535
 401186c:	10a0001c 	xori	r2,r2,32768
 4011870:	10a00004 	addi	r2,r2,-32768
 4011874:	e0fffa17 	ldw	r3,-24(fp)
 4011878:	180f883a 	mov	r7,r3
 401187c:	e1bffb17 	ldw	r6,-20(fp)
 4011880:	100b883a 	mov	r5,r2
 4011884:	e13ffd17 	ldw	r4,-12(fp)
 4011888:	4013b600 	call	4013b60 <_read_r>
 401188c:	1023883a 	mov	r17,r2
    setmode (fp->_file, oldmode);
#endif

  /* If the read succeeded, update the current offset.  */

  if (ret >= 0)
 4011890:	88000416 	blt	r17,zero,40118a4 <__sread+0x6c>
    fp->_offset += ret;
 4011894:	80801417 	ldw	r2,80(r16)
 4011898:	8885883a 	add	r2,r17,r2
 401189c:	80801415 	stw	r2,80(r16)
 40118a0:	00000406 	br	40118b4 <__sread+0x7c>
  else
    fp->_flags &= ~__SOFF;	/* paranoia */
 40118a4:	80c0030b 	ldhu	r3,12(r16)
 40118a8:	00bbffc4 	movi	r2,-4097
 40118ac:	1884703a 	and	r2,r3,r2
 40118b0:	8080030d 	sth	r2,12(r16)
  return ret;
 40118b4:	8805883a 	mov	r2,r17
}
 40118b8:	e6fffe04 	addi	sp,fp,-8
 40118bc:	dfc00317 	ldw	ra,12(sp)
 40118c0:	df000217 	ldw	fp,8(sp)
 40118c4:	dc400117 	ldw	r17,4(sp)
 40118c8:	dc000017 	ldw	r16,0(sp)
 40118cc:	dec00404 	addi	sp,sp,16
 40118d0:	f800283a 	ret

040118d4 <__seofread>:
_READ_WRITE_RETURN_TYPE
__seofread (struct _reent *_ptr,
       void *cookie,
       char *buf,
       _READ_WRITE_BUFSIZE_TYPE len)
{
 40118d4:	defffb04 	addi	sp,sp,-20
 40118d8:	df000415 	stw	fp,16(sp)
 40118dc:	df000404 	addi	fp,sp,16
 40118e0:	e13fff15 	stw	r4,-4(fp)
 40118e4:	e17ffe15 	stw	r5,-8(fp)
 40118e8:	e1bffd15 	stw	r6,-12(fp)
 40118ec:	e1fffc15 	stw	r7,-16(fp)
  return 0;
 40118f0:	0005883a 	mov	r2,zero
}
 40118f4:	e037883a 	mov	sp,fp
 40118f8:	df000017 	ldw	fp,0(sp)
 40118fc:	dec00104 	addi	sp,sp,4
 4011900:	f800283a 	ret

04011904 <__swrite>:
_READ_WRITE_RETURN_TYPE
__swrite (struct _reent *ptr,
       void *cookie,
       char const *buf,
       _READ_WRITE_BUFSIZE_TYPE n)
{
 4011904:	defff804 	addi	sp,sp,-32
 4011908:	dfc00715 	stw	ra,28(sp)
 401190c:	df000615 	stw	fp,24(sp)
 4011910:	dc000515 	stw	r16,20(sp)
 4011914:	df000604 	addi	fp,sp,24
 4011918:	e13ffd15 	stw	r4,-12(fp)
 401191c:	e17ffc15 	stw	r5,-16(fp)
 4011920:	e1bffb15 	stw	r6,-20(fp)
 4011924:	e1fffa15 	stw	r7,-24(fp)
  register FILE *fp = (FILE *) cookie;
 4011928:	e43ffc17 	ldw	r16,-16(fp)
  ssize_t w;
#ifdef __SCLE
  int oldmode=0;
#endif

  if (fp->_flags & __SAPP)
 401192c:	8080030b 	ldhu	r2,12(r16)
 4011930:	10bfffcc 	andi	r2,r2,65535
 4011934:	1080400c 	andi	r2,r2,256
 4011938:	10000926 	beq	r2,zero,4011960 <__swrite+0x5c>
    _lseek_r (ptr, fp->_file, (_off_t) 0, SEEK_END);
 401193c:	8080038b 	ldhu	r2,14(r16)
 4011940:	10bfffcc 	andi	r2,r2,65535
 4011944:	10a0001c 	xori	r2,r2,32768
 4011948:	10a00004 	addi	r2,r2,-32768
 401194c:	01c00084 	movi	r7,2
 4011950:	000d883a 	mov	r6,zero
 4011954:	100b883a 	mov	r5,r2
 4011958:	e13ffd17 	ldw	r4,-12(fp)
 401195c:	40139b80 	call	40139b8 <_lseek_r>
  fp->_flags &= ~__SOFF;	/* in case O_APPEND mode is set */
 4011960:	80c0030b 	ldhu	r3,12(r16)
 4011964:	00bbffc4 	movi	r2,-4097
 4011968:	1884703a 	and	r2,r3,r2
 401196c:	8080030d 	sth	r2,12(r16)
#ifdef __SCLE
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  w = _write_r (ptr, fp->_file, buf, n);
 4011970:	8080038b 	ldhu	r2,14(r16)
 4011974:	10bfffcc 	andi	r2,r2,65535
 4011978:	10a0001c 	xori	r2,r2,32768
 401197c:	10a00004 	addi	r2,r2,-32768
 4011980:	e0fffa17 	ldw	r3,-24(fp)
 4011984:	180f883a 	mov	r7,r3
 4011988:	e1bffb17 	ldw	r6,-20(fp)
 401198c:	100b883a 	mov	r5,r2
 4011990:	e13ffd17 	ldw	r4,-12(fp)
 4011994:	4012fdc0 	call	4012fdc <_write_r>
 4011998:	e0bffe15 	stw	r2,-8(fp)
#ifdef __SCLE
  if (oldmode)
    setmode (fp->_file, oldmode);
#endif

  return w;
 401199c:	e0bffe17 	ldw	r2,-8(fp)
}
 40119a0:	e6ffff04 	addi	sp,fp,-4
 40119a4:	dfc00217 	ldw	ra,8(sp)
 40119a8:	df000117 	ldw	fp,4(sp)
 40119ac:	dc000017 	ldw	r16,0(sp)
 40119b0:	dec00304 	addi	sp,sp,12
 40119b4:	f800283a 	ret

040119b8 <__sseek>:
_fpos_t
__sseek (struct _reent *ptr,
       void *cookie,
       _fpos_t offset,
       int whence)
{
 40119b8:	defff804 	addi	sp,sp,-32
 40119bc:	dfc00715 	stw	ra,28(sp)
 40119c0:	df000615 	stw	fp,24(sp)
 40119c4:	dc400515 	stw	r17,20(sp)
 40119c8:	dc000415 	stw	r16,16(sp)
 40119cc:	df000604 	addi	fp,sp,24
 40119d0:	e13ffd15 	stw	r4,-12(fp)
 40119d4:	e17ffc15 	stw	r5,-16(fp)
 40119d8:	e1bffb15 	stw	r6,-20(fp)
 40119dc:	e1fffa15 	stw	r7,-24(fp)
  register FILE *fp = (FILE *) cookie;
 40119e0:	e43ffc17 	ldw	r16,-16(fp)
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
 40119e4:	8080038b 	ldhu	r2,14(r16)
 40119e8:	10bfffcc 	andi	r2,r2,65535
 40119ec:	10a0001c 	xori	r2,r2,32768
 40119f0:	10a00004 	addi	r2,r2,-32768
 40119f4:	e1fffa17 	ldw	r7,-24(fp)
 40119f8:	e1bffb17 	ldw	r6,-20(fp)
 40119fc:	100b883a 	mov	r5,r2
 4011a00:	e13ffd17 	ldw	r4,-12(fp)
 4011a04:	40139b80 	call	40139b8 <_lseek_r>
 4011a08:	1023883a 	mov	r17,r2
  if (ret == -1L)
 4011a0c:	88bfffd8 	cmpnei	r2,r17,-1
 4011a10:	1000051e 	bne	r2,zero,4011a28 <__sseek+0x70>
    fp->_flags &= ~__SOFF;
 4011a14:	80c0030b 	ldhu	r3,12(r16)
 4011a18:	00bbffc4 	movi	r2,-4097
 4011a1c:	1884703a 	and	r2,r3,r2
 4011a20:	8080030d 	sth	r2,12(r16)
 4011a24:	00000406 	br	4011a38 <__sseek+0x80>
  else
    {
      fp->_flags |= __SOFF;
 4011a28:	8080030b 	ldhu	r2,12(r16)
 4011a2c:	10840014 	ori	r2,r2,4096
 4011a30:	8080030d 	sth	r2,12(r16)
      fp->_offset = ret;
 4011a34:	84401415 	stw	r17,80(r16)
    }
  return ret;
 4011a38:	8805883a 	mov	r2,r17
}
 4011a3c:	e6fffe04 	addi	sp,fp,-8
 4011a40:	dfc00317 	ldw	ra,12(sp)
 4011a44:	df000217 	ldw	fp,8(sp)
 4011a48:	dc400117 	ldw	r17,4(sp)
 4011a4c:	dc000017 	ldw	r16,0(sp)
 4011a50:	dec00404 	addi	sp,sp,16
 4011a54:	f800283a 	ret

04011a58 <__sclose>:

int
__sclose (struct _reent *ptr,
       void *cookie)
{
 4011a58:	defffb04 	addi	sp,sp,-20
 4011a5c:	dfc00415 	stw	ra,16(sp)
 4011a60:	df000315 	stw	fp,12(sp)
 4011a64:	df000304 	addi	fp,sp,12
 4011a68:	e13ffe15 	stw	r4,-8(fp)
 4011a6c:	e17ffd15 	stw	r5,-12(fp)
  FILE *fp = (FILE *) cookie;
 4011a70:	e0bffd17 	ldw	r2,-12(fp)
 4011a74:	e0bfff15 	stw	r2,-4(fp)

  return _close_r (ptr, fp->_file);
 4011a78:	e0bfff17 	ldw	r2,-4(fp)
 4011a7c:	1080038b 	ldhu	r2,14(r2)
 4011a80:	10bfffcc 	andi	r2,r2,65535
 4011a84:	10a0001c 	xori	r2,r2,32768
 4011a88:	10a00004 	addi	r2,r2,-32768
 4011a8c:	100b883a 	mov	r5,r2
 4011a90:	e13ffe17 	ldw	r4,-8(fp)
 4011a94:	401304c0 	call	401304c <_close_r>
}
 4011a98:	e037883a 	mov	sp,fp
 4011a9c:	dfc00117 	ldw	ra,4(sp)
 4011aa0:	df000017 	ldw	fp,0(sp)
 4011aa4:	dec00204 	addi	sp,sp,8
 4011aa8:	f800283a 	ret

04011aac <__sprint_r>:
{
 4011aac:	defff604 	addi	sp,sp,-40
 4011ab0:	dfc00915 	stw	ra,36(sp)
 4011ab4:	df000815 	stw	fp,32(sp)
 4011ab8:	dc400715 	stw	r17,28(sp)
 4011abc:	dc000615 	stw	r16,24(sp)
 4011ac0:	df000804 	addi	fp,sp,32
 4011ac4:	e13ff915 	stw	r4,-28(fp)
 4011ac8:	e17ff815 	stw	r5,-32(fp)
 4011acc:	3021883a 	mov	r16,r6
	register int err = 0;
 4011ad0:	0023883a 	mov	r17,zero
	if (uio->uio_resid == 0) {
 4011ad4:	80800217 	ldw	r2,8(r16)
 4011ad8:	1000031e 	bne	r2,zero,4011ae8 <__sprint_r+0x3c>
		uio->uio_iovcnt = 0;
 4011adc:	80000115 	stw	zero,4(r16)
		return (0);
 4011ae0:	0005883a 	mov	r2,zero
 4011ae4:	00003606 	br	4011bc0 <__sprint_r+0x114>
	if (fp->_flags2 & __SWID) {
 4011ae8:	e0bff817 	ldw	r2,-32(fp)
 4011aec:	10801917 	ldw	r2,100(r2)
 4011af0:	1088000c 	andi	r2,r2,8192
 4011af4:	10002a26 	beq	r2,zero,4011ba0 <__sprint_r+0xf4>
		iov = uio->uio_iov;
 4011af8:	80800017 	ldw	r2,0(r16)
 4011afc:	e0bffd15 	stw	r2,-12(fp)
		for (; uio->uio_resid != 0;
 4011b00:	00002406 	br	4011b94 <__sprint_r+0xe8>
			p = (wchar_t *) iov->iov_base;
 4011b04:	e0bffd17 	ldw	r2,-12(fp)
 4011b08:	10800017 	ldw	r2,0(r2)
 4011b0c:	e0bffb15 	stw	r2,-20(fp)
			len = iov->iov_len / sizeof (wchar_t);
 4011b10:	e0bffd17 	ldw	r2,-12(fp)
 4011b14:	10800117 	ldw	r2,4(r2)
 4011b18:	1004d0ba 	srli	r2,r2,2
 4011b1c:	e0bffa15 	stw	r2,-24(fp)
			for (i = 0; i < len; i++) {
 4011b20:	e03ffc15 	stw	zero,-16(fp)
 4011b24:	00001006 	br	4011b68 <__sprint_r+0xbc>
				if (_fputwc_r (ptr, p[i], fp) == WEOF) {
 4011b28:	e0bffc17 	ldw	r2,-16(fp)
 4011b2c:	100490ba 	slli	r2,r2,2
 4011b30:	e0fffb17 	ldw	r3,-20(fp)
 4011b34:	1885883a 	add	r2,r3,r2
 4011b38:	10800017 	ldw	r2,0(r2)
 4011b3c:	e1bff817 	ldw	r6,-32(fp)
 4011b40:	100b883a 	mov	r5,r2
 4011b44:	e13ff917 	ldw	r4,-28(fp)
 4011b48:	40136bc0 	call	40136bc <_fputwc_r>
 4011b4c:	10bfffd8 	cmpnei	r2,r2,-1
 4011b50:	1000021e 	bne	r2,zero,4011b5c <__sprint_r+0xb0>
					err = -1;
 4011b54:	047fffc4 	movi	r17,-1
					goto out;
 4011b58:	00001606 	br	4011bb4 <__sprint_r+0x108>
			for (i = 0; i < len; i++) {
 4011b5c:	e0bffc17 	ldw	r2,-16(fp)
 4011b60:	10800044 	addi	r2,r2,1
 4011b64:	e0bffc15 	stw	r2,-16(fp)
 4011b68:	e0fffc17 	ldw	r3,-16(fp)
 4011b6c:	e0bffa17 	ldw	r2,-24(fp)
 4011b70:	18bfed16 	blt	r3,r2,4011b28 <__sprint_r+0x7c>
		     uio->uio_resid -= len * sizeof (wchar_t), iov++) {
 4011b74:	80c00217 	ldw	r3,8(r16)
 4011b78:	e0bffa17 	ldw	r2,-24(fp)
 4011b7c:	100490ba 	slli	r2,r2,2
 4011b80:	1885c83a 	sub	r2,r3,r2
 4011b84:	80800215 	stw	r2,8(r16)
 4011b88:	e0bffd17 	ldw	r2,-12(fp)
 4011b8c:	10800204 	addi	r2,r2,8
 4011b90:	e0bffd15 	stw	r2,-12(fp)
		for (; uio->uio_resid != 0;
 4011b94:	80800217 	ldw	r2,8(r16)
 4011b98:	103fda1e 	bne	r2,zero,4011b04 <__sprint_r+0x58>
 4011b9c:	00000506 	br	4011bb4 <__sprint_r+0x108>
		err = __sfvwrite_r(ptr, fp, uio);
 4011ba0:	800d883a 	mov	r6,r16
 4011ba4:	e17ff817 	ldw	r5,-32(fp)
 4011ba8:	e13ff917 	ldw	r4,-28(fp)
 4011bac:	400d2280 	call	400d228 <__sfvwrite_r>
 4011bb0:	1023883a 	mov	r17,r2
	uio->uio_resid = 0;
 4011bb4:	80000215 	stw	zero,8(r16)
	uio->uio_iovcnt = 0;
 4011bb8:	80000115 	stw	zero,4(r16)
	return (err);
 4011bbc:	8805883a 	mov	r2,r17
}
 4011bc0:	e6fffe04 	addi	sp,fp,-8
 4011bc4:	dfc00317 	ldw	ra,12(sp)
 4011bc8:	df000217 	ldw	fp,8(sp)
 4011bcc:	dc400117 	ldw	r17,4(sp)
 4011bd0:	dc000017 	ldw	r16,0(sp)
 4011bd4:	dec00404 	addi	sp,sp,16
 4011bd8:	f800283a 	ret

04011bdc <__sbprintf>:
{
 4011bdc:	defedf04 	addi	sp,sp,-1156
 4011be0:	dfc12015 	stw	ra,1152(sp)
 4011be4:	df011f15 	stw	fp,1148(sp)
 4011be8:	dc011e15 	stw	r16,1144(sp)
 4011bec:	df011f04 	addi	fp,sp,1148
 4011bf0:	e13ee315 	stw	r4,-1140(fp)
 4011bf4:	2821883a 	mov	r16,r5
 4011bf8:	e1bee215 	stw	r6,-1144(fp)
 4011bfc:	e1fee115 	stw	r7,-1148(fp)
	fake._flags = fp->_flags & ~__SNBF;
 4011c00:	80c0030b 	ldhu	r3,12(r16)
 4011c04:	00bfff44 	movi	r2,-3
 4011c08:	1884703a 	and	r2,r3,r2
 4011c0c:	e0bfe70d 	sth	r2,-100(fp)
	fake._flags2 = fp->_flags2;
 4011c10:	80801917 	ldw	r2,100(r16)
 4011c14:	e0bffd15 	stw	r2,-12(fp)
	fake._file = fp->_file;
 4011c18:	8080038b 	ldhu	r2,14(r16)
 4011c1c:	e0bfe78d 	sth	r2,-98(fp)
	fake._cookie = fp->_cookie;
 4011c20:	80800717 	ldw	r2,28(r16)
 4011c24:	e0bfeb15 	stw	r2,-84(fp)
	fake._write = fp->_write;
 4011c28:	80800917 	ldw	r2,36(r16)
 4011c2c:	e0bfed15 	stw	r2,-76(fp)
	fake._bf._base = fake._p = buf;
 4011c30:	e0bee404 	addi	r2,fp,-1136
 4011c34:	e0bfe415 	stw	r2,-112(fp)
 4011c38:	e0bfe417 	ldw	r2,-112(fp)
 4011c3c:	e0bfe815 	stw	r2,-96(fp)
	fake._bf._size = fake._w = sizeof (buf);
 4011c40:	00810004 	movi	r2,1024
 4011c44:	e0bfe615 	stw	r2,-104(fp)
 4011c48:	e0bfe617 	ldw	r2,-104(fp)
 4011c4c:	e0bfe915 	stw	r2,-92(fp)
	fake._lbfsize = 0;	/* not actually used, but Just In Case */
 4011c50:	e03fea15 	stw	zero,-88(fp)
	ret = _VFPRINTF_R (rptr, &fake, fmt, ap);
 4011c54:	e0bfe404 	addi	r2,fp,-112
 4011c58:	e1fee117 	ldw	r7,-1148(fp)
 4011c5c:	e1bee217 	ldw	r6,-1144(fp)
 4011c60:	100b883a 	mov	r5,r2
 4011c64:	e13ee317 	ldw	r4,-1140(fp)
 4011c68:	4011d1c0 	call	4011d1c <___vfiprintf_internal_r>
 4011c6c:	e0bffe15 	stw	r2,-8(fp)
	if (ret >= 0 && _fflush_r (rptr, &fake))
 4011c70:	e0bffe17 	ldw	r2,-8(fp)
 4011c74:	10000716 	blt	r2,zero,4011c94 <__sbprintf+0xb8>
 4011c78:	e0bfe404 	addi	r2,fp,-112
 4011c7c:	100b883a 	mov	r5,r2
 4011c80:	e13ee317 	ldw	r4,-1140(fp)
 4011c84:	400c3c80 	call	400c3c8 <_fflush_r>
 4011c88:	10000226 	beq	r2,zero,4011c94 <__sbprintf+0xb8>
		ret = EOF;
 4011c8c:	00bfffc4 	movi	r2,-1
 4011c90:	e0bffe15 	stw	r2,-8(fp)
	if (fake._flags & __SERR)
 4011c94:	e0bfe70b 	ldhu	r2,-100(fp)
 4011c98:	10bfffcc 	andi	r2,r2,65535
 4011c9c:	1080100c 	andi	r2,r2,64
 4011ca0:	10000326 	beq	r2,zero,4011cb0 <__sbprintf+0xd4>
		fp->_flags |= __SERR;
 4011ca4:	8080030b 	ldhu	r2,12(r16)
 4011ca8:	10801014 	ori	r2,r2,64
 4011cac:	8080030d 	sth	r2,12(r16)
	return (ret);
 4011cb0:	e0bffe17 	ldw	r2,-8(fp)
}
 4011cb4:	e6ffff04 	addi	sp,fp,-4
 4011cb8:	dfc00217 	ldw	ra,8(sp)
 4011cbc:	df000117 	ldw	fp,4(sp)
 4011cc0:	dc000017 	ldw	r16,0(sp)
 4011cc4:	dec00304 	addi	sp,sp,12
 4011cc8:	f800283a 	ret

04011ccc <__vfiprintf_internal>:
{
 4011ccc:	defffa04 	addi	sp,sp,-24
 4011cd0:	dfc00515 	stw	ra,20(sp)
 4011cd4:	df000415 	stw	fp,16(sp)
 4011cd8:	df000404 	addi	fp,sp,16
 4011cdc:	e13ffe15 	stw	r4,-8(fp)
 4011ce0:	e17ffd15 	stw	r5,-12(fp)
 4011ce4:	e1bffc15 	stw	r6,-16(fp)
  result = _VFPRINTF_R (_REENT, fp, fmt0, ap);
 4011ce8:	d0a00117 	ldw	r2,-32764(gp)
 4011cec:	e1fffc17 	ldw	r7,-16(fp)
 4011cf0:	e1bffd17 	ldw	r6,-12(fp)
 4011cf4:	e17ffe17 	ldw	r5,-8(fp)
 4011cf8:	1009883a 	mov	r4,r2
 4011cfc:	4011d1c0 	call	4011d1c <___vfiprintf_internal_r>
 4011d00:	e0bfff15 	stw	r2,-4(fp)
  return result;
 4011d04:	e0bfff17 	ldw	r2,-4(fp)
}
 4011d08:	e037883a 	mov	sp,fp
 4011d0c:	dfc00117 	ldw	ra,4(sp)
 4011d10:	df000017 	ldw	fp,0(sp)
 4011d14:	dec00204 	addi	sp,sp,8
 4011d18:	f800283a 	ret

04011d1c <___vfiprintf_internal_r>:
{
 4011d1c:	deffbd04 	addi	sp,sp,-268
 4011d20:	dfc04215 	stw	ra,264(sp)
 4011d24:	df004115 	stw	fp,260(sp)
 4011d28:	ddc04015 	stw	r23,256(sp)
 4011d2c:	dd803f15 	stw	r22,252(sp)
 4011d30:	dd403e15 	stw	r21,248(sp)
 4011d34:	dd003d15 	stw	r20,244(sp)
 4011d38:	dcc03c15 	stw	r19,240(sp)
 4011d3c:	dc803b15 	stw	r18,236(sp)
 4011d40:	dc403a15 	stw	r17,232(sp)
 4011d44:	dc003915 	stw	r16,228(sp)
 4011d48:	df004104 	addi	fp,sp,260
 4011d4c:	e13fca15 	stw	r4,-216(fp)
 4011d50:	e17fc915 	stw	r5,-220(fp)
 4011d54:	e1bfc815 	stw	r6,-224(fp)
 4011d58:	e1ffc715 	stw	r7,-228(fp)
	char *xdigs = NULL;	/* digits for [xX] conversion */
 4011d5c:	e03fee15 	stw	zero,-72(fp)
	char *malloc_buf = NULL;/* handy pointer for malloced buffers */
 4011d60:	e03fed15 	stw	zero,-76(fp)
	CHECK_INIT (data, fp);
 4011d64:	e0bfca17 	ldw	r2,-216(fp)
 4011d68:	e0bfec15 	stw	r2,-80(fp)
 4011d6c:	e0bfec17 	ldw	r2,-80(fp)
 4011d70:	10000526 	beq	r2,zero,4011d88 <___vfiprintf_internal_r+0x6c>
 4011d74:	e0bfec17 	ldw	r2,-80(fp)
 4011d78:	10800e17 	ldw	r2,56(r2)
 4011d7c:	1000021e 	bne	r2,zero,4011d88 <___vfiprintf_internal_r+0x6c>
 4011d80:	e13fec17 	ldw	r4,-80(fp)
 4011d84:	400c9100 	call	400c910 <__sinit>
	ORIENT(fp, -1);
 4011d88:	e0bfc917 	ldw	r2,-220(fp)
 4011d8c:	1080030b 	ldhu	r2,12(r2)
 4011d90:	10bfffcc 	andi	r2,r2,65535
 4011d94:	1088000c 	andi	r2,r2,8192
 4011d98:	10000c1e 	bne	r2,zero,4011dcc <___vfiprintf_internal_r+0xb0>
 4011d9c:	e0bfc917 	ldw	r2,-220(fp)
 4011da0:	1080030b 	ldhu	r2,12(r2)
 4011da4:	10880014 	ori	r2,r2,8192
 4011da8:	1007883a 	mov	r3,r2
 4011dac:	e0bfc917 	ldw	r2,-220(fp)
 4011db0:	10c0030d 	sth	r3,12(r2)
 4011db4:	e0bfc917 	ldw	r2,-220(fp)
 4011db8:	10c01917 	ldw	r3,100(r2)
 4011dbc:	00b7ffc4 	movi	r2,-8193
 4011dc0:	1886703a 	and	r3,r3,r2
 4011dc4:	e0bfc917 	ldw	r2,-220(fp)
 4011dc8:	10c01915 	stw	r3,100(r2)
	if (cantwrite (data, fp)) {
 4011dcc:	e0bfc917 	ldw	r2,-220(fp)
 4011dd0:	1080030b 	ldhu	r2,12(r2)
 4011dd4:	10bfffcc 	andi	r2,r2,65535
 4011dd8:	1080020c 	andi	r2,r2,8
 4011ddc:	10000326 	beq	r2,zero,4011dec <___vfiprintf_internal_r+0xd0>
 4011de0:	e0bfc917 	ldw	r2,-220(fp)
 4011de4:	10800417 	ldw	r2,16(r2)
 4011de8:	1000061e 	bne	r2,zero,4011e04 <___vfiprintf_internal_r+0xe8>
 4011dec:	e17fc917 	ldw	r5,-220(fp)
 4011df0:	e13fca17 	ldw	r4,-216(fp)
 4011df4:	4009f4c0 	call	4009f4c <__swsetup_r>
 4011df8:	10000226 	beq	r2,zero,4011e04 <___vfiprintf_internal_r+0xe8>
		return (EOF);
 4011dfc:	00bfffc4 	movi	r2,-1
 4011e00:	00046906 	br	4012fa8 <___vfiprintf_internal_r+0x128c>
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
 4011e04:	e0bfc917 	ldw	r2,-220(fp)
 4011e08:	1080030b 	ldhu	r2,12(r2)
 4011e0c:	10bfffcc 	andi	r2,r2,65535
 4011e10:	1080068c 	andi	r2,r2,26
 4011e14:	10800298 	cmpnei	r2,r2,10
 4011e18:	10000d1e 	bne	r2,zero,4011e50 <___vfiprintf_internal_r+0x134>
	    fp->_file >= 0) {
 4011e1c:	e0bfc917 	ldw	r2,-220(fp)
 4011e20:	1080038b 	ldhu	r2,14(r2)
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
 4011e24:	10bfffcc 	andi	r2,r2,65535
 4011e28:	10a0001c 	xori	r2,r2,32768
 4011e2c:	10a00004 	addi	r2,r2,-32768
 4011e30:	10000716 	blt	r2,zero,4011e50 <___vfiprintf_internal_r+0x134>
		return (__sbprintf (data, fp, fmt0, ap));
 4011e34:	e0bfc717 	ldw	r2,-228(fp)
 4011e38:	100f883a 	mov	r7,r2
 4011e3c:	e1bfc817 	ldw	r6,-224(fp)
 4011e40:	e17fc917 	ldw	r5,-220(fp)
 4011e44:	e13fca17 	ldw	r4,-216(fp)
 4011e48:	4011bdc0 	call	4011bdc <__sbprintf>
 4011e4c:	00045606 	br	4012fa8 <___vfiprintf_internal_r+0x128c>
	fmt = (char *)fmt0;
 4011e50:	e53fc817 	ldw	r20,-224(fp)
	uio.uio_iov = iovp = iov;
 4011e54:	e43fd604 	addi	r16,fp,-168
 4011e58:	e43fe615 	stw	r16,-104(fp)
	uio.uio_resid = 0;
 4011e5c:	e03fe815 	stw	zero,-96(fp)
	uio.uio_iovcnt = 0;
 4011e60:	e03fe715 	stw	zero,-100(fp)
	ret = 0;
 4011e64:	e03ff715 	stw	zero,-36(fp)
	        cp = fmt;
 4011e68:	a025883a 	mov	r18,r20
                while (*fmt != '\0' && *fmt != '%')
 4011e6c:	00000106 	br	4011e74 <___vfiprintf_internal_r+0x158>
                    fmt += 1;
 4011e70:	a5000044 	addi	r20,r20,1
                while (*fmt != '\0' && *fmt != '%')
 4011e74:	a0800003 	ldbu	r2,0(r20)
 4011e78:	10803fcc 	andi	r2,r2,255
 4011e7c:	1080201c 	xori	r2,r2,128
 4011e80:	10bfe004 	addi	r2,r2,-128
 4011e84:	10000626 	beq	r2,zero,4011ea0 <___vfiprintf_internal_r+0x184>
 4011e88:	a0800003 	ldbu	r2,0(r20)
 4011e8c:	10803fcc 	andi	r2,r2,255
 4011e90:	1080201c 	xori	r2,r2,128
 4011e94:	10bfe004 	addi	r2,r2,-128
 4011e98:	10800958 	cmpnei	r2,r2,37
 4011e9c:	103ff41e 	bne	r2,zero,4011e70 <___vfiprintf_internal_r+0x154>
		if ((m = fmt - cp) != 0) {
 4011ea0:	a4a3c83a 	sub	r17,r20,r18
 4011ea4:	88001826 	beq	r17,zero,4011f08 <___vfiprintf_internal_r+0x1ec>
			PRINT (cp, m);
 4011ea8:	84800015 	stw	r18,0(r16)
 4011eac:	8805883a 	mov	r2,r17
 4011eb0:	80800115 	stw	r2,4(r16)
 4011eb4:	e0bfe817 	ldw	r2,-96(fp)
 4011eb8:	8807883a 	mov	r3,r17
 4011ebc:	10c5883a 	add	r2,r2,r3
 4011ec0:	e0bfe815 	stw	r2,-96(fp)
 4011ec4:	84000204 	addi	r16,r16,8
 4011ec8:	e0bfe717 	ldw	r2,-100(fp)
 4011ecc:	10800044 	addi	r2,r2,1
 4011ed0:	e0bfe715 	stw	r2,-100(fp)
 4011ed4:	e0bfe717 	ldw	r2,-100(fp)
 4011ed8:	10800210 	cmplti	r2,r2,8
 4011edc:	1000071e 	bne	r2,zero,4011efc <___vfiprintf_internal_r+0x1e0>
 4011ee0:	e0bfe604 	addi	r2,fp,-104
 4011ee4:	100d883a 	mov	r6,r2
 4011ee8:	e17fc917 	ldw	r5,-220(fp)
 4011eec:	e13fca17 	ldw	r4,-216(fp)
 4011ef0:	4011aac0 	call	4011aac <__sprint_r>
 4011ef4:	1004041e 	bne	r2,zero,4012f08 <___vfiprintf_internal_r+0x11ec>
 4011ef8:	e43fd604 	addi	r16,fp,-168
			ret += m;
 4011efc:	e0bff717 	ldw	r2,-36(fp)
 4011f00:	1445883a 	add	r2,r2,r17
 4011f04:	e0bff715 	stw	r2,-36(fp)
                if (*fmt == '\0')
 4011f08:	a0800003 	ldbu	r2,0(r20)
 4011f0c:	10803fcc 	andi	r2,r2,255
 4011f10:	1080201c 	xori	r2,r2,128
 4011f14:	10bfe004 	addi	r2,r2,-128
 4011f18:	1003ed26 	beq	r2,zero,4012ed0 <___vfiprintf_internal_r+0x11b4>
		fmt_anchor = fmt;
 4011f1c:	e53feb15 	stw	r20,-84(fp)
		fmt++;		/* skip over '%' */
 4011f20:	a5000044 	addi	r20,r20,1
		flags = 0;
 4011f24:	0023883a 	mov	r17,zero
		dprec = 0;
 4011f28:	e03ff115 	stw	zero,-60(fp)
		width = 0;
 4011f2c:	e03ff615 	stw	zero,-40(fp)
		prec = -1;
 4011f30:	00bfffc4 	movi	r2,-1
 4011f34:	e0bff515 	stw	r2,-44(fp)
		sign = '\0';
 4011f38:	e03fe9c5 	stb	zero,-89(fp)
rflag:		ch = *fmt++;
 4011f3c:	a005883a 	mov	r2,r20
 4011f40:	15000044 	addi	r20,r2,1
 4011f44:	10800003 	ldbu	r2,0(r2)
 4011f48:	15403fcc 	andi	r21,r2,255
 4011f4c:	ad40201c 	xori	r21,r21,128
 4011f50:	ad7fe004 	addi	r21,r21,-128
 4011f54:	a8bff804 	addi	r2,r21,-32
 4011f58:	10c01668 	cmpgeui	r3,r2,89
 4011f5c:	1802891e 	bne	r3,zero,4012984 <___vfiprintf_internal_r+0xc68>
 4011f60:	100690ba 	slli	r3,r2,2
 4011f64:	00810074 	movhi	r2,1025
 4011f68:	1885883a 	add	r2,r3,r2
 4011f6c:	1087dd17 	ldw	r2,8052(r2)
 4011f70:	1000683a 	jmp	r2
 4011f74:	040120d8 	cmpnei	r16,zero,1155
 4011f78:	04012984 	movi	r16,1190
 4011f7c:	04012984 	movi	r16,1190
 4011f80:	040120f8 	rdprs	r16,zero,1155
 4011f84:	04012984 	movi	r16,1190
 4011f88:	04012984 	movi	r16,1190
 4011f8c:	04012984 	movi	r16,1190
 4011f90:	04012984 	movi	r16,1190
 4011f94:	04012984 	movi	r16,1190
 4011f98:	04012984 	movi	r16,1190
 4011f9c:	04012100 	call	401210 <__alt_mem_dram-0x3bfedf0>
 4011fa0:	04012134 	movhi	r16,1156
 4011fa4:	04012984 	movi	r16,1190
 4011fa8:	0401212c 	andhi	r16,zero,1156
 4011fac:	04012140 	call	401214 <__alt_mem_dram-0x3bfedec>
 4011fb0:	04012984 	movi	r16,1190
 4011fb4:	040121e4 	muli	r16,zero,1159
 4011fb8:	040121ec 	andhi	r16,zero,1159
 4011fbc:	040121ec 	andhi	r16,zero,1159
 4011fc0:	040121ec 	andhi	r16,zero,1159
 4011fc4:	040121ec 	andhi	r16,zero,1159
 4011fc8:	040121ec 	andhi	r16,zero,1159
 4011fcc:	040121ec 	andhi	r16,zero,1159
 4011fd0:	040121ec 	andhi	r16,zero,1159
 4011fd4:	040121ec 	andhi	r16,zero,1159
 4011fd8:	040121ec 	andhi	r16,zero,1159
 4011fdc:	04012984 	movi	r16,1190
 4011fe0:	04012984 	movi	r16,1190
 4011fe4:	04012984 	movi	r16,1190
 4011fe8:	04012984 	movi	r16,1190
 4011fec:	04012984 	movi	r16,1190
 4011ff0:	04012984 	movi	r16,1190
 4011ff4:	04012984 	movi	r16,1190
 4011ff8:	04012984 	movi	r16,1190
 4011ffc:	04012984 	movi	r16,1190
 4012000:	04012984 	movi	r16,1190
 4012004:	0401229c 	xori	r16,zero,1162
 4012008:	04012984 	movi	r16,1190
 401200c:	04012984 	movi	r16,1190
 4012010:	04012984 	movi	r16,1190
 4012014:	04012984 	movi	r16,1190
 4012018:	04012984 	movi	r16,1190
 401201c:	04012984 	movi	r16,1190
 4012020:	04012984 	movi	r16,1190
 4012024:	04012984 	movi	r16,1190
 4012028:	04012984 	movi	r16,1190
 401202c:	04012984 	movi	r16,1190
 4012030:	0401243c 	xorhi	r16,zero,1168
 4012034:	04012984 	movi	r16,1190
 4012038:	04012984 	movi	r16,1190
 401203c:	04012984 	movi	r16,1190
 4012040:	04012984 	movi	r16,1190
 4012044:	04012984 	movi	r16,1190
 4012048:	040125a8 	cmpgeui	r16,zero,1174
 401204c:	04012984 	movi	r16,1190
 4012050:	04012984 	movi	r16,1190
 4012054:	04012654 	movui	r16,1177
 4012058:	04012984 	movi	r16,1190
 401205c:	04012984 	movi	r16,1190
 4012060:	04012984 	movi	r16,1190
 4012064:	04012984 	movi	r16,1190
 4012068:	04012984 	movi	r16,1190
 401206c:	04012984 	movi	r16,1190
 4012070:	04012984 	movi	r16,1190
 4012074:	04012984 	movi	r16,1190
 4012078:	04012984 	movi	r16,1190
 401207c:	04012984 	movi	r16,1190
 4012080:	04012274 	movhi	r16,1161
 4012084:	040122a0 	cmpeqi	r16,zero,1162
 4012088:	04012984 	movi	r16,1190
 401208c:	04012984 	movi	r16,1190
 4012090:	04012984 	movi	r16,1190
 4012094:	04012238 	rdprs	r16,zero,1160
 4012098:	040122a0 	cmpeqi	r16,zero,1162
 401209c:	04012984 	movi	r16,1190
 40120a0:	04012984 	movi	r16,1190
 40120a4:	04012240 	call	401224 <__alt_mem_dram-0x3bfeddc>
 40120a8:	04012984 	movi	r16,1190
 40120ac:	0401239c 	xori	r16,zero,1166
 40120b0:	04012440 	call	401244 <__alt_mem_dram-0x3bfedbc>
 40120b4:	040124d4 	movui	r16,1171
 40120b8:	0401226c 	andhi	r16,zero,1161
 40120bc:	04012984 	movi	r16,1190
 40120c0:	0401251c 	xori	r16,zero,1172
 40120c4:	04012984 	movi	r16,1190
 40120c8:	040125ac 	andhi	r16,zero,1174
 40120cc:	04012984 	movi	r16,1190
 40120d0:	04012984 	movi	r16,1190
 40120d4:	04012664 	muli	r16,zero,1177
			if (!sign)
 40120d8:	e0bfe9c3 	ldbu	r2,-89(fp)
 40120dc:	10803fcc 	andi	r2,r2,255
 40120e0:	1080201c 	xori	r2,r2,128
 40120e4:	10bfe004 	addi	r2,r2,-128
 40120e8:	103f941e 	bne	r2,zero,4011f3c <___vfiprintf_internal_r+0x220>
				sign = ' ';
 40120ec:	00800804 	movi	r2,32
 40120f0:	e0bfe9c5 	stb	r2,-89(fp)
			goto rflag;
 40120f4:	003f9106 	br	4011f3c <___vfiprintf_internal_r+0x220>
			flags |= ALT;
 40120f8:	8c400054 	ori	r17,r17,1
			goto rflag;
 40120fc:	003f8f06 	br	4011f3c <___vfiprintf_internal_r+0x220>
			width = GET_ARG (n, ap, int);
 4012100:	e0bfc717 	ldw	r2,-228(fp)
 4012104:	10c00104 	addi	r3,r2,4
 4012108:	e0ffc715 	stw	r3,-228(fp)
 401210c:	10800017 	ldw	r2,0(r2)
 4012110:	e0bff615 	stw	r2,-40(fp)
			if (width >= 0)
 4012114:	e0bff617 	ldw	r2,-40(fp)
 4012118:	10000116 	blt	r2,zero,4012120 <___vfiprintf_internal_r+0x404>
				goto rflag;
 401211c:	003f8706 	br	4011f3c <___vfiprintf_internal_r+0x220>
			width = -width;
 4012120:	e0bff617 	ldw	r2,-40(fp)
 4012124:	0085c83a 	sub	r2,zero,r2
 4012128:	e0bff615 	stw	r2,-40(fp)
			flags |= LADJUST;
 401212c:	8c400114 	ori	r17,r17,4
			goto rflag;
 4012130:	003f8206 	br	4011f3c <___vfiprintf_internal_r+0x220>
			sign = '+';
 4012134:	00800ac4 	movi	r2,43
 4012138:	e0bfe9c5 	stb	r2,-89(fp)
			goto rflag;
 401213c:	003f7f06 	br	4011f3c <___vfiprintf_internal_r+0x220>
			if ((ch = *fmt++) == '*') {
 4012140:	a005883a 	mov	r2,r20
 4012144:	15000044 	addi	r20,r2,1
 4012148:	10800003 	ldbu	r2,0(r2)
 401214c:	15403fcc 	andi	r21,r2,255
 4012150:	ad40201c 	xori	r21,r21,128
 4012154:	ad7fe004 	addi	r21,r21,-128
 4012158:	a8800a98 	cmpnei	r2,r21,42
 401215c:	10000a1e 	bne	r2,zero,4012188 <___vfiprintf_internal_r+0x46c>
				prec = GET_ARG (n, ap, int);
 4012160:	e0bfc717 	ldw	r2,-228(fp)
 4012164:	10c00104 	addi	r3,r2,4
 4012168:	e0ffc715 	stw	r3,-228(fp)
 401216c:	10800017 	ldw	r2,0(r2)
 4012170:	e0bff515 	stw	r2,-44(fp)
				if (prec < 0)
 4012174:	e0bff517 	ldw	r2,-44(fp)
 4012178:	103f700e 	bge	r2,zero,4011f3c <___vfiprintf_internal_r+0x220>
					prec = -1;
 401217c:	00bfffc4 	movi	r2,-1
 4012180:	e0bff515 	stw	r2,-44(fp)
				goto rflag;
 4012184:	003f6d06 	br	4011f3c <___vfiprintf_internal_r+0x220>
			n = 0;
 4012188:	0027883a 	mov	r19,zero
			while (is_digit (ch)) {
 401218c:	00000d06 	br	40121c4 <___vfiprintf_internal_r+0x4a8>
				n = 10 * n + to_digit (ch);
 4012190:	9805883a 	mov	r2,r19
 4012194:	100490ba 	slli	r2,r2,2
 4012198:	14c5883a 	add	r2,r2,r19
 401219c:	1085883a 	add	r2,r2,r2
 40121a0:	1007883a 	mov	r3,r2
 40121a4:	a8bff404 	addi	r2,r21,-48
 40121a8:	18a7883a 	add	r19,r3,r2
				ch = *fmt++;
 40121ac:	a005883a 	mov	r2,r20
 40121b0:	15000044 	addi	r20,r2,1
 40121b4:	10800003 	ldbu	r2,0(r2)
 40121b8:	15403fcc 	andi	r21,r2,255
 40121bc:	ad40201c 	xori	r21,r21,128
 40121c0:	ad7fe004 	addi	r21,r21,-128
			while (is_digit (ch)) {
 40121c4:	a8bff404 	addi	r2,r21,-48
 40121c8:	108002b0 	cmpltui	r2,r2,10
 40121cc:	103ff01e 	bne	r2,zero,4012190 <___vfiprintf_internal_r+0x474>
			prec = n < 0 ? -1 : n;
 40121d0:	9805883a 	mov	r2,r19
 40121d4:	1000010e 	bge	r2,zero,40121dc <___vfiprintf_internal_r+0x4c0>
 40121d8:	00bfffc4 	movi	r2,-1
 40121dc:	e0bff515 	stw	r2,-44(fp)
			goto reswitch;
 40121e0:	003f5c06 	br	4011f54 <___vfiprintf_internal_r+0x238>
			flags |= ZEROPAD;
 40121e4:	8c402014 	ori	r17,r17,128
			goto rflag;
 40121e8:	003f5406 	br	4011f3c <___vfiprintf_internal_r+0x220>
			n = 0;
 40121ec:	0027883a 	mov	r19,zero
				n = 10 * n + to_digit (ch);
 40121f0:	9805883a 	mov	r2,r19
 40121f4:	100490ba 	slli	r2,r2,2
 40121f8:	14c5883a 	add	r2,r2,r19
 40121fc:	1085883a 	add	r2,r2,r2
 4012200:	1007883a 	mov	r3,r2
 4012204:	a8bff404 	addi	r2,r21,-48
 4012208:	18a7883a 	add	r19,r3,r2
				ch = *fmt++;
 401220c:	a005883a 	mov	r2,r20
 4012210:	15000044 	addi	r20,r2,1
 4012214:	10800003 	ldbu	r2,0(r2)
 4012218:	15403fcc 	andi	r21,r2,255
 401221c:	ad40201c 	xori	r21,r21,128
 4012220:	ad7fe004 	addi	r21,r21,-128
			} while (is_digit (ch));
 4012224:	a8bff404 	addi	r2,r21,-48
 4012228:	108002b0 	cmpltui	r2,r2,10
 401222c:	103ff01e 	bne	r2,zero,40121f0 <___vfiprintf_internal_r+0x4d4>
			width = n;
 4012230:	e4fff615 	stw	r19,-40(fp)
			goto reswitch;
 4012234:	003f4706 	br	4011f54 <___vfiprintf_internal_r+0x238>
				flags |= SHORTINT;
 4012238:	8c401014 	ori	r17,r17,64
			goto rflag;
 401223c:	003f3f06 	br	4011f3c <___vfiprintf_internal_r+0x220>
			if (*fmt == 'l') {
 4012240:	a0800003 	ldbu	r2,0(r20)
 4012244:	10803fcc 	andi	r2,r2,255
 4012248:	1080201c 	xori	r2,r2,128
 401224c:	10bfe004 	addi	r2,r2,-128
 4012250:	10801b18 	cmpnei	r2,r2,108
 4012254:	1000031e 	bne	r2,zero,4012264 <___vfiprintf_internal_r+0x548>
				fmt++;
 4012258:	a5000044 	addi	r20,r20,1
				flags |= QUADINT;
 401225c:	8c400814 	ori	r17,r17,32
 4012260:	003f3606 	br	4011f3c <___vfiprintf_internal_r+0x220>
				flags |= LONGINT;
 4012264:	8c400414 	ori	r17,r17,16
			goto rflag;
 4012268:	003f3406 	br	4011f3c <___vfiprintf_internal_r+0x220>
			flags |= QUADINT;
 401226c:	8c400814 	ori	r17,r17,32
			goto rflag;
 4012270:	003f3206 	br	4011f3c <___vfiprintf_internal_r+0x220>
			cp = buf;
 4012274:	e4bfcc04 	addi	r18,fp,-208
				*cp = GET_ARG (N, ap, int);
 4012278:	e0bfc717 	ldw	r2,-228(fp)
 401227c:	10c00104 	addi	r3,r2,4
 4012280:	e0ffc715 	stw	r3,-228(fp)
 4012284:	10800017 	ldw	r2,0(r2)
 4012288:	90800005 	stb	r2,0(r18)
				size = 1;
 401228c:	00800044 	movi	r2,1
 4012290:	e0bfef15 	stw	r2,-68(fp)
			sign = '\0';
 4012294:	e03fe9c5 	stb	zero,-89(fp)
			break;
 4012298:	0001c206 	br	40129a4 <___vfiprintf_internal_r+0xc88>
			flags |= LONGINT;
 401229c:	8c400414 	ori	r17,r17,16
			_uquad = SARG ();
 40122a0:	8880080c 	andi	r2,r17,32
 40122a4:	10000826 	beq	r2,zero,40122c8 <___vfiprintf_internal_r+0x5ac>
 40122a8:	e13fc717 	ldw	r4,-228(fp)
 40122ac:	20800204 	addi	r2,r4,8
 40122b0:	e0bfc715 	stw	r2,-228(fp)
 40122b4:	20800017 	ldw	r2,0(r4)
 40122b8:	20c00117 	ldw	r3,4(r4)
 40122bc:	e0bfc515 	stw	r2,-236(fp)
 40122c0:	e0ffc615 	stw	r3,-232(fp)
 40122c4:	00001e06 	br	4012340 <___vfiprintf_internal_r+0x624>
 40122c8:	8880040c 	andi	r2,r17,16
 40122cc:	10000826 	beq	r2,zero,40122f0 <___vfiprintf_internal_r+0x5d4>
 40122d0:	e0bfc717 	ldw	r2,-228(fp)
 40122d4:	10c00104 	addi	r3,r2,4
 40122d8:	e0ffc715 	stw	r3,-228(fp)
 40122dc:	10800017 	ldw	r2,0(r2)
 40122e0:	e0bfc515 	stw	r2,-236(fp)
 40122e4:	1005d7fa 	srai	r2,r2,31
 40122e8:	e0bfc615 	stw	r2,-232(fp)
 40122ec:	00001406 	br	4012340 <___vfiprintf_internal_r+0x624>
 40122f0:	8880100c 	andi	r2,r17,64
 40122f4:	10000b26 	beq	r2,zero,4012324 <___vfiprintf_internal_r+0x608>
 40122f8:	e0bfc717 	ldw	r2,-228(fp)
 40122fc:	10c00104 	addi	r3,r2,4
 4012300:	e0ffc715 	stw	r3,-228(fp)
 4012304:	10800017 	ldw	r2,0(r2)
 4012308:	10bfffcc 	andi	r2,r2,65535
 401230c:	10a0001c 	xori	r2,r2,32768
 4012310:	10a00004 	addi	r2,r2,-32768
 4012314:	e0bfc515 	stw	r2,-236(fp)
 4012318:	1005d7fa 	srai	r2,r2,31
 401231c:	e0bfc615 	stw	r2,-232(fp)
 4012320:	00000706 	br	4012340 <___vfiprintf_internal_r+0x624>
 4012324:	e0bfc717 	ldw	r2,-228(fp)
 4012328:	10c00104 	addi	r3,r2,4
 401232c:	e0ffc715 	stw	r3,-228(fp)
 4012330:	10800017 	ldw	r2,0(r2)
 4012334:	e0bfc515 	stw	r2,-236(fp)
 4012338:	1005d7fa 	srai	r2,r2,31
 401233c:	e0bfc615 	stw	r2,-232(fp)
 4012340:	e0bfc517 	ldw	r2,-236(fp)
 4012344:	e0bff315 	stw	r2,-52(fp)
 4012348:	e0bfc617 	ldw	r2,-232(fp)
 401234c:	e0bff415 	stw	r2,-48(fp)
			if ((quad_t)_uquad < 0)
 4012350:	e0bff317 	ldw	r2,-52(fp)
 4012354:	e0fff417 	ldw	r3,-48(fp)
 4012358:	18000d0e 	bge	r3,zero,4012390 <___vfiprintf_internal_r+0x674>
				_uquad = -_uquad;
 401235c:	000d883a 	mov	r6,zero
 4012360:	000f883a 	mov	r7,zero
 4012364:	e13ff317 	ldw	r4,-52(fp)
 4012368:	e17ff417 	ldw	r5,-48(fp)
 401236c:	3105c83a 	sub	r2,r6,r4
 4012370:	3091803a 	cmpltu	r8,r6,r2
 4012374:	3947c83a 	sub	r3,r7,r5
 4012378:	1a09c83a 	sub	r4,r3,r8
 401237c:	2007883a 	mov	r3,r4
 4012380:	e0bff315 	stw	r2,-52(fp)
 4012384:	e0fff415 	stw	r3,-48(fp)
				sign = '-';
 4012388:	00800b44 	movi	r2,45
 401238c:	e0bfe9c5 	stb	r2,-89(fp)
			base = DEC;
 4012390:	00800044 	movi	r2,1
 4012394:	e0bff215 	stw	r2,-56(fp)
			goto number;
 4012398:	0000ec06 	br	401274c <___vfiprintf_internal_r+0xa30>
			if (flags & QUADINT)
 401239c:	8880080c 	andi	r2,r17,32
 40123a0:	10000d26 	beq	r2,zero,40123d8 <___vfiprintf_internal_r+0x6bc>
				*GET_ARG (N, ap, quad_ptr_t) = ret;
 40123a4:	e0bfc717 	ldw	r2,-228(fp)
 40123a8:	10c00104 	addi	r3,r2,4
 40123ac:	e0ffc715 	stw	r3,-228(fp)
 40123b0:	10800017 	ldw	r2,0(r2)
 40123b4:	e0fff717 	ldw	r3,-36(fp)
 40123b8:	e0ffbf15 	stw	r3,-260(fp)
 40123bc:	1807d7fa 	srai	r3,r3,31
 40123c0:	e0ffc015 	stw	r3,-256(fp)
 40123c4:	e0ffbf17 	ldw	r3,-260(fp)
 40123c8:	10c00015 	stw	r3,0(r2)
 40123cc:	e0ffc017 	ldw	r3,-256(fp)
 40123d0:	10c00115 	stw	r3,4(r2)
			continue;	/* no output */
 40123d4:	0002bd06 	br	4012ecc <___vfiprintf_internal_r+0x11b0>
			if (flags & LONGINT)
 40123d8:	8880040c 	andi	r2,r17,16
 40123dc:	10000726 	beq	r2,zero,40123fc <___vfiprintf_internal_r+0x6e0>
				*GET_ARG (N, ap, long_ptr_t) = ret;
 40123e0:	e0bfc717 	ldw	r2,-228(fp)
 40123e4:	10c00104 	addi	r3,r2,4
 40123e8:	e0ffc715 	stw	r3,-228(fp)
 40123ec:	10800017 	ldw	r2,0(r2)
 40123f0:	e0fff717 	ldw	r3,-36(fp)
 40123f4:	10c00015 	stw	r3,0(r2)
			continue;	/* no output */
 40123f8:	0002b406 	br	4012ecc <___vfiprintf_internal_r+0x11b0>
			else if (flags & SHORTINT)
 40123fc:	8880100c 	andi	r2,r17,64
 4012400:	10000726 	beq	r2,zero,4012420 <___vfiprintf_internal_r+0x704>
				*GET_ARG (N, ap, short_ptr_t) = ret;
 4012404:	e0bfc717 	ldw	r2,-228(fp)
 4012408:	10c00104 	addi	r3,r2,4
 401240c:	e0ffc715 	stw	r3,-228(fp)
 4012410:	10800017 	ldw	r2,0(r2)
 4012414:	e0fff717 	ldw	r3,-36(fp)
 4012418:	10c0000d 	sth	r3,0(r2)
			continue;	/* no output */
 401241c:	0002ab06 	br	4012ecc <___vfiprintf_internal_r+0x11b0>
				*GET_ARG (N, ap, int_ptr_t) = ret;
 4012420:	e0bfc717 	ldw	r2,-228(fp)
 4012424:	10c00104 	addi	r3,r2,4
 4012428:	e0ffc715 	stw	r3,-228(fp)
 401242c:	10800017 	ldw	r2,0(r2)
 4012430:	e0fff717 	ldw	r3,-36(fp)
 4012434:	10c00015 	stw	r3,0(r2)
			continue;	/* no output */
 4012438:	0002a406 	br	4012ecc <___vfiprintf_internal_r+0x11b0>
			flags |= LONGINT;
 401243c:	8c400414 	ori	r17,r17,16
			_uquad = UARG ();
 4012440:	8880080c 	andi	r2,r17,32
 4012444:	10000626 	beq	r2,zero,4012460 <___vfiprintf_internal_r+0x744>
 4012448:	e0bfc717 	ldw	r2,-228(fp)
 401244c:	10c00204 	addi	r3,r2,8
 4012450:	e0ffc715 	stw	r3,-228(fp)
 4012454:	15800017 	ldw	r22,0(r2)
 4012458:	15c00117 	ldw	r23,4(r2)
 401245c:	00001906 	br	40124c4 <___vfiprintf_internal_r+0x7a8>
 4012460:	8880040c 	andi	r2,r17,16
 4012464:	10000726 	beq	r2,zero,4012484 <___vfiprintf_internal_r+0x768>
 4012468:	e0bfc717 	ldw	r2,-228(fp)
 401246c:	10c00104 	addi	r3,r2,4
 4012470:	e0ffc715 	stw	r3,-228(fp)
 4012474:	10800017 	ldw	r2,0(r2)
 4012478:	102d883a 	mov	r22,r2
 401247c:	002f883a 	mov	r23,zero
 4012480:	00001006 	br	40124c4 <___vfiprintf_internal_r+0x7a8>
 4012484:	8880100c 	andi	r2,r17,64
 4012488:	10000826 	beq	r2,zero,40124ac <___vfiprintf_internal_r+0x790>
 401248c:	e0bfc717 	ldw	r2,-228(fp)
 4012490:	10c00104 	addi	r3,r2,4
 4012494:	e0ffc715 	stw	r3,-228(fp)
 4012498:	10800017 	ldw	r2,0(r2)
 401249c:	10bfffcc 	andi	r2,r2,65535
 40124a0:	102d883a 	mov	r22,r2
 40124a4:	002f883a 	mov	r23,zero
 40124a8:	00000606 	br	40124c4 <___vfiprintf_internal_r+0x7a8>
 40124ac:	e0bfc717 	ldw	r2,-228(fp)
 40124b0:	10c00104 	addi	r3,r2,4
 40124b4:	e0ffc715 	stw	r3,-228(fp)
 40124b8:	10800017 	ldw	r2,0(r2)
 40124bc:	102d883a 	mov	r22,r2
 40124c0:	002f883a 	mov	r23,zero
 40124c4:	e5bff315 	stw	r22,-52(fp)
 40124c8:	e5fff415 	stw	r23,-48(fp)
			base = OCT;
 40124cc:	e03ff215 	stw	zero,-56(fp)
			goto nosign;
 40124d0:	00009d06 	br	4012748 <___vfiprintf_internal_r+0xa2c>
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
 40124d4:	e0bfc717 	ldw	r2,-228(fp)
 40124d8:	10c00104 	addi	r3,r2,4
 40124dc:	e0ffc715 	stw	r3,-228(fp)
 40124e0:	10800017 	ldw	r2,0(r2)
 40124e4:	e0bff315 	stw	r2,-52(fp)
 40124e8:	e03ff415 	stw	zero,-48(fp)
			base = HEX;
 40124ec:	00800084 	movi	r2,2
 40124f0:	e0bff215 	stw	r2,-56(fp)
			xdigs = "0123456789abcdef";
 40124f4:	008100b4 	movhi	r2,1026
 40124f8:	10ab6604 	addi	r2,r2,-21096
 40124fc:	e0bfee15 	stw	r2,-72(fp)
			flags |= HEXPREFIX;
 4012500:	8c400094 	ori	r17,r17,2
			ox[0] = '0';
 4012504:	00800c04 	movi	r2,48
 4012508:	e0bfcb85 	stb	r2,-210(fp)
			ox[1] = ch = 'x';
 401250c:	05401e04 	movi	r21,120
 4012510:	00801e04 	movi	r2,120
 4012514:	e0bfcbc5 	stb	r2,-209(fp)
			goto nosign;
 4012518:	00008b06 	br	4012748 <___vfiprintf_internal_r+0xa2c>
			cp = GET_ARG (N, ap, char_ptr_t);
 401251c:	e0bfc717 	ldw	r2,-228(fp)
 4012520:	10c00104 	addi	r3,r2,4
 4012524:	e0ffc715 	stw	r3,-228(fp)
 4012528:	14800017 	ldw	r18,0(r2)
			sign = '\0';
 401252c:	e03fe9c5 	stb	zero,-89(fp)
			if (cp == NULL) {
 4012530:	9000081e 	bne	r18,zero,4012554 <___vfiprintf_internal_r+0x838>
				cp = "(null)";
 4012534:	048100b4 	movhi	r18,1026
 4012538:	94ab6b04 	addi	r18,r18,-21076
				size = ((unsigned) prec > 6U) ? 6 : prec;
 401253c:	e0bff517 	ldw	r2,-44(fp)
 4012540:	10c001f0 	cmpltui	r3,r2,7
 4012544:	1800011e 	bne	r3,zero,401254c <___vfiprintf_internal_r+0x830>
 4012548:	00800184 	movi	r2,6
 401254c:	e0bfef15 	stw	r2,-68(fp)
			break;
 4012550:	00011406 	br	40129a4 <___vfiprintf_internal_r+0xc88>
			if (prec >= 0) {
 4012554:	e0bff517 	ldw	r2,-44(fp)
 4012558:	10000f16 	blt	r2,zero,4012598 <___vfiprintf_internal_r+0x87c>
				char *p = memchr (cp, 0, prec);
 401255c:	e0bff517 	ldw	r2,-44(fp)
 4012560:	100d883a 	mov	r6,r2
 4012564:	000b883a 	mov	r5,zero
 4012568:	9009883a 	mov	r4,r18
 401256c:	400eca80 	call	400eca8 <memchr>
 4012570:	e0bfea15 	stw	r2,-88(fp)
				if (p != NULL)
 4012574:	e0bfea17 	ldw	r2,-88(fp)
 4012578:	10000426 	beq	r2,zero,401258c <___vfiprintf_internal_r+0x870>
					size = p - cp;
 401257c:	e0bfea17 	ldw	r2,-88(fp)
 4012580:	1485c83a 	sub	r2,r2,r18
 4012584:	e0bfef15 	stw	r2,-68(fp)
			break;
 4012588:	00010606 	br	40129a4 <___vfiprintf_internal_r+0xc88>
					size = prec;
 401258c:	e0bff517 	ldw	r2,-44(fp)
 4012590:	e0bfef15 	stw	r2,-68(fp)
			break;
 4012594:	00010306 	br	40129a4 <___vfiprintf_internal_r+0xc88>
				size = strlen (cp);
 4012598:	9009883a 	mov	r4,r18
 401259c:	40078680 	call	4007868 <strlen>
 40125a0:	e0bfef15 	stw	r2,-68(fp)
			break;
 40125a4:	0000ff06 	br	40129a4 <___vfiprintf_internal_r+0xc88>
			flags |= LONGINT;
 40125a8:	8c400414 	ori	r17,r17,16
			_uquad = UARG ();
 40125ac:	8880080c 	andi	r2,r17,32
 40125b0:	10000826 	beq	r2,zero,40125d4 <___vfiprintf_internal_r+0x8b8>
 40125b4:	e0bfc717 	ldw	r2,-228(fp)
 40125b8:	10c00204 	addi	r3,r2,8
 40125bc:	e0ffc715 	stw	r3,-228(fp)
 40125c0:	10c00017 	ldw	r3,0(r2)
 40125c4:	e0ffc315 	stw	r3,-244(fp)
 40125c8:	10800117 	ldw	r2,4(r2)
 40125cc:	e0bfc415 	stw	r2,-240(fp)
 40125d0:	00001906 	br	4012638 <___vfiprintf_internal_r+0x91c>
 40125d4:	8880040c 	andi	r2,r17,16
 40125d8:	10000726 	beq	r2,zero,40125f8 <___vfiprintf_internal_r+0x8dc>
 40125dc:	e0bfc717 	ldw	r2,-228(fp)
 40125e0:	10c00104 	addi	r3,r2,4
 40125e4:	e0ffc715 	stw	r3,-228(fp)
 40125e8:	10800017 	ldw	r2,0(r2)
 40125ec:	e0bfc315 	stw	r2,-244(fp)
 40125f0:	e03fc415 	stw	zero,-240(fp)
 40125f4:	00001006 	br	4012638 <___vfiprintf_internal_r+0x91c>
 40125f8:	8880100c 	andi	r2,r17,64
 40125fc:	10000826 	beq	r2,zero,4012620 <___vfiprintf_internal_r+0x904>
 4012600:	e0bfc717 	ldw	r2,-228(fp)
 4012604:	10c00104 	addi	r3,r2,4
 4012608:	e0ffc715 	stw	r3,-228(fp)
 401260c:	10800017 	ldw	r2,0(r2)
 4012610:	10bfffcc 	andi	r2,r2,65535
 4012614:	e0bfc315 	stw	r2,-244(fp)
 4012618:	e03fc415 	stw	zero,-240(fp)
 401261c:	00000606 	br	4012638 <___vfiprintf_internal_r+0x91c>
 4012620:	e0bfc717 	ldw	r2,-228(fp)
 4012624:	10c00104 	addi	r3,r2,4
 4012628:	e0ffc715 	stw	r3,-228(fp)
 401262c:	10800017 	ldw	r2,0(r2)
 4012630:	e0bfc315 	stw	r2,-244(fp)
 4012634:	e03fc415 	stw	zero,-240(fp)
 4012638:	e0bfc317 	ldw	r2,-244(fp)
 401263c:	e0bff315 	stw	r2,-52(fp)
 4012640:	e0bfc417 	ldw	r2,-240(fp)
 4012644:	e0bff415 	stw	r2,-48(fp)
			base = DEC;
 4012648:	00800044 	movi	r2,1
 401264c:	e0bff215 	stw	r2,-56(fp)
			goto nosign;
 4012650:	00003d06 	br	4012748 <___vfiprintf_internal_r+0xa2c>
			xdigs = "0123456789ABCDEF";
 4012654:	008100b4 	movhi	r2,1026
 4012658:	10ab6d04 	addi	r2,r2,-21068
 401265c:	e0bfee15 	stw	r2,-72(fp)
			goto hex;
 4012660:	00000306 	br	4012670 <___vfiprintf_internal_r+0x954>
			xdigs = "0123456789abcdef";
 4012664:	008100b4 	movhi	r2,1026
 4012668:	10ab6604 	addi	r2,r2,-21096
 401266c:	e0bfee15 	stw	r2,-72(fp)
hex:			_uquad = UARG ();
 4012670:	8880080c 	andi	r2,r17,32
 4012674:	10000826 	beq	r2,zero,4012698 <___vfiprintf_internal_r+0x97c>
 4012678:	e0bfc717 	ldw	r2,-228(fp)
 401267c:	10c00204 	addi	r3,r2,8
 4012680:	e0ffc715 	stw	r3,-228(fp)
 4012684:	10c00017 	ldw	r3,0(r2)
 4012688:	e0ffc115 	stw	r3,-252(fp)
 401268c:	10800117 	ldw	r2,4(r2)
 4012690:	e0bfc215 	stw	r2,-248(fp)
 4012694:	00001906 	br	40126fc <___vfiprintf_internal_r+0x9e0>
 4012698:	8880040c 	andi	r2,r17,16
 401269c:	10000726 	beq	r2,zero,40126bc <___vfiprintf_internal_r+0x9a0>
 40126a0:	e0bfc717 	ldw	r2,-228(fp)
 40126a4:	10c00104 	addi	r3,r2,4
 40126a8:	e0ffc715 	stw	r3,-228(fp)
 40126ac:	10800017 	ldw	r2,0(r2)
 40126b0:	e0bfc115 	stw	r2,-252(fp)
 40126b4:	e03fc215 	stw	zero,-248(fp)
 40126b8:	00001006 	br	40126fc <___vfiprintf_internal_r+0x9e0>
 40126bc:	8880100c 	andi	r2,r17,64
 40126c0:	10000826 	beq	r2,zero,40126e4 <___vfiprintf_internal_r+0x9c8>
 40126c4:	e0bfc717 	ldw	r2,-228(fp)
 40126c8:	10c00104 	addi	r3,r2,4
 40126cc:	e0ffc715 	stw	r3,-228(fp)
 40126d0:	10800017 	ldw	r2,0(r2)
 40126d4:	10bfffcc 	andi	r2,r2,65535
 40126d8:	e0bfc115 	stw	r2,-252(fp)
 40126dc:	e03fc215 	stw	zero,-248(fp)
 40126e0:	00000606 	br	40126fc <___vfiprintf_internal_r+0x9e0>
 40126e4:	e0bfc717 	ldw	r2,-228(fp)
 40126e8:	10c00104 	addi	r3,r2,4
 40126ec:	e0ffc715 	stw	r3,-228(fp)
 40126f0:	10800017 	ldw	r2,0(r2)
 40126f4:	e0bfc115 	stw	r2,-252(fp)
 40126f8:	e03fc215 	stw	zero,-248(fp)
 40126fc:	e0bfc117 	ldw	r2,-252(fp)
 4012700:	e0bff315 	stw	r2,-52(fp)
 4012704:	e0bfc217 	ldw	r2,-248(fp)
 4012708:	e0bff415 	stw	r2,-48(fp)
			base = HEX;
 401270c:	00800084 	movi	r2,2
 4012710:	e0bff215 	stw	r2,-56(fp)
			if (flags & ALT && _uquad != 0) {
 4012714:	8880004c 	andi	r2,r17,1
 4012718:	10000a26 	beq	r2,zero,4012744 <___vfiprintf_internal_r+0xa28>
 401271c:	e0bff317 	ldw	r2,-52(fp)
 4012720:	e0fff417 	ldw	r3,-48(fp)
 4012724:	10c4b03a 	or	r2,r2,r3
 4012728:	10000726 	beq	r2,zero,4012748 <___vfiprintf_internal_r+0xa2c>
				ox[0] = '0';
 401272c:	00800c04 	movi	r2,48
 4012730:	e0bfcb85 	stb	r2,-210(fp)
				ox[1] = ch;
 4012734:	a805883a 	mov	r2,r21
 4012738:	e0bfcbc5 	stb	r2,-209(fp)
				flags |= HEXPREFIX;
 401273c:	8c400094 	ori	r17,r17,2
 4012740:	00000106 	br	4012748 <___vfiprintf_internal_r+0xa2c>
nosign:			sign = '\0';
 4012744:	0001883a 	nop
 4012748:	e03fe9c5 	stb	zero,-89(fp)
number:			if ((dprec = prec) >= 0)
 401274c:	e0bff517 	ldw	r2,-44(fp)
 4012750:	e0bff115 	stw	r2,-60(fp)
 4012754:	e0bff117 	ldw	r2,-60(fp)
 4012758:	10000216 	blt	r2,zero,4012764 <___vfiprintf_internal_r+0xa48>
				flags &= ~ZEROPAD;
 401275c:	00bfdfc4 	movi	r2,-129
 4012760:	88a2703a 	and	r17,r17,r2
			cp = buf + BUF;
 4012764:	e4bfcc04 	addi	r18,fp,-208
 4012768:	94800a04 	addi	r18,r18,40
			if (_uquad != 0 || prec != 0) {
 401276c:	e0bff317 	ldw	r2,-52(fp)
 4012770:	e0fff417 	ldw	r3,-48(fp)
 4012774:	10c4b03a 	or	r2,r2,r3
 4012778:	1000021e 	bne	r2,zero,4012784 <___vfiprintf_internal_r+0xa68>
 401277c:	e0bff517 	ldw	r2,-44(fp)
 4012780:	10007426 	beq	r2,zero,4012954 <___vfiprintf_internal_r+0xc38>
 4012784:	e0bff217 	ldw	r2,-56(fp)
 4012788:	108000a0 	cmpeqi	r2,r2,2
 401278c:	1000531e 	bne	r2,zero,40128dc <___vfiprintf_internal_r+0xbc0>
 4012790:	e0bff217 	ldw	r2,-56(fp)
 4012794:	108000e8 	cmpgeui	r2,r2,3
 4012798:	1000651e 	bne	r2,zero,4012930 <___vfiprintf_internal_r+0xc14>
 401279c:	e0bff217 	ldw	r2,-56(fp)
 40127a0:	10000526 	beq	r2,zero,40127b8 <___vfiprintf_internal_r+0xa9c>
 40127a4:	e0bff217 	ldw	r2,-56(fp)
 40127a8:	10800060 	cmpeqi	r2,r2,1
 40127ac:	1000201e 	bne	r2,zero,4012830 <___vfiprintf_internal_r+0xb14>
 40127b0:	00005f06 	br	4012930 <___vfiprintf_internal_r+0xc14>
				case OCT:
 40127b4:	0001883a 	nop
						*--cp = to_char (_uquad & 7);
 40127b8:	e0bff317 	ldw	r2,-52(fp)
 40127bc:	108001cc 	andi	r2,r2,7
 40127c0:	10800c04 	addi	r2,r2,48
 40127c4:	94bfffc4 	addi	r18,r18,-1
 40127c8:	90800005 	stb	r2,0(r18)
						_uquad >>= 3;
 40127cc:	e0bff417 	ldw	r2,-48(fp)
 40127d0:	1004977a 	slli	r2,r2,29
 40127d4:	e0fff317 	ldw	r3,-52(fp)
 40127d8:	1806d0fa 	srli	r3,r3,3
 40127dc:	1884b03a 	or	r2,r3,r2
 40127e0:	e0bff315 	stw	r2,-52(fp)
 40127e4:	e0bff417 	ldw	r2,-48(fp)
 40127e8:	1004d0fa 	srli	r2,r2,3
 40127ec:	e0bff415 	stw	r2,-48(fp)
					} while (_uquad);
 40127f0:	e0bff317 	ldw	r2,-52(fp)
 40127f4:	e0fff417 	ldw	r3,-48(fp)
 40127f8:	10c4b03a 	or	r2,r2,r3
 40127fc:	103fed1e 	bne	r2,zero,40127b4 <___vfiprintf_internal_r+0xa98>
					if (flags & ALT && *cp != '0')
 4012800:	8880004c 	andi	r2,r17,1
 4012804:	10005126 	beq	r2,zero,401294c <___vfiprintf_internal_r+0xc30>
 4012808:	90800003 	ldbu	r2,0(r18)
 401280c:	10803fcc 	andi	r2,r2,255
 4012810:	1080201c 	xori	r2,r2,128
 4012814:	10bfe004 	addi	r2,r2,-128
 4012818:	10800c20 	cmpeqi	r2,r2,48
 401281c:	10004b1e 	bne	r2,zero,401294c <___vfiprintf_internal_r+0xc30>
						*--cp = '0';
 4012820:	94bfffc4 	addi	r18,r18,-1
 4012824:	00800c04 	movi	r2,48
 4012828:	90800005 	stb	r2,0(r18)
					break;
 401282c:	00004706 	br	401294c <___vfiprintf_internal_r+0xc30>
					if (_uquad < 10) {
 4012830:	e0bff417 	ldw	r2,-48(fp)
 4012834:	10000a1e 	bne	r2,zero,4012860 <___vfiprintf_internal_r+0xb44>
 4012838:	e0bff417 	ldw	r2,-48(fp)
 401283c:	1000031e 	bne	r2,zero,401284c <___vfiprintf_internal_r+0xb30>
 4012840:	e0bff317 	ldw	r2,-52(fp)
 4012844:	108002a8 	cmpgeui	r2,r2,10
 4012848:	1000051e 	bne	r2,zero,4012860 <___vfiprintf_internal_r+0xb44>
						*--cp = to_char(_uquad);
 401284c:	e0bff317 	ldw	r2,-52(fp)
 4012850:	10800c04 	addi	r2,r2,48
 4012854:	94bfffc4 	addi	r18,r18,-1
 4012858:	90800005 	stb	r2,0(r18)
						break;
 401285c:	00003c06 	br	4012950 <___vfiprintf_internal_r+0xc34>
					  *--cp = to_char (_uquad % 10);
 4012860:	e0bff317 	ldw	r2,-52(fp)
 4012864:	e0fff417 	ldw	r3,-48(fp)
 4012868:	01800284 	movi	r6,10
 401286c:	000f883a 	mov	r7,zero
 4012870:	1009883a 	mov	r4,r2
 4012874:	180b883a 	mov	r5,r3
 4012878:	4014cc80 	call	4014cc8 <__umoddi3>
 401287c:	1009883a 	mov	r4,r2
 4012880:	180b883a 	mov	r5,r3
 4012884:	2005883a 	mov	r2,r4
 4012888:	2807883a 	mov	r3,r5
 401288c:	10800c04 	addi	r2,r2,48
 4012890:	94bfffc4 	addi	r18,r18,-1
 4012894:	90800005 	stb	r2,0(r18)
					  _uquad /= 10;
 4012898:	e0bff317 	ldw	r2,-52(fp)
 401289c:	e0fff417 	ldw	r3,-48(fp)
 40128a0:	01800284 	movi	r6,10
 40128a4:	000f883a 	mov	r7,zero
 40128a8:	1009883a 	mov	r4,r2
 40128ac:	180b883a 	mov	r5,r3
 40128b0:	40146ac0 	call	40146ac <__udivdi3>
 40128b4:	1009883a 	mov	r4,r2
 40128b8:	180b883a 	mov	r5,r3
 40128bc:	e13ff315 	stw	r4,-52(fp)
 40128c0:	e17ff415 	stw	r5,-48(fp)
					} while (_uquad != 0);
 40128c4:	e0bff317 	ldw	r2,-52(fp)
 40128c8:	e0fff417 	ldw	r3,-48(fp)
 40128cc:	10c4b03a 	or	r2,r2,r3
 40128d0:	103fe31e 	bne	r2,zero,4012860 <___vfiprintf_internal_r+0xb44>
					break;
 40128d4:	00001e06 	br	4012950 <___vfiprintf_internal_r+0xc34>
				case HEX:
 40128d8:	0001883a 	nop
						*--cp = xdigs[_uquad & 15];
 40128dc:	e0bff317 	ldw	r2,-52(fp)
 40128e0:	108003cc 	andi	r2,r2,15
 40128e4:	e0ffee17 	ldw	r3,-72(fp)
 40128e8:	1885883a 	add	r2,r3,r2
 40128ec:	94bfffc4 	addi	r18,r18,-1
 40128f0:	10800003 	ldbu	r2,0(r2)
 40128f4:	90800005 	stb	r2,0(r18)
						_uquad >>= 4;
 40128f8:	e0bff417 	ldw	r2,-48(fp)
 40128fc:	1004973a 	slli	r2,r2,28
 4012900:	e0fff317 	ldw	r3,-52(fp)
 4012904:	1806d13a 	srli	r3,r3,4
 4012908:	1884b03a 	or	r2,r3,r2
 401290c:	e0bff315 	stw	r2,-52(fp)
 4012910:	e0bff417 	ldw	r2,-48(fp)
 4012914:	1004d13a 	srli	r2,r2,4
 4012918:	e0bff415 	stw	r2,-48(fp)
					} while (_uquad);
 401291c:	e0bff317 	ldw	r2,-52(fp)
 4012920:	e0fff417 	ldw	r3,-48(fp)
 4012924:	10c4b03a 	or	r2,r2,r3
 4012928:	103feb1e 	bne	r2,zero,40128d8 <___vfiprintf_internal_r+0xbbc>
					break;
 401292c:	00000806 	br	4012950 <___vfiprintf_internal_r+0xc34>
					cp = "bug in vfprintf: bad base";
 4012930:	048100b4 	movhi	r18,1026
 4012934:	94ab7204 	addi	r18,r18,-21048
					size = strlen (cp);
 4012938:	9009883a 	mov	r4,r18
 401293c:	40078680 	call	4007868 <strlen>
 4012940:	e0bfef15 	stw	r2,-68(fp)
					goto skipsize;
 4012944:	0001883a 	nop
			break;
 4012948:	00001606 	br	40129a4 <___vfiprintf_internal_r+0xc88>
					break;
 401294c:	0001883a 	nop
				switch (base) {
 4012950:	00000706 	br	4012970 <___vfiprintf_internal_r+0xc54>
                       else if (base == OCT && (flags & ALT))
 4012954:	e0bff217 	ldw	r2,-56(fp)
 4012958:	1000051e 	bne	r2,zero,4012970 <___vfiprintf_internal_r+0xc54>
 401295c:	8880004c 	andi	r2,r17,1
 4012960:	10000326 	beq	r2,zero,4012970 <___vfiprintf_internal_r+0xc54>
                         *--cp = '0';
 4012964:	94bfffc4 	addi	r18,r18,-1
 4012968:	00800c04 	movi	r2,48
 401296c:	90800005 	stb	r2,0(r18)
			size = buf + BUF - cp;
 4012970:	e0bfcc04 	addi	r2,fp,-208
 4012974:	10800a04 	addi	r2,r2,40
 4012978:	1485c83a 	sub	r2,r2,r18
 401297c:	e0bfef15 	stw	r2,-68(fp)
			break;
 4012980:	00000806 	br	40129a4 <___vfiprintf_internal_r+0xc88>
			if (ch == '\0')
 4012984:	a8015426 	beq	r21,zero,4012ed8 <___vfiprintf_internal_r+0x11bc>
			cp = buf;
 4012988:	e4bfcc04 	addi	r18,fp,-208
			*cp = ch;
 401298c:	a805883a 	mov	r2,r21
 4012990:	90800005 	stb	r2,0(r18)
			size = 1;
 4012994:	00800044 	movi	r2,1
 4012998:	e0bfef15 	stw	r2,-68(fp)
			sign = '\0';
 401299c:	e03fe9c5 	stb	zero,-89(fp)
			break;
 40129a0:	0001883a 	nop
		realsz = dprec > size ? dprec : size;
 40129a4:	e0fff117 	ldw	r3,-60(fp)
 40129a8:	e0bfef17 	ldw	r2,-68(fp)
 40129ac:	10c0010e 	bge	r2,r3,40129b4 <___vfiprintf_internal_r+0xc98>
 40129b0:	1805883a 	mov	r2,r3
 40129b4:	e0bff015 	stw	r2,-64(fp)
		if (sign)
 40129b8:	e0bfe9c3 	ldbu	r2,-89(fp)
 40129bc:	10803fcc 	andi	r2,r2,255
 40129c0:	1080201c 	xori	r2,r2,128
 40129c4:	10bfe004 	addi	r2,r2,-128
 40129c8:	10000326 	beq	r2,zero,40129d8 <___vfiprintf_internal_r+0xcbc>
			realsz++;
 40129cc:	e0bff017 	ldw	r2,-64(fp)
 40129d0:	10800044 	addi	r2,r2,1
 40129d4:	e0bff015 	stw	r2,-64(fp)
		if (flags & HEXPREFIX)
 40129d8:	8880008c 	andi	r2,r17,2
 40129dc:	10000326 	beq	r2,zero,40129ec <___vfiprintf_internal_r+0xcd0>
			realsz+= 2;
 40129e0:	e0bff017 	ldw	r2,-64(fp)
 40129e4:	10800084 	addi	r2,r2,2
 40129e8:	e0bff015 	stw	r2,-64(fp)
		if ((flags & (LADJUST|ZEROPAD)) == 0)
 40129ec:	8880210c 	andi	r2,r17,132
 40129f0:	1000351e 	bne	r2,zero,4012ac8 <___vfiprintf_internal_r+0xdac>
			PAD (width - realsz, blanks);
 40129f4:	e0fff617 	ldw	r3,-40(fp)
 40129f8:	e0bff017 	ldw	r2,-64(fp)
 40129fc:	18a7c83a 	sub	r19,r3,r2
 4012a00:	04c0310e 	bge	zero,r19,4012ac8 <___vfiprintf_internal_r+0xdac>
 4012a04:	00001706 	br	4012a64 <___vfiprintf_internal_r+0xd48>
 4012a08:	008100b4 	movhi	r2,1026
 4012a0c:	10ab7904 	addi	r2,r2,-21020
 4012a10:	80800015 	stw	r2,0(r16)
 4012a14:	00800404 	movi	r2,16
 4012a18:	80800115 	stw	r2,4(r16)
 4012a1c:	e0bfe817 	ldw	r2,-96(fp)
 4012a20:	10800404 	addi	r2,r2,16
 4012a24:	e0bfe815 	stw	r2,-96(fp)
 4012a28:	84000204 	addi	r16,r16,8
 4012a2c:	e0bfe717 	ldw	r2,-100(fp)
 4012a30:	10800044 	addi	r2,r2,1
 4012a34:	e0bfe715 	stw	r2,-100(fp)
 4012a38:	e0bfe717 	ldw	r2,-100(fp)
 4012a3c:	10800210 	cmplti	r2,r2,8
 4012a40:	1000071e 	bne	r2,zero,4012a60 <___vfiprintf_internal_r+0xd44>
 4012a44:	e0bfe604 	addi	r2,fp,-104
 4012a48:	100d883a 	mov	r6,r2
 4012a4c:	e17fc917 	ldw	r5,-220(fp)
 4012a50:	e13fca17 	ldw	r4,-216(fp)
 4012a54:	4011aac0 	call	4011aac <__sprint_r>
 4012a58:	10012d1e 	bne	r2,zero,4012f10 <___vfiprintf_internal_r+0x11f4>
 4012a5c:	e43fd604 	addi	r16,fp,-168
 4012a60:	9cfffc04 	addi	r19,r19,-16
 4012a64:	98800448 	cmpgei	r2,r19,17
 4012a68:	103fe71e 	bne	r2,zero,4012a08 <___vfiprintf_internal_r+0xcec>
 4012a6c:	008100b4 	movhi	r2,1026
 4012a70:	10ab7904 	addi	r2,r2,-21020
 4012a74:	80800015 	stw	r2,0(r16)
 4012a78:	9805883a 	mov	r2,r19
 4012a7c:	80800115 	stw	r2,4(r16)
 4012a80:	e0bfe817 	ldw	r2,-96(fp)
 4012a84:	9807883a 	mov	r3,r19
 4012a88:	10c5883a 	add	r2,r2,r3
 4012a8c:	e0bfe815 	stw	r2,-96(fp)
 4012a90:	84000204 	addi	r16,r16,8
 4012a94:	e0bfe717 	ldw	r2,-100(fp)
 4012a98:	10800044 	addi	r2,r2,1
 4012a9c:	e0bfe715 	stw	r2,-100(fp)
 4012aa0:	e0bfe717 	ldw	r2,-100(fp)
 4012aa4:	10800210 	cmplti	r2,r2,8
 4012aa8:	1000071e 	bne	r2,zero,4012ac8 <___vfiprintf_internal_r+0xdac>
 4012aac:	e0bfe604 	addi	r2,fp,-104
 4012ab0:	100d883a 	mov	r6,r2
 4012ab4:	e17fc917 	ldw	r5,-220(fp)
 4012ab8:	e13fca17 	ldw	r4,-216(fp)
 4012abc:	4011aac0 	call	4011aac <__sprint_r>
 4012ac0:	1001151e 	bne	r2,zero,4012f18 <___vfiprintf_internal_r+0x11fc>
 4012ac4:	e43fd604 	addi	r16,fp,-168
		if (sign)
 4012ac8:	e0bfe9c3 	ldbu	r2,-89(fp)
 4012acc:	10803fcc 	andi	r2,r2,255
 4012ad0:	1080201c 	xori	r2,r2,128
 4012ad4:	10bfe004 	addi	r2,r2,-128
 4012ad8:	10001526 	beq	r2,zero,4012b30 <___vfiprintf_internal_r+0xe14>
			PRINT (&sign, 1);
 4012adc:	e0bfe9c4 	addi	r2,fp,-89
 4012ae0:	80800015 	stw	r2,0(r16)
 4012ae4:	00800044 	movi	r2,1
 4012ae8:	80800115 	stw	r2,4(r16)
 4012aec:	e0bfe817 	ldw	r2,-96(fp)
 4012af0:	10800044 	addi	r2,r2,1
 4012af4:	e0bfe815 	stw	r2,-96(fp)
 4012af8:	84000204 	addi	r16,r16,8
 4012afc:	e0bfe717 	ldw	r2,-100(fp)
 4012b00:	10800044 	addi	r2,r2,1
 4012b04:	e0bfe715 	stw	r2,-100(fp)
 4012b08:	e0bfe717 	ldw	r2,-100(fp)
 4012b0c:	10800210 	cmplti	r2,r2,8
 4012b10:	1000071e 	bne	r2,zero,4012b30 <___vfiprintf_internal_r+0xe14>
 4012b14:	e0bfe604 	addi	r2,fp,-104
 4012b18:	100d883a 	mov	r6,r2
 4012b1c:	e17fc917 	ldw	r5,-220(fp)
 4012b20:	e13fca17 	ldw	r4,-216(fp)
 4012b24:	4011aac0 	call	4011aac <__sprint_r>
 4012b28:	1000fd1e 	bne	r2,zero,4012f20 <___vfiprintf_internal_r+0x1204>
 4012b2c:	e43fd604 	addi	r16,fp,-168
		if (flags & HEXPREFIX)
 4012b30:	8880008c 	andi	r2,r17,2
 4012b34:	10001526 	beq	r2,zero,4012b8c <___vfiprintf_internal_r+0xe70>
			PRINT (ox, 2);
 4012b38:	e0bfcb84 	addi	r2,fp,-210
 4012b3c:	80800015 	stw	r2,0(r16)
 4012b40:	00800084 	movi	r2,2
 4012b44:	80800115 	stw	r2,4(r16)
 4012b48:	e0bfe817 	ldw	r2,-96(fp)
 4012b4c:	10800084 	addi	r2,r2,2
 4012b50:	e0bfe815 	stw	r2,-96(fp)
 4012b54:	84000204 	addi	r16,r16,8
 4012b58:	e0bfe717 	ldw	r2,-100(fp)
 4012b5c:	10800044 	addi	r2,r2,1
 4012b60:	e0bfe715 	stw	r2,-100(fp)
 4012b64:	e0bfe717 	ldw	r2,-100(fp)
 4012b68:	10800210 	cmplti	r2,r2,8
 4012b6c:	1000071e 	bne	r2,zero,4012b8c <___vfiprintf_internal_r+0xe70>
 4012b70:	e0bfe604 	addi	r2,fp,-104
 4012b74:	100d883a 	mov	r6,r2
 4012b78:	e17fc917 	ldw	r5,-220(fp)
 4012b7c:	e13fca17 	ldw	r4,-216(fp)
 4012b80:	4011aac0 	call	4011aac <__sprint_r>
 4012b84:	1000e81e 	bne	r2,zero,4012f28 <___vfiprintf_internal_r+0x120c>
 4012b88:	e43fd604 	addi	r16,fp,-168
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
 4012b8c:	8880210c 	andi	r2,r17,132
 4012b90:	10802018 	cmpnei	r2,r2,128
 4012b94:	1000351e 	bne	r2,zero,4012c6c <___vfiprintf_internal_r+0xf50>
			PAD (width - realsz, zeroes);
 4012b98:	e0fff617 	ldw	r3,-40(fp)
 4012b9c:	e0bff017 	ldw	r2,-64(fp)
 4012ba0:	18a7c83a 	sub	r19,r3,r2
 4012ba4:	04c0310e 	bge	zero,r19,4012c6c <___vfiprintf_internal_r+0xf50>
 4012ba8:	00001706 	br	4012c08 <___vfiprintf_internal_r+0xeec>
 4012bac:	008100b4 	movhi	r2,1026
 4012bb0:	10ab7d04 	addi	r2,r2,-21004
 4012bb4:	80800015 	stw	r2,0(r16)
 4012bb8:	00800404 	movi	r2,16
 4012bbc:	80800115 	stw	r2,4(r16)
 4012bc0:	e0bfe817 	ldw	r2,-96(fp)
 4012bc4:	10800404 	addi	r2,r2,16
 4012bc8:	e0bfe815 	stw	r2,-96(fp)
 4012bcc:	84000204 	addi	r16,r16,8
 4012bd0:	e0bfe717 	ldw	r2,-100(fp)
 4012bd4:	10800044 	addi	r2,r2,1
 4012bd8:	e0bfe715 	stw	r2,-100(fp)
 4012bdc:	e0bfe717 	ldw	r2,-100(fp)
 4012be0:	10800210 	cmplti	r2,r2,8
 4012be4:	1000071e 	bne	r2,zero,4012c04 <___vfiprintf_internal_r+0xee8>
 4012be8:	e0bfe604 	addi	r2,fp,-104
 4012bec:	100d883a 	mov	r6,r2
 4012bf0:	e17fc917 	ldw	r5,-220(fp)
 4012bf4:	e13fca17 	ldw	r4,-216(fp)
 4012bf8:	4011aac0 	call	4011aac <__sprint_r>
 4012bfc:	1000cc1e 	bne	r2,zero,4012f30 <___vfiprintf_internal_r+0x1214>
 4012c00:	e43fd604 	addi	r16,fp,-168
 4012c04:	9cfffc04 	addi	r19,r19,-16
 4012c08:	98800448 	cmpgei	r2,r19,17
 4012c0c:	103fe71e 	bne	r2,zero,4012bac <___vfiprintf_internal_r+0xe90>
 4012c10:	008100b4 	movhi	r2,1026
 4012c14:	10ab7d04 	addi	r2,r2,-21004
 4012c18:	80800015 	stw	r2,0(r16)
 4012c1c:	9805883a 	mov	r2,r19
 4012c20:	80800115 	stw	r2,4(r16)
 4012c24:	e0bfe817 	ldw	r2,-96(fp)
 4012c28:	9807883a 	mov	r3,r19
 4012c2c:	10c5883a 	add	r2,r2,r3
 4012c30:	e0bfe815 	stw	r2,-96(fp)
 4012c34:	84000204 	addi	r16,r16,8
 4012c38:	e0bfe717 	ldw	r2,-100(fp)
 4012c3c:	10800044 	addi	r2,r2,1
 4012c40:	e0bfe715 	stw	r2,-100(fp)
 4012c44:	e0bfe717 	ldw	r2,-100(fp)
 4012c48:	10800210 	cmplti	r2,r2,8
 4012c4c:	1000071e 	bne	r2,zero,4012c6c <___vfiprintf_internal_r+0xf50>
 4012c50:	e0bfe604 	addi	r2,fp,-104
 4012c54:	100d883a 	mov	r6,r2
 4012c58:	e17fc917 	ldw	r5,-220(fp)
 4012c5c:	e13fca17 	ldw	r4,-216(fp)
 4012c60:	4011aac0 	call	4011aac <__sprint_r>
 4012c64:	1000b41e 	bne	r2,zero,4012f38 <___vfiprintf_internal_r+0x121c>
 4012c68:	e43fd604 	addi	r16,fp,-168
		PAD (dprec - size, zeroes);
 4012c6c:	e0fff117 	ldw	r3,-60(fp)
 4012c70:	e0bfef17 	ldw	r2,-68(fp)
 4012c74:	18a7c83a 	sub	r19,r3,r2
 4012c78:	04c0310e 	bge	zero,r19,4012d40 <___vfiprintf_internal_r+0x1024>
 4012c7c:	00001706 	br	4012cdc <___vfiprintf_internal_r+0xfc0>
 4012c80:	008100b4 	movhi	r2,1026
 4012c84:	10ab7d04 	addi	r2,r2,-21004
 4012c88:	80800015 	stw	r2,0(r16)
 4012c8c:	00800404 	movi	r2,16
 4012c90:	80800115 	stw	r2,4(r16)
 4012c94:	e0bfe817 	ldw	r2,-96(fp)
 4012c98:	10800404 	addi	r2,r2,16
 4012c9c:	e0bfe815 	stw	r2,-96(fp)
 4012ca0:	84000204 	addi	r16,r16,8
 4012ca4:	e0bfe717 	ldw	r2,-100(fp)
 4012ca8:	10800044 	addi	r2,r2,1
 4012cac:	e0bfe715 	stw	r2,-100(fp)
 4012cb0:	e0bfe717 	ldw	r2,-100(fp)
 4012cb4:	10800210 	cmplti	r2,r2,8
 4012cb8:	1000071e 	bne	r2,zero,4012cd8 <___vfiprintf_internal_r+0xfbc>
 4012cbc:	e0bfe604 	addi	r2,fp,-104
 4012cc0:	100d883a 	mov	r6,r2
 4012cc4:	e17fc917 	ldw	r5,-220(fp)
 4012cc8:	e13fca17 	ldw	r4,-216(fp)
 4012ccc:	4011aac0 	call	4011aac <__sprint_r>
 4012cd0:	10009b1e 	bne	r2,zero,4012f40 <___vfiprintf_internal_r+0x1224>
 4012cd4:	e43fd604 	addi	r16,fp,-168
 4012cd8:	9cfffc04 	addi	r19,r19,-16
 4012cdc:	98800448 	cmpgei	r2,r19,17
 4012ce0:	103fe71e 	bne	r2,zero,4012c80 <___vfiprintf_internal_r+0xf64>
 4012ce4:	008100b4 	movhi	r2,1026
 4012ce8:	10ab7d04 	addi	r2,r2,-21004
 4012cec:	80800015 	stw	r2,0(r16)
 4012cf0:	9805883a 	mov	r2,r19
 4012cf4:	80800115 	stw	r2,4(r16)
 4012cf8:	e0bfe817 	ldw	r2,-96(fp)
 4012cfc:	9807883a 	mov	r3,r19
 4012d00:	10c5883a 	add	r2,r2,r3
 4012d04:	e0bfe815 	stw	r2,-96(fp)
 4012d08:	84000204 	addi	r16,r16,8
 4012d0c:	e0bfe717 	ldw	r2,-100(fp)
 4012d10:	10800044 	addi	r2,r2,1
 4012d14:	e0bfe715 	stw	r2,-100(fp)
 4012d18:	e0bfe717 	ldw	r2,-100(fp)
 4012d1c:	10800210 	cmplti	r2,r2,8
 4012d20:	1000071e 	bne	r2,zero,4012d40 <___vfiprintf_internal_r+0x1024>
 4012d24:	e0bfe604 	addi	r2,fp,-104
 4012d28:	100d883a 	mov	r6,r2
 4012d2c:	e17fc917 	ldw	r5,-220(fp)
 4012d30:	e13fca17 	ldw	r4,-216(fp)
 4012d34:	4011aac0 	call	4011aac <__sprint_r>
 4012d38:	1000831e 	bne	r2,zero,4012f48 <___vfiprintf_internal_r+0x122c>
 4012d3c:	e43fd604 	addi	r16,fp,-168
		PRINT (cp, size);
 4012d40:	84800015 	stw	r18,0(r16)
 4012d44:	e0bfef17 	ldw	r2,-68(fp)
 4012d48:	80800115 	stw	r2,4(r16)
 4012d4c:	e0ffe817 	ldw	r3,-96(fp)
 4012d50:	e0bfef17 	ldw	r2,-68(fp)
 4012d54:	1885883a 	add	r2,r3,r2
 4012d58:	e0bfe815 	stw	r2,-96(fp)
 4012d5c:	84000204 	addi	r16,r16,8
 4012d60:	e0bfe717 	ldw	r2,-100(fp)
 4012d64:	10800044 	addi	r2,r2,1
 4012d68:	e0bfe715 	stw	r2,-100(fp)
 4012d6c:	e0bfe717 	ldw	r2,-100(fp)
 4012d70:	10800210 	cmplti	r2,r2,8
 4012d74:	1000071e 	bne	r2,zero,4012d94 <___vfiprintf_internal_r+0x1078>
 4012d78:	e0bfe604 	addi	r2,fp,-104
 4012d7c:	100d883a 	mov	r6,r2
 4012d80:	e17fc917 	ldw	r5,-220(fp)
 4012d84:	e13fca17 	ldw	r4,-216(fp)
 4012d88:	4011aac0 	call	4011aac <__sprint_r>
 4012d8c:	1000701e 	bne	r2,zero,4012f50 <___vfiprintf_internal_r+0x1234>
 4012d90:	e43fd604 	addi	r16,fp,-168
		if (flags & LADJUST)
 4012d94:	8880010c 	andi	r2,r17,4
 4012d98:	10003526 	beq	r2,zero,4012e70 <___vfiprintf_internal_r+0x1154>
			PAD (width - realsz, blanks);
 4012d9c:	e0fff617 	ldw	r3,-40(fp)
 4012da0:	e0bff017 	ldw	r2,-64(fp)
 4012da4:	18a7c83a 	sub	r19,r3,r2
 4012da8:	04c0310e 	bge	zero,r19,4012e70 <___vfiprintf_internal_r+0x1154>
 4012dac:	00001706 	br	4012e0c <___vfiprintf_internal_r+0x10f0>
 4012db0:	008100b4 	movhi	r2,1026
 4012db4:	10ab7904 	addi	r2,r2,-21020
 4012db8:	80800015 	stw	r2,0(r16)
 4012dbc:	00800404 	movi	r2,16
 4012dc0:	80800115 	stw	r2,4(r16)
 4012dc4:	e0bfe817 	ldw	r2,-96(fp)
 4012dc8:	10800404 	addi	r2,r2,16
 4012dcc:	e0bfe815 	stw	r2,-96(fp)
 4012dd0:	84000204 	addi	r16,r16,8
 4012dd4:	e0bfe717 	ldw	r2,-100(fp)
 4012dd8:	10800044 	addi	r2,r2,1
 4012ddc:	e0bfe715 	stw	r2,-100(fp)
 4012de0:	e0bfe717 	ldw	r2,-100(fp)
 4012de4:	10800210 	cmplti	r2,r2,8
 4012de8:	1000071e 	bne	r2,zero,4012e08 <___vfiprintf_internal_r+0x10ec>
 4012dec:	e0bfe604 	addi	r2,fp,-104
 4012df0:	100d883a 	mov	r6,r2
 4012df4:	e17fc917 	ldw	r5,-220(fp)
 4012df8:	e13fca17 	ldw	r4,-216(fp)
 4012dfc:	4011aac0 	call	4011aac <__sprint_r>
 4012e00:	1000551e 	bne	r2,zero,4012f58 <___vfiprintf_internal_r+0x123c>
 4012e04:	e43fd604 	addi	r16,fp,-168
 4012e08:	9cfffc04 	addi	r19,r19,-16
 4012e0c:	98800448 	cmpgei	r2,r19,17
 4012e10:	103fe71e 	bne	r2,zero,4012db0 <___vfiprintf_internal_r+0x1094>
 4012e14:	008100b4 	movhi	r2,1026
 4012e18:	10ab7904 	addi	r2,r2,-21020
 4012e1c:	80800015 	stw	r2,0(r16)
 4012e20:	9805883a 	mov	r2,r19
 4012e24:	80800115 	stw	r2,4(r16)
 4012e28:	e0bfe817 	ldw	r2,-96(fp)
 4012e2c:	9807883a 	mov	r3,r19
 4012e30:	10c5883a 	add	r2,r2,r3
 4012e34:	e0bfe815 	stw	r2,-96(fp)
 4012e38:	84000204 	addi	r16,r16,8
 4012e3c:	e0bfe717 	ldw	r2,-100(fp)
 4012e40:	10800044 	addi	r2,r2,1
 4012e44:	e0bfe715 	stw	r2,-100(fp)
 4012e48:	e0bfe717 	ldw	r2,-100(fp)
 4012e4c:	10800210 	cmplti	r2,r2,8
 4012e50:	1000071e 	bne	r2,zero,4012e70 <___vfiprintf_internal_r+0x1154>
 4012e54:	e0bfe604 	addi	r2,fp,-104
 4012e58:	100d883a 	mov	r6,r2
 4012e5c:	e17fc917 	ldw	r5,-220(fp)
 4012e60:	e13fca17 	ldw	r4,-216(fp)
 4012e64:	4011aac0 	call	4011aac <__sprint_r>
 4012e68:	10003d1e 	bne	r2,zero,4012f60 <___vfiprintf_internal_r+0x1244>
 4012e6c:	e43fd604 	addi	r16,fp,-168
		ret += width > realsz ? width : realsz;
 4012e70:	e0fff617 	ldw	r3,-40(fp)
 4012e74:	e0bff017 	ldw	r2,-64(fp)
 4012e78:	10c0010e 	bge	r2,r3,4012e80 <___vfiprintf_internal_r+0x1164>
 4012e7c:	1805883a 	mov	r2,r3
 4012e80:	e0fff717 	ldw	r3,-36(fp)
 4012e84:	1885883a 	add	r2,r3,r2
 4012e88:	e0bff715 	stw	r2,-36(fp)
		FLUSH ();	/* copy out the I/O vectors */
 4012e8c:	e0bfe817 	ldw	r2,-96(fp)
 4012e90:	10000626 	beq	r2,zero,4012eac <___vfiprintf_internal_r+0x1190>
 4012e94:	e0bfe604 	addi	r2,fp,-104
 4012e98:	100d883a 	mov	r6,r2
 4012e9c:	e17fc917 	ldw	r5,-220(fp)
 4012ea0:	e13fca17 	ldw	r4,-216(fp)
 4012ea4:	4011aac0 	call	4011aac <__sprint_r>
 4012ea8:	10002f1e 	bne	r2,zero,4012f68 <___vfiprintf_internal_r+0x124c>
 4012eac:	e03fe715 	stw	zero,-100(fp)
 4012eb0:	e43fd604 	addi	r16,fp,-168
                if (malloc_buf != NULL) {
 4012eb4:	e0bfed17 	ldw	r2,-76(fp)
 4012eb8:	103beb26 	beq	r2,zero,4011e68 <___vfiprintf_internal_r+0x14c>
			_free_r (data, malloc_buf);
 4012ebc:	e17fed17 	ldw	r5,-76(fp)
 4012ec0:	e13fca17 	ldw	r4,-216(fp)
 4012ec4:	400cb0c0 	call	400cb0c <_free_r>
			malloc_buf = NULL;
 4012ec8:	e03fed15 	stw	zero,-76(fp)
	        cp = fmt;
 4012ecc:	003be606 	br	4011e68 <___vfiprintf_internal_r+0x14c>
                    goto done;
 4012ed0:	0001883a 	nop
 4012ed4:	00000106 	br	4012edc <___vfiprintf_internal_r+0x11c0>
				goto done;
 4012ed8:	0001883a 	nop
	FLUSH ();
 4012edc:	e0bfe817 	ldw	r2,-96(fp)
 4012ee0:	10000626 	beq	r2,zero,4012efc <___vfiprintf_internal_r+0x11e0>
 4012ee4:	e0bfe604 	addi	r2,fp,-104
 4012ee8:	100d883a 	mov	r6,r2
 4012eec:	e17fc917 	ldw	r5,-220(fp)
 4012ef0:	e13fca17 	ldw	r4,-216(fp)
 4012ef4:	4011aac0 	call	4011aac <__sprint_r>
 4012ef8:	10001d1e 	bne	r2,zero,4012f70 <___vfiprintf_internal_r+0x1254>
 4012efc:	e03fe715 	stw	zero,-100(fp)
 4012f00:	e43fd604 	addi	r16,fp,-168
 4012f04:	00001b06 	br	4012f74 <___vfiprintf_internal_r+0x1258>
			PRINT (cp, m);
 4012f08:	0001883a 	nop
 4012f0c:	00001906 	br	4012f74 <___vfiprintf_internal_r+0x1258>
			PAD (width - realsz, blanks);
 4012f10:	0001883a 	nop
 4012f14:	00001706 	br	4012f74 <___vfiprintf_internal_r+0x1258>
 4012f18:	0001883a 	nop
 4012f1c:	00001506 	br	4012f74 <___vfiprintf_internal_r+0x1258>
			PRINT (&sign, 1);
 4012f20:	0001883a 	nop
 4012f24:	00001306 	br	4012f74 <___vfiprintf_internal_r+0x1258>
			PRINT (ox, 2);
 4012f28:	0001883a 	nop
 4012f2c:	00001106 	br	4012f74 <___vfiprintf_internal_r+0x1258>
			PAD (width - realsz, zeroes);
 4012f30:	0001883a 	nop
 4012f34:	00000f06 	br	4012f74 <___vfiprintf_internal_r+0x1258>
 4012f38:	0001883a 	nop
 4012f3c:	00000d06 	br	4012f74 <___vfiprintf_internal_r+0x1258>
		PAD (dprec - size, zeroes);
 4012f40:	0001883a 	nop
 4012f44:	00000b06 	br	4012f74 <___vfiprintf_internal_r+0x1258>
 4012f48:	0001883a 	nop
 4012f4c:	00000906 	br	4012f74 <___vfiprintf_internal_r+0x1258>
		PRINT (cp, size);
 4012f50:	0001883a 	nop
 4012f54:	00000706 	br	4012f74 <___vfiprintf_internal_r+0x1258>
			PAD (width - realsz, blanks);
 4012f58:	0001883a 	nop
 4012f5c:	00000506 	br	4012f74 <___vfiprintf_internal_r+0x1258>
 4012f60:	0001883a 	nop
 4012f64:	00000306 	br	4012f74 <___vfiprintf_internal_r+0x1258>
		FLUSH ();	/* copy out the I/O vectors */
 4012f68:	0001883a 	nop
 4012f6c:	00000106 	br	4012f74 <___vfiprintf_internal_r+0x1258>
	FLUSH ();
 4012f70:	0001883a 	nop
	if (malloc_buf != NULL)
 4012f74:	e0bfed17 	ldw	r2,-76(fp)
 4012f78:	10000326 	beq	r2,zero,4012f88 <___vfiprintf_internal_r+0x126c>
		_free_r (data, malloc_buf);
 4012f7c:	e17fed17 	ldw	r5,-76(fp)
 4012f80:	e13fca17 	ldw	r4,-216(fp)
 4012f84:	400cb0c0 	call	400cb0c <_free_r>
	return (__sferror (fp) ? EOF : ret);
 4012f88:	e0bfc917 	ldw	r2,-220(fp)
 4012f8c:	1080030b 	ldhu	r2,12(r2)
 4012f90:	10bfffcc 	andi	r2,r2,65535
 4012f94:	1080100c 	andi	r2,r2,64
 4012f98:	1000021e 	bne	r2,zero,4012fa4 <___vfiprintf_internal_r+0x1288>
 4012f9c:	e0bff717 	ldw	r2,-36(fp)
 4012fa0:	00000106 	br	4012fa8 <___vfiprintf_internal_r+0x128c>
 4012fa4:	00bfffc4 	movi	r2,-1
}
 4012fa8:	e6fff804 	addi	sp,fp,-32
 4012fac:	dfc00917 	ldw	ra,36(sp)
 4012fb0:	df000817 	ldw	fp,32(sp)
 4012fb4:	ddc00717 	ldw	r23,28(sp)
 4012fb8:	dd800617 	ldw	r22,24(sp)
 4012fbc:	dd400517 	ldw	r21,20(sp)
 4012fc0:	dd000417 	ldw	r20,16(sp)
 4012fc4:	dcc00317 	ldw	r19,12(sp)
 4012fc8:	dc800217 	ldw	r18,8(sp)
 4012fcc:	dc400117 	ldw	r17,4(sp)
 4012fd0:	dc000017 	ldw	r16,0(sp)
 4012fd4:	dec00a04 	addi	sp,sp,40
 4012fd8:	f800283a 	ret

04012fdc <_write_r>:
_ssize_t
_write_r (struct _reent *ptr,
     int fd,
     const void *buf,
     size_t cnt)
{
 4012fdc:	defff904 	addi	sp,sp,-28
 4012fe0:	dfc00615 	stw	ra,24(sp)
 4012fe4:	df000515 	stw	fp,20(sp)
 4012fe8:	df000504 	addi	fp,sp,20
 4012fec:	e13ffe15 	stw	r4,-8(fp)
 4012ff0:	e17ffd15 	stw	r5,-12(fp)
 4012ff4:	e1bffc15 	stw	r6,-16(fp)
 4012ff8:	e1fffb15 	stw	r7,-20(fp)
  _ssize_t ret;

  errno = 0;
 4012ffc:	d0272715 	stw	zero,-25444(gp)
  if ((ret = (_ssize_t)_write (fd, buf, cnt)) == -1 && errno != 0)
 4013000:	e1bffb17 	ldw	r6,-20(fp)
 4013004:	e17ffc17 	ldw	r5,-16(fp)
 4013008:	e13ffd17 	ldw	r4,-12(fp)
 401300c:	40189900 	call	4018990 <write>
 4013010:	e0bfff15 	stw	r2,-4(fp)
 4013014:	e0bfff17 	ldw	r2,-4(fp)
 4013018:	10bfffd8 	cmpnei	r2,r2,-1
 401301c:	1000051e 	bne	r2,zero,4013034 <_write_r+0x58>
 4013020:	d0a72717 	ldw	r2,-25444(gp)
 4013024:	10000326 	beq	r2,zero,4013034 <_write_r+0x58>
    ptr->_errno = errno;
 4013028:	d0e72717 	ldw	r3,-25444(gp)
 401302c:	e0bffe17 	ldw	r2,-8(fp)
 4013030:	10c00015 	stw	r3,0(r2)
  return ret;
 4013034:	e0bfff17 	ldw	r2,-4(fp)
}
 4013038:	e037883a 	mov	sp,fp
 401303c:	dfc00117 	ldw	ra,4(sp)
 4013040:	df000017 	ldw	fp,0(sp)
 4013044:	dec00204 	addi	sp,sp,8
 4013048:	f800283a 	ret

0401304c <_close_r>:

int
_close_r (ptr, fd)
     struct _reent *ptr;
     int fd;
{
 401304c:	defffb04 	addi	sp,sp,-20
 4013050:	dfc00415 	stw	ra,16(sp)
 4013054:	df000315 	stw	fp,12(sp)
 4013058:	df000304 	addi	fp,sp,12
 401305c:	e13ffe15 	stw	r4,-8(fp)
 4013060:	e17ffd15 	stw	r5,-12(fp)
  int ret;

  errno = 0;
 4013064:	d0272715 	stw	zero,-25444(gp)
  if ((ret = _close (fd)) == -1 && errno != 0)
 4013068:	e13ffd17 	ldw	r4,-12(fp)
 401306c:	4017cd80 	call	4017cd8 <close>
 4013070:	e0bfff15 	stw	r2,-4(fp)
 4013074:	e0bfff17 	ldw	r2,-4(fp)
 4013078:	10bfffd8 	cmpnei	r2,r2,-1
 401307c:	1000051e 	bne	r2,zero,4013094 <_close_r+0x48>
 4013080:	d0a72717 	ldw	r2,-25444(gp)
 4013084:	10000326 	beq	r2,zero,4013094 <_close_r+0x48>
    ptr->_errno = errno;
 4013088:	d0e72717 	ldw	r3,-25444(gp)
 401308c:	e0bffe17 	ldw	r2,-8(fp)
 4013090:	10c00015 	stw	r3,0(r2)
  return ret;
 4013094:	e0bfff17 	ldw	r2,-4(fp)
}
 4013098:	e037883a 	mov	sp,fp
 401309c:	dfc00117 	ldw	ra,4(sp)
 40130a0:	df000017 	ldw	fp,0(sp)
 40130a4:	dec00204 	addi	sp,sp,8
 40130a8:	f800283a 	ret

040130ac <__assert_func>:
void
__assert_func (const char *file,
	int line,
	const char *func,
	const char *failedexpr)
{
 40130ac:	defff704 	addi	sp,sp,-36
 40130b0:	dfc00815 	stw	ra,32(sp)
 40130b4:	df000715 	stw	fp,28(sp)
 40130b8:	df000704 	addi	fp,sp,28
 40130bc:	e13fff15 	stw	r4,-4(fp)
 40130c0:	e17ffe15 	stw	r5,-8(fp)
 40130c4:	e1bffd15 	stw	r6,-12(fp)
 40130c8:	e1fffc15 	stw	r7,-16(fp)
  fiprintf(stderr,
 40130cc:	d0a00117 	ldw	r2,-32764(gp)
 40130d0:	11000317 	ldw	r4,12(r2)
 40130d4:	e0bffd17 	ldw	r2,-12(fp)
 40130d8:	10000326 	beq	r2,zero,40130e8 <__assert_func+0x3c>
 40130dc:	008100b4 	movhi	r2,1026
 40130e0:	10ab8104 	addi	r2,r2,-20988
 40130e4:	00000206 	br	40130f0 <__assert_func+0x44>
 40130e8:	008100b4 	movhi	r2,1026
 40130ec:	10ab8504 	addi	r2,r2,-20972
 40130f0:	e0fffd17 	ldw	r3,-12(fp)
 40130f4:	18000226 	beq	r3,zero,4013100 <__assert_func+0x54>
 40130f8:	e0fffd17 	ldw	r3,-12(fp)
 40130fc:	00000206 	br	4013108 <__assert_func+0x5c>
 4013100:	00c100b4 	movhi	r3,1026
 4013104:	18eb8504 	addi	r3,r3,-20972
 4013108:	d8c00215 	stw	r3,8(sp)
 401310c:	d8800115 	stw	r2,4(sp)
 4013110:	e0bffe17 	ldw	r2,-8(fp)
 4013114:	d8800015 	stw	r2,0(sp)
 4013118:	e1ffff17 	ldw	r7,-4(fp)
 401311c:	e1bffc17 	ldw	r6,-16(fp)
 4013120:	014100b4 	movhi	r5,1026
 4013124:	296b8604 	addi	r5,r5,-20968
 4013128:	40134840 	call	4013484 <fiprintf>
	   "assertion \"%s\" failed: file \"%s\", line %d%s%s\n",
	   failedexpr, file, line,
	   func ? ", function: " : "", func ? func : "");
  abort();
 401312c:	40141d80 	call	40141d8 <abort>

04013130 <__assert>:

void
__assert (const char *file,
	int line,
	const char *failedexpr)
{
 4013130:	defffb04 	addi	sp,sp,-20
 4013134:	dfc00415 	stw	ra,16(sp)
 4013138:	df000315 	stw	fp,12(sp)
 401313c:	df000304 	addi	fp,sp,12
 4013140:	e13fff15 	stw	r4,-4(fp)
 4013144:	e17ffe15 	stw	r5,-8(fp)
 4013148:	e1bffd15 	stw	r6,-12(fp)
   __assert_func (file, line, NULL, failedexpr);
 401314c:	e1fffd17 	ldw	r7,-12(fp)
 4013150:	000d883a 	mov	r6,zero
 4013154:	e17ffe17 	ldw	r5,-8(fp)
 4013158:	e13fff17 	ldw	r4,-4(fp)
 401315c:	40130ac0 	call	40130ac <__assert_func>

04013160 <_calloc_r>:
{
 4013160:	defff504 	addi	sp,sp,-44
 4013164:	dfc00a15 	stw	ra,40(sp)
 4013168:	df000915 	stw	fp,36(sp)
 401316c:	df000904 	addi	fp,sp,36
 4013170:	e13ff915 	stw	r4,-28(fp)
 4013174:	e17ff815 	stw	r5,-32(fp)
 4013178:	e1bff715 	stw	r6,-36(fp)
  INTERNAL_SIZE_T sz = n * elem_size;
 401317c:	e17ff717 	ldw	r5,-36(fp)
 4013180:	e13ff817 	ldw	r4,-32(fp)
 4013184:	40072d80 	call	40072d8 <__mulsi3>
 4013188:	e0bffe15 	stw	r2,-8(fp)
  mem = mALLOc (RCALL sz);
 401318c:	e17ffe17 	ldw	r5,-8(fp)
 4013190:	e13ff917 	ldw	r4,-28(fp)
 4013194:	400e1400 	call	400e140 <_malloc_r>
 4013198:	e0bffd15 	stw	r2,-12(fp)
  if (mem == 0) 
 401319c:	e0bffd17 	ldw	r2,-12(fp)
 40131a0:	1000021e 	bne	r2,zero,40131ac <_calloc_r+0x4c>
    return 0;
 40131a4:	0005883a 	mov	r2,zero
 40131a8:	00004106 	br	40132b0 <_calloc_r+0x150>
    p = mem2chunk(mem);
 40131ac:	e0bffd17 	ldw	r2,-12(fp)
 40131b0:	10bffe04 	addi	r2,r2,-8
 40131b4:	e0bffc15 	stw	r2,-16(fp)
    csz = chunksize(p);
 40131b8:	e0bffc17 	ldw	r2,-16(fp)
 40131bc:	10c00117 	ldw	r3,4(r2)
 40131c0:	00bfff04 	movi	r2,-4
 40131c4:	1884703a 	and	r2,r3,r2
 40131c8:	e0bffb15 	stw	r2,-20(fp)
    MALLOC_ZERO(mem, csz - SIZE_SZ);
 40131cc:	e0bffb17 	ldw	r2,-20(fp)
 40131d0:	10bfff04 	addi	r2,r2,-4
 40131d4:	e0bffa15 	stw	r2,-24(fp)
 40131d8:	e0bffa17 	ldw	r2,-24(fp)
 40131dc:	10800968 	cmpgeui	r2,r2,37
 40131e0:	10002e1e 	bne	r2,zero,401329c <_calloc_r+0x13c>
 40131e4:	e0bffd17 	ldw	r2,-12(fp)
 40131e8:	e0bfff15 	stw	r2,-4(fp)
 40131ec:	e0bffa17 	ldw	r2,-24(fp)
 40131f0:	10800530 	cmpltui	r2,r2,20
 40131f4:	10001e1e 	bne	r2,zero,4013270 <_calloc_r+0x110>
 40131f8:	e0bfff17 	ldw	r2,-4(fp)
 40131fc:	10c00104 	addi	r3,r2,4
 4013200:	e0ffff15 	stw	r3,-4(fp)
 4013204:	10000015 	stw	zero,0(r2)
 4013208:	e0bfff17 	ldw	r2,-4(fp)
 401320c:	10c00104 	addi	r3,r2,4
 4013210:	e0ffff15 	stw	r3,-4(fp)
 4013214:	10000015 	stw	zero,0(r2)
 4013218:	e0bffa17 	ldw	r2,-24(fp)
 401321c:	10800730 	cmpltui	r2,r2,28
 4013220:	1000131e 	bne	r2,zero,4013270 <_calloc_r+0x110>
 4013224:	e0bfff17 	ldw	r2,-4(fp)
 4013228:	10c00104 	addi	r3,r2,4
 401322c:	e0ffff15 	stw	r3,-4(fp)
 4013230:	10000015 	stw	zero,0(r2)
 4013234:	e0bfff17 	ldw	r2,-4(fp)
 4013238:	10c00104 	addi	r3,r2,4
 401323c:	e0ffff15 	stw	r3,-4(fp)
 4013240:	10000015 	stw	zero,0(r2)
 4013244:	e0bffa17 	ldw	r2,-24(fp)
 4013248:	10800930 	cmpltui	r2,r2,36
 401324c:	1000081e 	bne	r2,zero,4013270 <_calloc_r+0x110>
 4013250:	e0bfff17 	ldw	r2,-4(fp)
 4013254:	10c00104 	addi	r3,r2,4
 4013258:	e0ffff15 	stw	r3,-4(fp)
 401325c:	10000015 	stw	zero,0(r2)
 4013260:	e0bfff17 	ldw	r2,-4(fp)
 4013264:	10c00104 	addi	r3,r2,4
 4013268:	e0ffff15 	stw	r3,-4(fp)
 401326c:	10000015 	stw	zero,0(r2)
 4013270:	e0bfff17 	ldw	r2,-4(fp)
 4013274:	10c00104 	addi	r3,r2,4
 4013278:	e0ffff15 	stw	r3,-4(fp)
 401327c:	10000015 	stw	zero,0(r2)
 4013280:	e0bfff17 	ldw	r2,-4(fp)
 4013284:	10c00104 	addi	r3,r2,4
 4013288:	e0ffff15 	stw	r3,-4(fp)
 401328c:	10000015 	stw	zero,0(r2)
 4013290:	e0bfff17 	ldw	r2,-4(fp)
 4013294:	10000015 	stw	zero,0(r2)
 4013298:	00000406 	br	40132ac <_calloc_r+0x14c>
 401329c:	e1bffa17 	ldw	r6,-24(fp)
 40132a0:	000b883a 	mov	r5,zero
 40132a4:	e13ffd17 	ldw	r4,-12(fp)
 40132a8:	40074880 	call	4007488 <memset>
    return mem;
 40132ac:	e0bffd17 	ldw	r2,-12(fp)
}
 40132b0:	e037883a 	mov	sp,fp
 40132b4:	dfc00117 	ldw	ra,4(sp)
 40132b8:	df000017 	ldw	fp,0(sp)
 40132bc:	dec00204 	addi	sp,sp,8
 40132c0:	f800283a 	ret

040132c4 <_fclose_r>:
#include "local.h"

int
_fclose_r (struct _reent *rptr,
      register FILE * fp)
{
 40132c4:	defffa04 	addi	sp,sp,-24
 40132c8:	dfc00515 	stw	ra,20(sp)
 40132cc:	df000415 	stw	fp,16(sp)
 40132d0:	dc000315 	stw	r16,12(sp)
 40132d4:	df000404 	addi	fp,sp,16
 40132d8:	e13ffc15 	stw	r4,-16(fp)
 40132dc:	2821883a 	mov	r16,r5
  int r;

  if (fp == NULL)
 40132e0:	8000021e 	bne	r16,zero,40132ec <_fclose_r+0x28>
    return (0);			/* on NULL */
 40132e4:	0005883a 	mov	r2,zero
 40132e8:	00003b06 	br	40133d8 <_fclose_r+0x114>

  CHECK_INIT (rptr, fp);
 40132ec:	e0bffc17 	ldw	r2,-16(fp)
 40132f0:	e0bffd15 	stw	r2,-12(fp)
 40132f4:	e0bffd17 	ldw	r2,-12(fp)
 40132f8:	10000526 	beq	r2,zero,4013310 <_fclose_r+0x4c>
 40132fc:	e0bffd17 	ldw	r2,-12(fp)
 4013300:	10800e17 	ldw	r2,56(r2)
 4013304:	1000021e 	bne	r2,zero,4013310 <_fclose_r+0x4c>
 4013308:	e13ffd17 	ldw	r4,-12(fp)
 401330c:	400c9100 	call	400c910 <__sinit>
  pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, &__oldcancel);
#endif
  if (!(fp->_flags2 & __SNLK))
    _flockfile (fp);

  if (fp->_flags == 0)		/* not open! */
 4013310:	8080030b 	ldhu	r2,12(r16)
 4013314:	10bfffcc 	andi	r2,r2,65535
 4013318:	10a0001c 	xori	r2,r2,32768
 401331c:	10a00004 	addi	r2,r2,-32768
 4013320:	1000021e 	bne	r2,zero,401332c <_fclose_r+0x68>
      if (!(fp->_flags2 & __SNLK))
	_funlockfile (fp);
#ifdef _STDIO_WITH_THREAD_CANCELLATION_SUPPORT
      pthread_setcancelstate (__oldcancel, &__oldcancel);
#endif
      return (0);
 4013324:	0005883a 	mov	r2,zero
 4013328:	00002b06 	br	40133d8 <_fclose_r+0x114>
  r = (fp->_flags & __SWR) ? __sflush_r (rptr, fp) : 0;
#else
  /* Follow POSIX semantics exactly.  Unconditionally flush to allow
     special handling for seekable read files to reposition file to last
     byte processed as opposed to last byte read ahead into the buffer. */
  r = __sflush_r (rptr, fp);
 401332c:	800b883a 	mov	r5,r16
 4013330:	e13ffc17 	ldw	r4,-16(fp)
 4013334:	400c0cc0 	call	400c0cc <__sflush_r>
 4013338:	e0bffe15 	stw	r2,-8(fp)
#endif
  if (fp->_close != NULL && fp->_close (rptr, fp->_cookie) < 0)
 401333c:	80800b17 	ldw	r2,44(r16)
 4013340:	10000826 	beq	r2,zero,4013364 <_fclose_r+0xa0>
 4013344:	80800b17 	ldw	r2,44(r16)
 4013348:	80c00717 	ldw	r3,28(r16)
 401334c:	180b883a 	mov	r5,r3
 4013350:	e13ffc17 	ldw	r4,-16(fp)
 4013354:	103ee83a 	callr	r2
 4013358:	1000020e 	bge	r2,zero,4013364 <_fclose_r+0xa0>
    r = EOF;
 401335c:	00bfffc4 	movi	r2,-1
 4013360:	e0bffe15 	stw	r2,-8(fp)
  if (fp->_flags & __SMBF)
 4013364:	8080030b 	ldhu	r2,12(r16)
 4013368:	10bfffcc 	andi	r2,r2,65535
 401336c:	1080200c 	andi	r2,r2,128
 4013370:	10000426 	beq	r2,zero,4013384 <_fclose_r+0xc0>
    _free_r (rptr, (char *) fp->_bf._base);
 4013374:	80800417 	ldw	r2,16(r16)
 4013378:	100b883a 	mov	r5,r2
 401337c:	e13ffc17 	ldw	r4,-16(fp)
 4013380:	400cb0c0 	call	400cb0c <_free_r>
  if (HASUB (fp))
 4013384:	80800c17 	ldw	r2,48(r16)
 4013388:	10000826 	beq	r2,zero,40133ac <_fclose_r+0xe8>
    FREEUB (rptr, fp);
 401338c:	80c00c17 	ldw	r3,48(r16)
 4013390:	80801004 	addi	r2,r16,64
 4013394:	18800426 	beq	r3,r2,40133a8 <_fclose_r+0xe4>
 4013398:	80800c17 	ldw	r2,48(r16)
 401339c:	100b883a 	mov	r5,r2
 40133a0:	e13ffc17 	ldw	r4,-16(fp)
 40133a4:	400cb0c0 	call	400cb0c <_free_r>
 40133a8:	80000c15 	stw	zero,48(r16)
  if (HASLB (fp))
 40133ac:	80801117 	ldw	r2,68(r16)
 40133b0:	10000526 	beq	r2,zero,40133c8 <_fclose_r+0x104>
    FREELB (rptr, fp);
 40133b4:	80801117 	ldw	r2,68(r16)
 40133b8:	100b883a 	mov	r5,r2
 40133bc:	e13ffc17 	ldw	r4,-16(fp)
 40133c0:	400cb0c0 	call	400cb0c <_free_r>
 40133c4:	80001115 	stw	zero,68(r16)
  __sfp_lock_acquire ();
 40133c8:	400c9c40 	call	400c9c4 <__sfp_lock_acquire>
  fp->_flags = 0;		/* release this FILE for reuse */
 40133cc:	8000030d 	sth	zero,12(r16)
    _funlockfile (fp);
#ifndef __SINGLE_THREAD__
  __lock_close_recursive (fp->_lock);
#endif

  __sfp_lock_release ();
 40133d0:	400c9e40 	call	400c9e4 <__sfp_lock_release>
#ifdef _STDIO_WITH_THREAD_CANCELLATION_SUPPORT
  pthread_setcancelstate (__oldcancel, &__oldcancel);
#endif

  return (r);
 40133d4:	e0bffe17 	ldw	r2,-8(fp)
}
 40133d8:	e6ffff04 	addi	sp,fp,-4
 40133dc:	dfc00217 	ldw	ra,8(sp)
 40133e0:	df000117 	ldw	fp,4(sp)
 40133e4:	dc000017 	ldw	r16,0(sp)
 40133e8:	dec00304 	addi	sp,sp,12
 40133ec:	f800283a 	ret

040133f0 <fclose>:

#ifndef _REENT_ONLY

int
fclose (register FILE * fp)
{
 40133f0:	defffe04 	addi	sp,sp,-8
 40133f4:	dfc00115 	stw	ra,4(sp)
 40133f8:	df000015 	stw	fp,0(sp)
 40133fc:	d839883a 	mov	fp,sp
 4013400:	2007883a 	mov	r3,r4
  return _fclose_r(_REENT, fp);
 4013404:	d0a00117 	ldw	r2,-32764(gp)
 4013408:	180b883a 	mov	r5,r3
 401340c:	1009883a 	mov	r4,r2
 4013410:	40132c40 	call	40132c4 <_fclose_r>
}
 4013414:	e037883a 	mov	sp,fp
 4013418:	dfc00117 	ldw	ra,4(sp)
 401341c:	df000017 	ldw	fp,0(sp)
 4013420:	dec00204 	addi	sp,sp,8
 4013424:	f800283a 	ret

04013428 <_fiprintf_r>:

int
_fiprintf_r (struct _reent *ptr,
       FILE * fp,
       const char *fmt, ...)
{
 4013428:	defff804 	addi	sp,sp,-32
 401342c:	dfc00615 	stw	ra,24(sp)
 4013430:	df000515 	stw	fp,20(sp)
 4013434:	df000504 	addi	fp,sp,20
 4013438:	e13ffd15 	stw	r4,-12(fp)
 401343c:	e17ffc15 	stw	r5,-16(fp)
 4013440:	e1bffb15 	stw	r6,-20(fp)
 4013444:	e1c00215 	stw	r7,8(fp)
  int ret;
  va_list ap;

  va_start (ap, fmt);
 4013448:	e0800204 	addi	r2,fp,8
 401344c:	e0bffe15 	stw	r2,-8(fp)
  ret = _vfiprintf_r (ptr, fp, fmt, ap);
 4013450:	e0bffe17 	ldw	r2,-8(fp)
 4013454:	100f883a 	mov	r7,r2
 4013458:	e1bffb17 	ldw	r6,-20(fp)
 401345c:	e17ffc17 	ldw	r5,-16(fp)
 4013460:	e13ffd17 	ldw	r4,-12(fp)
 4013464:	4013d100 	call	4013d10 <_vfiprintf_r>
 4013468:	e0bfff15 	stw	r2,-4(fp)
  va_end (ap);
  return ret;
 401346c:	e0bfff17 	ldw	r2,-4(fp)
}
 4013470:	e037883a 	mov	sp,fp
 4013474:	dfc00117 	ldw	ra,4(sp)
 4013478:	df000017 	ldw	fp,0(sp)
 401347c:	dec00304 	addi	sp,sp,12
 4013480:	f800283a 	ret

04013484 <fiprintf>:
#ifndef _REENT_ONLY

int
fiprintf (FILE * fp,
       const char *fmt, ...)
{
 4013484:	defff804 	addi	sp,sp,-32
 4013488:	dfc00515 	stw	ra,20(sp)
 401348c:	df000415 	stw	fp,16(sp)
 4013490:	df000404 	addi	fp,sp,16
 4013494:	e13ffd15 	stw	r4,-12(fp)
 4013498:	e17ffc15 	stw	r5,-16(fp)
 401349c:	e1800215 	stw	r6,8(fp)
 40134a0:	e1c00315 	stw	r7,12(fp)
  int ret;
  va_list ap;

  va_start (ap, fmt);
 40134a4:	e0800204 	addi	r2,fp,8
 40134a8:	e0bffe15 	stw	r2,-8(fp)
  ret = _vfiprintf_r (_REENT, fp, fmt, ap);
 40134ac:	d0a00117 	ldw	r2,-32764(gp)
 40134b0:	e0fffe17 	ldw	r3,-8(fp)
 40134b4:	180f883a 	mov	r7,r3
 40134b8:	e1bffc17 	ldw	r6,-16(fp)
 40134bc:	e17ffd17 	ldw	r5,-12(fp)
 40134c0:	1009883a 	mov	r4,r2
 40134c4:	4013d100 	call	4013d10 <_vfiprintf_r>
 40134c8:	e0bfff15 	stw	r2,-4(fp)
  va_end (ap);
  return ret;
 40134cc:	e0bfff17 	ldw	r2,-4(fp)
}
 40134d0:	e037883a 	mov	sp,fp
 40134d4:	dfc00117 	ldw	ra,4(sp)
 40134d8:	df000017 	ldw	fp,0(sp)
 40134dc:	dec00404 	addi	sp,sp,16
 40134e0:	f800283a 	ret

040134e4 <__fputwc>:

wint_t
__fputwc (struct _reent *ptr,
	wchar_t wc,
	FILE *fp)
{
 40134e4:	defff804 	addi	sp,sp,-32
 40134e8:	dfc00715 	stw	ra,28(sp)
 40134ec:	df000615 	stw	fp,24(sp)
 40134f0:	df000604 	addi	fp,sp,24
 40134f4:	e13ffc15 	stw	r4,-16(fp)
 40134f8:	e17ffb15 	stw	r5,-20(fp)
 40134fc:	e1bffa15 	stw	r6,-24(fp)
  char buf[MB_LEN_MAX];
  size_t i, len;

  if (MB_CUR_MAX == 1 && wc > 0 && wc <= UCHAR_MAX)
 4013500:	40139400 	call	4013940 <__locale_mb_cur_max>
 4013504:	10800058 	cmpnei	r2,r2,1
 4013508:	10000a1e 	bne	r2,zero,4013534 <__fputwc+0x50>
 401350c:	e0bffb17 	ldw	r2,-20(fp)
 4013510:	0080080e 	bge	zero,r2,4013534 <__fputwc+0x50>
 4013514:	e0bffb17 	ldw	r2,-20(fp)
 4013518:	10804008 	cmpgei	r2,r2,256
 401351c:	1000051e 	bne	r2,zero,4013534 <__fputwc+0x50>
      /*
       * Assume single-byte locale with no special encoding.
       * A more careful test would be to check
       * _CurrentRuneLocale->encoding.
       */
      *buf = (unsigned char)wc;
 4013520:	e0bffb17 	ldw	r2,-20(fp)
 4013524:	e0bffdc5 	stb	r2,-9(fp)
      len = 1;
 4013528:	00800044 	movi	r2,1
 401352c:	e0bffe15 	stw	r2,-8(fp)
 4013530:	00001406 	br	4013584 <__fputwc+0xa0>
    }
  else
    {
      if ((len = _wcrtomb_r (ptr, buf, wc, &fp->_mbstate)) == (size_t) -1)
 4013534:	e0bffa17 	ldw	r2,-24(fp)
 4013538:	10c01704 	addi	r3,r2,92
 401353c:	e0bffdc4 	addi	r2,fp,-9
 4013540:	180f883a 	mov	r7,r3
 4013544:	e1bffb17 	ldw	r6,-20(fp)
 4013548:	100b883a 	mov	r5,r2
 401354c:	e13ffc17 	ldw	r4,-16(fp)
 4013550:	4013f580 	call	4013f58 <_wcrtomb_r>
 4013554:	e0bffe15 	stw	r2,-8(fp)
 4013558:	e0bffe17 	ldw	r2,-8(fp)
 401355c:	10bfffd8 	cmpnei	r2,r2,-1
 4013560:	1000081e 	bne	r2,zero,4013584 <__fputwc+0xa0>
	{
	  fp->_flags |= __SERR;
 4013564:	e0bffa17 	ldw	r2,-24(fp)
 4013568:	1080030b 	ldhu	r2,12(r2)
 401356c:	10801014 	ori	r2,r2,64
 4013570:	1007883a 	mov	r3,r2
 4013574:	e0bffa17 	ldw	r2,-24(fp)
 4013578:	10c0030d 	sth	r3,12(r2)
	  return WEOF;
 401357c:	00bfffc4 	movi	r2,-1
 4013580:	00004906 	br	40136a8 <__fputwc+0x1c4>
	}
    }

  for (i = 0; i < len; i++)
 4013584:	e03fff15 	stw	zero,-4(fp)
 4013588:	00004306 	br	4013698 <__fputwc+0x1b4>
    if (__sputc_r (ptr, (unsigned char) buf[i], fp) == EOF)
 401358c:	e0bffa17 	ldw	r2,-24(fp)
 4013590:	10800217 	ldw	r2,8(r2)
 4013594:	10ffffc4 	addi	r3,r2,-1
 4013598:	e0bffa17 	ldw	r2,-24(fp)
 401359c:	10c00215 	stw	r3,8(r2)
 40135a0:	e0bffa17 	ldw	r2,-24(fp)
 40135a4:	10800217 	ldw	r2,8(r2)
 40135a8:	1000280e 	bge	r2,zero,401364c <__fputwc+0x168>
 40135ac:	e0bffa17 	ldw	r2,-24(fp)
 40135b0:	10c00217 	ldw	r3,8(r2)
 40135b4:	e0bffa17 	ldw	r2,-24(fp)
 40135b8:	10800617 	ldw	r2,24(r2)
 40135bc:	18801916 	blt	r3,r2,4013624 <__fputwc+0x140>
 40135c0:	e0bfff17 	ldw	r2,-4(fp)
 40135c4:	e085883a 	add	r2,fp,r2
 40135c8:	10fffdc3 	ldbu	r3,-9(r2)
 40135cc:	e0bffa17 	ldw	r2,-24(fp)
 40135d0:	10800017 	ldw	r2,0(r2)
 40135d4:	10c00005 	stb	r3,0(r2)
 40135d8:	e0bffa17 	ldw	r2,-24(fp)
 40135dc:	10800017 	ldw	r2,0(r2)
 40135e0:	10800003 	ldbu	r2,0(r2)
 40135e4:	10803fcc 	andi	r2,r2,255
 40135e8:	108002a0 	cmpeqi	r2,r2,10
 40135ec:	1000071e 	bne	r2,zero,401360c <__fputwc+0x128>
 40135f0:	e0bffa17 	ldw	r2,-24(fp)
 40135f4:	10800017 	ldw	r2,0(r2)
 40135f8:	10c00044 	addi	r3,r2,1
 40135fc:	e0bffa17 	ldw	r2,-24(fp)
 4013600:	10c00015 	stw	r3,0(r2)
 4013604:	0005883a 	mov	r2,zero
 4013608:	00001c06 	br	401367c <__fputwc+0x198>
 401360c:	e1bffa17 	ldw	r6,-24(fp)
 4013610:	01400284 	movi	r5,10
 4013614:	e13ffc17 	ldw	r4,-16(fp)
 4013618:	4013d640 	call	4013d64 <__swbuf_r>
 401361c:	10bfffe0 	cmpeqi	r2,r2,-1
 4013620:	00001606 	br	401367c <__fputwc+0x198>
 4013624:	e0bfff17 	ldw	r2,-4(fp)
 4013628:	e085883a 	add	r2,fp,r2
 401362c:	10bffdc3 	ldbu	r2,-9(r2)
 4013630:	10803fcc 	andi	r2,r2,255
 4013634:	e1bffa17 	ldw	r6,-24(fp)
 4013638:	100b883a 	mov	r5,r2
 401363c:	e13ffc17 	ldw	r4,-16(fp)
 4013640:	4013d640 	call	4013d64 <__swbuf_r>
 4013644:	10bfffe0 	cmpeqi	r2,r2,-1
 4013648:	00000c06 	br	401367c <__fputwc+0x198>
 401364c:	e0bfff17 	ldw	r2,-4(fp)
 4013650:	e085883a 	add	r2,fp,r2
 4013654:	10fffdc3 	ldbu	r3,-9(r2)
 4013658:	e0bffa17 	ldw	r2,-24(fp)
 401365c:	10800017 	ldw	r2,0(r2)
 4013660:	10c00005 	stb	r3,0(r2)
 4013664:	e0bffa17 	ldw	r2,-24(fp)
 4013668:	10800017 	ldw	r2,0(r2)
 401366c:	10c00044 	addi	r3,r2,1
 4013670:	e0bffa17 	ldw	r2,-24(fp)
 4013674:	10c00015 	stw	r3,0(r2)
 4013678:	0005883a 	mov	r2,zero
 401367c:	10803fcc 	andi	r2,r2,255
 4013680:	10000226 	beq	r2,zero,401368c <__fputwc+0x1a8>
      return WEOF;
 4013684:	00bfffc4 	movi	r2,-1
 4013688:	00000706 	br	40136a8 <__fputwc+0x1c4>
  for (i = 0; i < len; i++)
 401368c:	e0bfff17 	ldw	r2,-4(fp)
 4013690:	10800044 	addi	r2,r2,1
 4013694:	e0bfff15 	stw	r2,-4(fp)
 4013698:	e0ffff17 	ldw	r3,-4(fp)
 401369c:	e0bffe17 	ldw	r2,-8(fp)
 40136a0:	18bfba36 	bltu	r3,r2,401358c <__fputwc+0xa8>

  return (wint_t) wc;
 40136a4:	e0bffb17 	ldw	r2,-20(fp)
}
 40136a8:	e037883a 	mov	sp,fp
 40136ac:	dfc00117 	ldw	ra,4(sp)
 40136b0:	df000017 	ldw	fp,0(sp)
 40136b4:	dec00204 	addi	sp,sp,8
 40136b8:	f800283a 	ret

040136bc <_fputwc_r>:

wint_t
_fputwc_r (struct _reent *ptr,
	wchar_t wc,
	FILE *fp)
{
 40136bc:	defffa04 	addi	sp,sp,-24
 40136c0:	dfc00515 	stw	ra,20(sp)
 40136c4:	df000415 	stw	fp,16(sp)
 40136c8:	df000404 	addi	fp,sp,16
 40136cc:	e13ffe15 	stw	r4,-8(fp)
 40136d0:	e17ffd15 	stw	r5,-12(fp)
 40136d4:	e1bffc15 	stw	r6,-16(fp)
  wint_t r;

  _newlib_flockfile_start (fp);
  ORIENT(fp, 1);
 40136d8:	e0bffc17 	ldw	r2,-16(fp)
 40136dc:	1080030b 	ldhu	r2,12(r2)
 40136e0:	10bfffcc 	andi	r2,r2,65535
 40136e4:	1088000c 	andi	r2,r2,8192
 40136e8:	10000b1e 	bne	r2,zero,4013718 <_fputwc_r+0x5c>
 40136ec:	e0bffc17 	ldw	r2,-16(fp)
 40136f0:	1080030b 	ldhu	r2,12(r2)
 40136f4:	10880014 	ori	r2,r2,8192
 40136f8:	1007883a 	mov	r3,r2
 40136fc:	e0bffc17 	ldw	r2,-16(fp)
 4013700:	10c0030d 	sth	r3,12(r2)
 4013704:	e0bffc17 	ldw	r2,-16(fp)
 4013708:	10801917 	ldw	r2,100(r2)
 401370c:	10c80014 	ori	r3,r2,8192
 4013710:	e0bffc17 	ldw	r2,-16(fp)
 4013714:	10c01915 	stw	r3,100(r2)
  r = __fputwc(ptr, wc, fp);
 4013718:	e1bffc17 	ldw	r6,-16(fp)
 401371c:	e17ffd17 	ldw	r5,-12(fp)
 4013720:	e13ffe17 	ldw	r4,-8(fp)
 4013724:	40134e40 	call	40134e4 <__fputwc>
 4013728:	e0bfff15 	stw	r2,-4(fp)
  _newlib_flockfile_end (fp);
  return r;
 401372c:	e0bfff17 	ldw	r2,-4(fp)
}
 4013730:	e037883a 	mov	sp,fp
 4013734:	dfc00117 	ldw	ra,4(sp)
 4013738:	df000017 	ldw	fp,0(sp)
 401373c:	dec00204 	addi	sp,sp,8
 4013740:	f800283a 	ret

04013744 <fputwc>:

wint_t
fputwc (wchar_t wc,
	FILE *fp)
{
 4013744:	defffa04 	addi	sp,sp,-24
 4013748:	dfc00515 	stw	ra,20(sp)
 401374c:	df000415 	stw	fp,16(sp)
 4013750:	df000404 	addi	fp,sp,16
 4013754:	e13ffd15 	stw	r4,-12(fp)
 4013758:	e17ffc15 	stw	r5,-16(fp)
  struct _reent *reent = _REENT;
 401375c:	d0a00117 	ldw	r2,-32764(gp)
 4013760:	e0bfff15 	stw	r2,-4(fp)

  CHECK_INIT(reent, fp);
 4013764:	e0bfff17 	ldw	r2,-4(fp)
 4013768:	e0bffe15 	stw	r2,-8(fp)
 401376c:	e0bffe17 	ldw	r2,-8(fp)
 4013770:	10000526 	beq	r2,zero,4013788 <fputwc+0x44>
 4013774:	e0bffe17 	ldw	r2,-8(fp)
 4013778:	10800e17 	ldw	r2,56(r2)
 401377c:	1000021e 	bne	r2,zero,4013788 <fputwc+0x44>
 4013780:	e13ffe17 	ldw	r4,-8(fp)
 4013784:	400c9100 	call	400c910 <__sinit>
  return _fputwc_r (reent, wc, fp);
 4013788:	e1bffc17 	ldw	r6,-16(fp)
 401378c:	e17ffd17 	ldw	r5,-12(fp)
 4013790:	e13fff17 	ldw	r4,-4(fp)
 4013794:	40136bc0 	call	40136bc <_fputwc_r>
}
 4013798:	e037883a 	mov	sp,fp
 401379c:	dfc00117 	ldw	ra,4(sp)
 40137a0:	df000017 	ldw	fp,0(sp)
 40137a4:	dec00204 	addi	sp,sp,8
 40137a8:	f800283a 	ret

040137ac <_fstat_r>:
int
_fstat_r (ptr, fd, pstat)
     struct _reent *ptr;
     int fd;
     struct stat *pstat;
{
 40137ac:	defffa04 	addi	sp,sp,-24
 40137b0:	dfc00515 	stw	ra,20(sp)
 40137b4:	df000415 	stw	fp,16(sp)
 40137b8:	df000404 	addi	fp,sp,16
 40137bc:	e13ffe15 	stw	r4,-8(fp)
 40137c0:	e17ffd15 	stw	r5,-12(fp)
 40137c4:	e1bffc15 	stw	r6,-16(fp)
  int ret;

  errno = 0;
 40137c8:	d0272715 	stw	zero,-25444(gp)
  if ((ret = _fstat (fd, pstat)) == -1 && errno != 0)
 40137cc:	e17ffc17 	ldw	r5,-16(fp)
 40137d0:	e13ffd17 	ldw	r4,-12(fp)
 40137d4:	4017e540 	call	4017e54 <fstat>
 40137d8:	e0bfff15 	stw	r2,-4(fp)
 40137dc:	e0bfff17 	ldw	r2,-4(fp)
 40137e0:	10bfffd8 	cmpnei	r2,r2,-1
 40137e4:	1000051e 	bne	r2,zero,40137fc <_fstat_r+0x50>
 40137e8:	d0a72717 	ldw	r2,-25444(gp)
 40137ec:	10000326 	beq	r2,zero,40137fc <_fstat_r+0x50>
    ptr->_errno = errno;
 40137f0:	d0e72717 	ldw	r3,-25444(gp)
 40137f4:	e0bffe17 	ldw	r2,-8(fp)
 40137f8:	10c00015 	stw	r3,0(r2)
  return ret;
 40137fc:	e0bfff17 	ldw	r2,-4(fp)
}
 4013800:	e037883a 	mov	sp,fp
 4013804:	dfc00117 	ldw	ra,4(sp)
 4013808:	df000017 	ldw	fp,0(sp)
 401380c:	dec00204 	addi	sp,sp,8
 4013810:	f800283a 	ret

04013814 <_isatty_r>:

int
_isatty_r (ptr, fd)
     struct _reent *ptr;
     int fd;
{
 4013814:	defffb04 	addi	sp,sp,-20
 4013818:	dfc00415 	stw	ra,16(sp)
 401381c:	df000315 	stw	fp,12(sp)
 4013820:	df000304 	addi	fp,sp,12
 4013824:	e13ffe15 	stw	r4,-8(fp)
 4013828:	e17ffd15 	stw	r5,-12(fp)
  int ret;

  errno = 0;
 401382c:	d0272715 	stw	zero,-25444(gp)
  if ((ret = _isatty (fd)) == -1 && errno != 0)
 4013830:	e13ffd17 	ldw	r4,-12(fp)
 4013834:	40182040 	call	4018204 <isatty>
 4013838:	e0bfff15 	stw	r2,-4(fp)
 401383c:	e0bfff17 	ldw	r2,-4(fp)
 4013840:	10bfffd8 	cmpnei	r2,r2,-1
 4013844:	1000051e 	bne	r2,zero,401385c <_isatty_r+0x48>
 4013848:	d0a72717 	ldw	r2,-25444(gp)
 401384c:	10000326 	beq	r2,zero,401385c <_isatty_r+0x48>
    ptr->_errno = errno;
 4013850:	d0e72717 	ldw	r3,-25444(gp)
 4013854:	e0bffe17 	ldw	r2,-8(fp)
 4013858:	10c00015 	stw	r3,0(r2)
  return ret;
 401385c:	e0bfff17 	ldw	r2,-4(fp)
}
 4013860:	e037883a 	mov	sp,fp
 4013864:	dfc00117 	ldw	ra,4(sp)
 4013868:	df000017 	ldw	fp,0(sp)
 401386c:	dec00204 	addi	sp,sp,8
 4013870:	f800283a 	ret

04013874 <__get_global_locale>:
{
 4013874:	deffff04 	addi	sp,sp,-4
 4013878:	df000015 	stw	fp,0(sp)
 401387c:	d839883a 	mov	fp,sp
  return &__global_locale;
 4013880:	008100b4 	movhi	r2,1026
 4013884:	10ae9604 	addi	r2,r2,-17832
}
 4013888:	e037883a 	mov	sp,fp
 401388c:	df000017 	ldw	fp,0(sp)
 4013890:	dec00104 	addi	sp,sp,4
 4013894:	f800283a 	ret

04013898 <__get_current_locale>:
{
 4013898:	defffe04 	addi	sp,sp,-8
 401389c:	dfc00115 	stw	ra,4(sp)
 40138a0:	df000015 	stw	fp,0(sp)
 40138a4:	d839883a 	mov	fp,sp
  return __get_global_locale();
 40138a8:	40138740 	call	4013874 <__get_global_locale>
}
 40138ac:	e037883a 	mov	sp,fp
 40138b0:	dfc00117 	ldw	ra,4(sp)
 40138b4:	df000017 	ldw	fp,0(sp)
 40138b8:	dec00204 	addi	sp,sp,8
 40138bc:	f800283a 	ret

040138c0 <_setlocale_r>:

char *
_setlocale_r (struct _reent *p,
       int category,
       const char *locale)
{
 40138c0:	defffb04 	addi	sp,sp,-20
 40138c4:	dfc00415 	stw	ra,16(sp)
 40138c8:	df000315 	stw	fp,12(sp)
 40138cc:	df000304 	addi	fp,sp,12
 40138d0:	e13fff15 	stw	r4,-4(fp)
 40138d4:	e17ffe15 	stw	r5,-8(fp)
 40138d8:	e1bffd15 	stw	r6,-12(fp)
#ifndef _MB_CAPABLE
  if (locale)
 40138dc:	e0bffd17 	ldw	r2,-12(fp)
 40138e0:	10001026 	beq	r2,zero,4013924 <_setlocale_r+0x64>
    { 
      if (strcmp (locale, "POSIX") && strcmp (locale, "C")
 40138e4:	014100b4 	movhi	r5,1026
 40138e8:	296b9404 	addi	r5,r5,-20912
 40138ec:	e13ffd17 	ldw	r4,-12(fp)
 40138f0:	4013bd00 	call	4013bd0 <strcmp>
 40138f4:	10000b26 	beq	r2,zero,4013924 <_setlocale_r+0x64>
 40138f8:	014100b4 	movhi	r5,1026
 40138fc:	296b9604 	addi	r5,r5,-20904
 4013900:	e13ffd17 	ldw	r4,-12(fp)
 4013904:	4013bd00 	call	4013bd0 <strcmp>
 4013908:	10000626 	beq	r2,zero,4013924 <_setlocale_r+0x64>
	  && strcmp (locale, ""))
 401390c:	e0bffd17 	ldw	r2,-12(fp)
 4013910:	10800003 	ldbu	r2,0(r2)
 4013914:	10803fcc 	andi	r2,r2,255
 4013918:	10000226 	beq	r2,zero,4013924 <_setlocale_r+0x64>
        return NULL;
 401391c:	0005883a 	mov	r2,zero
 4013920:	00000206 	br	401392c <_setlocale_r+0x6c>
    }
  return "C";
 4013924:	008100b4 	movhi	r2,1026
 4013928:	10ab9604 	addi	r2,r2,-20904
	  return NULL;
	}
    }
  return currentlocale ();
#endif /* _MB_CAPABLE */
}
 401392c:	e037883a 	mov	sp,fp
 4013930:	dfc00117 	ldw	ra,4(sp)
 4013934:	df000017 	ldw	fp,0(sp)
 4013938:	dec00204 	addi	sp,sp,8
 401393c:	f800283a 	ret

04013940 <__locale_mb_cur_max>:
}
#endif /* _MB_CAPABLE */

int
__locale_mb_cur_max (void)
{
 4013940:	defffe04 	addi	sp,sp,-8
 4013944:	dfc00115 	stw	ra,4(sp)
 4013948:	df000015 	stw	fp,0(sp)
 401394c:	d839883a 	mov	fp,sp
#ifdef __HAVE_LOCALE_INFO__
  return __get_current_ctype_locale ()->mb_cur_max[0];
#else
  return __get_current_locale ()->mb_cur_max[0];
 4013950:	40138980 	call	4013898 <__get_current_locale>
 4013954:	10804a03 	ldbu	r2,296(r2)
 4013958:	10803fcc 	andi	r2,r2,255
 401395c:	1080201c 	xori	r2,r2,128
 4013960:	10bfe004 	addi	r2,r2,-128
#endif
}
 4013964:	e037883a 	mov	sp,fp
 4013968:	dfc00117 	ldw	ra,4(sp)
 401396c:	df000017 	ldw	fp,0(sp)
 4013970:	dec00204 	addi	sp,sp,8
 4013974:	f800283a 	ret

04013978 <setlocale>:
#ifndef _REENT_ONLY

char *
setlocale (int category,
	const char *locale)
{
 4013978:	defffc04 	addi	sp,sp,-16
 401397c:	dfc00315 	stw	ra,12(sp)
 4013980:	df000215 	stw	fp,8(sp)
 4013984:	df000204 	addi	fp,sp,8
 4013988:	e13fff15 	stw	r4,-4(fp)
 401398c:	e17ffe15 	stw	r5,-8(fp)
  return _setlocale_r (_REENT, category, locale);
 4013990:	d0a00117 	ldw	r2,-32764(gp)
 4013994:	e1bffe17 	ldw	r6,-8(fp)
 4013998:	e17fff17 	ldw	r5,-4(fp)
 401399c:	1009883a 	mov	r4,r2
 40139a0:	40138c00 	call	40138c0 <_setlocale_r>
}
 40139a4:	e037883a 	mov	sp,fp
 40139a8:	dfc00117 	ldw	ra,4(sp)
 40139ac:	df000017 	ldw	fp,0(sp)
 40139b0:	dec00204 	addi	sp,sp,8
 40139b4:	f800283a 	ret

040139b8 <_lseek_r>:
_off_t
_lseek_r (struct _reent *ptr,
     int fd,
     _off_t pos,
     int whence)
{
 40139b8:	defff904 	addi	sp,sp,-28
 40139bc:	dfc00615 	stw	ra,24(sp)
 40139c0:	df000515 	stw	fp,20(sp)
 40139c4:	df000504 	addi	fp,sp,20
 40139c8:	e13ffe15 	stw	r4,-8(fp)
 40139cc:	e17ffd15 	stw	r5,-12(fp)
 40139d0:	e1bffc15 	stw	r6,-16(fp)
 40139d4:	e1fffb15 	stw	r7,-20(fp)
  _off_t ret;

  errno = 0;
 40139d8:	d0272715 	stw	zero,-25444(gp)
  if ((ret = _lseek (fd, pos, whence)) == (_off_t) -1 && errno != 0)
 40139dc:	e1bffb17 	ldw	r6,-20(fp)
 40139e0:	e17ffc17 	ldw	r5,-16(fp)
 40139e4:	e13ffd17 	ldw	r4,-12(fp)
 40139e8:	40185440 	call	4018544 <lseek>
 40139ec:	e0bfff15 	stw	r2,-4(fp)
 40139f0:	e0bfff17 	ldw	r2,-4(fp)
 40139f4:	10bfffd8 	cmpnei	r2,r2,-1
 40139f8:	1000051e 	bne	r2,zero,4013a10 <_lseek_r+0x58>
 40139fc:	d0a72717 	ldw	r2,-25444(gp)
 4013a00:	10000326 	beq	r2,zero,4013a10 <_lseek_r+0x58>
    ptr->_errno = errno;
 4013a04:	d0e72717 	ldw	r3,-25444(gp)
 4013a08:	e0bffe17 	ldw	r2,-8(fp)
 4013a0c:	10c00015 	stw	r3,0(r2)
  return ret;
 4013a10:	e0bfff17 	ldw	r2,-4(fp)
}
 4013a14:	e037883a 	mov	sp,fp
 4013a18:	dfc00117 	ldw	ra,4(sp)
 4013a1c:	df000017 	ldw	fp,0(sp)
 4013a20:	dec00204 	addi	sp,sp,8
 4013a24:	f800283a 	ret

04013a28 <__get_global_locale>:

/* In POSIX terms the global locale is the process-wide locale.  Use this
   function to always refer to the global locale. */
_ELIDABLE_INLINE struct __locale_t *
__get_global_locale ()
{
 4013a28:	deffff04 	addi	sp,sp,-4
 4013a2c:	df000015 	stw	fp,0(sp)
 4013a30:	d839883a 	mov	fp,sp
  extern struct __locale_t __global_locale;
  return &__global_locale;
 4013a34:	008100b4 	movhi	r2,1026
 4013a38:	10ae9604 	addi	r2,r2,-17832
}
 4013a3c:	e037883a 	mov	sp,fp
 4013a40:	df000017 	ldw	fp,0(sp)
 4013a44:	dec00104 	addi	sp,sp,4
 4013a48:	f800283a 	ret

04013a4c <__get_current_locale>:
   using locale info without providing a locale as parameter (*_l functions).
   The current locale is either the locale of the current thread, if the
   thread called uselocale, or the global locale if not. */
_ELIDABLE_INLINE struct __locale_t *
__get_current_locale (void)
{
 4013a4c:	defffe04 	addi	sp,sp,-8
 4013a50:	dfc00115 	stw	ra,4(sp)
 4013a54:	df000015 	stw	fp,0(sp)
 4013a58:	d839883a 	mov	fp,sp
#ifdef __HAVE_LOCALE_INFO__
  return _REENT->_locale ?: __get_global_locale ();
#else
  return __get_global_locale();
 4013a5c:	4013a280 	call	4013a28 <__get_global_locale>
#endif
}
 4013a60:	e037883a 	mov	sp,fp
 4013a64:	dfc00117 	ldw	ra,4(sp)
 4013a68:	df000017 	ldw	fp,0(sp)
 4013a6c:	dec00204 	addi	sp,sp,8
 4013a70:	f800283a 	ret

04013a74 <_mbtowc_r>:
_mbtowc_r (struct _reent *r,
        wchar_t       *__restrict pwc,
        const char    *__restrict s,
        size_t         n,
        mbstate_t      *state)
{
 4013a74:	defff904 	addi	sp,sp,-28
 4013a78:	dfc00615 	stw	ra,24(sp)
 4013a7c:	df000515 	stw	fp,20(sp)
 4013a80:	df000504 	addi	fp,sp,20
 4013a84:	e13fff15 	stw	r4,-4(fp)
 4013a88:	e17ffe15 	stw	r5,-8(fp)
 4013a8c:	e1bffd15 	stw	r6,-12(fp)
 4013a90:	e1fffc15 	stw	r7,-16(fp)
  return __MBTOWC (r, pwc, s, n, state);
 4013a94:	4013a4c0 	call	4013a4c <__get_current_locale>
 4013a98:	10803917 	ldw	r2,228(r2)
 4013a9c:	e0c00217 	ldw	r3,8(fp)
 4013aa0:	d8c00015 	stw	r3,0(sp)
 4013aa4:	e1fffc17 	ldw	r7,-16(fp)
 4013aa8:	e1bffd17 	ldw	r6,-12(fp)
 4013aac:	e17ffe17 	ldw	r5,-8(fp)
 4013ab0:	e13fff17 	ldw	r4,-4(fp)
 4013ab4:	103ee83a 	callr	r2
}
 4013ab8:	e037883a 	mov	sp,fp
 4013abc:	dfc00117 	ldw	ra,4(sp)
 4013ac0:	df000017 	ldw	fp,0(sp)
 4013ac4:	dec00204 	addi	sp,sp,8
 4013ac8:	f800283a 	ret

04013acc <__ascii_mbtowc>:
__ascii_mbtowc (struct _reent *r,
        wchar_t       *pwc,
        const char    *s,
        size_t         n,
        mbstate_t      *state)
{
 4013acc:	defff904 	addi	sp,sp,-28
 4013ad0:	df000615 	stw	fp,24(sp)
 4013ad4:	df000604 	addi	fp,sp,24
 4013ad8:	e13ffd15 	stw	r4,-12(fp)
 4013adc:	e17ffc15 	stw	r5,-16(fp)
 4013ae0:	e1bffb15 	stw	r6,-20(fp)
 4013ae4:	e1fffa15 	stw	r7,-24(fp)
  wchar_t dummy;
  unsigned char *t = (unsigned char *)s;
 4013ae8:	e0bffb17 	ldw	r2,-20(fp)
 4013aec:	e0bfff15 	stw	r2,-4(fp)

  if (pwc == NULL)
 4013af0:	e0bffc17 	ldw	r2,-16(fp)
 4013af4:	1000021e 	bne	r2,zero,4013b00 <__ascii_mbtowc+0x34>
    pwc = &dummy;
 4013af8:	e0bffe04 	addi	r2,fp,-8
 4013afc:	e0bffc15 	stw	r2,-16(fp)

  if (s == NULL)
 4013b00:	e0bffb17 	ldw	r2,-20(fp)
 4013b04:	1000021e 	bne	r2,zero,4013b10 <__ascii_mbtowc+0x44>
    return 0;
 4013b08:	0005883a 	mov	r2,zero
 4013b0c:	00001006 	br	4013b50 <__ascii_mbtowc+0x84>

  if (n == 0)
 4013b10:	e0bffa17 	ldw	r2,-24(fp)
 4013b14:	1000021e 	bne	r2,zero,4013b20 <__ascii_mbtowc+0x54>
    return -2;
 4013b18:	00bfff84 	movi	r2,-2
 4013b1c:	00000c06 	br	4013b50 <__ascii_mbtowc+0x84>
      r->_errno = EILSEQ;
      return -1;
    }
#endif

  *pwc = (wchar_t)*t;
 4013b20:	e0bfff17 	ldw	r2,-4(fp)
 4013b24:	10800003 	ldbu	r2,0(r2)
 4013b28:	10c03fcc 	andi	r3,r2,255
 4013b2c:	e0bffc17 	ldw	r2,-16(fp)
 4013b30:	10c00015 	stw	r3,0(r2)
  
  if (*t == '\0')
 4013b34:	e0bfff17 	ldw	r2,-4(fp)
 4013b38:	10800003 	ldbu	r2,0(r2)
 4013b3c:	10803fcc 	andi	r2,r2,255
 4013b40:	1000021e 	bne	r2,zero,4013b4c <__ascii_mbtowc+0x80>
    return 0;
 4013b44:	0005883a 	mov	r2,zero
 4013b48:	00000106 	br	4013b50 <__ascii_mbtowc+0x84>

  return 1;
 4013b4c:	00800044 	movi	r2,1
}
 4013b50:	e037883a 	mov	sp,fp
 4013b54:	df000017 	ldw	fp,0(sp)
 4013b58:	dec00104 	addi	sp,sp,4
 4013b5c:	f800283a 	ret

04013b60 <_read_r>:
_ssize_t
_read_r (struct _reent *ptr,
     int fd,
     void *buf,
     size_t cnt)
{
 4013b60:	defff904 	addi	sp,sp,-28
 4013b64:	dfc00615 	stw	ra,24(sp)
 4013b68:	df000515 	stw	fp,20(sp)
 4013b6c:	df000504 	addi	fp,sp,20
 4013b70:	e13ffe15 	stw	r4,-8(fp)
 4013b74:	e17ffd15 	stw	r5,-12(fp)
 4013b78:	e1bffc15 	stw	r6,-16(fp)
 4013b7c:	e1fffb15 	stw	r7,-20(fp)
  _ssize_t ret;

  errno = 0;
 4013b80:	d0272715 	stw	zero,-25444(gp)
  if ((ret = (_ssize_t)_read (fd, buf, cnt)) == -1 && errno != 0)
 4013b84:	e1bffb17 	ldw	r6,-20(fp)
 4013b88:	e17ffc17 	ldw	r5,-16(fp)
 4013b8c:	e13ffd17 	ldw	r4,-12(fp)
 4013b90:	40187240 	call	4018724 <read>
 4013b94:	e0bfff15 	stw	r2,-4(fp)
 4013b98:	e0bfff17 	ldw	r2,-4(fp)
 4013b9c:	10bfffd8 	cmpnei	r2,r2,-1
 4013ba0:	1000051e 	bne	r2,zero,4013bb8 <_read_r+0x58>
 4013ba4:	d0a72717 	ldw	r2,-25444(gp)
 4013ba8:	10000326 	beq	r2,zero,4013bb8 <_read_r+0x58>
    ptr->_errno = errno;
 4013bac:	d0e72717 	ldw	r3,-25444(gp)
 4013bb0:	e0bffe17 	ldw	r2,-8(fp)
 4013bb4:	10c00015 	stw	r3,0(r2)
  return ret;
 4013bb8:	e0bfff17 	ldw	r2,-4(fp)
}
 4013bbc:	e037883a 	mov	sp,fp
 4013bc0:	dfc00117 	ldw	ra,4(sp)
 4013bc4:	df000017 	ldw	fp,0(sp)
 4013bc8:	dec00204 	addi	sp,sp,8
 4013bcc:	f800283a 	ret

04013bd0 <strcmp>:
#endif

int
strcmp (const char *s1,
	const char *s2)
{ 
 4013bd0:	defffb04 	addi	sp,sp,-20
 4013bd4:	df000415 	stw	fp,16(sp)
 4013bd8:	df000404 	addi	fp,sp,16
 4013bdc:	e13ffd15 	stw	r4,-12(fp)
 4013be0:	e17ffc15 	stw	r5,-16(fp)
#else
  unsigned long *a1;
  unsigned long *a2;

  /* If s1 or s2 are unaligned, then compare bytes. */
  if (!UNALIGNED (s1, s2))
 4013be4:	e0fffd17 	ldw	r3,-12(fp)
 4013be8:	e0bffc17 	ldw	r2,-16(fp)
 4013bec:	1884b03a 	or	r2,r3,r2
 4013bf0:	108000cc 	andi	r2,r2,3
 4013bf4:	10002a1e 	bne	r2,zero,4013ca0 <strcmp+0xd0>
    {  
      /* If s1 and s2 are word-aligned, compare them a word at a time. */
      a1 = (unsigned long*)s1;
 4013bf8:	e0bffd17 	ldw	r2,-12(fp)
 4013bfc:	e0bfff15 	stw	r2,-4(fp)
      a2 = (unsigned long*)s2;
 4013c00:	e0bffc17 	ldw	r2,-16(fp)
 4013c04:	e0bffe15 	stw	r2,-8(fp)
      while (*a1 == *a2)
 4013c08:	00001506 	br	4013c60 <strcmp+0x90>
        {
          /* To get here, *a1 == *a2, thus if we find a null in *a1,
	     then the strings must be equal, so return zero.  */
          if (DETECTNULL (*a1))
 4013c0c:	e0bfff17 	ldw	r2,-4(fp)
 4013c10:	10c00017 	ldw	r3,0(r2)
 4013c14:	00bfbff4 	movhi	r2,65279
 4013c18:	10bfbfc4 	addi	r2,r2,-257
 4013c1c:	1887883a 	add	r3,r3,r2
 4013c20:	e0bfff17 	ldw	r2,-4(fp)
 4013c24:	10800017 	ldw	r2,0(r2)
 4013c28:	0084303a 	nor	r2,zero,r2
 4013c2c:	1886703a 	and	r3,r3,r2
 4013c30:	00a02074 	movhi	r2,32897
 4013c34:	10a02004 	addi	r2,r2,-32640
 4013c38:	1884703a 	and	r2,r3,r2
 4013c3c:	10000226 	beq	r2,zero,4013c48 <strcmp+0x78>
	    return 0;
 4013c40:	0005883a 	mov	r2,zero
 4013c44:	00002e06 	br	4013d00 <strcmp+0x130>

          a1++;
 4013c48:	e0bfff17 	ldw	r2,-4(fp)
 4013c4c:	10800104 	addi	r2,r2,4
 4013c50:	e0bfff15 	stw	r2,-4(fp)
          a2++;
 4013c54:	e0bffe17 	ldw	r2,-8(fp)
 4013c58:	10800104 	addi	r2,r2,4
 4013c5c:	e0bffe15 	stw	r2,-8(fp)
      while (*a1 == *a2)
 4013c60:	e0bfff17 	ldw	r2,-4(fp)
 4013c64:	10c00017 	ldw	r3,0(r2)
 4013c68:	e0bffe17 	ldw	r2,-8(fp)
 4013c6c:	10800017 	ldw	r2,0(r2)
 4013c70:	18bfe626 	beq	r3,r2,4013c0c <strcmp+0x3c>
        }

      /* A difference was detected in last few bytes of s1, so search bytewise */
      s1 = (char*)a1;
 4013c74:	e0bfff17 	ldw	r2,-4(fp)
 4013c78:	e0bffd15 	stw	r2,-12(fp)
      s2 = (char*)a2;
 4013c7c:	e0bffe17 	ldw	r2,-8(fp)
 4013c80:	e0bffc15 	stw	r2,-16(fp)
    }

  while (*s1 != '\0' && *s1 == *s2)
 4013c84:	00000606 	br	4013ca0 <strcmp+0xd0>
    {
      s1++;
 4013c88:	e0bffd17 	ldw	r2,-12(fp)
 4013c8c:	10800044 	addi	r2,r2,1
 4013c90:	e0bffd15 	stw	r2,-12(fp)
      s2++;
 4013c94:	e0bffc17 	ldw	r2,-16(fp)
 4013c98:	10800044 	addi	r2,r2,1
 4013c9c:	e0bffc15 	stw	r2,-16(fp)
  while (*s1 != '\0' && *s1 == *s2)
 4013ca0:	e0bffd17 	ldw	r2,-12(fp)
 4013ca4:	10800003 	ldbu	r2,0(r2)
 4013ca8:	10803fcc 	andi	r2,r2,255
 4013cac:	1080201c 	xori	r2,r2,128
 4013cb0:	10bfe004 	addi	r2,r2,-128
 4013cb4:	10000b26 	beq	r2,zero,4013ce4 <strcmp+0x114>
 4013cb8:	e0bffd17 	ldw	r2,-12(fp)
 4013cbc:	10c00003 	ldbu	r3,0(r2)
 4013cc0:	e0bffc17 	ldw	r2,-16(fp)
 4013cc4:	10800003 	ldbu	r2,0(r2)
 4013cc8:	18c03fcc 	andi	r3,r3,255
 4013ccc:	18c0201c 	xori	r3,r3,128
 4013cd0:	18ffe004 	addi	r3,r3,-128
 4013cd4:	10803fcc 	andi	r2,r2,255
 4013cd8:	1080201c 	xori	r2,r2,128
 4013cdc:	10bfe004 	addi	r2,r2,-128
 4013ce0:	18bfe926 	beq	r3,r2,4013c88 <strcmp+0xb8>
    }
  return (*(unsigned char *) s1) - (*(unsigned char *) s2);
 4013ce4:	e0bffd17 	ldw	r2,-12(fp)
 4013ce8:	10800003 	ldbu	r2,0(r2)
 4013cec:	10c03fcc 	andi	r3,r2,255
 4013cf0:	e0bffc17 	ldw	r2,-16(fp)
 4013cf4:	10800003 	ldbu	r2,0(r2)
 4013cf8:	10803fcc 	andi	r2,r2,255
 4013cfc:	1885c83a 	sub	r2,r3,r2
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 4013d00:	e037883a 	mov	sp,fp
 4013d04:	df000017 	ldw	fp,0(sp)
 4013d08:	dec00104 	addi	sp,sp,4
 4013d0c:	f800283a 	ret

04013d10 <_vfiprintf_r>:
_DEFUN (_vfiprintf_r, (data, fp, fmt, ap),
	struct _reent *data _AND
	FILE * fp _AND
	_CONST char *fmt _AND
	va_list ap)
{
 4013d10:	defff904 	addi	sp,sp,-28
 4013d14:	dfc00615 	stw	ra,24(sp)
 4013d18:	df000515 	stw	fp,20(sp)
 4013d1c:	df000504 	addi	fp,sp,20
 4013d20:	e13ffe15 	stw	r4,-8(fp)
 4013d24:	e17ffd15 	stw	r5,-12(fp)
 4013d28:	e1bffc15 	stw	r6,-16(fp)
 4013d2c:	e1fffb15 	stw	r7,-20(fp)
  int ret;

  _REENT_SMALL_CHECK_INIT(fp);
  _FILE_INIT_DEV_WRITE (fp);
  ret = ___vfiprintf_internal_r (data, fp, fmt, ap);
 4013d30:	e0bffb17 	ldw	r2,-20(fp)
 4013d34:	100f883a 	mov	r7,r2
 4013d38:	e1bffc17 	ldw	r6,-16(fp)
 4013d3c:	e17ffd17 	ldw	r5,-12(fp)
 4013d40:	e13ffe17 	ldw	r4,-8(fp)
 4013d44:	4011d1c0 	call	4011d1c <___vfiprintf_internal_r>
 4013d48:	e0bfff15 	stw	r2,-4(fp)
  va_end (ap);
  return ret;
 4013d4c:	e0bfff17 	ldw	r2,-4(fp)
}
 4013d50:	e037883a 	mov	sp,fp
 4013d54:	dfc00117 	ldw	ra,4(sp)
 4013d58:	df000017 	ldw	fp,0(sp)
 4013d5c:	dec00204 	addi	sp,sp,8
 4013d60:	f800283a 	ret

04013d64 <__swbuf_r>:

int
__swbuf_r (struct _reent *ptr,
       register int c,
       register FILE *fp)
{
 4013d64:	defff904 	addi	sp,sp,-28
 4013d68:	dfc00615 	stw	ra,24(sp)
 4013d6c:	df000515 	stw	fp,20(sp)
 4013d70:	dc800415 	stw	r18,16(sp)
 4013d74:	dc400315 	stw	r17,12(sp)
 4013d78:	dc000215 	stw	r16,8(sp)
 4013d7c:	df000504 	addi	fp,sp,20
 4013d80:	e13ffb15 	stw	r4,-20(fp)
 4013d84:	2825883a 	mov	r18,r5
 4013d88:	3021883a 	mov	r16,r6
  register int n;

  /* Ensure stdio has been initialized.  */

  CHECK_INIT (ptr, fp);
 4013d8c:	e0bffb17 	ldw	r2,-20(fp)
 4013d90:	e0bffc15 	stw	r2,-16(fp)
 4013d94:	e0bffc17 	ldw	r2,-16(fp)
 4013d98:	10000526 	beq	r2,zero,4013db0 <__swbuf_r+0x4c>
 4013d9c:	e0bffc17 	ldw	r2,-16(fp)
 4013da0:	10800e17 	ldw	r2,56(r2)
 4013da4:	1000021e 	bne	r2,zero,4013db0 <__swbuf_r+0x4c>
 4013da8:	e13ffc17 	ldw	r4,-16(fp)
 4013dac:	400c9100 	call	400c910 <__sinit>
   * (if line buffered) so that we will get called again.
   * If we did not do this, a sufficient number of putc()
   * calls might wrap _w from negative to positive.
   */

  fp->_w = fp->_lbfsize;
 4013db0:	80800617 	ldw	r2,24(r16)
 4013db4:	80800215 	stw	r2,8(r16)
  if (cantwrite (ptr, fp))
 4013db8:	8080030b 	ldhu	r2,12(r16)
 4013dbc:	10bfffcc 	andi	r2,r2,65535
 4013dc0:	1080020c 	andi	r2,r2,8
 4013dc4:	10000226 	beq	r2,zero,4013dd0 <__swbuf_r+0x6c>
 4013dc8:	80800417 	ldw	r2,16(r16)
 4013dcc:	1000061e 	bne	r2,zero,4013de8 <__swbuf_r+0x84>
 4013dd0:	800b883a 	mov	r5,r16
 4013dd4:	e13ffb17 	ldw	r4,-20(fp)
 4013dd8:	4009f4c0 	call	4009f4c <__swsetup_r>
 4013ddc:	10000226 	beq	r2,zero,4013de8 <__swbuf_r+0x84>
    return EOF;
 4013de0:	00bfffc4 	movi	r2,-1
 4013de4:	00003106 	br	4013eac <__swbuf_r+0x148>
  c = (unsigned char) c;
 4013de8:	9005883a 	mov	r2,r18
 4013dec:	14803fcc 	andi	r18,r2,255

  ORIENT (fp, -1);
 4013df0:	8080030b 	ldhu	r2,12(r16)
 4013df4:	10bfffcc 	andi	r2,r2,65535
 4013df8:	1088000c 	andi	r2,r2,8192
 4013dfc:	1000071e 	bne	r2,zero,4013e1c <__swbuf_r+0xb8>
 4013e00:	8080030b 	ldhu	r2,12(r16)
 4013e04:	10880014 	ori	r2,r2,8192
 4013e08:	8080030d 	sth	r2,12(r16)
 4013e0c:	80c01917 	ldw	r3,100(r16)
 4013e10:	00b7ffc4 	movi	r2,-8193
 4013e14:	1884703a 	and	r2,r3,r2
 4013e18:	80801915 	stw	r2,100(r16)
   * happen on unbuffered streams, where _bf._size==1; fflush()
   * guarantees that putc() will always call wbuf() by setting _w
   * to 0, so we need not do anything else.
   */

  n = fp->_p - fp->_bf._base;
 4013e1c:	80c00017 	ldw	r3,0(r16)
 4013e20:	80800417 	ldw	r2,16(r16)
 4013e24:	18a3c83a 	sub	r17,r3,r2
  if (n >= fp->_bf._size)
 4013e28:	80800517 	ldw	r2,20(r16)
 4013e2c:	88800716 	blt	r17,r2,4013e4c <__swbuf_r+0xe8>
    {
      if (_fflush_r (ptr, fp))
 4013e30:	800b883a 	mov	r5,r16
 4013e34:	e13ffb17 	ldw	r4,-20(fp)
 4013e38:	400c3c80 	call	400c3c8 <_fflush_r>
 4013e3c:	10000226 	beq	r2,zero,4013e48 <__swbuf_r+0xe4>
	return EOF;
 4013e40:	00bfffc4 	movi	r2,-1
 4013e44:	00001906 	br	4013eac <__swbuf_r+0x148>
      n = 0;
 4013e48:	0023883a 	mov	r17,zero
    }
  fp->_w--;
 4013e4c:	80800217 	ldw	r2,8(r16)
 4013e50:	10bfffc4 	addi	r2,r2,-1
 4013e54:	80800215 	stw	r2,8(r16)
  *fp->_p++ = c;
 4013e58:	80800017 	ldw	r2,0(r16)
 4013e5c:	10c00044 	addi	r3,r2,1
 4013e60:	80c00015 	stw	r3,0(r16)
 4013e64:	9007883a 	mov	r3,r18
 4013e68:	10c00005 	stb	r3,0(r2)
  if (++n == fp->_bf._size || (fp->_flags & __SLBF && c == '\n'))
 4013e6c:	8c400044 	addi	r17,r17,1
 4013e70:	80800517 	ldw	r2,20(r16)
 4013e74:	88800626 	beq	r17,r2,4013e90 <__swbuf_r+0x12c>
 4013e78:	8080030b 	ldhu	r2,12(r16)
 4013e7c:	10bfffcc 	andi	r2,r2,65535
 4013e80:	1080004c 	andi	r2,r2,1
 4013e84:	10000826 	beq	r2,zero,4013ea8 <__swbuf_r+0x144>
 4013e88:	90800298 	cmpnei	r2,r18,10
 4013e8c:	1000061e 	bne	r2,zero,4013ea8 <__swbuf_r+0x144>
    if (_fflush_r (ptr, fp))
 4013e90:	800b883a 	mov	r5,r16
 4013e94:	e13ffb17 	ldw	r4,-20(fp)
 4013e98:	400c3c80 	call	400c3c8 <_fflush_r>
 4013e9c:	10000226 	beq	r2,zero,4013ea8 <__swbuf_r+0x144>
      return EOF;
 4013ea0:	00bfffc4 	movi	r2,-1
 4013ea4:	00000106 	br	4013eac <__swbuf_r+0x148>
  return c;
 4013ea8:	9005883a 	mov	r2,r18
}
 4013eac:	e6fffd04 	addi	sp,fp,-12
 4013eb0:	dfc00417 	ldw	ra,16(sp)
 4013eb4:	df000317 	ldw	fp,12(sp)
 4013eb8:	dc800217 	ldw	r18,8(sp)
 4013ebc:	dc400117 	ldw	r17,4(sp)
 4013ec0:	dc000017 	ldw	r16,0(sp)
 4013ec4:	dec00504 	addi	sp,sp,20
 4013ec8:	f800283a 	ret

04013ecc <__swbuf>:
   required for backward compatibility with applications built against
   earlier dynamically built newlib libraries. */
int
__swbuf (register int c,
       register FILE *fp)
{
 4013ecc:	defffe04 	addi	sp,sp,-8
 4013ed0:	dfc00115 	stw	ra,4(sp)
 4013ed4:	df000015 	stw	fp,0(sp)
 4013ed8:	d839883a 	mov	fp,sp
 4013edc:	2007883a 	mov	r3,r4
 4013ee0:	2809883a 	mov	r4,r5
  return __swbuf_r (_REENT, c, fp);
 4013ee4:	d0a00117 	ldw	r2,-32764(gp)
 4013ee8:	200d883a 	mov	r6,r4
 4013eec:	180b883a 	mov	r5,r3
 4013ef0:	1009883a 	mov	r4,r2
 4013ef4:	4013d640 	call	4013d64 <__swbuf_r>
}
 4013ef8:	e037883a 	mov	sp,fp
 4013efc:	dfc00117 	ldw	ra,4(sp)
 4013f00:	df000017 	ldw	fp,0(sp)
 4013f04:	dec00204 	addi	sp,sp,8
 4013f08:	f800283a 	ret

04013f0c <__get_global_locale>:
{
 4013f0c:	deffff04 	addi	sp,sp,-4
 4013f10:	df000015 	stw	fp,0(sp)
 4013f14:	d839883a 	mov	fp,sp
  return &__global_locale;
 4013f18:	008100b4 	movhi	r2,1026
 4013f1c:	10ae9604 	addi	r2,r2,-17832
}
 4013f20:	e037883a 	mov	sp,fp
 4013f24:	df000017 	ldw	fp,0(sp)
 4013f28:	dec00104 	addi	sp,sp,4
 4013f2c:	f800283a 	ret

04013f30 <__get_current_locale>:
{
 4013f30:	defffe04 	addi	sp,sp,-8
 4013f34:	dfc00115 	stw	ra,4(sp)
 4013f38:	df000015 	stw	fp,0(sp)
 4013f3c:	d839883a 	mov	fp,sp
  return __get_global_locale();
 4013f40:	4013f0c0 	call	4013f0c <__get_global_locale>
}
 4013f44:	e037883a 	mov	sp,fp
 4013f48:	dfc00117 	ldw	ra,4(sp)
 4013f4c:	df000017 	ldw	fp,0(sp)
 4013f50:	dec00204 	addi	sp,sp,8
 4013f54:	f800283a 	ret

04013f58 <_wcrtomb_r>:
size_t
_wcrtomb_r (struct _reent *ptr,
	char *s,
	wchar_t wc,
	mbstate_t *ps)
{
 4013f58:	defff604 	addi	sp,sp,-40
 4013f5c:	dfc00915 	stw	ra,36(sp)
 4013f60:	df000815 	stw	fp,32(sp)
 4013f64:	df000804 	addi	fp,sp,32
 4013f68:	e13ffb15 	stw	r4,-20(fp)
 4013f6c:	e17ffa15 	stw	r5,-24(fp)
 4013f70:	e1bff915 	stw	r6,-28(fp)
 4013f74:	e1fff815 	stw	r7,-32(fp)
  int retval = 0;
 4013f78:	e03fff15 	stw	zero,-4(fp)
      _REENT_CHECK_MISC(ptr);
      ps = &(_REENT_WCRTOMB_STATE(ptr));
    }
#endif

  if (s == NULL)
 4013f7c:	e0bffa17 	ldw	r2,-24(fp)
 4013f80:	10000a1e 	bne	r2,zero,4013fac <_wcrtomb_r+0x54>
    retval = __WCTOMB (ptr, buf, L'\0', ps);
 4013f84:	4013f300 	call	4013f30 <__get_current_locale>
 4013f88:	10803817 	ldw	r2,224(r2)
 4013f8c:	e0fffc84 	addi	r3,fp,-14
 4013f90:	e1fff817 	ldw	r7,-32(fp)
 4013f94:	000d883a 	mov	r6,zero
 4013f98:	180b883a 	mov	r5,r3
 4013f9c:	e13ffb17 	ldw	r4,-20(fp)
 4013fa0:	103ee83a 	callr	r2
 4013fa4:	e0bfff15 	stw	r2,-4(fp)
 4013fa8:	00000806 	br	4013fcc <_wcrtomb_r+0x74>
  else
    retval = __WCTOMB (ptr, s, wc, ps);
 4013fac:	4013f300 	call	4013f30 <__get_current_locale>
 4013fb0:	10803817 	ldw	r2,224(r2)
 4013fb4:	e1fff817 	ldw	r7,-32(fp)
 4013fb8:	e1bff917 	ldw	r6,-28(fp)
 4013fbc:	e17ffa17 	ldw	r5,-24(fp)
 4013fc0:	e13ffb17 	ldw	r4,-20(fp)
 4013fc4:	103ee83a 	callr	r2
 4013fc8:	e0bfff15 	stw	r2,-4(fp)

  if (retval == -1)
 4013fcc:	e0bfff17 	ldw	r2,-4(fp)
 4013fd0:	10bfffd8 	cmpnei	r2,r2,-1
 4013fd4:	1000071e 	bne	r2,zero,4013ff4 <_wcrtomb_r+0x9c>
    {
      ps->__count = 0;
 4013fd8:	e0bff817 	ldw	r2,-32(fp)
 4013fdc:	10000015 	stw	zero,0(r2)
      ptr->_errno = EILSEQ;
 4013fe0:	e0bffb17 	ldw	r2,-20(fp)
 4013fe4:	00c02284 	movi	r3,138
 4013fe8:	10c00015 	stw	r3,0(r2)
      return (size_t)(-1);
 4013fec:	00bfffc4 	movi	r2,-1
 4013ff0:	00000106 	br	4013ff8 <_wcrtomb_r+0xa0>
    }
  else
    return (size_t)retval;
 4013ff4:	e0bfff17 	ldw	r2,-4(fp)
}
 4013ff8:	e037883a 	mov	sp,fp
 4013ffc:	dfc00117 	ldw	ra,4(sp)
 4014000:	df000017 	ldw	fp,0(sp)
 4014004:	dec00204 	addi	sp,sp,8
 4014008:	f800283a 	ret

0401400c <wcrtomb>:
#ifndef _REENT_ONLY
size_t
wcrtomb (char *__restrict s,
	wchar_t wc,
	mbstate_t *__restrict ps)
{
 401400c:	defff604 	addi	sp,sp,-40
 4014010:	dfc00915 	stw	ra,36(sp)
 4014014:	df000815 	stw	fp,32(sp)
 4014018:	df000804 	addi	fp,sp,32
 401401c:	e13ffa15 	stw	r4,-24(fp)
 4014020:	e17ff915 	stw	r5,-28(fp)
 4014024:	e1bff815 	stw	r6,-32(fp)
#if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
  return _wcrtomb_r (_REENT, s, wc, ps);
#else
  int retval = 0;
 4014028:	e03fff15 	stw	zero,-4(fp)
  struct _reent *reent = _REENT;
 401402c:	d0a00117 	ldw	r2,-32764(gp)
 4014030:	e0bffe15 	stw	r2,-8(fp)
      _REENT_CHECK_MISC(reent);
      ps = &(_REENT_WCRTOMB_STATE(reent));
    }
#endif

  if (s == NULL)
 4014034:	e0bffa17 	ldw	r2,-24(fp)
 4014038:	10000a1e 	bne	r2,zero,4014064 <wcrtomb+0x58>
    retval = __WCTOMB (reent, buf, L'\0', ps);
 401403c:	4013f300 	call	4013f30 <__get_current_locale>
 4014040:	10803817 	ldw	r2,224(r2)
 4014044:	e0fffb84 	addi	r3,fp,-18
 4014048:	e1fff817 	ldw	r7,-32(fp)
 401404c:	000d883a 	mov	r6,zero
 4014050:	180b883a 	mov	r5,r3
 4014054:	e13ffe17 	ldw	r4,-8(fp)
 4014058:	103ee83a 	callr	r2
 401405c:	e0bfff15 	stw	r2,-4(fp)
 4014060:	00000806 	br	4014084 <wcrtomb+0x78>
  else
    retval = __WCTOMB (reent, s, wc, ps);
 4014064:	4013f300 	call	4013f30 <__get_current_locale>
 4014068:	10803817 	ldw	r2,224(r2)
 401406c:	e1fff817 	ldw	r7,-32(fp)
 4014070:	e1bff917 	ldw	r6,-28(fp)
 4014074:	e17ffa17 	ldw	r5,-24(fp)
 4014078:	e13ffe17 	ldw	r4,-8(fp)
 401407c:	103ee83a 	callr	r2
 4014080:	e0bfff15 	stw	r2,-4(fp)

  if (retval == -1)
 4014084:	e0bfff17 	ldw	r2,-4(fp)
 4014088:	10bfffd8 	cmpnei	r2,r2,-1
 401408c:	1000071e 	bne	r2,zero,40140ac <wcrtomb+0xa0>
    {
      ps->__count = 0;
 4014090:	e0bff817 	ldw	r2,-32(fp)
 4014094:	10000015 	stw	zero,0(r2)
      reent->_errno = EILSEQ;
 4014098:	e0bffe17 	ldw	r2,-8(fp)
 401409c:	00c02284 	movi	r3,138
 40140a0:	10c00015 	stw	r3,0(r2)
      return (size_t)(-1);
 40140a4:	00bfffc4 	movi	r2,-1
 40140a8:	00000106 	br	40140b0 <wcrtomb+0xa4>
    }
  else
    return (size_t)retval;
 40140ac:	e0bfff17 	ldw	r2,-4(fp)
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 40140b0:	e037883a 	mov	sp,fp
 40140b4:	dfc00117 	ldw	ra,4(sp)
 40140b8:	df000017 	ldw	fp,0(sp)
 40140bc:	dec00204 	addi	sp,sp,8
 40140c0:	f800283a 	ret

040140c4 <__get_global_locale>:
{
 40140c4:	deffff04 	addi	sp,sp,-4
 40140c8:	df000015 	stw	fp,0(sp)
 40140cc:	d839883a 	mov	fp,sp
  return &__global_locale;
 40140d0:	008100b4 	movhi	r2,1026
 40140d4:	10ae9604 	addi	r2,r2,-17832
}
 40140d8:	e037883a 	mov	sp,fp
 40140dc:	df000017 	ldw	fp,0(sp)
 40140e0:	dec00104 	addi	sp,sp,4
 40140e4:	f800283a 	ret

040140e8 <__get_current_locale>:
{
 40140e8:	defffe04 	addi	sp,sp,-8
 40140ec:	dfc00115 	stw	ra,4(sp)
 40140f0:	df000015 	stw	fp,0(sp)
 40140f4:	d839883a 	mov	fp,sp
  return __get_global_locale();
 40140f8:	40140c40 	call	40140c4 <__get_global_locale>
}
 40140fc:	e037883a 	mov	sp,fp
 4014100:	dfc00117 	ldw	ra,4(sp)
 4014104:	df000017 	ldw	fp,0(sp)
 4014108:	dec00204 	addi	sp,sp,8
 401410c:	f800283a 	ret

04014110 <_wctomb_r>:
int
_wctomb_r (struct _reent *r,
        char          *s,
        wchar_t        _wchar,
        mbstate_t     *state)
{
 4014110:	defffa04 	addi	sp,sp,-24
 4014114:	dfc00515 	stw	ra,20(sp)
 4014118:	df000415 	stw	fp,16(sp)
 401411c:	df000404 	addi	fp,sp,16
 4014120:	e13fff15 	stw	r4,-4(fp)
 4014124:	e17ffe15 	stw	r5,-8(fp)
 4014128:	e1bffd15 	stw	r6,-12(fp)
 401412c:	e1fffc15 	stw	r7,-16(fp)
  return __WCTOMB (r, s, _wchar, state);
 4014130:	40140e80 	call	40140e8 <__get_current_locale>
 4014134:	10803817 	ldw	r2,224(r2)
 4014138:	e1fffc17 	ldw	r7,-16(fp)
 401413c:	e1bffd17 	ldw	r6,-12(fp)
 4014140:	e17ffe17 	ldw	r5,-8(fp)
 4014144:	e13fff17 	ldw	r4,-4(fp)
 4014148:	103ee83a 	callr	r2
}
 401414c:	e037883a 	mov	sp,fp
 4014150:	dfc00117 	ldw	ra,4(sp)
 4014154:	df000017 	ldw	fp,0(sp)
 4014158:	dec00204 	addi	sp,sp,8
 401415c:	f800283a 	ret

04014160 <__ascii_wctomb>:
int
__ascii_wctomb (struct _reent *r,
        char          *s,
        wchar_t        _wchar,
        mbstate_t     *state)
{
 4014160:	defffa04 	addi	sp,sp,-24
 4014164:	df000515 	stw	fp,20(sp)
 4014168:	df000504 	addi	fp,sp,20
 401416c:	e13ffe15 	stw	r4,-8(fp)
 4014170:	e17ffd15 	stw	r5,-12(fp)
 4014174:	e1bffc15 	stw	r6,-16(fp)
 4014178:	e1fffb15 	stw	r7,-20(fp)
  /* Avoids compiler warnings about comparisons that are always false
     due to limited range when sizeof(wchar_t) is 2 but sizeof(wint_t)
     is 4, as is the case on cygwin.  */
  wint_t wchar = _wchar;
 401417c:	e0bffc17 	ldw	r2,-16(fp)
 4014180:	e0bfff15 	stw	r2,-4(fp)

  if (s == NULL)
 4014184:	e0bffd17 	ldw	r2,-12(fp)
 4014188:	1000021e 	bne	r2,zero,4014194 <__ascii_wctomb+0x34>
    return 0;
 401418c:	0005883a 	mov	r2,zero
 4014190:	00000d06 	br	40141c8 <__ascii_wctomb+0x68>
 
#ifdef __CYGWIN__
  if ((size_t)wchar >= 0x80)
#else
  if ((size_t)wchar >= 0x100)
 4014194:	e0bfff17 	ldw	r2,-4(fp)
 4014198:	10804030 	cmpltui	r2,r2,256
 401419c:	1000051e 	bne	r2,zero,40141b4 <__ascii_wctomb+0x54>
#endif
    {
      r->_errno = EILSEQ;
 40141a0:	e0bffe17 	ldw	r2,-8(fp)
 40141a4:	00c02284 	movi	r3,138
 40141a8:	10c00015 	stw	r3,0(r2)
      return -1;
 40141ac:	00bfffc4 	movi	r2,-1
 40141b0:	00000506 	br	40141c8 <__ascii_wctomb+0x68>
    }

  *s = (char) wchar;
 40141b4:	e0bfff17 	ldw	r2,-4(fp)
 40141b8:	1007883a 	mov	r3,r2
 40141bc:	e0bffd17 	ldw	r2,-12(fp)
 40141c0:	10c00005 	stb	r3,0(r2)
  return 1;
 40141c4:	00800044 	movi	r2,1
}
 40141c8:	e037883a 	mov	sp,fp
 40141cc:	df000017 	ldw	fp,0(sp)
 40141d0:	dec00104 	addi	sp,sp,4
 40141d4:	f800283a 	ret

040141d8 <abort>:
#include <unistd.h>
#include <signal.h>

void
abort (void)
{
 40141d8:	defffe04 	addi	sp,sp,-8
 40141dc:	dfc00115 	stw	ra,4(sp)
 40141e0:	df000015 	stw	fp,0(sp)
 40141e4:	d839883a 	mov	fp,sp
  write (2, "Abort called\n", sizeof ("Abort called\n")-1);
#endif

  while (1)
    {
      raise (SIGABRT);
 40141e8:	01000184 	movi	r4,6
 40141ec:	40145300 	call	4014530 <raise>
      _exit (1);
 40141f0:	01000044 	movi	r4,1
 40141f4:	4017de00 	call	4017de0 <_exit>

040141f8 <_init_signal_r>:
#include <reent.h>
#include <_syslist.h>

int
_init_signal_r (struct _reent *ptr)
{
 40141f8:	defffc04 	addi	sp,sp,-16
 40141fc:	dfc00315 	stw	ra,12(sp)
 4014200:	df000215 	stw	fp,8(sp)
 4014204:	df000204 	addi	fp,sp,8
 4014208:	e13ffe15 	stw	r4,-8(fp)
  int i;

  if (ptr->_sig_func == NULL)
 401420c:	e0bffe17 	ldw	r2,-8(fp)
 4014210:	1080b717 	ldw	r2,732(r2)
 4014214:	1000191e 	bne	r2,zero,401427c <_init_signal_r+0x84>
    {
      ptr->_sig_func = (_sig_func_ptr *)_malloc_r (ptr, sizeof (_sig_func_ptr) * NSIG);
 4014218:	01402004 	movi	r5,128
 401421c:	e13ffe17 	ldw	r4,-8(fp)
 4014220:	400e1400 	call	400e140 <_malloc_r>
 4014224:	1007883a 	mov	r3,r2
 4014228:	e0bffe17 	ldw	r2,-8(fp)
 401422c:	10c0b715 	stw	r3,732(r2)
      if (ptr->_sig_func == NULL)
 4014230:	e0bffe17 	ldw	r2,-8(fp)
 4014234:	1080b717 	ldw	r2,732(r2)
 4014238:	1000021e 	bne	r2,zero,4014244 <_init_signal_r+0x4c>
	return -1;
 401423c:	00bfffc4 	movi	r2,-1
 4014240:	00000f06 	br	4014280 <_init_signal_r+0x88>

      for (i = 0; i < NSIG; i++)
 4014244:	e03fff15 	stw	zero,-4(fp)
 4014248:	00000906 	br	4014270 <_init_signal_r+0x78>
	ptr->_sig_func[i] = SIG_DFL;
 401424c:	e0bffe17 	ldw	r2,-8(fp)
 4014250:	10c0b717 	ldw	r3,732(r2)
 4014254:	e0bfff17 	ldw	r2,-4(fp)
 4014258:	100490ba 	slli	r2,r2,2
 401425c:	1885883a 	add	r2,r3,r2
 4014260:	10000015 	stw	zero,0(r2)
      for (i = 0; i < NSIG; i++)
 4014264:	e0bfff17 	ldw	r2,-4(fp)
 4014268:	10800044 	addi	r2,r2,1
 401426c:	e0bfff15 	stw	r2,-4(fp)
 4014270:	e0bfff17 	ldw	r2,-4(fp)
 4014274:	10800810 	cmplti	r2,r2,32
 4014278:	103ff41e 	bne	r2,zero,401424c <_init_signal_r+0x54>
    }

  return 0;
 401427c:	0005883a 	mov	r2,zero
}
 4014280:	e037883a 	mov	sp,fp
 4014284:	dfc00117 	ldw	ra,4(sp)
 4014288:	df000017 	ldw	fp,0(sp)
 401428c:	dec00204 	addi	sp,sp,8
 4014290:	f800283a 	ret

04014294 <_signal_r>:

_sig_func_ptr
_signal_r (struct _reent *ptr,
	int sig,
	_sig_func_ptr func)
{
 4014294:	defffa04 	addi	sp,sp,-24
 4014298:	dfc00515 	stw	ra,20(sp)
 401429c:	df000415 	stw	fp,16(sp)
 40142a0:	df000404 	addi	fp,sp,16
 40142a4:	e13ffe15 	stw	r4,-8(fp)
 40142a8:	e17ffd15 	stw	r5,-12(fp)
 40142ac:	e1bffc15 	stw	r6,-16(fp)
  _sig_func_ptr old_func;

  if (sig < 0 || sig >= NSIG)
 40142b0:	e0bffd17 	ldw	r2,-12(fp)
 40142b4:	10000316 	blt	r2,zero,40142c4 <_signal_r+0x30>
 40142b8:	e0bffd17 	ldw	r2,-12(fp)
 40142bc:	10800810 	cmplti	r2,r2,32
 40142c0:	1000051e 	bne	r2,zero,40142d8 <_signal_r+0x44>
    {
      ptr->_errno = EINVAL;
 40142c4:	e0bffe17 	ldw	r2,-8(fp)
 40142c8:	00c00584 	movi	r3,22
 40142cc:	10c00015 	stw	r3,0(r2)
      return SIG_ERR;
 40142d0:	00bfffc4 	movi	r2,-1
 40142d4:	00001706 	br	4014334 <_signal_r+0xa0>
    }

  if (ptr->_sig_func == NULL && _init_signal_r (ptr) != 0)
 40142d8:	e0bffe17 	ldw	r2,-8(fp)
 40142dc:	1080b717 	ldw	r2,732(r2)
 40142e0:	1000051e 	bne	r2,zero,40142f8 <_signal_r+0x64>
 40142e4:	e13ffe17 	ldw	r4,-8(fp)
 40142e8:	40141f80 	call	40141f8 <_init_signal_r>
 40142ec:	10000226 	beq	r2,zero,40142f8 <_signal_r+0x64>
    return SIG_ERR;
 40142f0:	00bfffc4 	movi	r2,-1
 40142f4:	00000f06 	br	4014334 <_signal_r+0xa0>
  
  old_func = ptr->_sig_func[sig];
 40142f8:	e0bffe17 	ldw	r2,-8(fp)
 40142fc:	10c0b717 	ldw	r3,732(r2)
 4014300:	e0bffd17 	ldw	r2,-12(fp)
 4014304:	100490ba 	slli	r2,r2,2
 4014308:	1885883a 	add	r2,r3,r2
 401430c:	10800017 	ldw	r2,0(r2)
 4014310:	e0bfff15 	stw	r2,-4(fp)
  ptr->_sig_func[sig] = func;
 4014314:	e0bffe17 	ldw	r2,-8(fp)
 4014318:	10c0b717 	ldw	r3,732(r2)
 401431c:	e0bffd17 	ldw	r2,-12(fp)
 4014320:	100490ba 	slli	r2,r2,2
 4014324:	1885883a 	add	r2,r3,r2
 4014328:	e0fffc17 	ldw	r3,-16(fp)
 401432c:	10c00015 	stw	r3,0(r2)

  return old_func;
 4014330:	e0bfff17 	ldw	r2,-4(fp)
}
 4014334:	e037883a 	mov	sp,fp
 4014338:	dfc00117 	ldw	ra,4(sp)
 401433c:	df000017 	ldw	fp,0(sp)
 4014340:	dec00204 	addi	sp,sp,8
 4014344:	f800283a 	ret

04014348 <_raise_r>:

int 
_raise_r (struct _reent *ptr,
     int sig)
{
 4014348:	defffb04 	addi	sp,sp,-20
 401434c:	dfc00415 	stw	ra,16(sp)
 4014350:	df000315 	stw	fp,12(sp)
 4014354:	df000304 	addi	fp,sp,12
 4014358:	e13ffe15 	stw	r4,-8(fp)
 401435c:	e17ffd15 	stw	r5,-12(fp)
  _sig_func_ptr func;

  if (sig < 0 || sig >= NSIG)
 4014360:	e0bffd17 	ldw	r2,-12(fp)
 4014364:	10000316 	blt	r2,zero,4014374 <_raise_r+0x2c>
 4014368:	e0bffd17 	ldw	r2,-12(fp)
 401436c:	10800810 	cmplti	r2,r2,32
 4014370:	1000051e 	bne	r2,zero,4014388 <_raise_r+0x40>
    {
      ptr->_errno = EINVAL;
 4014374:	e0bffe17 	ldw	r2,-8(fp)
 4014378:	00c00584 	movi	r3,22
 401437c:	10c00015 	stw	r3,0(r2)
      return -1;
 4014380:	00bfffc4 	movi	r2,-1
 4014384:	00002c06 	br	4014438 <_raise_r+0xf0>
    }

  if (ptr->_sig_func == NULL)
 4014388:	e0bffe17 	ldw	r2,-8(fp)
 401438c:	1080b717 	ldw	r2,732(r2)
 4014390:	1000021e 	bne	r2,zero,401439c <_raise_r+0x54>
    func = SIG_DFL;
 4014394:	e03fff15 	stw	zero,-4(fp)
 4014398:	00000706 	br	40143b8 <_raise_r+0x70>
  else
    func = ptr->_sig_func[sig];
 401439c:	e0bffe17 	ldw	r2,-8(fp)
 40143a0:	10c0b717 	ldw	r3,732(r2)
 40143a4:	e0bffd17 	ldw	r2,-12(fp)
 40143a8:	100490ba 	slli	r2,r2,2
 40143ac:	1885883a 	add	r2,r3,r2
 40143b0:	10800017 	ldw	r2,0(r2)
 40143b4:	e0bfff15 	stw	r2,-4(fp)

  if (func == SIG_DFL)
 40143b8:	e0bfff17 	ldw	r2,-4(fp)
 40143bc:	1000071e 	bne	r2,zero,40143dc <_raise_r+0x94>
    return _kill_r (ptr, _getpid_r (ptr), sig);
 40143c0:	e13ffe17 	ldw	r4,-8(fp)
 40143c4:	40146780 	call	4014678 <_getpid_r>
 40143c8:	e1bffd17 	ldw	r6,-12(fp)
 40143cc:	100b883a 	mov	r5,r2
 40143d0:	e13ffe17 	ldw	r4,-8(fp)
 40143d4:	40146100 	call	4014610 <_kill_r>
 40143d8:	00001706 	br	4014438 <_raise_r+0xf0>
  else if (func == SIG_IGN)
 40143dc:	e0bfff17 	ldw	r2,-4(fp)
 40143e0:	10800058 	cmpnei	r2,r2,1
 40143e4:	1000021e 	bne	r2,zero,40143f0 <_raise_r+0xa8>
    return 0;
 40143e8:	0005883a 	mov	r2,zero
 40143ec:	00001206 	br	4014438 <_raise_r+0xf0>
  else if (func == SIG_ERR)
 40143f0:	e0bfff17 	ldw	r2,-4(fp)
 40143f4:	10bfffd8 	cmpnei	r2,r2,-1
 40143f8:	1000051e 	bne	r2,zero,4014410 <_raise_r+0xc8>
    {
      ptr->_errno = EINVAL;
 40143fc:	e0bffe17 	ldw	r2,-8(fp)
 4014400:	00c00584 	movi	r3,22
 4014404:	10c00015 	stw	r3,0(r2)
      return 1;
 4014408:	00800044 	movi	r2,1
 401440c:	00000a06 	br	4014438 <_raise_r+0xf0>
    }
  else
    {
      ptr->_sig_func[sig] = SIG_DFL;
 4014410:	e0bffe17 	ldw	r2,-8(fp)
 4014414:	10c0b717 	ldw	r3,732(r2)
 4014418:	e0bffd17 	ldw	r2,-12(fp)
 401441c:	100490ba 	slli	r2,r2,2
 4014420:	1885883a 	add	r2,r3,r2
 4014424:	10000015 	stw	zero,0(r2)
      func (sig);
 4014428:	e0bfff17 	ldw	r2,-4(fp)
 401442c:	e13ffd17 	ldw	r4,-12(fp)
 4014430:	103ee83a 	callr	r2
      return 0;
 4014434:	0005883a 	mov	r2,zero
    }
}
 4014438:	e037883a 	mov	sp,fp
 401443c:	dfc00117 	ldw	ra,4(sp)
 4014440:	df000017 	ldw	fp,0(sp)
 4014444:	dec00204 	addi	sp,sp,8
 4014448:	f800283a 	ret

0401444c <__sigtramp_r>:

int
__sigtramp_r (struct _reent *ptr,
     int sig)
{
 401444c:	defffb04 	addi	sp,sp,-20
 4014450:	dfc00415 	stw	ra,16(sp)
 4014454:	df000315 	stw	fp,12(sp)
 4014458:	df000304 	addi	fp,sp,12
 401445c:	e13ffe15 	stw	r4,-8(fp)
 4014460:	e17ffd15 	stw	r5,-12(fp)
  _sig_func_ptr func;

  if (sig < 0 || sig >= NSIG)
 4014464:	e0bffd17 	ldw	r2,-12(fp)
 4014468:	10000316 	blt	r2,zero,4014478 <__sigtramp_r+0x2c>
 401446c:	e0bffd17 	ldw	r2,-12(fp)
 4014470:	10800810 	cmplti	r2,r2,32
 4014474:	1000021e 	bne	r2,zero,4014480 <__sigtramp_r+0x34>
    {
      return -1;
 4014478:	00bfffc4 	movi	r2,-1
 401447c:	00002706 	br	401451c <__sigtramp_r+0xd0>
    }

  if (ptr->_sig_func == NULL && _init_signal_r (ptr) != 0)
 4014480:	e0bffe17 	ldw	r2,-8(fp)
 4014484:	1080b717 	ldw	r2,732(r2)
 4014488:	1000051e 	bne	r2,zero,40144a0 <__sigtramp_r+0x54>
 401448c:	e13ffe17 	ldw	r4,-8(fp)
 4014490:	40141f80 	call	40141f8 <_init_signal_r>
 4014494:	10000226 	beq	r2,zero,40144a0 <__sigtramp_r+0x54>
    return -1;
 4014498:	00bfffc4 	movi	r2,-1
 401449c:	00001f06 	br	401451c <__sigtramp_r+0xd0>

  func = ptr->_sig_func[sig];
 40144a0:	e0bffe17 	ldw	r2,-8(fp)
 40144a4:	10c0b717 	ldw	r3,732(r2)
 40144a8:	e0bffd17 	ldw	r2,-12(fp)
 40144ac:	100490ba 	slli	r2,r2,2
 40144b0:	1885883a 	add	r2,r3,r2
 40144b4:	10800017 	ldw	r2,0(r2)
 40144b8:	e0bfff15 	stw	r2,-4(fp)
  if (func == SIG_DFL)
 40144bc:	e0bfff17 	ldw	r2,-4(fp)
 40144c0:	1000021e 	bne	r2,zero,40144cc <__sigtramp_r+0x80>
    return 1;
 40144c4:	00800044 	movi	r2,1
 40144c8:	00001406 	br	401451c <__sigtramp_r+0xd0>
  else if (func == SIG_ERR)
 40144cc:	e0bfff17 	ldw	r2,-4(fp)
 40144d0:	10bfffd8 	cmpnei	r2,r2,-1
 40144d4:	1000021e 	bne	r2,zero,40144e0 <__sigtramp_r+0x94>
    return 2;
 40144d8:	00800084 	movi	r2,2
 40144dc:	00000f06 	br	401451c <__sigtramp_r+0xd0>
  else if (func == SIG_IGN)
 40144e0:	e0bfff17 	ldw	r2,-4(fp)
 40144e4:	10800058 	cmpnei	r2,r2,1
 40144e8:	1000021e 	bne	r2,zero,40144f4 <__sigtramp_r+0xa8>
    return 3;
 40144ec:	008000c4 	movi	r2,3
 40144f0:	00000a06 	br	401451c <__sigtramp_r+0xd0>
  else
    {
      ptr->_sig_func[sig] = SIG_DFL;
 40144f4:	e0bffe17 	ldw	r2,-8(fp)
 40144f8:	10c0b717 	ldw	r3,732(r2)
 40144fc:	e0bffd17 	ldw	r2,-12(fp)
 4014500:	100490ba 	slli	r2,r2,2
 4014504:	1885883a 	add	r2,r3,r2
 4014508:	10000015 	stw	zero,0(r2)
      func (sig);
 401450c:	e0bfff17 	ldw	r2,-4(fp)
 4014510:	e13ffd17 	ldw	r4,-12(fp)
 4014514:	103ee83a 	callr	r2
      return 0;
 4014518:	0005883a 	mov	r2,zero
    }
}
 401451c:	e037883a 	mov	sp,fp
 4014520:	dfc00117 	ldw	ra,4(sp)
 4014524:	df000017 	ldw	fp,0(sp)
 4014528:	dec00204 	addi	sp,sp,8
 401452c:	f800283a 	ret

04014530 <raise>:

#ifndef _REENT_ONLY

int 
raise (int sig)
{
 4014530:	defffd04 	addi	sp,sp,-12
 4014534:	dfc00215 	stw	ra,8(sp)
 4014538:	df000115 	stw	fp,4(sp)
 401453c:	df000104 	addi	fp,sp,4
 4014540:	e13fff15 	stw	r4,-4(fp)
  return _raise_r (_REENT, sig);
 4014544:	d0a00117 	ldw	r2,-32764(gp)
 4014548:	e17fff17 	ldw	r5,-4(fp)
 401454c:	1009883a 	mov	r4,r2
 4014550:	40143480 	call	4014348 <_raise_r>
}
 4014554:	e037883a 	mov	sp,fp
 4014558:	dfc00117 	ldw	ra,4(sp)
 401455c:	df000017 	ldw	fp,0(sp)
 4014560:	dec00204 	addi	sp,sp,8
 4014564:	f800283a 	ret

04014568 <signal>:

_sig_func_ptr
signal (int sig,
	_sig_func_ptr func)
{
 4014568:	defffc04 	addi	sp,sp,-16
 401456c:	dfc00315 	stw	ra,12(sp)
 4014570:	df000215 	stw	fp,8(sp)
 4014574:	df000204 	addi	fp,sp,8
 4014578:	e13fff15 	stw	r4,-4(fp)
 401457c:	e17ffe15 	stw	r5,-8(fp)
  return _signal_r (_REENT, sig, func);
 4014580:	d0a00117 	ldw	r2,-32764(gp)
 4014584:	e1bffe17 	ldw	r6,-8(fp)
 4014588:	e17fff17 	ldw	r5,-4(fp)
 401458c:	1009883a 	mov	r4,r2
 4014590:	40142940 	call	4014294 <_signal_r>
}
 4014594:	e037883a 	mov	sp,fp
 4014598:	dfc00117 	ldw	ra,4(sp)
 401459c:	df000017 	ldw	fp,0(sp)
 40145a0:	dec00204 	addi	sp,sp,8
 40145a4:	f800283a 	ret

040145a8 <_init_signal>:

int 
_init_signal (void)
{
 40145a8:	defffe04 	addi	sp,sp,-8
 40145ac:	dfc00115 	stw	ra,4(sp)
 40145b0:	df000015 	stw	fp,0(sp)
 40145b4:	d839883a 	mov	fp,sp
  return _init_signal_r (_REENT);
 40145b8:	d0a00117 	ldw	r2,-32764(gp)
 40145bc:	1009883a 	mov	r4,r2
 40145c0:	40141f80 	call	40141f8 <_init_signal_r>
}
 40145c4:	e037883a 	mov	sp,fp
 40145c8:	dfc00117 	ldw	ra,4(sp)
 40145cc:	df000017 	ldw	fp,0(sp)
 40145d0:	dec00204 	addi	sp,sp,8
 40145d4:	f800283a 	ret

040145d8 <__sigtramp>:

int
__sigtramp (int sig)
{
 40145d8:	defffd04 	addi	sp,sp,-12
 40145dc:	dfc00215 	stw	ra,8(sp)
 40145e0:	df000115 	stw	fp,4(sp)
 40145e4:	df000104 	addi	fp,sp,4
 40145e8:	e13fff15 	stw	r4,-4(fp)
  return __sigtramp_r (_REENT, sig);
 40145ec:	d0a00117 	ldw	r2,-32764(gp)
 40145f0:	e17fff17 	ldw	r5,-4(fp)
 40145f4:	1009883a 	mov	r4,r2
 40145f8:	401444c0 	call	401444c <__sigtramp_r>
}
 40145fc:	e037883a 	mov	sp,fp
 4014600:	dfc00117 	ldw	ra,4(sp)
 4014604:	df000017 	ldw	fp,0(sp)
 4014608:	dec00204 	addi	sp,sp,8
 401460c:	f800283a 	ret

04014610 <_kill_r>:

int
_kill_r (struct _reent *ptr,
     int pid,
     int sig)
{
 4014610:	defffa04 	addi	sp,sp,-24
 4014614:	dfc00515 	stw	ra,20(sp)
 4014618:	df000415 	stw	fp,16(sp)
 401461c:	df000404 	addi	fp,sp,16
 4014620:	e13ffe15 	stw	r4,-8(fp)
 4014624:	e17ffd15 	stw	r5,-12(fp)
 4014628:	e1bffc15 	stw	r6,-16(fp)
  int ret;

  errno = 0;
 401462c:	d0272715 	stw	zero,-25444(gp)
  if ((ret = _kill (pid, sig)) == -1 && errno != 0)
 4014630:	e17ffc17 	ldw	r5,-16(fp)
 4014634:	e13ffd17 	ldw	r4,-12(fp)
 4014638:	40182f00 	call	40182f0 <kill>
 401463c:	e0bfff15 	stw	r2,-4(fp)
 4014640:	e0bfff17 	ldw	r2,-4(fp)
 4014644:	10bfffd8 	cmpnei	r2,r2,-1
 4014648:	1000051e 	bne	r2,zero,4014660 <_kill_r+0x50>
 401464c:	d0a72717 	ldw	r2,-25444(gp)
 4014650:	10000326 	beq	r2,zero,4014660 <_kill_r+0x50>
    ptr->_errno = errno;
 4014654:	d0e72717 	ldw	r3,-25444(gp)
 4014658:	e0bffe17 	ldw	r2,-8(fp)
 401465c:	10c00015 	stw	r3,0(r2)
  return ret;
 4014660:	e0bfff17 	ldw	r2,-4(fp)
}
 4014664:	e037883a 	mov	sp,fp
 4014668:	dfc00117 	ldw	ra,4(sp)
 401466c:	df000017 	ldw	fp,0(sp)
 4014670:	dec00204 	addi	sp,sp,8
 4014674:	f800283a 	ret

04014678 <_getpid_r>:
	still must have the reentrant pointer argument.
*/

int
_getpid_r (struct _reent *ptr)
{
 4014678:	defffc04 	addi	sp,sp,-16
 401467c:	dfc00315 	stw	ra,12(sp)
 4014680:	df000215 	stw	fp,8(sp)
 4014684:	df000204 	addi	fp,sp,8
 4014688:	e13ffe15 	stw	r4,-8(fp)
  int ret;
  ret = _getpid ();
 401468c:	4017f100 	call	4017f10 <getpid>
 4014690:	e0bfff15 	stw	r2,-4(fp)
  return ret;
 4014694:	e0bfff17 	ldw	r2,-4(fp)
}
 4014698:	e037883a 	mov	sp,fp
 401469c:	dfc00117 	ldw	ra,4(sp)
 40146a0:	df000017 	ldw	fp,0(sp)
 40146a4:	dec00204 	addi	sp,sp,8
 40146a8:	f800283a 	ret

040146ac <__udivdi3>:
 40146ac:	defff504 	addi	sp,sp,-44
 40146b0:	dd000515 	stw	r20,20(sp)
 40146b4:	dc800315 	stw	r18,12(sp)
 40146b8:	dfc00a15 	stw	ra,40(sp)
 40146bc:	df000915 	stw	fp,36(sp)
 40146c0:	ddc00815 	stw	r23,32(sp)
 40146c4:	dd800715 	stw	r22,28(sp)
 40146c8:	dd400615 	stw	r21,24(sp)
 40146cc:	dcc00415 	stw	r19,16(sp)
 40146d0:	dc400215 	stw	r17,8(sp)
 40146d4:	dc000115 	stw	r16,4(sp)
 40146d8:	2029883a 	mov	r20,r4
 40146dc:	2825883a 	mov	r18,r5
 40146e0:	3800461e 	bne	r7,zero,40147fc <__udivdi3+0x150>
 40146e4:	3823883a 	mov	r17,r7
 40146e8:	3021883a 	mov	r16,r6
 40146ec:	2027883a 	mov	r19,r4
 40146f0:	2980622e 	bgeu	r5,r6,401487c <__udivdi3+0x1d0>
 40146f4:	00bfffd4 	movui	r2,65535
 40146f8:	282b883a 	mov	r21,r5
 40146fc:	1180aa2e 	bgeu	r2,r6,40149a8 <__udivdi3+0x2fc>
 4014700:	00804034 	movhi	r2,256
 4014704:	30815936 	bltu	r6,r2,4014c6c <__udivdi3+0x5c0>
 4014708:	3006d63a 	srli	r3,r6,24
 401470c:	04400604 	movi	r17,24
 4014710:	008100b4 	movhi	r2,1026
 4014714:	1885883a 	add	r2,r3,r2
 4014718:	112c3803 	ldbu	r4,-20256(r2)
 401471c:	00800804 	movi	r2,32
 4014720:	2463883a 	add	r17,r4,r17
 4014724:	1449c83a 	sub	r4,r2,r17
 4014728:	14400526 	beq	r2,r17,4014740 <__udivdi3+0x94>
 401472c:	9106983a 	sll	r3,r18,r4
 4014730:	a462d83a 	srl	r17,r20,r17
 4014734:	3120983a 	sll	r16,r6,r4
 4014738:	a126983a 	sll	r19,r20,r4
 401473c:	88eab03a 	or	r21,r17,r3
 4014740:	802cd43a 	srli	r22,r16,16
 4014744:	a809883a 	mov	r4,r21
 4014748:	853fffcc 	andi	r20,r16,65535
 401474c:	b00b883a 	mov	r5,r22
 4014750:	40153e40 	call	40153e4 <__umodsi3>
 4014754:	a809883a 	mov	r4,r21
 4014758:	b00b883a 	mov	r5,r22
 401475c:	1025883a 	mov	r18,r2
 4014760:	40153800 	call	4015380 <__udivsi3>
 4014764:	a009883a 	mov	r4,r20
 4014768:	100b883a 	mov	r5,r2
 401476c:	102b883a 	mov	r21,r2
 4014770:	40072d80 	call	40072d8 <__mulsi3>
 4014774:	9024943a 	slli	r18,r18,16
 4014778:	9808d43a 	srli	r4,r19,16
 401477c:	9108b03a 	or	r4,r18,r4
 4014780:	2080052e 	bgeu	r4,r2,4014798 <__udivdi3+0xec>
 4014784:	2409883a 	add	r4,r4,r16
 4014788:	a8ffffc4 	addi	r3,r21,-1
 401478c:	24000136 	bltu	r4,r16,4014794 <__udivdi3+0xe8>
 4014790:	20814736 	bltu	r4,r2,4014cb0 <__udivdi3+0x604>
 4014794:	182b883a 	mov	r21,r3
 4014798:	20a3c83a 	sub	r17,r4,r2
 401479c:	8809883a 	mov	r4,r17
 40147a0:	b00b883a 	mov	r5,r22
 40147a4:	40153e40 	call	40153e4 <__umodsi3>
 40147a8:	8809883a 	mov	r4,r17
 40147ac:	1023883a 	mov	r17,r2
 40147b0:	b00b883a 	mov	r5,r22
 40147b4:	8822943a 	slli	r17,r17,16
 40147b8:	40153800 	call	4015380 <__udivsi3>
 40147bc:	100b883a 	mov	r5,r2
 40147c0:	a009883a 	mov	r4,r20
 40147c4:	9cffffcc 	andi	r19,r19,65535
 40147c8:	1025883a 	mov	r18,r2
 40147cc:	8ce6b03a 	or	r19,r17,r19
 40147d0:	40072d80 	call	40072d8 <__mulsi3>
 40147d4:	9880052e 	bgeu	r19,r2,40147ec <__udivdi3+0x140>
 40147d8:	84e7883a 	add	r19,r16,r19
 40147dc:	90ffffc4 	addi	r3,r18,-1
 40147e0:	9c000136 	bltu	r19,r16,40147e8 <__udivdi3+0x13c>
 40147e4:	98813036 	bltu	r19,r2,4014ca8 <__udivdi3+0x5fc>
 40147e8:	1825883a 	mov	r18,r3
 40147ec:	a80c943a 	slli	r6,r21,16
 40147f0:	0007883a 	mov	r3,zero
 40147f4:	3484b03a 	or	r2,r6,r18
 40147f8:	00000306 	br	4014808 <__udivdi3+0x15c>
 40147fc:	29c00e2e 	bgeu	r5,r7,4014838 <__udivdi3+0x18c>
 4014800:	0007883a 	mov	r3,zero
 4014804:	0005883a 	mov	r2,zero
 4014808:	dfc00a17 	ldw	ra,40(sp)
 401480c:	df000917 	ldw	fp,36(sp)
 4014810:	ddc00817 	ldw	r23,32(sp)
 4014814:	dd800717 	ldw	r22,28(sp)
 4014818:	dd400617 	ldw	r21,24(sp)
 401481c:	dd000517 	ldw	r20,20(sp)
 4014820:	dcc00417 	ldw	r19,16(sp)
 4014824:	dc800317 	ldw	r18,12(sp)
 4014828:	dc400217 	ldw	r17,8(sp)
 401482c:	dc000117 	ldw	r16,4(sp)
 4014830:	dec00b04 	addi	sp,sp,44
 4014834:	f800283a 	ret
 4014838:	00bfffd4 	movui	r2,65535
 401483c:	11c05f2e 	bgeu	r2,r7,40149bc <__udivdi3+0x310>
 4014840:	00804034 	movhi	r2,256
 4014844:	3880fb36 	bltu	r7,r2,4014c34 <__udivdi3+0x588>
 4014848:	3806d63a 	srli	r3,r7,24
 401484c:	01000604 	movi	r4,24
 4014850:	008100b4 	movhi	r2,1026
 4014854:	1885883a 	add	r2,r3,r2
 4014858:	10ec3803 	ldbu	r3,-20256(r2)
 401485c:	00800804 	movi	r2,32
 4014860:	1907883a 	add	r3,r3,r4
 4014864:	10e3c83a 	sub	r17,r2,r3
 4014868:	10c0901e 	bne	r2,r3,4014aac <__udivdi3+0x400>
 401486c:	3c80f636 	bltu	r7,r18,4014c48 <__udivdi3+0x59c>
 4014870:	a185403a 	cmpgeu	r2,r20,r6
 4014874:	0007883a 	mov	r3,zero
 4014878:	003fe306 	br	4014808 <__udivdi3+0x15c>
 401487c:	3000041e 	bne	r6,zero,4014890 <__udivdi3+0x1e4>
 4014880:	000b883a 	mov	r5,zero
 4014884:	01000044 	movi	r4,1
 4014888:	40153800 	call	4015380 <__udivsi3>
 401488c:	1021883a 	mov	r16,r2
 4014890:	00bfffd4 	movui	r2,65535
 4014894:	14003f2e 	bgeu	r2,r16,4014994 <__udivdi3+0x2e8>
 4014898:	00804034 	movhi	r2,256
 401489c:	8080f036 	bltu	r16,r2,4014c60 <__udivdi3+0x5b4>
 40148a0:	8006d63a 	srli	r3,r16,24
 40148a4:	04400604 	movi	r17,24
 40148a8:	008100b4 	movhi	r2,1026
 40148ac:	1885883a 	add	r2,r3,r2
 40148b0:	10ac3803 	ldbu	r2,-20256(r2)
 40148b4:	00c00804 	movi	r3,32
 40148b8:	1463883a 	add	r17,r2,r17
 40148bc:	1c45c83a 	sub	r2,r3,r17
 40148c0:	1c40431e 	bne	r3,r17,40149d0 <__udivdi3+0x324>
 40148c4:	802cd43a 	srli	r22,r16,16
 40148c8:	9423c83a 	sub	r17,r18,r16
 40148cc:	853fffcc 	andi	r20,r16,65535
 40148d0:	00c00044 	movi	r3,1
 40148d4:	b00b883a 	mov	r5,r22
 40148d8:	8809883a 	mov	r4,r17
 40148dc:	d8c00015 	stw	r3,0(sp)
 40148e0:	40153e40 	call	40153e4 <__umodsi3>
 40148e4:	b00b883a 	mov	r5,r22
 40148e8:	8809883a 	mov	r4,r17
 40148ec:	1025883a 	mov	r18,r2
 40148f0:	40153800 	call	4015380 <__udivsi3>
 40148f4:	1009883a 	mov	r4,r2
 40148f8:	a00b883a 	mov	r5,r20
 40148fc:	102b883a 	mov	r21,r2
 4014900:	40072d80 	call	40072d8 <__mulsi3>
 4014904:	9024943a 	slli	r18,r18,16
 4014908:	9808d43a 	srli	r4,r19,16
 401490c:	d8c00017 	ldw	r3,0(sp)
 4014910:	9108b03a 	or	r4,r18,r4
 4014914:	2080052e 	bgeu	r4,r2,401492c <__udivdi3+0x280>
 4014918:	2409883a 	add	r4,r4,r16
 401491c:	a97fffc4 	addi	r5,r21,-1
 4014920:	24000136 	bltu	r4,r16,4014928 <__udivdi3+0x27c>
 4014924:	2080e536 	bltu	r4,r2,4014cbc <__udivdi3+0x610>
 4014928:	282b883a 	mov	r21,r5
 401492c:	20a3c83a 	sub	r17,r4,r2
 4014930:	8809883a 	mov	r4,r17
 4014934:	b00b883a 	mov	r5,r22
 4014938:	d8c00015 	stw	r3,0(sp)
 401493c:	40153e40 	call	40153e4 <__umodsi3>
 4014940:	8809883a 	mov	r4,r17
 4014944:	1023883a 	mov	r17,r2
 4014948:	b00b883a 	mov	r5,r22
 401494c:	8822943a 	slli	r17,r17,16
 4014950:	40153800 	call	4015380 <__udivsi3>
 4014954:	a00b883a 	mov	r5,r20
 4014958:	1009883a 	mov	r4,r2
 401495c:	9cffffcc 	andi	r19,r19,65535
 4014960:	1025883a 	mov	r18,r2
 4014964:	8ce6b03a 	or	r19,r17,r19
 4014968:	40072d80 	call	40072d8 <__mulsi3>
 401496c:	d8c00017 	ldw	r3,0(sp)
 4014970:	9880052e 	bgeu	r19,r2,4014988 <__udivdi3+0x2dc>
 4014974:	84e7883a 	add	r19,r16,r19
 4014978:	913fffc4 	addi	r4,r18,-1
 401497c:	9c000136 	bltu	r19,r16,4014984 <__udivdi3+0x2d8>
 4014980:	9880c736 	bltu	r19,r2,4014ca0 <__udivdi3+0x5f4>
 4014984:	2025883a 	mov	r18,r4
 4014988:	a80c943a 	slli	r6,r21,16
 401498c:	3484b03a 	or	r2,r6,r18
 4014990:	003f9d06 	br	4014808 <__udivdi3+0x15c>
 4014994:	80804030 	cmpltui	r2,r16,256
 4014998:	1000b71e 	bne	r2,zero,4014c78 <__udivdi3+0x5cc>
 401499c:	8006d23a 	srli	r3,r16,8
 40149a0:	04400204 	movi	r17,8
 40149a4:	003fc006 	br	40148a8 <__udivdi3+0x1fc>
 40149a8:	30804030 	cmpltui	r2,r6,256
 40149ac:	1000a41e 	bne	r2,zero,4014c40 <__udivdi3+0x594>
 40149b0:	3006d23a 	srli	r3,r6,8
 40149b4:	04400204 	movi	r17,8
 40149b8:	003f5506 	br	4014710 <__udivdi3+0x64>
 40149bc:	38804030 	cmpltui	r2,r7,256
 40149c0:	1000a41e 	bne	r2,zero,4014c54 <__udivdi3+0x5a8>
 40149c4:	3806d23a 	srli	r3,r7,8
 40149c8:	01000204 	movi	r4,8
 40149cc:	003fa006 	br	4014850 <__udivdi3+0x1a4>
 40149d0:	80a0983a 	sll	r16,r16,r2
 40149d4:	946ed83a 	srl	r23,r18,r17
 40149d8:	9086983a 	sll	r3,r18,r2
 40149dc:	802cd43a 	srli	r22,r16,16
 40149e0:	a462d83a 	srl	r17,r20,r17
 40149e4:	b809883a 	mov	r4,r23
 40149e8:	b00b883a 	mov	r5,r22
 40149ec:	88eab03a 	or	r21,r17,r3
 40149f0:	a0a6983a 	sll	r19,r20,r2
 40149f4:	40153e40 	call	40153e4 <__umodsi3>
 40149f8:	b809883a 	mov	r4,r23
 40149fc:	b00b883a 	mov	r5,r22
 4014a00:	1025883a 	mov	r18,r2
 4014a04:	853fffcc 	andi	r20,r16,65535
 4014a08:	40153800 	call	4015380 <__udivsi3>
 4014a0c:	a009883a 	mov	r4,r20
 4014a10:	100b883a 	mov	r5,r2
 4014a14:	102f883a 	mov	r23,r2
 4014a18:	40072d80 	call	40072d8 <__mulsi3>
 4014a1c:	9024943a 	slli	r18,r18,16
 4014a20:	a808d43a 	srli	r4,r21,16
 4014a24:	9108b03a 	or	r4,r18,r4
 4014a28:	2080062e 	bgeu	r4,r2,4014a44 <__udivdi3+0x398>
 4014a2c:	2409883a 	add	r4,r4,r16
 4014a30:	b8ffffc4 	addi	r3,r23,-1
 4014a34:	24009836 	bltu	r4,r16,4014c98 <__udivdi3+0x5ec>
 4014a38:	2080972e 	bgeu	r4,r2,4014c98 <__udivdi3+0x5ec>
 4014a3c:	bdffff84 	addi	r23,r23,-2
 4014a40:	2409883a 	add	r4,r4,r16
 4014a44:	20a3c83a 	sub	r17,r4,r2
 4014a48:	8809883a 	mov	r4,r17
 4014a4c:	b00b883a 	mov	r5,r22
 4014a50:	40153e40 	call	40153e4 <__umodsi3>
 4014a54:	1025883a 	mov	r18,r2
 4014a58:	8809883a 	mov	r4,r17
 4014a5c:	b00b883a 	mov	r5,r22
 4014a60:	9024943a 	slli	r18,r18,16
 4014a64:	40153800 	call	4015380 <__udivsi3>
 4014a68:	100b883a 	mov	r5,r2
 4014a6c:	a009883a 	mov	r4,r20
 4014a70:	ac7fffcc 	andi	r17,r21,65535
 4014a74:	1039883a 	mov	fp,r2
 4014a78:	9462b03a 	or	r17,r18,r17
 4014a7c:	40072d80 	call	40072d8 <__mulsi3>
 4014a80:	8880062e 	bgeu	r17,r2,4014a9c <__udivdi3+0x3f0>
 4014a84:	8c23883a 	add	r17,r17,r16
 4014a88:	e0ffffc4 	addi	r3,fp,-1
 4014a8c:	8c007e36 	bltu	r17,r16,4014c88 <__udivdi3+0x5dc>
 4014a90:	88807d2e 	bgeu	r17,r2,4014c88 <__udivdi3+0x5dc>
 4014a94:	e73fff84 	addi	fp,fp,-2
 4014a98:	8c23883a 	add	r17,r17,r16
 4014a9c:	b806943a 	slli	r3,r23,16
 4014aa0:	88a3c83a 	sub	r17,r17,r2
 4014aa4:	1f06b03a 	or	r3,r3,fp
 4014aa8:	003f8a06 	br	40148d4 <__udivdi3+0x228>
 4014aac:	30e6d83a 	srl	r19,r6,r3
 4014ab0:	3c4e983a 	sll	r7,r7,r17
 4014ab4:	90e0d83a 	srl	r16,r18,r3
 4014ab8:	a0c4d83a 	srl	r2,r20,r3
 4014abc:	99e6b03a 	or	r19,r19,r7
 4014ac0:	9446983a 	sll	r3,r18,r17
 4014ac4:	9838d43a 	srli	fp,r19,16
 4014ac8:	8009883a 	mov	r4,r16
 4014acc:	10eab03a 	or	r21,r2,r3
 4014ad0:	e00b883a 	mov	r5,fp
 4014ad4:	346c983a 	sll	r22,r6,r17
 4014ad8:	dd400015 	stw	r21,0(sp)
 4014adc:	40153e40 	call	40153e4 <__umodsi3>
 4014ae0:	8009883a 	mov	r4,r16
 4014ae4:	e00b883a 	mov	r5,fp
 4014ae8:	102f883a 	mov	r23,r2
 4014aec:	9cbfffcc 	andi	r18,r19,65535
 4014af0:	40153800 	call	4015380 <__udivsi3>
 4014af4:	9009883a 	mov	r4,r18
 4014af8:	100b883a 	mov	r5,r2
 4014afc:	1021883a 	mov	r16,r2
 4014b00:	40072d80 	call	40072d8 <__mulsi3>
 4014b04:	b82e943a 	slli	r23,r23,16
 4014b08:	a808d43a 	srli	r4,r21,16
 4014b0c:	b908b03a 	or	r4,r23,r4
 4014b10:	2080062e 	bgeu	r4,r2,4014b2c <__udivdi3+0x480>
 4014b14:	24c9883a 	add	r4,r4,r19
 4014b18:	817fffc4 	addi	r5,r16,-1
 4014b1c:	24c05c36 	bltu	r4,r19,4014c90 <__udivdi3+0x5e4>
 4014b20:	20805b2e 	bgeu	r4,r2,4014c90 <__udivdi3+0x5e4>
 4014b24:	843fff84 	addi	r16,r16,-2
 4014b28:	24c9883a 	add	r4,r4,r19
 4014b2c:	20abc83a 	sub	r21,r4,r2
 4014b30:	a809883a 	mov	r4,r21
 4014b34:	e00b883a 	mov	r5,fp
 4014b38:	40153e40 	call	40153e4 <__umodsi3>
 4014b3c:	a809883a 	mov	r4,r21
 4014b40:	e00b883a 	mov	r5,fp
 4014b44:	102b883a 	mov	r21,r2
 4014b48:	40153800 	call	4015380 <__udivsi3>
 4014b4c:	9009883a 	mov	r4,r18
 4014b50:	100b883a 	mov	r5,r2
 4014b54:	102f883a 	mov	r23,r2
 4014b58:	40072d80 	call	40072d8 <__mulsi3>
 4014b5c:	d8c00017 	ldw	r3,0(sp)
 4014b60:	a82a943a 	slli	r21,r21,16
 4014b64:	1cbfffcc 	andi	r18,r3,65535
 4014b68:	aca4b03a 	or	r18,r21,r18
 4014b6c:	9080062e 	bgeu	r18,r2,4014b88 <__udivdi3+0x4dc>
 4014b70:	94e5883a 	add	r18,r18,r19
 4014b74:	b8ffffc4 	addi	r3,r23,-1
 4014b78:	94c04136 	bltu	r18,r19,4014c80 <__udivdi3+0x5d4>
 4014b7c:	9080402e 	bgeu	r18,r2,4014c80 <__udivdi3+0x5d4>
 4014b80:	bdffff84 	addi	r23,r23,-2
 4014b84:	94e5883a 	add	r18,r18,r19
 4014b88:	8020943a 	slli	r16,r16,16
 4014b8c:	bd7fffcc 	andi	r21,r23,65535
 4014b90:	b73fffcc 	andi	fp,r22,65535
 4014b94:	85e0b03a 	or	r16,r16,r23
 4014b98:	8026d43a 	srli	r19,r16,16
 4014b9c:	a809883a 	mov	r4,r21
 4014ba0:	e00b883a 	mov	r5,fp
 4014ba4:	b02cd43a 	srli	r22,r22,16
 4014ba8:	90a5c83a 	sub	r18,r18,r2
 4014bac:	40072d80 	call	40072d8 <__mulsi3>
 4014bb0:	9809883a 	mov	r4,r19
 4014bb4:	e00b883a 	mov	r5,fp
 4014bb8:	102f883a 	mov	r23,r2
 4014bbc:	40072d80 	call	40072d8 <__mulsi3>
 4014bc0:	9809883a 	mov	r4,r19
 4014bc4:	b00b883a 	mov	r5,r22
 4014bc8:	1027883a 	mov	r19,r2
 4014bcc:	40072d80 	call	40072d8 <__mulsi3>
 4014bd0:	a809883a 	mov	r4,r21
 4014bd4:	b00b883a 	mov	r5,r22
 4014bd8:	102b883a 	mov	r21,r2
 4014bdc:	40072d80 	call	40072d8 <__mulsi3>
 4014be0:	b806d43a 	srli	r3,r23,16
 4014be4:	14c5883a 	add	r2,r2,r19
 4014be8:	1887883a 	add	r3,r3,r2
 4014bec:	1cc0022e 	bgeu	r3,r19,4014bf8 <__udivdi3+0x54c>
 4014bf0:	00800074 	movhi	r2,1
 4014bf4:	a8ab883a 	add	r21,r21,r2
 4014bf8:	1804d43a 	srli	r2,r3,16
 4014bfc:	156b883a 	add	r21,r2,r21
 4014c00:	95400936 	bltu	r18,r21,4014c28 <__udivdi3+0x57c>
 4014c04:	95400326 	beq	r18,r21,4014c14 <__udivdi3+0x568>
 4014c08:	8005883a 	mov	r2,r16
 4014c0c:	0007883a 	mov	r3,zero
 4014c10:	003efd06 	br	4014808 <__udivdi3+0x15c>
 4014c14:	1806943a 	slli	r3,r3,16
 4014c18:	a44c983a 	sll	r6,r20,r17
 4014c1c:	bdffffcc 	andi	r23,r23,65535
 4014c20:	1dc7883a 	add	r3,r3,r23
 4014c24:	30fff82e 	bgeu	r6,r3,4014c08 <__udivdi3+0x55c>
 4014c28:	80bfffc4 	addi	r2,r16,-1
 4014c2c:	0007883a 	mov	r3,zero
 4014c30:	003ef506 	br	4014808 <__udivdi3+0x15c>
 4014c34:	3806d43a 	srli	r3,r7,16
 4014c38:	01000404 	movi	r4,16
 4014c3c:	003f0406 	br	4014850 <__udivdi3+0x1a4>
 4014c40:	3007883a 	mov	r3,r6
 4014c44:	003eb206 	br	4014710 <__udivdi3+0x64>
 4014c48:	0007883a 	mov	r3,zero
 4014c4c:	00800044 	movi	r2,1
 4014c50:	003eed06 	br	4014808 <__udivdi3+0x15c>
 4014c54:	3807883a 	mov	r3,r7
 4014c58:	0009883a 	mov	r4,zero
 4014c5c:	003efc06 	br	4014850 <__udivdi3+0x1a4>
 4014c60:	8006d43a 	srli	r3,r16,16
 4014c64:	04400404 	movi	r17,16
 4014c68:	003f0f06 	br	40148a8 <__udivdi3+0x1fc>
 4014c6c:	3006d43a 	srli	r3,r6,16
 4014c70:	04400404 	movi	r17,16
 4014c74:	003ea606 	br	4014710 <__udivdi3+0x64>
 4014c78:	8007883a 	mov	r3,r16
 4014c7c:	003f0a06 	br	40148a8 <__udivdi3+0x1fc>
 4014c80:	182f883a 	mov	r23,r3
 4014c84:	003fc006 	br	4014b88 <__udivdi3+0x4dc>
 4014c88:	1839883a 	mov	fp,r3
 4014c8c:	003f8306 	br	4014a9c <__udivdi3+0x3f0>
 4014c90:	2821883a 	mov	r16,r5
 4014c94:	003fa506 	br	4014b2c <__udivdi3+0x480>
 4014c98:	182f883a 	mov	r23,r3
 4014c9c:	003f6906 	br	4014a44 <__udivdi3+0x398>
 4014ca0:	94bfff84 	addi	r18,r18,-2
 4014ca4:	003f3806 	br	4014988 <__udivdi3+0x2dc>
 4014ca8:	94bfff84 	addi	r18,r18,-2
 4014cac:	003ecf06 	br	40147ec <__udivdi3+0x140>
 4014cb0:	ad7fff84 	addi	r21,r21,-2
 4014cb4:	2409883a 	add	r4,r4,r16
 4014cb8:	003eb706 	br	4014798 <__udivdi3+0xec>
 4014cbc:	ad7fff84 	addi	r21,r21,-2
 4014cc0:	2409883a 	add	r4,r4,r16
 4014cc4:	003f1906 	br	401492c <__udivdi3+0x280>

04014cc8 <__umoddi3>:
 4014cc8:	defff304 	addi	sp,sp,-52
 4014ccc:	dc400415 	stw	r17,16(sp)
 4014cd0:	dc000315 	stw	r16,12(sp)
 4014cd4:	dfc00c15 	stw	ra,48(sp)
 4014cd8:	df000b15 	stw	fp,44(sp)
 4014cdc:	ddc00a15 	stw	r23,40(sp)
 4014ce0:	dd800915 	stw	r22,36(sp)
 4014ce4:	dd400815 	stw	r21,32(sp)
 4014ce8:	dd000715 	stw	r20,28(sp)
 4014cec:	dcc00615 	stw	r19,24(sp)
 4014cf0:	dc800515 	stw	r18,20(sp)
 4014cf4:	2823883a 	mov	r17,r5
 4014cf8:	2021883a 	mov	r16,r4
 4014cfc:	38003b1e 	bne	r7,zero,4014dec <__umoddi3+0x124>
 4014d00:	3825883a 	mov	r18,r7
 4014d04:	3029883a 	mov	r20,r6
 4014d08:	2027883a 	mov	r19,r4
 4014d0c:	29805b2e 	bgeu	r5,r6,4014e7c <__umoddi3+0x1b4>
 4014d10:	00bfffd4 	movui	r2,65535
 4014d14:	282d883a 	mov	r22,r5
 4014d18:	11809a2e 	bgeu	r2,r6,4014f84 <__umoddi3+0x2bc>
 4014d1c:	00804034 	movhi	r2,256
 4014d20:	30814436 	bltu	r6,r2,4015234 <__umoddi3+0x56c>
 4014d24:	3006d63a 	srli	r3,r6,24
 4014d28:	04800604 	movi	r18,24
 4014d2c:	008100b4 	movhi	r2,1026
 4014d30:	1885883a 	add	r2,r3,r2
 4014d34:	112c3803 	ldbu	r4,-20256(r2)
 4014d38:	00800804 	movi	r2,32
 4014d3c:	2489883a 	add	r4,r4,r18
 4014d40:	1125c83a 	sub	r18,r2,r4
 4014d44:	11000526 	beq	r2,r4,4014d5c <__umoddi3+0x94>
 4014d48:	8ca2983a 	sll	r17,r17,r18
 4014d4c:	8108d83a 	srl	r4,r16,r4
 4014d50:	34a8983a 	sll	r20,r6,r18
 4014d54:	84a6983a 	sll	r19,r16,r18
 4014d58:	246cb03a 	or	r22,r4,r17
 4014d5c:	a02ed43a 	srli	r23,r20,16
 4014d60:	b009883a 	mov	r4,r22
 4014d64:	a57fffcc 	andi	r21,r20,65535
 4014d68:	b80b883a 	mov	r5,r23
 4014d6c:	40153e40 	call	40153e4 <__umodsi3>
 4014d70:	b80b883a 	mov	r5,r23
 4014d74:	b009883a 	mov	r4,r22
 4014d78:	1023883a 	mov	r17,r2
 4014d7c:	40153800 	call	4015380 <__udivsi3>
 4014d80:	a809883a 	mov	r4,r21
 4014d84:	100b883a 	mov	r5,r2
 4014d88:	40072d80 	call	40072d8 <__mulsi3>
 4014d8c:	8822943a 	slli	r17,r17,16
 4014d90:	9808d43a 	srli	r4,r19,16
 4014d94:	8908b03a 	or	r4,r17,r4
 4014d98:	2080042e 	bgeu	r4,r2,4014dac <__umoddi3+0xe4>
 4014d9c:	2509883a 	add	r4,r4,r20
 4014da0:	25000236 	bltu	r4,r20,4014dac <__umoddi3+0xe4>
 4014da4:	2080012e 	bgeu	r4,r2,4014dac <__umoddi3+0xe4>
 4014da8:	2509883a 	add	r4,r4,r20
 4014dac:	20a1c83a 	sub	r16,r4,r2
 4014db0:	b80b883a 	mov	r5,r23
 4014db4:	8009883a 	mov	r4,r16
 4014db8:	40153e40 	call	40153e4 <__umodsi3>
 4014dbc:	b80b883a 	mov	r5,r23
 4014dc0:	8009883a 	mov	r4,r16
 4014dc4:	1023883a 	mov	r17,r2
 4014dc8:	40153800 	call	4015380 <__udivsi3>
 4014dcc:	8822943a 	slli	r17,r17,16
 4014dd0:	100b883a 	mov	r5,r2
 4014dd4:	a809883a 	mov	r4,r21
 4014dd8:	40072d80 	call	40072d8 <__mulsi3>
 4014ddc:	98ffffcc 	andi	r3,r19,65535
 4014de0:	88c6b03a 	or	r3,r17,r3
 4014de4:	18805e2e 	bgeu	r3,r2,4014f60 <__umoddi3+0x298>
 4014de8:	00005906 	br	4014f50 <__umoddi3+0x288>
 4014dec:	2005883a 	mov	r2,r4
 4014df0:	29c00d2e 	bgeu	r5,r7,4014e28 <__umoddi3+0x160>
 4014df4:	2807883a 	mov	r3,r5
 4014df8:	dfc00c17 	ldw	ra,48(sp)
 4014dfc:	df000b17 	ldw	fp,44(sp)
 4014e00:	ddc00a17 	ldw	r23,40(sp)
 4014e04:	dd800917 	ldw	r22,36(sp)
 4014e08:	dd400817 	ldw	r21,32(sp)
 4014e0c:	dd000717 	ldw	r20,28(sp)
 4014e10:	dcc00617 	ldw	r19,24(sp)
 4014e14:	dc800517 	ldw	r18,20(sp)
 4014e18:	dc400417 	ldw	r17,16(sp)
 4014e1c:	dc000317 	ldw	r16,12(sp)
 4014e20:	dec00d04 	addi	sp,sp,52
 4014e24:	f800283a 	ret
 4014e28:	013fffd4 	movui	r4,65535
 4014e2c:	2807883a 	mov	r3,r5
 4014e30:	21c0592e 	bgeu	r4,r7,4014f98 <__umoddi3+0x2d0>
 4014e34:	01004034 	movhi	r4,256
 4014e38:	39010336 	bltu	r7,r4,4015248 <__umoddi3+0x580>
 4014e3c:	3808d63a 	srli	r4,r7,24
 4014e40:	02000604 	movi	r8,24
 4014e44:	014100b4 	movhi	r5,1026
 4014e48:	214b883a 	add	r5,r4,r5
 4014e4c:	2d2c3803 	ldbu	r20,-20256(r5)
 4014e50:	01000804 	movi	r4,32
 4014e54:	a229883a 	add	r20,r20,r8
 4014e58:	252bc83a 	sub	r21,r4,r20
 4014e5c:	2500531e 	bne	r4,r20,4014fac <__umoddi3+0x2e4>
 4014e60:	3c400136 	bltu	r7,r17,4014e68 <__umoddi3+0x1a0>
 4014e64:	81bfe436 	bltu	r16,r6,4014df8 <__umoddi3+0x130>
 4014e68:	8185c83a 	sub	r2,r16,r6
 4014e6c:	89cfc83a 	sub	r7,r17,r7
 4014e70:	8087803a 	cmpltu	r3,r16,r2
 4014e74:	38c7c83a 	sub	r3,r7,r3
 4014e78:	003fdf06 	br	4014df8 <__umoddi3+0x130>
 4014e7c:	3000041e 	bne	r6,zero,4014e90 <__umoddi3+0x1c8>
 4014e80:	000b883a 	mov	r5,zero
 4014e84:	01000044 	movi	r4,1
 4014e88:	40153800 	call	4015380 <__udivsi3>
 4014e8c:	1029883a 	mov	r20,r2
 4014e90:	00bfffd4 	movui	r2,65535
 4014e94:	1500362e 	bgeu	r2,r20,4014f70 <__umoddi3+0x2a8>
 4014e98:	00804034 	movhi	r2,256
 4014e9c:	a080ed36 	bltu	r20,r2,4015254 <__umoddi3+0x58c>
 4014ea0:	a006d63a 	srli	r3,r20,24
 4014ea4:	04800604 	movi	r18,24
 4014ea8:	008100b4 	movhi	r2,1026
 4014eac:	1885883a 	add	r2,r3,r2
 4014eb0:	15ac3803 	ldbu	r22,-20256(r2)
 4014eb4:	00800804 	movi	r2,32
 4014eb8:	b4ad883a 	add	r22,r22,r18
 4014ebc:	15a5c83a 	sub	r18,r2,r22
 4014ec0:	1580a51e 	bne	r2,r22,4015158 <__umoddi3+0x490>
 4014ec4:	a02ed43a 	srli	r23,r20,16
 4014ec8:	8d23c83a 	sub	r17,r17,r20
 4014ecc:	a57fffcc 	andi	r21,r20,65535
 4014ed0:	8809883a 	mov	r4,r17
 4014ed4:	b80b883a 	mov	r5,r23
 4014ed8:	40153e40 	call	40153e4 <__umodsi3>
 4014edc:	8809883a 	mov	r4,r17
 4014ee0:	b80b883a 	mov	r5,r23
 4014ee4:	1023883a 	mov	r17,r2
 4014ee8:	40153800 	call	4015380 <__udivsi3>
 4014eec:	1009883a 	mov	r4,r2
 4014ef0:	a80b883a 	mov	r5,r21
 4014ef4:	40072d80 	call	40072d8 <__mulsi3>
 4014ef8:	8822943a 	slli	r17,r17,16
 4014efc:	9808d43a 	srli	r4,r19,16
 4014f00:	8908b03a 	or	r4,r17,r4
 4014f04:	2080032e 	bgeu	r4,r2,4014f14 <__umoddi3+0x24c>
 4014f08:	2509883a 	add	r4,r4,r20
 4014f0c:	25000136 	bltu	r4,r20,4014f14 <__umoddi3+0x24c>
 4014f10:	2080dc36 	bltu	r4,r2,4015284 <__umoddi3+0x5bc>
 4014f14:	20a1c83a 	sub	r16,r4,r2
 4014f18:	b80b883a 	mov	r5,r23
 4014f1c:	8009883a 	mov	r4,r16
 4014f20:	40153e40 	call	40153e4 <__umodsi3>
 4014f24:	b80b883a 	mov	r5,r23
 4014f28:	8009883a 	mov	r4,r16
 4014f2c:	1023883a 	mov	r17,r2
 4014f30:	8822943a 	slli	r17,r17,16
 4014f34:	40153800 	call	4015380 <__udivsi3>
 4014f38:	a80b883a 	mov	r5,r21
 4014f3c:	1009883a 	mov	r4,r2
 4014f40:	40072d80 	call	40072d8 <__mulsi3>
 4014f44:	9cffffcc 	andi	r19,r19,65535
 4014f48:	8cc6b03a 	or	r3,r17,r19
 4014f4c:	1880042e 	bgeu	r3,r2,4014f60 <__umoddi3+0x298>
 4014f50:	1d07883a 	add	r3,r3,r20
 4014f54:	1d000236 	bltu	r3,r20,4014f60 <__umoddi3+0x298>
 4014f58:	1880012e 	bgeu	r3,r2,4014f60 <__umoddi3+0x298>
 4014f5c:	1d07883a 	add	r3,r3,r20
 4014f60:	1885c83a 	sub	r2,r3,r2
 4014f64:	1484d83a 	srl	r2,r2,r18
 4014f68:	0007883a 	mov	r3,zero
 4014f6c:	003fa206 	br	4014df8 <__umoddi3+0x130>
 4014f70:	a0804030 	cmpltui	r2,r20,256
 4014f74:	1000ba1e 	bne	r2,zero,4015260 <__umoddi3+0x598>
 4014f78:	a006d23a 	srli	r3,r20,8
 4014f7c:	04800204 	movi	r18,8
 4014f80:	003fc906 	br	4014ea8 <__umoddi3+0x1e0>
 4014f84:	30804030 	cmpltui	r2,r6,256
 4014f88:	1000ad1e 	bne	r2,zero,4015240 <__umoddi3+0x578>
 4014f8c:	3006d23a 	srli	r3,r6,8
 4014f90:	04800204 	movi	r18,8
 4014f94:	003f6506 	br	4014d2c <__umoddi3+0x64>
 4014f98:	39004030 	cmpltui	r4,r7,256
 4014f9c:	2000b21e 	bne	r4,zero,4015268 <__umoddi3+0x5a0>
 4014fa0:	3808d23a 	srli	r4,r7,8
 4014fa4:	02000204 	movi	r8,8
 4014fa8:	003fa606 	br	4014e44 <__umoddi3+0x17c>
 4014fac:	3d4e983a 	sll	r7,r7,r21
 4014fb0:	3508d83a 	srl	r4,r6,r20
 4014fb4:	8d2cd83a 	srl	r22,r17,r20
 4014fb8:	8504d83a 	srl	r2,r16,r20
 4014fbc:	21e4b03a 	or	r18,r4,r7
 4014fc0:	8d62983a 	sll	r17,r17,r21
 4014fc4:	9026d43a 	srli	r19,r18,16
 4014fc8:	354c983a 	sll	r6,r6,r21
 4014fcc:	1444b03a 	or	r2,r2,r17
 4014fd0:	b009883a 	mov	r4,r22
 4014fd4:	980b883a 	mov	r5,r19
 4014fd8:	d9800115 	stw	r6,4(sp)
 4014fdc:	d8800015 	stw	r2,0(sp)
 4014fe0:	40153e40 	call	40153e4 <__umodsi3>
 4014fe4:	980b883a 	mov	r5,r19
 4014fe8:	b009883a 	mov	r4,r22
 4014fec:	102f883a 	mov	r23,r2
 4014ff0:	947fffcc 	andi	r17,r18,65535
 4014ff4:	40153800 	call	4015380 <__udivsi3>
 4014ff8:	8809883a 	mov	r4,r17
 4014ffc:	100b883a 	mov	r5,r2
 4015000:	1039883a 	mov	fp,r2
 4015004:	40072d80 	call	40072d8 <__mulsi3>
 4015008:	d8c00017 	ldw	r3,0(sp)
 401500c:	b82e943a 	slli	r23,r23,16
 4015010:	8560983a 	sll	r16,r16,r21
 4015014:	1808d43a 	srli	r4,r3,16
 4015018:	b908b03a 	or	r4,r23,r4
 401501c:	2080062e 	bgeu	r4,r2,4015038 <__umoddi3+0x370>
 4015020:	2489883a 	add	r4,r4,r18
 4015024:	e17fffc4 	addi	r5,fp,-1
 4015028:	24809436 	bltu	r4,r18,401527c <__umoddi3+0x5b4>
 401502c:	2080932e 	bgeu	r4,r2,401527c <__umoddi3+0x5b4>
 4015030:	e73fff84 	addi	fp,fp,-2
 4015034:	2489883a 	add	r4,r4,r18
 4015038:	20adc83a 	sub	r22,r4,r2
 401503c:	980b883a 	mov	r5,r19
 4015040:	b009883a 	mov	r4,r22
 4015044:	40153e40 	call	40153e4 <__umodsi3>
 4015048:	980b883a 	mov	r5,r19
 401504c:	b009883a 	mov	r4,r22
 4015050:	102f883a 	mov	r23,r2
 4015054:	40153800 	call	4015380 <__udivsi3>
 4015058:	100b883a 	mov	r5,r2
 401505c:	8809883a 	mov	r4,r17
 4015060:	d8800215 	stw	r2,8(sp)
 4015064:	40072d80 	call	40072d8 <__mulsi3>
 4015068:	d8c00017 	ldw	r3,0(sp)
 401506c:	b82e943a 	slli	r23,r23,16
 4015070:	d9400217 	ldw	r5,8(sp)
 4015074:	1c7fffcc 	andi	r17,r3,65535
 4015078:	bc62b03a 	or	r17,r23,r17
 401507c:	8880062e 	bgeu	r17,r2,4015098 <__umoddi3+0x3d0>
 4015080:	8ca3883a 	add	r17,r17,r18
 4015084:	28ffffc4 	addi	r3,r5,-1
 4015088:	8c807a36 	bltu	r17,r18,4015274 <__umoddi3+0x5ac>
 401508c:	8880792e 	bgeu	r17,r2,4015274 <__umoddi3+0x5ac>
 4015090:	297fff84 	addi	r5,r5,-2
 4015094:	8ca3883a 	add	r17,r17,r18
 4015098:	e02c943a 	slli	r22,fp,16
 401509c:	d9c00117 	ldw	r7,4(sp)
 40150a0:	29bfffcc 	andi	r6,r5,65535
 40150a4:	b16cb03a 	or	r22,r22,r5
 40150a8:	38ffffcc 	andi	r3,r7,65535
 40150ac:	b02cd43a 	srli	r22,r22,16
 40150b0:	180b883a 	mov	r5,r3
 40150b4:	3009883a 	mov	r4,r6
 40150b8:	3838d43a 	srli	fp,r7,16
 40150bc:	182f883a 	mov	r23,r3
 40150c0:	d9800015 	stw	r6,0(sp)
 40150c4:	88a3c83a 	sub	r17,r17,r2
 40150c8:	40072d80 	call	40072d8 <__mulsi3>
 40150cc:	b80b883a 	mov	r5,r23
 40150d0:	b009883a 	mov	r4,r22
 40150d4:	102f883a 	mov	r23,r2
 40150d8:	40072d80 	call	40072d8 <__mulsi3>
 40150dc:	e00b883a 	mov	r5,fp
 40150e0:	b009883a 	mov	r4,r22
 40150e4:	102d883a 	mov	r22,r2
 40150e8:	40072d80 	call	40072d8 <__mulsi3>
 40150ec:	d9800017 	ldw	r6,0(sp)
 40150f0:	e00b883a 	mov	r5,fp
 40150f4:	1039883a 	mov	fp,r2
 40150f8:	3009883a 	mov	r4,r6
 40150fc:	40072d80 	call	40072d8 <__mulsi3>
 4015100:	b808d43a 	srli	r4,r23,16
 4015104:	1585883a 	add	r2,r2,r22
 4015108:	2089883a 	add	r4,r4,r2
 401510c:	2580022e 	bgeu	r4,r22,4015118 <__umoddi3+0x450>
 4015110:	00800074 	movhi	r2,1
 4015114:	e0b9883a 	add	fp,fp,r2
 4015118:	2006d43a 	srli	r3,r4,16
 401511c:	2008943a 	slli	r4,r4,16
 4015120:	bdffffcc 	andi	r23,r23,65535
 4015124:	1f07883a 	add	r3,r3,fp
 4015128:	25c9883a 	add	r4,r4,r23
 401512c:	88c03a36 	bltu	r17,r3,4015218 <__umoddi3+0x550>
 4015130:	88c03826 	beq	r17,r3,4015214 <__umoddi3+0x54c>
 4015134:	8109c83a 	sub	r4,r16,r4
 4015138:	8121803a 	cmpltu	r16,r16,r4
 401513c:	88c7c83a 	sub	r3,r17,r3
 4015140:	1c07c83a 	sub	r3,r3,r16
 4015144:	1d04983a 	sll	r2,r3,r20
 4015148:	2548d83a 	srl	r4,r4,r21
 401514c:	1d46d83a 	srl	r3,r3,r21
 4015150:	1104b03a 	or	r2,r2,r4
 4015154:	003f2806 	br	4014df8 <__umoddi3+0x130>
 4015158:	a4a8983a 	sll	r20,r20,r18
 401515c:	8da6d83a 	srl	r19,r17,r22
 4015160:	8ca2983a 	sll	r17,r17,r18
 4015164:	a02ed43a 	srli	r23,r20,16
 4015168:	9809883a 	mov	r4,r19
 401516c:	85acd83a 	srl	r22,r16,r22
 4015170:	b80b883a 	mov	r5,r23
 4015174:	40153e40 	call	40153e4 <__umodsi3>
 4015178:	9809883a 	mov	r4,r19
 401517c:	b80b883a 	mov	r5,r23
 4015180:	b46cb03a 	or	r22,r22,r17
 4015184:	a57fffcc 	andi	r21,r20,65535
 4015188:	1023883a 	mov	r17,r2
 401518c:	40153800 	call	4015380 <__udivsi3>
 4015190:	a809883a 	mov	r4,r21
 4015194:	100b883a 	mov	r5,r2
 4015198:	40072d80 	call	40072d8 <__mulsi3>
 401519c:	8822943a 	slli	r17,r17,16
 40151a0:	b008d43a 	srli	r4,r22,16
 40151a4:	84a6983a 	sll	r19,r16,r18
 40151a8:	8908b03a 	or	r4,r17,r4
 40151ac:	2080042e 	bgeu	r4,r2,40151c0 <__umoddi3+0x4f8>
 40151b0:	2509883a 	add	r4,r4,r20
 40151b4:	25000236 	bltu	r4,r20,40151c0 <__umoddi3+0x4f8>
 40151b8:	2080012e 	bgeu	r4,r2,40151c0 <__umoddi3+0x4f8>
 40151bc:	2509883a 	add	r4,r4,r20
 40151c0:	20a1c83a 	sub	r16,r4,r2
 40151c4:	8009883a 	mov	r4,r16
 40151c8:	b80b883a 	mov	r5,r23
 40151cc:	40153e40 	call	40153e4 <__umodsi3>
 40151d0:	8009883a 	mov	r4,r16
 40151d4:	1021883a 	mov	r16,r2
 40151d8:	b80b883a 	mov	r5,r23
 40151dc:	8020943a 	slli	r16,r16,16
 40151e0:	40153800 	call	4015380 <__udivsi3>
 40151e4:	100b883a 	mov	r5,r2
 40151e8:	a809883a 	mov	r4,r21
 40151ec:	b47fffcc 	andi	r17,r22,65535
 40151f0:	40072d80 	call	40072d8 <__mulsi3>
 40151f4:	8462b03a 	or	r17,r16,r17
 40151f8:	8880042e 	bgeu	r17,r2,401520c <__umoddi3+0x544>
 40151fc:	8d23883a 	add	r17,r17,r20
 4015200:	8d000236 	bltu	r17,r20,401520c <__umoddi3+0x544>
 4015204:	8880012e 	bgeu	r17,r2,401520c <__umoddi3+0x544>
 4015208:	8d23883a 	add	r17,r17,r20
 401520c:	88a3c83a 	sub	r17,r17,r2
 4015210:	003f2f06 	br	4014ed0 <__umoddi3+0x208>
 4015214:	813fc72e 	bgeu	r16,r4,4015134 <__umoddi3+0x46c>
 4015218:	d8800117 	ldw	r2,4(sp)
 401521c:	20a7c83a 	sub	r19,r4,r2
 4015220:	24c9803a 	cmpltu	r4,r4,r19
 4015224:	2489883a 	add	r4,r4,r18
 4015228:	1907c83a 	sub	r3,r3,r4
 401522c:	9809883a 	mov	r4,r19
 4015230:	003fc006 	br	4015134 <__umoddi3+0x46c>
 4015234:	3006d43a 	srli	r3,r6,16
 4015238:	04800404 	movi	r18,16
 401523c:	003ebb06 	br	4014d2c <__umoddi3+0x64>
 4015240:	3007883a 	mov	r3,r6
 4015244:	003eb906 	br	4014d2c <__umoddi3+0x64>
 4015248:	3808d43a 	srli	r4,r7,16
 401524c:	02000404 	movi	r8,16
 4015250:	003efc06 	br	4014e44 <__umoddi3+0x17c>
 4015254:	a006d43a 	srli	r3,r20,16
 4015258:	04800404 	movi	r18,16
 401525c:	003f1206 	br	4014ea8 <__umoddi3+0x1e0>
 4015260:	a007883a 	mov	r3,r20
 4015264:	003f1006 	br	4014ea8 <__umoddi3+0x1e0>
 4015268:	3809883a 	mov	r4,r7
 401526c:	0011883a 	mov	r8,zero
 4015270:	003ef406 	br	4014e44 <__umoddi3+0x17c>
 4015274:	180b883a 	mov	r5,r3
 4015278:	003f8706 	br	4015098 <__umoddi3+0x3d0>
 401527c:	2839883a 	mov	fp,r5
 4015280:	003f6d06 	br	4015038 <__umoddi3+0x370>
 4015284:	2509883a 	add	r4,r4,r20
 4015288:	003f2206 	br	4014f14 <__umoddi3+0x24c>

0401528c <__divsi3>:
 401528c:	20001a16 	blt	r4,zero,40152f8 <__divsi3+0x6c>
 4015290:	000f883a 	mov	r7,zero
 4015294:	2800020e 	bge	r5,zero,40152a0 <__divsi3+0x14>
 4015298:	014bc83a 	sub	r5,zero,r5
 401529c:	39c0005c 	xori	r7,r7,1
 40152a0:	200d883a 	mov	r6,r4
 40152a4:	00c00044 	movi	r3,1
 40152a8:	2900092e 	bgeu	r5,r4,40152d0 <__divsi3+0x44>
 40152ac:	00800804 	movi	r2,32
 40152b0:	00c00044 	movi	r3,1
 40152b4:	00000106 	br	40152bc <__divsi3+0x30>
 40152b8:	10001226 	beq	r2,zero,4015304 <__divsi3+0x78>
 40152bc:	294b883a 	add	r5,r5,r5
 40152c0:	10bfffc4 	addi	r2,r2,-1
 40152c4:	18c7883a 	add	r3,r3,r3
 40152c8:	293ffb36 	bltu	r5,r4,40152b8 <__divsi3+0x2c>
 40152cc:	18000d26 	beq	r3,zero,4015304 <__divsi3+0x78>
 40152d0:	0005883a 	mov	r2,zero
 40152d4:	31400236 	bltu	r6,r5,40152e0 <__divsi3+0x54>
 40152d8:	314dc83a 	sub	r6,r6,r5
 40152dc:	10c4b03a 	or	r2,r2,r3
 40152e0:	1806d07a 	srli	r3,r3,1
 40152e4:	280ad07a 	srli	r5,r5,1
 40152e8:	183ffa1e 	bne	r3,zero,40152d4 <__divsi3+0x48>
 40152ec:	38000126 	beq	r7,zero,40152f4 <__divsi3+0x68>
 40152f0:	0085c83a 	sub	r2,zero,r2
 40152f4:	f800283a 	ret
 40152f8:	0109c83a 	sub	r4,zero,r4
 40152fc:	01c00044 	movi	r7,1
 4015300:	003fe406 	br	4015294 <__divsi3+0x8>
 4015304:	0005883a 	mov	r2,zero
 4015308:	003ff806 	br	40152ec <__divsi3+0x60>

0401530c <__modsi3>:
 401530c:	20001916 	blt	r4,zero,4015374 <__modsi3+0x68>
 4015310:	000f883a 	mov	r7,zero
 4015314:	2005883a 	mov	r2,r4
 4015318:	2800010e 	bge	r5,zero,4015320 <__modsi3+0x14>
 401531c:	014bc83a 	sub	r5,zero,r5
 4015320:	00c00044 	movi	r3,1
 4015324:	2900092e 	bgeu	r5,r4,401534c <__modsi3+0x40>
 4015328:	01800804 	movi	r6,32
 401532c:	00c00044 	movi	r3,1
 4015330:	00000106 	br	4015338 <__modsi3+0x2c>
 4015334:	30000d26 	beq	r6,zero,401536c <__modsi3+0x60>
 4015338:	294b883a 	add	r5,r5,r5
 401533c:	31bfffc4 	addi	r6,r6,-1
 4015340:	18c7883a 	add	r3,r3,r3
 4015344:	293ffb36 	bltu	r5,r4,4015334 <__modsi3+0x28>
 4015348:	18000826 	beq	r3,zero,401536c <__modsi3+0x60>
 401534c:	1806d07a 	srli	r3,r3,1
 4015350:	11400136 	bltu	r2,r5,4015358 <__modsi3+0x4c>
 4015354:	1145c83a 	sub	r2,r2,r5
 4015358:	280ad07a 	srli	r5,r5,1
 401535c:	183ffb1e 	bne	r3,zero,401534c <__modsi3+0x40>
 4015360:	38000126 	beq	r7,zero,4015368 <__modsi3+0x5c>
 4015364:	0085c83a 	sub	r2,zero,r2
 4015368:	f800283a 	ret
 401536c:	2005883a 	mov	r2,r4
 4015370:	003ffb06 	br	4015360 <__modsi3+0x54>
 4015374:	0109c83a 	sub	r4,zero,r4
 4015378:	01c00044 	movi	r7,1
 401537c:	003fe506 	br	4015314 <__modsi3+0x8>

04015380 <__udivsi3>:
 4015380:	200d883a 	mov	r6,r4
 4015384:	2900152e 	bgeu	r5,r4,40153dc <__udivsi3+0x5c>
 4015388:	28001416 	blt	r5,zero,40153dc <__udivsi3+0x5c>
 401538c:	00800804 	movi	r2,32
 4015390:	00c00044 	movi	r3,1
 4015394:	00000206 	br	40153a0 <__udivsi3+0x20>
 4015398:	10000e26 	beq	r2,zero,40153d4 <__udivsi3+0x54>
 401539c:	28000516 	blt	r5,zero,40153b4 <__udivsi3+0x34>
 40153a0:	294b883a 	add	r5,r5,r5
 40153a4:	10bfffc4 	addi	r2,r2,-1
 40153a8:	18c7883a 	add	r3,r3,r3
 40153ac:	293ffa36 	bltu	r5,r4,4015398 <__udivsi3+0x18>
 40153b0:	18000826 	beq	r3,zero,40153d4 <__udivsi3+0x54>
 40153b4:	0005883a 	mov	r2,zero
 40153b8:	31400236 	bltu	r6,r5,40153c4 <__udivsi3+0x44>
 40153bc:	314dc83a 	sub	r6,r6,r5
 40153c0:	10c4b03a 	or	r2,r2,r3
 40153c4:	1806d07a 	srli	r3,r3,1
 40153c8:	280ad07a 	srli	r5,r5,1
 40153cc:	183ffa1e 	bne	r3,zero,40153b8 <__udivsi3+0x38>
 40153d0:	f800283a 	ret
 40153d4:	0005883a 	mov	r2,zero
 40153d8:	f800283a 	ret
 40153dc:	00c00044 	movi	r3,1
 40153e0:	003ff406 	br	40153b4 <__udivsi3+0x34>

040153e4 <__umodsi3>:
 40153e4:	2005883a 	mov	r2,r4
 40153e8:	2900132e 	bgeu	r5,r4,4015438 <__umodsi3+0x54>
 40153ec:	28001216 	blt	r5,zero,4015438 <__umodsi3+0x54>
 40153f0:	01800804 	movi	r6,32
 40153f4:	00c00044 	movi	r3,1
 40153f8:	00000206 	br	4015404 <__umodsi3+0x20>
 40153fc:	30000c26 	beq	r6,zero,4015430 <__umodsi3+0x4c>
 4015400:	28000516 	blt	r5,zero,4015418 <__umodsi3+0x34>
 4015404:	294b883a 	add	r5,r5,r5
 4015408:	31bfffc4 	addi	r6,r6,-1
 401540c:	18c7883a 	add	r3,r3,r3
 4015410:	293ffa36 	bltu	r5,r4,40153fc <__umodsi3+0x18>
 4015414:	18000626 	beq	r3,zero,4015430 <__umodsi3+0x4c>
 4015418:	1806d07a 	srli	r3,r3,1
 401541c:	11400136 	bltu	r2,r5,4015424 <__umodsi3+0x40>
 4015420:	1145c83a 	sub	r2,r2,r5
 4015424:	280ad07a 	srli	r5,r5,1
 4015428:	183ffb1e 	bne	r3,zero,4015418 <__umodsi3+0x34>
 401542c:	f800283a 	ret
 4015430:	2005883a 	mov	r2,r4
 4015434:	f800283a 	ret
 4015438:	00c00044 	movi	r3,1
 401543c:	003ff606 	br	4015418 <__umodsi3+0x34>

04015440 <__adddf3>:
 4015440:	02000434 	movhi	r8,16
 4015444:	423fffc4 	addi	r8,r8,-1
 4015448:	3a12703a 	and	r9,r7,r8
 401544c:	2a06703a 	and	r3,r5,r8
 4015450:	2818d53a 	srli	r12,r5,20
 4015454:	3804d53a 	srli	r2,r7,20
 4015458:	481490fa 	slli	r10,r9,3
 401545c:	280ad7fa 	srli	r5,r5,31
 4015460:	180690fa 	slli	r3,r3,3
 4015464:	2016d77a 	srli	r11,r4,29
 4015468:	3012d77a 	srli	r9,r6,29
 401546c:	380ed7fa 	srli	r7,r7,31
 4015470:	defffb04 	addi	sp,sp,-20
 4015474:	dc400115 	stw	r17,4(sp)
 4015478:	dc000015 	stw	r16,0(sp)
 401547c:	dfc00415 	stw	ra,16(sp)
 4015480:	dcc00315 	stw	r19,12(sp)
 4015484:	dc800215 	stw	r18,8(sp)
 4015488:	201c90fa 	slli	r14,r4,3
 401548c:	301a90fa 	slli	r13,r6,3
 4015490:	6441ffcc 	andi	r17,r12,2047
 4015494:	2821883a 	mov	r16,r5
 4015498:	58c6b03a 	or	r3,r11,r3
 401549c:	1081ffcc 	andi	r2,r2,2047
 40154a0:	4a92b03a 	or	r9,r9,r10
 40154a4:	29c06326 	beq	r5,r7,4015634 <__adddf3+0x1f4>
 40154a8:	888bc83a 	sub	r5,r17,r2
 40154ac:	0140560e 	bge	zero,r5,4015608 <__adddf3+0x1c8>
 40154b0:	10007526 	beq	r2,zero,4015688 <__adddf3+0x248>
 40154b4:	8881ffd8 	cmpnei	r2,r17,2047
 40154b8:	10012d26 	beq	r2,zero,4015970 <__adddf3+0x530>
 40154bc:	4a402034 	orhi	r9,r9,128
 40154c0:	28800e48 	cmpgei	r2,r5,57
 40154c4:	1000f41e 	bne	r2,zero,4015898 <__adddf3+0x458>
 40154c8:	28800808 	cmpgei	r2,r5,32
 40154cc:	1001471e 	bne	r2,zero,40159ec <__adddf3+0x5ac>
 40154d0:	00800804 	movi	r2,32
 40154d4:	1145c83a 	sub	r2,r2,r5
 40154d8:	6948d83a 	srl	r4,r13,r5
 40154dc:	48a4983a 	sll	r18,r9,r2
 40154e0:	6884983a 	sll	r2,r13,r2
 40154e4:	494ad83a 	srl	r5,r9,r5
 40154e8:	9124b03a 	or	r18,r18,r4
 40154ec:	101ac03a 	cmpne	r13,r2,zero
 40154f0:	9364b03a 	or	r18,r18,r13
 40154f4:	1947c83a 	sub	r3,r3,r5
 40154f8:	74a5c83a 	sub	r18,r14,r18
 40154fc:	7489803a 	cmpltu	r4,r14,r18
 4015500:	1909c83a 	sub	r4,r3,r4
 4015504:	2080202c 	andhi	r2,r4,128
 4015508:	10008626 	beq	r2,zero,4015724 <__adddf3+0x2e4>
 401550c:	00802034 	movhi	r2,128
 4015510:	10bfffc4 	addi	r2,r2,-1
 4015514:	20a6703a 	and	r19,r4,r2
 4015518:	9800d626 	beq	r19,zero,4015874 <__adddf3+0x434>
 401551c:	9809883a 	mov	r4,r19
 4015520:	4017c480 	call	4017c48 <__clzsi2>
 4015524:	133ffe04 	addi	r12,r2,-8
 4015528:	01000804 	movi	r4,32
 401552c:	2309c83a 	sub	r4,r4,r12
 4015530:	9108d83a 	srl	r4,r18,r4
 4015534:	9b04983a 	sll	r2,r19,r12
 4015538:	9324983a 	sll	r18,r18,r12
 401553c:	2088b03a 	or	r4,r4,r2
 4015540:	6440c716 	blt	r12,r17,4015860 <__adddf3+0x420>
 4015544:	6459c83a 	sub	r12,r12,r17
 4015548:	62000044 	addi	r8,r12,1
 401554c:	40800808 	cmpgei	r2,r8,32
 4015550:	1001191e 	bne	r2,zero,40159b8 <__adddf3+0x578>
 4015554:	00800804 	movi	r2,32
 4015558:	1205c83a 	sub	r2,r2,r8
 401555c:	9206d83a 	srl	r3,r18,r8
 4015560:	90a4983a 	sll	r18,r18,r2
 4015564:	2084983a 	sll	r2,r4,r2
 4015568:	2208d83a 	srl	r4,r4,r8
 401556c:	9024c03a 	cmpne	r18,r18,zero
 4015570:	10c4b03a 	or	r2,r2,r3
 4015574:	14a4b03a 	or	r18,r2,r18
 4015578:	0023883a 	mov	r17,zero
 401557c:	908001cc 	andi	r2,r18,7
 4015580:	10000726 	beq	r2,zero,40155a0 <__adddf3+0x160>
 4015584:	908003cc 	andi	r2,r18,15
 4015588:	10800120 	cmpeqi	r2,r2,4
 401558c:	1000041e 	bne	r2,zero,40155a0 <__adddf3+0x160>
 4015590:	90c00104 	addi	r3,r18,4
 4015594:	1ca5803a 	cmpltu	r18,r3,r18
 4015598:	2489883a 	add	r4,r4,r18
 401559c:	1825883a 	mov	r18,r3
 40155a0:	2080202c 	andhi	r2,r4,128
 40155a4:	10006126 	beq	r2,zero,401572c <__adddf3+0x2ec>
 40155a8:	89400044 	addi	r5,r17,1
 40155ac:	2881ffe0 	cmpeqi	r2,r5,2047
 40155b0:	2941ffcc 	andi	r5,r5,2047
 40155b4:	1000731e 	bne	r2,zero,4015784 <__adddf3+0x344>
 40155b8:	023fe034 	movhi	r8,65408
 40155bc:	423fffc4 	addi	r8,r8,-1
 40155c0:	2210703a 	and	r8,r4,r8
 40155c4:	4006927a 	slli	r3,r8,9
 40155c8:	9024d0fa 	srli	r18,r18,3
 40155cc:	4004977a 	slli	r2,r8,29
 40155d0:	1806d33a 	srli	r3,r3,12
 40155d4:	1484b03a 	or	r2,r2,r18
 40155d8:	280a953a 	slli	r5,r5,20
 40155dc:	84003fcc 	andi	r16,r16,255
 40155e0:	802097fa 	slli	r16,r16,31
 40155e4:	28c6b03a 	or	r3,r5,r3
 40155e8:	1c06b03a 	or	r3,r3,r16
 40155ec:	dfc00417 	ldw	ra,16(sp)
 40155f0:	dcc00317 	ldw	r19,12(sp)
 40155f4:	dc800217 	ldw	r18,8(sp)
 40155f8:	dc400117 	ldw	r17,4(sp)
 40155fc:	dc000017 	ldw	r16,0(sp)
 4015600:	dec00504 	addi	sp,sp,20
 4015604:	f800283a 	ret
 4015608:	28002726 	beq	r5,zero,40156a8 <__adddf3+0x268>
 401560c:	144bc83a 	sub	r5,r2,r17
 4015610:	8800be1e 	bne	r17,zero,401590c <__adddf3+0x4cc>
 4015614:	1b88b03a 	or	r4,r3,r14
 4015618:	20013126 	beq	r4,zero,4015ae0 <__adddf3+0x6a0>
 401561c:	293fffc4 	addi	r4,r5,-1
 4015620:	20017226 	beq	r4,zero,4015bec <__adddf3+0x7ac>
 4015624:	2941ffd8 	cmpnei	r5,r5,2047
 4015628:	2801c226 	beq	r5,zero,4015d34 <__adddf3+0x8f4>
 401562c:	200b883a 	mov	r5,r4
 4015630:	0000b906 	br	4015918 <__adddf3+0x4d8>
 4015634:	888bc83a 	sub	r5,r17,r2
 4015638:	0140700e 	bge	zero,r5,40157fc <__adddf3+0x3bc>
 401563c:	10002a26 	beq	r2,zero,40156e8 <__adddf3+0x2a8>
 4015640:	8881ffd8 	cmpnei	r2,r17,2047
 4015644:	1000ca26 	beq	r2,zero,4015970 <__adddf3+0x530>
 4015648:	4a402034 	orhi	r9,r9,128
 401564c:	28800e48 	cmpgei	r2,r5,57
 4015650:	1000421e 	bne	r2,zero,401575c <__adddf3+0x31c>
 4015654:	28800808 	cmpgei	r2,r5,32
 4015658:	1000ff26 	beq	r2,zero,4015a58 <__adddf3+0x618>
 401565c:	2cbff804 	addi	r18,r5,-32
 4015660:	29000820 	cmpeqi	r4,r5,32
 4015664:	4c84d83a 	srl	r2,r9,r18
 4015668:	2000041e 	bne	r4,zero,401567c <__adddf3+0x23c>
 401566c:	01001004 	movi	r4,64
 4015670:	214bc83a 	sub	r5,r4,r5
 4015674:	4952983a 	sll	r9,r9,r5
 4015678:	6a5ab03a 	or	r13,r13,r9
 401567c:	6824c03a 	cmpne	r18,r13,zero
 4015680:	90a4b03a 	or	r18,r18,r2
 4015684:	00003706 	br	4015764 <__adddf3+0x324>
 4015688:	4b44b03a 	or	r2,r9,r13
 401568c:	1000b126 	beq	r2,zero,4015954 <__adddf3+0x514>
 4015690:	28bfffc4 	addi	r2,r5,-1
 4015694:	10011a26 	beq	r2,zero,4015b00 <__adddf3+0x6c0>
 4015698:	2941ffd8 	cmpnei	r5,r5,2047
 401569c:	28012526 	beq	r5,zero,4015b34 <__adddf3+0x6f4>
 40156a0:	100b883a 	mov	r5,r2
 40156a4:	003f8606 	br	40154c0 <__adddf3+0x80>
 40156a8:	8a800044 	addi	r10,r17,1
 40156ac:	5281ff8c 	andi	r10,r10,2046
 40156b0:	50008b1e 	bne	r10,zero,40158e0 <__adddf3+0x4a0>
 40156b4:	1b96b03a 	or	r11,r3,r14
 40156b8:	4b44b03a 	or	r2,r9,r13
 40156bc:	8801031e 	bne	r17,zero,4015acc <__adddf3+0x68c>
 40156c0:	58014126 	beq	r11,zero,4015bc8 <__adddf3+0x788>
 40156c4:	1001571e 	bne	r2,zero,4015c24 <__adddf3+0x7e4>
 40156c8:	1804977a 	slli	r2,r3,29
 40156cc:	01480034 	movhi	r5,8192
 40156d0:	297fffc4 	addi	r5,r5,-1
 40156d4:	2148703a 	and	r4,r4,r5
 40156d8:	1810d0fa 	srli	r8,r3,3
 40156dc:	1104b03a 	or	r2,r2,r4
 40156e0:	500b883a 	mov	r5,r10
 40156e4:	00001806 	br	4015748 <__adddf3+0x308>
 40156e8:	4b44b03a 	or	r2,r9,r13
 40156ec:	10010a26 	beq	r2,zero,4015b18 <__adddf3+0x6d8>
 40156f0:	28bfffc4 	addi	r2,r5,-1
 40156f4:	10000426 	beq	r2,zero,4015708 <__adddf3+0x2c8>
 40156f8:	2941ffd8 	cmpnei	r5,r5,2047
 40156fc:	28014226 	beq	r5,zero,4015c08 <__adddf3+0x7c8>
 4015700:	100b883a 	mov	r5,r2
 4015704:	003fd106 	br	401564c <__adddf3+0x20c>
 4015708:	7365883a 	add	r18,r14,r13
 401570c:	1a47883a 	add	r3,r3,r9
 4015710:	9389803a 	cmpltu	r4,r18,r14
 4015714:	1909883a 	add	r4,r3,r4
 4015718:	2080202c 	andhi	r2,r4,128
 401571c:	10009b1e 	bne	r2,zero,401598c <__adddf3+0x54c>
 4015720:	04400044 	movi	r17,1
 4015724:	908001cc 	andi	r2,r18,7
 4015728:	103f961e 	bne	r2,zero,4015584 <__adddf3+0x144>
 401572c:	9024d0fa 	srli	r18,r18,3
 4015730:	2004977a 	slli	r2,r4,29
 4015734:	2010d0fa 	srli	r8,r4,3
 4015738:	880b883a 	mov	r5,r17
 401573c:	9084b03a 	or	r2,r18,r2
 4015740:	28c1ffe0 	cmpeqi	r3,r5,2047
 4015744:	1800251e 	bne	r3,zero,40157dc <__adddf3+0x39c>
 4015748:	00c00434 	movhi	r3,16
 401574c:	18ffffc4 	addi	r3,r3,-1
 4015750:	40c6703a 	and	r3,r8,r3
 4015754:	2941ffcc 	andi	r5,r5,2047
 4015758:	003f9f06 	br	40155d8 <__adddf3+0x198>
 401575c:	4b64b03a 	or	r18,r9,r13
 4015760:	9024c03a 	cmpne	r18,r18,zero
 4015764:	93a5883a 	add	r18,r18,r14
 4015768:	9389803a 	cmpltu	r4,r18,r14
 401576c:	20c9883a 	add	r4,r4,r3
 4015770:	2080202c 	andhi	r2,r4,128
 4015774:	103feb26 	beq	r2,zero,4015724 <__adddf3+0x2e4>
 4015778:	8c400044 	addi	r17,r17,1
 401577c:	8881ffe0 	cmpeqi	r2,r17,2047
 4015780:	10008326 	beq	r2,zero,4015990 <__adddf3+0x550>
 4015784:	0141ffc4 	movi	r5,2047
 4015788:	0007883a 	mov	r3,zero
 401578c:	0005883a 	mov	r2,zero
 4015790:	003f9106 	br	40155d8 <__adddf3+0x198>
 4015794:	4b44b03a 	or	r2,r9,r13
 4015798:	180a977a 	slli	r5,r3,29
 401579c:	1810d0fa 	srli	r8,r3,3
 40157a0:	10016c26 	beq	r2,zero,4015d54 <__adddf3+0x914>
 40157a4:	00c80034 	movhi	r3,8192
 40157a8:	18ffffc4 	addi	r3,r3,-1
 40157ac:	20c4703a 	and	r2,r4,r3
 40157b0:	4100022c 	andhi	r4,r8,8
 40157b4:	1144b03a 	or	r2,r2,r5
 40157b8:	20000826 	beq	r4,zero,40157dc <__adddf3+0x39c>
 40157bc:	4808d0fa 	srli	r4,r9,3
 40157c0:	2140022c 	andhi	r5,r4,8
 40157c4:	2800051e 	bne	r5,zero,40157dc <__adddf3+0x39c>
 40157c8:	4804977a 	slli	r2,r9,29
 40157cc:	30cc703a 	and	r6,r6,r3
 40157d0:	3821883a 	mov	r16,r7
 40157d4:	3084b03a 	or	r2,r6,r2
 40157d8:	2011883a 	mov	r8,r4
 40157dc:	4086b03a 	or	r3,r8,r2
 40157e0:	18017126 	beq	r3,zero,4015da8 <__adddf3+0x968>
 40157e4:	01000434 	movhi	r4,16
 40157e8:	40c00234 	orhi	r3,r8,8
 40157ec:	213fffc4 	addi	r4,r4,-1
 40157f0:	1906703a 	and	r3,r3,r4
 40157f4:	0141ffc4 	movi	r5,2047
 40157f8:	003f7706 	br	40155d8 <__adddf3+0x198>
 40157fc:	28002926 	beq	r5,zero,40158a4 <__adddf3+0x464>
 4015800:	144bc83a 	sub	r5,r2,r17
 4015804:	88008c26 	beq	r17,zero,4015a38 <__adddf3+0x5f8>
 4015808:	1101ffd8 	cmpnei	r4,r2,2047
 401580c:	20011126 	beq	r4,zero,4015c54 <__adddf3+0x814>
 4015810:	18c02034 	orhi	r3,r3,128
 4015814:	29000e48 	cmpgei	r4,r5,57
 4015818:	2000d51e 	bne	r4,zero,4015b70 <__adddf3+0x730>
 401581c:	29000808 	cmpgei	r4,r5,32
 4015820:	2001511e 	bne	r4,zero,4015d68 <__adddf3+0x928>
 4015824:	01000804 	movi	r4,32
 4015828:	2149c83a 	sub	r4,r4,r5
 401582c:	1924983a 	sll	r18,r3,r4
 4015830:	714cd83a 	srl	r6,r14,r5
 4015834:	7108983a 	sll	r4,r14,r4
 4015838:	194ad83a 	srl	r5,r3,r5
 401583c:	91a4b03a 	or	r18,r18,r6
 4015840:	2006c03a 	cmpne	r3,r4,zero
 4015844:	90e4b03a 	or	r18,r18,r3
 4015848:	4953883a 	add	r9,r9,r5
 401584c:	9365883a 	add	r18,r18,r13
 4015850:	9349803a 	cmpltu	r4,r18,r13
 4015854:	2249883a 	add	r4,r4,r9
 4015858:	1023883a 	mov	r17,r2
 401585c:	003fc406 	br	4015770 <__adddf3+0x330>
 4015860:	023fe034 	movhi	r8,65408
 4015864:	423fffc4 	addi	r8,r8,-1
 4015868:	8b23c83a 	sub	r17,r17,r12
 401586c:	2208703a 	and	r4,r4,r8
 4015870:	003f4206 	br	401557c <__adddf3+0x13c>
 4015874:	9009883a 	mov	r4,r18
 4015878:	4017c480 	call	4017c48 <__clzsi2>
 401587c:	13000604 	addi	r12,r2,24
 4015880:	60c00808 	cmpgei	r3,r12,32
 4015884:	183f2826 	beq	r3,zero,4015528 <__adddf3+0xe8>
 4015888:	113ffe04 	addi	r4,r2,-8
 401588c:	9108983a 	sll	r4,r18,r4
 4015890:	0025883a 	mov	r18,zero
 4015894:	003f2a06 	br	4015540 <__adddf3+0x100>
 4015898:	4b64b03a 	or	r18,r9,r13
 401589c:	9024c03a 	cmpne	r18,r18,zero
 40158a0:	003f1506 	br	40154f8 <__adddf3+0xb8>
 40158a4:	8a000044 	addi	r8,r17,1
 40158a8:	4081ff8c 	andi	r2,r8,2046
 40158ac:	1000751e 	bne	r2,zero,4015a84 <__adddf3+0x644>
 40158b0:	1b84b03a 	or	r2,r3,r14
 40158b4:	8800bc1e 	bne	r17,zero,4015ba8 <__adddf3+0x768>
 40158b8:	10010c26 	beq	r2,zero,4015cec <__adddf3+0x8ac>
 40158bc:	4b44b03a 	or	r2,r9,r13
 40158c0:	1001111e 	bne	r2,zero,4015d08 <__adddf3+0x8c8>
 40158c4:	180c977a 	slli	r6,r3,29
 40158c8:	00880034 	movhi	r2,8192
 40158cc:	10bfffc4 	addi	r2,r2,-1
 40158d0:	2084703a 	and	r2,r4,r2
 40158d4:	1810d0fa 	srli	r8,r3,3
 40158d8:	1184b03a 	or	r2,r2,r6
 40158dc:	003f9a06 	br	4015748 <__adddf3+0x308>
 40158e0:	7365c83a 	sub	r18,r14,r13
 40158e4:	1a67c83a 	sub	r19,r3,r9
 40158e8:	7489803a 	cmpltu	r4,r14,r18
 40158ec:	9927c83a 	sub	r19,r19,r4
 40158f0:	9880202c 	andhi	r2,r19,128
 40158f4:	10006f1e 	bne	r2,zero,4015ab4 <__adddf3+0x674>
 40158f8:	94c4b03a 	or	r2,r18,r19
 40158fc:	103f061e 	bne	r2,zero,4015518 <__adddf3+0xd8>
 4015900:	0011883a 	mov	r8,zero
 4015904:	0021883a 	mov	r16,zero
 4015908:	003f8f06 	br	4015748 <__adddf3+0x308>
 401590c:	1101ffd8 	cmpnei	r4,r2,2047
 4015910:	20008f26 	beq	r4,zero,4015b50 <__adddf3+0x710>
 4015914:	18c02034 	orhi	r3,r3,128
 4015918:	29000e48 	cmpgei	r4,r5,57
 401591c:	20003e1e 	bne	r4,zero,4015a18 <__adddf3+0x5d8>
 4015920:	29000808 	cmpgei	r4,r5,32
 4015924:	2000951e 	bne	r4,zero,4015b7c <__adddf3+0x73c>
 4015928:	01000804 	movi	r4,32
 401592c:	2149c83a 	sub	r4,r4,r5
 4015930:	1924983a 	sll	r18,r3,r4
 4015934:	714cd83a 	srl	r6,r14,r5
 4015938:	711c983a 	sll	r14,r14,r4
 401593c:	1946d83a 	srl	r3,r3,r5
 4015940:	91a4b03a 	or	r18,r18,r6
 4015944:	701cc03a 	cmpne	r14,r14,zero
 4015948:	93a4b03a 	or	r18,r18,r14
 401594c:	48d3c83a 	sub	r9,r9,r3
 4015950:	00003306 	br	4015a20 <__adddf3+0x5e0>
 4015954:	1824977a 	slli	r18,r3,29
 4015958:	01880034 	movhi	r6,8192
 401595c:	31bfffc4 	addi	r6,r6,-1
 4015960:	2184703a 	and	r2,r4,r6
 4015964:	1810d0fa 	srli	r8,r3,3
 4015968:	1484b03a 	or	r2,r2,r18
 401596c:	003f7406 	br	4015740 <__adddf3+0x300>
 4015970:	1804977a 	slli	r2,r3,29
 4015974:	01480034 	movhi	r5,8192
 4015978:	297fffc4 	addi	r5,r5,-1
 401597c:	2148703a 	and	r4,r4,r5
 4015980:	1810d0fa 	srli	r8,r3,3
 4015984:	1104b03a 	or	r2,r2,r4
 4015988:	003f9406 	br	40157dc <__adddf3+0x39c>
 401598c:	04400084 	movi	r17,2
 4015990:	00bfe034 	movhi	r2,65408
 4015994:	10bfffc4 	addi	r2,r2,-1
 4015998:	9006d07a 	srli	r3,r18,1
 401599c:	2088703a 	and	r4,r4,r2
 40159a0:	200497fa 	slli	r2,r4,31
 40159a4:	9480004c 	andi	r18,r18,1
 40159a8:	1ca4b03a 	or	r18,r3,r18
 40159ac:	2008d07a 	srli	r4,r4,1
 40159b0:	14a4b03a 	or	r18,r2,r18
 40159b4:	003ef106 	br	401557c <__adddf3+0x13c>
 40159b8:	633ff844 	addi	r12,r12,-31
 40159bc:	40800820 	cmpeqi	r2,r8,32
 40159c0:	2318d83a 	srl	r12,r4,r12
 40159c4:	1000041e 	bne	r2,zero,40159d8 <__adddf3+0x598>
 40159c8:	00801004 	movi	r2,64
 40159cc:	1211c83a 	sub	r8,r2,r8
 40159d0:	2208983a 	sll	r4,r4,r8
 40159d4:	9124b03a 	or	r18,r18,r4
 40159d8:	9024c03a 	cmpne	r18,r18,zero
 40159dc:	9324b03a 	or	r18,r18,r12
 40159e0:	0009883a 	mov	r4,zero
 40159e4:	0023883a 	mov	r17,zero
 40159e8:	003f4e06 	br	4015724 <__adddf3+0x2e4>
 40159ec:	2cbff804 	addi	r18,r5,-32
 40159f0:	29000820 	cmpeqi	r4,r5,32
 40159f4:	4c84d83a 	srl	r2,r9,r18
 40159f8:	2000041e 	bne	r4,zero,4015a0c <__adddf3+0x5cc>
 40159fc:	01001004 	movi	r4,64
 4015a00:	214bc83a 	sub	r5,r4,r5
 4015a04:	4952983a 	sll	r9,r9,r5
 4015a08:	6a5ab03a 	or	r13,r13,r9
 4015a0c:	6824c03a 	cmpne	r18,r13,zero
 4015a10:	90a4b03a 	or	r18,r18,r2
 4015a14:	003eb806 	br	40154f8 <__adddf3+0xb8>
 4015a18:	1b88b03a 	or	r4,r3,r14
 4015a1c:	2024c03a 	cmpne	r18,r4,zero
 4015a20:	6ca5c83a 	sub	r18,r13,r18
 4015a24:	6c89803a 	cmpltu	r4,r13,r18
 4015a28:	4909c83a 	sub	r4,r9,r4
 4015a2c:	3821883a 	mov	r16,r7
 4015a30:	1023883a 	mov	r17,r2
 4015a34:	003eb306 	br	4015504 <__adddf3+0xc4>
 4015a38:	1b88b03a 	or	r4,r3,r14
 4015a3c:	20008c26 	beq	r4,zero,4015c70 <__adddf3+0x830>
 4015a40:	293fffc4 	addi	r4,r5,-1
 4015a44:	2000d326 	beq	r4,zero,4015d94 <__adddf3+0x954>
 4015a48:	2941ffd8 	cmpnei	r5,r5,2047
 4015a4c:	28008126 	beq	r5,zero,4015c54 <__adddf3+0x814>
 4015a50:	200b883a 	mov	r5,r4
 4015a54:	003f6f06 	br	4015814 <__adddf3+0x3d4>
 4015a58:	00800804 	movi	r2,32
 4015a5c:	1145c83a 	sub	r2,r2,r5
 4015a60:	6948d83a 	srl	r4,r13,r5
 4015a64:	48a4983a 	sll	r18,r9,r2
 4015a68:	6884983a 	sll	r2,r13,r2
 4015a6c:	494ad83a 	srl	r5,r9,r5
 4015a70:	9124b03a 	or	r18,r18,r4
 4015a74:	101ac03a 	cmpne	r13,r2,zero
 4015a78:	9364b03a 	or	r18,r18,r13
 4015a7c:	1947883a 	add	r3,r3,r5
 4015a80:	003f3806 	br	4015764 <__adddf3+0x324>
 4015a84:	4081ffe0 	cmpeqi	r2,r8,2047
 4015a88:	103f3e1e 	bne	r2,zero,4015784 <__adddf3+0x344>
 4015a8c:	7345883a 	add	r2,r14,r13
 4015a90:	139d803a 	cmpltu	r14,r2,r14
 4015a94:	1a49883a 	add	r4,r3,r9
 4015a98:	2389883a 	add	r4,r4,r14
 4015a9c:	202497fa 	slli	r18,r4,31
 4015aa0:	1004d07a 	srli	r2,r2,1
 4015aa4:	2008d07a 	srli	r4,r4,1
 4015aa8:	4023883a 	mov	r17,r8
 4015aac:	90a4b03a 	or	r18,r18,r2
 4015ab0:	003f1c06 	br	4015724 <__adddf3+0x2e4>
 4015ab4:	6ba5c83a 	sub	r18,r13,r14
 4015ab8:	48c9c83a 	sub	r4,r9,r3
 4015abc:	6c85803a 	cmpltu	r2,r13,r18
 4015ac0:	20a7c83a 	sub	r19,r4,r2
 4015ac4:	3821883a 	mov	r16,r7
 4015ac8:	003e9306 	br	4015518 <__adddf3+0xd8>
 4015acc:	58006f1e 	bne	r11,zero,4015c8c <__adddf3+0x84c>
 4015ad0:	10001f1e 	bne	r2,zero,4015b50 <__adddf3+0x710>
 4015ad4:	00bfffc4 	movi	r2,-1
 4015ad8:	0021883a 	mov	r16,zero
 4015adc:	003f4106 	br	40157e4 <__adddf3+0x3a4>
 4015ae0:	4808977a 	slli	r4,r9,29
 4015ae4:	00c80034 	movhi	r3,8192
 4015ae8:	18ffffc4 	addi	r3,r3,-1
 4015aec:	30c4703a 	and	r2,r6,r3
 4015af0:	4810d0fa 	srli	r8,r9,3
 4015af4:	1104b03a 	or	r2,r2,r4
 4015af8:	3821883a 	mov	r16,r7
 4015afc:	003f1006 	br	4015740 <__adddf3+0x300>
 4015b00:	7365c83a 	sub	r18,r14,r13
 4015b04:	1a47c83a 	sub	r3,r3,r9
 4015b08:	7489803a 	cmpltu	r4,r14,r18
 4015b0c:	1909c83a 	sub	r4,r3,r4
 4015b10:	04400044 	movi	r17,1
 4015b14:	003e7b06 	br	4015504 <__adddf3+0xc4>
 4015b18:	1824977a 	slli	r18,r3,29
 4015b1c:	01c80034 	movhi	r7,8192
 4015b20:	39ffffc4 	addi	r7,r7,-1
 4015b24:	21c4703a 	and	r2,r4,r7
 4015b28:	1810d0fa 	srli	r8,r3,3
 4015b2c:	1484b03a 	or	r2,r2,r18
 4015b30:	003f0306 	br	4015740 <__adddf3+0x300>
 4015b34:	1824977a 	slli	r18,r3,29
 4015b38:	01480034 	movhi	r5,8192
 4015b3c:	297fffc4 	addi	r5,r5,-1
 4015b40:	2144703a 	and	r2,r4,r5
 4015b44:	1810d0fa 	srli	r8,r3,3
 4015b48:	1484b03a 	or	r2,r2,r18
 4015b4c:	003f2306 	br	40157dc <__adddf3+0x39c>
 4015b50:	4806977a 	slli	r3,r9,29
 4015b54:	00880034 	movhi	r2,8192
 4015b58:	10bfffc4 	addi	r2,r2,-1
 4015b5c:	3084703a 	and	r2,r6,r2
 4015b60:	4810d0fa 	srli	r8,r9,3
 4015b64:	10c4b03a 	or	r2,r2,r3
 4015b68:	3821883a 	mov	r16,r7
 4015b6c:	003f1b06 	br	40157dc <__adddf3+0x39c>
 4015b70:	1b88b03a 	or	r4,r3,r14
 4015b74:	2024c03a 	cmpne	r18,r4,zero
 4015b78:	003f3406 	br	401584c <__adddf3+0x40c>
 4015b7c:	2cbff804 	addi	r18,r5,-32
 4015b80:	29800820 	cmpeqi	r6,r5,32
 4015b84:	1c88d83a 	srl	r4,r3,r18
 4015b88:	3000041e 	bne	r6,zero,4015b9c <__adddf3+0x75c>
 4015b8c:	01801004 	movi	r6,64
 4015b90:	314bc83a 	sub	r5,r6,r5
 4015b94:	1946983a 	sll	r3,r3,r5
 4015b98:	70dcb03a 	or	r14,r14,r3
 4015b9c:	7024c03a 	cmpne	r18,r14,zero
 4015ba0:	9124b03a 	or	r18,r18,r4
 4015ba4:	003f9e06 	br	4015a20 <__adddf3+0x5e0>
 4015ba8:	103efa1e 	bne	r2,zero,4015794 <__adddf3+0x354>
 4015bac:	4804977a 	slli	r2,r9,29
 4015bb0:	00c80034 	movhi	r3,8192
 4015bb4:	18ffffc4 	addi	r3,r3,-1
 4015bb8:	30cc703a 	and	r6,r6,r3
 4015bbc:	4810d0fa 	srli	r8,r9,3
 4015bc0:	1184b03a 	or	r2,r2,r6
 4015bc4:	003f0506 	br	40157dc <__adddf3+0x39c>
 4015bc8:	10004426 	beq	r2,zero,4015cdc <__adddf3+0x89c>
 4015bcc:	4806977a 	slli	r3,r9,29
 4015bd0:	00880034 	movhi	r2,8192
 4015bd4:	10bfffc4 	addi	r2,r2,-1
 4015bd8:	3084703a 	and	r2,r6,r2
 4015bdc:	4810d0fa 	srli	r8,r9,3
 4015be0:	10c4b03a 	or	r2,r2,r3
 4015be4:	3821883a 	mov	r16,r7
 4015be8:	003ed706 	br	4015748 <__adddf3+0x308>
 4015bec:	6ba5c83a 	sub	r18,r13,r14
 4015bf0:	48c7c83a 	sub	r3,r9,r3
 4015bf4:	6c85803a 	cmpltu	r2,r13,r18
 4015bf8:	1889c83a 	sub	r4,r3,r2
 4015bfc:	3821883a 	mov	r16,r7
 4015c00:	04400044 	movi	r17,1
 4015c04:	003e3f06 	br	4015504 <__adddf3+0xc4>
 4015c08:	180a977a 	slli	r5,r3,29
 4015c0c:	00880034 	movhi	r2,8192
 4015c10:	10bfffc4 	addi	r2,r2,-1
 4015c14:	2084703a 	and	r2,r4,r2
 4015c18:	1810d0fa 	srli	r8,r3,3
 4015c1c:	1144b03a 	or	r2,r2,r5
 4015c20:	003eee06 	br	40157dc <__adddf3+0x39c>
 4015c24:	7365c83a 	sub	r18,r14,r13
 4015c28:	7485803a 	cmpltu	r2,r14,r18
 4015c2c:	1a49c83a 	sub	r4,r3,r9
 4015c30:	2089c83a 	sub	r4,r4,r2
 4015c34:	2080202c 	andhi	r2,r4,128
 4015c38:	10002626 	beq	r2,zero,4015cd4 <__adddf3+0x894>
 4015c3c:	6ba5c83a 	sub	r18,r13,r14
 4015c40:	48c7c83a 	sub	r3,r9,r3
 4015c44:	6c85803a 	cmpltu	r2,r13,r18
 4015c48:	1889c83a 	sub	r4,r3,r2
 4015c4c:	3821883a 	mov	r16,r7
 4015c50:	003e4a06 	br	401557c <__adddf3+0x13c>
 4015c54:	4806977a 	slli	r3,r9,29
 4015c58:	00880034 	movhi	r2,8192
 4015c5c:	10bfffc4 	addi	r2,r2,-1
 4015c60:	3084703a 	and	r2,r6,r2
 4015c64:	4810d0fa 	srli	r8,r9,3
 4015c68:	10c4b03a 	or	r2,r2,r3
 4015c6c:	003edb06 	br	40157dc <__adddf3+0x39c>
 4015c70:	4806977a 	slli	r3,r9,29
 4015c74:	00880034 	movhi	r2,8192
 4015c78:	10bfffc4 	addi	r2,r2,-1
 4015c7c:	3084703a 	and	r2,r6,r2
 4015c80:	4810d0fa 	srli	r8,r9,3
 4015c84:	10c4b03a 	or	r2,r2,r3
 4015c88:	003ead06 	br	4015740 <__adddf3+0x300>
 4015c8c:	180a977a 	slli	r5,r3,29
 4015c90:	1810d0fa 	srli	r8,r3,3
 4015c94:	10002f26 	beq	r2,zero,4015d54 <__adddf3+0x914>
 4015c98:	00c80034 	movhi	r3,8192
 4015c9c:	18ffffc4 	addi	r3,r3,-1
 4015ca0:	20c4703a 	and	r2,r4,r3
 4015ca4:	4100022c 	andhi	r4,r8,8
 4015ca8:	1144b03a 	or	r2,r2,r5
 4015cac:	203ecb26 	beq	r4,zero,40157dc <__adddf3+0x39c>
 4015cb0:	4808d0fa 	srli	r4,r9,3
 4015cb4:	2140022c 	andhi	r5,r4,8
 4015cb8:	283ec81e 	bne	r5,zero,40157dc <__adddf3+0x39c>
 4015cbc:	4812977a 	slli	r9,r9,29
 4015cc0:	30c4703a 	and	r2,r6,r3
 4015cc4:	3821883a 	mov	r16,r7
 4015cc8:	1244b03a 	or	r2,r2,r9
 4015ccc:	2011883a 	mov	r8,r4
 4015cd0:	003ec206 	br	40157dc <__adddf3+0x39c>
 4015cd4:	9104b03a 	or	r2,r18,r4
 4015cd8:	103e921e 	bne	r2,zero,4015724 <__adddf3+0x2e4>
 4015cdc:	0011883a 	mov	r8,zero
 4015ce0:	100b883a 	mov	r5,r2
 4015ce4:	0021883a 	mov	r16,zero
 4015ce8:	003e9706 	br	4015748 <__adddf3+0x308>
 4015cec:	4804977a 	slli	r2,r9,29
 4015cf0:	00c80034 	movhi	r3,8192
 4015cf4:	18ffffc4 	addi	r3,r3,-1
 4015cf8:	30cc703a 	and	r6,r6,r3
 4015cfc:	4810d0fa 	srli	r8,r9,3
 4015d00:	1184b03a 	or	r2,r2,r6
 4015d04:	003e9006 	br	4015748 <__adddf3+0x308>
 4015d08:	7365883a 	add	r18,r14,r13
 4015d0c:	1a47883a 	add	r3,r3,r9
 4015d10:	9389803a 	cmpltu	r4,r18,r14
 4015d14:	1909883a 	add	r4,r3,r4
 4015d18:	2080202c 	andhi	r2,r4,128
 4015d1c:	103e8126 	beq	r2,zero,4015724 <__adddf3+0x2e4>
 4015d20:	00bfe034 	movhi	r2,65408
 4015d24:	10bfffc4 	addi	r2,r2,-1
 4015d28:	2088703a 	and	r4,r4,r2
 4015d2c:	04400044 	movi	r17,1
 4015d30:	003e7c06 	br	4015724 <__adddf3+0x2e4>
 4015d34:	4804977a 	slli	r2,r9,29
 4015d38:	00c80034 	movhi	r3,8192
 4015d3c:	18ffffc4 	addi	r3,r3,-1
 4015d40:	30cc703a 	and	r6,r6,r3
 4015d44:	4810d0fa 	srli	r8,r9,3
 4015d48:	1184b03a 	or	r2,r2,r6
 4015d4c:	3821883a 	mov	r16,r7
 4015d50:	003ea206 	br	40157dc <__adddf3+0x39c>
 4015d54:	00880034 	movhi	r2,8192
 4015d58:	10bfffc4 	addi	r2,r2,-1
 4015d5c:	2084703a 	and	r2,r4,r2
 4015d60:	1144b03a 	or	r2,r2,r5
 4015d64:	003e9d06 	br	40157dc <__adddf3+0x39c>
 4015d68:	293ff804 	addi	r4,r5,-32
 4015d6c:	29800820 	cmpeqi	r6,r5,32
 4015d70:	1908d83a 	srl	r4,r3,r4
 4015d74:	3000041e 	bne	r6,zero,4015d88 <__adddf3+0x948>
 4015d78:	01801004 	movi	r6,64
 4015d7c:	314bc83a 	sub	r5,r6,r5
 4015d80:	1946983a 	sll	r3,r3,r5
 4015d84:	70dcb03a 	or	r14,r14,r3
 4015d88:	7024c03a 	cmpne	r18,r14,zero
 4015d8c:	9124b03a 	or	r18,r18,r4
 4015d90:	003eae06 	br	401584c <__adddf3+0x40c>
 4015d94:	7365883a 	add	r18,r14,r13
 4015d98:	1a47883a 	add	r3,r3,r9
 4015d9c:	9345803a 	cmpltu	r2,r18,r13
 4015da0:	1889883a 	add	r4,r3,r2
 4015da4:	003e5c06 	br	4015718 <__adddf3+0x2d8>
 4015da8:	0005883a 	mov	r2,zero
 4015dac:	0141ffc4 	movi	r5,2047
 4015db0:	0007883a 	mov	r3,zero
 4015db4:	003e0806 	br	40155d8 <__adddf3+0x198>

04015db8 <__divdf3>:
 4015db8:	2810d53a 	srli	r8,r5,20
 4015dbc:	defff004 	addi	sp,sp,-64
 4015dc0:	dc000615 	stw	r16,24(sp)
 4015dc4:	04000434 	movhi	r16,16
 4015dc8:	df000e15 	stw	fp,56(sp)
 4015dcc:	ddc00d15 	stw	r23,52(sp)
 4015dd0:	dd800c15 	stw	r22,48(sp)
 4015dd4:	dd000a15 	stw	r20,40(sp)
 4015dd8:	843fffc4 	addi	r16,r16,-1
 4015ddc:	dfc00f15 	stw	ra,60(sp)
 4015de0:	dd400b15 	stw	r21,44(sp)
 4015de4:	dcc00915 	stw	r19,36(sp)
 4015de8:	dc800815 	stw	r18,32(sp)
 4015dec:	dc400715 	stw	r17,28(sp)
 4015df0:	4201ffcc 	andi	r8,r8,2047
 4015df4:	282ed7fa 	srli	r23,r5,31
 4015df8:	3039883a 	mov	fp,r6
 4015dfc:	382d883a 	mov	r22,r7
 4015e00:	2029883a 	mov	r20,r4
 4015e04:	2c20703a 	and	r16,r5,r16
 4015e08:	40005326 	beq	r8,zero,4015f58 <__divdf3+0x1a0>
 4015e0c:	4081ffe0 	cmpeqi	r2,r8,2047
 4015e10:	1000641e 	bne	r2,zero,4015fa4 <__divdf3+0x1ec>
 4015e14:	2026d77a 	srli	r19,r4,29
 4015e18:	800a90fa 	slli	r5,r16,3
 4015e1c:	202890fa 	slli	r20,r4,3
 4015e20:	44bf0044 	addi	r18,r8,-1023
 4015e24:	994ab03a 	or	r5,r19,r5
 4015e28:	2cc02034 	orhi	r19,r5,128
 4015e2c:	0021883a 	mov	r16,zero
 4015e30:	0023883a 	mov	r17,zero
 4015e34:	b010d53a 	srli	r8,r22,20
 4015e38:	00c00434 	movhi	r3,16
 4015e3c:	18ffffc4 	addi	r3,r3,-1
 4015e40:	4201ffcc 	andi	r8,r8,2047
 4015e44:	b02ad7fa 	srli	r21,r22,31
 4015e48:	b0ec703a 	and	r22,r22,r3
 4015e4c:	40005c26 	beq	r8,zero,4015fc0 <__divdf3+0x208>
 4015e50:	4081ffe0 	cmpeqi	r2,r8,2047
 4015e54:	1000201e 	bne	r2,zero,4015ed8 <__divdf3+0x120>
 4015e58:	b00690fa 	slli	r3,r22,3
 4015e5c:	e004d77a 	srli	r2,fp,29
 4015e60:	e01490fa 	slli	r10,fp,3
 4015e64:	423f0044 	addi	r8,r8,-1023
 4015e68:	10c6b03a 	or	r3,r2,r3
 4015e6c:	1d802034 	orhi	r22,r3,128
 4015e70:	9225c83a 	sub	r18,r18,r8
 4015e74:	0007883a 	mov	r3,zero
 4015e78:	80800428 	cmpgeui	r2,r16,16
 4015e7c:	bd52f03a 	xor	r9,r23,r21
 4015e80:	1000a81e 	bne	r2,zero,4016124 <__divdf3+0x36c>
 4015e84:	800c90ba 	slli	r6,r16,2
 4015e88:	00810074 	movhi	r2,1025
 4015e8c:	3085883a 	add	r2,r6,r2
 4015e90:	1097a617 	ldw	r2,24216(r2)
 4015e94:	1000683a 	jmp	r2
 4015e98:	04016124 	muli	r16,zero,1412
 4015e9c:	04015f48 	cmpgei	r16,zero,1405
 4015ea0:	04015ef4 	movhi	r16,1403
 4015ea4:	0401606c 	andhi	r16,zero,1409
 4015ea8:	04015ef4 	movhi	r16,1403
 4015eac:	040160c8 	cmpgei	r16,zero,1411
 4015eb0:	04015ef4 	movhi	r16,1403
 4015eb4:	0401606c 	andhi	r16,zero,1409
 4015eb8:	04015f48 	cmpgei	r16,zero,1405
 4015ebc:	04015f48 	cmpgei	r16,zero,1405
 4015ec0:	040160c8 	cmpgei	r16,zero,1411
 4015ec4:	0401606c 	andhi	r16,zero,1409
 4015ec8:	04016004 	movi	r16,1408
 4015ecc:	04016004 	movi	r16,1408
 4015ed0:	04016004 	movi	r16,1408
 4015ed4:	040160e0 	cmpeqi	r16,zero,1411
 4015ed8:	b714b03a 	or	r10,r22,fp
 4015edc:	94be0044 	addi	r18,r18,-2047
 4015ee0:	5000671e 	bne	r10,zero,4016080 <__divdf3+0x2c8>
 4015ee4:	84000094 	ori	r16,r16,2
 4015ee8:	002d883a 	mov	r22,zero
 4015eec:	00c00084 	movi	r3,2
 4015ef0:	003fe106 	br	4015e78 <__divdf3+0xc0>
 4015ef4:	0007883a 	mov	r3,zero
 4015ef8:	000b883a 	mov	r5,zero
 4015efc:	0029883a 	mov	r20,zero
 4015f00:	1806953a 	slli	r3,r3,20
 4015f04:	4a403fcc 	andi	r9,r9,255
 4015f08:	481297fa 	slli	r9,r9,31
 4015f0c:	1946b03a 	or	r3,r3,r5
 4015f10:	a005883a 	mov	r2,r20
 4015f14:	1a46b03a 	or	r3,r3,r9
 4015f18:	dfc00f17 	ldw	ra,60(sp)
 4015f1c:	df000e17 	ldw	fp,56(sp)
 4015f20:	ddc00d17 	ldw	r23,52(sp)
 4015f24:	dd800c17 	ldw	r22,48(sp)
 4015f28:	dd400b17 	ldw	r21,44(sp)
 4015f2c:	dd000a17 	ldw	r20,40(sp)
 4015f30:	dcc00917 	ldw	r19,36(sp)
 4015f34:	dc800817 	ldw	r18,32(sp)
 4015f38:	dc400717 	ldw	r17,28(sp)
 4015f3c:	dc000617 	ldw	r16,24(sp)
 4015f40:	dec01004 	addi	sp,sp,64
 4015f44:	f800283a 	ret
 4015f48:	00c1ffc4 	movi	r3,2047
 4015f4c:	000b883a 	mov	r5,zero
 4015f50:	0029883a 	mov	r20,zero
 4015f54:	003fea06 	br	4015f00 <__divdf3+0x148>
 4015f58:	2426b03a 	or	r19,r4,r16
 4015f5c:	2023883a 	mov	r17,r4
 4015f60:	98004f26 	beq	r19,zero,40160a0 <__divdf3+0x2e8>
 4015f64:	80017b26 	beq	r16,zero,4016554 <__divdf3+0x79c>
 4015f68:	8009883a 	mov	r4,r16
 4015f6c:	4017c480 	call	4017c48 <__clzsi2>
 4015f70:	113ffd44 	addi	r4,r2,-11
 4015f74:	00c00744 	movi	r3,29
 4015f78:	14fffe04 	addi	r19,r2,-8
 4015f7c:	1907c83a 	sub	r3,r3,r4
 4015f80:	84ca983a 	sll	r5,r16,r19
 4015f84:	88c6d83a 	srl	r3,r17,r3
 4015f88:	8ce8983a 	sll	r20,r17,r19
 4015f8c:	1966b03a 	or	r19,r3,r5
 4015f90:	023f0344 	movi	r8,-1011
 4015f94:	40a5c83a 	sub	r18,r8,r2
 4015f98:	0021883a 	mov	r16,zero
 4015f9c:	0023883a 	mov	r17,zero
 4015fa0:	003fa406 	br	4015e34 <__divdf3+0x7c>
 4015fa4:	2426b03a 	or	r19,r4,r16
 4015fa8:	9800421e 	bne	r19,zero,40160b4 <__divdf3+0x2fc>
 4015fac:	0029883a 	mov	r20,zero
 4015fb0:	04000204 	movi	r16,8
 4015fb4:	0481ffc4 	movi	r18,2047
 4015fb8:	04400084 	movi	r17,2
 4015fbc:	003f9d06 	br	4015e34 <__divdf3+0x7c>
 4015fc0:	b714b03a 	or	r10,r22,fp
 4015fc4:	50003226 	beq	r10,zero,4016090 <__divdf3+0x2d8>
 4015fc8:	b0016c26 	beq	r22,zero,401657c <__divdf3+0x7c4>
 4015fcc:	b009883a 	mov	r4,r22
 4015fd0:	4017c480 	call	4017c48 <__clzsi2>
 4015fd4:	117ffd44 	addi	r5,r2,-11
 4015fd8:	01000744 	movi	r4,29
 4015fdc:	12bffe04 	addi	r10,r2,-8
 4015fe0:	2149c83a 	sub	r4,r4,r5
 4015fe4:	b286983a 	sll	r3,r22,r10
 4015fe8:	e108d83a 	srl	r4,fp,r4
 4015fec:	e294983a 	sll	r10,fp,r10
 4015ff0:	20ecb03a 	or	r22,r4,r3
 4015ff4:	1491883a 	add	r8,r2,r18
 4015ff8:	4480fcc4 	addi	r18,r8,1011
 4015ffc:	0007883a 	mov	r3,zero
 4016000:	003f9d06 	br	4015e78 <__divdf3+0xc0>
 4016004:	b813883a 	mov	r9,r23
 4016008:	888000a0 	cmpeqi	r2,r17,2
 401600c:	103fce1e 	bne	r2,zero,4015f48 <__divdf3+0x190>
 4016010:	888000e0 	cmpeqi	r2,r17,3
 4016014:	1001ac1e 	bne	r2,zero,40166c8 <__divdf3+0x910>
 4016018:	88800060 	cmpeqi	r2,r17,1
 401601c:	103fb51e 	bne	r2,zero,4015ef4 <__divdf3+0x13c>
 4016020:	9440ffc4 	addi	r17,r18,1023
 4016024:	04411c0e 	bge	zero,r17,4016498 <__divdf3+0x6e0>
 4016028:	a08001cc 	andi	r2,r20,7
 401602c:	1001831e 	bne	r2,zero,401663c <__divdf3+0x884>
 4016030:	a008d0fa 	srli	r4,r20,3
 4016034:	9880402c 	andhi	r2,r19,256
 4016038:	10000426 	beq	r2,zero,401604c <__divdf3+0x294>
 401603c:	00bfc034 	movhi	r2,65280
 4016040:	10bfffc4 	addi	r2,r2,-1
 4016044:	98a6703a 	and	r19,r19,r2
 4016048:	94410004 	addi	r17,r18,1024
 401604c:	8881ffc8 	cmpgei	r2,r17,2047
 4016050:	103fbd1e 	bne	r2,zero,4015f48 <__divdf3+0x190>
 4016054:	9828977a 	slli	r20,r19,29
 4016058:	980a927a 	slli	r5,r19,9
 401605c:	88c1ffcc 	andi	r3,r17,2047
 4016060:	a128b03a 	or	r20,r20,r4
 4016064:	280ad33a 	srli	r5,r5,12
 4016068:	003fa506 	br	4015f00 <__divdf3+0x148>
 401606c:	a813883a 	mov	r9,r21
 4016070:	b027883a 	mov	r19,r22
 4016074:	5029883a 	mov	r20,r10
 4016078:	1823883a 	mov	r17,r3
 401607c:	003fe206 	br	4016008 <__divdf3+0x250>
 4016080:	840000d4 	ori	r16,r16,3
 4016084:	e015883a 	mov	r10,fp
 4016088:	00c000c4 	movi	r3,3
 401608c:	003f7a06 	br	4015e78 <__divdf3+0xc0>
 4016090:	84000054 	ori	r16,r16,1
 4016094:	002d883a 	mov	r22,zero
 4016098:	00c00044 	movi	r3,1
 401609c:	003f7606 	br	4015e78 <__divdf3+0xc0>
 40160a0:	0029883a 	mov	r20,zero
 40160a4:	04000104 	movi	r16,4
 40160a8:	0025883a 	mov	r18,zero
 40160ac:	04400044 	movi	r17,1
 40160b0:	003f6006 	br	4015e34 <__divdf3+0x7c>
 40160b4:	8027883a 	mov	r19,r16
 40160b8:	0481ffc4 	movi	r18,2047
 40160bc:	04000304 	movi	r16,12
 40160c0:	044000c4 	movi	r17,3
 40160c4:	003f5b06 	br	4015e34 <__divdf3+0x7c>
 40160c8:	01400434 	movhi	r5,16
 40160cc:	0013883a 	mov	r9,zero
 40160d0:	297fffc4 	addi	r5,r5,-1
 40160d4:	053fffc4 	movi	r20,-1
 40160d8:	00c1ffc4 	movi	r3,2047
 40160dc:	003f8806 	br	4015f00 <__divdf3+0x148>
 40160e0:	9880022c 	andhi	r2,r19,8
 40160e4:	10000926 	beq	r2,zero,401610c <__divdf3+0x354>
 40160e8:	b080022c 	andhi	r2,r22,8
 40160ec:	1000071e 	bne	r2,zero,401610c <__divdf3+0x354>
 40160f0:	00800434 	movhi	r2,16
 40160f4:	b1400234 	orhi	r5,r22,8
 40160f8:	10bfffc4 	addi	r2,r2,-1
 40160fc:	288a703a 	and	r5,r5,r2
 4016100:	a813883a 	mov	r9,r21
 4016104:	5029883a 	mov	r20,r10
 4016108:	003ff306 	br	40160d8 <__divdf3+0x320>
 401610c:	00800434 	movhi	r2,16
 4016110:	99400234 	orhi	r5,r19,8
 4016114:	10bfffc4 	addi	r2,r2,-1
 4016118:	288a703a 	and	r5,r5,r2
 401611c:	b813883a 	mov	r9,r23
 4016120:	003fed06 	br	40160d8 <__divdf3+0x320>
 4016124:	b4c10536 	bltu	r22,r19,401653c <__divdf3+0x784>
 4016128:	b4c10326 	beq	r22,r19,4016538 <__divdf3+0x780>
 401612c:	94bfffc4 	addi	r18,r18,-1
 4016130:	a039883a 	mov	fp,r20
 4016134:	9821883a 	mov	r16,r19
 4016138:	0023883a 	mov	r17,zero
 401613c:	b006923a 	slli	r3,r22,8
 4016140:	502cd63a 	srli	r22,r10,24
 4016144:	8009883a 	mov	r4,r16
 4016148:	182ed43a 	srli	r23,r3,16
 401614c:	b0ecb03a 	or	r22,r22,r3
 4016150:	da400015 	stw	r9,0(sp)
 4016154:	b80b883a 	mov	r5,r23
 4016158:	502a923a 	slli	r21,r10,8
 401615c:	b53fffcc 	andi	r20,r22,65535
 4016160:	40153800 	call	4015380 <__udivsi3>
 4016164:	100b883a 	mov	r5,r2
 4016168:	a009883a 	mov	r4,r20
 401616c:	1027883a 	mov	r19,r2
 4016170:	40072d80 	call	40072d8 <__mulsi3>
 4016174:	8009883a 	mov	r4,r16
 4016178:	b80b883a 	mov	r5,r23
 401617c:	1021883a 	mov	r16,r2
 4016180:	40153e40 	call	40153e4 <__umodsi3>
 4016184:	1004943a 	slli	r2,r2,16
 4016188:	e008d43a 	srli	r4,fp,16
 401618c:	da400017 	ldw	r9,0(sp)
 4016190:	2088b03a 	or	r4,r4,r2
 4016194:	2400042e 	bgeu	r4,r16,40161a8 <__divdf3+0x3f0>
 4016198:	2589883a 	add	r4,r4,r22
 401619c:	98bfffc4 	addi	r2,r19,-1
 40161a0:	2581082e 	bgeu	r4,r22,40165c4 <__divdf3+0x80c>
 40161a4:	1027883a 	mov	r19,r2
 40161a8:	2421c83a 	sub	r16,r4,r16
 40161ac:	b80b883a 	mov	r5,r23
 40161b0:	8009883a 	mov	r4,r16
 40161b4:	da400215 	stw	r9,8(sp)
 40161b8:	40153800 	call	4015380 <__udivsi3>
 40161bc:	100b883a 	mov	r5,r2
 40161c0:	a009883a 	mov	r4,r20
 40161c4:	d8800115 	stw	r2,4(sp)
 40161c8:	40072d80 	call	40072d8 <__mulsi3>
 40161cc:	b80b883a 	mov	r5,r23
 40161d0:	8009883a 	mov	r4,r16
 40161d4:	d8800015 	stw	r2,0(sp)
 40161d8:	40153e40 	call	40153e4 <__umodsi3>
 40161dc:	100c943a 	slli	r6,r2,16
 40161e0:	d8c00017 	ldw	r3,0(sp)
 40161e4:	e73fffcc 	andi	fp,fp,65535
 40161e8:	e18cb03a 	or	r6,fp,r6
 40161ec:	d9c00117 	ldw	r7,4(sp)
 40161f0:	da400217 	ldw	r9,8(sp)
 40161f4:	30c0042e 	bgeu	r6,r3,4016208 <__divdf3+0x450>
 40161f8:	358d883a 	add	r6,r6,r22
 40161fc:	38bfffc4 	addi	r2,r7,-1
 4016200:	3580ec2e 	bgeu	r6,r22,40165b4 <__divdf3+0x7fc>
 4016204:	100f883a 	mov	r7,r2
 4016208:	9826943a 	slli	r19,r19,16
 401620c:	af3fffcc 	andi	fp,r21,65535
 4016210:	30c7c83a 	sub	r3,r6,r3
 4016214:	99e6b03a 	or	r19,r19,r7
 4016218:	980ed43a 	srli	r7,r19,16
 401621c:	9abfffcc 	andi	r10,r19,65535
 4016220:	5009883a 	mov	r4,r10
 4016224:	e00b883a 	mov	r5,fp
 4016228:	da400515 	stw	r9,20(sp)
 401622c:	d8c00315 	stw	r3,12(sp)
 4016230:	da800415 	stw	r10,16(sp)
 4016234:	d9c00015 	stw	r7,0(sp)
 4016238:	40072d80 	call	40072d8 <__mulsi3>
 401623c:	d9c00017 	ldw	r7,0(sp)
 4016240:	e00b883a 	mov	r5,fp
 4016244:	d8800215 	stw	r2,8(sp)
 4016248:	3809883a 	mov	r4,r7
 401624c:	40072d80 	call	40072d8 <__mulsi3>
 4016250:	d9c00017 	ldw	r7,0(sp)
 4016254:	a820d43a 	srli	r16,r21,16
 4016258:	d8800115 	stw	r2,4(sp)
 401625c:	3809883a 	mov	r4,r7
 4016260:	800b883a 	mov	r5,r16
 4016264:	40072d80 	call	40072d8 <__mulsi3>
 4016268:	da800417 	ldw	r10,16(sp)
 401626c:	8009883a 	mov	r4,r16
 4016270:	d8800015 	stw	r2,0(sp)
 4016274:	500b883a 	mov	r5,r10
 4016278:	40072d80 	call	40072d8 <__mulsi3>
 401627c:	d9800217 	ldw	r6,8(sp)
 4016280:	d9c00117 	ldw	r7,4(sp)
 4016284:	da000017 	ldw	r8,0(sp)
 4016288:	3008d43a 	srli	r4,r6,16
 401628c:	11c5883a 	add	r2,r2,r7
 4016290:	d8c00317 	ldw	r3,12(sp)
 4016294:	2089883a 	add	r4,r4,r2
 4016298:	da400517 	ldw	r9,20(sp)
 401629c:	21c0022e 	bgeu	r4,r7,40162a8 <__divdf3+0x4f0>
 40162a0:	00800074 	movhi	r2,1
 40162a4:	4091883a 	add	r8,r8,r2
 40162a8:	200ad43a 	srli	r5,r4,16
 40162ac:	2008943a 	slli	r4,r4,16
 40162b0:	31bfffcc 	andi	r6,r6,65535
 40162b4:	2a0b883a 	add	r5,r5,r8
 40162b8:	218d883a 	add	r6,r4,r6
 40162bc:	19409436 	bltu	r3,r5,4016510 <__divdf3+0x758>
 40162c0:	19409226 	beq	r3,r5,401650c <__divdf3+0x754>
 40162c4:	898dc83a 	sub	r6,r17,r6
 40162c8:	89a3803a 	cmpltu	r17,r17,r6
 40162cc:	1947c83a 	sub	r3,r3,r5
 40162d0:	1c47c83a 	sub	r3,r3,r17
 40162d4:	9440ffc4 	addi	r17,r18,1023
 40162d8:	b0c0d326 	beq	r22,r3,4016628 <__divdf3+0x870>
 40162dc:	1809883a 	mov	r4,r3
 40162e0:	b80b883a 	mov	r5,r23
 40162e4:	d9800315 	stw	r6,12(sp)
 40162e8:	da400215 	stw	r9,8(sp)
 40162ec:	d8c00015 	stw	r3,0(sp)
 40162f0:	40153800 	call	4015380 <__udivsi3>
 40162f4:	100b883a 	mov	r5,r2
 40162f8:	a009883a 	mov	r4,r20
 40162fc:	d8800115 	stw	r2,4(sp)
 4016300:	40072d80 	call	40072d8 <__mulsi3>
 4016304:	d8c00017 	ldw	r3,0(sp)
 4016308:	b80b883a 	mov	r5,r23
 401630c:	d8800015 	stw	r2,0(sp)
 4016310:	1809883a 	mov	r4,r3
 4016314:	40153e40 	call	40153e4 <__umodsi3>
 4016318:	d9800317 	ldw	r6,12(sp)
 401631c:	1006943a 	slli	r3,r2,16
 4016320:	da000017 	ldw	r8,0(sp)
 4016324:	3008d43a 	srli	r4,r6,16
 4016328:	d9c00117 	ldw	r7,4(sp)
 401632c:	da400217 	ldw	r9,8(sp)
 4016330:	20c6b03a 	or	r3,r4,r3
 4016334:	1a00062e 	bgeu	r3,r8,4016350 <__divdf3+0x598>
 4016338:	1d87883a 	add	r3,r3,r22
 401633c:	38bfffc4 	addi	r2,r7,-1
 4016340:	1d80c836 	bltu	r3,r22,4016664 <__divdf3+0x8ac>
 4016344:	1a00c72e 	bgeu	r3,r8,4016664 <__divdf3+0x8ac>
 4016348:	39ffff84 	addi	r7,r7,-2
 401634c:	1d87883a 	add	r3,r3,r22
 4016350:	1a07c83a 	sub	r3,r3,r8
 4016354:	1809883a 	mov	r4,r3
 4016358:	b80b883a 	mov	r5,r23
 401635c:	d9800415 	stw	r6,16(sp)
 4016360:	da400315 	stw	r9,12(sp)
 4016364:	d9c00215 	stw	r7,8(sp)
 4016368:	d8c00115 	stw	r3,4(sp)
 401636c:	40153800 	call	4015380 <__udivsi3>
 4016370:	100b883a 	mov	r5,r2
 4016374:	a009883a 	mov	r4,r20
 4016378:	d8800015 	stw	r2,0(sp)
 401637c:	40072d80 	call	40072d8 <__mulsi3>
 4016380:	d8c00117 	ldw	r3,4(sp)
 4016384:	b80b883a 	mov	r5,r23
 4016388:	102f883a 	mov	r23,r2
 401638c:	1809883a 	mov	r4,r3
 4016390:	40153e40 	call	40153e4 <__umodsi3>
 4016394:	d9800417 	ldw	r6,16(sp)
 4016398:	1004943a 	slli	r2,r2,16
 401639c:	da000017 	ldw	r8,0(sp)
 40163a0:	31bfffcc 	andi	r6,r6,65535
 40163a4:	308cb03a 	or	r6,r6,r2
 40163a8:	d9c00217 	ldw	r7,8(sp)
 40163ac:	da400317 	ldw	r9,12(sp)
 40163b0:	35c0062e 	bgeu	r6,r23,40163cc <__divdf3+0x614>
 40163b4:	358d883a 	add	r6,r6,r22
 40163b8:	40bfffc4 	addi	r2,r8,-1
 40163bc:	3580a736 	bltu	r6,r22,401665c <__divdf3+0x8a4>
 40163c0:	35c0a62e 	bgeu	r6,r23,401665c <__divdf3+0x8a4>
 40163c4:	423fff84 	addi	r8,r8,-2
 40163c8:	358d883a 	add	r6,r6,r22
 40163cc:	3828943a 	slli	r20,r7,16
 40163d0:	35d5c83a 	sub	r10,r6,r23
 40163d4:	e009883a 	mov	r4,fp
 40163d8:	a228b03a 	or	r20,r20,r8
 40163dc:	a1ffffcc 	andi	r7,r20,65535
 40163e0:	a02ed43a 	srli	r23,r20,16
 40163e4:	380b883a 	mov	r5,r7
 40163e8:	da400315 	stw	r9,12(sp)
 40163ec:	da800215 	stw	r10,8(sp)
 40163f0:	d9c00115 	stw	r7,4(sp)
 40163f4:	40072d80 	call	40072d8 <__mulsi3>
 40163f8:	e00b883a 	mov	r5,fp
 40163fc:	b809883a 	mov	r4,r23
 4016400:	1039883a 	mov	fp,r2
 4016404:	40072d80 	call	40072d8 <__mulsi3>
 4016408:	8009883a 	mov	r4,r16
 401640c:	b80b883a 	mov	r5,r23
 4016410:	d8800015 	stw	r2,0(sp)
 4016414:	40072d80 	call	40072d8 <__mulsi3>
 4016418:	d9c00117 	ldw	r7,4(sp)
 401641c:	8009883a 	mov	r4,r16
 4016420:	1021883a 	mov	r16,r2
 4016424:	380b883a 	mov	r5,r7
 4016428:	40072d80 	call	40072d8 <__mulsi3>
 401642c:	d9800017 	ldw	r6,0(sp)
 4016430:	e006d43a 	srli	r3,fp,16
 4016434:	da800217 	ldw	r10,8(sp)
 4016438:	1185883a 	add	r2,r2,r6
 401643c:	1887883a 	add	r3,r3,r2
 4016440:	da400317 	ldw	r9,12(sp)
 4016444:	1980022e 	bgeu	r3,r6,4016450 <__divdf3+0x698>
 4016448:	00800074 	movhi	r2,1
 401644c:	80a1883a 	add	r16,r16,r2
 4016450:	1808d43a 	srli	r4,r3,16
 4016454:	1806943a 	slli	r3,r3,16
 4016458:	e73fffcc 	andi	fp,fp,65535
 401645c:	2409883a 	add	r4,r4,r16
 4016460:	1f07883a 	add	r3,r3,fp
 4016464:	51000436 	bltu	r10,r4,4016478 <__divdf3+0x6c0>
 4016468:	51000226 	beq	r10,r4,4016474 <__divdf3+0x6bc>
 401646c:	a5000054 	ori	r20,r20,1
 4016470:	003eec06 	br	4016024 <__divdf3+0x26c>
 4016474:	183eeb26 	beq	r3,zero,4016024 <__divdf3+0x26c>
 4016478:	b28d883a 	add	r6,r22,r10
 401647c:	a0bfffc4 	addi	r2,r20,-1
 4016480:	35806536 	bltu	r6,r22,4016618 <__divdf3+0x860>
 4016484:	31008036 	bltu	r6,r4,4016688 <__divdf3+0x8d0>
 4016488:	31009426 	beq	r6,r4,40166dc <__divdf3+0x924>
 401648c:	1029883a 	mov	r20,r2
 4016490:	003ff606 	br	401646c <__divdf3+0x6b4>
 4016494:	053fffc4 	movi	r20,-1
 4016498:	01400044 	movi	r5,1
 401649c:	2c4bc83a 	sub	r5,r5,r17
 40164a0:	28800e48 	cmpgei	r2,r5,57
 40164a4:	103e931e 	bne	r2,zero,4015ef4 <__divdf3+0x13c>
 40164a8:	28800808 	cmpgei	r2,r5,32
 40164ac:	1000491e 	bne	r2,zero,40165d4 <__divdf3+0x81c>
 40164b0:	92010784 	addi	r8,r18,1054
 40164b4:	9a04983a 	sll	r2,r19,r8
 40164b8:	a146d83a 	srl	r3,r20,r5
 40164bc:	a210983a 	sll	r8,r20,r8
 40164c0:	994ad83a 	srl	r5,r19,r5
 40164c4:	10e8b03a 	or	r20,r2,r3
 40164c8:	4010c03a 	cmpne	r8,r8,zero
 40164cc:	a228b03a 	or	r20,r20,r8
 40164d0:	a08001cc 	andi	r2,r20,7
 40164d4:	10000726 	beq	r2,zero,40164f4 <__divdf3+0x73c>
 40164d8:	a08003cc 	andi	r2,r20,15
 40164dc:	10800120 	cmpeqi	r2,r2,4
 40164e0:	1000041e 	bne	r2,zero,40164f4 <__divdf3+0x73c>
 40164e4:	a0800104 	addi	r2,r20,4
 40164e8:	1529803a 	cmpltu	r20,r2,r20
 40164ec:	2d0b883a 	add	r5,r5,r20
 40164f0:	1029883a 	mov	r20,r2
 40164f4:	2880202c 	andhi	r2,r5,128
 40164f8:	10006f26 	beq	r2,zero,40166b8 <__divdf3+0x900>
 40164fc:	00c00044 	movi	r3,1
 4016500:	000b883a 	mov	r5,zero
 4016504:	0029883a 	mov	r20,zero
 4016508:	003e7d06 	br	4015f00 <__divdf3+0x148>
 401650c:	89bf6d2e 	bgeu	r17,r6,40162c4 <__divdf3+0x50c>
 4016510:	8d63883a 	add	r17,r17,r21
 4016514:	8d45803a 	cmpltu	r2,r17,r21
 4016518:	1585883a 	add	r2,r2,r22
 401651c:	1887883a 	add	r3,r3,r2
 4016520:	98bfffc4 	addi	r2,r19,-1
 4016524:	b0c0202e 	bgeu	r22,r3,40165a8 <__divdf3+0x7f0>
 4016528:	19405136 	bltu	r3,r5,4016670 <__divdf3+0x8b8>
 401652c:	28c04f26 	beq	r5,r3,401666c <__divdf3+0x8b4>
 4016530:	1027883a 	mov	r19,r2
 4016534:	003f6306 	br	40162c4 <__divdf3+0x50c>
 4016538:	a2befc36 	bltu	r20,r10,401612c <__divdf3+0x374>
 401653c:	983897fa 	slli	fp,r19,31
 4016540:	a004d07a 	srli	r2,r20,1
 4016544:	9820d07a 	srli	r16,r19,1
 4016548:	a02297fa 	slli	r17,r20,31
 401654c:	e0b8b03a 	or	fp,fp,r2
 4016550:	003efa06 	br	401613c <__divdf3+0x384>
 4016554:	4017c480 	call	4017c48 <__clzsi2>
 4016558:	11000544 	addi	r4,r2,21
 401655c:	20c00748 	cmpgei	r3,r4,29
 4016560:	100b883a 	mov	r5,r2
 4016564:	10800804 	addi	r2,r2,32
 4016568:	183e8226 	beq	r3,zero,4015f74 <__divdf3+0x1bc>
 401656c:	297ffe04 	addi	r5,r5,-8
 4016570:	a166983a 	sll	r19,r20,r5
 4016574:	0029883a 	mov	r20,zero
 4016578:	003e8506 	br	4015f90 <__divdf3+0x1d8>
 401657c:	e009883a 	mov	r4,fp
 4016580:	4017c480 	call	4017c48 <__clzsi2>
 4016584:	11400544 	addi	r5,r2,21
 4016588:	29000748 	cmpgei	r4,r5,29
 401658c:	1007883a 	mov	r3,r2
 4016590:	10800804 	addi	r2,r2,32
 4016594:	203e9026 	beq	r4,zero,4015fd8 <__divdf3+0x220>
 4016598:	18fffe04 	addi	r3,r3,-8
 401659c:	e0ec983a 	sll	r22,fp,r3
 40165a0:	0015883a 	mov	r10,zero
 40165a4:	003e9306 	br	4015ff4 <__divdf3+0x23c>
 40165a8:	b0ffe11e 	bne	r22,r3,4016530 <__divdf3+0x778>
 40165ac:	8d7fe036 	bltu	r17,r21,4016530 <__divdf3+0x778>
 40165b0:	003fdd06 	br	4016528 <__divdf3+0x770>
 40165b4:	30ff132e 	bgeu	r6,r3,4016204 <__divdf3+0x44c>
 40165b8:	39ffff84 	addi	r7,r7,-2
 40165bc:	358d883a 	add	r6,r6,r22
 40165c0:	003f1106 	br	4016208 <__divdf3+0x450>
 40165c4:	243ef72e 	bgeu	r4,r16,40161a4 <__divdf3+0x3ec>
 40165c8:	9cffff84 	addi	r19,r19,-2
 40165cc:	2589883a 	add	r4,r4,r22
 40165d0:	003ef506 	br	40161a8 <__divdf3+0x3f0>
 40165d4:	00fff844 	movi	r3,-31
 40165d8:	1c47c83a 	sub	r3,r3,r17
 40165dc:	29400820 	cmpeqi	r5,r5,32
 40165e0:	98c6d83a 	srl	r3,r19,r3
 40165e4:	2800031e 	bne	r5,zero,40165f4 <__divdf3+0x83c>
 40165e8:	91410f84 	addi	r5,r18,1086
 40165ec:	994a983a 	sll	r5,r19,r5
 40165f0:	a168b03a 	or	r20,r20,r5
 40165f4:	a028c03a 	cmpne	r20,r20,zero
 40165f8:	a0e8b03a 	or	r20,r20,r3
 40165fc:	a4c001cc 	andi	r19,r20,7
 4016600:	9800291e 	bne	r19,zero,40166a8 <__divdf3+0x8f0>
 4016604:	000b883a 	mov	r5,zero
 4016608:	a028d0fa 	srli	r20,r20,3
 401660c:	0007883a 	mov	r3,zero
 4016610:	a4e8b03a 	or	r20,r20,r19
 4016614:	003e3a06 	br	4015f00 <__divdf3+0x148>
 4016618:	1029883a 	mov	r20,r2
 401661c:	313f931e 	bne	r6,r4,401646c <__divdf3+0x6b4>
 4016620:	1d7f921e 	bne	r3,r21,401646c <__divdf3+0x6b4>
 4016624:	003e7f06 	br	4016024 <__divdf3+0x26c>
 4016628:	047f9a0e 	bge	zero,r17,4016494 <__divdf3+0x6dc>
 401662c:	0009883a 	mov	r4,zero
 4016630:	05000044 	movi	r20,1
 4016634:	9d27883a 	add	r19,r19,r20
 4016638:	003e7e06 	br	4016034 <__divdf3+0x27c>
 401663c:	a08003cc 	andi	r2,r20,15
 4016640:	10800118 	cmpnei	r2,r2,4
 4016644:	103e7a26 	beq	r2,zero,4016030 <__divdf3+0x278>
 4016648:	a1000104 	addi	r4,r20,4
 401664c:	00bffec4 	movi	r2,-5
 4016650:	2008d0fa 	srli	r4,r4,3
 4016654:	1529803a 	cmpltu	r20,r2,r20
 4016658:	003ff606 	br	4016634 <__divdf3+0x87c>
 401665c:	1011883a 	mov	r8,r2
 4016660:	003f5a06 	br	40163cc <__divdf3+0x614>
 4016664:	100f883a 	mov	r7,r2
 4016668:	003f3906 	br	4016350 <__divdf3+0x598>
 401666c:	89bfb02e 	bgeu	r17,r6,4016530 <__divdf3+0x778>
 4016670:	8d63883a 	add	r17,r17,r21
 4016674:	8d45803a 	cmpltu	r2,r17,r21
 4016678:	1585883a 	add	r2,r2,r22
 401667c:	9cffff84 	addi	r19,r19,-2
 4016680:	1887883a 	add	r3,r3,r2
 4016684:	003f0f06 	br	40162c4 <__divdf3+0x50c>
 4016688:	ad45883a 	add	r2,r21,r21
 401668c:	156b803a 	cmpltu	r21,r2,r21
 4016690:	adad883a 	add	r22,r21,r22
 4016694:	358d883a 	add	r6,r6,r22
 4016698:	a53fff84 	addi	r20,r20,-2
 401669c:	102b883a 	mov	r21,r2
 40166a0:	313fdf26 	beq	r6,r4,4016620 <__divdf3+0x868>
 40166a4:	003f7106 	br	401646c <__divdf3+0x6b4>
 40166a8:	a08003cc 	andi	r2,r20,15
 40166ac:	10800118 	cmpnei	r2,r2,4
 40166b0:	000b883a 	mov	r5,zero
 40166b4:	103f8b1e 	bne	r2,zero,40164e4 <__divdf3+0x72c>
 40166b8:	2804927a 	slli	r2,r5,9
 40166bc:	2826977a 	slli	r19,r5,29
 40166c0:	100ad33a 	srli	r5,r2,12
 40166c4:	003fd006 	br	4016608 <__divdf3+0x850>
 40166c8:	00800434 	movhi	r2,16
 40166cc:	99400234 	orhi	r5,r19,8
 40166d0:	10bfffc4 	addi	r2,r2,-1
 40166d4:	288a703a 	and	r5,r5,r2
 40166d8:	003e7f06 	br	40160d8 <__divdf3+0x320>
 40166dc:	a8ffea36 	bltu	r21,r3,4016688 <__divdf3+0x8d0>
 40166e0:	1029883a 	mov	r20,r2
 40166e4:	1d7f611e 	bne	r3,r21,401646c <__divdf3+0x6b4>
 40166e8:	003e4e06 	br	4016024 <__divdf3+0x26c>

040166ec <__eqdf2>:
 40166ec:	2810d53a 	srli	r8,r5,20
 40166f0:	3806d53a 	srli	r3,r7,20
 40166f4:	00800434 	movhi	r2,16
 40166f8:	4201ffcc 	andi	r8,r8,2047
 40166fc:	10bfffc4 	addi	r2,r2,-1
 4016700:	4241ffd8 	cmpnei	r9,r8,2047
 4016704:	2814d7fa 	srli	r10,r5,31
 4016708:	3816d7fa 	srli	r11,r7,31
 401670c:	288a703a 	and	r5,r5,r2
 4016710:	388e703a 	and	r7,r7,r2
 4016714:	1881ffcc 	andi	r2,r3,2047
 4016718:	48000626 	beq	r9,zero,4016734 <__eqdf2+0x48>
 401671c:	10c1ffe0 	cmpeqi	r3,r2,2047
 4016720:	1800021e 	bne	r3,zero,401672c <__eqdf2+0x40>
 4016724:	4080011e 	bne	r8,r2,401672c <__eqdf2+0x40>
 4016728:	29c00826 	beq	r5,r7,401674c <__eqdf2+0x60>
 401672c:	00800044 	movi	r2,1
 4016730:	f800283a 	ret
 4016734:	2906b03a 	or	r3,r5,r4
 4016738:	183ffc1e 	bne	r3,zero,401672c <__eqdf2+0x40>
 401673c:	1081ffd8 	cmpnei	r2,r2,2047
 4016740:	103ffa1e 	bne	r2,zero,401672c <__eqdf2+0x40>
 4016744:	398eb03a 	or	r7,r7,r6
 4016748:	383ff81e 	bne	r7,zero,401672c <__eqdf2+0x40>
 401674c:	21bff71e 	bne	r4,r6,401672c <__eqdf2+0x40>
 4016750:	52c00426 	beq	r10,r11,4016764 <__eqdf2+0x78>
 4016754:	403ff51e 	bne	r8,zero,401672c <__eqdf2+0x40>
 4016758:	290ab03a 	or	r5,r5,r4
 401675c:	2804c03a 	cmpne	r2,r5,zero
 4016760:	f800283a 	ret
 4016764:	0005883a 	mov	r2,zero
 4016768:	f800283a 	ret

0401676c <__gedf2>:
 401676c:	2810d53a 	srli	r8,r5,20
 4016770:	3812d53a 	srli	r9,r7,20
 4016774:	00c00434 	movhi	r3,16
 4016778:	4201ffcc 	andi	r8,r8,2047
 401677c:	18ffffc4 	addi	r3,r3,-1
 4016780:	4281ffd8 	cmpnei	r10,r8,2047
 4016784:	2816d7fa 	srli	r11,r5,31
 4016788:	3804d7fa 	srli	r2,r7,31
 401678c:	28ca703a 	and	r5,r5,r3
 4016790:	38ce703a 	and	r7,r7,r3
 4016794:	48c1ffcc 	andi	r3,r9,2047
 4016798:	50000b26 	beq	r10,zero,40167c8 <__gedf2+0x5c>
 401679c:	1a41ffd8 	cmpnei	r9,r3,2047
 40167a0:	48000d26 	beq	r9,zero,40167d8 <__gedf2+0x6c>
 40167a4:	4000191e 	bne	r8,zero,401680c <__gedf2+0xa0>
 40167a8:	2914b03a 	or	r10,r5,r4
 40167ac:	5013003a 	cmpeq	r9,r10,zero
 40167b0:	1800131e 	bne	r3,zero,4016800 <__gedf2+0x94>
 40167b4:	3998b03a 	or	r12,r7,r6
 40167b8:	6000111e 	bne	r12,zero,4016800 <__gedf2+0x94>
 40167bc:	50000a1e 	bne	r10,zero,40167e8 <__gedf2+0x7c>
 40167c0:	0005883a 	mov	r2,zero
 40167c4:	f800283a 	ret
 40167c8:	2912b03a 	or	r9,r5,r4
 40167cc:	48001e1e 	bne	r9,zero,4016848 <__gedf2+0xdc>
 40167d0:	1a41ffe0 	cmpeqi	r9,r3,2047
 40167d4:	48000d26 	beq	r9,zero,401680c <__gedf2+0xa0>
 40167d8:	3992b03a 	or	r9,r7,r6
 40167dc:	48001a1e 	bne	r9,zero,4016848 <__gedf2+0xdc>
 40167e0:	40000526 	beq	r8,zero,40167f8 <__gedf2+0x8c>
 40167e4:	58800d26 	beq	r11,r2,401681c <__gedf2+0xb0>
 40167e8:	00800044 	movi	r2,1
 40167ec:	58000626 	beq	r11,zero,4016808 <__gedf2+0x9c>
 40167f0:	00bfffc4 	movi	r2,-1
 40167f4:	f800283a 	ret
 40167f8:	2912b03a 	or	r9,r5,r4
 40167fc:	4813003a 	cmpeq	r9,r9,zero
 4016800:	483ff826 	beq	r9,zero,40167e4 <__gedf2+0x78>
 4016804:	103ffa26 	beq	r2,zero,40167f0 <__gedf2+0x84>
 4016808:	f800283a 	ret
 401680c:	183ff51e 	bne	r3,zero,40167e4 <__gedf2+0x78>
 4016810:	3992b03a 	or	r9,r7,r6
 4016814:	483ff31e 	bne	r9,zero,40167e4 <__gedf2+0x78>
 4016818:	003ff306 	br	40167e8 <__gedf2+0x7c>
 401681c:	1a000716 	blt	r3,r8,401683c <__gedf2+0xd0>
 4016820:	40fff816 	blt	r8,r3,4016804 <__gedf2+0x98>
 4016824:	397ff036 	bltu	r7,r5,40167e8 <__gedf2+0x7c>
 4016828:	29c00926 	beq	r5,r7,4016850 <__gedf2+0xe4>
 401682c:	29ffe42e 	bgeu	r5,r7,40167c0 <__gedf2+0x54>
 4016830:	583fef26 	beq	r11,zero,40167f0 <__gedf2+0x84>
 4016834:	5805883a 	mov	r2,r11
 4016838:	f800283a 	ret
 401683c:	103fec1e 	bne	r2,zero,40167f0 <__gedf2+0x84>
 4016840:	00800044 	movi	r2,1
 4016844:	f800283a 	ret
 4016848:	00bfff84 	movi	r2,-2
 401684c:	f800283a 	ret
 4016850:	313fe536 	bltu	r6,r4,40167e8 <__gedf2+0x7c>
 4016854:	21bfda2e 	bgeu	r4,r6,40167c0 <__gedf2+0x54>
 4016858:	003ff506 	br	4016830 <__gedf2+0xc4>

0401685c <__ledf2>:
 401685c:	2810d53a 	srli	r8,r5,20
 4016860:	3812d53a 	srli	r9,r7,20
 4016864:	00c00434 	movhi	r3,16
 4016868:	4201ffcc 	andi	r8,r8,2047
 401686c:	18ffffc4 	addi	r3,r3,-1
 4016870:	4281ffd8 	cmpnei	r10,r8,2047
 4016874:	2816d7fa 	srli	r11,r5,31
 4016878:	3804d7fa 	srli	r2,r7,31
 401687c:	28ca703a 	and	r5,r5,r3
 4016880:	38ce703a 	and	r7,r7,r3
 4016884:	48c1ffcc 	andi	r3,r9,2047
 4016888:	50000b26 	beq	r10,zero,40168b8 <__ledf2+0x5c>
 401688c:	1a41ffd8 	cmpnei	r9,r3,2047
 4016890:	48000d26 	beq	r9,zero,40168c8 <__ledf2+0x6c>
 4016894:	40001b1e 	bne	r8,zero,4016904 <__ledf2+0xa8>
 4016898:	2914b03a 	or	r10,r5,r4
 401689c:	5013003a 	cmpeq	r9,r10,zero
 40168a0:	18000e1e 	bne	r3,zero,40168dc <__ledf2+0x80>
 40168a4:	3998b03a 	or	r12,r7,r6
 40168a8:	60000c1e 	bne	r12,zero,40168dc <__ledf2+0x80>
 40168ac:	50000d1e 	bne	r10,zero,40168e4 <__ledf2+0x88>
 40168b0:	0005883a 	mov	r2,zero
 40168b4:	f800283a 	ret
 40168b8:	2912b03a 	or	r9,r5,r4
 40168bc:	48000d1e 	bne	r9,zero,40168f4 <__ledf2+0x98>
 40168c0:	1a41ffe0 	cmpeqi	r9,r3,2047
 40168c4:	48000f26 	beq	r9,zero,4016904 <__ledf2+0xa8>
 40168c8:	3992b03a 	or	r9,r7,r6
 40168cc:	4800091e 	bne	r9,zero,40168f4 <__ledf2+0x98>
 40168d0:	4000031e 	bne	r8,zero,40168e0 <__ledf2+0x84>
 40168d4:	2912b03a 	or	r9,r5,r4
 40168d8:	4813003a 	cmpeq	r9,r9,zero
 40168dc:	4800071e 	bne	r9,zero,40168fc <__ledf2+0xa0>
 40168e0:	58800c26 	beq	r11,r2,4016914 <__ledf2+0xb8>
 40168e4:	00800044 	movi	r2,1
 40168e8:	58000526 	beq	r11,zero,4016900 <__ledf2+0xa4>
 40168ec:	00bfffc4 	movi	r2,-1
 40168f0:	f800283a 	ret
 40168f4:	00800084 	movi	r2,2
 40168f8:	f800283a 	ret
 40168fc:	103ffb26 	beq	r2,zero,40168ec <__ledf2+0x90>
 4016900:	f800283a 	ret
 4016904:	183ff61e 	bne	r3,zero,40168e0 <__ledf2+0x84>
 4016908:	3992b03a 	or	r9,r7,r6
 401690c:	483ff41e 	bne	r9,zero,40168e0 <__ledf2+0x84>
 4016910:	003ff406 	br	40168e4 <__ledf2+0x88>
 4016914:	1a00030e 	bge	r3,r8,4016924 <__ledf2+0xc8>
 4016918:	103ff41e 	bne	r2,zero,40168ec <__ledf2+0x90>
 401691c:	00800044 	movi	r2,1
 4016920:	f800283a 	ret
 4016924:	40fff516 	blt	r8,r3,40168fc <__ledf2+0xa0>
 4016928:	397fee36 	bltu	r7,r5,40168e4 <__ledf2+0x88>
 401692c:	29c00426 	beq	r5,r7,4016940 <__ledf2+0xe4>
 4016930:	29ffdf2e 	bgeu	r5,r7,40168b0 <__ledf2+0x54>
 4016934:	583fed26 	beq	r11,zero,40168ec <__ledf2+0x90>
 4016938:	5805883a 	mov	r2,r11
 401693c:	f800283a 	ret
 4016940:	313fe836 	bltu	r6,r4,40168e4 <__ledf2+0x88>
 4016944:	21bfda2e 	bgeu	r4,r6,40168b0 <__ledf2+0x54>
 4016948:	003ffa06 	br	4016934 <__ledf2+0xd8>

0401694c <__muldf3>:
 401694c:	2810d53a 	srli	r8,r5,20
 4016950:	defff004 	addi	sp,sp,-64
 4016954:	00800434 	movhi	r2,16
 4016958:	df000e15 	stw	fp,56(sp)
 401695c:	dd000a15 	stw	r20,40(sp)
 4016960:	dcc00915 	stw	r19,36(sp)
 4016964:	dc400715 	stw	r17,28(sp)
 4016968:	10bfffc4 	addi	r2,r2,-1
 401696c:	dfc00f15 	stw	ra,60(sp)
 4016970:	ddc00d15 	stw	r23,52(sp)
 4016974:	dd800c15 	stw	r22,48(sp)
 4016978:	dd400b15 	stw	r21,44(sp)
 401697c:	dc800815 	stw	r18,32(sp)
 4016980:	dc000615 	stw	r16,24(sp)
 4016984:	4201ffcc 	andi	r8,r8,2047
 4016988:	2828d7fa 	srli	r20,r5,31
 401698c:	2023883a 	mov	r17,r4
 4016990:	3039883a 	mov	fp,r6
 4016994:	28a6703a 	and	r19,r5,r2
 4016998:	40005a26 	beq	r8,zero,4016b04 <__muldf3+0x1b8>
 401699c:	4081ffe0 	cmpeqi	r2,r8,2047
 40169a0:	10006c1e 	bne	r2,zero,4016b54 <__muldf3+0x208>
 40169a4:	980a90fa 	slli	r5,r19,3
 40169a8:	2026d77a 	srli	r19,r4,29
 40169ac:	202490fa 	slli	r18,r4,3
 40169b0:	423f0044 	addi	r8,r8,-1023
 40169b4:	9966b03a 	or	r19,r19,r5
 40169b8:	9cc02034 	orhi	r19,r19,128
 40169bc:	002b883a 	mov	r21,zero
 40169c0:	002d883a 	mov	r22,zero
 40169c4:	3804d53a 	srli	r2,r7,20
 40169c8:	00c00434 	movhi	r3,16
 40169cc:	18ffffc4 	addi	r3,r3,-1
 40169d0:	1081ffcc 	andi	r2,r2,2047
 40169d4:	382ed7fa 	srli	r23,r7,31
 40169d8:	38e0703a 	and	r16,r7,r3
 40169dc:	10006426 	beq	r2,zero,4016b70 <__muldf3+0x224>
 40169e0:	10c1ffe0 	cmpeqi	r3,r2,2047
 40169e4:	1800211e 	bne	r3,zero,4016a6c <__muldf3+0x120>
 40169e8:	e008d77a 	srli	r4,fp,29
 40169ec:	802090fa 	slli	r16,r16,3
 40169f0:	e02290fa 	slli	r17,fp,3
 40169f4:	10bf0044 	addi	r2,r2,-1023
 40169f8:	2420b03a 	or	r16,r4,r16
 40169fc:	84002034 	orhi	r16,r16,128
 4016a00:	4091883a 	add	r8,r8,r2
 4016a04:	0009883a 	mov	r4,zero
 4016a08:	a8800428 	cmpgeui	r2,r21,16
 4016a0c:	a5ccf03a 	xor	r6,r20,r23
 4016a10:	41c00044 	addi	r7,r8,1
 4016a14:	10006d1e 	bne	r2,zero,4016bcc <__muldf3+0x280>
 4016a18:	a80490ba 	slli	r2,r21,2
 4016a1c:	00c10074 	movhi	r3,1025
 4016a20:	10c7883a 	add	r3,r2,r3
 4016a24:	189a8b17 	ldw	r2,27180(r3)
 4016a28:	1000683a 	jmp	r2
 4016a2c:	04016bcc 	andi	r16,zero,1455
 4016a30:	04016a8c 	andi	r16,zero,1450
 4016a34:	04016a8c 	andi	r16,zero,1450
 4016a38:	04016a88 	cmpgei	r16,zero,1450
 4016a3c:	04016a98 	cmpnei	r16,zero,1450
 4016a40:	04016a98 	cmpnei	r16,zero,1450
 4016a44:	04016f48 	cmpgei	r16,zero,1469
 4016a48:	04016a88 	cmpgei	r16,zero,1450
 4016a4c:	04016a98 	cmpnei	r16,zero,1450
 4016a50:	04016f48 	cmpgei	r16,zero,1469
 4016a54:	04016a98 	cmpnei	r16,zero,1450
 4016a58:	04016a88 	cmpgei	r16,zero,1450
 4016a5c:	04016ef8 	rdprs	r16,zero,1467
 4016a60:	04016ef8 	rdprs	r16,zero,1467
 4016a64:	04016ef8 	rdprs	r16,zero,1467
 4016a68:	04016fd4 	movui	r16,1471
 4016a6c:	e422b03a 	or	r17,fp,r16
 4016a70:	4201ffc4 	addi	r8,r8,2047
 4016a74:	8801221e 	bne	r17,zero,4016f00 <__muldf3+0x5b4>
 4016a78:	ad400094 	ori	r21,r21,2
 4016a7c:	0021883a 	mov	r16,zero
 4016a80:	01000084 	movi	r4,2
 4016a84:	003fe006 	br	4016a08 <__muldf3+0xbc>
 4016a88:	b80d883a 	mov	r6,r23
 4016a8c:	8027883a 	mov	r19,r16
 4016a90:	8825883a 	mov	r18,r17
 4016a94:	202d883a 	mov	r22,r4
 4016a98:	b08000a0 	cmpeqi	r2,r22,2
 4016a9c:	1000471e 	bne	r2,zero,4016bbc <__muldf3+0x270>
 4016aa0:	b08000e0 	cmpeqi	r2,r22,3
 4016aa4:	10018e1e 	bne	r2,zero,40170e0 <__muldf3+0x794>
 4016aa8:	b0800060 	cmpeqi	r2,r22,1
 4016aac:	1000f826 	beq	r2,zero,4016e90 <__muldf3+0x544>
 4016ab0:	0007883a 	mov	r3,zero
 4016ab4:	0027883a 	mov	r19,zero
 4016ab8:	0025883a 	mov	r18,zero
 4016abc:	1806953a 	slli	r3,r3,20
 4016ac0:	31803fcc 	andi	r6,r6,255
 4016ac4:	300c97fa 	slli	r6,r6,31
 4016ac8:	1cc6b03a 	or	r3,r3,r19
 4016acc:	9005883a 	mov	r2,r18
 4016ad0:	1986b03a 	or	r3,r3,r6
 4016ad4:	dfc00f17 	ldw	ra,60(sp)
 4016ad8:	df000e17 	ldw	fp,56(sp)
 4016adc:	ddc00d17 	ldw	r23,52(sp)
 4016ae0:	dd800c17 	ldw	r22,48(sp)
 4016ae4:	dd400b17 	ldw	r21,44(sp)
 4016ae8:	dd000a17 	ldw	r20,40(sp)
 4016aec:	dcc00917 	ldw	r19,36(sp)
 4016af0:	dc800817 	ldw	r18,32(sp)
 4016af4:	dc400717 	ldw	r17,28(sp)
 4016af8:	dc000617 	ldw	r16,24(sp)
 4016afc:	dec01004 	addi	sp,sp,64
 4016b00:	f800283a 	ret
 4016b04:	9924b03a 	or	r18,r19,r4
 4016b08:	90010a26 	beq	r18,zero,4016f34 <__muldf3+0x5e8>
 4016b0c:	d9c00015 	stw	r7,0(sp)
 4016b10:	98014d26 	beq	r19,zero,4017048 <__muldf3+0x6fc>
 4016b14:	9809883a 	mov	r4,r19
 4016b18:	4017c480 	call	4017c48 <__clzsi2>
 4016b1c:	d9c00017 	ldw	r7,0(sp)
 4016b20:	113ffd44 	addi	r4,r2,-11
 4016b24:	00c00744 	movi	r3,29
 4016b28:	14bffe04 	addi	r18,r2,-8
 4016b2c:	1907c83a 	sub	r3,r3,r4
 4016b30:	9ca6983a 	sll	r19,r19,r18
 4016b34:	88c6d83a 	srl	r3,r17,r3
 4016b38:	8ca4983a 	sll	r18,r17,r18
 4016b3c:	1ce6b03a 	or	r19,r3,r19
 4016b40:	023f0344 	movi	r8,-1011
 4016b44:	4091c83a 	sub	r8,r8,r2
 4016b48:	002b883a 	mov	r21,zero
 4016b4c:	002d883a 	mov	r22,zero
 4016b50:	003f9c06 	br	40169c4 <__muldf3+0x78>
 4016b54:	9924b03a 	or	r18,r19,r4
 4016b58:	9000f11e 	bne	r18,zero,4016f20 <__muldf3+0x5d4>
 4016b5c:	0027883a 	mov	r19,zero
 4016b60:	05400204 	movi	r21,8
 4016b64:	0201ffc4 	movi	r8,2047
 4016b68:	05800084 	movi	r22,2
 4016b6c:	003f9506 	br	40169c4 <__muldf3+0x78>
 4016b70:	e422b03a 	or	r17,fp,r16
 4016b74:	8800e626 	beq	r17,zero,4016f10 <__muldf3+0x5c4>
 4016b78:	da000015 	stw	r8,0(sp)
 4016b7c:	80012626 	beq	r16,zero,4017018 <__muldf3+0x6cc>
 4016b80:	8009883a 	mov	r4,r16
 4016b84:	4017c480 	call	4017c48 <__clzsi2>
 4016b88:	da000017 	ldw	r8,0(sp)
 4016b8c:	117ffd44 	addi	r5,r2,-11
 4016b90:	01000744 	movi	r4,29
 4016b94:	147ffe04 	addi	r17,r2,-8
 4016b98:	2149c83a 	sub	r4,r4,r5
 4016b9c:	8460983a 	sll	r16,r16,r17
 4016ba0:	e108d83a 	srl	r4,fp,r4
 4016ba4:	e462983a 	sll	r17,fp,r17
 4016ba8:	2420b03a 	or	r16,r4,r16
 4016bac:	4091c83a 	sub	r8,r8,r2
 4016bb0:	423f0344 	addi	r8,r8,-1011
 4016bb4:	0009883a 	mov	r4,zero
 4016bb8:	003f9306 	br	4016a08 <__muldf3+0xbc>
 4016bbc:	00c1ffc4 	movi	r3,2047
 4016bc0:	0027883a 	mov	r19,zero
 4016bc4:	0025883a 	mov	r18,zero
 4016bc8:	003fbc06 	br	4016abc <__muldf3+0x170>
 4016bcc:	9028d43a 	srli	r20,r18,16
 4016bd0:	8f3fffcc 	andi	fp,r17,65535
 4016bd4:	957fffcc 	andi	r21,r18,65535
 4016bd8:	a80b883a 	mov	r5,r21
 4016bdc:	e009883a 	mov	r4,fp
 4016be0:	d9800315 	stw	r6,12(sp)
 4016be4:	da000215 	stw	r8,8(sp)
 4016be8:	d9c00115 	stw	r7,4(sp)
 4016bec:	8822d43a 	srli	r17,r17,16
 4016bf0:	40072d80 	call	40072d8 <__mulsi3>
 4016bf4:	e00b883a 	mov	r5,fp
 4016bf8:	a009883a 	mov	r4,r20
 4016bfc:	102d883a 	mov	r22,r2
 4016c00:	40072d80 	call	40072d8 <__mulsi3>
 4016c04:	880b883a 	mov	r5,r17
 4016c08:	a009883a 	mov	r4,r20
 4016c0c:	102f883a 	mov	r23,r2
 4016c10:	40072d80 	call	40072d8 <__mulsi3>
 4016c14:	a80b883a 	mov	r5,r21
 4016c18:	8809883a 	mov	r4,r17
 4016c1c:	d8800015 	stw	r2,0(sp)
 4016c20:	40072d80 	call	40072d8 <__mulsi3>
 4016c24:	b006d43a 	srli	r3,r22,16
 4016c28:	15e5883a 	add	r18,r2,r23
 4016c2c:	d9c00117 	ldw	r7,4(sp)
 4016c30:	1c87883a 	add	r3,r3,r18
 4016c34:	da000217 	ldw	r8,8(sp)
 4016c38:	d9800317 	ldw	r6,12(sp)
 4016c3c:	1dc0042e 	bgeu	r3,r23,4016c50 <__muldf3+0x304>
 4016c40:	d9000017 	ldw	r4,0(sp)
 4016c44:	00800074 	movhi	r2,1
 4016c48:	2085883a 	add	r2,r4,r2
 4016c4c:	d8800015 	stw	r2,0(sp)
 4016c50:	1804943a 	slli	r2,r3,16
 4016c54:	85ffffcc 	andi	r23,r16,65535
 4016c58:	b5bfffcc 	andi	r22,r22,65535
 4016c5c:	1585883a 	add	r2,r2,r22
 4016c60:	a80b883a 	mov	r5,r21
 4016c64:	b809883a 	mov	r4,r23
 4016c68:	1824d43a 	srli	r18,r3,16
 4016c6c:	d9800515 	stw	r6,20(sp)
 4016c70:	da000415 	stw	r8,16(sp)
 4016c74:	d9c00315 	stw	r7,12(sp)
 4016c78:	8020d43a 	srli	r16,r16,16
 4016c7c:	d8800115 	stw	r2,4(sp)
 4016c80:	40072d80 	call	40072d8 <__mulsi3>
 4016c84:	a009883a 	mov	r4,r20
 4016c88:	b80b883a 	mov	r5,r23
 4016c8c:	d8800215 	stw	r2,8(sp)
 4016c90:	40072d80 	call	40072d8 <__mulsi3>
 4016c94:	a009883a 	mov	r4,r20
 4016c98:	800b883a 	mov	r5,r16
 4016c9c:	102d883a 	mov	r22,r2
 4016ca0:	40072d80 	call	40072d8 <__mulsi3>
 4016ca4:	a80b883a 	mov	r5,r21
 4016ca8:	8009883a 	mov	r4,r16
 4016cac:	1029883a 	mov	r20,r2
 4016cb0:	40072d80 	call	40072d8 <__mulsi3>
 4016cb4:	da800217 	ldw	r10,8(sp)
 4016cb8:	1585883a 	add	r2,r2,r22
 4016cbc:	d9c00317 	ldw	r7,12(sp)
 4016cc0:	5006d43a 	srli	r3,r10,16
 4016cc4:	da000417 	ldw	r8,16(sp)
 4016cc8:	d9800517 	ldw	r6,20(sp)
 4016ccc:	1887883a 	add	r3,r3,r2
 4016cd0:	1d80022e 	bgeu	r3,r22,4016cdc <__muldf3+0x390>
 4016cd4:	00800074 	movhi	r2,1
 4016cd8:	a0a9883a 	add	r20,r20,r2
 4016cdc:	1804d43a 	srli	r2,r3,16
 4016ce0:	1806943a 	slli	r3,r3,16
 4016ce4:	982cd43a 	srli	r22,r19,16
 4016ce8:	9d7fffcc 	andi	r21,r19,65535
 4016cec:	e009883a 	mov	r4,fp
 4016cf0:	54ffffcc 	andi	r19,r10,65535
 4016cf4:	a80b883a 	mov	r5,r21
 4016cf8:	1ce7883a 	add	r19,r3,r19
 4016cfc:	d9800515 	stw	r6,20(sp)
 4016d00:	da000415 	stw	r8,16(sp)
 4016d04:	d9c00315 	stw	r7,12(sp)
 4016d08:	1529883a 	add	r20,r2,r20
 4016d0c:	40072d80 	call	40072d8 <__mulsi3>
 4016d10:	e00b883a 	mov	r5,fp
 4016d14:	b009883a 	mov	r4,r22
 4016d18:	d8800215 	stw	r2,8(sp)
 4016d1c:	40072d80 	call	40072d8 <__mulsi3>
 4016d20:	8809883a 	mov	r4,r17
 4016d24:	b00b883a 	mov	r5,r22
 4016d28:	1039883a 	mov	fp,r2
 4016d2c:	40072d80 	call	40072d8 <__mulsi3>
 4016d30:	8809883a 	mov	r4,r17
 4016d34:	a80b883a 	mov	r5,r21
 4016d38:	1023883a 	mov	r17,r2
 4016d3c:	40072d80 	call	40072d8 <__mulsi3>
 4016d40:	d8c00217 	ldw	r3,8(sp)
 4016d44:	1705883a 	add	r2,r2,fp
 4016d48:	d9c00317 	ldw	r7,12(sp)
 4016d4c:	1808d43a 	srli	r4,r3,16
 4016d50:	da000417 	ldw	r8,16(sp)
 4016d54:	d9800517 	ldw	r6,20(sp)
 4016d58:	2089883a 	add	r4,r4,r2
 4016d5c:	94e5883a 	add	r18,r18,r19
 4016d60:	2700022e 	bgeu	r4,fp,4016d6c <__muldf3+0x420>
 4016d64:	00800074 	movhi	r2,1
 4016d68:	88a3883a 	add	r17,r17,r2
 4016d6c:	2004d43a 	srli	r2,r4,16
 4016d70:	2038943a 	slli	fp,r4,16
 4016d74:	18ffffcc 	andi	r3,r3,65535
 4016d78:	b809883a 	mov	r4,r23
 4016d7c:	a80b883a 	mov	r5,r21
 4016d80:	d9800415 	stw	r6,16(sp)
 4016d84:	da000315 	stw	r8,12(sp)
 4016d88:	d9c00215 	stw	r7,8(sp)
 4016d8c:	e0f9883a 	add	fp,fp,r3
 4016d90:	1463883a 	add	r17,r2,r17
 4016d94:	40072d80 	call	40072d8 <__mulsi3>
 4016d98:	b80b883a 	mov	r5,r23
 4016d9c:	b009883a 	mov	r4,r22
 4016da0:	102f883a 	mov	r23,r2
 4016da4:	40072d80 	call	40072d8 <__mulsi3>
 4016da8:	b00b883a 	mov	r5,r22
 4016dac:	8009883a 	mov	r4,r16
 4016db0:	102d883a 	mov	r22,r2
 4016db4:	40072d80 	call	40072d8 <__mulsi3>
 4016db8:	a80b883a 	mov	r5,r21
 4016dbc:	8009883a 	mov	r4,r16
 4016dc0:	1021883a 	mov	r16,r2
 4016dc4:	40072d80 	call	40072d8 <__mulsi3>
 4016dc8:	b80ad43a 	srli	r5,r23,16
 4016dcc:	1585883a 	add	r2,r2,r22
 4016dd0:	d9c00217 	ldw	r7,8(sp)
 4016dd4:	288b883a 	add	r5,r5,r2
 4016dd8:	da000317 	ldw	r8,12(sp)
 4016ddc:	d9800417 	ldw	r6,16(sp)
 4016de0:	2d80022e 	bgeu	r5,r22,4016dec <__muldf3+0x4a0>
 4016de4:	00800074 	movhi	r2,1
 4016de8:	80a1883a 	add	r16,r16,r2
 4016dec:	2806943a 	slli	r3,r5,16
 4016df0:	d8800017 	ldw	r2,0(sp)
 4016df4:	bdffffcc 	andi	r23,r23,65535
 4016df8:	1dc7883a 	add	r3,r3,r23
 4016dfc:	90ab883a 	add	r21,r18,r2
 4016e00:	acd5803a 	cmpltu	r10,r21,r19
 4016e04:	1d07883a 	add	r3,r3,r20
 4016e08:	af2b883a 	add	r21,r21,fp
 4016e0c:	1a97883a 	add	r11,r3,r10
 4016e10:	af09803a 	cmpltu	r4,r21,fp
 4016e14:	2826d43a 	srli	r19,r5,16
 4016e18:	5c53883a 	add	r9,r11,r17
 4016e1c:	4905883a 	add	r2,r9,r4
 4016e20:	1d29803a 	cmpltu	r20,r3,r20
 4016e24:	5a95803a 	cmpltu	r10,r11,r10
 4016e28:	1109803a 	cmpltu	r4,r2,r4
 4016e2c:	a2a8b03a 	or	r20,r20,r10
 4016e30:	4c63803a 	cmpltu	r17,r9,r17
 4016e34:	a4e7883a 	add	r19,r20,r19
 4016e38:	8908b03a 	or	r4,r17,r4
 4016e3c:	a824927a 	slli	r18,r21,9
 4016e40:	d8c00117 	ldw	r3,4(sp)
 4016e44:	9927883a 	add	r19,r19,r4
 4016e48:	9c27883a 	add	r19,r19,r16
 4016e4c:	9826927a 	slli	r19,r19,9
 4016e50:	a82ad5fa 	srli	r21,r21,23
 4016e54:	100ad5fa 	srli	r5,r2,23
 4016e58:	90e4b03a 	or	r18,r18,r3
 4016e5c:	1004927a 	slli	r2,r2,9
 4016e60:	9024c03a 	cmpne	r18,r18,zero
 4016e64:	9564b03a 	or	r18,r18,r21
 4016e68:	98c0402c 	andhi	r3,r19,256
 4016e6c:	90a4b03a 	or	r18,r18,r2
 4016e70:	9966b03a 	or	r19,r19,r5
 4016e74:	18007f26 	beq	r3,zero,4017074 <__muldf3+0x728>
 4016e78:	9006d07a 	srli	r3,r18,1
 4016e7c:	980497fa 	slli	r2,r19,31
 4016e80:	9480004c 	andi	r18,r18,1
 4016e84:	9826d07a 	srli	r19,r19,1
 4016e88:	1c86b03a 	or	r3,r3,r18
 4016e8c:	18a4b03a 	or	r18,r3,r2
 4016e90:	3900ffc4 	addi	r4,r7,1023
 4016e94:	0100320e 	bge	zero,r4,4016f60 <__muldf3+0x614>
 4016e98:	908001cc 	andi	r2,r18,7
 4016e9c:	10000726 	beq	r2,zero,4016ebc <__muldf3+0x570>
 4016ea0:	908003cc 	andi	r2,r18,15
 4016ea4:	10800120 	cmpeqi	r2,r2,4
 4016ea8:	1000041e 	bne	r2,zero,4016ebc <__muldf3+0x570>
 4016eac:	90800104 	addi	r2,r18,4
 4016eb0:	14a5803a 	cmpltu	r18,r2,r18
 4016eb4:	9ca7883a 	add	r19,r19,r18
 4016eb8:	1025883a 	mov	r18,r2
 4016ebc:	9880402c 	andhi	r2,r19,256
 4016ec0:	10000426 	beq	r2,zero,4016ed4 <__muldf3+0x588>
 4016ec4:	00bfc034 	movhi	r2,65280
 4016ec8:	10bfffc4 	addi	r2,r2,-1
 4016ecc:	98a6703a 	and	r19,r19,r2
 4016ed0:	39010004 	addi	r4,r7,1024
 4016ed4:	2081ffc8 	cmpgei	r2,r4,2047
 4016ed8:	103f381e 	bne	r2,zero,4016bbc <__muldf3+0x270>
 4016edc:	9804977a 	slli	r2,r19,29
 4016ee0:	9024d0fa 	srli	r18,r18,3
 4016ee4:	9826927a 	slli	r19,r19,9
 4016ee8:	20c1ffcc 	andi	r3,r4,2047
 4016eec:	14a4b03a 	or	r18,r2,r18
 4016ef0:	9826d33a 	srli	r19,r19,12
 4016ef4:	003ef106 	br	4016abc <__muldf3+0x170>
 4016ef8:	a00d883a 	mov	r6,r20
 4016efc:	003ee606 	br	4016a98 <__muldf3+0x14c>
 4016f00:	ad4000d4 	ori	r21,r21,3
 4016f04:	e023883a 	mov	r17,fp
 4016f08:	010000c4 	movi	r4,3
 4016f0c:	003ebe06 	br	4016a08 <__muldf3+0xbc>
 4016f10:	ad400054 	ori	r21,r21,1
 4016f14:	0021883a 	mov	r16,zero
 4016f18:	01000044 	movi	r4,1
 4016f1c:	003eba06 	br	4016a08 <__muldf3+0xbc>
 4016f20:	2025883a 	mov	r18,r4
 4016f24:	05400304 	movi	r21,12
 4016f28:	0201ffc4 	movi	r8,2047
 4016f2c:	058000c4 	movi	r22,3
 4016f30:	003ea406 	br	40169c4 <__muldf3+0x78>
 4016f34:	0027883a 	mov	r19,zero
 4016f38:	05400104 	movi	r21,4
 4016f3c:	0011883a 	mov	r8,zero
 4016f40:	05800044 	movi	r22,1
 4016f44:	003e9f06 	br	40169c4 <__muldf3+0x78>
 4016f48:	04c00434 	movhi	r19,16
 4016f4c:	000d883a 	mov	r6,zero
 4016f50:	9cffffc4 	addi	r19,r19,-1
 4016f54:	04bfffc4 	movi	r18,-1
 4016f58:	00c1ffc4 	movi	r3,2047
 4016f5c:	003ed706 	br	4016abc <__muldf3+0x170>
 4016f60:	00800044 	movi	r2,1
 4016f64:	1105c83a 	sub	r2,r2,r4
 4016f68:	10c00e48 	cmpgei	r3,r2,57
 4016f6c:	183ed01e 	bne	r3,zero,4016ab0 <__muldf3+0x164>
 4016f70:	10c00808 	cmpgei	r3,r2,32
 4016f74:	1800411e 	bne	r3,zero,401707c <__muldf3+0x730>
 4016f78:	39c10784 	addi	r7,r7,1054
 4016f7c:	99c6983a 	sll	r3,r19,r7
 4016f80:	9088d83a 	srl	r4,r18,r2
 4016f84:	91ce983a 	sll	r7,r18,r7
 4016f88:	98a6d83a 	srl	r19,r19,r2
 4016f8c:	1904b03a 	or	r2,r3,r4
 4016f90:	3824c03a 	cmpne	r18,r7,zero
 4016f94:	1484b03a 	or	r2,r2,r18
 4016f98:	10c001cc 	andi	r3,r2,7
 4016f9c:	18000726 	beq	r3,zero,4016fbc <__muldf3+0x670>
 4016fa0:	10c003cc 	andi	r3,r2,15
 4016fa4:	18c00120 	cmpeqi	r3,r3,4
 4016fa8:	1800041e 	bne	r3,zero,4016fbc <__muldf3+0x670>
 4016fac:	10c00104 	addi	r3,r2,4
 4016fb0:	1885803a 	cmpltu	r2,r3,r2
 4016fb4:	98a7883a 	add	r19,r19,r2
 4016fb8:	1805883a 	mov	r2,r3
 4016fbc:	98c0202c 	andhi	r3,r19,128
 4016fc0:	18004326 	beq	r3,zero,40170d0 <__muldf3+0x784>
 4016fc4:	00c00044 	movi	r3,1
 4016fc8:	0027883a 	mov	r19,zero
 4016fcc:	0025883a 	mov	r18,zero
 4016fd0:	003eba06 	br	4016abc <__muldf3+0x170>
 4016fd4:	9880022c 	andhi	r2,r19,8
 4016fd8:	10000926 	beq	r2,zero,4017000 <__muldf3+0x6b4>
 4016fdc:	8080022c 	andhi	r2,r16,8
 4016fe0:	1000071e 	bne	r2,zero,4017000 <__muldf3+0x6b4>
 4016fe4:	00800434 	movhi	r2,16
 4016fe8:	84c00234 	orhi	r19,r16,8
 4016fec:	10bfffc4 	addi	r2,r2,-1
 4016ff0:	98a6703a 	and	r19,r19,r2
 4016ff4:	b80d883a 	mov	r6,r23
 4016ff8:	8825883a 	mov	r18,r17
 4016ffc:	003fd606 	br	4016f58 <__muldf3+0x60c>
 4017000:	00800434 	movhi	r2,16
 4017004:	9cc00234 	orhi	r19,r19,8
 4017008:	10bfffc4 	addi	r2,r2,-1
 401700c:	98a6703a 	and	r19,r19,r2
 4017010:	a00d883a 	mov	r6,r20
 4017014:	003fd006 	br	4016f58 <__muldf3+0x60c>
 4017018:	e009883a 	mov	r4,fp
 401701c:	4017c480 	call	4017c48 <__clzsi2>
 4017020:	11400544 	addi	r5,r2,21
 4017024:	29000748 	cmpgei	r4,r5,29
 4017028:	1007883a 	mov	r3,r2
 401702c:	da000017 	ldw	r8,0(sp)
 4017030:	10800804 	addi	r2,r2,32
 4017034:	203ed626 	beq	r4,zero,4016b90 <__muldf3+0x244>
 4017038:	1c3ffe04 	addi	r16,r3,-8
 401703c:	e420983a 	sll	r16,fp,r16
 4017040:	0023883a 	mov	r17,zero
 4017044:	003ed906 	br	4016bac <__muldf3+0x260>
 4017048:	4017c480 	call	4017c48 <__clzsi2>
 401704c:	11000544 	addi	r4,r2,21
 4017050:	21400748 	cmpgei	r5,r4,29
 4017054:	1007883a 	mov	r3,r2
 4017058:	d9c00017 	ldw	r7,0(sp)
 401705c:	10800804 	addi	r2,r2,32
 4017060:	283eb026 	beq	r5,zero,4016b24 <__muldf3+0x1d8>
 4017064:	1cfffe04 	addi	r19,r3,-8
 4017068:	8ce6983a 	sll	r19,r17,r19
 401706c:	0025883a 	mov	r18,zero
 4017070:	003eb306 	br	4016b40 <__muldf3+0x1f4>
 4017074:	400f883a 	mov	r7,r8
 4017078:	003f8506 	br	4016e90 <__muldf3+0x544>
 401707c:	00fff844 	movi	r3,-31
 4017080:	1907c83a 	sub	r3,r3,r4
 4017084:	10800820 	cmpeqi	r2,r2,32
 4017088:	98c6d83a 	srl	r3,r19,r3
 401708c:	1000031e 	bne	r2,zero,401709c <__muldf3+0x750>
 4017090:	39c10f84 	addi	r7,r7,1086
 4017094:	99e6983a 	sll	r19,r19,r7
 4017098:	94e4b03a 	or	r18,r18,r19
 401709c:	9024c03a 	cmpne	r18,r18,zero
 40170a0:	90c4b03a 	or	r2,r18,r3
 40170a4:	148001cc 	andi	r18,r2,7
 40170a8:	9000051e 	bne	r18,zero,40170c0 <__muldf3+0x774>
 40170ac:	0027883a 	mov	r19,zero
 40170b0:	1004d0fa 	srli	r2,r2,3
 40170b4:	0007883a 	mov	r3,zero
 40170b8:	14a4b03a 	or	r18,r2,r18
 40170bc:	003e7f06 	br	4016abc <__muldf3+0x170>
 40170c0:	10c003cc 	andi	r3,r2,15
 40170c4:	18c00118 	cmpnei	r3,r3,4
 40170c8:	0027883a 	mov	r19,zero
 40170cc:	183fb71e 	bne	r3,zero,4016fac <__muldf3+0x660>
 40170d0:	9806927a 	slli	r3,r19,9
 40170d4:	9824977a 	slli	r18,r19,29
 40170d8:	1826d33a 	srli	r19,r3,12
 40170dc:	003ff406 	br	40170b0 <__muldf3+0x764>
 40170e0:	00800434 	movhi	r2,16
 40170e4:	9cc00234 	orhi	r19,r19,8
 40170e8:	10bfffc4 	addi	r2,r2,-1
 40170ec:	98a6703a 	and	r19,r19,r2
 40170f0:	003f9906 	br	4016f58 <__muldf3+0x60c>

040170f4 <__subdf3>:
 40170f4:	00c00434 	movhi	r3,16
 40170f8:	3812d53a 	srli	r9,r7,20
 40170fc:	18ffffc4 	addi	r3,r3,-1
 4017100:	defffb04 	addi	sp,sp,-20
 4017104:	28d0703a 	and	r8,r5,r3
 4017108:	38c6703a 	and	r3,r7,r3
 401710c:	2804d7fa 	srli	r2,r5,31
 4017110:	401090fa 	slli	r8,r8,3
 4017114:	280ad53a 	srli	r5,r5,20
 4017118:	180690fa 	slli	r3,r3,3
 401711c:	dcc00315 	stw	r19,12(sp)
 4017120:	dc400115 	stw	r17,4(sp)
 4017124:	2026d77a 	srli	r19,r4,29
 4017128:	3022d77a 	srli	r17,r6,29
 401712c:	4b41ffcc 	andi	r13,r9,2047
 4017130:	dc800215 	stw	r18,8(sp)
 4017134:	dc000015 	stw	r16,0(sp)
 4017138:	dfc00415 	stw	ra,16(sp)
 401713c:	6a41ffe0 	cmpeqi	r9,r13,2047
 4017140:	1025883a 	mov	r18,r2
 4017144:	201690fa 	slli	r11,r4,3
 4017148:	380ed7fa 	srli	r7,r7,31
 401714c:	301490fa 	slli	r10,r6,3
 4017150:	2c01ffcc 	andi	r16,r5,2047
 4017154:	10803fcc 	andi	r2,r2,255
 4017158:	9a10b03a 	or	r8,r19,r8
 401715c:	88c6b03a 	or	r3,r17,r3
 4017160:	48006e1e 	bne	r9,zero,401731c <__subdf3+0x228>
 4017164:	3a40005c 	xori	r9,r7,1
 4017168:	834bc83a 	sub	r5,r16,r13
 401716c:	12405726 	beq	r2,r9,40172cc <__subdf3+0x1d8>
 4017170:	01406f0e 	bge	zero,r5,4017330 <__subdf3+0x23c>
 4017174:	68007a26 	beq	r13,zero,4017360 <__subdf3+0x26c>
 4017178:	8081ffd8 	cmpnei	r2,r16,2047
 401717c:	10019f26 	beq	r2,zero,40177fc <__subdf3+0x708>
 4017180:	18c02034 	orhi	r3,r3,128
 4017184:	28800e48 	cmpgei	r2,r5,57
 4017188:	1000f91e 	bne	r2,zero,4017570 <__subdf3+0x47c>
 401718c:	28800808 	cmpgei	r2,r5,32
 4017190:	1001451e 	bne	r2,zero,40176a8 <__subdf3+0x5b4>
 4017194:	00800804 	movi	r2,32
 4017198:	1145c83a 	sub	r2,r2,r5
 401719c:	18a2983a 	sll	r17,r3,r2
 40171a0:	5148d83a 	srl	r4,r10,r5
 40171a4:	5084983a 	sll	r2,r10,r2
 40171a8:	1946d83a 	srl	r3,r3,r5
 40171ac:	8922b03a 	or	r17,r17,r4
 40171b0:	1004c03a 	cmpne	r2,r2,zero
 40171b4:	88a2b03a 	or	r17,r17,r2
 40171b8:	40d1c83a 	sub	r8,r8,r3
 40171bc:	5c63c83a 	sub	r17,r11,r17
 40171c0:	5c49803a 	cmpltu	r4,r11,r17
 40171c4:	4109c83a 	sub	r4,r8,r4
 40171c8:	2080202c 	andhi	r2,r4,128
 40171cc:	1000a526 	beq	r2,zero,4017464 <__subdf3+0x370>
 40171d0:	04c02034 	movhi	r19,128
 40171d4:	9cffffc4 	addi	r19,r19,-1
 40171d8:	24e6703a 	and	r19,r4,r19
 40171dc:	9800db26 	beq	r19,zero,401754c <__subdf3+0x458>
 40171e0:	9809883a 	mov	r4,r19
 40171e4:	4017c480 	call	4017c48 <__clzsi2>
 40171e8:	117ffe04 	addi	r5,r2,-8
 40171ec:	01000804 	movi	r4,32
 40171f0:	2149c83a 	sub	r4,r4,r5
 40171f4:	8906d83a 	srl	r3,r17,r4
 40171f8:	9948983a 	sll	r4,r19,r5
 40171fc:	8962983a 	sll	r17,r17,r5
 4017200:	1908b03a 	or	r4,r3,r4
 4017204:	2c00cc16 	blt	r5,r16,4017538 <__subdf3+0x444>
 4017208:	2c0bc83a 	sub	r5,r5,r16
 401720c:	28c00044 	addi	r3,r5,1
 4017210:	18800808 	cmpgei	r2,r3,32
 4017214:	1001171e 	bne	r2,zero,4017674 <__subdf3+0x580>
 4017218:	00800804 	movi	r2,32
 401721c:	10c5c83a 	sub	r2,r2,r3
 4017220:	88cad83a 	srl	r5,r17,r3
 4017224:	88a2983a 	sll	r17,r17,r2
 4017228:	2084983a 	sll	r2,r4,r2
 401722c:	20c8d83a 	srl	r4,r4,r3
 4017230:	8822c03a 	cmpne	r17,r17,zero
 4017234:	1144b03a 	or	r2,r2,r5
 4017238:	1462b03a 	or	r17,r2,r17
 401723c:	0021883a 	mov	r16,zero
 4017240:	888001cc 	andi	r2,r17,7
 4017244:	10000726 	beq	r2,zero,4017264 <__subdf3+0x170>
 4017248:	888003cc 	andi	r2,r17,15
 401724c:	10800120 	cmpeqi	r2,r2,4
 4017250:	1000041e 	bne	r2,zero,4017264 <__subdf3+0x170>
 4017254:	88c00104 	addi	r3,r17,4
 4017258:	1c63803a 	cmpltu	r17,r3,r17
 401725c:	2449883a 	add	r4,r4,r17
 4017260:	1823883a 	mov	r17,r3
 4017264:	2080202c 	andhi	r2,r4,128
 4017268:	10008026 	beq	r2,zero,401746c <__subdf3+0x378>
 401726c:	81400044 	addi	r5,r16,1
 4017270:	2881ffe0 	cmpeqi	r2,r5,2047
 4017274:	2941ffcc 	andi	r5,r5,2047
 4017278:	1000921e 	bne	r2,zero,40174c4 <__subdf3+0x3d0>
 401727c:	00bfe034 	movhi	r2,65408
 4017280:	10bfffc4 	addi	r2,r2,-1
 4017284:	2088703a 	and	r4,r4,r2
 4017288:	2006927a 	slli	r3,r4,9
 401728c:	8822d0fa 	srli	r17,r17,3
 4017290:	2004977a 	slli	r2,r4,29
 4017294:	1806d33a 	srli	r3,r3,12
 4017298:	1444b03a 	or	r2,r2,r17
 401729c:	280a953a 	slli	r5,r5,20
 40172a0:	94803fcc 	andi	r18,r18,255
 40172a4:	902497fa 	slli	r18,r18,31
 40172a8:	28c6b03a 	or	r3,r5,r3
 40172ac:	1c86b03a 	or	r3,r3,r18
 40172b0:	dfc00417 	ldw	ra,16(sp)
 40172b4:	dcc00317 	ldw	r19,12(sp)
 40172b8:	dc800217 	ldw	r18,8(sp)
 40172bc:	dc400117 	ldw	r17,4(sp)
 40172c0:	dc000017 	ldw	r16,0(sp)
 40172c4:	dec00504 	addi	sp,sp,20
 40172c8:	f800283a 	ret
 40172cc:	01402e0e 	bge	zero,r5,4017388 <__subdf3+0x294>
 40172d0:	68005526 	beq	r13,zero,4017428 <__subdf3+0x334>
 40172d4:	8081ffd8 	cmpnei	r2,r16,2047
 40172d8:	10013b26 	beq	r2,zero,40177c8 <__subdf3+0x6d4>
 40172dc:	18c02034 	orhi	r3,r3,128
 40172e0:	28800e48 	cmpgei	r2,r5,57
 40172e4:	10006d1e 	bne	r2,zero,401749c <__subdf3+0x3a8>
 40172e8:	28800808 	cmpgei	r2,r5,32
 40172ec:	10010826 	beq	r2,zero,4017710 <__subdf3+0x61c>
 40172f0:	2c7ff804 	addi	r17,r5,-32
 40172f4:	29000820 	cmpeqi	r4,r5,32
 40172f8:	1c44d83a 	srl	r2,r3,r17
 40172fc:	2000041e 	bne	r4,zero,4017310 <__subdf3+0x21c>
 4017300:	01001004 	movi	r4,64
 4017304:	214bc83a 	sub	r5,r4,r5
 4017308:	1946983a 	sll	r3,r3,r5
 401730c:	50d4b03a 	or	r10,r10,r3
 4017310:	5022c03a 	cmpne	r17,r10,zero
 4017314:	88a2b03a 	or	r17,r17,r2
 4017318:	00006206 	br	40174a4 <__subdf3+0x3b0>
 401731c:	1a98b03a 	or	r12,r3,r10
 4017320:	817e0044 	addi	r5,r16,-2047
 4017324:	6000161e 	bne	r12,zero,4017380 <__subdf3+0x28c>
 4017328:	3a40005c 	xori	r9,r7,1
 401732c:	12401626 	beq	r2,r9,4017388 <__subdf3+0x294>
 4017330:	28002e26 	beq	r5,zero,40173ec <__subdf3+0x2f8>
 4017334:	6c0bc83a 	sub	r5,r13,r16
 4017338:	4825883a 	mov	r18,r9
 401733c:	80009e1e 	bne	r16,zero,40175b8 <__subdf3+0x4c4>
 4017340:	42c4b03a 	or	r2,r8,r11
 4017344:	10010926 	beq	r2,zero,401776c <__subdf3+0x678>
 4017348:	28bfffc4 	addi	r2,r5,-1
 401734c:	10016826 	beq	r2,zero,40178f0 <__subdf3+0x7fc>
 4017350:	2941ffd8 	cmpnei	r5,r5,2047
 4017354:	28015f26 	beq	r5,zero,40178d4 <__subdf3+0x7e0>
 4017358:	100b883a 	mov	r5,r2
 401735c:	00009906 	br	40175c4 <__subdf3+0x4d0>
 4017360:	1a84b03a 	or	r2,r3,r10
 4017364:	1000b126 	beq	r2,zero,401762c <__subdf3+0x538>
 4017368:	28bfffc4 	addi	r2,r5,-1
 401736c:	10011d26 	beq	r2,zero,40177e4 <__subdf3+0x6f0>
 4017370:	2941ffd8 	cmpnei	r5,r5,2047
 4017374:	28011426 	beq	r5,zero,40177c8 <__subdf3+0x6d4>
 4017378:	100b883a 	mov	r5,r2
 401737c:	003f8106 	br	4017184 <__subdf3+0x90>
 4017380:	3a403fcc 	andi	r9,r7,255
 4017384:	11ffea1e 	bne	r2,r7,4017330 <__subdf3+0x23c>
 4017388:	28007c26 	beq	r5,zero,401757c <__subdf3+0x488>
 401738c:	6c0bc83a 	sub	r5,r13,r16
 4017390:	8000d726 	beq	r16,zero,40176f0 <__subdf3+0x5fc>
 4017394:	6881ffd8 	cmpnei	r2,r13,2047
 4017398:	10012626 	beq	r2,zero,4017834 <__subdf3+0x740>
 401739c:	42002034 	orhi	r8,r8,128
 40173a0:	28800e48 	cmpgei	r2,r5,57
 40173a4:	10012a1e 	bne	r2,zero,4017850 <__subdf3+0x75c>
 40173a8:	28800808 	cmpgei	r2,r5,32
 40173ac:	1001821e 	bne	r2,zero,40179b8 <__subdf3+0x8c4>
 40173b0:	00800804 	movi	r2,32
 40173b4:	1145c83a 	sub	r2,r2,r5
 40173b8:	40a2983a 	sll	r17,r8,r2
 40173bc:	5948d83a 	srl	r4,r11,r5
 40173c0:	5884983a 	sll	r2,r11,r2
 40173c4:	4150d83a 	srl	r8,r8,r5
 40173c8:	8922b03a 	or	r17,r17,r4
 40173cc:	1004c03a 	cmpne	r2,r2,zero
 40173d0:	88a2b03a 	or	r17,r17,r2
 40173d4:	1a07883a 	add	r3,r3,r8
 40173d8:	8aa3883a 	add	r17,r17,r10
 40173dc:	8a89803a 	cmpltu	r4,r17,r10
 40173e0:	20c9883a 	add	r4,r4,r3
 40173e4:	6821883a 	mov	r16,r13
 40173e8:	00003106 	br	40174b0 <__subdf3+0x3bc>
 40173ec:	80800044 	addi	r2,r16,1
 40173f0:	1081ff8c 	andi	r2,r2,2046
 40173f4:	1000821e 	bne	r2,zero,4017600 <__subdf3+0x50c>
 40173f8:	42ceb03a 	or	r7,r8,r11
 40173fc:	1a84b03a 	or	r2,r3,r10
 4017400:	8000e11e 	bne	r16,zero,4017788 <__subdf3+0x694>
 4017404:	38012a26 	beq	r7,zero,40178b0 <__subdf3+0x7bc>
 4017408:	1001461e 	bne	r2,zero,4017924 <__subdf3+0x830>
 401740c:	4004977a 	slli	r2,r8,29
 4017410:	00c80034 	movhi	r3,8192
 4017414:	18ffffc4 	addi	r3,r3,-1
 4017418:	20c8703a 	and	r4,r4,r3
 401741c:	4010d0fa 	srli	r8,r8,3
 4017420:	1104b03a 	or	r2,r2,r4
 4017424:	00001806 	br	4017488 <__subdf3+0x394>
 4017428:	1a84b03a 	or	r2,r3,r10
 401742c:	1000fa26 	beq	r2,zero,4017818 <__subdf3+0x724>
 4017430:	28bfffc4 	addi	r2,r5,-1
 4017434:	10000426 	beq	r2,zero,4017448 <__subdf3+0x354>
 4017438:	2941ffd8 	cmpnei	r5,r5,2047
 401743c:	28013226 	beq	r5,zero,4017908 <__subdf3+0x814>
 4017440:	100b883a 	mov	r5,r2
 4017444:	003fa606 	br	40172e0 <__subdf3+0x1ec>
 4017448:	5aa3883a 	add	r17,r11,r10
 401744c:	40c9883a 	add	r4,r8,r3
 4017450:	8ad7803a 	cmpltu	r11,r17,r11
 4017454:	22c9883a 	add	r4,r4,r11
 4017458:	2080202c 	andhi	r2,r4,128
 401745c:	10007a1e 	bne	r2,zero,4017648 <__subdf3+0x554>
 4017460:	04000044 	movi	r16,1
 4017464:	888001cc 	andi	r2,r17,7
 4017468:	103f771e 	bne	r2,zero,4017248 <__subdf3+0x154>
 401746c:	8822d0fa 	srli	r17,r17,3
 4017470:	2004977a 	slli	r2,r4,29
 4017474:	2010d0fa 	srli	r8,r4,3
 4017478:	800b883a 	mov	r5,r16
 401747c:	8884b03a 	or	r2,r17,r2
 4017480:	28c1ffe0 	cmpeqi	r3,r5,2047
 4017484:	1800241e 	bne	r3,zero,4017518 <__subdf3+0x424>
 4017488:	00c00434 	movhi	r3,16
 401748c:	18ffffc4 	addi	r3,r3,-1
 4017490:	40c6703a 	and	r3,r8,r3
 4017494:	2941ffcc 	andi	r5,r5,2047
 4017498:	003f8006 	br	401729c <__subdf3+0x1a8>
 401749c:	1aa2b03a 	or	r17,r3,r10
 40174a0:	8822c03a 	cmpne	r17,r17,zero
 40174a4:	8ae3883a 	add	r17,r17,r11
 40174a8:	8ac9803a 	cmpltu	r4,r17,r11
 40174ac:	2209883a 	add	r4,r4,r8
 40174b0:	2080202c 	andhi	r2,r4,128
 40174b4:	103feb26 	beq	r2,zero,4017464 <__subdf3+0x370>
 40174b8:	84000044 	addi	r16,r16,1
 40174bc:	8081ffe0 	cmpeqi	r2,r16,2047
 40174c0:	10006226 	beq	r2,zero,401764c <__subdf3+0x558>
 40174c4:	0141ffc4 	movi	r5,2047
 40174c8:	0007883a 	mov	r3,zero
 40174cc:	0005883a 	mov	r2,zero
 40174d0:	003f7206 	br	401729c <__subdf3+0x1a8>
 40174d4:	400e977a 	slli	r7,r8,29
 40174d8:	4010d0fa 	srli	r8,r8,3
 40174dc:	1000ef26 	beq	r2,zero,401789c <__subdf3+0x7a8>
 40174e0:	01480034 	movhi	r5,8192
 40174e4:	297fffc4 	addi	r5,r5,-1
 40174e8:	2144703a 	and	r2,r4,r5
 40174ec:	4100022c 	andhi	r4,r8,8
 40174f0:	11c4b03a 	or	r2,r2,r7
 40174f4:	20000826 	beq	r4,zero,4017518 <__subdf3+0x424>
 40174f8:	1808d0fa 	srli	r4,r3,3
 40174fc:	21c0022c 	andhi	r7,r4,8
 4017500:	3800051e 	bne	r7,zero,4017518 <__subdf3+0x424>
 4017504:	1804977a 	slli	r2,r3,29
 4017508:	314c703a 	and	r6,r6,r5
 401750c:	4825883a 	mov	r18,r9
 4017510:	3084b03a 	or	r2,r6,r2
 4017514:	2011883a 	mov	r8,r4
 4017518:	1206b03a 	or	r3,r2,r8
 401751c:	18013e26 	beq	r3,zero,4017a18 <__subdf3+0x924>
 4017520:	01000434 	movhi	r4,16
 4017524:	40c00234 	orhi	r3,r8,8
 4017528:	213fffc4 	addi	r4,r4,-1
 401752c:	1906703a 	and	r3,r3,r4
 4017530:	0141ffc4 	movi	r5,2047
 4017534:	003f5906 	br	401729c <__subdf3+0x1a8>
 4017538:	00ffe034 	movhi	r3,65408
 401753c:	18ffffc4 	addi	r3,r3,-1
 4017540:	8161c83a 	sub	r16,r16,r5
 4017544:	20c8703a 	and	r4,r4,r3
 4017548:	003f3d06 	br	4017240 <__subdf3+0x14c>
 401754c:	8809883a 	mov	r4,r17
 4017550:	4017c480 	call	4017c48 <__clzsi2>
 4017554:	11400604 	addi	r5,r2,24
 4017558:	28c00808 	cmpgei	r3,r5,32
 401755c:	183f2326 	beq	r3,zero,40171ec <__subdf3+0xf8>
 4017560:	113ffe04 	addi	r4,r2,-8
 4017564:	8908983a 	sll	r4,r17,r4
 4017568:	0023883a 	mov	r17,zero
 401756c:	003f2506 	br	4017204 <__subdf3+0x110>
 4017570:	1aa2b03a 	or	r17,r3,r10
 4017574:	8822c03a 	cmpne	r17,r17,zero
 4017578:	003f1006 	br	40171bc <__subdf3+0xc8>
 401757c:	80800044 	addi	r2,r16,1
 4017580:	11c1ff8c 	andi	r7,r2,2046
 4017584:	38006d1e 	bne	r7,zero,401773c <__subdf3+0x648>
 4017588:	42c4b03a 	or	r2,r8,r11
 401758c:	8000be1e 	bne	r16,zero,4017888 <__subdf3+0x794>
 4017590:	1000f726 	beq	r2,zero,4017970 <__subdf3+0x87c>
 4017594:	1a84b03a 	or	r2,r3,r10
 4017598:	1000fc1e 	bne	r2,zero,401798c <__subdf3+0x898>
 401759c:	4006977a 	slli	r3,r8,29
 40175a0:	00880034 	movhi	r2,8192
 40175a4:	10bfffc4 	addi	r2,r2,-1
 40175a8:	2084703a 	and	r2,r4,r2
 40175ac:	4010d0fa 	srli	r8,r8,3
 40175b0:	10c4b03a 	or	r2,r2,r3
 40175b4:	003fb406 	br	4017488 <__subdf3+0x394>
 40175b8:	6881ffd8 	cmpnei	r2,r13,2047
 40175bc:	10009d26 	beq	r2,zero,4017834 <__subdf3+0x740>
 40175c0:	42002034 	orhi	r8,r8,128
 40175c4:	28800e48 	cmpgei	r2,r5,57
 40175c8:	1000421e 	bne	r2,zero,40176d4 <__subdf3+0x5e0>
 40175cc:	28800808 	cmpgei	r2,r5,32
 40175d0:	1000a21e 	bne	r2,zero,401785c <__subdf3+0x768>
 40175d4:	00800804 	movi	r2,32
 40175d8:	1145c83a 	sub	r2,r2,r5
 40175dc:	40a2983a 	sll	r17,r8,r2
 40175e0:	5948d83a 	srl	r4,r11,r5
 40175e4:	5896983a 	sll	r11,r11,r2
 40175e8:	4150d83a 	srl	r8,r8,r5
 40175ec:	8922b03a 	or	r17,r17,r4
 40175f0:	5816c03a 	cmpne	r11,r11,zero
 40175f4:	8ae2b03a 	or	r17,r17,r11
 40175f8:	1a07c83a 	sub	r3,r3,r8
 40175fc:	00003706 	br	40176dc <__subdf3+0x5e8>
 4017600:	5aa3c83a 	sub	r17,r11,r10
 4017604:	40e7c83a 	sub	r19,r8,r3
 4017608:	5c49803a 	cmpltu	r4,r11,r17
 401760c:	9927c83a 	sub	r19,r19,r4
 4017610:	9880202c 	andhi	r2,r19,128
 4017614:	1000661e 	bne	r2,zero,40177b0 <__subdf3+0x6bc>
 4017618:	8cc4b03a 	or	r2,r17,r19
 401761c:	103eef1e 	bne	r2,zero,40171dc <__subdf3+0xe8>
 4017620:	0011883a 	mov	r8,zero
 4017624:	0025883a 	mov	r18,zero
 4017628:	003f9706 	br	4017488 <__subdf3+0x394>
 401762c:	4022977a 	slli	r17,r8,29
 4017630:	00880034 	movhi	r2,8192
 4017634:	10bfffc4 	addi	r2,r2,-1
 4017638:	2088703a 	and	r4,r4,r2
 401763c:	4010d0fa 	srli	r8,r8,3
 4017640:	2444b03a 	or	r2,r4,r17
 4017644:	003f8e06 	br	4017480 <__subdf3+0x38c>
 4017648:	04000084 	movi	r16,2
 401764c:	00bfe034 	movhi	r2,65408
 4017650:	10bfffc4 	addi	r2,r2,-1
 4017654:	8806d07a 	srli	r3,r17,1
 4017658:	2088703a 	and	r4,r4,r2
 401765c:	200497fa 	slli	r2,r4,31
 4017660:	8c40004c 	andi	r17,r17,1
 4017664:	1c62b03a 	or	r17,r3,r17
 4017668:	2008d07a 	srli	r4,r4,1
 401766c:	1462b03a 	or	r17,r2,r17
 4017670:	003ef306 	br	4017240 <__subdf3+0x14c>
 4017674:	297ff844 	addi	r5,r5,-31
 4017678:	18800820 	cmpeqi	r2,r3,32
 401767c:	214ad83a 	srl	r5,r4,r5
 4017680:	1000041e 	bne	r2,zero,4017694 <__subdf3+0x5a0>
 4017684:	00801004 	movi	r2,64
 4017688:	10c7c83a 	sub	r3,r2,r3
 401768c:	20c8983a 	sll	r4,r4,r3
 4017690:	8922b03a 	or	r17,r17,r4
 4017694:	8822c03a 	cmpne	r17,r17,zero
 4017698:	8962b03a 	or	r17,r17,r5
 401769c:	0009883a 	mov	r4,zero
 40176a0:	0021883a 	mov	r16,zero
 40176a4:	003f6f06 	br	4017464 <__subdf3+0x370>
 40176a8:	2c7ff804 	addi	r17,r5,-32
 40176ac:	29000820 	cmpeqi	r4,r5,32
 40176b0:	1c44d83a 	srl	r2,r3,r17
 40176b4:	2000041e 	bne	r4,zero,40176c8 <__subdf3+0x5d4>
 40176b8:	01001004 	movi	r4,64
 40176bc:	214bc83a 	sub	r5,r4,r5
 40176c0:	1946983a 	sll	r3,r3,r5
 40176c4:	50d4b03a 	or	r10,r10,r3
 40176c8:	5022c03a 	cmpne	r17,r10,zero
 40176cc:	88a2b03a 	or	r17,r17,r2
 40176d0:	003eba06 	br	40171bc <__subdf3+0xc8>
 40176d4:	42d0b03a 	or	r8,r8,r11
 40176d8:	4022c03a 	cmpne	r17,r8,zero
 40176dc:	5463c83a 	sub	r17,r10,r17
 40176e0:	5449803a 	cmpltu	r4,r10,r17
 40176e4:	1909c83a 	sub	r4,r3,r4
 40176e8:	6821883a 	mov	r16,r13
 40176ec:	003eb606 	br	40171c8 <__subdf3+0xd4>
 40176f0:	42c4b03a 	or	r2,r8,r11
 40176f4:	10009726 	beq	r2,zero,4017954 <__subdf3+0x860>
 40176f8:	28bfffc4 	addi	r2,r5,-1
 40176fc:	1000b926 	beq	r2,zero,40179e4 <__subdf3+0x8f0>
 4017700:	2941ffd8 	cmpnei	r5,r5,2047
 4017704:	28007326 	beq	r5,zero,40178d4 <__subdf3+0x7e0>
 4017708:	100b883a 	mov	r5,r2
 401770c:	003f2406 	br	40173a0 <__subdf3+0x2ac>
 4017710:	00800804 	movi	r2,32
 4017714:	1145c83a 	sub	r2,r2,r5
 4017718:	18a2983a 	sll	r17,r3,r2
 401771c:	5148d83a 	srl	r4,r10,r5
 4017720:	5084983a 	sll	r2,r10,r2
 4017724:	1946d83a 	srl	r3,r3,r5
 4017728:	8922b03a 	or	r17,r17,r4
 401772c:	1004c03a 	cmpne	r2,r2,zero
 4017730:	88a2b03a 	or	r17,r17,r2
 4017734:	40d1883a 	add	r8,r8,r3
 4017738:	003f5a06 	br	40174a4 <__subdf3+0x3b0>
 401773c:	1101ffe0 	cmpeqi	r4,r2,2047
 4017740:	203f601e 	bne	r4,zero,40174c4 <__subdf3+0x3d0>
 4017744:	5a95883a 	add	r10,r11,r10
 4017748:	52d7803a 	cmpltu	r11,r10,r11
 401774c:	40c9883a 	add	r4,r8,r3
 4017750:	22c9883a 	add	r4,r4,r11
 4017754:	202297fa 	slli	r17,r4,31
 4017758:	5014d07a 	srli	r10,r10,1
 401775c:	2008d07a 	srli	r4,r4,1
 4017760:	1021883a 	mov	r16,r2
 4017764:	8aa2b03a 	or	r17,r17,r10
 4017768:	003f3e06 	br	4017464 <__subdf3+0x370>
 401776c:	1808977a 	slli	r4,r3,29
 4017770:	00880034 	movhi	r2,8192
 4017774:	10bfffc4 	addi	r2,r2,-1
 4017778:	308c703a 	and	r6,r6,r2
 401777c:	1810d0fa 	srli	r8,r3,3
 4017780:	3104b03a 	or	r2,r6,r4
 4017784:	003f3e06 	br	4017480 <__subdf3+0x38c>
 4017788:	383f521e 	bne	r7,zero,40174d4 <__subdf3+0x3e0>
 401778c:	10009d26 	beq	r2,zero,4017a04 <__subdf3+0x910>
 4017790:	1808977a 	slli	r4,r3,29
 4017794:	00880034 	movhi	r2,8192
 4017798:	10bfffc4 	addi	r2,r2,-1
 401779c:	3084703a 	and	r2,r6,r2
 40177a0:	1810d0fa 	srli	r8,r3,3
 40177a4:	1104b03a 	or	r2,r2,r4
 40177a8:	4825883a 	mov	r18,r9
 40177ac:	003f5a06 	br	4017518 <__subdf3+0x424>
 40177b0:	52e3c83a 	sub	r17,r10,r11
 40177b4:	1a09c83a 	sub	r4,r3,r8
 40177b8:	5467803a 	cmpltu	r19,r10,r17
 40177bc:	24e7c83a 	sub	r19,r4,r19
 40177c0:	4825883a 	mov	r18,r9
 40177c4:	003e8506 	br	40171dc <__subdf3+0xe8>
 40177c8:	4022977a 	slli	r17,r8,29
 40177cc:	00880034 	movhi	r2,8192
 40177d0:	10bfffc4 	addi	r2,r2,-1
 40177d4:	2088703a 	and	r4,r4,r2
 40177d8:	4010d0fa 	srli	r8,r8,3
 40177dc:	2444b03a 	or	r2,r4,r17
 40177e0:	003f4d06 	br	4017518 <__subdf3+0x424>
 40177e4:	5aa3c83a 	sub	r17,r11,r10
 40177e8:	40c9c83a 	sub	r4,r8,r3
 40177ec:	5c57803a 	cmpltu	r11,r11,r17
 40177f0:	22c9c83a 	sub	r4,r4,r11
 40177f4:	04000044 	movi	r16,1
 40177f8:	003e7306 	br	40171c8 <__subdf3+0xd4>
 40177fc:	4004977a 	slli	r2,r8,29
 4017800:	00c80034 	movhi	r3,8192
 4017804:	18ffffc4 	addi	r3,r3,-1
 4017808:	20c8703a 	and	r4,r4,r3
 401780c:	4010d0fa 	srli	r8,r8,3
 4017810:	1104b03a 	or	r2,r2,r4
 4017814:	003f4006 	br	4017518 <__subdf3+0x424>
 4017818:	4004977a 	slli	r2,r8,29
 401781c:	00c80034 	movhi	r3,8192
 4017820:	18ffffc4 	addi	r3,r3,-1
 4017824:	20c8703a 	and	r4,r4,r3
 4017828:	4010d0fa 	srli	r8,r8,3
 401782c:	1104b03a 	or	r2,r2,r4
 4017830:	003f1306 	br	4017480 <__subdf3+0x38c>
 4017834:	1804977a 	slli	r2,r3,29
 4017838:	01080034 	movhi	r4,8192
 401783c:	213fffc4 	addi	r4,r4,-1
 4017840:	310c703a 	and	r6,r6,r4
 4017844:	1810d0fa 	srli	r8,r3,3
 4017848:	1184b03a 	or	r2,r2,r6
 401784c:	003f3206 	br	4017518 <__subdf3+0x424>
 4017850:	42d0b03a 	or	r8,r8,r11
 4017854:	4022c03a 	cmpne	r17,r8,zero
 4017858:	003edf06 	br	40173d8 <__subdf3+0x2e4>
 401785c:	2c7ff804 	addi	r17,r5,-32
 4017860:	29000820 	cmpeqi	r4,r5,32
 4017864:	4444d83a 	srl	r2,r8,r17
 4017868:	2000041e 	bne	r4,zero,401787c <__subdf3+0x788>
 401786c:	01001004 	movi	r4,64
 4017870:	214bc83a 	sub	r5,r4,r5
 4017874:	4150983a 	sll	r8,r8,r5
 4017878:	5a16b03a 	or	r11,r11,r8
 401787c:	5822c03a 	cmpne	r17,r11,zero
 4017880:	88a2b03a 	or	r17,r17,r2
 4017884:	003f9506 	br	40176dc <__subdf3+0x5e8>
 4017888:	103fea26 	beq	r2,zero,4017834 <__subdf3+0x740>
 401788c:	1a94b03a 	or	r10,r3,r10
 4017890:	400e977a 	slli	r7,r8,29
 4017894:	4010d0fa 	srli	r8,r8,3
 4017898:	503f111e 	bne	r10,zero,40174e0 <__subdf3+0x3ec>
 401789c:	00880034 	movhi	r2,8192
 40178a0:	10bfffc4 	addi	r2,r2,-1
 40178a4:	2084703a 	and	r2,r4,r2
 40178a8:	11c4b03a 	or	r2,r2,r7
 40178ac:	003f1a06 	br	4017518 <__subdf3+0x424>
 40178b0:	103f5b26 	beq	r2,zero,4017620 <__subdf3+0x52c>
 40178b4:	1804977a 	slli	r2,r3,29
 40178b8:	01080034 	movhi	r4,8192
 40178bc:	213fffc4 	addi	r4,r4,-1
 40178c0:	310c703a 	and	r6,r6,r4
 40178c4:	1810d0fa 	srli	r8,r3,3
 40178c8:	1184b03a 	or	r2,r2,r6
 40178cc:	4825883a 	mov	r18,r9
 40178d0:	003eed06 	br	4017488 <__subdf3+0x394>
 40178d4:	1808977a 	slli	r4,r3,29
 40178d8:	00880034 	movhi	r2,8192
 40178dc:	10bfffc4 	addi	r2,r2,-1
 40178e0:	3084703a 	and	r2,r6,r2
 40178e4:	1810d0fa 	srli	r8,r3,3
 40178e8:	1104b03a 	or	r2,r2,r4
 40178ec:	003f0a06 	br	4017518 <__subdf3+0x424>
 40178f0:	52e3c83a 	sub	r17,r10,r11
 40178f4:	1a09c83a 	sub	r4,r3,r8
 40178f8:	5455803a 	cmpltu	r10,r10,r17
 40178fc:	2289c83a 	sub	r4,r4,r10
 4017900:	04000044 	movi	r16,1
 4017904:	003e3006 	br	40171c8 <__subdf3+0xd4>
 4017908:	4006977a 	slli	r3,r8,29
 401790c:	00880034 	movhi	r2,8192
 4017910:	10bfffc4 	addi	r2,r2,-1
 4017914:	2084703a 	and	r2,r4,r2
 4017918:	4010d0fa 	srli	r8,r8,3
 401791c:	10c4b03a 	or	r2,r2,r3
 4017920:	003efd06 	br	4017518 <__subdf3+0x424>
 4017924:	5aa3c83a 	sub	r17,r11,r10
 4017928:	5c45803a 	cmpltu	r2,r11,r17
 401792c:	40c9c83a 	sub	r4,r8,r3
 4017930:	2089c83a 	sub	r4,r4,r2
 4017934:	2080202c 	andhi	r2,r4,128
 4017938:	10002f26 	beq	r2,zero,40179f8 <__subdf3+0x904>
 401793c:	52e3c83a 	sub	r17,r10,r11
 4017940:	1a09c83a 	sub	r4,r3,r8
 4017944:	5455803a 	cmpltu	r10,r10,r17
 4017948:	2289c83a 	sub	r4,r4,r10
 401794c:	4825883a 	mov	r18,r9
 4017950:	003e3b06 	br	4017240 <__subdf3+0x14c>
 4017954:	1808977a 	slli	r4,r3,29
 4017958:	00880034 	movhi	r2,8192
 401795c:	10bfffc4 	addi	r2,r2,-1
 4017960:	3084703a 	and	r2,r6,r2
 4017964:	1810d0fa 	srli	r8,r3,3
 4017968:	1104b03a 	or	r2,r2,r4
 401796c:	003ec406 	br	4017480 <__subdf3+0x38c>
 4017970:	1808977a 	slli	r4,r3,29
 4017974:	00880034 	movhi	r2,8192
 4017978:	10bfffc4 	addi	r2,r2,-1
 401797c:	3084703a 	and	r2,r6,r2
 4017980:	1810d0fa 	srli	r8,r3,3
 4017984:	1104b03a 	or	r2,r2,r4
 4017988:	003ebf06 	br	4017488 <__subdf3+0x394>
 401798c:	5aa3883a 	add	r17,r11,r10
 4017990:	40c9883a 	add	r4,r8,r3
 4017994:	8ad7803a 	cmpltu	r11,r17,r11
 4017998:	22c9883a 	add	r4,r4,r11
 401799c:	2080202c 	andhi	r2,r4,128
 40179a0:	103eb026 	beq	r2,zero,4017464 <__subdf3+0x370>
 40179a4:	00bfe034 	movhi	r2,65408
 40179a8:	10bfffc4 	addi	r2,r2,-1
 40179ac:	2088703a 	and	r4,r4,r2
 40179b0:	04000044 	movi	r16,1
 40179b4:	003eab06 	br	4017464 <__subdf3+0x370>
 40179b8:	28bff804 	addi	r2,r5,-32
 40179bc:	29000820 	cmpeqi	r4,r5,32
 40179c0:	4084d83a 	srl	r2,r8,r2
 40179c4:	2000041e 	bne	r4,zero,40179d8 <__subdf3+0x8e4>
 40179c8:	01001004 	movi	r4,64
 40179cc:	214bc83a 	sub	r5,r4,r5
 40179d0:	4150983a 	sll	r8,r8,r5
 40179d4:	5a16b03a 	or	r11,r11,r8
 40179d8:	5822c03a 	cmpne	r17,r11,zero
 40179dc:	88a2b03a 	or	r17,r17,r2
 40179e0:	003e7d06 	br	40173d8 <__subdf3+0x2e4>
 40179e4:	5aa3883a 	add	r17,r11,r10
 40179e8:	40c9883a 	add	r4,r8,r3
 40179ec:	8a95803a 	cmpltu	r10,r17,r10
 40179f0:	2289883a 	add	r4,r4,r10
 40179f4:	003e9806 	br	4017458 <__subdf3+0x364>
 40179f8:	8904b03a 	or	r2,r17,r4
 40179fc:	103f0826 	beq	r2,zero,4017620 <__subdf3+0x52c>
 4017a00:	003e9806 	br	4017464 <__subdf3+0x370>
 4017a04:	02000434 	movhi	r8,16
 4017a08:	423fffc4 	addi	r8,r8,-1
 4017a0c:	0025883a 	mov	r18,zero
 4017a10:	00bfffc4 	movi	r2,-1
 4017a14:	003ec206 	br	4017520 <__subdf3+0x42c>
 4017a18:	0005883a 	mov	r2,zero
 4017a1c:	0141ffc4 	movi	r5,2047
 4017a20:	0007883a 	mov	r3,zero
 4017a24:	003e1d06 	br	401729c <__subdf3+0x1a8>

04017a28 <__unorddf2>:
 4017a28:	2806d53a 	srli	r3,r5,20
 4017a2c:	3810d53a 	srli	r8,r7,20
 4017a30:	02400434 	movhi	r9,16
 4017a34:	18c1ffcc 	andi	r3,r3,2047
 4017a38:	4a7fffc4 	addi	r9,r9,-1
 4017a3c:	18c1ffd8 	cmpnei	r3,r3,2047
 4017a40:	2a4a703a 	and	r5,r5,r9
 4017a44:	3a4e703a 	and	r7,r7,r9
 4017a48:	4201ffcc 	andi	r8,r8,2047
 4017a4c:	18000426 	beq	r3,zero,4017a60 <__unorddf2+0x38>
 4017a50:	4201ffd8 	cmpnei	r8,r8,2047
 4017a54:	40000626 	beq	r8,zero,4017a70 <__unorddf2+0x48>
 4017a58:	0005883a 	mov	r2,zero
 4017a5c:	f800283a 	ret
 4017a60:	214ab03a 	or	r5,r4,r5
 4017a64:	283ffa26 	beq	r5,zero,4017a50 <__unorddf2+0x28>
 4017a68:	00800044 	movi	r2,1
 4017a6c:	f800283a 	ret
 4017a70:	398eb03a 	or	r7,r7,r6
 4017a74:	3804c03a 	cmpne	r2,r7,zero
 4017a78:	f800283a 	ret

04017a7c <__fixdfsi>:
 4017a7c:	2806d53a 	srli	r3,r5,20
 4017a80:	01800434 	movhi	r6,16
 4017a84:	31bfffc4 	addi	r6,r6,-1
 4017a88:	18c1ffcc 	andi	r3,r3,2047
 4017a8c:	19c0ffd0 	cmplti	r7,r3,1023
 4017a90:	2810d7fa 	srli	r8,r5,31
 4017a94:	298a703a 	and	r5,r5,r6
 4017a98:	3800061e 	bne	r7,zero,4017ab4 <__fixdfsi+0x38>
 4017a9c:	18810790 	cmplti	r2,r3,1054
 4017aa0:	1000061e 	bne	r2,zero,4017abc <__fixdfsi+0x40>
 4017aa4:	00a00034 	movhi	r2,32768
 4017aa8:	10bfffc4 	addi	r2,r2,-1
 4017aac:	4085883a 	add	r2,r8,r2
 4017ab0:	f800283a 	ret
 4017ab4:	0005883a 	mov	r2,zero
 4017ab8:	f800283a 	ret
 4017abc:	01810cc4 	movi	r6,1075
 4017ac0:	30cdc83a 	sub	r6,r6,r3
 4017ac4:	30800808 	cmpgei	r2,r6,32
 4017ac8:	29400434 	orhi	r5,r5,16
 4017acc:	1000071e 	bne	r2,zero,4017aec <__fixdfsi+0x70>
 4017ad0:	18befb44 	addi	r2,r3,-1043
 4017ad4:	2884983a 	sll	r2,r5,r2
 4017ad8:	2188d83a 	srl	r4,r4,r6
 4017adc:	1104b03a 	or	r2,r2,r4
 4017ae0:	403ff526 	beq	r8,zero,4017ab8 <__fixdfsi+0x3c>
 4017ae4:	0085c83a 	sub	r2,zero,r2
 4017ae8:	f800283a 	ret
 4017aec:	008104c4 	movi	r2,1043
 4017af0:	10c5c83a 	sub	r2,r2,r3
 4017af4:	2884d83a 	srl	r2,r5,r2
 4017af8:	003ff906 	br	4017ae0 <__fixdfsi+0x64>

04017afc <__floatsidf>:
 4017afc:	defffd04 	addi	sp,sp,-12
 4017b00:	dfc00215 	stw	ra,8(sp)
 4017b04:	dc400115 	stw	r17,4(sp)
 4017b08:	dc000015 	stw	r16,0(sp)
 4017b0c:	20001326 	beq	r4,zero,4017b5c <__floatsidf+0x60>
 4017b10:	2022d7fa 	srli	r17,r4,31
 4017b14:	2021883a 	mov	r16,r4
 4017b18:	20002516 	blt	r4,zero,4017bb0 <__floatsidf+0xb4>
 4017b1c:	8009883a 	mov	r4,r16
 4017b20:	4017c480 	call	4017c48 <__clzsi2>
 4017b24:	01410784 	movi	r5,1054
 4017b28:	288bc83a 	sub	r5,r5,r2
 4017b2c:	10c002c8 	cmpgei	r3,r2,11
 4017b30:	2941ffcc 	andi	r5,r5,2047
 4017b34:	1800171e 	bne	r3,zero,4017b94 <__floatsidf+0x98>
 4017b38:	00c002c4 	movi	r3,11
 4017b3c:	1887c83a 	sub	r3,r3,r2
 4017b40:	80c6d83a 	srl	r3,r16,r3
 4017b44:	01000434 	movhi	r4,16
 4017b48:	10800544 	addi	r2,r2,21
 4017b4c:	213fffc4 	addi	r4,r4,-1
 4017b50:	8084983a 	sll	r2,r16,r2
 4017b54:	1906703a 	and	r3,r3,r4
 4017b58:	00000406 	br	4017b6c <__floatsidf+0x70>
 4017b5c:	0023883a 	mov	r17,zero
 4017b60:	000b883a 	mov	r5,zero
 4017b64:	0007883a 	mov	r3,zero
 4017b68:	0005883a 	mov	r2,zero
 4017b6c:	280a953a 	slli	r5,r5,20
 4017b70:	8c403fcc 	andi	r17,r17,255
 4017b74:	882297fa 	slli	r17,r17,31
 4017b78:	28c6b03a 	or	r3,r5,r3
 4017b7c:	1c46b03a 	or	r3,r3,r17
 4017b80:	dfc00217 	ldw	ra,8(sp)
 4017b84:	dc400117 	ldw	r17,4(sp)
 4017b88:	dc000017 	ldw	r16,0(sp)
 4017b8c:	dec00304 	addi	sp,sp,12
 4017b90:	f800283a 	ret
 4017b94:	10bffd44 	addi	r2,r2,-11
 4017b98:	8086983a 	sll	r3,r16,r2
 4017b9c:	00800434 	movhi	r2,16
 4017ba0:	10bfffc4 	addi	r2,r2,-1
 4017ba4:	1886703a 	and	r3,r3,r2
 4017ba8:	0005883a 	mov	r2,zero
 4017bac:	003fef06 	br	4017b6c <__floatsidf+0x70>
 4017bb0:	0121c83a 	sub	r16,zero,r4
 4017bb4:	003fd906 	br	4017b1c <__floatsidf+0x20>

04017bb8 <__floatunsidf>:
 4017bb8:	defffe04 	addi	sp,sp,-8
 4017bbc:	dc000015 	stw	r16,0(sp)
 4017bc0:	dfc00115 	stw	ra,4(sp)
 4017bc4:	2021883a 	mov	r16,r4
 4017bc8:	20000f26 	beq	r4,zero,4017c08 <__floatunsidf+0x50>
 4017bcc:	4017c480 	call	4017c48 <__clzsi2>
 4017bd0:	00c10784 	movi	r3,1054
 4017bd4:	1887c83a 	sub	r3,r3,r2
 4017bd8:	110002c8 	cmpgei	r4,r2,11
 4017bdc:	18c1ffcc 	andi	r3,r3,2047
 4017be0:	2000121e 	bne	r4,zero,4017c2c <__floatunsidf+0x74>
 4017be4:	014002c4 	movi	r5,11
 4017be8:	288bc83a 	sub	r5,r5,r2
 4017bec:	814ad83a 	srl	r5,r16,r5
 4017bf0:	01000434 	movhi	r4,16
 4017bf4:	10800544 	addi	r2,r2,21
 4017bf8:	213fffc4 	addi	r4,r4,-1
 4017bfc:	80a0983a 	sll	r16,r16,r2
 4017c00:	290a703a 	and	r5,r5,r4
 4017c04:	00000206 	br	4017c10 <__floatunsidf+0x58>
 4017c08:	0007883a 	mov	r3,zero
 4017c0c:	000b883a 	mov	r5,zero
 4017c10:	1806953a 	slli	r3,r3,20
 4017c14:	8005883a 	mov	r2,r16
 4017c18:	1946b03a 	or	r3,r3,r5
 4017c1c:	dfc00117 	ldw	ra,4(sp)
 4017c20:	dc000017 	ldw	r16,0(sp)
 4017c24:	dec00204 	addi	sp,sp,8
 4017c28:	f800283a 	ret
 4017c2c:	10bffd44 	addi	r2,r2,-11
 4017c30:	808a983a 	sll	r5,r16,r2
 4017c34:	00800434 	movhi	r2,16
 4017c38:	10bfffc4 	addi	r2,r2,-1
 4017c3c:	288a703a 	and	r5,r5,r2
 4017c40:	0021883a 	mov	r16,zero
 4017c44:	003ff206 	br	4017c10 <__floatunsidf+0x58>

04017c48 <__clzsi2>:
 4017c48:	00bfffd4 	movui	r2,65535
 4017c4c:	11000436 	bltu	r2,r4,4017c60 <__clzsi2+0x18>
 4017c50:	20804030 	cmpltui	r2,r4,256
 4017c54:	10000e26 	beq	r2,zero,4017c90 <__clzsi2+0x48>
 4017c58:	01400804 	movi	r5,32
 4017c5c:	00000406 	br	4017c70 <__clzsi2+0x28>
 4017c60:	00804034 	movhi	r2,256
 4017c64:	20800736 	bltu	r4,r2,4017c84 <__clzsi2+0x3c>
 4017c68:	2008d63a 	srli	r4,r4,24
 4017c6c:	01400204 	movi	r5,8
 4017c70:	00c100b4 	movhi	r3,1026
 4017c74:	20c7883a 	add	r3,r4,r3
 4017c78:	18ac3803 	ldbu	r2,-20256(r3)
 4017c7c:	2885c83a 	sub	r2,r5,r2
 4017c80:	f800283a 	ret
 4017c84:	2008d43a 	srli	r4,r4,16
 4017c88:	01400404 	movi	r5,16
 4017c8c:	003ff806 	br	4017c70 <__clzsi2+0x28>
 4017c90:	2008d23a 	srli	r4,r4,8
 4017c94:	01400604 	movi	r5,24
 4017c98:	003ff506 	br	4017c70 <__clzsi2+0x28>

04017c9c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 4017c9c:	defffe04 	addi	sp,sp,-8
 4017ca0:	dfc00115 	stw	ra,4(sp)
 4017ca4:	df000015 	stw	fp,0(sp)
 4017ca8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 4017cac:	d0a00a17 	ldw	r2,-32728(gp)
 4017cb0:	10000326 	beq	r2,zero,4017cc0 <alt_get_errno+0x24>
 4017cb4:	d0a00a17 	ldw	r2,-32728(gp)
 4017cb8:	103ee83a 	callr	r2
 4017cbc:	00000106 	br	4017cc4 <alt_get_errno+0x28>
 4017cc0:	d0a72704 	addi	r2,gp,-25444
}
 4017cc4:	e037883a 	mov	sp,fp
 4017cc8:	dfc00117 	ldw	ra,4(sp)
 4017ccc:	df000017 	ldw	fp,0(sp)
 4017cd0:	dec00204 	addi	sp,sp,8
 4017cd4:	f800283a 	ret

04017cd8 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
 4017cd8:	defffb04 	addi	sp,sp,-20
 4017cdc:	dfc00415 	stw	ra,16(sp)
 4017ce0:	df000315 	stw	fp,12(sp)
 4017ce4:	df000304 	addi	fp,sp,12
 4017ce8:	e13ffd15 	stw	r4,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
 4017cec:	e0bffd17 	ldw	r2,-12(fp)
 4017cf0:	10000916 	blt	r2,zero,4017d18 <close+0x40>
 4017cf4:	e0fffd17 	ldw	r3,-12(fp)
 4017cf8:	1805883a 	mov	r2,r3
 4017cfc:	1085883a 	add	r2,r2,r2
 4017d00:	10c5883a 	add	r2,r2,r3
 4017d04:	100490ba 	slli	r2,r2,2
 4017d08:	00c100b4 	movhi	r3,1026
 4017d0c:	18eefb04 	addi	r3,r3,-17428
 4017d10:	10c5883a 	add	r2,r2,r3
 4017d14:	00000106 	br	4017d1c <close+0x44>
 4017d18:	0005883a 	mov	r2,zero
 4017d1c:	e0bfff15 	stw	r2,-4(fp)

  if (fd)
 4017d20:	e0bfff17 	ldw	r2,-4(fp)
 4017d24:	10001926 	beq	r2,zero,4017d8c <close+0xb4>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
 4017d28:	e0bfff17 	ldw	r2,-4(fp)
 4017d2c:	10800017 	ldw	r2,0(r2)
 4017d30:	10800417 	ldw	r2,16(r2)
 4017d34:	10000626 	beq	r2,zero,4017d50 <close+0x78>
 4017d38:	e0bfff17 	ldw	r2,-4(fp)
 4017d3c:	10800017 	ldw	r2,0(r2)
 4017d40:	10800417 	ldw	r2,16(r2)
 4017d44:	e13fff17 	ldw	r4,-4(fp)
 4017d48:	103ee83a 	callr	r2
 4017d4c:	00000106 	br	4017d54 <close+0x7c>
 4017d50:	0005883a 	mov	r2,zero
 4017d54:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
 4017d58:	e13ffd17 	ldw	r4,-12(fp)
 4017d5c:	401882c0 	call	401882c <alt_release_fd>
    if (rval < 0)
 4017d60:	e0bffe17 	ldw	r2,-8(fp)
 4017d64:	1000070e 	bge	r2,zero,4017d84 <close+0xac>
    {
      ALT_ERRNO = -rval;
 4017d68:	4017c9c0 	call	4017c9c <alt_get_errno>
 4017d6c:	1007883a 	mov	r3,r2
 4017d70:	e0bffe17 	ldw	r2,-8(fp)
 4017d74:	0085c83a 	sub	r2,zero,r2
 4017d78:	18800015 	stw	r2,0(r3)
      return -1;
 4017d7c:	00bfffc4 	movi	r2,-1
 4017d80:	00000706 	br	4017da0 <close+0xc8>
    }
    return 0;
 4017d84:	0005883a 	mov	r2,zero
 4017d88:	00000506 	br	4017da0 <close+0xc8>
  }
  else
  {
    ALT_ERRNO = EBADFD;
 4017d8c:	4017c9c0 	call	4017c9c <alt_get_errno>
 4017d90:	1007883a 	mov	r3,r2
 4017d94:	00801444 	movi	r2,81
 4017d98:	18800015 	stw	r2,0(r3)
    return -1;
 4017d9c:	00bfffc4 	movi	r2,-1
  }
}
 4017da0:	e037883a 	mov	sp,fp
 4017da4:	dfc00117 	ldw	ra,4(sp)
 4017da8:	df000017 	ldw	fp,0(sp)
 4017dac:	dec00204 	addi	sp,sp,8
 4017db0:	f800283a 	ret

04017db4 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
 4017db4:	defffc04 	addi	sp,sp,-16
 4017db8:	df000315 	stw	fp,12(sp)
 4017dbc:	df000304 	addi	fp,sp,12
 4017dc0:	e13fff15 	stw	r4,-4(fp)
 4017dc4:	e17ffe15 	stw	r5,-8(fp)
 4017dc8:	e1bffd15 	stw	r6,-12(fp)
  return len;
 4017dcc:	e0bffd17 	ldw	r2,-12(fp)
}
 4017dd0:	e037883a 	mov	sp,fp
 4017dd4:	df000017 	ldw	fp,0(sp)
 4017dd8:	dec00104 	addi	sp,sp,4
 4017ddc:	f800283a 	ret

04017de0 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
 4017de0:	defffd04 	addi	sp,sp,-12
 4017de4:	df000215 	stw	fp,8(sp)
 4017de8:	df000204 	addi	fp,sp,8
 4017dec:	e13ffe15 	stw	r4,-8(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
 4017df0:	0001883a 	nop
 4017df4:	e0bffe17 	ldw	r2,-8(fp)
 4017df8:	e0bfff15 	stw	r2,-4(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
 4017dfc:	e0bfff17 	ldw	r2,-4(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
 4017e00:	10000226 	beq	r2,zero,4017e0c <_exit+0x2c>
    ALT_SIM_FAIL();
 4017e04:	002af070 	cmpltui	zero,zero,43969
  } else {
    ALT_SIM_PASS();
  }
#endif /* DEBUG_STUB */
}
 4017e08:	00000106 	br	4017e10 <_exit+0x30>
    ALT_SIM_PASS();
 4017e0c:	002af0b0 	cmpltui	zero,zero,43970
}
 4017e10:	0001883a 	nop
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
 4017e14:	003fff06 	br	4017e14 <_exit+0x34>

04017e18 <alt_get_errno>:
{
 4017e18:	defffe04 	addi	sp,sp,-8
 4017e1c:	dfc00115 	stw	ra,4(sp)
 4017e20:	df000015 	stw	fp,0(sp)
 4017e24:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 4017e28:	d0a00a17 	ldw	r2,-32728(gp)
 4017e2c:	10000326 	beq	r2,zero,4017e3c <alt_get_errno+0x24>
 4017e30:	d0a00a17 	ldw	r2,-32728(gp)
 4017e34:	103ee83a 	callr	r2
 4017e38:	00000106 	br	4017e40 <alt_get_errno+0x28>
 4017e3c:	d0a72704 	addi	r2,gp,-25444
}
 4017e40:	e037883a 	mov	sp,fp
 4017e44:	dfc00117 	ldw	ra,4(sp)
 4017e48:	df000017 	ldw	fp,0(sp)
 4017e4c:	dec00204 	addi	sp,sp,8
 4017e50:	f800283a 	ret

04017e54 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
 4017e54:	defffb04 	addi	sp,sp,-20
 4017e58:	dfc00415 	stw	ra,16(sp)
 4017e5c:	df000315 	stw	fp,12(sp)
 4017e60:	df000304 	addi	fp,sp,12
 4017e64:	e13ffe15 	stw	r4,-8(fp)
 4017e68:	e17ffd15 	stw	r5,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 4017e6c:	e0bffe17 	ldw	r2,-8(fp)
 4017e70:	10000916 	blt	r2,zero,4017e98 <fstat+0x44>
 4017e74:	e0fffe17 	ldw	r3,-8(fp)
 4017e78:	1805883a 	mov	r2,r3
 4017e7c:	1085883a 	add	r2,r2,r2
 4017e80:	10c5883a 	add	r2,r2,r3
 4017e84:	100490ba 	slli	r2,r2,2
 4017e88:	00c100b4 	movhi	r3,1026
 4017e8c:	18eefb04 	addi	r3,r3,-17428
 4017e90:	10c5883a 	add	r2,r2,r3
 4017e94:	00000106 	br	4017e9c <fstat+0x48>
 4017e98:	0005883a 	mov	r2,zero
 4017e9c:	e0bfff15 	stw	r2,-4(fp)
  
  if (fd)
 4017ea0:	e0bfff17 	ldw	r2,-4(fp)
 4017ea4:	10001026 	beq	r2,zero,4017ee8 <fstat+0x94>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
 4017ea8:	e0bfff17 	ldw	r2,-4(fp)
 4017eac:	10800017 	ldw	r2,0(r2)
 4017eb0:	10800817 	ldw	r2,32(r2)
 4017eb4:	10000726 	beq	r2,zero,4017ed4 <fstat+0x80>
    {
      return fd->dev->fstat(fd, st);
 4017eb8:	e0bfff17 	ldw	r2,-4(fp)
 4017ebc:	10800017 	ldw	r2,0(r2)
 4017ec0:	10800817 	ldw	r2,32(r2)
 4017ec4:	e17ffd17 	ldw	r5,-12(fp)
 4017ec8:	e13fff17 	ldw	r4,-4(fp)
 4017ecc:	103ee83a 	callr	r2
 4017ed0:	00000a06 	br	4017efc <fstat+0xa8>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
 4017ed4:	e0bffd17 	ldw	r2,-12(fp)
 4017ed8:	00c80004 	movi	r3,8192
 4017edc:	10c00115 	stw	r3,4(r2)
      return 0;
 4017ee0:	0005883a 	mov	r2,zero
 4017ee4:	00000506 	br	4017efc <fstat+0xa8>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 4017ee8:	4017e180 	call	4017e18 <alt_get_errno>
 4017eec:	1007883a 	mov	r3,r2
 4017ef0:	00801444 	movi	r2,81
 4017ef4:	18800015 	stw	r2,0(r3)
    return -1;
 4017ef8:	00bfffc4 	movi	r2,-1
  }
}
 4017efc:	e037883a 	mov	sp,fp
 4017f00:	dfc00117 	ldw	ra,4(sp)
 4017f04:	df000017 	ldw	fp,0(sp)
 4017f08:	dec00204 	addi	sp,sp,8
 4017f0c:	f800283a 	ret

04017f10 <getpid>:
 *
 * ALT_GETPID is mapped onto the getpid() system call in alt_syscall.h
 */
 
int ALT_GETPID (void)
{
 4017f10:	deffff04 	addi	sp,sp,-4
 4017f14:	df000015 	stw	fp,0(sp)
 4017f18:	d839883a 	mov	fp,sp
  return 0;
 4017f1c:	0005883a 	mov	r2,zero
}
 4017f20:	e037883a 	mov	sp,fp
 4017f24:	df000017 	ldw	fp,0(sp)
 4017f28:	dec00104 	addi	sp,sp,4
 4017f2c:	f800283a 	ret

04017f30 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 4017f30:	defff904 	addi	sp,sp,-28
 4017f34:	dfc00615 	stw	ra,24(sp)
 4017f38:	df000515 	stw	fp,20(sp)
 4017f3c:	df000504 	addi	fp,sp,20
 4017f40:	e13fff15 	stw	r4,-4(fp)
 4017f44:	e17ffe15 	stw	r5,-8(fp)
 4017f48:	e1bffd15 	stw	r6,-12(fp)
 4017f4c:	e1fffc15 	stw	r7,-16(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
 4017f50:	e0800217 	ldw	r2,8(fp)
 4017f54:	d8800015 	stw	r2,0(sp)
 4017f58:	e1fffc17 	ldw	r7,-16(fp)
 4017f5c:	e1bffd17 	ldw	r6,-12(fp)
 4017f60:	e17ffe17 	ldw	r5,-8(fp)
 4017f64:	e13fff17 	ldw	r4,-4(fp)
 4017f68:	40180e00 	call	40180e0 <alt_iic_isr_register>
}  
 4017f6c:	e037883a 	mov	sp,fp
 4017f70:	dfc00117 	ldw	ra,4(sp)
 4017f74:	df000017 	ldw	fp,0(sp)
 4017f78:	dec00204 	addi	sp,sp,8
 4017f7c:	f800283a 	ret

04017f80 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
 4017f80:	defff904 	addi	sp,sp,-28
 4017f84:	df000615 	stw	fp,24(sp)
 4017f88:	df000604 	addi	fp,sp,24
 4017f8c:	e13ffb15 	stw	r4,-20(fp)
 4017f90:	e17ffa15 	stw	r5,-24(fp)
 4017f94:	e0bffa17 	ldw	r2,-24(fp)
 4017f98:	e0bfff15 	stw	r2,-4(fp)
  NIOS2_READ_STATUS (context);
 4017f9c:	0005303a 	rdctl	r2,status
 4017fa0:	e0bffe15 	stw	r2,-8(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 4017fa4:	e0fffe17 	ldw	r3,-8(fp)
 4017fa8:	00bfff84 	movi	r2,-2
 4017fac:	1884703a 	and	r2,r3,r2
 4017fb0:	1001703a 	wrctl	status,r2
  return context;
 4017fb4:	e0bffe17 	ldw	r2,-8(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 4017fb8:	e0bffd15 	stw	r2,-12(fp)

  alt_irq_active |= (1 << id);
 4017fbc:	00c00044 	movi	r3,1
 4017fc0:	e0bfff17 	ldw	r2,-4(fp)
 4017fc4:	1884983a 	sll	r2,r3,r2
 4017fc8:	1007883a 	mov	r3,r2
 4017fcc:	d0a72917 	ldw	r2,-25436(gp)
 4017fd0:	1884b03a 	or	r2,r3,r2
 4017fd4:	d0a72915 	stw	r2,-25436(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 4017fd8:	d0a72917 	ldw	r2,-25436(gp)
 4017fdc:	100170fa 	wrctl	ienable,r2
 4017fe0:	e0bffd17 	ldw	r2,-12(fp)
 4017fe4:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context);
 4017fe8:	e0bffc17 	ldw	r2,-16(fp)
 4017fec:	1001703a 	wrctl	status,r2
}
 4017ff0:	0001883a 	nop

  alt_irq_enable_all(status);

  return 0;
 4017ff4:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
}
 4017ff8:	e037883a 	mov	sp,fp
 4017ffc:	df000017 	ldw	fp,0(sp)
 4018000:	dec00104 	addi	sp,sp,4
 4018004:	f800283a 	ret

04018008 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
 4018008:	defff904 	addi	sp,sp,-28
 401800c:	df000615 	stw	fp,24(sp)
 4018010:	df000604 	addi	fp,sp,24
 4018014:	e13ffb15 	stw	r4,-20(fp)
 4018018:	e17ffa15 	stw	r5,-24(fp)
 401801c:	e0bffa17 	ldw	r2,-24(fp)
 4018020:	e0bfff15 	stw	r2,-4(fp)
  NIOS2_READ_STATUS (context);
 4018024:	0005303a 	rdctl	r2,status
 4018028:	e0bffe15 	stw	r2,-8(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 401802c:	e0fffe17 	ldw	r3,-8(fp)
 4018030:	00bfff84 	movi	r2,-2
 4018034:	1884703a 	and	r2,r3,r2
 4018038:	1001703a 	wrctl	status,r2
  return context;
 401803c:	e0bffe17 	ldw	r2,-8(fp)
  status = alt_irq_disable_all ();
 4018040:	e0bffd15 	stw	r2,-12(fp)
  alt_irq_active &= ~(1 << id);
 4018044:	00c00044 	movi	r3,1
 4018048:	e0bfff17 	ldw	r2,-4(fp)
 401804c:	1884983a 	sll	r2,r3,r2
 4018050:	0084303a 	nor	r2,zero,r2
 4018054:	1007883a 	mov	r3,r2
 4018058:	d0a72917 	ldw	r2,-25436(gp)
 401805c:	1884703a 	and	r2,r3,r2
 4018060:	d0a72915 	stw	r2,-25436(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 4018064:	d0a72917 	ldw	r2,-25436(gp)
 4018068:	100170fa 	wrctl	ienable,r2
 401806c:	e0bffd17 	ldw	r2,-12(fp)
 4018070:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context);
 4018074:	e0bffc17 	ldw	r2,-16(fp)
 4018078:	1001703a 	wrctl	status,r2
}
 401807c:	0001883a 	nop
  return 0;
 4018080:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
}
 4018084:	e037883a 	mov	sp,fp
 4018088:	df000017 	ldw	fp,0(sp)
 401808c:	dec00104 	addi	sp,sp,4
 4018090:	f800283a 	ret

04018094 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
 4018094:	defffc04 	addi	sp,sp,-16
 4018098:	df000315 	stw	fp,12(sp)
 401809c:	df000304 	addi	fp,sp,12
 40180a0:	e13ffe15 	stw	r4,-8(fp)
 40180a4:	e17ffd15 	stw	r5,-12(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
 40180a8:	000530fa 	rdctl	r2,ienable
 40180ac:	e0bfff15 	stw	r2,-4(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
 40180b0:	00c00044 	movi	r3,1
 40180b4:	e0bffd17 	ldw	r2,-12(fp)
 40180b8:	1884983a 	sll	r2,r3,r2
 40180bc:	1007883a 	mov	r3,r2
 40180c0:	e0bfff17 	ldw	r2,-4(fp)
 40180c4:	1884703a 	and	r2,r3,r2
 40180c8:	1004c03a 	cmpne	r2,r2,zero
 40180cc:	10803fcc 	andi	r2,r2,255
}
 40180d0:	e037883a 	mov	sp,fp
 40180d4:	df000017 	ldw	fp,0(sp)
 40180d8:	dec00104 	addi	sp,sp,4
 40180dc:	f800283a 	ret

040180e0 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 40180e0:	defff504 	addi	sp,sp,-44
 40180e4:	dfc00a15 	stw	ra,40(sp)
 40180e8:	df000915 	stw	fp,36(sp)
 40180ec:	df000904 	addi	fp,sp,36
 40180f0:	e13ffa15 	stw	r4,-24(fp)
 40180f4:	e17ff915 	stw	r5,-28(fp)
 40180f8:	e1bff815 	stw	r6,-32(fp)
 40180fc:	e1fff715 	stw	r7,-36(fp)
  int rc = -EINVAL;  
 4018100:	00bffa84 	movi	r2,-22
 4018104:	e0bfff15 	stw	r2,-4(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
 4018108:	e0bff917 	ldw	r2,-28(fp)
 401810c:	e0bffe15 	stw	r2,-8(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
 4018110:	e0bffe17 	ldw	r2,-8(fp)
 4018114:	10800808 	cmpgei	r2,r2,32
 4018118:	1000251e 	bne	r2,zero,40181b0 <alt_iic_isr_register+0xd0>
  NIOS2_READ_STATUS (context);
 401811c:	0005303a 	rdctl	r2,status
 4018120:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 4018124:	e0fffc17 	ldw	r3,-16(fp)
 4018128:	00bfff84 	movi	r2,-2
 401812c:	1884703a 	and	r2,r3,r2
 4018130:	1001703a 	wrctl	status,r2
  return context;
 4018134:	e0bffc17 	ldw	r2,-16(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
 4018138:	e0bffd15 	stw	r2,-12(fp)

    alt_irq[id].handler = isr;
 401813c:	e0bffe17 	ldw	r2,-8(fp)
 4018140:	100890fa 	slli	r4,r2,3
 4018144:	e0fff817 	ldw	r3,-32(fp)
 4018148:	008120b4 	movhi	r2,1154
 401814c:	2085883a 	add	r2,r4,r2
 4018150:	10faeb15 	stw	r3,-5204(r2)
    alt_irq[id].context = isr_context;
 4018154:	e0bffe17 	ldw	r2,-8(fp)
 4018158:	100890fa 	slli	r4,r2,3
 401815c:	e0fff717 	ldw	r3,-36(fp)
 4018160:	008120b4 	movhi	r2,1154
 4018164:	2085883a 	add	r2,r4,r2
 4018168:	10faec15 	stw	r3,-5200(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
 401816c:	e0bff817 	ldw	r2,-32(fp)
 4018170:	10000526 	beq	r2,zero,4018188 <alt_iic_isr_register+0xa8>
 4018174:	e0bffe17 	ldw	r2,-8(fp)
 4018178:	100b883a 	mov	r5,r2
 401817c:	e13ffa17 	ldw	r4,-24(fp)
 4018180:	4017f800 	call	4017f80 <alt_ic_irq_enable>
 4018184:	00000406 	br	4018198 <alt_iic_isr_register+0xb8>
 4018188:	e0bffe17 	ldw	r2,-8(fp)
 401818c:	100b883a 	mov	r5,r2
 4018190:	e13ffa17 	ldw	r4,-24(fp)
 4018194:	40180080 	call	4018008 <alt_ic_irq_disable>
 4018198:	e0bfff15 	stw	r2,-4(fp)
 401819c:	e0bffd17 	ldw	r2,-12(fp)
 40181a0:	e0bffb15 	stw	r2,-20(fp)
  NIOS2_WRITE_STATUS (context);
 40181a4:	e0bffb17 	ldw	r2,-20(fp)
 40181a8:	1001703a 	wrctl	status,r2
}
 40181ac:	0001883a 	nop

    alt_irq_enable_all(status);
  }

  return rc; 
 40181b0:	e0bfff17 	ldw	r2,-4(fp)
}
 40181b4:	e037883a 	mov	sp,fp
 40181b8:	dfc00117 	ldw	ra,4(sp)
 40181bc:	df000017 	ldw	fp,0(sp)
 40181c0:	dec00204 	addi	sp,sp,8
 40181c4:	f800283a 	ret

040181c8 <alt_get_errno>:
{
 40181c8:	defffe04 	addi	sp,sp,-8
 40181cc:	dfc00115 	stw	ra,4(sp)
 40181d0:	df000015 	stw	fp,0(sp)
 40181d4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 40181d8:	d0a00a17 	ldw	r2,-32728(gp)
 40181dc:	10000326 	beq	r2,zero,40181ec <alt_get_errno+0x24>
 40181e0:	d0a00a17 	ldw	r2,-32728(gp)
 40181e4:	103ee83a 	callr	r2
 40181e8:	00000106 	br	40181f0 <alt_get_errno+0x28>
 40181ec:	d0a72704 	addi	r2,gp,-25444
}
 40181f0:	e037883a 	mov	sp,fp
 40181f4:	dfc00117 	ldw	ra,4(sp)
 40181f8:	df000017 	ldw	fp,0(sp)
 40181fc:	dec00204 	addi	sp,sp,8
 4018200:	f800283a 	ret

04018204 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
 4018204:	deffea04 	addi	sp,sp,-88
 4018208:	dfc01515 	stw	ra,84(sp)
 401820c:	df001415 	stw	fp,80(sp)
 4018210:	df001404 	addi	fp,sp,80
 4018214:	e13fec15 	stw	r4,-80(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 4018218:	e0bfec17 	ldw	r2,-80(fp)
 401821c:	10000916 	blt	r2,zero,4018244 <isatty+0x40>
 4018220:	e0ffec17 	ldw	r3,-80(fp)
 4018224:	1805883a 	mov	r2,r3
 4018228:	1085883a 	add	r2,r2,r2
 401822c:	10c5883a 	add	r2,r2,r3
 4018230:	100490ba 	slli	r2,r2,2
 4018234:	00c100b4 	movhi	r3,1026
 4018238:	18eefb04 	addi	r3,r3,-17428
 401823c:	10c5883a 	add	r2,r2,r3
 4018240:	00000106 	br	4018248 <isatty+0x44>
 4018244:	0005883a 	mov	r2,zero
 4018248:	e0bfff15 	stw	r2,-4(fp)
  
  if (fd)
 401824c:	e0bfff17 	ldw	r2,-4(fp)
 4018250:	10000e26 	beq	r2,zero,401828c <isatty+0x88>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
 4018254:	e0bfff17 	ldw	r2,-4(fp)
 4018258:	10800017 	ldw	r2,0(r2)
 401825c:	10800817 	ldw	r2,32(r2)
 4018260:	1000021e 	bne	r2,zero,401826c <isatty+0x68>
    {
      return 1;
 4018264:	00800044 	movi	r2,1
 4018268:	00000d06 	br	40182a0 <isatty+0x9c>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
 401826c:	e0bfed04 	addi	r2,fp,-76
 4018270:	100b883a 	mov	r5,r2
 4018274:	e13fec17 	ldw	r4,-80(fp)
 4018278:	4017e540 	call	4017e54 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
 401827c:	e0bfee17 	ldw	r2,-72(fp)
 4018280:	10880020 	cmpeqi	r2,r2,8192
 4018284:	10803fcc 	andi	r2,r2,255
 4018288:	00000506 	br	40182a0 <isatty+0x9c>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 401828c:	40181c80 	call	40181c8 <alt_get_errno>
 4018290:	1007883a 	mov	r3,r2
 4018294:	00801444 	movi	r2,81
 4018298:	18800015 	stw	r2,0(r3)
    return 0;
 401829c:	0005883a 	mov	r2,zero
  }
}
 40182a0:	e037883a 	mov	sp,fp
 40182a4:	dfc00117 	ldw	ra,4(sp)
 40182a8:	df000017 	ldw	fp,0(sp)
 40182ac:	dec00204 	addi	sp,sp,8
 40182b0:	f800283a 	ret

040182b4 <alt_get_errno>:
{
 40182b4:	defffe04 	addi	sp,sp,-8
 40182b8:	dfc00115 	stw	ra,4(sp)
 40182bc:	df000015 	stw	fp,0(sp)
 40182c0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 40182c4:	d0a00a17 	ldw	r2,-32728(gp)
 40182c8:	10000326 	beq	r2,zero,40182d8 <alt_get_errno+0x24>
 40182cc:	d0a00a17 	ldw	r2,-32728(gp)
 40182d0:	103ee83a 	callr	r2
 40182d4:	00000106 	br	40182dc <alt_get_errno+0x28>
 40182d8:	d0a72704 	addi	r2,gp,-25444
}
 40182dc:	e037883a 	mov	sp,fp
 40182e0:	dfc00117 	ldw	ra,4(sp)
 40182e4:	df000017 	ldw	fp,0(sp)
 40182e8:	dec00204 	addi	sp,sp,8
 40182ec:	f800283a 	ret

040182f0 <kill>:
 *
 * ALT_KILL is mapped onto the kill() system call in alt_syscall.h
 */

int ALT_KILL (int pid, int sig)
{
 40182f0:	defffb04 	addi	sp,sp,-20
 40182f4:	dfc00415 	stw	ra,16(sp)
 40182f8:	df000315 	stw	fp,12(sp)
 40182fc:	df000304 	addi	fp,sp,12
 4018300:	e13ffe15 	stw	r4,-8(fp)
 4018304:	e17ffd15 	stw	r5,-12(fp)
  int status = 0;
 4018308:	e03fff15 	stw	zero,-4(fp)

  if (pid <= 0)
 401830c:	e0bffe17 	ldw	r2,-8(fp)
 4018310:	00802e16 	blt	zero,r2,40183cc <kill+0xdc>
 4018314:	e0bffd17 	ldw	r2,-12(fp)
 4018318:	10800828 	cmpgeui	r2,r2,32
 401831c:	1000281e 	bne	r2,zero,40183c0 <kill+0xd0>
 4018320:	e0bffd17 	ldw	r2,-12(fp)
 4018324:	100690ba 	slli	r3,r2,2
 4018328:	008100b4 	movhi	r2,1026
 401832c:	1885883a 	add	r2,r3,r2
 4018330:	10a0ce17 	ldw	r2,-31944(r2)
 4018334:	1000683a 	jmp	r2
 4018338:	040183e0 	cmpeqi	r16,zero,1551
 401833c:	040183c0 	call	40183c <__alt_mem_dram-0x3bfe7c4>
 4018340:	040183c0 	call	40183c <__alt_mem_dram-0x3bfe7c4>
 4018344:	040183b8 	rdprs	r16,zero,1550
 4018348:	040183b8 	rdprs	r16,zero,1550
 401834c:	040183b8 	rdprs	r16,zero,1550
 4018350:	040183b8 	rdprs	r16,zero,1550
 4018354:	040183c0 	call	40183c <__alt_mem_dram-0x3bfe7c4>
 4018358:	040183b8 	rdprs	r16,zero,1550
 401835c:	040183b8 	rdprs	r16,zero,1550
 4018360:	040183b8 	rdprs	r16,zero,1550
 4018364:	040183b8 	rdprs	r16,zero,1550
 4018368:	040183b8 	rdprs	r16,zero,1550
 401836c:	040183b8 	rdprs	r16,zero,1550
 4018370:	040183b8 	rdprs	r16,zero,1550
 4018374:	040183b8 	rdprs	r16,zero,1550
 4018378:	040183e0 	cmpeqi	r16,zero,1551
 401837c:	040183c0 	call	40183c <__alt_mem_dram-0x3bfe7c4>
 4018380:	040183c0 	call	40183c <__alt_mem_dram-0x3bfe7c4>
 4018384:	040183c0 	call	40183c <__alt_mem_dram-0x3bfe7c4>
 4018388:	040183e0 	cmpeqi	r16,zero,1551
 401838c:	040183c0 	call	40183c <__alt_mem_dram-0x3bfe7c4>
 4018390:	040183c0 	call	40183c <__alt_mem_dram-0x3bfe7c4>
 4018394:	040183b8 	rdprs	r16,zero,1550
 4018398:	040183b8 	rdprs	r16,zero,1550
 401839c:	040183b8 	rdprs	r16,zero,1550
 40183a0:	040183b8 	rdprs	r16,zero,1550
 40183a4:	040183b8 	rdprs	r16,zero,1550
 40183a8:	040183c0 	call	40183c <__alt_mem_dram-0x3bfe7c4>
 40183ac:	040183c0 	call	40183c <__alt_mem_dram-0x3bfe7c4>
 40183b0:	040183b8 	rdprs	r16,zero,1550
 40183b4:	040183b8 	rdprs	r16,zero,1550
       * The Posix standard defines the default behaviour for all these signals 
       * as being eqivalent to a call to _exit(). No mechanism is provided to 
       * change this behaviour.
       */

      _exit(0);
 40183b8:	0009883a 	mov	r4,zero
 40183bc:	4017de00 	call	4017de0 <_exit>
      break;
    default:

      /* Tried to send an unsupported signal */

      status = EINVAL;
 40183c0:	00800584 	movi	r2,22
 40183c4:	e0bfff15 	stw	r2,-4(fp)
 40183c8:	00000606 	br	40183e4 <kill+0xf4>
    }
  }

  else if (pid > 0)
 40183cc:	e0bffe17 	ldw	r2,-8(fp)
 40183d0:	0080040e 	bge	zero,r2,40183e4 <kill+0xf4>
  {
    /* Attempted to signal a non-existant process */

    status = ESRCH;
 40183d4:	008000c4 	movi	r2,3
 40183d8:	e0bfff15 	stw	r2,-4(fp)
 40183dc:	00000106 	br	40183e4 <kill+0xf4>
      break;
 40183e0:	0001883a 	nop
  }

  if (status)
 40183e4:	e0bfff17 	ldw	r2,-4(fp)
 40183e8:	10000626 	beq	r2,zero,4018404 <kill+0x114>
  {
    ALT_ERRNO = status;
 40183ec:	40182b40 	call	40182b4 <alt_get_errno>
 40183f0:	1007883a 	mov	r3,r2
 40183f4:	e0bfff17 	ldw	r2,-4(fp)
 40183f8:	18800015 	stw	r2,0(r3)
    return -1;
 40183fc:	00bfffc4 	movi	r2,-1
 4018400:	00000106 	br	4018408 <kill+0x118>
  }

  return 0;
 4018404:	0005883a 	mov	r2,zero
}
 4018408:	e037883a 	mov	sp,fp
 401840c:	dfc00117 	ldw	ra,4(sp)
 4018410:	df000017 	ldw	fp,0(sp)
 4018414:	dec00204 	addi	sp,sp,8
 4018418:	f800283a 	ret

0401841c <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
 401841c:	defffc04 	addi	sp,sp,-16
 4018420:	df000315 	stw	fp,12(sp)
 4018424:	df000304 	addi	fp,sp,12
 4018428:	e13fff15 	stw	r4,-4(fp)
 401842c:	e17ffe15 	stw	r5,-8(fp)
 4018430:	e1bffd15 	stw	r6,-12(fp)
  if (to != from)
 4018434:	e0fffe17 	ldw	r3,-8(fp)
 4018438:	e0bfff17 	ldw	r2,-4(fp)
 401843c:	18800c26 	beq	r3,r2,4018470 <alt_load_section+0x54>
  {
    while( to != end )
 4018440:	00000806 	br	4018464 <alt_load_section+0x48>
    {
      *to++ = *from++;
 4018444:	e0ffff17 	ldw	r3,-4(fp)
 4018448:	18800104 	addi	r2,r3,4
 401844c:	e0bfff15 	stw	r2,-4(fp)
 4018450:	e0bffe17 	ldw	r2,-8(fp)
 4018454:	11000104 	addi	r4,r2,4
 4018458:	e13ffe15 	stw	r4,-8(fp)
 401845c:	18c00017 	ldw	r3,0(r3)
 4018460:	10c00015 	stw	r3,0(r2)
    while( to != end )
 4018464:	e0fffe17 	ldw	r3,-8(fp)
 4018468:	e0bffd17 	ldw	r2,-12(fp)
 401846c:	18bff51e 	bne	r3,r2,4018444 <alt_load_section+0x28>
    }
  }
}
 4018470:	0001883a 	nop
 4018474:	e037883a 	mov	sp,fp
 4018478:	df000017 	ldw	fp,0(sp)
 401847c:	dec00104 	addi	sp,sp,4
 4018480:	f800283a 	ret

04018484 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
 4018484:	defffe04 	addi	sp,sp,-8
 4018488:	dfc00115 	stw	ra,4(sp)
 401848c:	df000015 	stw	fp,0(sp)
 4018490:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
 4018494:	018100b4 	movhi	r6,1026
 4018498:	31b38d04 	addi	r6,r6,-12748
 401849c:	014100b4 	movhi	r5,1026
 40184a0:	296c8b04 	addi	r5,r5,-19924
 40184a4:	010100b4 	movhi	r4,1026
 40184a8:	21338d04 	addi	r4,r4,-12748
 40184ac:	401841c0 	call	401841c <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
 40184b0:	01810034 	movhi	r6,1024
 40184b4:	3180d904 	addi	r6,r6,868
 40184b8:	01410034 	movhi	r5,1024
 40184bc:	29400804 	addi	r5,r5,32
 40184c0:	01010034 	movhi	r4,1024
 40184c4:	21000804 	addi	r4,r4,32
 40184c8:	401841c0 	call	401841c <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
 40184cc:	018100b4 	movhi	r6,1026
 40184d0:	31ac8b04 	addi	r6,r6,-19924
 40184d4:	014100b4 	movhi	r5,1026
 40184d8:	296aac04 	addi	r5,r5,-21840
 40184dc:	010100b4 	movhi	r4,1026
 40184e0:	212aac04 	addi	r4,r4,-21840
 40184e4:	401841c0 	call	401841c <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
 40184e8:	4019be80 	call	4019be8 <alt_dcache_flush_all>
  alt_icache_flush_all();
 40184ec:	4019e440 	call	4019e44 <alt_icache_flush_all>
}
 40184f0:	0001883a 	nop
 40184f4:	e037883a 	mov	sp,fp
 40184f8:	dfc00117 	ldw	ra,4(sp)
 40184fc:	df000017 	ldw	fp,0(sp)
 4018500:	dec00204 	addi	sp,sp,8
 4018504:	f800283a 	ret

04018508 <alt_get_errno>:
{
 4018508:	defffe04 	addi	sp,sp,-8
 401850c:	dfc00115 	stw	ra,4(sp)
 4018510:	df000015 	stw	fp,0(sp)
 4018514:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 4018518:	d0a00a17 	ldw	r2,-32728(gp)
 401851c:	10000326 	beq	r2,zero,401852c <alt_get_errno+0x24>
 4018520:	d0a00a17 	ldw	r2,-32728(gp)
 4018524:	103ee83a 	callr	r2
 4018528:	00000106 	br	4018530 <alt_get_errno+0x28>
 401852c:	d0a72704 	addi	r2,gp,-25444
}
 4018530:	e037883a 	mov	sp,fp
 4018534:	dfc00117 	ldw	ra,4(sp)
 4018538:	df000017 	ldw	fp,0(sp)
 401853c:	dec00204 	addi	sp,sp,8
 4018540:	f800283a 	ret

04018544 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
 4018544:	defff904 	addi	sp,sp,-28
 4018548:	dfc00615 	stw	ra,24(sp)
 401854c:	df000515 	stw	fp,20(sp)
 4018550:	df000504 	addi	fp,sp,20
 4018554:	e13ffd15 	stw	r4,-12(fp)
 4018558:	e17ffc15 	stw	r5,-16(fp)
 401855c:	e1bffb15 	stw	r6,-20(fp)
  alt_fd* fd;
  off_t   rc = 0; 
 4018560:	e03fff15 	stw	zero,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 4018564:	e0bffd17 	ldw	r2,-12(fp)
 4018568:	10000916 	blt	r2,zero,4018590 <lseek+0x4c>
 401856c:	e0fffd17 	ldw	r3,-12(fp)
 4018570:	1805883a 	mov	r2,r3
 4018574:	1085883a 	add	r2,r2,r2
 4018578:	10c5883a 	add	r2,r2,r3
 401857c:	100490ba 	slli	r2,r2,2
 4018580:	00c100b4 	movhi	r3,1026
 4018584:	18eefb04 	addi	r3,r3,-17428
 4018588:	10c5883a 	add	r2,r2,r3
 401858c:	00000106 	br	4018594 <lseek+0x50>
 4018590:	0005883a 	mov	r2,zero
 4018594:	e0bffe15 	stw	r2,-8(fp)
  
  if (fd) 
 4018598:	e0bffe17 	ldw	r2,-8(fp)
 401859c:	10001026 	beq	r2,zero,40185e0 <lseek+0x9c>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
 40185a0:	e0bffe17 	ldw	r2,-8(fp)
 40185a4:	10800017 	ldw	r2,0(r2)
 40185a8:	10800717 	ldw	r2,28(r2)
 40185ac:	10000926 	beq	r2,zero,40185d4 <lseek+0x90>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
 40185b0:	e0bffe17 	ldw	r2,-8(fp)
 40185b4:	10800017 	ldw	r2,0(r2)
 40185b8:	10800717 	ldw	r2,28(r2)
 40185bc:	e1bffb17 	ldw	r6,-20(fp)
 40185c0:	e17ffc17 	ldw	r5,-16(fp)
 40185c4:	e13ffe17 	ldw	r4,-8(fp)
 40185c8:	103ee83a 	callr	r2
 40185cc:	e0bfff15 	stw	r2,-4(fp)
 40185d0:	00000506 	br	40185e8 <lseek+0xa4>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
 40185d4:	00bfde84 	movi	r2,-134
 40185d8:	e0bfff15 	stw	r2,-4(fp)
 40185dc:	00000206 	br	40185e8 <lseek+0xa4>
    }
  }
  else  
  {
    rc = -EBADFD;
 40185e0:	00bfebc4 	movi	r2,-81
 40185e4:	e0bfff15 	stw	r2,-4(fp)
  }

  if (rc < 0)
 40185e8:	e0bfff17 	ldw	r2,-4(fp)
 40185ec:	1000070e 	bge	r2,zero,401860c <lseek+0xc8>
  {
    ALT_ERRNO = -rc;
 40185f0:	40185080 	call	4018508 <alt_get_errno>
 40185f4:	1007883a 	mov	r3,r2
 40185f8:	e0bfff17 	ldw	r2,-4(fp)
 40185fc:	0085c83a 	sub	r2,zero,r2
 4018600:	18800015 	stw	r2,0(r3)
    rc = -1;
 4018604:	00bfffc4 	movi	r2,-1
 4018608:	e0bfff15 	stw	r2,-4(fp)
  }

  return rc;
 401860c:	e0bfff17 	ldw	r2,-4(fp)
}
 4018610:	e037883a 	mov	sp,fp
 4018614:	dfc00117 	ldw	ra,4(sp)
 4018618:	df000017 	ldw	fp,0(sp)
 401861c:	dec00204 	addi	sp,sp,8
 4018620:	f800283a 	ret

04018624 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 4018624:	defffd04 	addi	sp,sp,-12
 4018628:	dfc00215 	stw	ra,8(sp)
 401862c:	df000115 	stw	fp,4(sp)
 4018630:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 4018634:	0009883a 	mov	r4,zero
 4018638:	4018ac80 	call	4018ac8 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
 401863c:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 4018640:	4018b040 	call	4018b04 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
 4018644:	018100b4 	movhi	r6,1026
 4018648:	31ac7b04 	addi	r6,r6,-19988
 401864c:	014100b4 	movhi	r5,1026
 4018650:	296c7b04 	addi	r5,r5,-19988
 4018654:	010100b4 	movhi	r4,1026
 4018658:	212c7b04 	addi	r4,r4,-19988
 401865c:	4019fd00 	call	4019fd0 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
 4018660:	4019cec0 	call	4019cec <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
 4018664:	010100b4 	movhi	r4,1026
 4018668:	21275404 	addi	r4,r4,-25264
 401866c:	401a6540 	call	401a654 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
 4018670:	d0a72a17 	ldw	r2,-25432(gp)
 4018674:	d0e72b17 	ldw	r3,-25428(gp)
 4018678:	d1272c17 	ldw	r4,-25424(gp)
 401867c:	200d883a 	mov	r6,r4
 4018680:	180b883a 	mov	r5,r3
 4018684:	1009883a 	mov	r4,r2
 4018688:	40072600 	call	4007260 <main>
 401868c:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
 4018690:	01000044 	movi	r4,1
 4018694:	4017cd80 	call	4017cd8 <close>
  exit (result);
 4018698:	e13fff17 	ldw	r4,-4(fp)
 401869c:	401a6900 	call	401a690 <exit>

040186a0 <__malloc_lock>:
 * configuration is single threaded, so there is nothing to do here. Note that 
 * this requires that malloc is never called by an interrupt service routine.
 */

void __malloc_lock ( struct _reent *_r )
{
 40186a0:	defffe04 	addi	sp,sp,-8
 40186a4:	df000115 	stw	fp,4(sp)
 40186a8:	df000104 	addi	fp,sp,4
 40186ac:	e13fff15 	stw	r4,-4(fp)
}
 40186b0:	0001883a 	nop
 40186b4:	e037883a 	mov	sp,fp
 40186b8:	df000017 	ldw	fp,0(sp)
 40186bc:	dec00104 	addi	sp,sp,4
 40186c0:	f800283a 	ret

040186c4 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
 40186c4:	defffe04 	addi	sp,sp,-8
 40186c8:	df000115 	stw	fp,4(sp)
 40186cc:	df000104 	addi	fp,sp,4
 40186d0:	e13fff15 	stw	r4,-4(fp)
}
 40186d4:	0001883a 	nop
 40186d8:	e037883a 	mov	sp,fp
 40186dc:	df000017 	ldw	fp,0(sp)
 40186e0:	dec00104 	addi	sp,sp,4
 40186e4:	f800283a 	ret

040186e8 <alt_get_errno>:
{
 40186e8:	defffe04 	addi	sp,sp,-8
 40186ec:	dfc00115 	stw	ra,4(sp)
 40186f0:	df000015 	stw	fp,0(sp)
 40186f4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 40186f8:	d0a00a17 	ldw	r2,-32728(gp)
 40186fc:	10000326 	beq	r2,zero,401870c <alt_get_errno+0x24>
 4018700:	d0a00a17 	ldw	r2,-32728(gp)
 4018704:	103ee83a 	callr	r2
 4018708:	00000106 	br	4018710 <alt_get_errno+0x28>
 401870c:	d0a72704 	addi	r2,gp,-25444
}
 4018710:	e037883a 	mov	sp,fp
 4018714:	dfc00117 	ldw	ra,4(sp)
 4018718:	df000017 	ldw	fp,0(sp)
 401871c:	dec00204 	addi	sp,sp,8
 4018720:	f800283a 	ret

04018724 <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
 4018724:	defff904 	addi	sp,sp,-28
 4018728:	dfc00615 	stw	ra,24(sp)
 401872c:	df000515 	stw	fp,20(sp)
 4018730:	df000504 	addi	fp,sp,20
 4018734:	e13ffd15 	stw	r4,-12(fp)
 4018738:	e17ffc15 	stw	r5,-16(fp)
 401873c:	e1bffb15 	stw	r6,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 4018740:	e0bffd17 	ldw	r2,-12(fp)
 4018744:	10000916 	blt	r2,zero,401876c <read+0x48>
 4018748:	e0fffd17 	ldw	r3,-12(fp)
 401874c:	1805883a 	mov	r2,r3
 4018750:	1085883a 	add	r2,r2,r2
 4018754:	10c5883a 	add	r2,r2,r3
 4018758:	100490ba 	slli	r2,r2,2
 401875c:	00c100b4 	movhi	r3,1026
 4018760:	18eefb04 	addi	r3,r3,-17428
 4018764:	10c5883a 	add	r2,r2,r3
 4018768:	00000106 	br	4018770 <read+0x4c>
 401876c:	0005883a 	mov	r2,zero
 4018770:	e0bfff15 	stw	r2,-4(fp)
  
  if (fd)
 4018774:	e0bfff17 	ldw	r2,-4(fp)
 4018778:	10002226 	beq	r2,zero,4018804 <read+0xe0>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 401877c:	e0bfff17 	ldw	r2,-4(fp)
 4018780:	10800217 	ldw	r2,8(r2)
 4018784:	108000cc 	andi	r2,r2,3
 4018788:	10800060 	cmpeqi	r2,r2,1
 401878c:	1000181e 	bne	r2,zero,40187f0 <read+0xcc>
        (fd->dev->read))
 4018790:	e0bfff17 	ldw	r2,-4(fp)
 4018794:	10800017 	ldw	r2,0(r2)
 4018798:	10800517 	ldw	r2,20(r2)
    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 401879c:	10001426 	beq	r2,zero,40187f0 <read+0xcc>
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
 40187a0:	e0bfff17 	ldw	r2,-4(fp)
 40187a4:	10800017 	ldw	r2,0(r2)
 40187a8:	10800517 	ldw	r2,20(r2)
 40187ac:	e0fffb17 	ldw	r3,-20(fp)
 40187b0:	180d883a 	mov	r6,r3
 40187b4:	e17ffc17 	ldw	r5,-16(fp)
 40187b8:	e13fff17 	ldw	r4,-4(fp)
 40187bc:	103ee83a 	callr	r2
 40187c0:	e0bffe15 	stw	r2,-8(fp)
 40187c4:	e0bffe17 	ldw	r2,-8(fp)
 40187c8:	1000070e 	bge	r2,zero,40187e8 <read+0xc4>
        {
          ALT_ERRNO = -rval;
 40187cc:	40186e80 	call	40186e8 <alt_get_errno>
 40187d0:	1007883a 	mov	r3,r2
 40187d4:	e0bffe17 	ldw	r2,-8(fp)
 40187d8:	0085c83a 	sub	r2,zero,r2
 40187dc:	18800015 	stw	r2,0(r3)
          return -1;
 40187e0:	00bfffc4 	movi	r2,-1
 40187e4:	00000c06 	br	4018818 <read+0xf4>
        }
        return rval;
 40187e8:	e0bffe17 	ldw	r2,-8(fp)
 40187ec:	00000a06 	br	4018818 <read+0xf4>
      }
      else
      {
        ALT_ERRNO = EACCES;
 40187f0:	40186e80 	call	40186e8 <alt_get_errno>
 40187f4:	1007883a 	mov	r3,r2
 40187f8:	00800344 	movi	r2,13
 40187fc:	18800015 	stw	r2,0(r3)
 4018800:	00000406 	br	4018814 <read+0xf0>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
 4018804:	40186e80 	call	40186e8 <alt_get_errno>
 4018808:	1007883a 	mov	r3,r2
 401880c:	00801444 	movi	r2,81
 4018810:	18800015 	stw	r2,0(r3)
  }
  return -1;
 4018814:	00bfffc4 	movi	r2,-1
}
 4018818:	e037883a 	mov	sp,fp
 401881c:	dfc00117 	ldw	ra,4(sp)
 4018820:	df000017 	ldw	fp,0(sp)
 4018824:	dec00204 	addi	sp,sp,8
 4018828:	f800283a 	ret

0401882c <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
 401882c:	defffe04 	addi	sp,sp,-8
 4018830:	df000115 	stw	fp,4(sp)
 4018834:	df000104 	addi	fp,sp,4
 4018838:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
 401883c:	e0bfff17 	ldw	r2,-4(fp)
 4018840:	108000d0 	cmplti	r2,r2,3
 4018844:	1000101e 	bne	r2,zero,4018888 <alt_release_fd+0x5c>
  {
    alt_fd_list[fd].fd_flags = 0;
 4018848:	e0ffff17 	ldw	r3,-4(fp)
 401884c:	1805883a 	mov	r2,r3
 4018850:	1085883a 	add	r2,r2,r2
 4018854:	10c5883a 	add	r2,r2,r3
 4018858:	100490ba 	slli	r2,r2,2
 401885c:	00c100b4 	movhi	r3,1026
 4018860:	10c7883a 	add	r3,r2,r3
 4018864:	182efd15 	stw	zero,-17420(r3)
    alt_fd_list[fd].dev      = 0;
 4018868:	e0ffff17 	ldw	r3,-4(fp)
 401886c:	1805883a 	mov	r2,r3
 4018870:	1085883a 	add	r2,r2,r2
 4018874:	10c5883a 	add	r2,r2,r3
 4018878:	100490ba 	slli	r2,r2,2
 401887c:	00c100b4 	movhi	r3,1026
 4018880:	10c7883a 	add	r3,r2,r3
 4018884:	182efb15 	stw	zero,-17428(r3)
  }
}
 4018888:	0001883a 	nop
 401888c:	e037883a 	mov	sp,fp
 4018890:	df000017 	ldw	fp,0(sp)
 4018894:	dec00104 	addi	sp,sp,4
 4018898:	f800283a 	ret

0401889c <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
 401889c:	defff904 	addi	sp,sp,-28
 40188a0:	df000615 	stw	fp,24(sp)
 40188a4:	df000604 	addi	fp,sp,24
 40188a8:	e13ffa15 	stw	r4,-24(fp)
  NIOS2_READ_STATUS (context);
 40188ac:	0005303a 	rdctl	r2,status
 40188b0:	e0bffd15 	stw	r2,-12(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 40188b4:	e0fffd17 	ldw	r3,-12(fp)
 40188b8:	00bfff84 	movi	r2,-2
 40188bc:	1884703a 	and	r2,r3,r2
 40188c0:	1001703a 	wrctl	status,r2
  return context;
 40188c4:	e0bffd17 	ldw	r2,-12(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
 40188c8:	e0bfff15 	stw	r2,-4(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
 40188cc:	d0a00c17 	ldw	r2,-32720(gp)
 40188d0:	10c000c4 	addi	r3,r2,3
 40188d4:	00bfff04 	movi	r2,-4
 40188d8:	1884703a 	and	r2,r3,r2
 40188dc:	d0a00c15 	stw	r2,-32720(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
 40188e0:	d0e00c17 	ldw	r3,-32720(gp)
 40188e4:	e0bffa17 	ldw	r2,-24(fp)
 40188e8:	1887883a 	add	r3,r3,r2
 40188ec:	00820034 	movhi	r2,2048
 40188f0:	10800004 	addi	r2,r2,0
 40188f4:	10c0072e 	bgeu	r2,r3,4018914 <sbrk+0x78>
 40188f8:	e0bfff17 	ldw	r2,-4(fp)
 40188fc:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context);
 4018900:	e0bffc17 	ldw	r2,-16(fp)
 4018904:	1001703a 	wrctl	status,r2
}
 4018908:	0001883a 	nop
    alt_irq_enable_all(context);
    return (caddr_t)-1;
 401890c:	00bfffc4 	movi	r2,-1
 4018910:	00000c06 	br	4018944 <sbrk+0xa8>
  }
#endif

  prev_heap_end = heap_end; 
 4018914:	d0a00c17 	ldw	r2,-32720(gp)
 4018918:	e0bffe15 	stw	r2,-8(fp)
  heap_end += incr; 
 401891c:	d0e00c17 	ldw	r3,-32720(gp)
 4018920:	e0bffa17 	ldw	r2,-24(fp)
 4018924:	1885883a 	add	r2,r3,r2
 4018928:	d0a00c15 	stw	r2,-32720(gp)
 401892c:	e0bfff17 	ldw	r2,-4(fp)
 4018930:	e0bffb15 	stw	r2,-20(fp)
  NIOS2_WRITE_STATUS (context);
 4018934:	e0bffb17 	ldw	r2,-20(fp)
 4018938:	1001703a 	wrctl	status,r2
}
 401893c:	0001883a 	nop

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
 4018940:	e0bffe17 	ldw	r2,-8(fp)
} 
 4018944:	e037883a 	mov	sp,fp
 4018948:	df000017 	ldw	fp,0(sp)
 401894c:	dec00104 	addi	sp,sp,4
 4018950:	f800283a 	ret

04018954 <alt_get_errno>:
{
 4018954:	defffe04 	addi	sp,sp,-8
 4018958:	dfc00115 	stw	ra,4(sp)
 401895c:	df000015 	stw	fp,0(sp)
 4018960:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 4018964:	d0a00a17 	ldw	r2,-32728(gp)
 4018968:	10000326 	beq	r2,zero,4018978 <alt_get_errno+0x24>
 401896c:	d0a00a17 	ldw	r2,-32728(gp)
 4018970:	103ee83a 	callr	r2
 4018974:	00000106 	br	401897c <alt_get_errno+0x28>
 4018978:	d0a72704 	addi	r2,gp,-25444
}
 401897c:	e037883a 	mov	sp,fp
 4018980:	dfc00117 	ldw	ra,4(sp)
 4018984:	df000017 	ldw	fp,0(sp)
 4018988:	dec00204 	addi	sp,sp,8
 401898c:	f800283a 	ret

04018990 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
 4018990:	defff904 	addi	sp,sp,-28
 4018994:	dfc00615 	stw	ra,24(sp)
 4018998:	df000515 	stw	fp,20(sp)
 401899c:	df000504 	addi	fp,sp,20
 40189a0:	e13ffd15 	stw	r4,-12(fp)
 40189a4:	e17ffc15 	stw	r5,-16(fp)
 40189a8:	e1bffb15 	stw	r6,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 40189ac:	e0bffd17 	ldw	r2,-12(fp)
 40189b0:	10000916 	blt	r2,zero,40189d8 <write+0x48>
 40189b4:	e0fffd17 	ldw	r3,-12(fp)
 40189b8:	1805883a 	mov	r2,r3
 40189bc:	1085883a 	add	r2,r2,r2
 40189c0:	10c5883a 	add	r2,r2,r3
 40189c4:	100490ba 	slli	r2,r2,2
 40189c8:	00c100b4 	movhi	r3,1026
 40189cc:	18eefb04 	addi	r3,r3,-17428
 40189d0:	10c5883a 	add	r2,r2,r3
 40189d4:	00000106 	br	40189dc <write+0x4c>
 40189d8:	0005883a 	mov	r2,zero
 40189dc:	e0bfff15 	stw	r2,-4(fp)
  
  if (fd)
 40189e0:	e0bfff17 	ldw	r2,-4(fp)
 40189e4:	10002126 	beq	r2,zero,4018a6c <write+0xdc>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
 40189e8:	e0bfff17 	ldw	r2,-4(fp)
 40189ec:	10800217 	ldw	r2,8(r2)
 40189f0:	108000cc 	andi	r2,r2,3
 40189f4:	10001826 	beq	r2,zero,4018a58 <write+0xc8>
 40189f8:	e0bfff17 	ldw	r2,-4(fp)
 40189fc:	10800017 	ldw	r2,0(r2)
 4018a00:	10800617 	ldw	r2,24(r2)
 4018a04:	10001426 	beq	r2,zero,4018a58 <write+0xc8>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
 4018a08:	e0bfff17 	ldw	r2,-4(fp)
 4018a0c:	10800017 	ldw	r2,0(r2)
 4018a10:	10800617 	ldw	r2,24(r2)
 4018a14:	e0fffb17 	ldw	r3,-20(fp)
 4018a18:	180d883a 	mov	r6,r3
 4018a1c:	e17ffc17 	ldw	r5,-16(fp)
 4018a20:	e13fff17 	ldw	r4,-4(fp)
 4018a24:	103ee83a 	callr	r2
 4018a28:	e0bffe15 	stw	r2,-8(fp)
 4018a2c:	e0bffe17 	ldw	r2,-8(fp)
 4018a30:	1000070e 	bge	r2,zero,4018a50 <write+0xc0>
      {
        ALT_ERRNO = -rval;
 4018a34:	40189540 	call	4018954 <alt_get_errno>
 4018a38:	1007883a 	mov	r3,r2
 4018a3c:	e0bffe17 	ldw	r2,-8(fp)
 4018a40:	0085c83a 	sub	r2,zero,r2
 4018a44:	18800015 	stw	r2,0(r3)
        return -1;
 4018a48:	00bfffc4 	movi	r2,-1
 4018a4c:	00000c06 	br	4018a80 <write+0xf0>
      }
      return rval;
 4018a50:	e0bffe17 	ldw	r2,-8(fp)
 4018a54:	00000a06 	br	4018a80 <write+0xf0>
    }
    else
    {
      ALT_ERRNO = EACCES;
 4018a58:	40189540 	call	4018954 <alt_get_errno>
 4018a5c:	1007883a 	mov	r3,r2
 4018a60:	00800344 	movi	r2,13
 4018a64:	18800015 	stw	r2,0(r3)
 4018a68:	00000406 	br	4018a7c <write+0xec>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
 4018a6c:	40189540 	call	4018954 <alt_get_errno>
 4018a70:	1007883a 	mov	r3,r2
 4018a74:	00801444 	movi	r2,81
 4018a78:	18800015 	stw	r2,0(r3)
  }
  return -1;
 4018a7c:	00bfffc4 	movi	r2,-1
}
 4018a80:	e037883a 	mov	sp,fp
 4018a84:	dfc00117 	ldw	ra,4(sp)
 4018a88:	df000017 	ldw	fp,0(sp)
 4018a8c:	dec00204 	addi	sp,sp,8
 4018a90:	f800283a 	ret

04018a94 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
 4018a94:	defffd04 	addi	sp,sp,-12
 4018a98:	dfc00215 	stw	ra,8(sp)
 4018a9c:	df000115 	stw	fp,4(sp)
 4018aa0:	df000104 	addi	fp,sp,4
 4018aa4:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
 4018aa8:	d1600704 	addi	r5,gp,-32740
 4018aac:	e13fff17 	ldw	r4,-4(fp)
 4018ab0:	4019c440 	call	4019c44 <alt_dev_llist_insert>
}
 4018ab4:	e037883a 	mov	sp,fp
 4018ab8:	dfc00117 	ldw	ra,4(sp)
 4018abc:	df000017 	ldw	fp,0(sp)
 4018ac0:	dec00204 	addi	sp,sp,8
 4018ac4:	f800283a 	ret

04018ac8 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 4018ac8:	defffd04 	addi	sp,sp,-12
 4018acc:	dfc00215 	stw	ra,8(sp)
 4018ad0:	df000115 	stw	fp,4(sp)
 4018ad4:	df000104 	addi	fp,sp,4
 4018ad8:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2, nios2);
 4018adc:	401a4700 	call	401a470 <altera_nios2_gen2_irq_init>
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 4018ae0:	00800044 	movi	r2,1
 4018ae4:	1001703a 	wrctl	status,r2
}
 4018ae8:	0001883a 	nop
    alt_irq_cpu_enable_interrupts();
}
 4018aec:	0001883a 	nop
 4018af0:	e037883a 	mov	sp,fp
 4018af4:	dfc00117 	ldw	ra,4(sp)
 4018af8:	df000017 	ldw	fp,0(sp)
 4018afc:	dec00204 	addi	sp,sp,8
 4018b00:	f800283a 	ret

04018b04 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 4018b04:	defffe04 	addi	sp,sp,-8
 4018b08:	dfc00115 	stw	ra,4(sp)
 4018b0c:	df000015 	stw	fp,0(sp)
 4018b10:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( SYS_CLK, sys_clk);
 4018b14:	01c0fa04 	movi	r7,1000
 4018b18:	01800084 	movi	r6,2
 4018b1c:	000b883a 	mov	r5,zero
 4018b20:	01020034 	movhi	r4,2048
 4018b24:	21040004 	addi	r4,r4,4096
 4018b28:	40196640 	call	4019664 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
 4018b2c:	000d883a 	mov	r6,zero
 4018b30:	000b883a 	mov	r5,zero
 4018b34:	010100b4 	movhi	r4,1026
 4018b38:	212f6504 	addi	r4,r4,-17004
 4018b3c:	4018cd80 	call	4018cd8 <altera_avalon_jtag_uart_init>
 4018b40:	010100b4 	movhi	r4,1026
 4018b44:	212f5b04 	addi	r4,r4,-17044
 4018b48:	4018a940 	call	4018a94 <alt_dev_reg>
    ALTERA_AVALON_SPI_INIT ( ESP32_SPI, esp32_spi);
 4018b4c:	0001883a 	nop
    ALTERA_UP_AVALON_ACCELEROMETER_SPI_INIT ( ACCELEROMETER_SPI, accelerometer_spi);
 4018b50:	010100b4 	movhi	r4,1026
 4018b54:	21337304 	addi	r4,r4,-12852
 4018b58:	4018a940 	call	4018a94 <alt_dev_reg>
}
 4018b5c:	0001883a 	nop
 4018b60:	e037883a 	mov	sp,fp
 4018b64:	dfc00117 	ldw	ra,4(sp)
 4018b68:	df000017 	ldw	fp,0(sp)
 4018b6c:	dec00204 	addi	sp,sp,8
 4018b70:	f800283a 	ret

04018b74 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 4018b74:	defffa04 	addi	sp,sp,-24
 4018b78:	dfc00515 	stw	ra,20(sp)
 4018b7c:	df000415 	stw	fp,16(sp)
 4018b80:	df000404 	addi	fp,sp,16
 4018b84:	e13ffe15 	stw	r4,-8(fp)
 4018b88:	e17ffd15 	stw	r5,-12(fp)
 4018b8c:	e1bffc15 	stw	r6,-16(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 4018b90:	e0bffe17 	ldw	r2,-8(fp)
 4018b94:	10800017 	ldw	r2,0(r2)
 4018b98:	e0bfff15 	stw	r2,-4(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
 4018b9c:	e0bfff17 	ldw	r2,-4(fp)
 4018ba0:	10c00a04 	addi	r3,r2,40
 4018ba4:	e0bffe17 	ldw	r2,-8(fp)
 4018ba8:	10800217 	ldw	r2,8(r2)
 4018bac:	100f883a 	mov	r7,r2
 4018bb0:	e1bffc17 	ldw	r6,-16(fp)
 4018bb4:	e17ffd17 	ldw	r5,-12(fp)
 4018bb8:	1809883a 	mov	r4,r3
 4018bbc:	40191a00 	call	40191a0 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
 4018bc0:	e037883a 	mov	sp,fp
 4018bc4:	dfc00117 	ldw	ra,4(sp)
 4018bc8:	df000017 	ldw	fp,0(sp)
 4018bcc:	dec00204 	addi	sp,sp,8
 4018bd0:	f800283a 	ret

04018bd4 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 4018bd4:	defffa04 	addi	sp,sp,-24
 4018bd8:	dfc00515 	stw	ra,20(sp)
 4018bdc:	df000415 	stw	fp,16(sp)
 4018be0:	df000404 	addi	fp,sp,16
 4018be4:	e13ffe15 	stw	r4,-8(fp)
 4018be8:	e17ffd15 	stw	r5,-12(fp)
 4018bec:	e1bffc15 	stw	r6,-16(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 4018bf0:	e0bffe17 	ldw	r2,-8(fp)
 4018bf4:	10800017 	ldw	r2,0(r2)
 4018bf8:	e0bfff15 	stw	r2,-4(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
 4018bfc:	e0bfff17 	ldw	r2,-4(fp)
 4018c00:	10c00a04 	addi	r3,r2,40
 4018c04:	e0bffe17 	ldw	r2,-8(fp)
 4018c08:	10800217 	ldw	r2,8(r2)
 4018c0c:	100f883a 	mov	r7,r2
 4018c10:	e1bffc17 	ldw	r6,-16(fp)
 4018c14:	e17ffd17 	ldw	r5,-12(fp)
 4018c18:	1809883a 	mov	r4,r3
 4018c1c:	40193c00 	call	40193c0 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
 4018c20:	e037883a 	mov	sp,fp
 4018c24:	dfc00117 	ldw	ra,4(sp)
 4018c28:	df000017 	ldw	fp,0(sp)
 4018c2c:	dec00204 	addi	sp,sp,8
 4018c30:	f800283a 	ret

04018c34 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
 4018c34:	defffc04 	addi	sp,sp,-16
 4018c38:	dfc00315 	stw	ra,12(sp)
 4018c3c:	df000215 	stw	fp,8(sp)
 4018c40:	df000204 	addi	fp,sp,8
 4018c44:	e13ffe15 	stw	r4,-8(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 4018c48:	e0bffe17 	ldw	r2,-8(fp)
 4018c4c:	10800017 	ldw	r2,0(r2)
 4018c50:	e0bfff15 	stw	r2,-4(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
 4018c54:	e0bfff17 	ldw	r2,-4(fp)
 4018c58:	10c00a04 	addi	r3,r2,40
 4018c5c:	e0bffe17 	ldw	r2,-8(fp)
 4018c60:	10800217 	ldw	r2,8(r2)
 4018c64:	100b883a 	mov	r5,r2
 4018c68:	1809883a 	mov	r4,r3
 4018c6c:	40190440 	call	4019044 <altera_avalon_jtag_uart_close>
}
 4018c70:	e037883a 	mov	sp,fp
 4018c74:	dfc00117 	ldw	ra,4(sp)
 4018c78:	df000017 	ldw	fp,0(sp)
 4018c7c:	dec00204 	addi	sp,sp,8
 4018c80:	f800283a 	ret

04018c84 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
 4018c84:	defffa04 	addi	sp,sp,-24
 4018c88:	dfc00515 	stw	ra,20(sp)
 4018c8c:	df000415 	stw	fp,16(sp)
 4018c90:	df000404 	addi	fp,sp,16
 4018c94:	e13ffe15 	stw	r4,-8(fp)
 4018c98:	e17ffd15 	stw	r5,-12(fp)
 4018c9c:	e1bffc15 	stw	r6,-16(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
 4018ca0:	e0bffe17 	ldw	r2,-8(fp)
 4018ca4:	10800017 	ldw	r2,0(r2)
 4018ca8:	e0bfff15 	stw	r2,-4(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
 4018cac:	e0bfff17 	ldw	r2,-4(fp)
 4018cb0:	10800a04 	addi	r2,r2,40
 4018cb4:	e1bffc17 	ldw	r6,-16(fp)
 4018cb8:	e17ffd17 	ldw	r5,-12(fp)
 4018cbc:	1009883a 	mov	r4,r2
 4018cc0:	40190ac0 	call	40190ac <altera_avalon_jtag_uart_ioctl>
}
 4018cc4:	e037883a 	mov	sp,fp
 4018cc8:	dfc00117 	ldw	ra,4(sp)
 4018ccc:	df000017 	ldw	fp,0(sp)
 4018cd0:	dec00204 	addi	sp,sp,8
 4018cd4:	f800283a 	ret

04018cd8 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
 4018cd8:	defffa04 	addi	sp,sp,-24
 4018cdc:	dfc00515 	stw	ra,20(sp)
 4018ce0:	df000415 	stw	fp,16(sp)
 4018ce4:	df000404 	addi	fp,sp,16
 4018ce8:	e13fff15 	stw	r4,-4(fp)
 4018cec:	e17ffe15 	stw	r5,-8(fp)
 4018cf0:	e1bffd15 	stw	r6,-12(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 4018cf4:	e0bfff17 	ldw	r2,-4(fp)
 4018cf8:	00c00044 	movi	r3,1
 4018cfc:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
 4018d00:	e0bfff17 	ldw	r2,-4(fp)
 4018d04:	10800017 	ldw	r2,0(r2)
 4018d08:	10800104 	addi	r2,r2,4
 4018d0c:	1007883a 	mov	r3,r2
 4018d10:	e0bfff17 	ldw	r2,-4(fp)
 4018d14:	10800817 	ldw	r2,32(r2)
 4018d18:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
 4018d1c:	e0bffe17 	ldw	r2,-8(fp)
 4018d20:	e0fffd17 	ldw	r3,-12(fp)
 4018d24:	d8000015 	stw	zero,0(sp)
 4018d28:	e1ffff17 	ldw	r7,-4(fp)
 4018d2c:	018100b4 	movhi	r6,1026
 4018d30:	31a36604 	addi	r6,r6,-29288
 4018d34:	180b883a 	mov	r5,r3
 4018d38:	1009883a 	mov	r4,r2
 4018d3c:	4017f300 	call	4017f30 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
 4018d40:	e0bfff17 	ldw	r2,-4(fp)
 4018d44:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
 4018d48:	e0bfff17 	ldw	r2,-4(fp)
 4018d4c:	10800204 	addi	r2,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 4018d50:	d0e72e17 	ldw	r3,-25416(gp)
 4018d54:	e1ffff17 	ldw	r7,-4(fp)
 4018d58:	018100b4 	movhi	r6,1026
 4018d5c:	31a3e904 	addi	r6,r6,-28764
 4018d60:	180b883a 	mov	r5,r3
 4018d64:	1009883a 	mov	r4,r2
 4018d68:	4019ab40 	call	4019ab4 <alt_alarm_start>
 4018d6c:	1000040e 	bge	r2,zero,4018d80 <altera_avalon_jtag_uart_init+0xa8>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
 4018d70:	e0ffff17 	ldw	r3,-4(fp)
 4018d74:	00a00034 	movhi	r2,32768
 4018d78:	10bfffc4 	addi	r2,r2,-1
 4018d7c:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
 4018d80:	0001883a 	nop
 4018d84:	e037883a 	mov	sp,fp
 4018d88:	dfc00117 	ldw	ra,4(sp)
 4018d8c:	df000017 	ldw	fp,0(sp)
 4018d90:	dec00204 	addi	sp,sp,8
 4018d94:	f800283a 	ret

04018d98 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
 4018d98:	defff804 	addi	sp,sp,-32
 4018d9c:	df000715 	stw	fp,28(sp)
 4018da0:	df000704 	addi	fp,sp,28
 4018da4:	e13ff915 	stw	r4,-28(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
 4018da8:	e0bff917 	ldw	r2,-28(fp)
 4018dac:	e0bffd15 	stw	r2,-12(fp)
  unsigned int base = sp->base;
 4018db0:	e0bffd17 	ldw	r2,-12(fp)
 4018db4:	10800017 	ldw	r2,0(r2)
 4018db8:	e0bffc15 	stw	r2,-16(fp)
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 4018dbc:	e0bffc17 	ldw	r2,-16(fp)
 4018dc0:	10800104 	addi	r2,r2,4
 4018dc4:	10800037 	ldwio	r2,0(r2)
 4018dc8:	e0bffb15 	stw	r2,-20(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
 4018dcc:	e0bffb17 	ldw	r2,-20(fp)
 4018dd0:	1080c00c 	andi	r2,r2,768
 4018dd4:	10006d26 	beq	r2,zero,4018f8c <altera_avalon_jtag_uart_irq+0x1f4>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
 4018dd8:	e0bffb17 	ldw	r2,-20(fp)
 4018ddc:	1080400c 	andi	r2,r2,256
 4018de0:	10003526 	beq	r2,zero,4018eb8 <altera_avalon_jtag_uart_irq+0x120>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
 4018de4:	00800074 	movhi	r2,1
 4018de8:	e0bfff15 	stw	r2,-4(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 4018dec:	e0bffd17 	ldw	r2,-12(fp)
 4018df0:	10800a17 	ldw	r2,40(r2)
 4018df4:	10800044 	addi	r2,r2,1
 4018df8:	1081ffcc 	andi	r2,r2,2047
 4018dfc:	e0bffa15 	stw	r2,-24(fp)
        if (next == sp->rx_out)
 4018e00:	e0bffd17 	ldw	r2,-12(fp)
 4018e04:	10800b17 	ldw	r2,44(r2)
 4018e08:	e0fffa17 	ldw	r3,-24(fp)
 4018e0c:	18801526 	beq	r3,r2,4018e64 <altera_avalon_jtag_uart_irq+0xcc>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
 4018e10:	e0bffc17 	ldw	r2,-16(fp)
 4018e14:	10800037 	ldwio	r2,0(r2)
 4018e18:	e0bfff15 	stw	r2,-4(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
 4018e1c:	e0bfff17 	ldw	r2,-4(fp)
 4018e20:	10a0000c 	andi	r2,r2,32768
 4018e24:	10001126 	beq	r2,zero,4018e6c <altera_avalon_jtag_uart_irq+0xd4>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
 4018e28:	e0bffd17 	ldw	r2,-12(fp)
 4018e2c:	10800a17 	ldw	r2,40(r2)
 4018e30:	e0ffff17 	ldw	r3,-4(fp)
 4018e34:	1809883a 	mov	r4,r3
 4018e38:	e0fffd17 	ldw	r3,-12(fp)
 4018e3c:	1885883a 	add	r2,r3,r2
 4018e40:	11000e05 	stb	r4,56(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 4018e44:	e0bffd17 	ldw	r2,-12(fp)
 4018e48:	10800a17 	ldw	r2,40(r2)
 4018e4c:	10800044 	addi	r2,r2,1
 4018e50:	10c1ffcc 	andi	r3,r2,2047
 4018e54:	e0bffd17 	ldw	r2,-12(fp)
 4018e58:	10c00a15 	stw	r3,40(r2)
 * HAL.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_no_error (void)
{
  return 0;
 4018e5c:	0001883a 	nop
      {
 4018e60:	003fe206 	br	4018dec <altera_avalon_jtag_uart_irq+0x54>
          break;
 4018e64:	0001883a 	nop
 4018e68:	00000106 	br	4018e70 <altera_avalon_jtag_uart_irq+0xd8>
          break;
 4018e6c:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
 4018e70:	e0bfff17 	ldw	r2,-4(fp)
 4018e74:	10bfffec 	andhi	r2,r2,65535
 4018e78:	10000f26 	beq	r2,zero,4018eb8 <altera_avalon_jtag_uart_irq+0x120>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 4018e7c:	e0bffd17 	ldw	r2,-12(fp)
 4018e80:	10c00817 	ldw	r3,32(r2)
 4018e84:	00bfff84 	movi	r2,-2
 4018e88:	1886703a 	and	r3,r3,r2
 4018e8c:	e0bffd17 	ldw	r2,-12(fp)
 4018e90:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
 4018e94:	e0bffc17 	ldw	r2,-16(fp)
 4018e98:	10800104 	addi	r2,r2,4
 4018e9c:	1007883a 	mov	r3,r2
 4018ea0:	e0bffd17 	ldw	r2,-12(fp)
 4018ea4:	10800817 	ldw	r2,32(r2)
 4018ea8:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 4018eac:	e0bffc17 	ldw	r2,-16(fp)
 4018eb0:	10800104 	addi	r2,r2,4
 4018eb4:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
 4018eb8:	e0bffb17 	ldw	r2,-20(fp)
 4018ebc:	1080800c 	andi	r2,r2,512
 4018ec0:	103fbe26 	beq	r2,zero,4018dbc <altera_avalon_jtag_uart_irq+0x24>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
 4018ec4:	e0bffb17 	ldw	r2,-20(fp)
 4018ec8:	1004d43a 	srli	r2,r2,16
 4018ecc:	e0bffe15 	stw	r2,-8(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
 4018ed0:	00001406 	br	4018f24 <altera_avalon_jtag_uart_irq+0x18c>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
 4018ed4:	e0bffc17 	ldw	r2,-16(fp)
 4018ed8:	e0fffd17 	ldw	r3,-12(fp)
 4018edc:	18c00d17 	ldw	r3,52(r3)
 4018ee0:	e13ffd17 	ldw	r4,-12(fp)
 4018ee4:	20c7883a 	add	r3,r4,r3
 4018ee8:	18c20e03 	ldbu	r3,2104(r3)
 4018eec:	18c03fcc 	andi	r3,r3,255
 4018ef0:	18c0201c 	xori	r3,r3,128
 4018ef4:	18ffe004 	addi	r3,r3,-128
 4018ef8:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 4018efc:	e0bffd17 	ldw	r2,-12(fp)
 4018f00:	10800d17 	ldw	r2,52(r2)
 4018f04:	10800044 	addi	r2,r2,1
 4018f08:	10c1ffcc 	andi	r3,r2,2047
 4018f0c:	e0bffd17 	ldw	r2,-12(fp)
 4018f10:	10c00d15 	stw	r3,52(r2)
 4018f14:	0001883a 	nop

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
 4018f18:	e0bffe17 	ldw	r2,-8(fp)
 4018f1c:	10bfffc4 	addi	r2,r2,-1
 4018f20:	e0bffe15 	stw	r2,-8(fp)
      while (space > 0 && sp->tx_out != sp->tx_in)
 4018f24:	e0bffe17 	ldw	r2,-8(fp)
 4018f28:	10000526 	beq	r2,zero,4018f40 <altera_avalon_jtag_uart_irq+0x1a8>
 4018f2c:	e0bffd17 	ldw	r2,-12(fp)
 4018f30:	10c00d17 	ldw	r3,52(r2)
 4018f34:	e0bffd17 	ldw	r2,-12(fp)
 4018f38:	10800c17 	ldw	r2,48(r2)
 4018f3c:	18bfe51e 	bne	r3,r2,4018ed4 <altera_avalon_jtag_uart_irq+0x13c>
      }

      if (space > 0)
 4018f40:	e0bffe17 	ldw	r2,-8(fp)
 4018f44:	103f9d26 	beq	r2,zero,4018dbc <altera_avalon_jtag_uart_irq+0x24>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 4018f48:	e0bffd17 	ldw	r2,-12(fp)
 4018f4c:	10c00817 	ldw	r3,32(r2)
 4018f50:	00bfff44 	movi	r2,-3
 4018f54:	1886703a 	and	r3,r3,r2
 4018f58:	e0bffd17 	ldw	r2,-12(fp)
 4018f5c:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 4018f60:	e0bffd17 	ldw	r2,-12(fp)
 4018f64:	10800017 	ldw	r2,0(r2)
 4018f68:	10800104 	addi	r2,r2,4
 4018f6c:	1007883a 	mov	r3,r2
 4018f70:	e0bffd17 	ldw	r2,-12(fp)
 4018f74:	10800817 	ldw	r2,32(r2)
 4018f78:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 4018f7c:	e0bffc17 	ldw	r2,-16(fp)
 4018f80:	10800104 	addi	r2,r2,4
 4018f84:	10800037 	ldwio	r2,0(r2)
  {
 4018f88:	003f8c06 	br	4018dbc <altera_avalon_jtag_uart_irq+0x24>
      break;
 4018f8c:	0001883a 	nop
      }
    }
  }
}
 4018f90:	0001883a 	nop
 4018f94:	e037883a 	mov	sp,fp
 4018f98:	df000017 	ldw	fp,0(sp)
 4018f9c:	dec00104 	addi	sp,sp,4
 4018fa0:	f800283a 	ret

04018fa4 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
 4018fa4:	defffc04 	addi	sp,sp,-16
 4018fa8:	df000315 	stw	fp,12(sp)
 4018fac:	df000304 	addi	fp,sp,12
 4018fb0:	e13ffd15 	stw	r4,-12(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
 4018fb4:	e0bffd17 	ldw	r2,-12(fp)
 4018fb8:	e0bfff15 	stw	r2,-4(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
 4018fbc:	e0bfff17 	ldw	r2,-4(fp)
 4018fc0:	10800017 	ldw	r2,0(r2)
 4018fc4:	10800104 	addi	r2,r2,4
 4018fc8:	10800037 	ldwio	r2,0(r2)
 4018fcc:	e0bffe15 	stw	r2,-8(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
 4018fd0:	e0bffe17 	ldw	r2,-8(fp)
 4018fd4:	1081000c 	andi	r2,r2,1024
 4018fd8:	10000b26 	beq	r2,zero,4019008 <altera_avalon_jtag_uart_timeout+0x64>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
 4018fdc:	e0bfff17 	ldw	r2,-4(fp)
 4018fe0:	10800017 	ldw	r2,0(r2)
 4018fe4:	10800104 	addi	r2,r2,4
 4018fe8:	1007883a 	mov	r3,r2
 4018fec:	e0bfff17 	ldw	r2,-4(fp)
 4018ff0:	10800817 	ldw	r2,32(r2)
 4018ff4:	10810014 	ori	r2,r2,1024
 4018ff8:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
 4018ffc:	e0bfff17 	ldw	r2,-4(fp)
 4019000:	10000915 	stw	zero,36(r2)
 4019004:	00000a06 	br	4019030 <altera_avalon_jtag_uart_timeout+0x8c>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
 4019008:	e0bfff17 	ldw	r2,-4(fp)
 401900c:	10c00917 	ldw	r3,36(r2)
 4019010:	00a00034 	movhi	r2,32768
 4019014:	10bfff04 	addi	r2,r2,-4
 4019018:	10c00536 	bltu	r2,r3,4019030 <altera_avalon_jtag_uart_timeout+0x8c>
    sp->host_inactive++;
 401901c:	e0bfff17 	ldw	r2,-4(fp)
 4019020:	10800917 	ldw	r2,36(r2)
 4019024:	10c00044 	addi	r3,r2,1
 4019028:	e0bfff17 	ldw	r2,-4(fp)
 401902c:	10c00915 	stw	r3,36(r2)
 4019030:	d0a72e17 	ldw	r2,-25416(gp)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
 4019034:	e037883a 	mov	sp,fp
 4019038:	df000017 	ldw	fp,0(sp)
 401903c:	dec00104 	addi	sp,sp,4
 4019040:	f800283a 	ret

04019044 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
 4019044:	defffd04 	addi	sp,sp,-12
 4019048:	df000215 	stw	fp,8(sp)
 401904c:	df000204 	addi	fp,sp,8
 4019050:	e13fff15 	stw	r4,-4(fp)
 4019054:	e17ffe15 	stw	r5,-8(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 4019058:	00000506 	br	4019070 <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
 401905c:	e0bffe17 	ldw	r2,-8(fp)
 4019060:	1090000c 	andi	r2,r2,16384
 4019064:	10000226 	beq	r2,zero,4019070 <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
 4019068:	00bffd44 	movi	r2,-11
 401906c:	00000b06 	br	401909c <altera_avalon_jtag_uart_close+0x58>
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 4019070:	e0bfff17 	ldw	r2,-4(fp)
 4019074:	10c00d17 	ldw	r3,52(r2)
 4019078:	e0bfff17 	ldw	r2,-4(fp)
 401907c:	10800c17 	ldw	r2,48(r2)
 4019080:	18800526 	beq	r3,r2,4019098 <altera_avalon_jtag_uart_close+0x54>
 4019084:	e0bfff17 	ldw	r2,-4(fp)
 4019088:	10c00917 	ldw	r3,36(r2)
 401908c:	e0bfff17 	ldw	r2,-4(fp)
 4019090:	10800117 	ldw	r2,4(r2)
 4019094:	18bff136 	bltu	r3,r2,401905c <altera_avalon_jtag_uart_close+0x18>
    }
  }

  return 0;
 4019098:	0005883a 	mov	r2,zero
}
 401909c:	e037883a 	mov	sp,fp
 40190a0:	df000017 	ldw	fp,0(sp)
 40190a4:	dec00104 	addi	sp,sp,4
 40190a8:	f800283a 	ret

040190ac <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
 40190ac:	defffa04 	addi	sp,sp,-24
 40190b0:	df000515 	stw	fp,20(sp)
 40190b4:	df000504 	addi	fp,sp,20
 40190b8:	e13ffd15 	stw	r4,-12(fp)
 40190bc:	e17ffc15 	stw	r5,-16(fp)
 40190c0:	e1bffb15 	stw	r6,-20(fp)
  int rc = -ENOTTY;
 40190c4:	00bff9c4 	movi	r2,-25
 40190c8:	e0bfff15 	stw	r2,-4(fp)

  switch (req)
 40190cc:	e0bffc17 	ldw	r2,-16(fp)
 40190d0:	109a8060 	cmpeqi	r2,r2,27137
 40190d4:	1000041e 	bne	r2,zero,40190e8 <altera_avalon_jtag_uart_ioctl+0x3c>
 40190d8:	e0bffc17 	ldw	r2,-16(fp)
 40190dc:	109a80a0 	cmpeqi	r2,r2,27138
 40190e0:	1000181e 	bne	r2,zero,4019144 <altera_avalon_jtag_uart_ioctl+0x98>
      rc = 0;
    }
    break;

  default:
    break;
 40190e4:	00002906 	br	401918c <altera_avalon_jtag_uart_ioctl+0xe0>
    if (sp->timeout != INT_MAX)
 40190e8:	e0bffd17 	ldw	r2,-12(fp)
 40190ec:	10c00117 	ldw	r3,4(r2)
 40190f0:	00a00034 	movhi	r2,32768
 40190f4:	10bfffc4 	addi	r2,r2,-1
 40190f8:	18802126 	beq	r3,r2,4019180 <altera_avalon_jtag_uart_ioctl+0xd4>
      int timeout = *((int *)arg);
 40190fc:	e0bffb17 	ldw	r2,-20(fp)
 4019100:	10800017 	ldw	r2,0(r2)
 4019104:	e0bffe15 	stw	r2,-8(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
 4019108:	e0bffe17 	ldw	r2,-8(fp)
 401910c:	10800090 	cmplti	r2,r2,2
 4019110:	1000061e 	bne	r2,zero,401912c <altera_avalon_jtag_uart_ioctl+0x80>
 4019114:	e0fffe17 	ldw	r3,-8(fp)
 4019118:	00a00034 	movhi	r2,32768
 401911c:	10bfffc4 	addi	r2,r2,-1
 4019120:	18800226 	beq	r3,r2,401912c <altera_avalon_jtag_uart_ioctl+0x80>
 4019124:	e0bffe17 	ldw	r2,-8(fp)
 4019128:	00000206 	br	4019134 <altera_avalon_jtag_uart_ioctl+0x88>
 401912c:	00a00034 	movhi	r2,32768
 4019130:	10bfff84 	addi	r2,r2,-2
 4019134:	e0fffd17 	ldw	r3,-12(fp)
 4019138:	18800115 	stw	r2,4(r3)
      rc = 0;
 401913c:	e03fff15 	stw	zero,-4(fp)
    break;
 4019140:	00000f06 	br	4019180 <altera_avalon_jtag_uart_ioctl+0xd4>
    if (sp->timeout != INT_MAX)
 4019144:	e0bffd17 	ldw	r2,-12(fp)
 4019148:	10c00117 	ldw	r3,4(r2)
 401914c:	00a00034 	movhi	r2,32768
 4019150:	10bfffc4 	addi	r2,r2,-1
 4019154:	18800c26 	beq	r3,r2,4019188 <altera_avalon_jtag_uart_ioctl+0xdc>
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
 4019158:	e0bffd17 	ldw	r2,-12(fp)
 401915c:	10c00917 	ldw	r3,36(r2)
 4019160:	e0bffd17 	ldw	r2,-12(fp)
 4019164:	10800117 	ldw	r2,4(r2)
 4019168:	1885803a 	cmpltu	r2,r3,r2
 401916c:	10c03fcc 	andi	r3,r2,255
 4019170:	e0bffb17 	ldw	r2,-20(fp)
 4019174:	10c00015 	stw	r3,0(r2)
      rc = 0;
 4019178:	e03fff15 	stw	zero,-4(fp)
    break;
 401917c:	00000206 	br	4019188 <altera_avalon_jtag_uart_ioctl+0xdc>
    break;
 4019180:	0001883a 	nop
 4019184:	00000106 	br	401918c <altera_avalon_jtag_uart_ioctl+0xe0>
    break;
 4019188:	0001883a 	nop
  }

  return rc;
 401918c:	e0bfff17 	ldw	r2,-4(fp)
}
 4019190:	e037883a 	mov	sp,fp
 4019194:	df000017 	ldw	fp,0(sp)
 4019198:	dec00104 	addi	sp,sp,4
 401919c:	f800283a 	ret

040191a0 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
 40191a0:	defff304 	addi	sp,sp,-52
 40191a4:	dfc00c15 	stw	ra,48(sp)
 40191a8:	df000b15 	stw	fp,44(sp)
 40191ac:	df000b04 	addi	fp,sp,44
 40191b0:	e13ff815 	stw	r4,-32(fp)
 40191b4:	e17ff715 	stw	r5,-36(fp)
 40191b8:	e1bff615 	stw	r6,-40(fp)
 40191bc:	e1fff515 	stw	r7,-44(fp)
  char * ptr = buffer;
 40191c0:	e0bff717 	ldw	r2,-36(fp)
 40191c4:	e0bfff15 	stw	r2,-4(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 40191c8:	00004706 	br	40192e8 <altera_avalon_jtag_uart_read+0x148>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
 40191cc:	e0bff817 	ldw	r2,-32(fp)
 40191d0:	10800a17 	ldw	r2,40(r2)
 40191d4:	e0bffd15 	stw	r2,-12(fp)
      out = sp->rx_out;
 40191d8:	e0bff817 	ldw	r2,-32(fp)
 40191dc:	10800b17 	ldw	r2,44(r2)
 40191e0:	e0bffc15 	stw	r2,-16(fp)

      if (in >= out)
 40191e4:	e0fffd17 	ldw	r3,-12(fp)
 40191e8:	e0bffc17 	ldw	r2,-16(fp)
 40191ec:	18800536 	bltu	r3,r2,4019204 <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
 40191f0:	e0fffd17 	ldw	r3,-12(fp)
 40191f4:	e0bffc17 	ldw	r2,-16(fp)
 40191f8:	1885c83a 	sub	r2,r3,r2
 40191fc:	e0bffe15 	stw	r2,-8(fp)
 4019200:	00000406 	br	4019214 <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
 4019204:	00c20004 	movi	r3,2048
 4019208:	e0bffc17 	ldw	r2,-16(fp)
 401920c:	1885c83a 	sub	r2,r3,r2
 4019210:	e0bffe15 	stw	r2,-8(fp)

      if (n == 0)
 4019214:	e0bffe17 	ldw	r2,-8(fp)
 4019218:	10001e26 	beq	r2,zero,4019294 <altera_avalon_jtag_uart_read+0xf4>
        break; /* No more data available */

      if (n > space)
 401921c:	e0fff617 	ldw	r3,-40(fp)
 4019220:	e0bffe17 	ldw	r2,-8(fp)
 4019224:	1880022e 	bgeu	r3,r2,4019230 <altera_avalon_jtag_uart_read+0x90>
        n = space;
 4019228:	e0bff617 	ldw	r2,-40(fp)
 401922c:	e0bffe15 	stw	r2,-8(fp)

      memcpy(ptr, sp->rx_buf + out, n);
 4019230:	e0bff817 	ldw	r2,-32(fp)
 4019234:	10c00e04 	addi	r3,r2,56
 4019238:	e0bffc17 	ldw	r2,-16(fp)
 401923c:	1885883a 	add	r2,r3,r2
 4019240:	e1bffe17 	ldw	r6,-8(fp)
 4019244:	100b883a 	mov	r5,r2
 4019248:	e13fff17 	ldw	r4,-4(fp)
 401924c:	40073000 	call	4007300 <memcpy>
      ptr   += n;
 4019250:	e0ffff17 	ldw	r3,-4(fp)
 4019254:	e0bffe17 	ldw	r2,-8(fp)
 4019258:	1885883a 	add	r2,r3,r2
 401925c:	e0bfff15 	stw	r2,-4(fp)
      space -= n;
 4019260:	e0fff617 	ldw	r3,-40(fp)
 4019264:	e0bffe17 	ldw	r2,-8(fp)
 4019268:	1885c83a 	sub	r2,r3,r2
 401926c:	e0bff615 	stw	r2,-40(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 4019270:	e0fffc17 	ldw	r3,-16(fp)
 4019274:	e0bffe17 	ldw	r2,-8(fp)
 4019278:	1885883a 	add	r2,r3,r2
 401927c:	10c1ffcc 	andi	r3,r2,2047
 4019280:	e0bff817 	ldw	r2,-32(fp)
 4019284:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
 4019288:	e0bff617 	ldw	r2,-40(fp)
 401928c:	00bfcf16 	blt	zero,r2,40191cc <altera_avalon_jtag_uart_read+0x2c>
 4019290:	00000106 	br	4019298 <altera_avalon_jtag_uart_read+0xf8>
        break; /* No more data available */
 4019294:	0001883a 	nop

    /* If we read any data then return it */
    if (ptr != buffer)
 4019298:	e0ffff17 	ldw	r3,-4(fp)
 401929c:	e0bff717 	ldw	r2,-36(fp)
 40192a0:	1880141e 	bne	r3,r2,40192f4 <altera_avalon_jtag_uart_read+0x154>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
 40192a4:	e0bff517 	ldw	r2,-44(fp)
 40192a8:	1090000c 	andi	r2,r2,16384
 40192ac:	1000131e 	bne	r2,zero,40192fc <altera_avalon_jtag_uart_read+0x15c>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
 40192b0:	0001883a 	nop
 40192b4:	e0bff817 	ldw	r2,-32(fp)
 40192b8:	10800a17 	ldw	r2,40(r2)
 40192bc:	e0fffd17 	ldw	r3,-12(fp)
 40192c0:	1880051e 	bne	r3,r2,40192d8 <altera_avalon_jtag_uart_read+0x138>
 40192c4:	e0bff817 	ldw	r2,-32(fp)
 40192c8:	10c00917 	ldw	r3,36(r2)
 40192cc:	e0bff817 	ldw	r2,-32(fp)
 40192d0:	10800117 	ldw	r2,4(r2)
 40192d4:	18bff736 	bltu	r3,r2,40192b4 <altera_avalon_jtag_uart_read+0x114>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
 40192d8:	e0bff817 	ldw	r2,-32(fp)
 40192dc:	10800a17 	ldw	r2,40(r2)
 40192e0:	e0fffd17 	ldw	r3,-12(fp)
 40192e4:	18800726 	beq	r3,r2,4019304 <altera_avalon_jtag_uart_read+0x164>
  while (space > 0)
 40192e8:	e0bff617 	ldw	r2,-40(fp)
 40192ec:	00bfb716 	blt	zero,r2,40191cc <altera_avalon_jtag_uart_read+0x2c>
 40192f0:	00000506 	br	4019308 <altera_avalon_jtag_uart_read+0x168>
      break;
 40192f4:	0001883a 	nop
 40192f8:	00000306 	br	4019308 <altera_avalon_jtag_uart_read+0x168>
      break;
 40192fc:	0001883a 	nop
 4019300:	00000106 	br	4019308 <altera_avalon_jtag_uart_read+0x168>
      break;
 4019304:	0001883a 	nop
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
 4019308:	e0ffff17 	ldw	r3,-4(fp)
 401930c:	e0bff717 	ldw	r2,-36(fp)
 4019310:	18801926 	beq	r3,r2,4019378 <altera_avalon_jtag_uart_read+0x1d8>
  NIOS2_READ_STATUS (context);
 4019314:	0005303a 	rdctl	r2,status
 4019318:	e0bff915 	stw	r2,-28(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 401931c:	e0fff917 	ldw	r3,-28(fp)
 4019320:	00bfff84 	movi	r2,-2
 4019324:	1884703a 	and	r2,r3,r2
 4019328:	1001703a 	wrctl	status,r2
  return context;
 401932c:	e0bff917 	ldw	r2,-28(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
 4019330:	e0bffb15 	stw	r2,-20(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 4019334:	e0bff817 	ldw	r2,-32(fp)
 4019338:	10800817 	ldw	r2,32(r2)
 401933c:	10c00054 	ori	r3,r2,1
 4019340:	e0bff817 	ldw	r2,-32(fp)
 4019344:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 4019348:	e0bff817 	ldw	r2,-32(fp)
 401934c:	10800017 	ldw	r2,0(r2)
 4019350:	10800104 	addi	r2,r2,4
 4019354:	1007883a 	mov	r3,r2
 4019358:	e0bff817 	ldw	r2,-32(fp)
 401935c:	10800817 	ldw	r2,32(r2)
 4019360:	18800035 	stwio	r2,0(r3)
 4019364:	e0bffb17 	ldw	r2,-20(fp)
 4019368:	e0bffa15 	stw	r2,-24(fp)
  NIOS2_WRITE_STATUS (context);
 401936c:	e0bffa17 	ldw	r2,-24(fp)
 4019370:	1001703a 	wrctl	status,r2
}
 4019374:	0001883a 	nop
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
 4019378:	e0ffff17 	ldw	r3,-4(fp)
 401937c:	e0bff717 	ldw	r2,-36(fp)
 4019380:	18800426 	beq	r3,r2,4019394 <altera_avalon_jtag_uart_read+0x1f4>
    return ptr - buffer;
 4019384:	e0ffff17 	ldw	r3,-4(fp)
 4019388:	e0bff717 	ldw	r2,-36(fp)
 401938c:	1885c83a 	sub	r2,r3,r2
 4019390:	00000606 	br	40193ac <altera_avalon_jtag_uart_read+0x20c>
  else if (flags & O_NONBLOCK)
 4019394:	e0bff517 	ldw	r2,-44(fp)
 4019398:	1090000c 	andi	r2,r2,16384
 401939c:	10000226 	beq	r2,zero,40193a8 <altera_avalon_jtag_uart_read+0x208>
    return -EWOULDBLOCK;
 40193a0:	00bffd44 	movi	r2,-11
 40193a4:	00000106 	br	40193ac <altera_avalon_jtag_uart_read+0x20c>
  else
    return -EIO;
 40193a8:	00bffec4 	movi	r2,-5
}
 40193ac:	e037883a 	mov	sp,fp
 40193b0:	dfc00117 	ldw	ra,4(sp)
 40193b4:	df000017 	ldw	fp,0(sp)
 40193b8:	dec00204 	addi	sp,sp,8
 40193bc:	f800283a 	ret

040193c0 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 40193c0:	defff304 	addi	sp,sp,-52
 40193c4:	dfc00c15 	stw	ra,48(sp)
 40193c8:	df000b15 	stw	fp,44(sp)
 40193cc:	df000b04 	addi	fp,sp,44
 40193d0:	e13ff815 	stw	r4,-32(fp)
 40193d4:	e17ff715 	stw	r5,-36(fp)
 40193d8:	e1bff615 	stw	r6,-40(fp)
 40193dc:	e1fff515 	stw	r7,-44(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
 40193e0:	e03fff15 	stw	zero,-4(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
 40193e4:	e0bff717 	ldw	r2,-36(fp)
 40193e8:	e0bffd15 	stw	r2,-12(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 40193ec:	00003706 	br	40194cc <altera_avalon_jtag_uart_write+0x10c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
 40193f0:	e0bff817 	ldw	r2,-32(fp)
 40193f4:	10800c17 	ldw	r2,48(r2)
 40193f8:	e0bffc15 	stw	r2,-16(fp)
      out = sp->tx_out;
 40193fc:	e0bff817 	ldw	r2,-32(fp)
 4019400:	10800d17 	ldw	r2,52(r2)
 4019404:	e0bfff15 	stw	r2,-4(fp)

      if (in < out)
 4019408:	e0fffc17 	ldw	r3,-16(fp)
 401940c:	e0bfff17 	ldw	r2,-4(fp)
 4019410:	1880062e 	bgeu	r3,r2,401942c <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
 4019414:	e0ffff17 	ldw	r3,-4(fp)
 4019418:	e0bffc17 	ldw	r2,-16(fp)
 401941c:	1885c83a 	sub	r2,r3,r2
 4019420:	10bfffc4 	addi	r2,r2,-1
 4019424:	e0bffe15 	stw	r2,-8(fp)
 4019428:	00000b06 	br	4019458 <altera_avalon_jtag_uart_write+0x98>
      else if (out > 0)
 401942c:	e0bfff17 	ldw	r2,-4(fp)
 4019430:	10000526 	beq	r2,zero,4019448 <altera_avalon_jtag_uart_write+0x88>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
 4019434:	00c20004 	movi	r3,2048
 4019438:	e0bffc17 	ldw	r2,-16(fp)
 401943c:	1885c83a 	sub	r2,r3,r2
 4019440:	e0bffe15 	stw	r2,-8(fp)
 4019444:	00000406 	br	4019458 <altera_avalon_jtag_uart_write+0x98>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
 4019448:	00c1ffc4 	movi	r3,2047
 401944c:	e0bffc17 	ldw	r2,-16(fp)
 4019450:	1885c83a 	sub	r2,r3,r2
 4019454:	e0bffe15 	stw	r2,-8(fp)

      if (n == 0)
 4019458:	e0bffe17 	ldw	r2,-8(fp)
 401945c:	10001e26 	beq	r2,zero,40194d8 <altera_avalon_jtag_uart_write+0x118>
        break;

      if (n > count)
 4019460:	e0fff617 	ldw	r3,-40(fp)
 4019464:	e0bffe17 	ldw	r2,-8(fp)
 4019468:	1880022e 	bgeu	r3,r2,4019474 <altera_avalon_jtag_uart_write+0xb4>
        n = count;
 401946c:	e0bff617 	ldw	r2,-40(fp)
 4019470:	e0bffe15 	stw	r2,-8(fp)

      memcpy(sp->tx_buf + in, ptr, n);
 4019474:	e0bff817 	ldw	r2,-32(fp)
 4019478:	10c20e04 	addi	r3,r2,2104
 401947c:	e0bffc17 	ldw	r2,-16(fp)
 4019480:	1885883a 	add	r2,r3,r2
 4019484:	e1bffe17 	ldw	r6,-8(fp)
 4019488:	e17ff717 	ldw	r5,-36(fp)
 401948c:	1009883a 	mov	r4,r2
 4019490:	40073000 	call	4007300 <memcpy>
      ptr   += n;
 4019494:	e0fff717 	ldw	r3,-36(fp)
 4019498:	e0bffe17 	ldw	r2,-8(fp)
 401949c:	1885883a 	add	r2,r3,r2
 40194a0:	e0bff715 	stw	r2,-36(fp)
      count -= n;
 40194a4:	e0fff617 	ldw	r3,-40(fp)
 40194a8:	e0bffe17 	ldw	r2,-8(fp)
 40194ac:	1885c83a 	sub	r2,r3,r2
 40194b0:	e0bff615 	stw	r2,-40(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 40194b4:	e0fffc17 	ldw	r3,-16(fp)
 40194b8:	e0bffe17 	ldw	r2,-8(fp)
 40194bc:	1885883a 	add	r2,r3,r2
 40194c0:	10c1ffcc 	andi	r3,r2,2047
 40194c4:	e0bff817 	ldw	r2,-32(fp)
 40194c8:	10c00c15 	stw	r3,48(r2)
    while (count > 0)
 40194cc:	e0bff617 	ldw	r2,-40(fp)
 40194d0:	00bfc716 	blt	zero,r2,40193f0 <altera_avalon_jtag_uart_write+0x30>
 40194d4:	00000106 	br	40194dc <altera_avalon_jtag_uart_write+0x11c>
        break;
 40194d8:	0001883a 	nop
  NIOS2_READ_STATUS (context);
 40194dc:	0005303a 	rdctl	r2,status
 40194e0:	e0bff915 	stw	r2,-28(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 40194e4:	e0fff917 	ldw	r3,-28(fp)
 40194e8:	00bfff84 	movi	r2,-2
 40194ec:	1884703a 	and	r2,r3,r2
 40194f0:	1001703a 	wrctl	status,r2
  return context;
 40194f4:	e0bff917 	ldw	r2,-28(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
 40194f8:	e0bffb15 	stw	r2,-20(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 40194fc:	e0bff817 	ldw	r2,-32(fp)
 4019500:	10800817 	ldw	r2,32(r2)
 4019504:	10c00094 	ori	r3,r2,2
 4019508:	e0bff817 	ldw	r2,-32(fp)
 401950c:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 4019510:	e0bff817 	ldw	r2,-32(fp)
 4019514:	10800017 	ldw	r2,0(r2)
 4019518:	10800104 	addi	r2,r2,4
 401951c:	1007883a 	mov	r3,r2
 4019520:	e0bff817 	ldw	r2,-32(fp)
 4019524:	10800817 	ldw	r2,32(r2)
 4019528:	18800035 	stwio	r2,0(r3)
 401952c:	e0bffb17 	ldw	r2,-20(fp)
 4019530:	e0bffa15 	stw	r2,-24(fp)
  NIOS2_WRITE_STATUS (context);
 4019534:	e0bffa17 	ldw	r2,-24(fp)
 4019538:	1001703a 	wrctl	status,r2
}
 401953c:	0001883a 	nop
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
 4019540:	e0bff617 	ldw	r2,-40(fp)
 4019544:	0080100e 	bge	zero,r2,4019588 <altera_avalon_jtag_uart_write+0x1c8>
    {
      if (flags & O_NONBLOCK)
 4019548:	e0bff517 	ldw	r2,-44(fp)
 401954c:	1090000c 	andi	r2,r2,16384
 4019550:	1000101e 	bne	r2,zero,4019594 <altera_avalon_jtag_uart_write+0x1d4>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
 4019554:	0001883a 	nop
 4019558:	e0bff817 	ldw	r2,-32(fp)
 401955c:	10800d17 	ldw	r2,52(r2)
 4019560:	e0ffff17 	ldw	r3,-4(fp)
 4019564:	1880051e 	bne	r3,r2,401957c <altera_avalon_jtag_uart_write+0x1bc>
 4019568:	e0bff817 	ldw	r2,-32(fp)
 401956c:	10c00917 	ldw	r3,36(r2)
 4019570:	e0bff817 	ldw	r2,-32(fp)
 4019574:	10800117 	ldw	r2,4(r2)
 4019578:	18bff736 	bltu	r3,r2,4019558 <altera_avalon_jtag_uart_write+0x198>
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
 401957c:	e0bff817 	ldw	r2,-32(fp)
 4019580:	10800917 	ldw	r2,36(r2)
 4019584:	1000051e 	bne	r2,zero,401959c <altera_avalon_jtag_uart_write+0x1dc>
         break;
    }
  }
  while (count > 0);
 4019588:	e0bff617 	ldw	r2,-40(fp)
 401958c:	00bfcf16 	blt	zero,r2,40194cc <altera_avalon_jtag_uart_write+0x10c>
 4019590:	00000306 	br	40195a0 <altera_avalon_jtag_uart_write+0x1e0>
        break;
 4019594:	0001883a 	nop
 4019598:	00000106 	br	40195a0 <altera_avalon_jtag_uart_write+0x1e0>
         break;
 401959c:	0001883a 	nop
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
 40195a0:	e0fff717 	ldw	r3,-36(fp)
 40195a4:	e0bffd17 	ldw	r2,-12(fp)
 40195a8:	18800426 	beq	r3,r2,40195bc <altera_avalon_jtag_uart_write+0x1fc>
    return ptr - start;
 40195ac:	e0fff717 	ldw	r3,-36(fp)
 40195b0:	e0bffd17 	ldw	r2,-12(fp)
 40195b4:	1885c83a 	sub	r2,r3,r2
 40195b8:	00000606 	br	40195d4 <altera_avalon_jtag_uart_write+0x214>
  else if (flags & O_NONBLOCK)
 40195bc:	e0bff517 	ldw	r2,-44(fp)
 40195c0:	1090000c 	andi	r2,r2,16384
 40195c4:	10000226 	beq	r2,zero,40195d0 <altera_avalon_jtag_uart_write+0x210>
    return -EWOULDBLOCK;
 40195c8:	00bffd44 	movi	r2,-11
 40195cc:	00000106 	br	40195d4 <altera_avalon_jtag_uart_write+0x214>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
 40195d0:	00bffec4 	movi	r2,-5
}
 40195d4:	e037883a 	mov	sp,fp
 40195d8:	dfc00117 	ldw	ra,4(sp)
 40195dc:	df000017 	ldw	fp,0(sp)
 40195e0:	dec00204 	addi	sp,sp,8
 40195e4:	f800283a 	ret

040195e8 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
 40195e8:	defffa04 	addi	sp,sp,-24
 40195ec:	dfc00515 	stw	ra,20(sp)
 40195f0:	df000415 	stw	fp,16(sp)
 40195f4:	df000404 	addi	fp,sp,16
 40195f8:	e13ffc15 	stw	r4,-16(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
 40195fc:	0007883a 	mov	r3,zero
 4019600:	e0bffc17 	ldw	r2,-16(fp)
 4019604:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
 4019608:	e0bffc17 	ldw	r2,-16(fp)
 401960c:	10800104 	addi	r2,r2,4
 4019610:	10800037 	ldwio	r2,0(r2)
  NIOS2_READ_STATUS (context);
 4019614:	0005303a 	rdctl	r2,status
 4019618:	e0bffd15 	stw	r2,-12(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 401961c:	e0fffd17 	ldw	r3,-12(fp)
 4019620:	00bfff84 	movi	r2,-2
 4019624:	1884703a 	and	r2,r3,r2
 4019628:	1001703a 	wrctl	status,r2
  return context;
 401962c:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
 4019630:	e0bfff15 	stw	r2,-4(fp)
  alt_tick ();
 4019634:	401a3680 	call	401a368 <alt_tick>
 4019638:	e0bfff17 	ldw	r2,-4(fp)
 401963c:	e0bffe15 	stw	r2,-8(fp)
  NIOS2_WRITE_STATUS (context);
 4019640:	e0bffe17 	ldw	r2,-8(fp)
 4019644:	1001703a 	wrctl	status,r2
}
 4019648:	0001883a 	nop
  alt_irq_enable_all(cpu_sr);
}
 401964c:	0001883a 	nop
 4019650:	e037883a 	mov	sp,fp
 4019654:	dfc00117 	ldw	ra,4(sp)
 4019658:	df000017 	ldw	fp,0(sp)
 401965c:	dec00204 	addi	sp,sp,8
 4019660:	f800283a 	ret

04019664 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
 4019664:	defff804 	addi	sp,sp,-32
 4019668:	dfc00715 	stw	ra,28(sp)
 401966c:	df000615 	stw	fp,24(sp)
 4019670:	df000604 	addi	fp,sp,24
 4019674:	e13ffe15 	stw	r4,-8(fp)
 4019678:	e17ffd15 	stw	r5,-12(fp)
 401967c:	e1bffc15 	stw	r6,-16(fp)
 4019680:	e1fffb15 	stw	r7,-20(fp)
 4019684:	e0bffb17 	ldw	r2,-20(fp)
 4019688:	e0bfff15 	stw	r2,-4(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
 401968c:	d0a72e17 	ldw	r2,-25416(gp)
 4019690:	1000031e 	bne	r2,zero,40196a0 <alt_avalon_timer_sc_init+0x3c>
  {
    _alt_tick_rate = nticks;
 4019694:	e0bfff17 	ldw	r2,-4(fp)
 4019698:	d0a72e15 	stw	r2,-25416(gp)
    return 0;
 401969c:	00000106 	br	40196a4 <alt_avalon_timer_sc_init+0x40>
  }
  else
  {
    return -1;
 40196a0:	0001883a 	nop
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
 40196a4:	e0bffe17 	ldw	r2,-8(fp)
 40196a8:	10800104 	addi	r2,r2,4
 40196ac:	00c001c4 	movi	r3,7
 40196b0:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
 40196b4:	d8000015 	stw	zero,0(sp)
 40196b8:	e1fffe17 	ldw	r7,-8(fp)
 40196bc:	018100b4 	movhi	r6,1026
 40196c0:	31a57a04 	addi	r6,r6,-27160
 40196c4:	e17ffc17 	ldw	r5,-16(fp)
 40196c8:	e13ffd17 	ldw	r4,-12(fp)
 40196cc:	4017f300 	call	4017f30 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
 40196d0:	0001883a 	nop
 40196d4:	e037883a 	mov	sp,fp
 40196d8:	dfc00117 	ldw	ra,4(sp)
 40196dc:	df000017 	ldw	fp,0(sp)
 40196e0:	dec00204 	addi	sp,sp,8
 40196e4:	f800283a 	ret

040196e8 <alt_up_accelerometer_spi_open_dev>:

#include "altera_up_avalon_accelerometer_spi.h"
#include "altera_up_avalon_accelerometer_spi_regs.h"

alt_up_accelerometer_spi_dev* alt_up_accelerometer_spi_open_dev(const char* name)
{
 40196e8:	defffc04 	addi	sp,sp,-16
 40196ec:	dfc00315 	stw	ra,12(sp)
 40196f0:	df000215 	stw	fp,8(sp)
 40196f4:	df000204 	addi	fp,sp,8
 40196f8:	e13ffe15 	stw	r4,-8(fp)
  // find the device from the device list 
  // (see altera_hal/HAL/inc/priv/alt_file.h 
  // and altera_hal/HAL/src/alt_find_dev.c 
  // for details)
  alt_up_accelerometer_spi_dev *dev = (alt_up_accelerometer_spi_dev*)alt_find_dev(name, &alt_dev_list);
 40196fc:	d1600704 	addi	r5,gp,-32740
 4019700:	e13ffe17 	ldw	r4,-8(fp)
 4019704:	4019db40 	call	4019db4 <alt_find_dev>
 4019708:	e0bfff15 	stw	r2,-4(fp)

  return dev;
 401970c:	e0bfff17 	ldw	r2,-4(fp)
}
 4019710:	e037883a 	mov	sp,fp
 4019714:	dfc00117 	ldw	ra,4(sp)
 4019718:	df000017 	ldw	fp,0(sp)
 401971c:	dec00204 	addi	sp,sp,8
 4019720:	f800283a 	ret

04019724 <alt_up_accelerometer_spi_read_address_register>:
 * @param addr -- a pointer to the location where the read address should be stored
 *
 * @return 0 for success 
 **/
int alt_up_accelerometer_spi_read_address_register(alt_up_accelerometer_spi_dev *accel_spi, alt_u8 *addr)
{
 4019724:	defffd04 	addi	sp,sp,-12
 4019728:	df000215 	stw	fp,8(sp)
 401972c:	df000204 	addi	fp,sp,8
 4019730:	e13fff15 	stw	r4,-4(fp)
 4019734:	e17ffe15 	stw	r5,-8(fp)
	// reads data from the device Address register
	*(addr) = IORD_ALT_UP_ACCELEROMETER_SPI_ADDRESS(accel_spi->base); 
 4019738:	e0bfff17 	ldw	r2,-4(fp)
 401973c:	10800a17 	ldw	r2,40(r2)
 4019740:	10800023 	ldbuio	r2,0(r2)
 4019744:	10803fcc 	andi	r2,r2,255
 4019748:	1007883a 	mov	r3,r2
 401974c:	e0bffe17 	ldw	r2,-8(fp)
 4019750:	10c00005 	stb	r3,0(r2)

	return 0;
 4019754:	0005883a 	mov	r2,zero
}
 4019758:	e037883a 	mov	sp,fp
 401975c:	df000017 	ldw	fp,0(sp)
 4019760:	dec00104 	addi	sp,sp,4
 4019764:	f800283a 	ret

04019768 <alt_up_accelerometer_spi_read>:
 * @param data -- a pointer to the location where the read data should be stored
 *
 * @return 0 for success
 **/
int alt_up_accelerometer_spi_read(alt_up_accelerometer_spi_dev *accel_spi, alt_u8 addr, alt_u8 *data)
{
 4019768:	defffc04 	addi	sp,sp,-16
 401976c:	df000315 	stw	fp,12(sp)
 4019770:	df000304 	addi	fp,sp,12
 4019774:	e13fff15 	stw	r4,-4(fp)
 4019778:	2805883a 	mov	r2,r5
 401977c:	e1bffd15 	stw	r6,-12(fp)
 4019780:	e0bffe05 	stb	r2,-8(fp)
	// set the register address in the Address register
	IOWR_ALT_UP_ACCELEROMETER_SPI_ADDRESS(accel_spi->base, addr & ALT_UP_ACCELEROMETER_SPI_ADDRESS_ADDR_MSK); 
 4019784:	e0bfff17 	ldw	r2,-4(fp)
 4019788:	10800a17 	ldw	r2,40(r2)
 401978c:	1007883a 	mov	r3,r2
 4019790:	e0bffe03 	ldbu	r2,-8(fp)
 4019794:	10800fcc 	andi	r2,r2,63
 4019798:	18800025 	stbio	r2,0(r3)

	// read data to the device Data register
	*(data) = IORD_ALT_UP_ACCELEROMETER_SPI_DATA(accel_spi->base) & ALT_UP_ACCELEROMETER_SPI_DATA_DATA_MSK;
 401979c:	e0bfff17 	ldw	r2,-4(fp)
 40197a0:	10800a17 	ldw	r2,40(r2)
 40197a4:	10800044 	addi	r2,r2,1
 40197a8:	10800023 	ldbuio	r2,0(r2)
 40197ac:	10803fcc 	andi	r2,r2,255
 40197b0:	1007883a 	mov	r3,r2
 40197b4:	e0bffd17 	ldw	r2,-12(fp)
 40197b8:	10c00005 	stb	r3,0(r2)

	return 0;
 40197bc:	0005883a 	mov	r2,zero
}
 40197c0:	e037883a 	mov	sp,fp
 40197c4:	df000017 	ldw	fp,0(sp)
 40197c8:	dec00104 	addi	sp,sp,4
 40197cc:	f800283a 	ret

040197d0 <alt_up_accelerometer_spi_write>:
 * @param data -- the data to be written
 *
 * @return 0 for success
 **/
int alt_up_accelerometer_spi_write(alt_up_accelerometer_spi_dev *accel_spi, alt_u8 addr, alt_u8 data)
{
 40197d0:	defffc04 	addi	sp,sp,-16
 40197d4:	df000315 	stw	fp,12(sp)
 40197d8:	df000304 	addi	fp,sp,12
 40197dc:	e13fff15 	stw	r4,-4(fp)
 40197e0:	2805883a 	mov	r2,r5
 40197e4:	3007883a 	mov	r3,r6
 40197e8:	e0bffe05 	stb	r2,-8(fp)
 40197ec:	1805883a 	mov	r2,r3
 40197f0:	e0bffd05 	stb	r2,-12(fp)
	// set the register address in the Address register
	IOWR_ALT_UP_ACCELEROMETER_SPI_ADDRESS(accel_spi->base, addr & ALT_UP_ACCELEROMETER_SPI_ADDRESS_ADDR_MSK); 
 40197f4:	e0bfff17 	ldw	r2,-4(fp)
 40197f8:	10800a17 	ldw	r2,40(r2)
 40197fc:	1007883a 	mov	r3,r2
 4019800:	e0bffe03 	ldbu	r2,-8(fp)
 4019804:	10800fcc 	andi	r2,r2,63
 4019808:	18800025 	stbio	r2,0(r3)

	// write data to the device Data register
	IOWR_ALT_UP_ACCELEROMETER_SPI_DATA(accel_spi->base, data & ALT_UP_ACCELEROMETER_SPI_DATA_DATA_MSK); 
 401980c:	e0bfff17 	ldw	r2,-4(fp)
 4019810:	10800a17 	ldw	r2,40(r2)
 4019814:	10800044 	addi	r2,r2,1
 4019818:	1007883a 	mov	r3,r2
 401981c:	e0bffd03 	ldbu	r2,-12(fp)
 4019820:	18800025 	stbio	r2,0(r3)

	return 0;
 4019824:	0005883a 	mov	r2,zero
}
 4019828:	e037883a 	mov	sp,fp
 401982c:	df000017 	ldw	fp,0(sp)
 4019830:	dec00104 	addi	sp,sp,4
 4019834:	f800283a 	ret

04019838 <alt_up_accelerometer_spi_read_x_axis>:
 * @param x_axis -- a pointer to the location where the x axis data should be stored
 *
 * @return 0 for success or -1 for failure
 **/
int alt_up_accelerometer_spi_read_x_axis(alt_up_accelerometer_spi_dev *accel_spi, alt_32 *x_axis)
{
 4019838:	defffd04 	addi	sp,sp,-12
 401983c:	df000215 	stw	fp,8(sp)
 4019840:	df000204 	addi	fp,sp,8
 4019844:	e13fff15 	stw	r4,-4(fp)
 4019848:	e17ffe15 	stw	r5,-8(fp)
	// set the register address in the Address register
	IOWR_ALT_UP_ACCELEROMETER_SPI_ADDRESS(accel_spi->base, ACCELEROMETER_SPI_X_AXIS_LOWER_BYTE & ALT_UP_ACCELEROMETER_SPI_ADDRESS_ADDR_MSK); 
 401984c:	e0bfff17 	ldw	r2,-4(fp)
 4019850:	10800a17 	ldw	r2,40(r2)
 4019854:	1007883a 	mov	r3,r2
 4019858:	00800c84 	movi	r2,50
 401985c:	18800025 	stbio	r2,0(r3)

	// read data to the device Data register
	*(x_axis) = IORD_ALT_UP_ACCELEROMETER_SPI_DATA(accel_spi->base) & ALT_UP_ACCELEROMETER_SPI_DATA_DATA_MSK;
 4019860:	e0bfff17 	ldw	r2,-4(fp)
 4019864:	10800a17 	ldw	r2,40(r2)
 4019868:	10800044 	addi	r2,r2,1
 401986c:	10800023 	ldbuio	r2,0(r2)
 4019870:	10803fcc 	andi	r2,r2,255
 4019874:	10ffffcc 	andi	r3,r2,65535
 4019878:	e0bffe17 	ldw	r2,-8(fp)
 401987c:	10c00015 	stw	r3,0(r2)

	// set the register address in the Address register
	IOWR_ALT_UP_ACCELEROMETER_SPI_ADDRESS(accel_spi->base, ACCELEROMETER_SPI_X_AXIS_UPPER_BYTE & ALT_UP_ACCELEROMETER_SPI_ADDRESS_ADDR_MSK); 
 4019880:	e0bfff17 	ldw	r2,-4(fp)
 4019884:	10800a17 	ldw	r2,40(r2)
 4019888:	1007883a 	mov	r3,r2
 401988c:	00800cc4 	movi	r2,51
 4019890:	18800025 	stbio	r2,0(r3)

	// read data to the device Data register
	*(x_axis) += (IORD_ALT_UP_ACCELEROMETER_SPI_DATA(accel_spi->base) & ALT_UP_ACCELEROMETER_SPI_DATA_DATA_MSK) << 8;
 4019894:	e0bfff17 	ldw	r2,-4(fp)
 4019898:	10800a17 	ldw	r2,40(r2)
 401989c:	10800044 	addi	r2,r2,1
 40198a0:	10800023 	ldbuio	r2,0(r2)
 40198a4:	10803fcc 	andi	r2,r2,255
 40198a8:	1006923a 	slli	r3,r2,8
 40198ac:	00804034 	movhi	r2,256
 40198b0:	10bfc004 	addi	r2,r2,-256
 40198b4:	1884703a 	and	r2,r3,r2
 40198b8:	e0fffe17 	ldw	r3,-8(fp)
 40198bc:	18c00017 	ldw	r3,0(r3)
 40198c0:	10c5883a 	add	r2,r2,r3
 40198c4:	1007883a 	mov	r3,r2
 40198c8:	e0bffe17 	ldw	r2,-8(fp)
 40198cc:	10c00015 	stw	r3,0(r2)

	if (*(x_axis) & 0x00008000)
 40198d0:	e0bffe17 	ldw	r2,-8(fp)
 40198d4:	10800017 	ldw	r2,0(r2)
 40198d8:	10a0000c 	andi	r2,r2,32768
 40198dc:	10000626 	beq	r2,zero,40198f8 <alt_up_accelerometer_spi_read_x_axis+0xc0>
	{
		*(x_axis) |= 0xFFFF0000;
 40198e0:	e0bffe17 	ldw	r2,-8(fp)
 40198e4:	10800017 	ldw	r2,0(r2)
 40198e8:	10bffff4 	orhi	r2,r2,65535
 40198ec:	1007883a 	mov	r3,r2
 40198f0:	e0bffe17 	ldw	r2,-8(fp)
 40198f4:	10c00015 	stw	r3,0(r2)
	}

	return 0;
 40198f8:	0005883a 	mov	r2,zero
}
 40198fc:	e037883a 	mov	sp,fp
 4019900:	df000017 	ldw	fp,0(sp)
 4019904:	dec00104 	addi	sp,sp,4
 4019908:	f800283a 	ret

0401990c <alt_up_accelerometer_spi_read_y_axis>:
 * @param y_axis -- a pointer to the location where the y axis data should be stored
 *
 * @return 0 for success or -1 for failure
 **/
int alt_up_accelerometer_spi_read_y_axis(alt_up_accelerometer_spi_dev *accel_spi, alt_32 *y_axis)
{
 401990c:	defffd04 	addi	sp,sp,-12
 4019910:	df000215 	stw	fp,8(sp)
 4019914:	df000204 	addi	fp,sp,8
 4019918:	e13fff15 	stw	r4,-4(fp)
 401991c:	e17ffe15 	stw	r5,-8(fp)
	// set the register address in the Address register
	IOWR_ALT_UP_ACCELEROMETER_SPI_ADDRESS(accel_spi->base, ACCELEROMETER_SPI_Y_AXIS_LOWER_BYTE & ALT_UP_ACCELEROMETER_SPI_ADDRESS_ADDR_MSK); 
 4019920:	e0bfff17 	ldw	r2,-4(fp)
 4019924:	10800a17 	ldw	r2,40(r2)
 4019928:	1007883a 	mov	r3,r2
 401992c:	00800d04 	movi	r2,52
 4019930:	18800025 	stbio	r2,0(r3)

	// read data to the device Data register
	*(y_axis) = IORD_ALT_UP_ACCELEROMETER_SPI_DATA(accel_spi->base) & ALT_UP_ACCELEROMETER_SPI_DATA_DATA_MSK;
 4019934:	e0bfff17 	ldw	r2,-4(fp)
 4019938:	10800a17 	ldw	r2,40(r2)
 401993c:	10800044 	addi	r2,r2,1
 4019940:	10800023 	ldbuio	r2,0(r2)
 4019944:	10803fcc 	andi	r2,r2,255
 4019948:	10ffffcc 	andi	r3,r2,65535
 401994c:	e0bffe17 	ldw	r2,-8(fp)
 4019950:	10c00015 	stw	r3,0(r2)

	// set the register address in the Address register
	IOWR_ALT_UP_ACCELEROMETER_SPI_ADDRESS(accel_spi->base, ACCELEROMETER_SPI_Y_AXIS_UPPER_BYTE & ALT_UP_ACCELEROMETER_SPI_ADDRESS_ADDR_MSK); 
 4019954:	e0bfff17 	ldw	r2,-4(fp)
 4019958:	10800a17 	ldw	r2,40(r2)
 401995c:	1007883a 	mov	r3,r2
 4019960:	00800d44 	movi	r2,53
 4019964:	18800025 	stbio	r2,0(r3)

	// read data to the device Data register
	*(y_axis) += (IORD_ALT_UP_ACCELEROMETER_SPI_DATA(accel_spi->base) & ALT_UP_ACCELEROMETER_SPI_DATA_DATA_MSK) << 8;
 4019968:	e0bfff17 	ldw	r2,-4(fp)
 401996c:	10800a17 	ldw	r2,40(r2)
 4019970:	10800044 	addi	r2,r2,1
 4019974:	10800023 	ldbuio	r2,0(r2)
 4019978:	10803fcc 	andi	r2,r2,255
 401997c:	1006923a 	slli	r3,r2,8
 4019980:	00804034 	movhi	r2,256
 4019984:	10bfc004 	addi	r2,r2,-256
 4019988:	1884703a 	and	r2,r3,r2
 401998c:	e0fffe17 	ldw	r3,-8(fp)
 4019990:	18c00017 	ldw	r3,0(r3)
 4019994:	10c5883a 	add	r2,r2,r3
 4019998:	1007883a 	mov	r3,r2
 401999c:	e0bffe17 	ldw	r2,-8(fp)
 40199a0:	10c00015 	stw	r3,0(r2)

	if (*(y_axis) & 0x00008000)
 40199a4:	e0bffe17 	ldw	r2,-8(fp)
 40199a8:	10800017 	ldw	r2,0(r2)
 40199ac:	10a0000c 	andi	r2,r2,32768
 40199b0:	10000626 	beq	r2,zero,40199cc <alt_up_accelerometer_spi_read_y_axis+0xc0>
	{
		*(y_axis) |= 0xFFFF0000;
 40199b4:	e0bffe17 	ldw	r2,-8(fp)
 40199b8:	10800017 	ldw	r2,0(r2)
 40199bc:	10bffff4 	orhi	r2,r2,65535
 40199c0:	1007883a 	mov	r3,r2
 40199c4:	e0bffe17 	ldw	r2,-8(fp)
 40199c8:	10c00015 	stw	r3,0(r2)
	}

	return 0;
 40199cc:	0005883a 	mov	r2,zero
}
 40199d0:	e037883a 	mov	sp,fp
 40199d4:	df000017 	ldw	fp,0(sp)
 40199d8:	dec00104 	addi	sp,sp,4
 40199dc:	f800283a 	ret

040199e0 <alt_up_accelerometer_spi_read_z_axis>:
 * @param z_axis -- a pointer to the location where the z axis data should be stored
 *
 * @return 0 for success or -1 for failure
 **/
int alt_up_accelerometer_spi_read_z_axis(alt_up_accelerometer_spi_dev *accel_spi, alt_32 *z_axis)
{
 40199e0:	defffd04 	addi	sp,sp,-12
 40199e4:	df000215 	stw	fp,8(sp)
 40199e8:	df000204 	addi	fp,sp,8
 40199ec:	e13fff15 	stw	r4,-4(fp)
 40199f0:	e17ffe15 	stw	r5,-8(fp)
	// set the register address in the Address register
	IOWR_ALT_UP_ACCELEROMETER_SPI_ADDRESS(accel_spi->base, ACCELEROMETER_SPI_Z_AXIS_LOWER_BYTE & ALT_UP_ACCELEROMETER_SPI_ADDRESS_ADDR_MSK); 
 40199f4:	e0bfff17 	ldw	r2,-4(fp)
 40199f8:	10800a17 	ldw	r2,40(r2)
 40199fc:	1007883a 	mov	r3,r2
 4019a00:	00800d84 	movi	r2,54
 4019a04:	18800025 	stbio	r2,0(r3)

	// read data to the device Data register
	*(z_axis) = IORD_ALT_UP_ACCELEROMETER_SPI_DATA(accel_spi->base) & ALT_UP_ACCELEROMETER_SPI_DATA_DATA_MSK;
 4019a08:	e0bfff17 	ldw	r2,-4(fp)
 4019a0c:	10800a17 	ldw	r2,40(r2)
 4019a10:	10800044 	addi	r2,r2,1
 4019a14:	10800023 	ldbuio	r2,0(r2)
 4019a18:	10803fcc 	andi	r2,r2,255
 4019a1c:	10ffffcc 	andi	r3,r2,65535
 4019a20:	e0bffe17 	ldw	r2,-8(fp)
 4019a24:	10c00015 	stw	r3,0(r2)

	// set the register address in the Address register
	IOWR_ALT_UP_ACCELEROMETER_SPI_ADDRESS(accel_spi->base, ACCELEROMETER_SPI_Z_AXIS_UPPER_BYTE & ALT_UP_ACCELEROMETER_SPI_ADDRESS_ADDR_MSK); 
 4019a28:	e0bfff17 	ldw	r2,-4(fp)
 4019a2c:	10800a17 	ldw	r2,40(r2)
 4019a30:	1007883a 	mov	r3,r2
 4019a34:	00800dc4 	movi	r2,55
 4019a38:	18800025 	stbio	r2,0(r3)

	// read data to the device Data register
	*(z_axis) += (IORD_ALT_UP_ACCELEROMETER_SPI_DATA(accel_spi->base) & ALT_UP_ACCELEROMETER_SPI_DATA_DATA_MSK) << 8;
 4019a3c:	e0bfff17 	ldw	r2,-4(fp)
 4019a40:	10800a17 	ldw	r2,40(r2)
 4019a44:	10800044 	addi	r2,r2,1
 4019a48:	10800023 	ldbuio	r2,0(r2)
 4019a4c:	10803fcc 	andi	r2,r2,255
 4019a50:	1006923a 	slli	r3,r2,8
 4019a54:	00804034 	movhi	r2,256
 4019a58:	10bfc004 	addi	r2,r2,-256
 4019a5c:	1884703a 	and	r2,r3,r2
 4019a60:	e0fffe17 	ldw	r3,-8(fp)
 4019a64:	18c00017 	ldw	r3,0(r3)
 4019a68:	10c5883a 	add	r2,r2,r3
 4019a6c:	1007883a 	mov	r3,r2
 4019a70:	e0bffe17 	ldw	r2,-8(fp)
 4019a74:	10c00015 	stw	r3,0(r2)

	if (*(z_axis) & 0x00008000)
 4019a78:	e0bffe17 	ldw	r2,-8(fp)
 4019a7c:	10800017 	ldw	r2,0(r2)
 4019a80:	10a0000c 	andi	r2,r2,32768
 4019a84:	10000626 	beq	r2,zero,4019aa0 <alt_up_accelerometer_spi_read_z_axis+0xc0>
	{
		*(z_axis) |= 0xFFFF0000;
 4019a88:	e0bffe17 	ldw	r2,-8(fp)
 4019a8c:	10800017 	ldw	r2,0(r2)
 4019a90:	10bffff4 	orhi	r2,r2,65535
 4019a94:	1007883a 	mov	r3,r2
 4019a98:	e0bffe17 	ldw	r2,-8(fp)
 4019a9c:	10c00015 	stw	r3,0(r2)
	}

	return 0;
 4019aa0:	0005883a 	mov	r2,zero
}
 4019aa4:	e037883a 	mov	sp,fp
 4019aa8:	df000017 	ldw	fp,0(sp)
 4019aac:	dec00104 	addi	sp,sp,4
 4019ab0:	f800283a 	ret

04019ab4 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
 4019ab4:	defff504 	addi	sp,sp,-44
 4019ab8:	df000a15 	stw	fp,40(sp)
 4019abc:	df000a04 	addi	fp,sp,40
 4019ac0:	e13ff915 	stw	r4,-28(fp)
 4019ac4:	e17ff815 	stw	r5,-32(fp)
 4019ac8:	e1bff715 	stw	r6,-36(fp)
 4019acc:	e1fff615 	stw	r7,-40(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
 4019ad0:	e03fff15 	stw	zero,-4(fp)
  return _alt_tick_rate;
 4019ad4:	d0a72e17 	ldw	r2,-25416(gp)
  
  if (alt_ticks_per_second ())
 4019ad8:	10003e26 	beq	r2,zero,4019bd4 <alt_alarm_start+0x120>
  {
    if (alarm)
 4019adc:	e0bff917 	ldw	r2,-28(fp)
 4019ae0:	10003a26 	beq	r2,zero,4019bcc <alt_alarm_start+0x118>
    {
      alarm->callback = callback;
 4019ae4:	e0bff917 	ldw	r2,-28(fp)
 4019ae8:	e0fff717 	ldw	r3,-36(fp)
 4019aec:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
 4019af0:	e0bff917 	ldw	r2,-28(fp)
 4019af4:	e0fff617 	ldw	r3,-40(fp)
 4019af8:	10c00515 	stw	r3,20(r2)
  NIOS2_READ_STATUS (context);
 4019afc:	0005303a 	rdctl	r2,status
 4019b00:	e0bffd15 	stw	r2,-12(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 4019b04:	e0fffd17 	ldw	r3,-12(fp)
 4019b08:	00bfff84 	movi	r2,-2
 4019b0c:	1884703a 	and	r2,r3,r2
 4019b10:	1001703a 	wrctl	status,r2
  return context;
 4019b14:	e0bffd17 	ldw	r2,-12(fp)
 
      irq_context = alt_irq_disable_all ();
 4019b18:	e0bffe15 	stw	r2,-8(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 4019b1c:	d0a72f17 	ldw	r2,-25412(gp)
      
      current_nticks = alt_nticks();
 4019b20:	e0bfff15 	stw	r2,-4(fp)
      
      alarm->time = nticks + current_nticks + 1; 
 4019b24:	e0fff817 	ldw	r3,-32(fp)
 4019b28:	e0bfff17 	ldw	r2,-4(fp)
 4019b2c:	1885883a 	add	r2,r3,r2
 4019b30:	10c00044 	addi	r3,r2,1
 4019b34:	e0bff917 	ldw	r2,-28(fp)
 4019b38:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
 4019b3c:	e0bff917 	ldw	r2,-28(fp)
 4019b40:	10c00217 	ldw	r3,8(r2)
 4019b44:	e0bfff17 	ldw	r2,-4(fp)
 4019b48:	1880042e 	bgeu	r3,r2,4019b5c <alt_alarm_start+0xa8>
      {
        alarm->rollover = 1;
 4019b4c:	e0bff917 	ldw	r2,-28(fp)
 4019b50:	00c00044 	movi	r3,1
 4019b54:	10c00405 	stb	r3,16(r2)
 4019b58:	00000206 	br	4019b64 <alt_alarm_start+0xb0>
      }
      else
      {
        alarm->rollover = 0;
 4019b5c:	e0bff917 	ldw	r2,-28(fp)
 4019b60:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
 4019b64:	e0bff917 	ldw	r2,-28(fp)
 4019b68:	d0e00d04 	addi	r3,gp,-32716
 4019b6c:	e0fffb15 	stw	r3,-20(fp)
 4019b70:	e0bffa15 	stw	r2,-24(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 4019b74:	e0bffa17 	ldw	r2,-24(fp)
 4019b78:	e0fffb17 	ldw	r3,-20(fp)
 4019b7c:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 4019b80:	e0bffb17 	ldw	r2,-20(fp)
 4019b84:	10c00017 	ldw	r3,0(r2)
 4019b88:	e0bffa17 	ldw	r2,-24(fp)
 4019b8c:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 4019b90:	e0bffb17 	ldw	r2,-20(fp)
 4019b94:	10800017 	ldw	r2,0(r2)
 4019b98:	e0fffa17 	ldw	r3,-24(fp)
 4019b9c:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 4019ba0:	e0bffb17 	ldw	r2,-20(fp)
 4019ba4:	e0fffa17 	ldw	r3,-24(fp)
 4019ba8:	10c00015 	stw	r3,0(r2)
}
 4019bac:	0001883a 	nop
 4019bb0:	e0bffe17 	ldw	r2,-8(fp)
 4019bb4:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context);
 4019bb8:	e0bffc17 	ldw	r2,-16(fp)
 4019bbc:	1001703a 	wrctl	status,r2
}
 4019bc0:	0001883a 	nop
      alt_irq_enable_all (irq_context);

      return 0;
 4019bc4:	0005883a 	mov	r2,zero
 4019bc8:	00000306 	br	4019bd8 <alt_alarm_start+0x124>
    }
    else
    {
      return -EINVAL;
 4019bcc:	00bffa84 	movi	r2,-22
 4019bd0:	00000106 	br	4019bd8 <alt_alarm_start+0x124>
    }
  }
  else
  {
    return -ENOTSUP;
 4019bd4:	00bfde84 	movi	r2,-134
  }
}
 4019bd8:	e037883a 	mov	sp,fp
 4019bdc:	df000017 	ldw	fp,0(sp)
 4019be0:	dec00104 	addi	sp,sp,4
 4019be4:	f800283a 	ret

04019be8 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
 4019be8:	deffff04 	addi	sp,sp,-4
 4019bec:	df000015 	stw	fp,0(sp)
 4019bf0:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 4019bf4:	0001883a 	nop
 4019bf8:	e037883a 	mov	sp,fp
 4019bfc:	df000017 	ldw	fp,0(sp)
 4019c00:	dec00104 	addi	sp,sp,4
 4019c04:	f800283a 	ret

04019c08 <alt_get_errno>:
{
 4019c08:	defffe04 	addi	sp,sp,-8
 4019c0c:	dfc00115 	stw	ra,4(sp)
 4019c10:	df000015 	stw	fp,0(sp)
 4019c14:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 4019c18:	d0a00a17 	ldw	r2,-32728(gp)
 4019c1c:	10000326 	beq	r2,zero,4019c2c <alt_get_errno+0x24>
 4019c20:	d0a00a17 	ldw	r2,-32728(gp)
 4019c24:	103ee83a 	callr	r2
 4019c28:	00000106 	br	4019c30 <alt_get_errno+0x28>
 4019c2c:	d0a72704 	addi	r2,gp,-25444
}
 4019c30:	e037883a 	mov	sp,fp
 4019c34:	dfc00117 	ldw	ra,4(sp)
 4019c38:	df000017 	ldw	fp,0(sp)
 4019c3c:	dec00204 	addi	sp,sp,8
 4019c40:	f800283a 	ret

04019c44 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
 4019c44:	defffa04 	addi	sp,sp,-24
 4019c48:	dfc00515 	stw	ra,20(sp)
 4019c4c:	df000415 	stw	fp,16(sp)
 4019c50:	df000404 	addi	fp,sp,16
 4019c54:	e13ffd15 	stw	r4,-12(fp)
 4019c58:	e17ffc15 	stw	r5,-16(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
 4019c5c:	e0bffd17 	ldw	r2,-12(fp)
 4019c60:	10000326 	beq	r2,zero,4019c70 <alt_dev_llist_insert+0x2c>
 4019c64:	e0bffd17 	ldw	r2,-12(fp)
 4019c68:	10800217 	ldw	r2,8(r2)
 4019c6c:	1000061e 	bne	r2,zero,4019c88 <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
 4019c70:	4019c080 	call	4019c08 <alt_get_errno>
 4019c74:	1007883a 	mov	r3,r2
 4019c78:	00800584 	movi	r2,22
 4019c7c:	18800015 	stw	r2,0(r3)
    return -EINVAL;
 4019c80:	00bffa84 	movi	r2,-22
 4019c84:	00001406 	br	4019cd8 <alt_dev_llist_insert+0x94>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
 4019c88:	e0bffd17 	ldw	r2,-12(fp)
 4019c8c:	e0fffc17 	ldw	r3,-16(fp)
 4019c90:	e0ffff15 	stw	r3,-4(fp)
 4019c94:	e0bffe15 	stw	r2,-8(fp)
  entry->previous = list;
 4019c98:	e0bffe17 	ldw	r2,-8(fp)
 4019c9c:	e0ffff17 	ldw	r3,-4(fp)
 4019ca0:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 4019ca4:	e0bfff17 	ldw	r2,-4(fp)
 4019ca8:	10c00017 	ldw	r3,0(r2)
 4019cac:	e0bffe17 	ldw	r2,-8(fp)
 4019cb0:	10c00015 	stw	r3,0(r2)
  list->next->previous = entry;
 4019cb4:	e0bfff17 	ldw	r2,-4(fp)
 4019cb8:	10800017 	ldw	r2,0(r2)
 4019cbc:	e0fffe17 	ldw	r3,-8(fp)
 4019cc0:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 4019cc4:	e0bfff17 	ldw	r2,-4(fp)
 4019cc8:	e0fffe17 	ldw	r3,-8(fp)
 4019ccc:	10c00015 	stw	r3,0(r2)
}
 4019cd0:	0001883a 	nop

  return 0;  
 4019cd4:	0005883a 	mov	r2,zero
}
 4019cd8:	e037883a 	mov	sp,fp
 4019cdc:	dfc00117 	ldw	ra,4(sp)
 4019ce0:	df000017 	ldw	fp,0(sp)
 4019ce4:	dec00204 	addi	sp,sp,8
 4019ce8:	f800283a 	ret

04019cec <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
 4019cec:	defffd04 	addi	sp,sp,-12
 4019cf0:	dfc00215 	stw	ra,8(sp)
 4019cf4:	df000115 	stw	fp,4(sp)
 4019cf8:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 4019cfc:	008100b4 	movhi	r2,1026
 4019d00:	10aaab04 	addi	r2,r2,-21844
 4019d04:	e0bfff15 	stw	r2,-4(fp)
 4019d08:	00000606 	br	4019d24 <_do_ctors+0x38>
        (*ctor) (); 
 4019d0c:	e0bfff17 	ldw	r2,-4(fp)
 4019d10:	10800017 	ldw	r2,0(r2)
 4019d14:	103ee83a 	callr	r2
  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 4019d18:	e0bfff17 	ldw	r2,-4(fp)
 4019d1c:	10bfff04 	addi	r2,r2,-4
 4019d20:	e0bfff15 	stw	r2,-4(fp)
 4019d24:	e0ffff17 	ldw	r3,-4(fp)
 4019d28:	008100b4 	movhi	r2,1026
 4019d2c:	10aaac04 	addi	r2,r2,-21840
 4019d30:	18bff62e 	bgeu	r3,r2,4019d0c <_do_ctors+0x20>
}
 4019d34:	0001883a 	nop
 4019d38:	0001883a 	nop
 4019d3c:	e037883a 	mov	sp,fp
 4019d40:	dfc00117 	ldw	ra,4(sp)
 4019d44:	df000017 	ldw	fp,0(sp)
 4019d48:	dec00204 	addi	sp,sp,8
 4019d4c:	f800283a 	ret

04019d50 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
 4019d50:	defffd04 	addi	sp,sp,-12
 4019d54:	dfc00215 	stw	ra,8(sp)
 4019d58:	df000115 	stw	fp,4(sp)
 4019d5c:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 4019d60:	008100b4 	movhi	r2,1026
 4019d64:	10aaab04 	addi	r2,r2,-21844
 4019d68:	e0bfff15 	stw	r2,-4(fp)
 4019d6c:	00000606 	br	4019d88 <_do_dtors+0x38>
        (*dtor) (); 
 4019d70:	e0bfff17 	ldw	r2,-4(fp)
 4019d74:	10800017 	ldw	r2,0(r2)
 4019d78:	103ee83a 	callr	r2
  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 4019d7c:	e0bfff17 	ldw	r2,-4(fp)
 4019d80:	10bfff04 	addi	r2,r2,-4
 4019d84:	e0bfff15 	stw	r2,-4(fp)
 4019d88:	e0ffff17 	ldw	r3,-4(fp)
 4019d8c:	008100b4 	movhi	r2,1026
 4019d90:	10aaac04 	addi	r2,r2,-21840
 4019d94:	18bff62e 	bgeu	r3,r2,4019d70 <_do_dtors+0x20>
}
 4019d98:	0001883a 	nop
 4019d9c:	0001883a 	nop
 4019da0:	e037883a 	mov	sp,fp
 4019da4:	dfc00117 	ldw	ra,4(sp)
 4019da8:	df000017 	ldw	fp,0(sp)
 4019dac:	dec00204 	addi	sp,sp,8
 4019db0:	f800283a 	ret

04019db4 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
 4019db4:	defffa04 	addi	sp,sp,-24
 4019db8:	dfc00515 	stw	ra,20(sp)
 4019dbc:	df000415 	stw	fp,16(sp)
 4019dc0:	df000404 	addi	fp,sp,16
 4019dc4:	e13ffd15 	stw	r4,-12(fp)
 4019dc8:	e17ffc15 	stw	r5,-16(fp)
  alt_dev* next = (alt_dev*) llist->next;
 4019dcc:	e0bffc17 	ldw	r2,-16(fp)
 4019dd0:	10800017 	ldw	r2,0(r2)
 4019dd4:	e0bfff15 	stw	r2,-4(fp)
  alt_32 len;

  len  = strlen(name) + 1;
 4019dd8:	e13ffd17 	ldw	r4,-12(fp)
 4019ddc:	40078680 	call	4007868 <strlen>
 4019de0:	10800044 	addi	r2,r2,1
 4019de4:	e0bffe15 	stw	r2,-8(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 4019de8:	00000d06 	br	4019e20 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
 4019dec:	e0bfff17 	ldw	r2,-4(fp)
 4019df0:	10800217 	ldw	r2,8(r2)
 4019df4:	e0fffe17 	ldw	r3,-8(fp)
 4019df8:	180d883a 	mov	r6,r3
 4019dfc:	e17ffd17 	ldw	r5,-12(fp)
 4019e00:	1009883a 	mov	r4,r2
 4019e04:	401a6d80 	call	401a6d8 <memcmp>
 4019e08:	1000021e 	bne	r2,zero,4019e14 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
 4019e0c:	e0bfff17 	ldw	r2,-4(fp)
 4019e10:	00000706 	br	4019e30 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
 4019e14:	e0bfff17 	ldw	r2,-4(fp)
 4019e18:	10800017 	ldw	r2,0(r2)
 4019e1c:	e0bfff15 	stw	r2,-4(fp)
  while (next != (alt_dev*) llist)
 4019e20:	e0ffff17 	ldw	r3,-4(fp)
 4019e24:	e0bffc17 	ldw	r2,-16(fp)
 4019e28:	18bff01e 	bne	r3,r2,4019dec <alt_find_dev+0x38>
  }
  
  /* No match found */
  
  return NULL;
 4019e2c:	0005883a 	mov	r2,zero
}
 4019e30:	e037883a 	mov	sp,fp
 4019e34:	dfc00117 	ldw	ra,4(sp)
 4019e38:	df000017 	ldw	fp,0(sp)
 4019e3c:	dec00204 	addi	sp,sp,8
 4019e40:	f800283a 	ret

04019e44 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
 4019e44:	deffff04 	addi	sp,sp,-4
 4019e48:	df000015 	stw	fp,0(sp)
 4019e4c:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
#endif
}
 4019e50:	0001883a 	nop
 4019e54:	e037883a 	mov	sp,fp
 4019e58:	df000017 	ldw	fp,0(sp)
 4019e5c:	dec00104 	addi	sp,sp,4
 4019e60:	f800283a 	ret

04019e64 <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
 4019e64:	defffe04 	addi	sp,sp,-8
 4019e68:	df000115 	stw	fp,4(sp)
 4019e6c:	df000104 	addi	fp,sp,4
 4019e70:	e13fff15 	stw	r4,-4(fp)
 4019e74:	e0bfff17 	ldw	r2,-4(fp)
 4019e78:	10bffe84 	addi	r2,r2,-6
 4019e7c:	10c00428 	cmpgeui	r3,r2,16
 4019e80:	1800191e 	bne	r3,zero,4019ee8 <alt_exception_cause_generated_bad_addr+0x84>
 4019e84:	100690ba 	slli	r3,r2,2
 4019e88:	008100b4 	movhi	r2,1026
 4019e8c:	1885883a 	add	r2,r3,r2
 4019e90:	10a7a617 	ldw	r2,-24936(r2)
 4019e94:	1000683a 	jmp	r2
 4019e98:	04019ed8 	cmpnei	r16,zero,1659
 4019e9c:	04019ed8 	cmpnei	r16,zero,1659
 4019ea0:	04019ee8 	cmpgeui	r16,zero,1659
 4019ea4:	04019ee8 	cmpgeui	r16,zero,1659
 4019ea8:	04019ee8 	cmpgeui	r16,zero,1659
 4019eac:	04019ed8 	cmpnei	r16,zero,1659
 4019eb0:	04019ee0 	cmpeqi	r16,zero,1659
 4019eb4:	04019ee8 	cmpgeui	r16,zero,1659
 4019eb8:	04019ed8 	cmpnei	r16,zero,1659
 4019ebc:	04019ed8 	cmpnei	r16,zero,1659
 4019ec0:	04019ee8 	cmpgeui	r16,zero,1659
 4019ec4:	04019ed8 	cmpnei	r16,zero,1659
 4019ec8:	04019ee0 	cmpeqi	r16,zero,1659
 4019ecc:	04019ee8 	cmpgeui	r16,zero,1659
 4019ed0:	04019ee8 	cmpgeui	r16,zero,1659
 4019ed4:	04019ed8 	cmpnei	r16,zero,1659
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
 4019ed8:	00800044 	movi	r2,1
 4019edc:	00000306 	br	4019eec <alt_exception_cause_generated_bad_addr+0x88>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
 4019ee0:	0005883a 	mov	r2,zero
 4019ee4:	00000106 	br	4019eec <alt_exception_cause_generated_bad_addr+0x88>

  default:
    return 0;
 4019ee8:	0005883a 	mov	r2,zero
  }
}
 4019eec:	e037883a 	mov	sp,fp
 4019ef0:	df000017 	ldw	fp,0(sp)
 4019ef4:	dec00104 	addi	sp,sp,4
 4019ef8:	f800283a 	ret

04019efc <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
 4019efc:	defff904 	addi	sp,sp,-28
 4019f00:	dfc00615 	stw	ra,24(sp)
 4019f04:	df000515 	stw	fp,20(sp)
 4019f08:	df000504 	addi	fp,sp,20
 4019f0c:	e13ffe15 	stw	r4,-8(fp)
 4019f10:	e17ffd15 	stw	r5,-12(fp)
 4019f14:	e1bffc15 	stw	r6,-16(fp)
 4019f18:	e1fffb15 	stw	r7,-20(fp)
  int old;

  old = open (name, flags, mode);
 4019f1c:	e1bffb17 	ldw	r6,-20(fp)
 4019f20:	e17ffc17 	ldw	r5,-16(fp)
 4019f24:	e13ffd17 	ldw	r4,-12(fp)
 4019f28:	401a1640 	call	401a164 <open>
 4019f2c:	e0bfff15 	stw	r2,-4(fp)

  if (old >= 0)
 4019f30:	e0bfff17 	ldw	r2,-4(fp)
 4019f34:	10002016 	blt	r2,zero,4019fb8 <alt_open_fd+0xbc>
  {
    fd->dev      = alt_fd_list[old].dev;
 4019f38:	e0ffff17 	ldw	r3,-4(fp)
 4019f3c:	1805883a 	mov	r2,r3
 4019f40:	1085883a 	add	r2,r2,r2
 4019f44:	10c5883a 	add	r2,r2,r3
 4019f48:	100490ba 	slli	r2,r2,2
 4019f4c:	00c100b4 	movhi	r3,1026
 4019f50:	10c7883a 	add	r3,r2,r3
 4019f54:	18eefb17 	ldw	r3,-17428(r3)
 4019f58:	e0bffe17 	ldw	r2,-8(fp)
 4019f5c:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
 4019f60:	e0ffff17 	ldw	r3,-4(fp)
 4019f64:	1805883a 	mov	r2,r3
 4019f68:	1085883a 	add	r2,r2,r2
 4019f6c:	10c5883a 	add	r2,r2,r3
 4019f70:	100490ba 	slli	r2,r2,2
 4019f74:	00c100b4 	movhi	r3,1026
 4019f78:	10c7883a 	add	r3,r2,r3
 4019f7c:	18eefc17 	ldw	r3,-17424(r3)
 4019f80:	e0bffe17 	ldw	r2,-8(fp)
 4019f84:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
 4019f88:	e0ffff17 	ldw	r3,-4(fp)
 4019f8c:	1805883a 	mov	r2,r3
 4019f90:	1085883a 	add	r2,r2,r2
 4019f94:	10c5883a 	add	r2,r2,r3
 4019f98:	100490ba 	slli	r2,r2,2
 4019f9c:	00c100b4 	movhi	r3,1026
 4019fa0:	10c7883a 	add	r3,r2,r3
 4019fa4:	18eefd17 	ldw	r3,-17420(r3)
 4019fa8:	e0bffe17 	ldw	r2,-8(fp)
 4019fac:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
 4019fb0:	e13fff17 	ldw	r4,-4(fp)
 4019fb4:	401882c0 	call	401882c <alt_release_fd>
  }
} 
 4019fb8:	0001883a 	nop
 4019fbc:	e037883a 	mov	sp,fp
 4019fc0:	dfc00117 	ldw	ra,4(sp)
 4019fc4:	df000017 	ldw	fp,0(sp)
 4019fc8:	dec00204 	addi	sp,sp,8
 4019fcc:	f800283a 	ret

04019fd0 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
 4019fd0:	defffb04 	addi	sp,sp,-20
 4019fd4:	dfc00415 	stw	ra,16(sp)
 4019fd8:	df000315 	stw	fp,12(sp)
 4019fdc:	df000304 	addi	fp,sp,12
 4019fe0:	e13fff15 	stw	r4,-4(fp)
 4019fe4:	e17ffe15 	stw	r5,-8(fp)
 4019fe8:	e1bffd15 	stw	r6,-12(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
 4019fec:	01c07fc4 	movi	r7,511
 4019ff0:	01800044 	movi	r6,1
 4019ff4:	e17fff17 	ldw	r5,-4(fp)
 4019ff8:	010100b4 	movhi	r4,1026
 4019ffc:	212efe04 	addi	r4,r4,-17416
 401a000:	4019efc0 	call	4019efc <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
 401a004:	01c07fc4 	movi	r7,511
 401a008:	000d883a 	mov	r6,zero
 401a00c:	e17ffe17 	ldw	r5,-8(fp)
 401a010:	010100b4 	movhi	r4,1026
 401a014:	212efb04 	addi	r4,r4,-17428
 401a018:	4019efc0 	call	4019efc <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
 401a01c:	01c07fc4 	movi	r7,511
 401a020:	01800044 	movi	r6,1
 401a024:	e17ffd17 	ldw	r5,-12(fp)
 401a028:	010100b4 	movhi	r4,1026
 401a02c:	212f0104 	addi	r4,r4,-17404
 401a030:	4019efc0 	call	4019efc <alt_open_fd>
}  
 401a034:	0001883a 	nop
 401a038:	e037883a 	mov	sp,fp
 401a03c:	dfc00117 	ldw	ra,4(sp)
 401a040:	df000017 	ldw	fp,0(sp)
 401a044:	dec00204 	addi	sp,sp,8
 401a048:	f800283a 	ret

0401a04c <alt_get_errno>:
{
 401a04c:	defffe04 	addi	sp,sp,-8
 401a050:	dfc00115 	stw	ra,4(sp)
 401a054:	df000015 	stw	fp,0(sp)
 401a058:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 401a05c:	d0a00a17 	ldw	r2,-32728(gp)
 401a060:	10000326 	beq	r2,zero,401a070 <alt_get_errno+0x24>
 401a064:	d0a00a17 	ldw	r2,-32728(gp)
 401a068:	103ee83a 	callr	r2
 401a06c:	00000106 	br	401a074 <alt_get_errno+0x28>
 401a070:	d0a72704 	addi	r2,gp,-25444
}
 401a074:	e037883a 	mov	sp,fp
 401a078:	dfc00117 	ldw	ra,4(sp)
 401a07c:	df000017 	ldw	fp,0(sp)
 401a080:	dec00204 	addi	sp,sp,8
 401a084:	f800283a 	ret

0401a088 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
 401a088:	defffd04 	addi	sp,sp,-12
 401a08c:	df000215 	stw	fp,8(sp)
 401a090:	df000204 	addi	fp,sp,8
 401a094:	e13ffe15 	stw	r4,-8(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
 401a098:	e0bffe17 	ldw	r2,-8(fp)
 401a09c:	10800217 	ldw	r2,8(r2)
 401a0a0:	10d00034 	orhi	r3,r2,16384
 401a0a4:	e0bffe17 	ldw	r2,-8(fp)
 401a0a8:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 401a0ac:	e03fff15 	stw	zero,-4(fp)
 401a0b0:	00002306 	br	401a140 <alt_file_locked+0xb8>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 401a0b4:	e0ffff17 	ldw	r3,-4(fp)
 401a0b8:	1805883a 	mov	r2,r3
 401a0bc:	1085883a 	add	r2,r2,r2
 401a0c0:	10c5883a 	add	r2,r2,r3
 401a0c4:	100490ba 	slli	r2,r2,2
 401a0c8:	00c100b4 	movhi	r3,1026
 401a0cc:	10c7883a 	add	r3,r2,r3
 401a0d0:	18eefb17 	ldw	r3,-17428(r3)
 401a0d4:	e0bffe17 	ldw	r2,-8(fp)
 401a0d8:	10800017 	ldw	r2,0(r2)
 401a0dc:	1880151e 	bne	r3,r2,401a134 <alt_file_locked+0xac>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 401a0e0:	e0ffff17 	ldw	r3,-4(fp)
 401a0e4:	1805883a 	mov	r2,r3
 401a0e8:	1085883a 	add	r2,r2,r2
 401a0ec:	10c5883a 	add	r2,r2,r3
 401a0f0:	100490ba 	slli	r2,r2,2
 401a0f4:	00c100b4 	movhi	r3,1026
 401a0f8:	10c7883a 	add	r3,r2,r3
 401a0fc:	18aefd17 	ldw	r2,-17420(r3)
    if ((alt_fd_list[i].dev == fd->dev) &&
 401a100:	10000c0e 	bge	r2,zero,401a134 <alt_file_locked+0xac>
        (&alt_fd_list[i] != fd))
 401a104:	e0ffff17 	ldw	r3,-4(fp)
 401a108:	1805883a 	mov	r2,r3
 401a10c:	1085883a 	add	r2,r2,r2
 401a110:	10c5883a 	add	r2,r2,r3
 401a114:	100490ba 	slli	r2,r2,2
 401a118:	00c100b4 	movhi	r3,1026
 401a11c:	18eefb04 	addi	r3,r3,-17428
 401a120:	10c5883a 	add	r2,r2,r3
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 401a124:	e0fffe17 	ldw	r3,-8(fp)
 401a128:	18800226 	beq	r3,r2,401a134 <alt_file_locked+0xac>
    {
      return -EACCES;
 401a12c:	00bffcc4 	movi	r2,-13
 401a130:	00000806 	br	401a154 <alt_file_locked+0xcc>
  for (i = 0; i <= alt_max_fd; i++)
 401a134:	e0bfff17 	ldw	r2,-4(fp)
 401a138:	10800044 	addi	r2,r2,1
 401a13c:	e0bfff15 	stw	r2,-4(fp)
 401a140:	d0a00917 	ldw	r2,-32732(gp)
 401a144:	1007883a 	mov	r3,r2
 401a148:	e0bfff17 	ldw	r2,-4(fp)
 401a14c:	18bfd92e 	bgeu	r3,r2,401a0b4 <alt_file_locked+0x2c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
 401a150:	0005883a 	mov	r2,zero
}
 401a154:	e037883a 	mov	sp,fp
 401a158:	df000017 	ldw	fp,0(sp)
 401a15c:	dec00104 	addi	sp,sp,4
 401a160:	f800283a 	ret

0401a164 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
 401a164:	defff604 	addi	sp,sp,-40
 401a168:	dfc00915 	stw	ra,36(sp)
 401a16c:	df000815 	stw	fp,32(sp)
 401a170:	df000804 	addi	fp,sp,32
 401a174:	e13ffa15 	stw	r4,-24(fp)
 401a178:	e17ff915 	stw	r5,-28(fp)
 401a17c:	e1bff815 	stw	r6,-32(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
 401a180:	00bfffc4 	movi	r2,-1
 401a184:	e0bffe15 	stw	r2,-8(fp)
  int status = -ENODEV;
 401a188:	00bffb44 	movi	r2,-19
 401a18c:	e0bffd15 	stw	r2,-12(fp)
  int isafs = 0;
 401a190:	e03ffc15 	stw	zero,-16(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
 401a194:	d1600704 	addi	r5,gp,-32740
 401a198:	e13ffa17 	ldw	r4,-24(fp)
 401a19c:	4019db40 	call	4019db4 <alt_find_dev>
 401a1a0:	e0bfff15 	stw	r2,-4(fp)
 401a1a4:	e0bfff17 	ldw	r2,-4(fp)
 401a1a8:	1000051e 	bne	r2,zero,401a1c0 <open+0x5c>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
 401a1ac:	e13ffa17 	ldw	r4,-24(fp)
 401a1b0:	401a4940 	call	401a494 <alt_find_file>
 401a1b4:	e0bfff15 	stw	r2,-4(fp)
    isafs = 1;
 401a1b8:	00800044 	movi	r2,1
 401a1bc:	e0bffc15 	stw	r2,-16(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
 401a1c0:	e0bfff17 	ldw	r2,-4(fp)
 401a1c4:	10002c26 	beq	r2,zero,401a278 <open+0x114>
  {
    if ((index = alt_get_fd (dev)) < 0)
 401a1c8:	e13fff17 	ldw	r4,-4(fp)
 401a1cc:	401a59c0 	call	401a59c <alt_get_fd>
 401a1d0:	e0bffe15 	stw	r2,-8(fp)
 401a1d4:	e0bffe17 	ldw	r2,-8(fp)
 401a1d8:	1000030e 	bge	r2,zero,401a1e8 <open+0x84>
    {
      status = index;
 401a1dc:	e0bffe17 	ldw	r2,-8(fp)
 401a1e0:	e0bffd15 	stw	r2,-12(fp)
 401a1e4:	00002606 	br	401a280 <open+0x11c>
    }
    else
    {
      fd = &alt_fd_list[index];
 401a1e8:	e0fffe17 	ldw	r3,-8(fp)
 401a1ec:	1805883a 	mov	r2,r3
 401a1f0:	1085883a 	add	r2,r2,r2
 401a1f4:	10c5883a 	add	r2,r2,r3
 401a1f8:	100490ba 	slli	r2,r2,2
 401a1fc:	00c100b4 	movhi	r3,1026
 401a200:	18eefb04 	addi	r3,r3,-17428
 401a204:	10c5883a 	add	r2,r2,r3
 401a208:	e0bffb15 	stw	r2,-20(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
 401a20c:	e0fff917 	ldw	r3,-28(fp)
 401a210:	00900034 	movhi	r2,16384
 401a214:	10bfffc4 	addi	r2,r2,-1
 401a218:	1886703a 	and	r3,r3,r2
 401a21c:	e0bffb17 	ldw	r2,-20(fp)
 401a220:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
 401a224:	e0bffc17 	ldw	r2,-16(fp)
 401a228:	1000051e 	bne	r2,zero,401a240 <open+0xdc>
 401a22c:	e13ffb17 	ldw	r4,-20(fp)
 401a230:	401a0880 	call	401a088 <alt_file_locked>
 401a234:	e0bffd15 	stw	r2,-12(fp)
 401a238:	e0bffd17 	ldw	r2,-12(fp)
 401a23c:	10001016 	blt	r2,zero,401a280 <open+0x11c>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
 401a240:	e0bfff17 	ldw	r2,-4(fp)
 401a244:	10800317 	ldw	r2,12(r2)
 401a248:	10000826 	beq	r2,zero,401a26c <open+0x108>
 401a24c:	e0bfff17 	ldw	r2,-4(fp)
 401a250:	10800317 	ldw	r2,12(r2)
 401a254:	e1fff817 	ldw	r7,-32(fp)
 401a258:	e1bff917 	ldw	r6,-28(fp)
 401a25c:	e17ffa17 	ldw	r5,-24(fp)
 401a260:	e13ffb17 	ldw	r4,-20(fp)
 401a264:	103ee83a 	callr	r2
 401a268:	00000106 	br	401a270 <open+0x10c>
 401a26c:	0005883a 	mov	r2,zero
 401a270:	e0bffd15 	stw	r2,-12(fp)
 401a274:	00000206 	br	401a280 <open+0x11c>
      }
    }
  }
  else
  {
    status = -ENODEV;
 401a278:	00bffb44 	movi	r2,-19
 401a27c:	e0bffd15 	stw	r2,-12(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
 401a280:	e0bffd17 	ldw	r2,-12(fp)
 401a284:	1000090e 	bge	r2,zero,401a2ac <open+0x148>
  {
    alt_release_fd (index);  
 401a288:	e13ffe17 	ldw	r4,-8(fp)
 401a28c:	401882c0 	call	401882c <alt_release_fd>
    ALT_ERRNO = -status;
 401a290:	401a04c0 	call	401a04c <alt_get_errno>
 401a294:	1007883a 	mov	r3,r2
 401a298:	e0bffd17 	ldw	r2,-12(fp)
 401a29c:	0085c83a 	sub	r2,zero,r2
 401a2a0:	18800015 	stw	r2,0(r3)
    return -1;
 401a2a4:	00bfffc4 	movi	r2,-1
 401a2a8:	00000106 	br	401a2b0 <open+0x14c>
  }
  
  /* return the reference upon success */

  return index;
 401a2ac:	e0bffe17 	ldw	r2,-8(fp)
}
 401a2b0:	e037883a 	mov	sp,fp
 401a2b4:	dfc00117 	ldw	ra,4(sp)
 401a2b8:	df000017 	ldw	fp,0(sp)
 401a2bc:	dec00204 	addi	sp,sp,8
 401a2c0:	f800283a 	ret

0401a2c4 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
 401a2c4:	defffa04 	addi	sp,sp,-24
 401a2c8:	df000515 	stw	fp,20(sp)
 401a2cc:	df000504 	addi	fp,sp,20
 401a2d0:	e13ffb15 	stw	r4,-20(fp)
  NIOS2_READ_STATUS (context);
 401a2d4:	0005303a 	rdctl	r2,status
 401a2d8:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 401a2dc:	e0fffc17 	ldw	r3,-16(fp)
 401a2e0:	00bfff84 	movi	r2,-2
 401a2e4:	1884703a 	and	r2,r3,r2
 401a2e8:	1001703a 	wrctl	status,r2
  return context;
 401a2ec:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
 401a2f0:	e0bfff15 	stw	r2,-4(fp)
  alt_llist_remove (&alarm->llist);
 401a2f4:	e0bffb17 	ldw	r2,-20(fp)
 401a2f8:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 401a2fc:	e0bffd17 	ldw	r2,-12(fp)
 401a300:	10800017 	ldw	r2,0(r2)
 401a304:	e0fffd17 	ldw	r3,-12(fp)
 401a308:	18c00117 	ldw	r3,4(r3)
 401a30c:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
 401a310:	e0bffd17 	ldw	r2,-12(fp)
 401a314:	10800117 	ldw	r2,4(r2)
 401a318:	e0fffd17 	ldw	r3,-12(fp)
 401a31c:	18c00017 	ldw	r3,0(r3)
 401a320:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 401a324:	e0bffd17 	ldw	r2,-12(fp)
 401a328:	e0fffd17 	ldw	r3,-12(fp)
 401a32c:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
 401a330:	e0bffd17 	ldw	r2,-12(fp)
 401a334:	e0fffd17 	ldw	r3,-12(fp)
 401a338:	10c00015 	stw	r3,0(r2)
} 
 401a33c:	0001883a 	nop
 401a340:	e0bfff17 	ldw	r2,-4(fp)
 401a344:	e0bffe15 	stw	r2,-8(fp)
  NIOS2_WRITE_STATUS (context);
 401a348:	e0bffe17 	ldw	r2,-8(fp)
 401a34c:	1001703a 	wrctl	status,r2
}
 401a350:	0001883a 	nop
  alt_irq_enable_all (irq_context);
}
 401a354:	0001883a 	nop
 401a358:	e037883a 	mov	sp,fp
 401a35c:	df000017 	ldw	fp,0(sp)
 401a360:	dec00104 	addi	sp,sp,4
 401a364:	f800283a 	ret

0401a368 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 401a368:	defffb04 	addi	sp,sp,-20
 401a36c:	dfc00415 	stw	ra,16(sp)
 401a370:	df000315 	stw	fp,12(sp)
 401a374:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 401a378:	d0a00d17 	ldw	r2,-32716(gp)
 401a37c:	e0bfff15 	stw	r2,-4(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 401a380:	d0a72f17 	ldw	r2,-25412(gp)
 401a384:	10800044 	addi	r2,r2,1
 401a388:	d0a72f15 	stw	r2,-25412(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 401a38c:	00002e06 	br	401a448 <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
 401a390:	e0bfff17 	ldw	r2,-4(fp)
 401a394:	10800017 	ldw	r2,0(r2)
 401a398:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 401a39c:	e0bfff17 	ldw	r2,-4(fp)
 401a3a0:	10800403 	ldbu	r2,16(r2)
 401a3a4:	10803fcc 	andi	r2,r2,255
 401a3a8:	10000426 	beq	r2,zero,401a3bc <alt_tick+0x54>
 401a3ac:	d0a72f17 	ldw	r2,-25412(gp)
 401a3b0:	1000021e 	bne	r2,zero,401a3bc <alt_tick+0x54>
    {
      alarm->rollover = 0;
 401a3b4:	e0bfff17 	ldw	r2,-4(fp)
 401a3b8:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
 401a3bc:	e0bfff17 	ldw	r2,-4(fp)
 401a3c0:	10800217 	ldw	r2,8(r2)
 401a3c4:	d0e72f17 	ldw	r3,-25412(gp)
 401a3c8:	18801d36 	bltu	r3,r2,401a440 <alt_tick+0xd8>
 401a3cc:	e0bfff17 	ldw	r2,-4(fp)
 401a3d0:	10800403 	ldbu	r2,16(r2)
 401a3d4:	10803fcc 	andi	r2,r2,255
 401a3d8:	1000191e 	bne	r2,zero,401a440 <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
 401a3dc:	e0bfff17 	ldw	r2,-4(fp)
 401a3e0:	10800317 	ldw	r2,12(r2)
 401a3e4:	e0ffff17 	ldw	r3,-4(fp)
 401a3e8:	18c00517 	ldw	r3,20(r3)
 401a3ec:	1809883a 	mov	r4,r3
 401a3f0:	103ee83a 	callr	r2
 401a3f4:	e0bffd15 	stw	r2,-12(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 401a3f8:	e0bffd17 	ldw	r2,-12(fp)
 401a3fc:	1000031e 	bne	r2,zero,401a40c <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
 401a400:	e13fff17 	ldw	r4,-4(fp)
 401a404:	401a2c40 	call	401a2c4 <alt_alarm_stop>
 401a408:	00000d06 	br	401a440 <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
 401a40c:	e0bfff17 	ldw	r2,-4(fp)
 401a410:	10c00217 	ldw	r3,8(r2)
 401a414:	e0bffd17 	ldw	r2,-12(fp)
 401a418:	1887883a 	add	r3,r3,r2
 401a41c:	e0bfff17 	ldw	r2,-4(fp)
 401a420:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 401a424:	e0bfff17 	ldw	r2,-4(fp)
 401a428:	10c00217 	ldw	r3,8(r2)
 401a42c:	d0a72f17 	ldw	r2,-25412(gp)
 401a430:	1880032e 	bgeu	r3,r2,401a440 <alt_tick+0xd8>
        {
          alarm->rollover = 1;
 401a434:	e0bfff17 	ldw	r2,-4(fp)
 401a438:	00c00044 	movi	r3,1
 401a43c:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
 401a440:	e0bffe17 	ldw	r2,-8(fp)
 401a444:	e0bfff15 	stw	r2,-4(fp)
  while (alarm != (alt_alarm*) &alt_alarm_list)
 401a448:	e0ffff17 	ldw	r3,-4(fp)
 401a44c:	d0a00d04 	addi	r2,gp,-32716
 401a450:	18bfcf1e 	bne	r3,r2,401a390 <alt_tick+0x28>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
 401a454:	0001883a 	nop
}
 401a458:	0001883a 	nop
 401a45c:	e037883a 	mov	sp,fp
 401a460:	dfc00117 	ldw	ra,4(sp)
 401a464:	df000017 	ldw	fp,0(sp)
 401a468:	dec00204 	addi	sp,sp,8
 401a46c:	f800283a 	ret

0401a470 <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
 401a470:	deffff04 	addi	sp,sp,-4
 401a474:	df000015 	stw	fp,0(sp)
 401a478:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
 401a47c:	000170fa 	wrctl	ienable,zero
}
 401a480:	0001883a 	nop
 401a484:	e037883a 	mov	sp,fp
 401a488:	df000017 	ldw	fp,0(sp)
 401a48c:	dec00104 	addi	sp,sp,4
 401a490:	f800283a 	ret

0401a494 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
 401a494:	defffb04 	addi	sp,sp,-20
 401a498:	dfc00415 	stw	ra,16(sp)
 401a49c:	df000315 	stw	fp,12(sp)
 401a4a0:	df000304 	addi	fp,sp,12
 401a4a4:	e13ffd15 	stw	r4,-12(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
 401a4a8:	d0a00517 	ldw	r2,-32748(gp)
 401a4ac:	e0bfff15 	stw	r2,-4(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 401a4b0:	00003106 	br	401a578 <alt_find_file+0xe4>
  {
    len = strlen(next->name);
 401a4b4:	e0bfff17 	ldw	r2,-4(fp)
 401a4b8:	10800217 	ldw	r2,8(r2)
 401a4bc:	1009883a 	mov	r4,r2
 401a4c0:	40078680 	call	4007868 <strlen>
 401a4c4:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
 401a4c8:	e0bfff17 	ldw	r2,-4(fp)
 401a4cc:	10c00217 	ldw	r3,8(r2)
 401a4d0:	e0bffe17 	ldw	r2,-8(fp)
 401a4d4:	10bfffc4 	addi	r2,r2,-1
 401a4d8:	1885883a 	add	r2,r3,r2
 401a4dc:	10800003 	ldbu	r2,0(r2)
 401a4e0:	10803fcc 	andi	r2,r2,255
 401a4e4:	1080201c 	xori	r2,r2,128
 401a4e8:	10bfe004 	addi	r2,r2,-128
 401a4ec:	10800bd8 	cmpnei	r2,r2,47
 401a4f0:	1000031e 	bne	r2,zero,401a500 <alt_find_file+0x6c>
    {
      len -= 1;
 401a4f4:	e0bffe17 	ldw	r2,-8(fp)
 401a4f8:	10bfffc4 	addi	r2,r2,-1
 401a4fc:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 401a500:	e0bffe17 	ldw	r2,-8(fp)
 401a504:	e0fffd17 	ldw	r3,-12(fp)
 401a508:	1885883a 	add	r2,r3,r2
 401a50c:	10800003 	ldbu	r2,0(r2)
 401a510:	10803fcc 	andi	r2,r2,255
 401a514:	1080201c 	xori	r2,r2,128
 401a518:	10bfe004 	addi	r2,r2,-128
 401a51c:	10800be0 	cmpeqi	r2,r2,47
 401a520:	1000081e 	bne	r2,zero,401a544 <alt_find_file+0xb0>
 401a524:	e0bffe17 	ldw	r2,-8(fp)
 401a528:	e0fffd17 	ldw	r3,-12(fp)
 401a52c:	1885883a 	add	r2,r3,r2
 401a530:	10800003 	ldbu	r2,0(r2)
 401a534:	10803fcc 	andi	r2,r2,255
 401a538:	1080201c 	xori	r2,r2,128
 401a53c:	10bfe004 	addi	r2,r2,-128
 401a540:	10000a1e 	bne	r2,zero,401a56c <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
 401a544:	e0bfff17 	ldw	r2,-4(fp)
 401a548:	10800217 	ldw	r2,8(r2)
 401a54c:	e0fffe17 	ldw	r3,-8(fp)
 401a550:	180d883a 	mov	r6,r3
 401a554:	e17ffd17 	ldw	r5,-12(fp)
 401a558:	1009883a 	mov	r4,r2
 401a55c:	401a6d80 	call	401a6d8 <memcmp>
    if (((name[len] == '/') || (name[len] == '\0')) && 
 401a560:	1000021e 	bne	r2,zero,401a56c <alt_find_file+0xd8>
    {
      /* match found */

      return next;
 401a564:	e0bfff17 	ldw	r2,-4(fp)
 401a568:	00000706 	br	401a588 <alt_find_file+0xf4>
    }
    next = (alt_dev*) next->llist.next;
 401a56c:	e0bfff17 	ldw	r2,-4(fp)
 401a570:	10800017 	ldw	r2,0(r2)
 401a574:	e0bfff15 	stw	r2,-4(fp)
  while (next != (alt_dev*) &alt_fs_list)
 401a578:	e0ffff17 	ldw	r3,-4(fp)
 401a57c:	d0a00504 	addi	r2,gp,-32748
 401a580:	18bfcc1e 	bne	r3,r2,401a4b4 <alt_find_file+0x20>
  }
  
  /* No match found */
  
  return NULL;     
 401a584:	0005883a 	mov	r2,zero
}
 401a588:	e037883a 	mov	sp,fp
 401a58c:	dfc00117 	ldw	ra,4(sp)
 401a590:	df000017 	ldw	fp,0(sp)
 401a594:	dec00204 	addi	sp,sp,8
 401a598:	f800283a 	ret

0401a59c <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
 401a59c:	defffc04 	addi	sp,sp,-16
 401a5a0:	df000315 	stw	fp,12(sp)
 401a5a4:	df000304 	addi	fp,sp,12
 401a5a8:	e13ffd15 	stw	r4,-12(fp)
  alt_32 i;
  int rc = -EMFILE;
 401a5ac:	00bffa04 	movi	r2,-24
 401a5b0:	e0bffe15 	stw	r2,-8(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 401a5b4:	e03fff15 	stw	zero,-4(fp)
 401a5b8:	00001d06 	br	401a630 <alt_get_fd+0x94>
  {
    if (!alt_fd_list[i].dev)
 401a5bc:	e0ffff17 	ldw	r3,-4(fp)
 401a5c0:	1805883a 	mov	r2,r3
 401a5c4:	1085883a 	add	r2,r2,r2
 401a5c8:	10c5883a 	add	r2,r2,r3
 401a5cc:	100490ba 	slli	r2,r2,2
 401a5d0:	00c100b4 	movhi	r3,1026
 401a5d4:	10c7883a 	add	r3,r2,r3
 401a5d8:	18aefb17 	ldw	r2,-17428(r3)
 401a5dc:	1000111e 	bne	r2,zero,401a624 <alt_get_fd+0x88>
    {
      alt_fd_list[i].dev = dev;
 401a5e0:	e0ffff17 	ldw	r3,-4(fp)
 401a5e4:	1805883a 	mov	r2,r3
 401a5e8:	1085883a 	add	r2,r2,r2
 401a5ec:	10c5883a 	add	r2,r2,r3
 401a5f0:	100490ba 	slli	r2,r2,2
 401a5f4:	e13ffd17 	ldw	r4,-12(fp)
 401a5f8:	00c100b4 	movhi	r3,1026
 401a5fc:	10c7883a 	add	r3,r2,r3
 401a600:	192efb15 	stw	r4,-17428(r3)
      if (i > alt_max_fd)
 401a604:	d0e00917 	ldw	r3,-32732(gp)
 401a608:	e0bfff17 	ldw	r2,-4(fp)
 401a60c:	1880020e 	bge	r3,r2,401a618 <alt_get_fd+0x7c>
      {
        alt_max_fd = i;
 401a610:	e0bfff17 	ldw	r2,-4(fp)
 401a614:	d0a00915 	stw	r2,-32732(gp)
      }
      rc = i;
 401a618:	e0bfff17 	ldw	r2,-4(fp)
 401a61c:	e0bffe15 	stw	r2,-8(fp)
      goto alt_get_fd_exit;
 401a620:	00000706 	br	401a640 <alt_get_fd+0xa4>
  for (i = 0; i < ALT_MAX_FD; i++)
 401a624:	e0bfff17 	ldw	r2,-4(fp)
 401a628:	10800044 	addi	r2,r2,1
 401a62c:	e0bfff15 	stw	r2,-4(fp)
 401a630:	e0bfff17 	ldw	r2,-4(fp)
 401a634:	10800810 	cmplti	r2,r2,32
 401a638:	103fe01e 	bne	r2,zero,401a5bc <alt_get_fd+0x20>
    }
  }

 alt_get_fd_exit:
 401a63c:	0001883a 	nop
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
 401a640:	e0bffe17 	ldw	r2,-8(fp)
}
 401a644:	e037883a 	mov	sp,fp
 401a648:	df000017 	ldw	fp,0(sp)
 401a64c:	dec00104 	addi	sp,sp,4
 401a650:	f800283a 	ret

0401a654 <atexit>:
 * Register a function to be performed at exit.
 */

int
atexit (void (*fn) (void))
{
 401a654:	defffd04 	addi	sp,sp,-12
 401a658:	dfc00215 	stw	ra,8(sp)
 401a65c:	df000115 	stw	fp,4(sp)
 401a660:	df000104 	addi	fp,sp,4
 401a664:	e13fff15 	stw	r4,-4(fp)
  return __register_exitproc (__et_atexit, fn, NULL, NULL);
 401a668:	000f883a 	mov	r7,zero
 401a66c:	000d883a 	mov	r6,zero
 401a670:	e17fff17 	ldw	r5,-4(fp)
 401a674:	0009883a 	mov	r4,zero
 401a678:	401a80c0 	call	401a80c <__register_exitproc>
}
 401a67c:	e037883a 	mov	sp,fp
 401a680:	dfc00117 	ldw	ra,4(sp)
 401a684:	df000017 	ldw	fp,0(sp)
 401a688:	dec00204 	addi	sp,sp,8
 401a68c:	f800283a 	ret

0401a690 <exit>:
 * Exit, flushing stdio buffers if necessary.
 */

void
exit (int code)
{
 401a690:	defffd04 	addi	sp,sp,-12
 401a694:	dfc00215 	stw	ra,8(sp)
 401a698:	df000115 	stw	fp,4(sp)
 401a69c:	df000104 	addi	fp,sp,4
 401a6a0:	e13fff15 	stw	r4,-4(fp)
#ifdef _LITE_EXIT
  /* Refer to comments in __atexit.c for more details of lite exit.  */
  void __call_exitprocs (int, void *) __attribute__((weak));
  if (__call_exitprocs)
#endif
    __call_exitprocs (code, NULL);
 401a6a4:	000b883a 	mov	r5,zero
 401a6a8:	e13fff17 	ldw	r4,-4(fp)
 401a6ac:	401a9240 	call	401a924 <__call_exitprocs>
#ifndef WANT_SMALL_STDIO        /* IntelSpecific */
  if (_GLOBAL_REENT->__cleanup)
 401a6b0:	d0a00217 	ldw	r2,-32760(gp)
 401a6b4:	10800f17 	ldw	r2,60(r2)
 401a6b8:	10000526 	beq	r2,zero,401a6d0 <exit+0x40>
    (*_GLOBAL_REENT->__cleanup) (_GLOBAL_REENT);
 401a6bc:	d0a00217 	ldw	r2,-32760(gp)
 401a6c0:	10800f17 	ldw	r2,60(r2)
 401a6c4:	d0e00217 	ldw	r3,-32760(gp)
 401a6c8:	1809883a 	mov	r4,r3
 401a6cc:	103ee83a 	callr	r2
#endif                          /* IntelSpecific */
  _exit (code);
 401a6d0:	e13fff17 	ldw	r4,-4(fp)
 401a6d4:	4017de00 	call	4017de0 <_exit>

0401a6d8 <memcmp>:

int
memcmp (const void *m1,
	const void *m2,
	size_t n)
{
 401a6d8:	defff804 	addi	sp,sp,-32
 401a6dc:	df000715 	stw	fp,28(sp)
 401a6e0:	df000704 	addi	fp,sp,28
 401a6e4:	e13ffb15 	stw	r4,-20(fp)
 401a6e8:	e17ffa15 	stw	r5,-24(fp)
 401a6ec:	e1bff915 	stw	r6,-28(fp)
      s1++;
      s2++;
    }
  return 0;
#else  
  unsigned char *s1 = (unsigned char *) m1;
 401a6f0:	e0bffb17 	ldw	r2,-20(fp)
 401a6f4:	e0bfff15 	stw	r2,-4(fp)
  unsigned char *s2 = (unsigned char *) m2;
 401a6f8:	e0bffa17 	ldw	r2,-24(fp)
 401a6fc:	e0bffe15 	stw	r2,-8(fp)
  unsigned long *a2;

  /* If the size is too small, or either pointer is unaligned,
     then we punt to the byte compare loop.  Hopefully this will
     not turn up in inner loops.  */
  if (!TOO_SMALL(n) && !UNALIGNED(s1,s2))
 401a700:	e0bff917 	ldw	r2,-28(fp)
 401a704:	10800130 	cmpltui	r2,r2,4
 401a708:	1000371e 	bne	r2,zero,401a7e8 <memcmp+0x110>
 401a70c:	e0ffff17 	ldw	r3,-4(fp)
 401a710:	e0bffe17 	ldw	r2,-8(fp)
 401a714:	1884b03a 	or	r2,r3,r2
 401a718:	108000cc 	andi	r2,r2,3
 401a71c:	1000321e 	bne	r2,zero,401a7e8 <memcmp+0x110>
    {
      /* Otherwise, load and compare the blocks of memory one 
         word at a time.  */
      a1 = (unsigned long*) s1;
 401a720:	e0bfff17 	ldw	r2,-4(fp)
 401a724:	e0bffd15 	stw	r2,-12(fp)
      a2 = (unsigned long*) s2;
 401a728:	e0bffe17 	ldw	r2,-8(fp)
 401a72c:	e0bffc15 	stw	r2,-16(fp)
      while (n >= LBLOCKSIZE)
 401a730:	00000e06 	br	401a76c <memcmp+0x94>
        {
          if (*a1 != *a2) 
 401a734:	e0bffd17 	ldw	r2,-12(fp)
 401a738:	10c00017 	ldw	r3,0(r2)
 401a73c:	e0bffc17 	ldw	r2,-16(fp)
 401a740:	10800017 	ldw	r2,0(r2)
 401a744:	18800d1e 	bne	r3,r2,401a77c <memcmp+0xa4>
   	    break;
          a1++;
 401a748:	e0bffd17 	ldw	r2,-12(fp)
 401a74c:	10800104 	addi	r2,r2,4
 401a750:	e0bffd15 	stw	r2,-12(fp)
          a2++;
 401a754:	e0bffc17 	ldw	r2,-16(fp)
 401a758:	10800104 	addi	r2,r2,4
 401a75c:	e0bffc15 	stw	r2,-16(fp)
          n -= LBLOCKSIZE;
 401a760:	e0bff917 	ldw	r2,-28(fp)
 401a764:	10bfff04 	addi	r2,r2,-4
 401a768:	e0bff915 	stw	r2,-28(fp)
      while (n >= LBLOCKSIZE)
 401a76c:	e0bff917 	ldw	r2,-28(fp)
 401a770:	10800128 	cmpgeui	r2,r2,4
 401a774:	103fef1e 	bne	r2,zero,401a734 <memcmp+0x5c>
 401a778:	00000106 	br	401a780 <memcmp+0xa8>
   	    break;
 401a77c:	0001883a 	nop
        }

      /* check m mod LBLOCKSIZE remaining characters */

      s1 = (unsigned char*)a1;
 401a780:	e0bffd17 	ldw	r2,-12(fp)
 401a784:	e0bfff15 	stw	r2,-4(fp)
      s2 = (unsigned char*)a2;
 401a788:	e0bffc17 	ldw	r2,-16(fp)
 401a78c:	e0bffe15 	stw	r2,-8(fp)
    }

  while (n--)
 401a790:	00001506 	br	401a7e8 <memcmp+0x110>
    {
      if (*s1 != *s2)
 401a794:	e0bfff17 	ldw	r2,-4(fp)
 401a798:	10c00003 	ldbu	r3,0(r2)
 401a79c:	e0bffe17 	ldw	r2,-8(fp)
 401a7a0:	10800003 	ldbu	r2,0(r2)
 401a7a4:	18c03fcc 	andi	r3,r3,255
 401a7a8:	10803fcc 	andi	r2,r2,255
 401a7ac:	18800826 	beq	r3,r2,401a7d0 <memcmp+0xf8>
	return *s1 - *s2;
 401a7b0:	e0bfff17 	ldw	r2,-4(fp)
 401a7b4:	10800003 	ldbu	r2,0(r2)
 401a7b8:	10c03fcc 	andi	r3,r2,255
 401a7bc:	e0bffe17 	ldw	r2,-8(fp)
 401a7c0:	10800003 	ldbu	r2,0(r2)
 401a7c4:	10803fcc 	andi	r2,r2,255
 401a7c8:	1885c83a 	sub	r2,r3,r2
 401a7cc:	00000b06 	br	401a7fc <memcmp+0x124>
      s1++;
 401a7d0:	e0bfff17 	ldw	r2,-4(fp)
 401a7d4:	10800044 	addi	r2,r2,1
 401a7d8:	e0bfff15 	stw	r2,-4(fp)
      s2++;
 401a7dc:	e0bffe17 	ldw	r2,-8(fp)
 401a7e0:	10800044 	addi	r2,r2,1
 401a7e4:	e0bffe15 	stw	r2,-8(fp)
  while (n--)
 401a7e8:	e0bff917 	ldw	r2,-28(fp)
 401a7ec:	10ffffc4 	addi	r3,r2,-1
 401a7f0:	e0fff915 	stw	r3,-28(fp)
 401a7f4:	103fe71e 	bne	r2,zero,401a794 <memcmp+0xbc>
    }

  return 0;
 401a7f8:	0005883a 	mov	r2,zero
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 401a7fc:	e037883a 	mov	sp,fp
 401a800:	df000017 	ldw	fp,0(sp)
 401a804:	dec00104 	addi	sp,sp,4
 401a808:	f800283a 	ret

0401a80c <__register_exitproc>:
int
__register_exitproc (int type,
	void (*fn) (void),
	void *arg,
	void *d)
{
 401a80c:	defff904 	addi	sp,sp,-28
 401a810:	df000615 	stw	fp,24(sp)
 401a814:	dc000515 	stw	r16,20(sp)
 401a818:	df000604 	addi	fp,sp,24
 401a81c:	e13ffd15 	stw	r4,-12(fp)
 401a820:	e17ffc15 	stw	r5,-16(fp)
 401a824:	e1bffb15 	stw	r6,-20(fp)
 401a828:	e1fffa15 	stw	r7,-24(fp)

#ifndef __SINGLE_THREAD__
  __lock_acquire_recursive(__atexit_recursive_mutex);
#endif

  p = _GLOBAL_ATEXIT;
 401a82c:	d0a00217 	ldw	r2,-32760(gp)
 401a830:	14005217 	ldw	r16,328(r2)
  if (p == NULL)
 401a834:	8000041e 	bne	r16,zero,401a848 <__register_exitproc+0x3c>
    {
      _GLOBAL_ATEXIT = p = _GLOBAL_ATEXIT0;
 401a838:	d0a00217 	ldw	r2,-32760(gp)
 401a83c:	14005304 	addi	r16,r2,332
 401a840:	d0a00217 	ldw	r2,-32760(gp)
 401a844:	14005215 	stw	r16,328(r2)
      extern struct _on_exit_args * const __on_exit_args _ATTRIBUTE ((weak));
      if (&__on_exit_args != NULL)
	p->_on_exit_args_ptr = __on_exit_args;
#endif	/* def _REENT_SMALL */
    }
  if (p->_ind >= _ATEXIT_SIZE)
 401a848:	80800117 	ldw	r2,4(r16)
 401a84c:	10800810 	cmplti	r2,r2,32
 401a850:	1000021e 	bne	r2,zero,401a85c <__register_exitproc+0x50>
    {
#if !defined (_ATEXIT_DYNAMIC_ALLOC) || !defined (MALLOC_PROVIDED)
#ifndef __SINGLE_THREAD__
      __lock_release_recursive(__atexit_recursive_mutex);
#endif
      return -1;
 401a854:	00bfffc4 	movi	r2,-1
 401a858:	00002d06 	br	401a910 <__register_exitproc+0x104>
      p->_on_exit_args_ptr = NULL;
#endif
#endif
    }

  if (type != __et_atexit)
 401a85c:	e0bffd17 	ldw	r2,-12(fp)
 401a860:	10002226 	beq	r2,zero,401a8ec <__register_exitproc+0xe0>
	  args->_is_cxa = 0;
	  p->_on_exit_args_ptr = args;
#endif
	}
#else
      args = &p->_on_exit_args;
 401a864:	80802204 	addi	r2,r16,136
 401a868:	e0bffe15 	stw	r2,-8(fp)
#endif
      args->_fnargs[p->_ind] = arg;
 401a86c:	80800117 	ldw	r2,4(r16)
 401a870:	e0fffe17 	ldw	r3,-8(fp)
 401a874:	100490ba 	slli	r2,r2,2
 401a878:	1885883a 	add	r2,r3,r2
 401a87c:	e0fffb17 	ldw	r3,-20(fp)
 401a880:	10c00015 	stw	r3,0(r2)
      args->_fntypes |= (1 << p->_ind);
 401a884:	e0bffe17 	ldw	r2,-8(fp)
 401a888:	10804017 	ldw	r2,256(r2)
 401a88c:	80c00117 	ldw	r3,4(r16)
 401a890:	01000044 	movi	r4,1
 401a894:	20c6983a 	sll	r3,r4,r3
 401a898:	10c6b03a 	or	r3,r2,r3
 401a89c:	e0bffe17 	ldw	r2,-8(fp)
 401a8a0:	10c04015 	stw	r3,256(r2)
      args->_dso_handle[p->_ind] = d;
 401a8a4:	80800117 	ldw	r2,4(r16)
 401a8a8:	e0fffe17 	ldw	r3,-8(fp)
 401a8ac:	10800804 	addi	r2,r2,32
 401a8b0:	100490ba 	slli	r2,r2,2
 401a8b4:	1885883a 	add	r2,r3,r2
 401a8b8:	e0fffa17 	ldw	r3,-24(fp)
 401a8bc:	10c00015 	stw	r3,0(r2)
      if (type == __et_cxa)
 401a8c0:	e0bffd17 	ldw	r2,-12(fp)
 401a8c4:	10800098 	cmpnei	r2,r2,2
 401a8c8:	1000081e 	bne	r2,zero,401a8ec <__register_exitproc+0xe0>
	args->_is_cxa |= (1 << p->_ind);
 401a8cc:	e0bffe17 	ldw	r2,-8(fp)
 401a8d0:	10804117 	ldw	r2,260(r2)
 401a8d4:	80c00117 	ldw	r3,4(r16)
 401a8d8:	01000044 	movi	r4,1
 401a8dc:	20c6983a 	sll	r3,r4,r3
 401a8e0:	10c6b03a 	or	r3,r2,r3
 401a8e4:	e0bffe17 	ldw	r2,-8(fp)
 401a8e8:	10c04115 	stw	r3,260(r2)
    }
  p->_fns[p->_ind++] = fn;
 401a8ec:	80800117 	ldw	r2,4(r16)
 401a8f0:	10c00044 	addi	r3,r2,1
 401a8f4:	80c00115 	stw	r3,4(r16)
 401a8f8:	10800084 	addi	r2,r2,2
 401a8fc:	100490ba 	slli	r2,r2,2
 401a900:	8085883a 	add	r2,r16,r2
 401a904:	e0fffc17 	ldw	r3,-16(fp)
 401a908:	10c00015 	stw	r3,0(r2)
#ifndef __SINGLE_THREAD__
  __lock_release_recursive(__atexit_recursive_mutex);
#endif
  return 0;
 401a90c:	0005883a 	mov	r2,zero
}
 401a910:	e6ffff04 	addi	sp,fp,-4
 401a914:	df000117 	ldw	fp,4(sp)
 401a918:	dc000017 	ldw	r16,0(sp)
 401a91c:	dec00204 	addi	sp,sp,8
 401a920:	f800283a 	ret

0401a924 <__call_exitprocs>:
 * otherwise only the handlers from that DSO are called.
 */

void 
__call_exitprocs (int code, void *d)
{
 401a924:	defff504 	addi	sp,sp,-44
 401a928:	dfc00a15 	stw	ra,40(sp)
 401a92c:	df000915 	stw	fp,36(sp)
 401a930:	dc800815 	stw	r18,32(sp)
 401a934:	dc400715 	stw	r17,28(sp)
 401a938:	dc000615 	stw	r16,24(sp)
 401a93c:	df000904 	addi	fp,sp,36
 401a940:	e13ff815 	stw	r4,-32(fp)
 401a944:	e17ff715 	stw	r5,-36(fp)
  __lock_acquire_recursive(__atexit_recursive_mutex);
#endif

 restart:

  p = _GLOBAL_ATEXIT;
 401a948:	d0a00217 	ldw	r2,-32760(gp)
 401a94c:	14005217 	ldw	r16,328(r2)
  lastp = &_GLOBAL_ATEXIT;
 401a950:	d0a00217 	ldw	r2,-32760(gp)
 401a954:	10805204 	addi	r2,r2,328
 401a958:	e0bffc15 	stw	r2,-16(fp)
  while (p)
 401a95c:	80004b26 	beq	r16,zero,401aa8c <__call_exitprocs+0x168>
    {
#ifdef _REENT_SMALL
      args = p->_on_exit_args_ptr;
#else
      args = &p->_on_exit_args;
 401a960:	84802204 	addi	r18,r16,136
#endif
      for (n = p->_ind - 1; n >= 0; n--)
 401a964:	80800117 	ldw	r2,4(r16)
 401a968:	147fffc4 	addi	r17,r2,-1
 401a96c:	00004506 	br	401aa84 <__call_exitprocs+0x160>
	{
	  int ind;

	  i = 1 << n;
 401a970:	00800044 	movi	r2,1
 401a974:	1444983a 	sll	r2,r2,r17
 401a978:	e0bffb15 	stw	r2,-20(fp)

	  /* Skip functions not from this dso.  */
	  if (d && (!args || args->_dso_handle[n] != d))
 401a97c:	e0bff717 	ldw	r2,-36(fp)
 401a980:	10000726 	beq	r2,zero,401a9a0 <__call_exitprocs+0x7c>
 401a984:	90003b26 	beq	r18,zero,401aa74 <__call_exitprocs+0x150>
 401a988:	88800804 	addi	r2,r17,32
 401a98c:	100490ba 	slli	r2,r2,2
 401a990:	9085883a 	add	r2,r18,r2
 401a994:	10800017 	ldw	r2,0(r2)
 401a998:	e0fff717 	ldw	r3,-36(fp)
 401a99c:	1880351e 	bne	r3,r2,401aa74 <__call_exitprocs+0x150>
	    continue;

	  /* Remove the function now to protect against the
	     function calling exit recursively.  */
	  fn = p->_fns[n];
 401a9a0:	88800084 	addi	r2,r17,2
 401a9a4:	100490ba 	slli	r2,r2,2
 401a9a8:	8085883a 	add	r2,r16,r2
 401a9ac:	10800017 	ldw	r2,0(r2)
 401a9b0:	e0bffa15 	stw	r2,-24(fp)
	  if (n == p->_ind - 1)
 401a9b4:	80800117 	ldw	r2,4(r16)
 401a9b8:	10bfffc4 	addi	r2,r2,-1
 401a9bc:	8880041e 	bne	r17,r2,401a9d0 <__call_exitprocs+0xac>
	    p->_ind--;
 401a9c0:	80800117 	ldw	r2,4(r16)
 401a9c4:	10bfffc4 	addi	r2,r2,-1
 401a9c8:	80800115 	stw	r2,4(r16)
 401a9cc:	00000406 	br	401a9e0 <__call_exitprocs+0xbc>
	  else
	    p->_fns[n] = NULL;
 401a9d0:	88800084 	addi	r2,r17,2
 401a9d4:	100490ba 	slli	r2,r2,2
 401a9d8:	8085883a 	add	r2,r16,r2
 401a9dc:	10000015 	stw	zero,0(r2)

	  /* Skip functions that have already been called.  */
	  if (!fn)
 401a9e0:	e0bffa17 	ldw	r2,-24(fp)
 401a9e4:	10002526 	beq	r2,zero,401aa7c <__call_exitprocs+0x158>
	    continue;

	  ind = p->_ind;
 401a9e8:	80800117 	ldw	r2,4(r16)
 401a9ec:	e0bff915 	stw	r2,-28(fp)

	  /* Call the function.  */
	  if (!args || (args->_fntypes & i) == 0)
 401a9f0:	90000426 	beq	r18,zero,401aa04 <__call_exitprocs+0xe0>
 401a9f4:	90c04017 	ldw	r3,256(r18)
 401a9f8:	e0bffb17 	ldw	r2,-20(fp)
 401a9fc:	1884703a 	and	r2,r3,r2
 401aa00:	1000031e 	bne	r2,zero,401aa10 <__call_exitprocs+0xec>
	    fn ();
 401aa04:	e0bffa17 	ldw	r2,-24(fp)
 401aa08:	103ee83a 	callr	r2
 401aa0c:	00001206 	br	401aa58 <__call_exitprocs+0x134>
	  else if ((args->_is_cxa & i) == 0)
 401aa10:	90c04117 	ldw	r3,260(r18)
 401aa14:	e0bffb17 	ldw	r2,-20(fp)
 401aa18:	1884703a 	and	r2,r3,r2
 401aa1c:	1000081e 	bne	r2,zero,401aa40 <__call_exitprocs+0x11c>
	    (*((void (*)(int, void *)) fn))(code, args->_fnargs[n]);
 401aa20:	880490ba 	slli	r2,r17,2
 401aa24:	9085883a 	add	r2,r18,r2
 401aa28:	10c00017 	ldw	r3,0(r2)
 401aa2c:	e0bffa17 	ldw	r2,-24(fp)
 401aa30:	180b883a 	mov	r5,r3
 401aa34:	e13ff817 	ldw	r4,-32(fp)
 401aa38:	103ee83a 	callr	r2
 401aa3c:	00000606 	br	401aa58 <__call_exitprocs+0x134>
	  else
	    (*((void (*)(void *)) fn))(args->_fnargs[n]);
 401aa40:	880490ba 	slli	r2,r17,2
 401aa44:	9085883a 	add	r2,r18,r2
 401aa48:	10c00017 	ldw	r3,0(r2)
 401aa4c:	e0bffa17 	ldw	r2,-24(fp)
 401aa50:	1809883a 	mov	r4,r3
 401aa54:	103ee83a 	callr	r2

	  /* The function we called call atexit and registered another
	     function (or functions).  Call these new functions before
	     continuing with the already registered functions.  */
	  if (ind != p->_ind || *lastp != p)
 401aa58:	80800117 	ldw	r2,4(r16)
 401aa5c:	e0fff917 	ldw	r3,-28(fp)
 401aa60:	18bfb91e 	bne	r3,r2,401a948 <__call_exitprocs+0x24>
 401aa64:	e0bffc17 	ldw	r2,-16(fp)
 401aa68:	10800017 	ldw	r2,0(r2)
 401aa6c:	80800426 	beq	r16,r2,401aa80 <__call_exitprocs+0x15c>
	    goto restart;
 401aa70:	003fb506 	br	401a948 <__call_exitprocs+0x24>
	    continue;
 401aa74:	0001883a 	nop
 401aa78:	00000106 	br	401aa80 <__call_exitprocs+0x15c>
	    continue;
 401aa7c:	0001883a 	nop
      for (n = p->_ind - 1; n >= 0; n--)
 401aa80:	8c7fffc4 	addi	r17,r17,-1
 401aa84:	883fba0e 	bge	r17,zero,401a970 <__call_exitprocs+0x4c>
	}

#if !defined (_ATEXIT_DYNAMIC_ALLOC) || !defined (MALLOC_PROVIDED)
      break;
 401aa88:	0001883a 	nop
    }
#ifndef __SINGLE_THREAD__
  __lock_release_recursive(__atexit_recursive_mutex);
#endif

}
 401aa8c:	0001883a 	nop
 401aa90:	e6fffd04 	addi	sp,fp,-12
 401aa94:	dfc00417 	ldw	ra,16(sp)
 401aa98:	df000317 	ldw	fp,12(sp)
 401aa9c:	dc800217 	ldw	r18,8(sp)
 401aaa0:	dc400117 	ldw	r17,4(sp)
 401aaa4:	dc000017 	ldw	r16,0(sp)
 401aaa8:	dec00504 	addi	sp,sp,20
 401aaac:	f800283a 	ret
