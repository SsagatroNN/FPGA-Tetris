
masterEsp32.elf:     file format elf32-littlenios2
masterEsp32.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x04000364

Program Header:
    LOAD off    0x00001000 vaddr 0x04000000 paddr 0x04000000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x04000020 paddr 0x04000020 align 2**12
         filesz 0x0001b31c memsz 0x0001b31c flags r-x
    LOAD off    0x0001c33c vaddr 0x0401b33c paddr 0x0401cf44 align 2**12
         filesz 0x00001c08 memsz 0x00001c08 flags rw-
    LOAD off    0x0001eb4c vaddr 0x0401eb4c paddr 0x0401eb4c align 2**12
         filesz 0x00000000 memsz 0x00800274 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  04000000  04000000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000344  04000020  04000020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0001a864  04000364  04000364  00001364  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00000774  0401abc8  0401abc8  0001bbc8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001c08  0401b33c  0401cf44  0001c33c  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          008002fa  0401eb4c  0401eb4c  0001eb4c  2**2
                  ALLOC, SMALL_DATA
  6 .dram         00000000  0481edc0  0481edc0  0001df44  2**0
                  CONTENTS
  7 .comment      0000002c  00000000  00000000  0001df44  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00001258  00000000  00000000  0001df70  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   00052e6d  00000000  00000000  0001f1c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 0000fed9  00000000  00000000  00072035  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00018cab  00000000  00000000  00081f0e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00003fec  00000000  00000000  0009abbc  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00006668  00000000  00000000  0009eba8  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    0000af74  00000000  00000000  000a5210  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000010  00000000  00000000  000b0184  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00001650  00000000  00000000  000b0198  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000003  00000000  00000000  000b677e  2**0
                  CONTENTS, READONLY
 18 .cpu          00000005  00000000  00000000  000b6781  2**0
                  CONTENTS, READONLY
 19 .qsys         00000001  00000000  00000000  000b6786  2**0
                  CONTENTS, READONLY
 20 .simulation_enabled 00000001  00000000  00000000  000b6787  2**0
                  CONTENTS, READONLY
 21 .stderr_dev   0000000b  00000000  00000000  000b6788  2**0
                  CONTENTS, READONLY
 22 .stdin_dev    0000000b  00000000  00000000  000b6793  2**0
                  CONTENTS, READONLY
 23 .stdout_dev   0000000b  00000000  00000000  000b679e  2**0
                  CONTENTS, READONLY
 24 .sopc_system_name 0000000d  00000000  00000000  000b67a9  2**0
                  CONTENTS, READONLY
 25 .quartus_project_dir 0000003d  00000000  00000000  000b67b6  2**0
                  CONTENTS, READONLY
 26 .jdi          00004d09  00000000  00000000  000b67f3  2**0
                  CONTENTS, READONLY
 27 .sopcinfo     0006f179  00000000  00000000  000bb4fc  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
04000000 l    d  .entry	00000000 .entry
04000020 l    d  .exceptions	00000000 .exceptions
04000364 l    d  .text	00000000 .text
0401abc8 l    d  .rodata	00000000 .rodata
0401b33c l    d  .rwdata	00000000 .rwdata
0401eb4c l    d  .bss	00000000 .bss
0481edc0 l    d  .dram	00000000 .dram
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../masterEsp32_bsp//obj/HAL/src/crt0.o
0400039c l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 obj/default/FreeRTOS/portable/GCC/NiosII/port_asm.o
04000020 l       .exceptions	00000000 save_context
0400009c l       .exceptions	00000000 save_sp_to_pxCurrentTCB
04000104 l       .exceptions	00000000 irq_test_user
0400016c l       .exceptions	00000000 restore_context
04000124 l       .exceptions	00000000 soft_exceptions
04000134 l       .exceptions	00000000 call_scheduler
04000148 l       .exceptions	00000000 exceptions_unknown_user
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 croutine.c
00000000 l    df *ABS*	00000000 event_groups.c
04000a30 l     F .text	00000070 prvTestWaitCondition
00000000 l    df *ABS*	00000000 list.c
00000000 l    df *ABS*	00000000 port.c
04000d30 l     F .text	0000002c prvReadGp
04000e94 l     F .text	00000090 prvSetupTimerInterrupt
00000000 l    df *ABS*	00000000 heap_1.c
0401ebd0 l     O .bss	00800000 ucHeap
0401eb4c l     O .bss	00000004 xNextFreeByte
0401eb50 l     O .bss	00000004 pucAlignedHeap.2586
00000000 l    df *ABS*	00000000 queue.c
0400157c l     F .text	00000084 prvInitialiseNewQueue
04001600 l     F .text	00000060 prvInitialiseMutex
04002438 l     F .text	0000018c prvCopyDataToQueue
040027ec l     F .text	00000058 prvIsQueueFull
04002660 l     F .text	000000f4 prvUnlockQueue
040025c4 l     F .text	0000009c prvCopyDataFromQueue
04002754 l     F .text	00000050 prvIsQueueEmpty
040023e8 l     F .text	00000050 prvGetDisinheritPriorityAfterTimeout
00000000 l    df *ABS*	00000000 stream_buffer.c
04003734 l     F .text	00000080 prvInitialiseNewStreamBuffer
040036c0 l     F .text	00000074 prvBytesInBuffer
04002e94 l     F .text	000000d0 prvWriteMessageToBuffer
04003500 l     F .text	000000e0 prvWriteBytesToBuffer
0400323c l     F .text	000000e0 prvReadMessageFromBuffer
040035e0 l     F .text	000000e0 prvReadBytesFromBuffer
00000000 l    df *ABS*	00000000 tasks.c
0481ebd0 l     O .bss	00000064 pxReadyTasksLists
0481ec34 l     O .bss	00000014 xDelayedTaskList1
0481ec48 l     O .bss	00000014 xDelayedTaskList2
0401eb58 l     O .bss	00000004 pxDelayedTaskList
0401eb5c l     O .bss	00000004 pxOverflowDelayedTaskList
0481ec5c l     O .bss	00000014 xPendingReadyList
0481ec70 l     O .bss	00000014 xTasksWaitingTermination
0401eb60 l     O .bss	00000004 uxDeletedTasksWaitingCleanUp
0481ec84 l     O .bss	00000014 xSuspendedTaskList
0401eb64 l     O .bss	00000004 uxCurrentNumberOfTasks
0401eb68 l     O .bss	00000004 xTickCount
0401eb6c l     O .bss	00000004 uxTopReadyPriority
0401eb70 l     O .bss	00000004 xSchedulerRunning
0401eb74 l     O .bss	00000004 xPendedTicks
0401eb78 l     O .bss	00000004 xYieldPending
0401eb7c l     O .bss	00000004 xNumOfOverflows
0401eb80 l     O .bss	00000004 uxTaskNumber
0401eb84 l     O .bss	00000004 xNextTaskUnblockTime
0401eb88 l     O .bss	00000004 xIdleTaskHandle
0401eb8c l     O .bss	00000004 uxSchedulerSuspended
040038a8 l     F .text	000001ac prvInitialiseNewTask
04003a54 l     F .text	000001b8 prvAddNewTaskToReadyList
04005700 l     F .text	000000c0 prvInitialiseTaskLists
04005948 l     F .text	00000048 prvResetNextTaskUnblockTime
04005904 l     F .text	00000044 prvDeleteTCB
04006e3c l     F .text	00000144 prvAddCurrentTaskToDelayedList
0400427c l     F .text	0000006c prvTaskIsTaskSuspended
040056e4 l     F .text	0000001c prvIdleTask
040057c0 l     F .text	00000080 prvCheckTasksWaitingTermination
04005840 l     F .text	00000064 prvTaskCheckFreeStackSpace
00000000 l    df *ABS*	00000000 timers.c
00000000 l    df *ABS*	00000000 float2_functionality.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 vfprintf.c
04007c28 l     F .text	000000f0 __sbprintf
04009ec8 l     F .text	00000208 cvt
0400a0d0 l     F .text	00000148 exponent
0401ac70 l     O .rodata	00000010 blanks.5176
0401ac80 l     O .rodata	00000010 zeroes.5177
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 dtoa.c
0400a3b8 l     F .text	000003b4 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
0400c770 l     F .text	000000f0 std
0400c860 l     F .text	0000003c stdin_init
0400c89c l     F .text	0000003c stdout_init
0400c8d8 l     F .text	0000003c stderr_init
0401eb94 l     O .bss	00000004 __sfp_recursive_mutex
0401eb98 l     O .bss	00000004 __sinit_recursive_mutex
0400cd10 l     F .text	00000024 __fp_lock
0400cd34 l     F .text	00000024 __fp_unlock
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 impure.c
0401b33c l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 localeconv.c
0400dc90 l     F .text	00000024 __get_global_locale
0400dcb4 l     F .text	00000028 __get_current_locale
0400dcdc l     F .text	00000028 __get_C_locale
00000000 l    df *ABS*	00000000 locale.c
0400ddb8 l     F .text	00000024 __get_global_locale
0400dddc l     F .text	00000028 __get_current_locale
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
0400e18c l     F .text	000003c4 malloc_extend_top
00000000 l    df *ABS*	00000000 mbtowc_r.c
0400f0b8 l     F .text	00000024 __get_global_locale
0400f0dc l     F .text	00000028 __get_current_locale
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mprec.c
0401aeb0 l     O .rodata	0000000c p05.3991
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 vfprintf.c
04012264 l     F .text	000000f0 __sbprintf
0401af08 l     O .rodata	00000010 blanks.5153
0401af18 l     O .rodata	00000010 zeroes.5154
00000000 l    df *ABS*	00000000 wctomb_r.c
04013664 l     F .text	00000024 __get_global_locale
04013688 l     F .text	00000028 __get_current_locale
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 assert.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 ctype_.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fiprintf.c
00000000 l    df *ABS*	00000000 fputwc.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 vfiprintfr_1.c
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 wcrtomb.c
040142ec l     F .text	00000024 __get_global_locale
04014310 l     F .text	00000028 __get_current_locale
00000000 l    df *ABS*	00000000 abort.c
00000000 l    df *ABS*	00000000 signal.c
00000000 l    df *ABS*	00000000 signalr.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 divdf3.c
00000000 l    df *ABS*	00000000 eqdf2.c
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 ledf2.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 subdf3.c
00000000 l    df *ABS*	00000000 unorddf2.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 floatunsidf.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 alt_close.c
04017db4 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_dev.c
04017ecc l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_exit.c
00000000 l    df *ABS*	00000000 alt_fstat.c
04017f30 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_getpid.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_isatty.c
040182e0 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_kill.c
040183cc l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_load.c
04018534 l     F .text	00000068 alt_load_section
00000000 l    df *ABS*	00000000 alt_lseek.c
04018620 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
00000000 l    df *ABS*	00000000 alt_read.c
04018800 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
0401cf38 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_write.c
04018a6c l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_sys_init.c
04018bac l     F .text	00000034 alt_dev_reg
0401be7c l     O .rwdata	00001060 jtag_uart_0
0401cedc l     O .rwdata	0000002c accelerometer_spi
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
04018eb0 l     F .text	0000020c altera_avalon_jtag_uart_irq
040190bc l     F .text	000000a0 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
04019700 l     F .text	0000007c alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_up_avalon_accelerometer_spi.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
04019d20 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
0401a014 l     F .text	000000d4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_open.c
0401a164 l     F .text	0000003c alt_get_errno
0401a1a0 l     F .text	000000dc alt_file_locked
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
0401ebcc l     O .bss	00000004 __atexit_recursive_mutex
0401ebc0 g     O .bss	00000004 alt_instruction_exception_handler
04010e90 g     F .text	000000b4 _mprec_log10
04011008 g     F .text	00000124 __any_on
04013fb0 g     F .text	00000060 _isatty_r
0401ae88 g     O .rodata	00000028 __mprec_tinytens
0401873c g     F .text	0000007c alt_main
040079e4 g     F .text	00000118 _puts_r
0481ecc0 g     O .bss	00000100 alt_irq
04014010 g     F .text	00000070 _lseek_r
0400015c g       .exceptions	00000000 restore_sp_from_pxCurrentTCB
04004f70 g     F .text	000000bc vTaskPlaceOnUnorderedEventList
0400116c g     F .text	0000002c xPortGetFreeHeapSize
04000788 g     F .text	0000003c xEventGroupGetBitsFromISR
0401cf44 g       *ABS*	00000000 __flash_rwdata_start
04016804 g     F .text	00000080 .hidden __eqdf2
0481edc0 g       *ABS*	00000000 __alt_heap_start
04003e4c g     F .text	00000058 uxTaskPriorityGet
040148dc g     F .text	00000068 _kill_r
0400797c g     F .text	00000068 printf
04014338 g     F .text	000000b4 _wcrtomb_r
04014560 g     F .text	000000b4 _signal_r
04011f00 g     F .text	000000a0 __sseek
0400cbdc g     F .text	000000b4 __sinit
04014144 g     F .text	00000168 __swbuf_r
0400de04 g     F .text	00000080 _setlocale_r
0400c914 g     F .text	000000bc __sfmoreglue
04002f64 g     F .text	00000160 xStreamBufferReceive
040187dc g     F .text	00000024 __malloc_unlock
04003d00 g     F .text	000000f0 xTaskDelayUntil
040003f4 g     F .text	00000184 xEventGroupSync
0400f3ac g     F .text	00000208 memmove
04006d90 g     F .text	000000ac ulTaskGenericNotifyValueClear
04005f7c g     F .text	00000054 vTaskEnterCritical
0400cba8 g     F .text	00000034 _cleanup
04001a0c g     F .text	00000108 xQueueGenericSendFromISR
04004a64 g     F .text	00000040 pcTaskGetName
0400f5b4 g     F .text	00000124 _Balloc
04002aec g     F .text	000000a4 xStreamBufferSpacesAvailable
04016884 g     F .text	000000f0 .hidden __gtdf2
0401a588 g     F .text	00000024 altera_nios2_gen2_irq_init
040029cc g     F .text	000000b4 xStreamBufferReset
04000000 g     F .entry	0000000c __reset
040016bc g     F .text	00000090 xQueueGiveMutexRecursive
0400dd04 g     F .text	00000050 __localeconv_l
04006f80 g     F .text	000000e8 convertData
0401eb54 g     O .bss	00000004 pxCurrentTCB
04019950 g     F .text	000000d4 alt_up_accelerometer_spi_read_x_axis
04000020 g       *ABS*	00000000 __flash_exceptions_start
04013f48 g     F .text	00000068 _fstat_r
0401ebac g     O .bss	00000004 errno
04011e1c g     F .text	00000030 __seofread
04002da0 g     F .text	000000f4 xStreamBufferSendFromISR
0401ebb8 g     O .bss	00000004 alt_argv
04024f08 g       *ABS*	00000000 _gp
04003ef0 g     F .text	00000268 vTaskPrioritySet
04018028 g     F .text	00000020 getpid
04005598 g     F .text	0000003c vTaskInternalSetTimeOutState
04000578 g     F .text	000001a8 xEventGroupWaitBits
04000f68 g     F .text	000000d4 _alt_ic_isr_register
0401bcfc g     O .rwdata	00000180 alt_fd_list
04000e3c g     F .text	00000038 xPortStartScheduler
040046a8 g     F .text	00000048 vTaskEndScheduler
04019ecc g     F .text	00000090 alt_find_dev
040075cc g     F .text	00000188 memcpy
04004f20 g     F .text	00000050 vTaskPlaceOnEventList
040052fc g     F .text	00000250 vTaskRemoveFromUnorderedEventList
0400cb64 g     F .text	00000044 _cleanup_r
04017c14 g     F .text	000000bc .hidden __floatsidf
0401a0e8 g     F .text	0000007c alt_io_redirect
04016974 g     F .text	000000f0 .hidden __ltdf2
04002264 g     F .text	0000007c xQueuePeekFromISR
0401abc8 g       *ABS*	00000000 __DTOR_END__
04007afc g     F .text	00000038 puts
04019f7c g     F .text	00000098 alt_exception_cause_generated_bad_addr
04001124 g     F .text	00000024 vPortFree
04010d74 g     F .text	0000011c __ratio
04012354 g     F .text	00000050 __vfiprintf_internal
04001dac g     F .text	00000210 xQueueSemaphoreTake
040192b8 g     F .text	00000220 altera_avalon_jtag_uart_read
04007918 g     F .text	00000064 _printf_r
040074e4 g     F .text	00000064 .hidden __udivsi3
0401831c g     F .text	000000b0 isatty
04014614 g     F .text	00000104 _raise_r
04013848 g     F .text	00000084 __assert_func
0401ad98 g     O .rodata	000000c8 __mprec_tens
040058a4 g     F .text	00000060 uxTaskGetStackHighWaterMark
04000b34 g     F .text	0000008c vListInsertEnd
0401eba0 g     O .bss	00000004 __malloc_top_pad
040060b0 g     F .text	00000104 ulTaskGenericNotifyTake
04014944 g     F .text	00000034 _getpid_r
040003a0 g     F .text	00000054 xEventGroupCreate
0400dd54 g     F .text	00000034 _localeconv_r
0400fc4c g     F .text	00000084 __i2b
0400d4f4 g     F .text	000005e8 __sfvwrite_r
04014718 g     F .text	000000e4 __sigtramp_r
04011d20 g     F .text	00000060 _sbrk_r
040009b8 g     F .text	0000003c vEventGroupSetBitsCallback
04004470 g     F .text	000001a4 xTaskResumeFromISR
04014080 g     F .text	00000070 _read_r
04000b08 g     F .text	0000002c vListInitialiseItem
0401cf2c g     O .rwdata	00000004 alt_max_fd
04000f24 g     F .text	00000044 vPortSysTickHandler
04013a60 g     F .text	0000012c _fclose_r
04001c04 g     F .text	000001a8 xQueueReceive
0400c71c g     F .text	00000054 fflush
0401eba4 g     O .bss	00000004 __malloc_max_sbrked_mem
04003ea4 g     F .text	0000004c uxTaskPriorityGetFromISR
04015558 g     F .text	00000978 .hidden __adddf3
04010914 g     F .text	000001fc __b2d
04014f94 g     F .text	000005c4 .hidden __umoddi3
0401865c g     F .text	000000e0 lseek
0401cf10 g     O .rwdata	00000004 _global_impure_ptr
040007c4 g     F .text	00000180 xEventGroupSetBits
0401112c g     F .text	00000bf4 _realloc_r
0481edc0 g       *ABS*	00000000 __bss_end
040181f8 g     F .text	000000e8 alt_iic_isr_register
0401a480 g     F .text	00000108 alt_tick
04014978 g     F .text	0000061c .hidden __udivdi3
04013e58 g     F .text	00000088 _fputwc_r
0401ae60 g     O .rodata	00000028 __mprec_bigtens
0400f91c g     F .text	000001b8 __s2b
040144a4 g     F .text	00000020 abort
04017cd0 g     F .text	00000090 .hidden __floatunsidf
04010458 g     F .text	00000104 __mcmp
0400103c g     F .text	000000e8 pvPortMalloc
0400cd58 g     F .text	00000040 __fp_lock_all
040181ac g     F .text	0000004c alt_ic_irq_enabled
040023ac g     F .text	0000003c vQueueDelete
04000e74 g     F .text	00000020 vPortEndScheduler
04000aa0 g     F .text	00000068 vListInitialise
0400331c g     F .text	00000058 xStreamBufferIsEmpty
0401a3dc g     F .text	000000a4 alt_alarm_stop
0401ebb0 g     O .bss	00000004 alt_irq_active
0400023c g     F .exceptions	000000c8 alt_irq_handler
0401bcd4 g     O .rwdata	00000028 alt_dev_null
040049f0 g     F .text	00000028 xTaskGetTickCount
04001858 g     F .text	000001b4 xQueueGenericSend
04002bd0 g     F .text	000001d0 xStreamBufferSend
04003478 g     F .text	00000088 xStreamBufferReceiveCompletedFromISR
04019d00 g     F .text	00000020 alt_dcache_flush_all
0400fad4 g     F .text	0000008c __hi0bits
04006a38 g     F .text	000002cc vTaskGenericNotifyGiveFromISR
04017b94 g     F .text	00000080 .hidden __fixdfsi
040030c4 g     F .text	00000098 xStreamBufferNextMessageLengthBytes
04005bc0 g     F .text	000001b8 xTaskPriorityDisinherit
0401cf44 g       *ABS*	00000000 __ram_rwdata_end
0401cf24 g     O .rwdata	00000008 alt_dev_list
0401eb90 g     O .bss	00000004 score
04018aa8 g     F .text	00000104 write
0400502c g     F .text	000002d0 xTaskRemoveFromEventList
0401b33c g       *ABS*	00000000 __ram_rodata_end
040070dc g     F .text	00000118 writeScore
04017f6c g     F .text	000000bc fstat
04000720 g     F .text	00000068 xEventGroupClearBits
04018408 g     F .text	0000012c kill
04016974 g     F .text	000000f0 .hidden __ledf2
04001fbc g     F .text	000001b0 xQueuePeek
040100cc g     F .text	00000170 __pow5mult
040123a4 g     F .text	000012c0 ___vfiprintf_internal_r
04007548 g     F .text	0000005c .hidden __umodsi3
0481edc0 g       *ABS*	00000000 end
0400315c g     F .text	000000e0 xStreamBufferReceiveFromISR
04003c0c g     F .text	000000f4 vTaskDelete
04007230 g     F .text	00000048 getScore
04018df0 g     F .text	000000c0 altera_avalon_jtag_uart_init
04000304 g     F .exceptions	00000060 alt_instruction_exception_entry
04006078 g     F .text	00000038 pvTaskIncrementMutexHeldCount
0401abc8 g       *ABS*	00000000 __CTOR_LIST__
08000000 g       *ABS*	00000000 __alt_stack_pointer
0401977c g     F .text	00000084 alt_avalon_timer_sc_init
04017d60 g     F .text	00000054 .hidden __clzsi2
040194d8 g     F .text	00000228 altera_avalon_jtag_uart_write
0400cc90 g     F .text	00000020 __sfp_lock_acquire
0400f1f0 g     F .text	000001bc memchr
04007d68 g     F .text	00002160 ___vfprintf_internal_r
04007278 g     F .text	000000c8 task1
040055d4 g     F .text	000000e8 xTaskCheckForTimeOut
0400cdd8 g     F .text	00000558 _free_r
040059b8 g     F .text	00000208 xTaskPriorityInherit
0401af6c g     O .rodata	00000180 _ctype_b
0400de84 g     F .text	00000038 __locale_mb_cur_max
0401aa3c g     F .text	0000018c __call_exitprocs
040061b4 g     F .text	00000164 xTaskGenericNotifyWait
04002968 g     F .text	00000064 vStreamBufferDelete
0401cf18 g     O .rwdata	00000004 __malloc_sbrk_base
04000364 g     F .text	0000003c _start
04007340 g     F .text	00000034 task2
0401ebc4 g     O .bss	00000004 _alt_tick_rate
040046f0 g     F .text	0000002c vTaskSuspendAll
04003374 g     F .text	0000007c xStreamBufferIsFull
04004a18 g     F .text	0000002c xTaskGetTickCountFromISR
0401023c g     F .text	0000021c __lshift
0401ebc8 g     O .bss	00000004 _alt_nticks
04014834 g     F .text	00000040 signal
0401883c g     F .text	00000108 read
04018c1c g     F .text	00000070 alt_sys_init
0401983c g     F .text	00000044 alt_up_accelerometer_spi_read_address_register
04000c98 g     F .text	00000098 uxListRemove
0401a924 g     F .text	00000118 __register_exitproc
04002894 g     F .text	000000d4 xStreamBufferGenericCreate
0400fcd0 g     F .text	000003fc __multiply
0401915c g     F .text	00000068 altera_avalon_jtag_uart_close
040075a4 g     F .text	00000028 .hidden __mulsi3
0401b33c g       *ABS*	00000000 __ram_rwdata_start
0401abc8 g       *ABS*	00000000 __ram_rodata_start
0481ec98 g     O .bss	00000028 __malloc_current_mallinfo
040042e8 g     F .text	00000188 vTaskResume
04010b10 g     F .text	00000264 __d2b
04004e30 g     F .text	000000f0 vTaskSwitchContext
04000000 g       *ABS*	00000000 __alt_mem_dram
04018c8c g     F .text	00000060 altera_avalon_jtag_uart_read_fd
0401a6b4 g     F .text	000000b8 alt_get_fd
04019a24 g     F .text	000000d4 alt_up_accelerometer_spi_read_y_axis
04007068 g     F .text	00000074 reversBits
040137e8 g     F .text	00000060 _close_r
0401a7f0 g     F .text	00000134 memcmp
04018d4c g     F .text	00000050 altera_avalon_jtag_uart_close_fd
0481edc0 g       *ABS*	00000000 __alt_stack_base
04018d9c g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
0400a218 g     F .text	000001a0 __swsetup_r
04004158 g     F .text	00000124 vTaskSuspend
04015ed0 g     F .text	00000934 .hidden __divdf3
0400c9d0 g     F .text	00000194 __sfp
04010f44 g     F .text	000000c4 __copybits
04004aa4 g     F .text	00000050 xTaskCatchUpTicks
04004a44 g     F .text	00000020 uxTaskGetNumberOfTasks
0401b8cc g     O .rwdata	00000408 __malloc_av_
0400ccf0 g     F .text	00000020 __sinit_lock_release
04016a64 g     F .text	000007a8 .hidden __muldf3
04011d80 g     F .text	0000009c __sread
0401a5ac g     F .text	00000108 alt_find_file
04019d5c g     F .text	000000a8 alt_dev_llist_insert
040187b8 g     F .text	00000024 __malloc_lock
040189b4 g     F .text	000000b8 sbrk
0400174c g     F .text	0000009c xQueueTakeMutexRecursive
0400c694 g     F .text	00000088 _fflush_r
04000944 g     F .text	00000074 vEventGroupDelete
040138fc g     F .text	00000164 _calloc_r
04006318 g     F .text	00000348 xTaskGenericNotify
0401eb4c g       *ABS*	00000000 __bss_start
04007754 g     F .text	000001c4 memset
04007374 g     F .text	0000007c main
0401ebbc g     O .bss	00000004 alt_envp
0401eba8 g     O .bss	00000004 __malloc_max_total_mem
04018cec g     F .text	00000060 altera_avalon_jtag_uart_write_fd
040142ac g     F .text	00000040 __swbuf
04000bc0 g     F .text	000000d8 vListInsert
04011fa0 g     F .text	00000054 __sclose
08000000 g       *ABS*	00000000 __alt_heap_limit
04013b8c g     F .text	00000038 fclose
0400a76c g     F .text	00001c2c _dtoa_r
0400e550 g     F .text	00000b68 _malloc_r
04013700 g     F .text	00000078 __ascii_wctomb
0401cf30 g     O .rwdata	00000004 alt_errno
04013bc4 g     F .text	0000005c _fiprintf_r
04014874 g     F .text	00000030 _init_signal
0400dadc g     F .text	000000d8 _fwalk
0400216c g     F .text	000000f8 xQueueReceiveFromISR
0400f104 g     F .text	00000058 _mbtowc_r
04005990 g     F .text	00000028 xTaskGetCurrentTaskHandle
040073f0 g     F .text	00000080 .hidden __divsi3
040013d8 g     F .text	000001a4 xQueueGenericCreate
0400d330 g     F .text	000001c4 _malloc_trim_r
0401abc8 g       *ABS*	00000000 __CTOR_END__
04011ff4 g     F .text	00000140 strcmp
040017e8 g     F .text	00000070 xQueueCreateCountingSemaphore
0401abc8 g       *ABS*	00000000 __flash_rodata_start
0401abc8 g       *ABS*	00000000 __DTOR_LIST__
04002a80 g     F .text	0000006c xStreamBufferSetTriggerLevel
04006660 g     F .text	000003d8 xTaskGenericNotifyFromISR
04016804 g     F .text	00000080 .hidden __nedf2
04018be0 g     F .text	0000003c alt_irq_init
04018944 g     F .text	00000070 alt_release_fd
0400471c g     F .text	000002d4 xTaskResumeAll
0401cf08 g     O .rwdata	00000004 uxTopUsedPriority
04002320 g     F .text	00000054 uxQueueSpacesAvailable
0401b1f0 g     O .rodata	00000100 .hidden __clz_tab
04004614 g     F .text	00000094 vTaskStartScheduler
0401eb9c g     O .bss	00000004 _PathLocale
0401a76c g     F .text	0000003c atexit
04013778 g     F .text	00000070 _write_r
0400debc g     F .text	00000040 setlocale
04002844 g     F .text	00000050 xQueueIsQueueFullFromISR
0401cf0c g     O .rwdata	00000004 _impure_ptr
0401ebb4 g     O .bss	00000004 alt_argc
0400c398 g     F .text	000002fc __sflush_r
04019e68 g     F .text	00000064 _do_dtors
040071f4 g     F .text	0000003c sendReading
04000020 g       .exceptions	00000000 alt_irq_entry
0400f15c g     F .text	00000094 __ascii_mbtowc
04010850 g     F .text	000000c4 __ulp
0400cd98 g     F .text	00000040 __fp_unlock_all
040056bc g     F .text	00000028 vTaskMissedYield
0401cf1c g     O .rwdata	00000008 alt_fs_list
040022e0 g     F .text	00000040 uxQueueMessagesWaiting
04004af4 g     F .text	0000033c xTaskIncrementTick
04000020 g       *ABS*	00000000 __ram_exceptions_start
04019800 g     F .text	0000003c alt_up_accelerometer_spi_open_dev
0400dd88 g     F .text	00000030 localeconv
0400e0a4 g     F .text	000000e8 __swhatbuf_r
04018048 g     F .text	00000050 alt_ic_isr_register
04001198 g     F .text	00000240 xQueueGenericReset
0401cf44 g       *ABS*	00000000 _edata
0481edc0 g       *ABS*	00000000 _end
04013c80 g     F .text	000001d8 __fputwc
04000364 g       *ABS*	00000000 __ram_exceptions_end
040191c4 g     F .text	000000f4 altera_avalon_jtag_uart_ioctl
040037b4 g     F .text	000000f4 xTaskCreate
04001148 g     F .text	00000024 vPortInitialiseBlocks
04006d04 g     F .text	0000008c xTaskGenericNotifyStateClear
04018120 g     F .text	0000008c alt_ic_irq_disable
04011e4c g     F .text	000000b4 __swrite
0401cf14 g     O .rwdata	00000004 __malloc_trim_threshold
0401a7a8 g     F .text	00000048 exit
04013c20 g     F .text	00000060 fiprintf
040140f0 g     F .text	00000054 _vfiprintf_r
0400dbb4 g     F .text	000000dc _fwalk_reent
0401055c g     F .text	000002f4 __mdiff
04007470 g     F .text	00000074 .hidden __modsi3
04003df0 g     F .text	0000005c vTaskDelay
04019af8 g     F .text	000000d4 alt_up_accelerometer_spi_read_z_axis
08000000 g       *ABS*	00000000 __alt_data_end
04000020 g     F .exceptions	00000000 alt_exception
0400ccb0 g     F .text	00000020 __sfp_lock_release
0401b0ec g     O .rodata	00000101 _ctype_
04005d78 g     F .text	00000204 vTaskPriorityDisinheritAfterTimeout
04017b40 g     F .text	00000054 .hidden __unorddf2
04017ef8 g     F .text	00000038 _exit
04019bcc g     F .text	00000134 alt_alarm_start
04019880 g     F .text	00000068 alt_up_accelerometer_spi_read
040198e8 g     F .text	00000068 alt_up_accelerometer_spi_write
0400defc g     F .text	000001a8 __smakebuf_r
04005fd0 g     F .text	00000064 vTaskExitCritical
04007b34 g     F .text	000000f4 strlen
04000d5c g     F .text	000000e0 pxPortInitialiseStack
040144c4 g     F .text	0000009c _init_signal_r
0401a27c g     F .text	00000160 open
04016884 g     F .text	000000f0 .hidden __gedf2
040138cc g     F .text	00000030 __assert
04012134 g     F .text	00000130 __sprint_r
04019f5c g     F .text	00000020 alt_icache_flush_all
0400554c g     F .text	0000004c vTaskSetTimeOutState
0401cf34 g     O .rwdata	00000004 alt_priority_mask
04018098 g     F .text	00000088 alt_ic_irq_enable
04007d18 g     F .text	00000050 __vfprintf_internal
040136b0 g     F .text	00000050 _wctomb_r
04002374 g     F .text	00000038 uxQueueMessagesWaitingFromISR
040027a4 g     F .text	00000048 xQueueIsQueueEmptyFromISR
04002b90 g     F .text	00000040 xStreamBufferBytesAvailable
0401720c g     F .text	00000934 .hidden __subdf3
0400fb60 g     F .text	000000ec __lo0bits
0401cf3c g     O .rwdata	00000008 alt_alarm_list
04019e04 g     F .text	00000064 _do_ctors
040148a4 g     F .text	00000038 __sigtramp
04006034 g     F .text	00000044 uxTaskResetEventItemValue
040143ec g     F .text	000000b8 wcrtomb
04001660 g     F .text	0000005c xQueueCreateMutex
04017df0 g     F .text	000000dc close
0401b760 g     O .rwdata	0000016c __global_locale
0401859c g     F .text	00000084 alt_load
040009f4 g     F .text	0000003c vEventGroupClearBitsCallback
040033f0 g     F .text	00000088 xStreamBufferSendCompletedFromISR
04001b14 g     F .text	000000f0 xQueueGiveFromISR
04013ee0 g     F .text	00000068 fputwc
040147fc g     F .text	00000038 raise
0400ccd0 g     F .text	00000020 __sinit_lock_acquire
0400f74c g     F .text	000001d0 __multadd
0400f6d8 g     F .text	00000074 _Bfree



Disassembly of section .entry:

04000000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
 4000000:	00410034 	movhi	at,1024
    ori r1, r1, %lo(_start)
 4000004:	0840d914 	ori	at,at,868
    jmp r1
 4000008:	0800683a 	jmp	at
	...

Disassembly of section .exceptions:

04000020 <alt_exception>:
# Entry point for exceptions.
.section .exceptions.entry.user, "xa"

# Save the entire context of a task.
save_context:
	addi	sp,	sp, -116		# Create space on the stack.
 4000020:	deffe304 	addi	sp,sp,-116
	stw		ra, 0(sp)
 4000024:	dfc00015 	stw	ra,0(sp)
								# Leave a gap for muldiv 0
	stw		at, 8(sp)
 4000028:	d8400215 	stw	at,8(sp)
	stw		r2, 12(sp)
 400002c:	d8800315 	stw	r2,12(sp)
	stw		r3, 16(sp)
 4000030:	d8c00415 	stw	r3,16(sp)
	stw		r4, 20(sp)
 4000034:	d9000515 	stw	r4,20(sp)
	stw		r5, 24(sp)
 4000038:	d9400615 	stw	r5,24(sp)
	stw		r6, 28(sp)
 400003c:	d9800715 	stw	r6,28(sp)
	stw		r7, 32(sp)
 4000040:	d9c00815 	stw	r7,32(sp)
	stw		r8, 36(sp)
 4000044:	da000915 	stw	r8,36(sp)
	stw		r9, 40(sp)
 4000048:	da400a15 	stw	r9,40(sp)
	stw		r10, 44(sp)
 400004c:	da800b15 	stw	r10,44(sp)
	stw		r11, 48(sp)
 4000050:	dac00c15 	stw	r11,48(sp)
	stw		r12, 52(sp)
 4000054:	db000d15 	stw	r12,52(sp)
	stw		r13, 56(sp)
 4000058:	db400e15 	stw	r13,56(sp)
	stw		r14, 60(sp)
 400005c:	db800f15 	stw	r14,60(sp)
	stw		r15, 64(sp)
 4000060:	dbc01015 	stw	r15,64(sp)
	rdctl	r5, estatus 		# Save the eStatus
 4000064:	000b307a 	rdctl	r5,estatus
	stw		r5, 68(sp)
 4000068:	d9401115 	stw	r5,68(sp)
	addi	r15, ea, -4			# Instruction that caused exception
 400006c:	ebffff04 	addi	r15,ea,-4
	stw		r15, 72(sp)			# Save as EA
 4000070:	dbc01215 	stw	r15,72(sp)
	stw		r16, 76(sp)			# Save the remaining registers
 4000074:	dc001315 	stw	r16,76(sp)
	stw		r17, 80(sp)
 4000078:	dc401415 	stw	r17,80(sp)
	stw		r18, 84(sp)
 400007c:	dc801515 	stw	r18,84(sp)
	stw		r19, 88(sp)
 4000080:	dcc01615 	stw	r19,88(sp)
	stw		r20, 92(sp)
 4000084:	dd001715 	stw	r20,92(sp)
	stw		r21, 96(sp)
 4000088:	dd401815 	stw	r21,96(sp)
	stw		r22, 100(sp)
 400008c:	dd801915 	stw	r22,100(sp)
	stw		r23, 104(sp)
 4000090:	ddc01a15 	stw	r23,104(sp)
	stw		gp, 108(sp)
 4000094:	de801b15 	stw	gp,108(sp)
	stw		fp, 112(sp)
 4000098:	df001c15 	stw	fp,112(sp)

0400009c <save_sp_to_pxCurrentTCB>:
 400009c:	060100b4 	movhi	et,1026

save_sp_to_pxCurrentTCB:
	movia	et, pxCurrentTCB	# Load the address of the pxCurrentTCB pointer
 40000a0:	c63ad504 	addi	et,et,-5292
	ldw		et, (et)			# Load the value of the pxCurrentTCB pointer
 40000a4:	c6000017 	ldw	et,0(et)
	stw		sp, (et)			# Store the stack pointer into the top of the TCB
 40000a8:	c6c00015 	stw	sp,0(et)

	br		irq_test_user		# skip the section .exceptions.entry
 40000ac:	00001506 	br	4000104 <irq_test_user>

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
 40000b0:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
 40000b4:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
 40000b8:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
 40000bc:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
 40000c0:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
 40000c4:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
 40000c8:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
 40000cc:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
 40000d0:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
 40000d4:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
 40000d8:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
 40000dc:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
 40000e0:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
 40000e4:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
 40000e8:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
 40000ec:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
 40000f0:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
 40000f4:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
 40000f8:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
 40000fc:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 4000100:	dbc01215 	stw	r15,72(sp)

04000104 <irq_test_user>:
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
 4000104:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
 4000108:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
 400010c:	10000326 	beq	r2,zero,400011c <irq_test_user+0x18>
        beq   r4, zero, .Lnot_irq
 4000110:	20000226 	beq	r4,zero,400011c <irq_test_user+0x18>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
 4000114:	400023c0 	call	400023c <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
 4000118:	00001006 	br	400015c <restore_sp_from_pxCurrentTCB>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
 400011c:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
 4000120:	e8bfff17 	ldw	r2,-4(ea)

04000124 <soft_exceptions>:

	eret					# Return to address ea, loading eStatus into Status.

	.section .exceptions.soft, "xa"
soft_exceptions:
	movhi	r3, 0x003b				/* upper half of trap opcode */
 4000124:	00c00ef4 	movhi	r3,59
	ori		r3, r3, 0x683a			/* lower half of trap opcode */
 4000128:	18da0e94 	ori	r3,r3,26682
	beq		r2, r3, call_scheduler
 400012c:	10c00126 	beq	r2,r3,4000134 <call_scheduler>
	br		exceptions_unknown_user			# its something else
 4000130:	00000506 	br	4000148 <exceptions_unknown_user>

04000134 <call_scheduler>:

call_scheduler:
	stw		ea, 72(sp)						# EA is PC+4 so will skip over instruction causing exception
 4000134:	df401215 	stw	ea,72(sp)
 4000138:	03c10034 	movhi	r15,1024
	movia	r15, vTaskSwitchContext			# Pick the next context - use long call version in place of "call"
 400013c:	7bd38c04 	addi	r15,r15,20016
	callr	r15
 4000140:	783ee83a 	callr	r15
	br		restore_sp_from_pxCurrentTCB	# Switch in the task context and restore.
 4000144:	00000506 	br	400015c <restore_sp_from_pxCurrentTCB>

04000148 <exceptions_unknown_user>:
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
 4000148:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
 400014c:	40003040 	call	4000304 <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
 4000150:	1000021e 	bne	r2,zero,400015c <restore_sp_from_pxCurrentTCB>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
 4000154:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 4000158:	dbc01215 	stw	r15,72(sp)

0400015c <restore_sp_from_pxCurrentTCB>:
 400015c:	060100b4 	movhi	et,1026
	movia	et, pxCurrentTCB		# Load the address of the pxCurrentTCB pointer
 4000160:	c63ad504 	addi	et,et,-5292
	ldw		et, (et)				# Load the value of the pxCurrentTCB pointer
 4000164:	c6000017 	ldw	et,0(et)
	ldw		sp, (et)				# Load the stack pointer with the top value of the TCB
 4000168:	c6c00017 	ldw	sp,0(et)

0400016c <restore_context>:
	ldw		ra, 0(sp)		# Restore the registers.
 400016c:	dfc00017 	ldw	ra,0(sp)
	ldw		at, 8(sp)
 4000170:	d8400217 	ldw	at,8(sp)
	ldw		r2, 12(sp)
 4000174:	d8800317 	ldw	r2,12(sp)
	ldw		r3, 16(sp)
 4000178:	d8c00417 	ldw	r3,16(sp)
	ldw		r4, 20(sp)
 400017c:	d9000517 	ldw	r4,20(sp)
	ldw		r5, 24(sp)
 4000180:	d9400617 	ldw	r5,24(sp)
	ldw		r6, 28(sp)
 4000184:	d9800717 	ldw	r6,28(sp)
	ldw		r7, 32(sp)
 4000188:	d9c00817 	ldw	r7,32(sp)
	ldw		r8, 36(sp)
 400018c:	da000917 	ldw	r8,36(sp)
	ldw		r9, 40(sp)
 4000190:	da400a17 	ldw	r9,40(sp)
	ldw		r10, 44(sp)
 4000194:	da800b17 	ldw	r10,44(sp)
	ldw		r11, 48(sp)
 4000198:	dac00c17 	ldw	r11,48(sp)
	ldw		r12, 52(sp)
 400019c:	db000d17 	ldw	r12,52(sp)
	ldw		r13, 56(sp)
 40001a0:	db400e17 	ldw	r13,56(sp)
	ldw		r14, 60(sp)
 40001a4:	db800f17 	ldw	r14,60(sp)
	ldw		r15, 64(sp)
 40001a8:	dbc01017 	ldw	r15,64(sp)
	ldw		et, 68(sp)		# Load the eStatus
 40001ac:	de001117 	ldw	et,68(sp)
	wrctl	estatus, et 	# Write the eStatus
 40001b0:	c001707a 	wrctl	estatus,et
	ldw		ea, 72(sp)		# Load the Program Counter
 40001b4:	df401217 	ldw	ea,72(sp)
	ldw		r16, 76(sp)
 40001b8:	dc001317 	ldw	r16,76(sp)
	ldw		r17, 80(sp)
 40001bc:	dc401417 	ldw	r17,80(sp)
	ldw		r18, 84(sp)
 40001c0:	dc801517 	ldw	r18,84(sp)
	ldw		r19, 88(sp)
 40001c4:	dcc01617 	ldw	r19,88(sp)
	ldw		r20, 92(sp)
 40001c8:	dd001717 	ldw	r20,92(sp)
	ldw		r21, 96(sp)
 40001cc:	dd401817 	ldw	r21,96(sp)
	ldw		r22, 100(sp)
 40001d0:	dd801917 	ldw	r22,100(sp)
	ldw		r23, 104(sp)
 40001d4:	ddc01a17 	ldw	r23,104(sp)
	ldw		gp, 108(sp)
 40001d8:	de801b17 	ldw	gp,108(sp)
	ldw		fp, 112(sp)
 40001dc:	df001c17 	ldw	fp,112(sp)
	addi	sp,	sp, 116		# Release stack space
 40001e0:	dec01d04 	addi	sp,sp,116
	eret					# Return to address ea, loading eStatus into Status.
 40001e4:	ef80083a 	eret
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
 40001e8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
 40001ec:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
 40001f0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
 40001f4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
 40001f8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
 40001fc:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
 4000200:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
 4000204:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
 4000208:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
 400020c:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
 4000210:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
 4000214:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
 4000218:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
 400021c:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
 4000220:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
 4000224:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
 4000228:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
 400022c:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
 4000230:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
 4000234:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
 4000238:	ef80083a 	eret

0400023c <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
 400023c:	defff904 	addi	sp,sp,-28
 4000240:	dfc00615 	stw	ra,24(sp)
 4000244:	df000515 	stw	fp,20(sp)
 4000248:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
 400024c:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 4000250:	0005313a 	rdctl	r2,ipending
 4000254:	e0bffc15 	stw	r2,-16(fp)

  return active;
 4000258:	e0bffc17 	ldw	r2,-16(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
 400025c:	e0bfff15 	stw	r2,-4(fp)

  do
  {
    i = 0;
 4000260:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
 4000264:	00800044 	movi	r2,1
 4000268:	e0bffe15 	stw	r2,-8(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
 400026c:	e0ffff17 	ldw	r3,-4(fp)
 4000270:	e0bffe17 	ldw	r2,-8(fp)
 4000274:	1884703a 	and	r2,r3,r2
 4000278:	10001126 	beq	r2,zero,40002c0 <alt_irq_handler+0x84>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
 400027c:	e0bffd17 	ldw	r2,-12(fp)
 4000280:	100690fa 	slli	r3,r2,3
 4000284:	008120b4 	movhi	r2,1154
 4000288:	1885883a 	add	r2,r3,r2
 400028c:	10fb3017 	ldw	r3,-4928(r2)
 4000290:	e0bffd17 	ldw	r2,-12(fp)
 4000294:	100890fa 	slli	r4,r2,3
 4000298:	008120b4 	movhi	r2,1154
 400029c:	2085883a 	add	r2,r4,r2
 40002a0:	10bb3117 	ldw	r2,-4924(r2)
 40002a4:	1009883a 	mov	r4,r2
 40002a8:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
 40002ac:	0001883a 	nop
  NIOS2_READ_IPENDING (active);
 40002b0:	0005313a 	rdctl	r2,ipending
 40002b4:	e0bffb15 	stw	r2,-20(fp)
  return active;
 40002b8:	e0bffb17 	ldw	r2,-20(fp)
 40002bc:	00000706 	br	40002dc <alt_irq_handler+0xa0>
      }
      mask <<= 1;
 40002c0:	e0bffe17 	ldw	r2,-8(fp)
 40002c4:	1085883a 	add	r2,r2,r2
 40002c8:	e0bffe15 	stw	r2,-8(fp)
      i++;
 40002cc:	e0bffd17 	ldw	r2,-12(fp)
 40002d0:	10800044 	addi	r2,r2,1
 40002d4:	e0bffd15 	stw	r2,-12(fp)
      if (active & mask)
 40002d8:	003fe406 	br	400026c <alt_irq_handler+0x30>

    } while (1);

    active = alt_irq_pending ();
 40002dc:	e0bfff15 	stw	r2,-4(fp)
    
  } while (active);
 40002e0:	e0bfff17 	ldw	r2,-4(fp)
 40002e4:	103fde1e 	bne	r2,zero,4000260 <alt_irq_handler+0x24>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
 40002e8:	0001883a 	nop
}
 40002ec:	0001883a 	nop
 40002f0:	e037883a 	mov	sp,fp
 40002f4:	dfc00117 	ldw	ra,4(sp)
 40002f8:	df000017 	ldw	fp,0(sp)
 40002fc:	dec00204 	addi	sp,sp,8
 4000300:	f800283a 	ret

04000304 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
 4000304:	defffb04 	addi	sp,sp,-20
 4000308:	dfc00415 	stw	ra,16(sp)
 400030c:	df000315 	stw	fp,12(sp)
 4000310:	df000304 	addi	fp,sp,12
 4000314:	e13ffd15 	stw	r4,-12(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
 4000318:	00bfffc4 	movi	r2,-1
 400031c:	e0bfff15 	stw	r2,-4(fp)
  badaddr = 0;
 4000320:	e03ffe15 	stw	zero,-8(fp)
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
 4000324:	d0a72e17 	ldw	r2,-25416(gp)
 4000328:	10000726 	beq	r2,zero,4000348 <alt_instruction_exception_entry+0x44>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
 400032c:	d0a72e17 	ldw	r2,-25416(gp)
 4000330:	e0ffff17 	ldw	r3,-4(fp)
 4000334:	e1bffe17 	ldw	r6,-8(fp)
 4000338:	e17ffd17 	ldw	r5,-12(fp)
 400033c:	1809883a 	mov	r4,r3
 4000340:	103ee83a 	callr	r2
 4000344:	00000206 	br	4000350 <alt_instruction_exception_entry+0x4c>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
 4000348:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
 400034c:	0005883a 	mov	r2,zero
}
 4000350:	e037883a 	mov	sp,fp
 4000354:	dfc00117 	ldw	ra,4(sp)
 4000358:	df000017 	ldw	fp,0(sp)
 400035c:	dec00204 	addi	sp,sp,8
 4000360:	f800283a 	ret

Disassembly of section .text:

04000364 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 4000364:	06c20034 	movhi	sp,2048
    ori sp, sp, %lo(__alt_stack_pointer)
 4000368:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
 400036c:	068100b4 	movhi	gp,1026
    ori gp, gp, %lo(_gp)
 4000370:	d693c214 	ori	gp,gp,20232
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 4000374:	00810074 	movhi	r2,1025
    ori r2, r2, %lo(__bss_start)
 4000378:	10bad314 	ori	r2,r2,60236

    movhi r3, %hi(__bss_end)
 400037c:	00c12074 	movhi	r3,1153
    ori r3, r3, %lo(__bss_end)
 4000380:	18fb7014 	ori	r3,r3,60864

    beq r2, r3, 1f
 4000384:	10c00326 	beq	r2,r3,4000394 <_start+0x30>

0:
    stw zero, (r2)
 4000388:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 400038c:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 4000390:	10fffd36 	bltu	r2,r3,4000388 <_start+0x24>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
 4000394:	401859c0 	call	401859c <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 4000398:	401873c0 	call	401873c <alt_main>

0400039c <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 400039c:	003fff06 	br	400039c <alt_after_alt_main>

040003a0 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    EventGroupHandle_t xEventGroupCreate( void )
    {
 40003a0:	defffd04 	addi	sp,sp,-12
 40003a4:	dfc00215 	stw	ra,8(sp)
 40003a8:	df000115 	stw	fp,4(sp)
 40003ac:	df000104 	addi	fp,sp,4
         * TickType_t alignment requirements the cast is safe.  In other cases,
         * where the natural word size of the architecture is less than
         * sizeof( TickType_t ), the TickType_t variables will be accessed in two
         * or more reads operations, and the alignment requirements is only that
         * of each individual read. */
        pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
 40003b0:	01000604 	movi	r4,24
 40003b4:	400103c0 	call	400103c <pvPortMalloc>
 40003b8:	e0bfff15 	stw	r2,-4(fp)

        if( pxEventBits != NULL )
 40003bc:	e0bfff17 	ldw	r2,-4(fp)
 40003c0:	10000626 	beq	r2,zero,40003dc <xEventGroupCreate+0x3c>
        {
            pxEventBits->uxEventBits = 0;
 40003c4:	e0bfff17 	ldw	r2,-4(fp)
 40003c8:	10000015 	stw	zero,0(r2)
            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
 40003cc:	e0bfff17 	ldw	r2,-4(fp)
 40003d0:	10800104 	addi	r2,r2,4
 40003d4:	1009883a 	mov	r4,r2
 40003d8:	4000aa00 	call	4000aa0 <vListInitialise>
        else
        {
            traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
        }

        return pxEventBits;
 40003dc:	e0bfff17 	ldw	r2,-4(fp)
    }
 40003e0:	e037883a 	mov	sp,fp
 40003e4:	dfc00117 	ldw	ra,4(sp)
 40003e8:	df000017 	ldw	fp,0(sp)
 40003ec:	dec00204 	addi	sp,sp,8
 40003f0:	f800283a 	ret

040003f4 <xEventGroupSync>:

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
                             const EventBits_t uxBitsToSet,
                             const EventBits_t uxBitsToWaitFor,
                             TickType_t xTicksToWait )
{
 40003f4:	defff504 	addi	sp,sp,-44
 40003f8:	dfc00a15 	stw	ra,40(sp)
 40003fc:	df000915 	stw	fp,36(sp)
 4000400:	df000904 	addi	fp,sp,36
 4000404:	e13ffa15 	stw	r4,-24(fp)
 4000408:	e17ff915 	stw	r5,-28(fp)
 400040c:	e1bff815 	stw	r6,-32(fp)
 4000410:	e1fff715 	stw	r7,-36(fp)
    EventBits_t uxOriginalBitValue, uxReturn;
    EventGroup_t * pxEventBits = xEventGroup;
 4000414:	e0bffa17 	ldw	r2,-24(fp)
 4000418:	e0bffe15 	stw	r2,-8(fp)
    BaseType_t xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
 400041c:	e03ffd15 	stw	zero,-12(fp)
    {
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    }
    #endif

    vTaskSuspendAll();
 4000420:	40046f00 	call	40046f0 <vTaskSuspendAll>
    {
        uxOriginalBitValue = pxEventBits->uxEventBits;
 4000424:	e0bffe17 	ldw	r2,-8(fp)
 4000428:	10800017 	ldw	r2,0(r2)
 400042c:	e0bffc15 	stw	r2,-16(fp)

        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
 4000430:	e17ff917 	ldw	r5,-28(fp)
 4000434:	e13ffa17 	ldw	r4,-24(fp)
 4000438:	40007c40 	call	40007c4 <xEventGroupSetBits>

        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
 400043c:	e0fffc17 	ldw	r3,-16(fp)
 4000440:	e0bff917 	ldw	r2,-28(fp)
 4000444:	1886b03a 	or	r3,r3,r2
 4000448:	e0bff817 	ldw	r2,-32(fp)
 400044c:	1884703a 	and	r2,r3,r2
 4000450:	e0fff817 	ldw	r3,-32(fp)
 4000454:	18800d1e 	bne	r3,r2,400048c <xEventGroupSync+0x98>
        {
            /* All the rendezvous bits are now set - no need to block. */
            uxReturn = ( uxOriginalBitValue | uxBitsToSet );
 4000458:	e0fffc17 	ldw	r3,-16(fp)
 400045c:	e0bff917 	ldw	r2,-28(fp)
 4000460:	1884b03a 	or	r2,r3,r2
 4000464:	e0bfff15 	stw	r2,-4(fp)

            /* Rendezvous always clear the bits.  They will have been cleared
             * already unless this is the only task in the rendezvous. */
            pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 4000468:	e0bffe17 	ldw	r2,-8(fp)
 400046c:	10c00017 	ldw	r3,0(r2)
 4000470:	e0bff817 	ldw	r2,-32(fp)
 4000474:	0084303a 	nor	r2,zero,r2
 4000478:	1886703a 	and	r3,r3,r2
 400047c:	e0bffe17 	ldw	r2,-8(fp)
 4000480:	10c00015 	stw	r3,0(r2)

            xTicksToWait = 0;
 4000484:	e03ff715 	stw	zero,-36(fp)
 4000488:	00001106 	br	40004d0 <xEventGroupSync+0xdc>
        }
        else
        {
            if( xTicksToWait != ( TickType_t ) 0 )
 400048c:	e0bff717 	ldw	r2,-36(fp)
 4000490:	10000a26 	beq	r2,zero,40004bc <xEventGroupSync+0xc8>
                traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

                /* Store the bits that the calling task is waiting for in the
                 * task's event list item so the kernel knows when a match is
                 * found.  Then enter the blocked state. */
                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
 4000494:	e0bffe17 	ldw	r2,-8(fp)
 4000498:	10c00104 	addi	r3,r2,4
 400049c:	e0bff817 	ldw	r2,-32(fp)
 40004a0:	10814034 	orhi	r2,r2,1280
 40004a4:	e1bff717 	ldw	r6,-36(fp)
 40004a8:	100b883a 	mov	r5,r2
 40004ac:	1809883a 	mov	r4,r3
 40004b0:	4004f700 	call	4004f70 <vTaskPlaceOnUnorderedEventList>

                /* This assignment is obsolete as uxReturn will get set after
                 * the task unblocks, but some compilers mistakenly generate a
                 * warning about uxReturn being returned without being set if the
                 * assignment is omitted. */
                uxReturn = 0;
 40004b4:	e03fff15 	stw	zero,-4(fp)
 40004b8:	00000506 	br	40004d0 <xEventGroupSync+0xdc>
            }
            else
            {
                /* The rendezvous bits were not set, but no block time was
                 * specified - just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
 40004bc:	e0bffe17 	ldw	r2,-8(fp)
 40004c0:	10800017 	ldw	r2,0(r2)
 40004c4:	e0bfff15 	stw	r2,-4(fp)
                xTimeoutOccurred = pdTRUE;
 40004c8:	00800044 	movi	r2,1
 40004cc:	e0bffd15 	stw	r2,-12(fp)
            }
        }
    }
    xAlreadyYielded = xTaskResumeAll();
 40004d0:	400471c0 	call	400471c <xTaskResumeAll>
 40004d4:	e0bffb15 	stw	r2,-20(fp)

    if( xTicksToWait != ( TickType_t ) 0 )
 40004d8:	e0bff717 	ldw	r2,-36(fp)
 40004dc:	10002026 	beq	r2,zero,4000560 <xEventGroupSync+0x16c>
    {
        if( xAlreadyYielded == pdFALSE )
 40004e0:	e0bffb17 	ldw	r2,-20(fp)
 40004e4:	1000011e 	bne	r2,zero,40004ec <xEventGroupSync+0xf8>
        {
            portYIELD_WITHIN_API();
 40004e8:	003b683a 	trap	0

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
 40004ec:	40060340 	call	4006034 <uxTaskResetEventItemValue>
 40004f0:	e0bfff15 	stw	r2,-4(fp)

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
 40004f4:	e0bfff17 	ldw	r2,-4(fp)
 40004f8:	1080802c 	andhi	r2,r2,512
 40004fc:	1000131e 	bne	r2,zero,400054c <xEventGroupSync+0x158>
        {
            /* The task timed out, just return the current event bit value. */
            taskENTER_CRITICAL();
 4000500:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
            {
                uxReturn = pxEventBits->uxEventBits;
 4000504:	e0bffe17 	ldw	r2,-8(fp)
 4000508:	10800017 	ldw	r2,0(r2)
 400050c:	e0bfff15 	stw	r2,-4(fp)

                /* Although the task got here because it timed out before the
                 * bits it was waiting for were set, it is possible that since it
                 * unblocked another task has set the bits.  If this is the case
                 * then it needs to clear the bits before exiting. */
                if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
 4000510:	e0ffff17 	ldw	r3,-4(fp)
 4000514:	e0bff817 	ldw	r2,-32(fp)
 4000518:	1884703a 	and	r2,r3,r2
 400051c:	e0fff817 	ldw	r3,-32(fp)
 4000520:	1880071e 	bne	r3,r2,4000540 <xEventGroupSync+0x14c>
                {
                    pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 4000524:	e0bffe17 	ldw	r2,-8(fp)
 4000528:	10c00017 	ldw	r3,0(r2)
 400052c:	e0bff817 	ldw	r2,-32(fp)
 4000530:	0084303a 	nor	r2,zero,r2
 4000534:	1886703a 	and	r3,r3,r2
 4000538:	e0bffe17 	ldw	r2,-8(fp)
 400053c:	10c00015 	stw	r3,0(r2)
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
 4000540:	4005fd00 	call	4005fd0 <vTaskExitCritical>

            xTimeoutOccurred = pdTRUE;
 4000544:	00800044 	movi	r2,1
 4000548:	e0bffd15 	stw	r2,-12(fp)
            /* The task unblocked because the bits were set. */
        }

        /* Control bits might be set as the task had blocked should not be
         * returned. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
 400054c:	e0ffff17 	ldw	r3,-4(fp)
 4000550:	00804034 	movhi	r2,256
 4000554:	10bfffc4 	addi	r2,r2,-1
 4000558:	1884703a 	and	r2,r3,r2
 400055c:	e0bfff15 	stw	r2,-4(fp)
    traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
 4000560:	e0bfff17 	ldw	r2,-4(fp)
}
 4000564:	e037883a 	mov	sp,fp
 4000568:	dfc00117 	ldw	ra,4(sp)
 400056c:	df000017 	ldw	fp,0(sp)
 4000570:	dec00204 	addi	sp,sp,8
 4000574:	f800283a 	ret

04000578 <xEventGroupWaitBits>:
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait )
{
 4000578:	defff304 	addi	sp,sp,-52
 400057c:	dfc00c15 	stw	ra,48(sp)
 4000580:	df000b15 	stw	fp,44(sp)
 4000584:	df000b04 	addi	fp,sp,44
 4000588:	e13ff815 	stw	r4,-32(fp)
 400058c:	e17ff715 	stw	r5,-36(fp)
 4000590:	e1bff615 	stw	r6,-40(fp)
 4000594:	e1fff515 	stw	r7,-44(fp)
    EventGroup_t * pxEventBits = xEventGroup;
 4000598:	e0bff817 	ldw	r2,-32(fp)
 400059c:	e0bffd15 	stw	r2,-12(fp)
    EventBits_t uxReturn, uxControlBits = 0;
 40005a0:	e03ffe15 	stw	zero,-8(fp)
    BaseType_t xWaitConditionMet, xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
 40005a4:	e03ffc15 	stw	zero,-16(fp)
    {
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    }
    #endif

    vTaskSuspendAll();
 40005a8:	40046f00 	call	40046f0 <vTaskSuspendAll>
    {
        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
 40005ac:	e0bffd17 	ldw	r2,-12(fp)
 40005b0:	10800017 	ldw	r2,0(r2)
 40005b4:	e0bffb15 	stw	r2,-20(fp)

        /* Check to see if the wait condition is already met or not. */
        xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
 40005b8:	e1bff517 	ldw	r6,-44(fp)
 40005bc:	e17ff717 	ldw	r5,-36(fp)
 40005c0:	e13ffb17 	ldw	r4,-20(fp)
 40005c4:	4000a300 	call	4000a30 <prvTestWaitCondition>
 40005c8:	e0bffa15 	stw	r2,-24(fp)

        if( xWaitConditionMet != pdFALSE )
 40005cc:	e0bffa17 	ldw	r2,-24(fp)
 40005d0:	10000d26 	beq	r2,zero,4000608 <xEventGroupWaitBits+0x90>
        {
            /* The wait condition has already been met so there is no need to
             * block. */
            uxReturn = uxCurrentEventBits;
 40005d4:	e0bffb17 	ldw	r2,-20(fp)
 40005d8:	e0bfff15 	stw	r2,-4(fp)
            xTicksToWait = ( TickType_t ) 0;
 40005dc:	e0000215 	stw	zero,8(fp)

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
 40005e0:	e0bff617 	ldw	r2,-40(fp)
 40005e4:	10002226 	beq	r2,zero,4000670 <xEventGroupWaitBits+0xf8>
            {
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 40005e8:	e0bffd17 	ldw	r2,-12(fp)
 40005ec:	10c00017 	ldw	r3,0(r2)
 40005f0:	e0bff717 	ldw	r2,-36(fp)
 40005f4:	0084303a 	nor	r2,zero,r2
 40005f8:	1886703a 	and	r3,r3,r2
 40005fc:	e0bffd17 	ldw	r2,-12(fp)
 4000600:	10c00015 	stw	r3,0(r2)
 4000604:	00001a06 	br	4000670 <xEventGroupWaitBits+0xf8>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else if( xTicksToWait == ( TickType_t ) 0 )
 4000608:	e0800217 	ldw	r2,8(fp)
 400060c:	1000051e 	bne	r2,zero,4000624 <xEventGroupWaitBits+0xac>
        {
            /* The wait condition has not been met, but no block time was
             * specified, so just return the current value. */
            uxReturn = uxCurrentEventBits;
 4000610:	e0bffb17 	ldw	r2,-20(fp)
 4000614:	e0bfff15 	stw	r2,-4(fp)
            xTimeoutOccurred = pdTRUE;
 4000618:	00800044 	movi	r2,1
 400061c:	e0bffc15 	stw	r2,-16(fp)
 4000620:	00001306 	br	4000670 <xEventGroupWaitBits+0xf8>
        {
            /* The task is going to block to wait for its required bits to be
             * set.  uxControlBits are used to remember the specified behaviour of
             * this call to xEventGroupWaitBits() - for use when the event bits
             * unblock the task. */
            if( xClearOnExit != pdFALSE )
 4000624:	e0bff617 	ldw	r2,-40(fp)
 4000628:	10000326 	beq	r2,zero,4000638 <xEventGroupWaitBits+0xc0>
            {
                uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
 400062c:	e0bffe17 	ldw	r2,-8(fp)
 4000630:	10804034 	orhi	r2,r2,256
 4000634:	e0bffe15 	stw	r2,-8(fp)
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if( xWaitForAllBits != pdFALSE )
 4000638:	e0bff517 	ldw	r2,-44(fp)
 400063c:	10000326 	beq	r2,zero,400064c <xEventGroupWaitBits+0xd4>
            {
                uxControlBits |= eventWAIT_FOR_ALL_BITS;
 4000640:	e0bffe17 	ldw	r2,-8(fp)
 4000644:	10810034 	orhi	r2,r2,1024
 4000648:	e0bffe15 	stw	r2,-8(fp)
            }

            /* Store the bits that the calling task is waiting for in the
             * task's event list item so the kernel knows when a match is
             * found.  Then enter the blocked state. */
            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
 400064c:	e0bffd17 	ldw	r2,-12(fp)
 4000650:	11000104 	addi	r4,r2,4
 4000654:	e0fff717 	ldw	r3,-36(fp)
 4000658:	e0bffe17 	ldw	r2,-8(fp)
 400065c:	1884b03a 	or	r2,r3,r2
 4000660:	e1800217 	ldw	r6,8(fp)
 4000664:	100b883a 	mov	r5,r2
 4000668:	4004f700 	call	4004f70 <vTaskPlaceOnUnorderedEventList>

            /* This is obsolete as it will get set after the task unblocks, but
             * some compilers mistakenly generate a warning about the variable
             * being returned without being set if it is not done. */
            uxReturn = 0;
 400066c:	e03fff15 	stw	zero,-4(fp)

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
 4000670:	400471c0 	call	400471c <xTaskResumeAll>
 4000674:	e0bff915 	stw	r2,-28(fp)

    if( xTicksToWait != ( TickType_t ) 0 )
 4000678:	e0800217 	ldw	r2,8(fp)
 400067c:	10002226 	beq	r2,zero,4000708 <xEventGroupWaitBits+0x190>
    {
        if( xAlreadyYielded == pdFALSE )
 4000680:	e0bff917 	ldw	r2,-28(fp)
 4000684:	1000011e 	bne	r2,zero,400068c <xEventGroupWaitBits+0x114>
        {
            portYIELD_WITHIN_API();
 4000688:	003b683a 	trap	0

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
 400068c:	40060340 	call	4006034 <uxTaskResetEventItemValue>
 4000690:	e0bfff15 	stw	r2,-4(fp)

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
 4000694:	e0bfff17 	ldw	r2,-4(fp)
 4000698:	1080802c 	andhi	r2,r2,512
 400069c:	1000151e 	bne	r2,zero,40006f4 <xEventGroupWaitBits+0x17c>
        {
            taskENTER_CRITICAL();
 40006a0:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
            {
                /* The task timed out, just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
 40006a4:	e0bffd17 	ldw	r2,-12(fp)
 40006a8:	10800017 	ldw	r2,0(r2)
 40006ac:	e0bfff15 	stw	r2,-4(fp)

                /* It is possible that the event bits were updated between this
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
 40006b0:	e1bff517 	ldw	r6,-44(fp)
 40006b4:	e17ff717 	ldw	r5,-36(fp)
 40006b8:	e13fff17 	ldw	r4,-4(fp)
 40006bc:	4000a300 	call	4000a30 <prvTestWaitCondition>
 40006c0:	10000926 	beq	r2,zero,40006e8 <xEventGroupWaitBits+0x170>
                {
                    if( xClearOnExit != pdFALSE )
 40006c4:	e0bff617 	ldw	r2,-40(fp)
 40006c8:	10000726 	beq	r2,zero,40006e8 <xEventGroupWaitBits+0x170>
                    {
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 40006cc:	e0bffd17 	ldw	r2,-12(fp)
 40006d0:	10c00017 	ldw	r3,0(r2)
 40006d4:	e0bff717 	ldw	r2,-36(fp)
 40006d8:	0084303a 	nor	r2,zero,r2
 40006dc:	1886703a 	and	r3,r3,r2
 40006e0:	e0bffd17 	ldw	r2,-12(fp)
 40006e4:	10c00015 	stw	r3,0(r2)
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                xTimeoutOccurred = pdTRUE;
 40006e8:	00800044 	movi	r2,1
 40006ec:	e0bffc15 	stw	r2,-16(fp)
            }
            taskEXIT_CRITICAL();
 40006f0:	4005fd00 	call	4005fd0 <vTaskExitCritical>
        {
            /* The task unblocked because the bits were set. */
        }

        /* The task blocked so control bits may have been set. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
 40006f4:	e0ffff17 	ldw	r3,-4(fp)
 40006f8:	00804034 	movhi	r2,256
 40006fc:	10bfffc4 	addi	r2,r2,-1
 4000700:	1884703a 	and	r2,r3,r2
 4000704:	e0bfff15 	stw	r2,-4(fp)
    traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
 4000708:	e0bfff17 	ldw	r2,-4(fp)
}
 400070c:	e037883a 	mov	sp,fp
 4000710:	dfc00117 	ldw	ra,4(sp)
 4000714:	df000017 	ldw	fp,0(sp)
 4000718:	dec00204 	addi	sp,sp,8
 400071c:	f800283a 	ret

04000720 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                  const EventBits_t uxBitsToClear )
{
 4000720:	defffa04 	addi	sp,sp,-24
 4000724:	dfc00515 	stw	ra,20(sp)
 4000728:	df000415 	stw	fp,16(sp)
 400072c:	df000404 	addi	fp,sp,16
 4000730:	e13ffd15 	stw	r4,-12(fp)
 4000734:	e17ffc15 	stw	r5,-16(fp)
    EventGroup_t * pxEventBits = xEventGroup;
 4000738:	e0bffd17 	ldw	r2,-12(fp)
 400073c:	e0bfff15 	stw	r2,-4(fp)
    /* Check the user is not attempting to clear the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    taskENTER_CRITICAL();
 4000740:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
    {
        traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

        /* The value returned is the event group value prior to the bits being
         * cleared. */
        uxReturn = pxEventBits->uxEventBits;
 4000744:	e0bfff17 	ldw	r2,-4(fp)
 4000748:	10800017 	ldw	r2,0(r2)
 400074c:	e0bffe15 	stw	r2,-8(fp)

        /* Clear the bits. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
 4000750:	e0bfff17 	ldw	r2,-4(fp)
 4000754:	10c00017 	ldw	r3,0(r2)
 4000758:	e0bffc17 	ldw	r2,-16(fp)
 400075c:	0084303a 	nor	r2,zero,r2
 4000760:	1886703a 	and	r3,r3,r2
 4000764:	e0bfff17 	ldw	r2,-4(fp)
 4000768:	10c00015 	stw	r3,0(r2)
    }
    taskEXIT_CRITICAL();
 400076c:	4005fd00 	call	4005fd0 <vTaskExitCritical>

    return uxReturn;
 4000770:	e0bffe17 	ldw	r2,-8(fp)
}
 4000774:	e037883a 	mov	sp,fp
 4000778:	dfc00117 	ldw	ra,4(sp)
 400077c:	df000017 	ldw	fp,0(sp)
 4000780:	dec00204 	addi	sp,sp,8
 4000784:	f800283a 	ret

04000788 <xEventGroupGetBitsFromISR>:

#endif /* if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) ) */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
 4000788:	defffb04 	addi	sp,sp,-20
 400078c:	df000415 	stw	fp,16(sp)
 4000790:	df000404 	addi	fp,sp,16
 4000794:	e13ffc15 	stw	r4,-16(fp)
    UBaseType_t uxSavedInterruptStatus;
    EventGroup_t const * const pxEventBits = xEventGroup;
 4000798:	e0bffc17 	ldw	r2,-16(fp)
 400079c:	e0bfff15 	stw	r2,-4(fp)
    EventBits_t uxReturn;

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 40007a0:	e03ffe15 	stw	zero,-8(fp)
    {
        uxReturn = pxEventBits->uxEventBits;
 40007a4:	e0bfff17 	ldw	r2,-4(fp)
 40007a8:	10800017 	ldw	r2,0(r2)
 40007ac:	e0bffd15 	stw	r2,-12(fp)
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return uxReturn;
 40007b0:	e0bffd17 	ldw	r2,-12(fp)
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
 40007b4:	e037883a 	mov	sp,fp
 40007b8:	df000017 	ldw	fp,0(sp)
 40007bc:	dec00104 	addi	sp,sp,4
 40007c0:	f800283a 	ret

040007c4 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet )
{
 40007c4:	defff304 	addi	sp,sp,-52
 40007c8:	dfc00c15 	stw	ra,48(sp)
 40007cc:	df000b15 	stw	fp,44(sp)
 40007d0:	df000b04 	addi	fp,sp,44
 40007d4:	e13ff615 	stw	r4,-40(fp)
 40007d8:	e17ff515 	stw	r5,-44(fp)
    ListItem_t * pxListItem;
    ListItem_t * pxNext;
    ListItem_t const * pxListEnd;
    List_t const * pxList;
    EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
 40007dc:	e03ffe15 	stw	zero,-8(fp)
    EventGroup_t * pxEventBits = xEventGroup;
 40007e0:	e0bff617 	ldw	r2,-40(fp)
 40007e4:	e0bffc15 	stw	r2,-16(fp)
    BaseType_t xMatchFound = pdFALSE;
 40007e8:	e03ffd15 	stw	zero,-12(fp)
    /* Check the user is not attempting to set the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    pxList = &( pxEventBits->xTasksWaitingForBits );
 40007ec:	e0bffc17 	ldw	r2,-16(fp)
 40007f0:	10800104 	addi	r2,r2,4
 40007f4:	e0bffb15 	stw	r2,-20(fp)
    pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 40007f8:	e0bffb17 	ldw	r2,-20(fp)
 40007fc:	10800204 	addi	r2,r2,8
 4000800:	e0bffa15 	stw	r2,-24(fp)
    vTaskSuspendAll();
 4000804:	40046f00 	call	40046f0 <vTaskSuspendAll>
    {
        traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

        pxListItem = listGET_HEAD_ENTRY( pxList );
 4000808:	e0bffb17 	ldw	r2,-20(fp)
 400080c:	10800317 	ldw	r2,12(r2)
 4000810:	e0bfff15 	stw	r2,-4(fp)

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;
 4000814:	e0bffc17 	ldw	r2,-16(fp)
 4000818:	10c00017 	ldw	r3,0(r2)
 400081c:	e0bff517 	ldw	r2,-44(fp)
 4000820:	1886b03a 	or	r3,r3,r2
 4000824:	e0bffc17 	ldw	r2,-16(fp)
 4000828:	10c00015 	stw	r3,0(r2)

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
 400082c:	00003306 	br	40008fc <xEventGroupSetBits+0x138>
        {
            pxNext = listGET_NEXT( pxListItem );
 4000830:	e0bfff17 	ldw	r2,-4(fp)
 4000834:	10800117 	ldw	r2,4(r2)
 4000838:	e0bff915 	stw	r2,-28(fp)
            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
 400083c:	e0bfff17 	ldw	r2,-4(fp)
 4000840:	10800017 	ldw	r2,0(r2)
 4000844:	e0bff815 	stw	r2,-32(fp)
            xMatchFound = pdFALSE;
 4000848:	e03ffd15 	stw	zero,-12(fp)

            /* Split the bits waited for from the control bits. */
            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
 400084c:	e0bff817 	ldw	r2,-32(fp)
 4000850:	10bfc02c 	andhi	r2,r2,65280
 4000854:	e0bff715 	stw	r2,-36(fp)
            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
 4000858:	e0fff817 	ldw	r3,-32(fp)
 400085c:	00804034 	movhi	r2,256
 4000860:	10bfffc4 	addi	r2,r2,-1
 4000864:	1884703a 	and	r2,r3,r2
 4000868:	e0bff815 	stw	r2,-32(fp)

            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
 400086c:	e0bff717 	ldw	r2,-36(fp)
 4000870:	1081002c 	andhi	r2,r2,1024
 4000874:	1000081e 	bne	r2,zero,4000898 <xEventGroupSetBits+0xd4>
            {
                /* Just looking for single bit being set. */
                if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
 4000878:	e0bffc17 	ldw	r2,-16(fp)
 400087c:	10c00017 	ldw	r3,0(r2)
 4000880:	e0bff817 	ldw	r2,-32(fp)
 4000884:	1884703a 	and	r2,r3,r2
 4000888:	10000b26 	beq	r2,zero,40008b8 <xEventGroupSetBits+0xf4>
                {
                    xMatchFound = pdTRUE;
 400088c:	00800044 	movi	r2,1
 4000890:	e0bffd15 	stw	r2,-12(fp)
 4000894:	00000806 	br	40008b8 <xEventGroupSetBits+0xf4>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
 4000898:	e0bffc17 	ldw	r2,-16(fp)
 400089c:	10c00017 	ldw	r3,0(r2)
 40008a0:	e0bff817 	ldw	r2,-32(fp)
 40008a4:	1884703a 	and	r2,r3,r2
 40008a8:	e0fff817 	ldw	r3,-32(fp)
 40008ac:	1880021e 	bne	r3,r2,40008b8 <xEventGroupSetBits+0xf4>
            {
                /* All bits are set. */
                xMatchFound = pdTRUE;
 40008b0:	00800044 	movi	r2,1
 40008b4:	e0bffd15 	stw	r2,-12(fp)
            else
            {
                /* Need all bits to be set, but not all the bits were set. */
            }

            if( xMatchFound != pdFALSE )
 40008b8:	e0bffd17 	ldw	r2,-12(fp)
 40008bc:	10000d26 	beq	r2,zero,40008f4 <xEventGroupSetBits+0x130>
            {
                /* The bits match.  Should the bits be cleared on exit? */
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
 40008c0:	e0bff717 	ldw	r2,-36(fp)
 40008c4:	1080402c 	andhi	r2,r2,256
 40008c8:	10000426 	beq	r2,zero,40008dc <xEventGroupSetBits+0x118>
                {
                    uxBitsToClear |= uxBitsWaitedFor;
 40008cc:	e0fffe17 	ldw	r3,-8(fp)
 40008d0:	e0bff817 	ldw	r2,-32(fp)
 40008d4:	1884b03a 	or	r2,r3,r2
 40008d8:	e0bffe15 	stw	r2,-8(fp)
                /* Store the actual event flag value in the task's event list
                 * item before removing the task from the event list.  The
                 * eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
                 * that is was unblocked due to its required bits matching, rather
                 * than because it timed out. */
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
 40008dc:	e0bffc17 	ldw	r2,-16(fp)
 40008e0:	10800017 	ldw	r2,0(r2)
 40008e4:	10808034 	orhi	r2,r2,512
 40008e8:	100b883a 	mov	r5,r2
 40008ec:	e13fff17 	ldw	r4,-4(fp)
 40008f0:	40052fc0 	call	40052fc <vTaskRemoveFromUnorderedEventList>
            }

            /* Move onto the next list item.  Note pxListItem->pxNext is not
             * used here as the list item may have been removed from the event list
             * and inserted into the ready/pending reading list. */
            pxListItem = pxNext;
 40008f4:	e0bff917 	ldw	r2,-28(fp)
 40008f8:	e0bfff15 	stw	r2,-4(fp)
        while( pxListItem != pxListEnd )
 40008fc:	e0ffff17 	ldw	r3,-4(fp)
 4000900:	e0bffa17 	ldw	r2,-24(fp)
 4000904:	18bfca1e 	bne	r3,r2,4000830 <xEventGroupSetBits+0x6c>
        }

        /* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
         * bit was set in the control word. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
 4000908:	e0bffc17 	ldw	r2,-16(fp)
 400090c:	10c00017 	ldw	r3,0(r2)
 4000910:	e0bffe17 	ldw	r2,-8(fp)
 4000914:	0084303a 	nor	r2,zero,r2
 4000918:	1886703a 	and	r3,r3,r2
 400091c:	e0bffc17 	ldw	r2,-16(fp)
 4000920:	10c00015 	stw	r3,0(r2)
    }
    ( void ) xTaskResumeAll();
 4000924:	400471c0 	call	400471c <xTaskResumeAll>

    return pxEventBits->uxEventBits;
 4000928:	e0bffc17 	ldw	r2,-16(fp)
 400092c:	10800017 	ldw	r2,0(r2)
}
 4000930:	e037883a 	mov	sp,fp
 4000934:	dfc00117 	ldw	ra,4(sp)
 4000938:	df000017 	ldw	fp,0(sp)
 400093c:	dec00204 	addi	sp,sp,8
 4000940:	f800283a 	ret

04000944 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
 4000944:	defffb04 	addi	sp,sp,-20
 4000948:	dfc00415 	stw	ra,16(sp)
 400094c:	df000315 	stw	fp,12(sp)
 4000950:	df000304 	addi	fp,sp,12
 4000954:	e13ffd15 	stw	r4,-12(fp)
    EventGroup_t * pxEventBits = xEventGroup;
 4000958:	e0bffd17 	ldw	r2,-12(fp)
 400095c:	e0bfff15 	stw	r2,-4(fp)
    const List_t * pxTasksWaitingForBits;

    configASSERT( pxEventBits );

    pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
 4000960:	e0bfff17 	ldw	r2,-4(fp)
 4000964:	10800104 	addi	r2,r2,4
 4000968:	e0bffe15 	stw	r2,-8(fp)

    vTaskSuspendAll();
 400096c:	40046f00 	call	40046f0 <vTaskSuspendAll>
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
 4000970:	00000506 	br	4000988 <vEventGroupDelete+0x44>
        {
            /* Unblock the task, returning 0 as the event list is being deleted
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
 4000974:	e0bffe17 	ldw	r2,-8(fp)
 4000978:	10800317 	ldw	r2,12(r2)
 400097c:	01408034 	movhi	r5,512
 4000980:	1009883a 	mov	r4,r2
 4000984:	40052fc0 	call	40052fc <vTaskRemoveFromUnorderedEventList>
        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
 4000988:	e0bffe17 	ldw	r2,-8(fp)
 400098c:	10800017 	ldw	r2,0(r2)
 4000990:	103ff81e 	bne	r2,zero,4000974 <vEventGroupDelete+0x30>
        }
    }
    ( void ) xTaskResumeAll();
 4000994:	400471c0 	call	400471c <xTaskResumeAll>

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
    {
        /* The event group can only have been allocated dynamically - free
         * it again. */
        vPortFree( pxEventBits );
 4000998:	e13fff17 	ldw	r4,-4(fp)
 400099c:	40011240 	call	4001124 <vPortFree>
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
 40009a0:	0001883a 	nop
 40009a4:	e037883a 	mov	sp,fp
 40009a8:	dfc00117 	ldw	ra,4(sp)
 40009ac:	df000017 	ldw	fp,0(sp)
 40009b0:	dec00204 	addi	sp,sp,8
 40009b4:	f800283a 	ret

040009b8 <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
 * an interrupt. */
void vEventGroupSetBitsCallback( void * pvEventGroup,
                                 const uint32_t ulBitsToSet )
{
 40009b8:	defffc04 	addi	sp,sp,-16
 40009bc:	dfc00315 	stw	ra,12(sp)
 40009c0:	df000215 	stw	fp,8(sp)
 40009c4:	df000204 	addi	fp,sp,8
 40009c8:	e13fff15 	stw	r4,-4(fp)
 40009cc:	e17ffe15 	stw	r5,-8(fp)
    ( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
 40009d0:	e17ffe17 	ldw	r5,-8(fp)
 40009d4:	e13fff17 	ldw	r4,-4(fp)
 40009d8:	40007c40 	call	40007c4 <xEventGroupSetBits>
}
 40009dc:	0001883a 	nop
 40009e0:	e037883a 	mov	sp,fp
 40009e4:	dfc00117 	ldw	ra,4(sp)
 40009e8:	df000017 	ldw	fp,0(sp)
 40009ec:	dec00204 	addi	sp,sp,8
 40009f0:	f800283a 	ret

040009f4 <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
 * an interrupt. */
void vEventGroupClearBitsCallback( void * pvEventGroup,
                                   const uint32_t ulBitsToClear )
{
 40009f4:	defffc04 	addi	sp,sp,-16
 40009f8:	dfc00315 	stw	ra,12(sp)
 40009fc:	df000215 	stw	fp,8(sp)
 4000a00:	df000204 	addi	fp,sp,8
 4000a04:	e13fff15 	stw	r4,-4(fp)
 4000a08:	e17ffe15 	stw	r5,-8(fp)
    ( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
 4000a0c:	e17ffe17 	ldw	r5,-8(fp)
 4000a10:	e13fff17 	ldw	r4,-4(fp)
 4000a14:	40007200 	call	4000720 <xEventGroupClearBits>
}
 4000a18:	0001883a 	nop
 4000a1c:	e037883a 	mov	sp,fp
 4000a20:	dfc00117 	ldw	ra,4(sp)
 4000a24:	df000017 	ldw	fp,0(sp)
 4000a28:	dec00204 	addi	sp,sp,8
 4000a2c:	f800283a 	ret

04000a30 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits,
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
 4000a30:	defffb04 	addi	sp,sp,-20
 4000a34:	df000415 	stw	fp,16(sp)
 4000a38:	df000404 	addi	fp,sp,16
 4000a3c:	e13ffe15 	stw	r4,-8(fp)
 4000a40:	e17ffd15 	stw	r5,-12(fp)
 4000a44:	e1bffc15 	stw	r6,-16(fp)
    BaseType_t xWaitConditionMet = pdFALSE;
 4000a48:	e03fff15 	stw	zero,-4(fp)

    if( xWaitForAllBits == pdFALSE )
 4000a4c:	e0bffc17 	ldw	r2,-16(fp)
 4000a50:	1000071e 	bne	r2,zero,4000a70 <prvTestWaitCondition+0x40>
    {
        /* Task only has to wait for one bit within uxBitsToWaitFor to be
         * set.  Is one already set? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
 4000a54:	e0fffe17 	ldw	r3,-8(fp)
 4000a58:	e0bffd17 	ldw	r2,-12(fp)
 4000a5c:	1884703a 	and	r2,r3,r2
 4000a60:	10000a26 	beq	r2,zero,4000a8c <prvTestWaitCondition+0x5c>
        {
            xWaitConditionMet = pdTRUE;
 4000a64:	00800044 	movi	r2,1
 4000a68:	e0bfff15 	stw	r2,-4(fp)
 4000a6c:	00000706 	br	4000a8c <prvTestWaitCondition+0x5c>
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
 4000a70:	e0fffe17 	ldw	r3,-8(fp)
 4000a74:	e0bffd17 	ldw	r2,-12(fp)
 4000a78:	1884703a 	and	r2,r3,r2
 4000a7c:	e0fffd17 	ldw	r3,-12(fp)
 4000a80:	1880021e 	bne	r3,r2,4000a8c <prvTestWaitCondition+0x5c>
        {
            xWaitConditionMet = pdTRUE;
 4000a84:	00800044 	movi	r2,1
 4000a88:	e0bfff15 	stw	r2,-4(fp)
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    return xWaitConditionMet;
 4000a8c:	e0bfff17 	ldw	r2,-4(fp)
}
 4000a90:	e037883a 	mov	sp,fp
 4000a94:	df000017 	ldw	fp,0(sp)
 4000a98:	dec00104 	addi	sp,sp,4
 4000a9c:	f800283a 	ret

04000aa0 <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 4000aa0:	defffe04 	addi	sp,sp,-8
 4000aa4:	df000115 	stw	fp,4(sp)
 4000aa8:	df000104 	addi	fp,sp,4
 4000aac:	e13fff15 	stw	r4,-4(fp)
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 4000ab0:	e0bfff17 	ldw	r2,-4(fp)
 4000ab4:	10c00204 	addi	r3,r2,8
 4000ab8:	e0bfff17 	ldw	r2,-4(fp)
 4000abc:	10c00115 	stw	r3,4(r2)

    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
 4000ac0:	e0bfff17 	ldw	r2,-4(fp)
 4000ac4:	00ffffc4 	movi	r3,-1
 4000ac8:	10c00215 	stw	r3,8(r2)

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 4000acc:	e0bfff17 	ldw	r2,-4(fp)
 4000ad0:	10c00204 	addi	r3,r2,8
 4000ad4:	e0bfff17 	ldw	r2,-4(fp)
 4000ad8:	10c00315 	stw	r3,12(r2)
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 4000adc:	e0bfff17 	ldw	r2,-4(fp)
 4000ae0:	10c00204 	addi	r3,r2,8
 4000ae4:	e0bfff17 	ldw	r2,-4(fp)
 4000ae8:	10c00415 	stw	r3,16(r2)
        pxList->xListEnd.pxContainer = NULL;
        listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );
    }
    #endif

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 4000aec:	e0bfff17 	ldw	r2,-4(fp)
 4000af0:	10000015 	stw	zero,0(r2)

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 4000af4:	0001883a 	nop
 4000af8:	e037883a 	mov	sp,fp
 4000afc:	df000017 	ldw	fp,0(sp)
 4000b00:	dec00104 	addi	sp,sp,4
 4000b04:	f800283a 	ret

04000b08 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
 4000b08:	defffe04 	addi	sp,sp,-8
 4000b0c:	df000115 	stw	fp,4(sp)
 4000b10:	df000104 	addi	fp,sp,4
 4000b14:	e13fff15 	stw	r4,-4(fp)
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
 4000b18:	e0bfff17 	ldw	r2,-4(fp)
 4000b1c:	10000415 	stw	zero,16(r2)

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 4000b20:	0001883a 	nop
 4000b24:	e037883a 	mov	sp,fp
 4000b28:	df000017 	ldw	fp,0(sp)
 4000b2c:	dec00104 	addi	sp,sp,4
 4000b30:	f800283a 	ret

04000b34 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
 4000b34:	defffc04 	addi	sp,sp,-16
 4000b38:	df000315 	stw	fp,12(sp)
 4000b3c:	df000304 	addi	fp,sp,12
 4000b40:	e13ffe15 	stw	r4,-8(fp)
 4000b44:	e17ffd15 	stw	r5,-12(fp)
    ListItem_t * const pxIndex = pxList->pxIndex;
 4000b48:	e0bffe17 	ldw	r2,-8(fp)
 4000b4c:	10800117 	ldw	r2,4(r2)
 4000b50:	e0bfff15 	stw	r2,-4(fp)
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
 4000b54:	e0bffd17 	ldw	r2,-12(fp)
 4000b58:	e0ffff17 	ldw	r3,-4(fp)
 4000b5c:	10c00115 	stw	r3,4(r2)
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 4000b60:	e0bfff17 	ldw	r2,-4(fp)
 4000b64:	10c00217 	ldw	r3,8(r2)
 4000b68:	e0bffd17 	ldw	r2,-12(fp)
 4000b6c:	10c00215 	stw	r3,8(r2)

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
 4000b70:	e0bfff17 	ldw	r2,-4(fp)
 4000b74:	10800217 	ldw	r2,8(r2)
 4000b78:	e0fffd17 	ldw	r3,-12(fp)
 4000b7c:	10c00115 	stw	r3,4(r2)
    pxIndex->pxPrevious = pxNewListItem;
 4000b80:	e0bfff17 	ldw	r2,-4(fp)
 4000b84:	e0fffd17 	ldw	r3,-12(fp)
 4000b88:	10c00215 	stw	r3,8(r2)

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
 4000b8c:	e0bffd17 	ldw	r2,-12(fp)
 4000b90:	e0fffe17 	ldw	r3,-8(fp)
 4000b94:	10c00415 	stw	r3,16(r2)

    ( pxList->uxNumberOfItems )++;
 4000b98:	e0bffe17 	ldw	r2,-8(fp)
 4000b9c:	10800017 	ldw	r2,0(r2)
 4000ba0:	10c00044 	addi	r3,r2,1
 4000ba4:	e0bffe17 	ldw	r2,-8(fp)
 4000ba8:	10c00015 	stw	r3,0(r2)
}
 4000bac:	0001883a 	nop
 4000bb0:	e037883a 	mov	sp,fp
 4000bb4:	df000017 	ldw	fp,0(sp)
 4000bb8:	dec00104 	addi	sp,sp,4
 4000bbc:	f800283a 	ret

04000bc0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
 4000bc0:	defffb04 	addi	sp,sp,-20
 4000bc4:	df000415 	stw	fp,16(sp)
 4000bc8:	df000404 	addi	fp,sp,16
 4000bcc:	e13ffd15 	stw	r4,-12(fp)
 4000bd0:	e17ffc15 	stw	r5,-16(fp)
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 4000bd4:	e0bffc17 	ldw	r2,-16(fp)
 4000bd8:	10800017 	ldw	r2,0(r2)
 4000bdc:	e0bffe15 	stw	r2,-8(fp)
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
 4000be0:	e0bffe17 	ldw	r2,-8(fp)
 4000be4:	10bfffd8 	cmpnei	r2,r2,-1
 4000be8:	1000041e 	bne	r2,zero,4000bfc <vListInsert+0x3c>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
 4000bec:	e0bffd17 	ldw	r2,-12(fp)
 4000bf0:	10800417 	ldw	r2,16(r2)
 4000bf4:	e0bfff15 	stw	r2,-4(fp)
 4000bf8:	00000c06 	br	4000c2c <vListInsert+0x6c>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 4000bfc:	e0bffd17 	ldw	r2,-12(fp)
 4000c00:	10800204 	addi	r2,r2,8
 4000c04:	e0bfff15 	stw	r2,-4(fp)
 4000c08:	00000306 	br	4000c18 <vListInsert+0x58>
 4000c0c:	e0bfff17 	ldw	r2,-4(fp)
 4000c10:	10800117 	ldw	r2,4(r2)
 4000c14:	e0bfff15 	stw	r2,-4(fp)
 4000c18:	e0bfff17 	ldw	r2,-4(fp)
 4000c1c:	10800117 	ldw	r2,4(r2)
 4000c20:	10800017 	ldw	r2,0(r2)
 4000c24:	e0fffe17 	ldw	r3,-8(fp)
 4000c28:	18bff82e 	bgeu	r3,r2,4000c0c <vListInsert+0x4c>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
 4000c2c:	e0bfff17 	ldw	r2,-4(fp)
 4000c30:	10c00117 	ldw	r3,4(r2)
 4000c34:	e0bffc17 	ldw	r2,-16(fp)
 4000c38:	10c00115 	stw	r3,4(r2)
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 4000c3c:	e0bffc17 	ldw	r2,-16(fp)
 4000c40:	10800117 	ldw	r2,4(r2)
 4000c44:	e0fffc17 	ldw	r3,-16(fp)
 4000c48:	10c00215 	stw	r3,8(r2)
    pxNewListItem->pxPrevious = pxIterator;
 4000c4c:	e0bffc17 	ldw	r2,-16(fp)
 4000c50:	e0ffff17 	ldw	r3,-4(fp)
 4000c54:	10c00215 	stw	r3,8(r2)
    pxIterator->pxNext = pxNewListItem;
 4000c58:	e0bfff17 	ldw	r2,-4(fp)
 4000c5c:	e0fffc17 	ldw	r3,-16(fp)
 4000c60:	10c00115 	stw	r3,4(r2)

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
 4000c64:	e0bffc17 	ldw	r2,-16(fp)
 4000c68:	e0fffd17 	ldw	r3,-12(fp)
 4000c6c:	10c00415 	stw	r3,16(r2)

    ( pxList->uxNumberOfItems )++;
 4000c70:	e0bffd17 	ldw	r2,-12(fp)
 4000c74:	10800017 	ldw	r2,0(r2)
 4000c78:	10c00044 	addi	r3,r2,1
 4000c7c:	e0bffd17 	ldw	r2,-12(fp)
 4000c80:	10c00015 	stw	r3,0(r2)
}
 4000c84:	0001883a 	nop
 4000c88:	e037883a 	mov	sp,fp
 4000c8c:	df000017 	ldw	fp,0(sp)
 4000c90:	dec00104 	addi	sp,sp,4
 4000c94:	f800283a 	ret

04000c98 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 4000c98:	defffd04 	addi	sp,sp,-12
 4000c9c:	df000215 	stw	fp,8(sp)
 4000ca0:	df000204 	addi	fp,sp,8
 4000ca4:	e13ffe15 	stw	r4,-8(fp)
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
 4000ca8:	e0bffe17 	ldw	r2,-8(fp)
 4000cac:	10800417 	ldw	r2,16(r2)
 4000cb0:	e0bfff15 	stw	r2,-4(fp)

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 4000cb4:	e0bffe17 	ldw	r2,-8(fp)
 4000cb8:	10800117 	ldw	r2,4(r2)
 4000cbc:	e0fffe17 	ldw	r3,-8(fp)
 4000cc0:	18c00217 	ldw	r3,8(r3)
 4000cc4:	10c00215 	stw	r3,8(r2)
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 4000cc8:	e0bffe17 	ldw	r2,-8(fp)
 4000ccc:	10800217 	ldw	r2,8(r2)
 4000cd0:	e0fffe17 	ldw	r3,-8(fp)
 4000cd4:	18c00117 	ldw	r3,4(r3)
 4000cd8:	10c00115 	stw	r3,4(r2)

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
 4000cdc:	e0bfff17 	ldw	r2,-4(fp)
 4000ce0:	10800117 	ldw	r2,4(r2)
 4000ce4:	e0fffe17 	ldw	r3,-8(fp)
 4000ce8:	1880041e 	bne	r3,r2,4000cfc <uxListRemove+0x64>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
 4000cec:	e0bffe17 	ldw	r2,-8(fp)
 4000cf0:	10c00217 	ldw	r3,8(r2)
 4000cf4:	e0bfff17 	ldw	r2,-4(fp)
 4000cf8:	10c00115 	stw	r3,4(r2)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
 4000cfc:	e0bffe17 	ldw	r2,-8(fp)
 4000d00:	10000415 	stw	zero,16(r2)
    ( pxList->uxNumberOfItems )--;
 4000d04:	e0bfff17 	ldw	r2,-4(fp)
 4000d08:	10800017 	ldw	r2,0(r2)
 4000d0c:	10ffffc4 	addi	r3,r2,-1
 4000d10:	e0bfff17 	ldw	r2,-4(fp)
 4000d14:	10c00015 	stw	r3,0(r2)

    return pxList->uxNumberOfItems;
 4000d18:	e0bfff17 	ldw	r2,-4(fp)
 4000d1c:	10800017 	ldw	r2,0(r2)
}
 4000d20:	e037883a 	mov	sp,fp
 4000d24:	df000017 	ldw	fp,0(sp)
 4000d28:	dec00104 	addi	sp,sp,4
 4000d2c:	f800283a 	ret

04000d30 <prvReadGp>:
void vPortSysTickHandler( void * context);

/*-----------------------------------------------------------*/

static void prvReadGp( uint32_t *ulValue )
{
 4000d30:	defffe04 	addi	sp,sp,-8
 4000d34:	df000115 	stw	fp,4(sp)
 4000d38:	df000104 	addi	fp,sp,4
 4000d3c:	e13fff15 	stw	r4,-4(fp)
	asm( "stw gp, (%0)" :: "r"(ulValue) );
 4000d40:	e0bfff17 	ldw	r2,-4(fp)
 4000d44:	16800015 	stw	gp,0(r2)
}
 4000d48:	0001883a 	nop
 4000d4c:	e037883a 	mov	sp,fp
 4000d50:	df000017 	ldw	fp,0(sp)
 4000d54:	dec00104 	addi	sp,sp,4
 4000d58:	f800283a 	ret

04000d5c <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{    
 4000d5c:	defff904 	addi	sp,sp,-28
 4000d60:	dfc00615 	stw	ra,24(sp)
 4000d64:	df000515 	stw	fp,20(sp)
 4000d68:	df000504 	addi	fp,sp,20
 4000d6c:	e13ffd15 	stw	r4,-12(fp)
 4000d70:	e17ffc15 	stw	r5,-16(fp)
 4000d74:	e1bffb15 	stw	r6,-20(fp)
StackType_t *pxFramePointer = pxTopOfStack - 1;
 4000d78:	e0bffd17 	ldw	r2,-12(fp)
 4000d7c:	10bfff04 	addi	r2,r2,-4
 4000d80:	e0bfff15 	stw	r2,-4(fp)
StackType_t xGlobalPointer;

    prvReadGp( &xGlobalPointer ); 
 4000d84:	e0bffe04 	addi	r2,fp,-8
 4000d88:	1009883a 	mov	r4,r2
 4000d8c:	4000d300 	call	4000d30 <prvReadGp>

    /* End of stack marker. */
    *pxTopOfStack = 0xdeadbeef;
 4000d90:	e0fffd17 	ldw	r3,-12(fp)
 4000d94:	00b7abb4 	movhi	r2,57006
 4000d98:	10afbbc4 	addi	r2,r2,-16657
 4000d9c:	18800015 	stw	r2,0(r3)
    pxTopOfStack--;
 4000da0:	e0bffd17 	ldw	r2,-12(fp)
 4000da4:	10bfff04 	addi	r2,r2,-4
 4000da8:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = ( StackType_t ) pxFramePointer; 
 4000dac:	e0ffff17 	ldw	r3,-4(fp)
 4000db0:	e0bffd17 	ldw	r2,-12(fp)
 4000db4:	10c00015 	stw	r3,0(r2)
    pxTopOfStack--;
 4000db8:	e0bffd17 	ldw	r2,-12(fp)
 4000dbc:	10bfff04 	addi	r2,r2,-4
 4000dc0:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = xGlobalPointer; 
 4000dc4:	e0fffe17 	ldw	r3,-8(fp)
 4000dc8:	e0bffd17 	ldw	r2,-12(fp)
 4000dcc:	10c00015 	stw	r3,0(r2)
    
    /* Space for R23 to R16. */
    pxTopOfStack -= 9;
 4000dd0:	e0bffd17 	ldw	r2,-12(fp)
 4000dd4:	10bff704 	addi	r2,r2,-36
 4000dd8:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = ( StackType_t ) pxCode; 
 4000ddc:	e0fffc17 	ldw	r3,-16(fp)
 4000de0:	e0bffd17 	ldw	r2,-12(fp)
 4000de4:	10c00015 	stw	r3,0(r2)
    pxTopOfStack--;
 4000de8:	e0bffd17 	ldw	r2,-12(fp)
 4000dec:	10bfff04 	addi	r2,r2,-4
 4000df0:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = portINITIAL_ESTATUS; 
 4000df4:	e0bffd17 	ldw	r2,-12(fp)
 4000df8:	00c00044 	movi	r3,1
 4000dfc:	10c00015 	stw	r3,0(r2)

    /* Space for R15 to R5. */    
    pxTopOfStack -= 12;
 4000e00:	e0bffd17 	ldw	r2,-12(fp)
 4000e04:	10bff404 	addi	r2,r2,-48
 4000e08:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = ( StackType_t ) pvParameters; 
 4000e0c:	e0fffb17 	ldw	r3,-20(fp)
 4000e10:	e0bffd17 	ldw	r2,-12(fp)
 4000e14:	10c00015 	stw	r3,0(r2)

    /* Space for R3 to R1, muldiv and RA. */
    pxTopOfStack -= 5;
 4000e18:	e0bffd17 	ldw	r2,-12(fp)
 4000e1c:	10bffb04 	addi	r2,r2,-20
 4000e20:	e0bffd15 	stw	r2,-12(fp)
    
    return pxTopOfStack;
 4000e24:	e0bffd17 	ldw	r2,-12(fp)
}
 4000e28:	e037883a 	mov	sp,fp
 4000e2c:	dfc00117 	ldw	ra,4(sp)
 4000e30:	df000017 	ldw	fp,0(sp)
 4000e34:	dec00204 	addi	sp,sp,8
 4000e38:	f800283a 	ret

04000e3c <xPortStartScheduler>:

/* 
 * See header file for description. 
 */
BaseType_t xPortStartScheduler( void )
{
 4000e3c:	defffe04 	addi	sp,sp,-8
 4000e40:	dfc00115 	stw	ra,4(sp)
 4000e44:	df000015 	stw	fp,0(sp)
 4000e48:	d839883a 	mov	fp,sp
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
 4000e4c:	4000e940 	call	4000e94 <prvSetupTimerInterrupt>
 4000e50:	00810034 	movhi	r2,1024
	
	/* Start the first task. */
    asm volatile (  " movia r2, restore_sp_from_pxCurrentTCB        \n"
 4000e54:	10805704 	addi	r2,r2,348
 4000e58:	1000683a 	jmp	r2
                    " jmp r2                                          " );

	/* Should not get here! */
	return 0;
 4000e5c:	0005883a 	mov	r2,zero
}
 4000e60:	e037883a 	mov	sp,fp
 4000e64:	dfc00117 	ldw	ra,4(sp)
 4000e68:	df000017 	ldw	fp,0(sp)
 4000e6c:	dec00204 	addi	sp,sp,8
 4000e70:	f800283a 	ret

04000e74 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 4000e74:	deffff04 	addi	sp,sp,-4
 4000e78:	df000015 	stw	fp,0(sp)
 4000e7c:	d839883a 	mov	fp,sp
	/* It is unlikely that the NIOS2 port will require this function as there
	is nothing to return to.  */
}
 4000e80:	0001883a 	nop
 4000e84:	e037883a 	mov	sp,fp
 4000e88:	df000017 	ldw	fp,0(sp)
 4000e8c:	dec00104 	addi	sp,sp,4
 4000e90:	f800283a 	ret

04000e94 <prvSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
 4000e94:	defffd04 	addi	sp,sp,-12
 4000e98:	dfc00215 	stw	ra,8(sp)
 4000e9c:	df000115 	stw	fp,4(sp)
 4000ea0:	df000104 	addi	fp,sp,4
	/* Try to register the interrupt handler. */
	if ( -EINVAL == _alt_ic_isr_register( SYS_CLK_IRQ_INTERRUPT_CONTROLLER_ID, SYS_CLK_IRQ, vPortSysTickHandler, 0x0, 0x0 ) )
 4000ea4:	d8000015 	stw	zero,0(sp)
 4000ea8:	000f883a 	mov	r7,zero
 4000eac:	01810034 	movhi	r6,1024
 4000eb0:	3183c904 	addi	r6,r6,3876
 4000eb4:	01400084 	movi	r5,2
 4000eb8:	0009883a 	mov	r4,zero
 4000ebc:	4000f680 	call	4000f68 <_alt_ic_isr_register>
 4000ec0:	10bffa98 	cmpnei	r2,r2,-22
 4000ec4:	1000021e 	bne	r2,zero,4000ed0 <prvSetupTimerInterrupt+0x3c>
	{ 
		/* Failed to install the Interrupt Handler. */
		asm( "break" );
 4000ec8:	003da03a 	break	0
 4000ecc:	00000c06 	br	4000f00 <prvSetupTimerInterrupt+0x6c>
	}
	else
	{
		/* Configure SysTick to interrupt at the requested rate. */
		IOWR_ALTERA_AVALON_TIMER_CONTROL( SYS_CLK_BASE, ALTERA_AVALON_TIMER_CONTROL_STOP_MSK );
 4000ed0:	00c00204 	movi	r3,8
 4000ed4:	00820034 	movhi	r2,2048
 4000ed8:	10c40135 	stwio	r3,4100(r2)
		IOWR_ALTERA_AVALON_TIMER_PERIODL( SYS_CLK_BASE, ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) & 0xFFFF );
 4000edc:	00e1a814 	movui	r3,34464
 4000ee0:	00820034 	movhi	r2,2048
 4000ee4:	10c40235 	stwio	r3,4104(r2)
		IOWR_ALTERA_AVALON_TIMER_PERIODH( SYS_CLK_BASE, ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) >> 16 );
 4000ee8:	00c00044 	movi	r3,1
 4000eec:	00820034 	movhi	r2,2048
 4000ef0:	10c40335 	stwio	r3,4108(r2)
		IOWR_ALTERA_AVALON_TIMER_CONTROL( SYS_CLK_BASE, ALTERA_AVALON_TIMER_CONTROL_CONT_MSK | ALTERA_AVALON_TIMER_CONTROL_START_MSK | ALTERA_AVALON_TIMER_CONTROL_ITO_MSK );	
 4000ef4:	00c001c4 	movi	r3,7
 4000ef8:	00820034 	movhi	r2,2048
 4000efc:	10c40135 	stwio	r3,4100(r2)
	} 

	/* Clear any already pending interrupts generated by the Timer. */
	IOWR_ALTERA_AVALON_TIMER_STATUS( SYS_CLK_BASE, ~ALTERA_AVALON_TIMER_STATUS_TO_MSK );
 4000f00:	00ffff84 	movi	r3,-2
 4000f04:	00820034 	movhi	r2,2048
 4000f08:	10c40035 	stwio	r3,4096(r2)
}
 4000f0c:	0001883a 	nop
 4000f10:	e037883a 	mov	sp,fp
 4000f14:	dfc00117 	ldw	ra,4(sp)
 4000f18:	df000017 	ldw	fp,0(sp)
 4000f1c:	dec00204 	addi	sp,sp,8
 4000f20:	f800283a 	ret

04000f24 <vPortSysTickHandler>:
/*-----------------------------------------------------------*/

void vPortSysTickHandler( void * context)
{
 4000f24:	defffd04 	addi	sp,sp,-12
 4000f28:	dfc00215 	stw	ra,8(sp)
 4000f2c:	df000115 	stw	fp,4(sp)
 4000f30:	df000104 	addi	fp,sp,4
 4000f34:	e13fff15 	stw	r4,-4(fp)
	/* Increment the kernel tick. */
	if( xTaskIncrementTick() != pdFALSE )
 4000f38:	4004af40 	call	4004af4 <xTaskIncrementTick>
 4000f3c:	10000126 	beq	r2,zero,4000f44 <vPortSysTickHandler+0x20>
	{
        vTaskSwitchContext();
 4000f40:	4004e300 	call	4004e30 <vTaskSwitchContext>
	}
		
	/* Clear the interrupt. */
	IOWR_ALTERA_AVALON_TIMER_STATUS( SYS_CLK_BASE, ~ALTERA_AVALON_TIMER_STATUS_TO_MSK );
 4000f44:	00ffff84 	movi	r3,-2
 4000f48:	00820034 	movhi	r2,2048
 4000f4c:	10c40035 	stwio	r3,4096(r2)
}
 4000f50:	0001883a 	nop
 4000f54:	e037883a 	mov	sp,fp
 4000f58:	dfc00117 	ldw	ra,4(sp)
 4000f5c:	df000017 	ldw	fp,0(sp)
 4000f60:	dec00204 	addi	sp,sp,8
 4000f64:	f800283a 	ret

04000f68 <_alt_ic_isr_register>:
 * kernel has its scheduler started so that contexts are saved and switched 
 * correctly.
 */
int _alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr,
  void *isr_context, void *flags)
{
 4000f68:	defff604 	addi	sp,sp,-40
 4000f6c:	dfc00915 	stw	ra,36(sp)
 4000f70:	df000815 	stw	fp,32(sp)
 4000f74:	df000804 	addi	fp,sp,32
 4000f78:	e13ffb15 	stw	r4,-20(fp)
 4000f7c:	e17ffa15 	stw	r5,-24(fp)
 4000f80:	e1bff915 	stw	r6,-28(fp)
 4000f84:	e1fff815 	stw	r7,-32(fp)
	int rc = -EINVAL;  
 4000f88:	00bffa84 	movi	r2,-22
 4000f8c:	e0bfff15 	stw	r2,-4(fp)
	alt_irq_context status;
	int id = irq;             /* IRQ interpreted as the interrupt ID. */
 4000f90:	e0bffa17 	ldw	r2,-24(fp)
 4000f94:	e0bffe15 	stw	r2,-8(fp)

	if (id < ALT_NIRQ)
 4000f98:	e0bffe17 	ldw	r2,-8(fp)
 4000f9c:	10800808 	cmpgei	r2,r2,32
 4000fa0:	1000201e 	bne	r2,zero,4001024 <_alt_ic_isr_register+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 4000fa4:	0005303a 	rdctl	r2,status
 4000fa8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 4000fac:	e0fffc17 	ldw	r3,-16(fp)
 4000fb0:	00bfff84 	movi	r2,-2
 4000fb4:	1884703a 	and	r2,r3,r2
 4000fb8:	1001703a 	wrctl	status,r2
  
  return context;
 4000fbc:	e0bffc17 	ldw	r2,-16(fp)
		 * interrupts are disabled while the handler tables are updated to ensure
		 * that an interrupt doesn't occur while the tables are in an inconsistant
		 * state.
		 */
	
		status = alt_irq_disable_all ();
 4000fc0:	e0bffd15 	stw	r2,-12(fp)
	
		alt_irq[id].handler = isr;
 4000fc4:	e0bffe17 	ldw	r2,-8(fp)
 4000fc8:	100890fa 	slli	r4,r2,3
 4000fcc:	e0fff917 	ldw	r3,-28(fp)
 4000fd0:	008120b4 	movhi	r2,1154
 4000fd4:	2085883a 	add	r2,r4,r2
 4000fd8:	10fb3015 	stw	r3,-4928(r2)
		alt_irq[id].context = isr_context;
 4000fdc:	e0bffe17 	ldw	r2,-8(fp)
 4000fe0:	100890fa 	slli	r4,r2,3
 4000fe4:	e0fff817 	ldw	r3,-32(fp)
 4000fe8:	008120b4 	movhi	r2,1154
 4000fec:	2085883a 	add	r2,r4,r2
 4000ff0:	10fb3115 	stw	r3,-4924(r2)
	
		rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
 4000ff4:	e0bff917 	ldw	r2,-28(fp)
 4000ff8:	10000526 	beq	r2,zero,4001010 <_alt_ic_isr_register+0xa8>
 4000ffc:	e0bffe17 	ldw	r2,-8(fp)
 4001000:	100b883a 	mov	r5,r2
 4001004:	e13ffb17 	ldw	r4,-20(fp)
 4001008:	40180980 	call	4018098 <alt_ic_irq_enable>
 400100c:	00000406 	br	4001020 <_alt_ic_isr_register+0xb8>
 4001010:	e0bffe17 	ldw	r2,-8(fp)
 4001014:	100b883a 	mov	r5,r2
 4001018:	e13ffb17 	ldw	r4,-20(fp)
 400101c:	40181200 	call	4018120 <alt_ic_irq_disable>
 4001020:	e0bfff15 	stw	r2,-4(fp)
	
		/* alt_irq_enable_all(status); This line is removed to prevent the interrupt from being immediately enabled. */
	}
    
	return rc; 
 4001024:	e0bfff17 	ldw	r2,-4(fp)
}
 4001028:	e037883a 	mov	sp,fp
 400102c:	dfc00117 	ldw	ra,4(sp)
 4001030:	df000017 	ldw	fp,0(sp)
 4001034:	dec00204 	addi	sp,sp,8
 4001038:	f800283a 	ret

0400103c <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
 400103c:	defffc04 	addi	sp,sp,-16
 4001040:	dfc00315 	stw	ra,12(sp)
 4001044:	df000215 	stw	fp,8(sp)
 4001048:	df000204 	addi	fp,sp,8
 400104c:	e13ffe15 	stw	r4,-8(fp)
    void * pvReturn = NULL;
 4001050:	e03fff15 	stw	zero,-4(fp)
    static uint8_t * pucAlignedHeap = NULL;

    /* Ensure that blocks are always aligned. */
    #if ( portBYTE_ALIGNMENT != 1 )
    {
        if( xWantedSize & portBYTE_ALIGNMENT_MASK )
 4001054:	e0bffe17 	ldw	r2,-8(fp)
 4001058:	108000cc 	andi	r2,r2,3
 400105c:	10000d26 	beq	r2,zero,4001094 <pvPortMalloc+0x58>
        {
            /* Byte alignment required. Check for overflow. */
            if( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) > xWantedSize )
 4001060:	e0fffe17 	ldw	r3,-8(fp)
 4001064:	00bfff04 	movi	r2,-4
 4001068:	1884703a 	and	r2,r3,r2
 400106c:	10800104 	addi	r2,r2,4
 4001070:	e0fffe17 	ldw	r3,-8(fp)
 4001074:	1880062e 	bgeu	r3,r2,4001090 <pvPortMalloc+0x54>
            {
                xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 4001078:	e0fffe17 	ldw	r3,-8(fp)
 400107c:	00bfff04 	movi	r2,-4
 4001080:	1884703a 	and	r2,r3,r2
 4001084:	10800104 	addi	r2,r2,4
 4001088:	e0bffe15 	stw	r2,-8(fp)
 400108c:	00000106 	br	4001094 <pvPortMalloc+0x58>
            }
            else
            {
                xWantedSize = 0;
 4001090:	e03ffe15 	stw	zero,-8(fp)
            }
        }
    }
    #endif /* if ( portBYTE_ALIGNMENT != 1 ) */

    vTaskSuspendAll();
 4001094:	40046f00 	call	40046f0 <vTaskSuspendAll>
    {
        if( pucAlignedHeap == NULL )
 4001098:	d0a71217 	ldw	r2,-25528(gp)
 400109c:	1000051e 	bne	r2,zero,40010b4 <pvPortMalloc+0x78>
        {
            /* Ensure the heap starts on a correctly aligned boundary. */
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT - 1 ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
 40010a0:	008100b4 	movhi	r2,1026
 40010a4:	10baf4c4 	addi	r2,r2,-5165
 40010a8:	00ffff04 	movi	r3,-4
 40010ac:	10c4703a 	and	r2,r2,r3
 40010b0:	d0a71215 	stw	r2,-25528(gp)
        }

        /* Check there is enough room left for the allocation and. */
        if( ( xWantedSize > 0 ) &&                                /* valid size */
 40010b4:	e0bffe17 	ldw	r2,-8(fp)
 40010b8:	10001326 	beq	r2,zero,4001108 <pvPortMalloc+0xcc>
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 40010bc:	d0e71117 	ldw	r3,-25532(gp)
 40010c0:	e0bffe17 	ldw	r2,-8(fp)
 40010c4:	1887883a 	add	r3,r3,r2
        if( ( xWantedSize > 0 ) &&                                /* valid size */
 40010c8:	00802034 	movhi	r2,128
 40010cc:	10bffec4 	addi	r2,r2,-5
 40010d0:	10c00d36 	bltu	r2,r3,4001108 <pvPortMalloc+0xcc>
            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */
 40010d4:	d0e71117 	ldw	r3,-25532(gp)
 40010d8:	e0bffe17 	ldw	r2,-8(fp)
 40010dc:	1885883a 	add	r2,r3,r2
 40010e0:	d0e71117 	ldw	r3,-25532(gp)
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 40010e4:	1880082e 	bgeu	r3,r2,4001108 <pvPortMalloc+0xcc>
        {
            /* Return the next free byte then increment the index past this
             * block. */
            pvReturn = pucAlignedHeap + xNextFreeByte;
 40010e8:	d0e71217 	ldw	r3,-25528(gp)
 40010ec:	d0a71117 	ldw	r2,-25532(gp)
 40010f0:	1885883a 	add	r2,r3,r2
 40010f4:	e0bfff15 	stw	r2,-4(fp)
            xNextFreeByte += xWantedSize;
 40010f8:	d0e71117 	ldw	r3,-25532(gp)
 40010fc:	e0bffe17 	ldw	r2,-8(fp)
 4001100:	1885883a 	add	r2,r3,r2
 4001104:	d0a71115 	stw	r2,-25532(gp)
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
 4001108:	400471c0 	call	400471c <xTaskResumeAll>
            vApplicationMallocFailedHook();
        }
    }
    #endif

    return pvReturn;
 400110c:	e0bfff17 	ldw	r2,-4(fp)
}
 4001110:	e037883a 	mov	sp,fp
 4001114:	dfc00117 	ldw	ra,4(sp)
 4001118:	df000017 	ldw	fp,0(sp)
 400111c:	dec00204 	addi	sp,sp,8
 4001120:	f800283a 	ret

04001124 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
 4001124:	defffe04 	addi	sp,sp,-8
 4001128:	df000115 	stw	fp,4(sp)
 400112c:	df000104 	addi	fp,sp,4
 4001130:	e13fff15 	stw	r4,-4(fp)
     * https://www.FreeRTOS.org for more information. */
    ( void ) pv;

    /* Force an assert as it is invalid to call this function. */
    configASSERT( pv == NULL );
}
 4001134:	0001883a 	nop
 4001138:	e037883a 	mov	sp,fp
 400113c:	df000017 	ldw	fp,0(sp)
 4001140:	dec00104 	addi	sp,sp,4
 4001144:	f800283a 	ret

04001148 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
 4001148:	deffff04 	addi	sp,sp,-4
 400114c:	df000015 	stw	fp,0(sp)
 4001150:	d839883a 	mov	fp,sp
    /* Only required when static memory is not cleared. */
    xNextFreeByte = ( size_t ) 0;
 4001154:	d0271115 	stw	zero,-25532(gp)
}
 4001158:	0001883a 	nop
 400115c:	e037883a 	mov	sp,fp
 4001160:	df000017 	ldw	fp,0(sp)
 4001164:	dec00104 	addi	sp,sp,4
 4001168:	f800283a 	ret

0400116c <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
 400116c:	deffff04 	addi	sp,sp,-4
 4001170:	df000015 	stw	fp,0(sp)
 4001174:	d839883a 	mov	fp,sp
    return( configADJUSTED_HEAP_SIZE - xNextFreeByte );
 4001178:	d0e71117 	ldw	r3,-25532(gp)
 400117c:	00802034 	movhi	r2,128
 4001180:	10bfff04 	addi	r2,r2,-4
 4001184:	10c5c83a 	sub	r2,r2,r3
}
 4001188:	e037883a 	mov	sp,fp
 400118c:	df000017 	ldw	fp,0(sp)
 4001190:	dec00104 	addi	sp,sp,4
 4001194:	f800283a 	ret

04001198 <xQueueGenericReset>:
    }
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
 4001198:	defff404 	addi	sp,sp,-48
 400119c:	dfc00b15 	stw	ra,44(sp)
 40011a0:	df000a15 	stw	fp,40(sp)
 40011a4:	dd400915 	stw	r21,36(sp)
 40011a8:	dd000815 	stw	r20,32(sp)
 40011ac:	dcc00715 	stw	r19,28(sp)
 40011b0:	dc800615 	stw	r18,24(sp)
 40011b4:	dc400515 	stw	r17,20(sp)
 40011b8:	dc000415 	stw	r16,16(sp)
 40011bc:	df000a04 	addi	fp,sp,40
 40011c0:	e13ff715 	stw	r4,-36(fp)
 40011c4:	e17ff615 	stw	r5,-40(fp)
    BaseType_t xReturn = pdPASS;
 40011c8:	00800044 	movi	r2,1
 40011cc:	e0bff915 	stw	r2,-28(fp)
    Queue_t * const pxQueue = xQueue;
 40011d0:	e0bff717 	ldw	r2,-36(fp)
 40011d4:	e0bff815 	stw	r2,-32(fp)

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
 40011d8:	e0bff817 	ldw	r2,-32(fp)
 40011dc:	10007126 	beq	r2,zero,40013a4 <xQueueGenericReset+0x20c>
        ( pxQueue->uxLength >= 1U ) &&
 40011e0:	e0bff817 	ldw	r2,-32(fp)
 40011e4:	10800f17 	ldw	r2,60(r2)
    if( ( pxQueue != NULL ) &&
 40011e8:	10006e26 	beq	r2,zero,40013a4 <xQueueGenericReset+0x20c>
        /* Check for multiplication overflow. */
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
 40011ec:	e0bff817 	ldw	r2,-32(fp)
 40011f0:	14001017 	ldw	r16,64(r2)
 40011f4:	e0bff817 	ldw	r2,-32(fp)
 40011f8:	14400f17 	ldw	r17,60(r2)
 40011fc:	0025883a 	mov	r18,zero
 4001200:	8008d43a 	srli	r4,r16,16
 4001204:	8804d43a 	srli	r2,r17,16
 4001208:	20ffffcc 	andi	r3,r4,65535
 400120c:	18000b1e 	bne	r3,zero,400123c <xQueueGenericReset+0xa4>
 4001210:	10ffffcc 	andi	r3,r2,65535
 4001214:	1800061e 	bne	r3,zero,4001230 <xQueueGenericReset+0x98>
 4001218:	80bfffcc 	andi	r2,r16,65535
 400121c:	88ffffcc 	andi	r3,r17,65535
 4001220:	180b883a 	mov	r5,r3
 4001224:	1009883a 	mov	r4,r2
 4001228:	40075a40 	call	40075a4 <__mulsi3>
 400122c:	00001f06 	br	40012ac <xQueueGenericReset+0x114>
 4001230:	1029883a 	mov	r20,r2
 4001234:	802b883a 	mov	r21,r16
 4001238:	00000406 	br	400124c <xQueueGenericReset+0xb4>
 400123c:	10bfffcc 	andi	r2,r2,65535
 4001240:	1000131e 	bne	r2,zero,4001290 <xQueueGenericReset+0xf8>
 4001244:	2029883a 	mov	r20,r4
 4001248:	882b883a 	mov	r21,r17
 400124c:	80bfffcc 	andi	r2,r16,65535
 4001250:	88ffffcc 	andi	r3,r17,65535
 4001254:	180b883a 	mov	r5,r3
 4001258:	1009883a 	mov	r4,r2
 400125c:	40075a40 	call	40075a4 <__mulsi3>
 4001260:	1027883a 	mov	r19,r2
 4001264:	a8bfffcc 	andi	r2,r21,65535
 4001268:	a0ffffcc 	andi	r3,r20,65535
 400126c:	180b883a 	mov	r5,r3
 4001270:	1009883a 	mov	r4,r2
 4001274:	40075a40 	call	40075a4 <__mulsi3>
 4001278:	9806d43a 	srli	r3,r19,16
 400127c:	10c5883a 	add	r2,r2,r3
 4001280:	1005d43a 	srai	r2,r2,16
 4001284:	10bfffcc 	andi	r2,r2,65535
 4001288:	1000041e 	bne	r2,zero,400129c <xQueueGenericReset+0x104>
 400128c:	00000706 	br	40012ac <xQueueGenericReset+0x114>
 4001290:	880b883a 	mov	r5,r17
 4001294:	8009883a 	mov	r4,r16
 4001298:	40075a40 	call	40075a4 <__mulsi3>
 400129c:	880b883a 	mov	r5,r17
 40012a0:	8009883a 	mov	r4,r16
 40012a4:	40075a40 	call	40075a4 <__mulsi3>
 40012a8:	04800044 	movi	r18,1
 40012ac:	9005883a 	mov	r2,r18
        ( pxQueue->uxLength >= 1U ) &&
 40012b0:	10003c1e 	bne	r2,zero,40013a4 <xQueueGenericReset+0x20c>
    {
        taskENTER_CRITICAL();
 40012b4:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
        {
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 40012b8:	e0bff817 	ldw	r2,-32(fp)
 40012bc:	14000017 	ldw	r16,0(r2)
 40012c0:	e0bff817 	ldw	r2,-32(fp)
 40012c4:	10c00f17 	ldw	r3,60(r2)
 40012c8:	e0bff817 	ldw	r2,-32(fp)
 40012cc:	10801017 	ldw	r2,64(r2)
 40012d0:	100b883a 	mov	r5,r2
 40012d4:	1809883a 	mov	r4,r3
 40012d8:	40075a40 	call	40075a4 <__mulsi3>
 40012dc:	8087883a 	add	r3,r16,r2
 40012e0:	e0bff817 	ldw	r2,-32(fp)
 40012e4:	10c00215 	stw	r3,8(r2)
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 40012e8:	e0bff817 	ldw	r2,-32(fp)
 40012ec:	10000e15 	stw	zero,56(r2)
            pxQueue->pcWriteTo = pxQueue->pcHead;
 40012f0:	e0bff817 	ldw	r2,-32(fp)
 40012f4:	10c00017 	ldw	r3,0(r2)
 40012f8:	e0bff817 	ldw	r2,-32(fp)
 40012fc:	10c00115 	stw	r3,4(r2)
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 4001300:	e0bff817 	ldw	r2,-32(fp)
 4001304:	14000017 	ldw	r16,0(r2)
 4001308:	e0bff817 	ldw	r2,-32(fp)
 400130c:	10800f17 	ldw	r2,60(r2)
 4001310:	10ffffc4 	addi	r3,r2,-1
 4001314:	e0bff817 	ldw	r2,-32(fp)
 4001318:	10801017 	ldw	r2,64(r2)
 400131c:	100b883a 	mov	r5,r2
 4001320:	1809883a 	mov	r4,r3
 4001324:	40075a40 	call	40075a4 <__mulsi3>
 4001328:	8087883a 	add	r3,r16,r2
 400132c:	e0bff817 	ldw	r2,-32(fp)
 4001330:	10c00315 	stw	r3,12(r2)
            pxQueue->cRxLock = queueUNLOCKED;
 4001334:	e0bff817 	ldw	r2,-32(fp)
 4001338:	00ffffc4 	movi	r3,-1
 400133c:	10c01105 	stb	r3,68(r2)
            pxQueue->cTxLock = queueUNLOCKED;
 4001340:	e0bff817 	ldw	r2,-32(fp)
 4001344:	00ffffc4 	movi	r3,-1
 4001348:	10c01145 	stb	r3,69(r2)

            if( xNewQueue == pdFALSE )
 400134c:	e0bff617 	ldw	r2,-40(fp)
 4001350:	10000a1e 	bne	r2,zero,400137c <xQueueGenericReset+0x1e4>
                /* If there are tasks blocked waiting to read from the queue, then
                 * the tasks will remain blocked as after this function exits the queue
                 * will still be empty.  If there are tasks blocked waiting to write to
                 * the queue, then one should be unblocked as after this function exits
                 * it will be possible to write to it. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 4001354:	e0bff817 	ldw	r2,-32(fp)
 4001358:	10800417 	ldw	r2,16(r2)
 400135c:	10000f26 	beq	r2,zero,400139c <xQueueGenericReset+0x204>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 4001360:	e0bff817 	ldw	r2,-32(fp)
 4001364:	10800404 	addi	r2,r2,16
 4001368:	1009883a 	mov	r4,r2
 400136c:	400502c0 	call	400502c <xTaskRemoveFromEventList>
 4001370:	10000a26 	beq	r2,zero,400139c <xQueueGenericReset+0x204>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
 4001374:	003b683a 	trap	0
 4001378:	00000806 	br	400139c <xQueueGenericReset+0x204>
                }
            }
            else
            {
                /* Ensure the event queues start in the correct state. */
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 400137c:	e0bff817 	ldw	r2,-32(fp)
 4001380:	10800404 	addi	r2,r2,16
 4001384:	1009883a 	mov	r4,r2
 4001388:	4000aa00 	call	4000aa0 <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 400138c:	e0bff817 	ldw	r2,-32(fp)
 4001390:	10800904 	addi	r2,r2,36
 4001394:	1009883a 	mov	r4,r2
 4001398:	4000aa00 	call	4000aa0 <vListInitialise>
            }
        }
        taskEXIT_CRITICAL();
 400139c:	4005fd00 	call	4005fd0 <vTaskExitCritical>
 40013a0:	00000106 	br	40013a8 <xQueueGenericReset+0x210>
    }
    else
    {
        xReturn = pdFAIL;
 40013a4:	e03ff915 	stw	zero,-28(fp)

    configASSERT( xReturn != pdFAIL );

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return xReturn;
 40013a8:	e0bff917 	ldw	r2,-28(fp)
}
 40013ac:	e6fffa04 	addi	sp,fp,-24
 40013b0:	dfc00717 	ldw	ra,28(sp)
 40013b4:	df000617 	ldw	fp,24(sp)
 40013b8:	dd400517 	ldw	r21,20(sp)
 40013bc:	dd000417 	ldw	r20,16(sp)
 40013c0:	dcc00317 	ldw	r19,12(sp)
 40013c4:	dc800217 	ldw	r18,8(sp)
 40013c8:	dc400117 	ldw	r17,4(sp)
 40013cc:	dc000017 	ldw	r16,0(sp)
 40013d0:	dec00804 	addi	sp,sp,32
 40013d4:	f800283a 	ret

040013d8 <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
 40013d8:	defff304 	addi	sp,sp,-52
 40013dc:	dfc00c15 	stw	ra,48(sp)
 40013e0:	df000b15 	stw	fp,44(sp)
 40013e4:	dcc00a15 	stw	r19,40(sp)
 40013e8:	dc800915 	stw	r18,36(sp)
 40013ec:	dc400815 	stw	r17,32(sp)
 40013f0:	dc000715 	stw	r16,28(sp)
 40013f4:	df000b04 	addi	fp,sp,44
 40013f8:	e13ff815 	stw	r4,-32(fp)
 40013fc:	e17ff715 	stw	r5,-36(fp)
 4001400:	3005883a 	mov	r2,r6
 4001404:	e0bff605 	stb	r2,-40(fp)
        Queue_t * pxNewQueue = NULL;
 4001408:	e03ffb15 	stw	zero,-20(fp)
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
 400140c:	e0bff817 	ldw	r2,-32(fp)
 4001410:	10005026 	beq	r2,zero,4001554 <xQueueGenericCreate+0x17c>
            /* Check for multiplication overflow. */
            ( ( SIZE_MAX / uxQueueLength ) >= uxItemSize ) &&
 4001414:	0021883a 	mov	r16,zero
 4001418:	e0bff717 	ldw	r2,-36(fp)
 400141c:	100cd43a 	srli	r6,r2,16
 4001420:	e0fff717 	ldw	r3,-36(fp)
 4001424:	e0bff817 	ldw	r2,-32(fp)
 4001428:	1008d43a 	srli	r4,r2,16
 400142c:	e0bff817 	ldw	r2,-32(fp)
 4001430:	317fffcc 	andi	r5,r6,65535
 4001434:	28000b1e 	bne	r5,zero,4001464 <xQueueGenericCreate+0x8c>
 4001438:	217fffcc 	andi	r5,r4,65535
 400143c:	2800061e 	bne	r5,zero,4001458 <xQueueGenericCreate+0x80>
 4001440:	18ffffcc 	andi	r3,r3,65535
 4001444:	10bfffcc 	andi	r2,r2,65535
 4001448:	100b883a 	mov	r5,r2
 400144c:	1809883a 	mov	r4,r3
 4001450:	40075a40 	call	40075a4 <__mulsi3>
 4001454:	00001f06 	br	40014d4 <xQueueGenericCreate+0xfc>
 4001458:	2025883a 	mov	r18,r4
 400145c:	1827883a 	mov	r19,r3
 4001460:	00000406 	br	4001474 <xQueueGenericCreate+0x9c>
 4001464:	213fffcc 	andi	r4,r4,65535
 4001468:	2000131e 	bne	r4,zero,40014b8 <xQueueGenericCreate+0xe0>
 400146c:	3025883a 	mov	r18,r6
 4001470:	1027883a 	mov	r19,r2
 4001474:	18ffffcc 	andi	r3,r3,65535
 4001478:	10bfffcc 	andi	r2,r2,65535
 400147c:	100b883a 	mov	r5,r2
 4001480:	1809883a 	mov	r4,r3
 4001484:	40075a40 	call	40075a4 <__mulsi3>
 4001488:	1023883a 	mov	r17,r2
 400148c:	98bfffcc 	andi	r2,r19,65535
 4001490:	90ffffcc 	andi	r3,r18,65535
 4001494:	180b883a 	mov	r5,r3
 4001498:	1009883a 	mov	r4,r2
 400149c:	40075a40 	call	40075a4 <__mulsi3>
 40014a0:	8806d43a 	srli	r3,r17,16
 40014a4:	10c5883a 	add	r2,r2,r3
 40014a8:	1005d43a 	srai	r2,r2,16
 40014ac:	10bfffcc 	andi	r2,r2,65535
 40014b0:	1000041e 	bne	r2,zero,40014c4 <xQueueGenericCreate+0xec>
 40014b4:	00000706 	br	40014d4 <xQueueGenericCreate+0xfc>
 40014b8:	e17ff817 	ldw	r5,-32(fp)
 40014bc:	e13ff717 	ldw	r4,-36(fp)
 40014c0:	40075a40 	call	40075a4 <__mulsi3>
 40014c4:	e17ff817 	ldw	r5,-32(fp)
 40014c8:	e13ff717 	ldw	r4,-36(fp)
 40014cc:	40075a40 	call	40075a4 <__mulsi3>
 40014d0:	04000044 	movi	r16,1
 40014d4:	8005883a 	mov	r2,r16
        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
 40014d8:	10001e1e 	bne	r2,zero,4001554 <xQueueGenericCreate+0x17c>
            /* Check for addition overflow. */
            ( ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
 40014dc:	e17ff717 	ldw	r5,-36(fp)
 40014e0:	e13ff817 	ldw	r4,-32(fp)
 40014e4:	40075a40 	call	40075a4 <__mulsi3>
 40014e8:	1007883a 	mov	r3,r2
            ( ( SIZE_MAX / uxQueueLength ) >= uxItemSize ) &&
 40014ec:	00bfedc4 	movi	r2,-73
 40014f0:	10c01836 	bltu	r2,r3,4001554 <xQueueGenericCreate+0x17c>
        {
            /* Allocate enough space to hold the maximum number of items that
             * can be in the queue at any time.  It is valid for uxItemSize to be
             * zero in the case the queue is used as a semaphore. */
            xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 40014f4:	e17ff717 	ldw	r5,-36(fp)
 40014f8:	e13ff817 	ldw	r4,-32(fp)
 40014fc:	40075a40 	call	40075a4 <__mulsi3>
 4001500:	e0bffa15 	stw	r2,-24(fp)
             * alignment requirements of the Queue_t structure - which in this case
             * is an int8_t *.  Therefore, whenever the stack alignment requirements
             * are greater than or equal to the pointer to char requirements the cast
             * is safe.  In other cases alignment requirements are not strict (one or
             * two bytes). */
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
 4001504:	e0bffa17 	ldw	r2,-24(fp)
 4001508:	10801204 	addi	r2,r2,72
 400150c:	1009883a 	mov	r4,r2
 4001510:	400103c0 	call	400103c <pvPortMalloc>
 4001514:	e0bffb15 	stw	r2,-20(fp)

            if( pxNewQueue != NULL )
 4001518:	e0bffb17 	ldw	r2,-20(fp)
 400151c:	10000d26 	beq	r2,zero,4001554 <xQueueGenericCreate+0x17c>
            {
                /* Jump past the queue structure to find the location of the queue
                 * storage area. */
                pucQueueStorage = ( uint8_t * ) pxNewQueue;
 4001520:	e0bffb17 	ldw	r2,-20(fp)
 4001524:	e0bff915 	stw	r2,-28(fp)
                pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 4001528:	e0bff917 	ldw	r2,-28(fp)
 400152c:	10801204 	addi	r2,r2,72
 4001530:	e0bff915 	stw	r2,-28(fp)
                     * deleted. */
                    pxNewQueue->ucStaticallyAllocated = pdFALSE;
                }
                #endif /* configSUPPORT_STATIC_ALLOCATION */

                prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 4001534:	e0fff603 	ldbu	r3,-40(fp)
 4001538:	e0bffb17 	ldw	r2,-20(fp)
 400153c:	d8800015 	stw	r2,0(sp)
 4001540:	180f883a 	mov	r7,r3
 4001544:	e1bff917 	ldw	r6,-28(fp)
 4001548:	e17ff717 	ldw	r5,-36(fp)
 400154c:	e13ff817 	ldw	r4,-32(fp)
 4001550:	400157c0 	call	400157c <prvInitialiseNewQueue>
        {
            configASSERT( pxNewQueue );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
 4001554:	e0bffb17 	ldw	r2,-20(fp)
    }
 4001558:	e6fffc04 	addi	sp,fp,-16
 400155c:	dfc00517 	ldw	ra,20(sp)
 4001560:	df000417 	ldw	fp,16(sp)
 4001564:	dcc00317 	ldw	r19,12(sp)
 4001568:	dc800217 	ldw	r18,8(sp)
 400156c:	dc400117 	ldw	r17,4(sp)
 4001570:	dc000017 	ldw	r16,0(sp)
 4001574:	dec00604 	addi	sp,sp,24
 4001578:	f800283a 	ret

0400157c <prvInitialiseNewQueue>:
static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
                                   const UBaseType_t uxItemSize,
                                   uint8_t * pucQueueStorage,
                                   const uint8_t ucQueueType,
                                   Queue_t * pxNewQueue )
{
 400157c:	defffa04 	addi	sp,sp,-24
 4001580:	dfc00515 	stw	ra,20(sp)
 4001584:	df000415 	stw	fp,16(sp)
 4001588:	df000404 	addi	fp,sp,16
 400158c:	e13fff15 	stw	r4,-4(fp)
 4001590:	e17ffe15 	stw	r5,-8(fp)
 4001594:	e1bffd15 	stw	r6,-12(fp)
 4001598:	3805883a 	mov	r2,r7
 400159c:	e0bffc05 	stb	r2,-16(fp)
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
 40015a0:	e0bffe17 	ldw	r2,-8(fp)
 40015a4:	1000041e 	bne	r2,zero,40015b8 <prvInitialiseNewQueue+0x3c>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 40015a8:	e0800217 	ldw	r2,8(fp)
 40015ac:	e0c00217 	ldw	r3,8(fp)
 40015b0:	10c00015 	stw	r3,0(r2)
 40015b4:	00000306 	br	40015c4 <prvInitialiseNewQueue+0x48>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 40015b8:	e0800217 	ldw	r2,8(fp)
 40015bc:	e0fffd17 	ldw	r3,-12(fp)
 40015c0:	10c00015 	stw	r3,0(r2)
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
 40015c4:	e0800217 	ldw	r2,8(fp)
 40015c8:	e0ffff17 	ldw	r3,-4(fp)
 40015cc:	10c00f15 	stw	r3,60(r2)
    pxNewQueue->uxItemSize = uxItemSize;
 40015d0:	e0800217 	ldw	r2,8(fp)
 40015d4:	e0fffe17 	ldw	r3,-8(fp)
 40015d8:	10c01015 	stw	r3,64(r2)
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 40015dc:	01400044 	movi	r5,1
 40015e0:	e1000217 	ldw	r4,8(fp)
 40015e4:	40011980 	call	4001198 <xQueueGenericReset>
        pxNewQueue->pxQueueSetContainer = NULL;
    }
    #endif /* configUSE_QUEUE_SETS */

    traceQUEUE_CREATE( pxNewQueue );
}
 40015e8:	0001883a 	nop
 40015ec:	e037883a 	mov	sp,fp
 40015f0:	dfc00117 	ldw	ra,4(sp)
 40015f4:	df000017 	ldw	fp,0(sp)
 40015f8:	dec00204 	addi	sp,sp,8
 40015fc:	f800283a 	ret

04001600 <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    static void prvInitialiseMutex( Queue_t * pxNewQueue )
    {
 4001600:	defffd04 	addi	sp,sp,-12
 4001604:	dfc00215 	stw	ra,8(sp)
 4001608:	df000115 	stw	fp,4(sp)
 400160c:	df000104 	addi	fp,sp,4
 4001610:	e13fff15 	stw	r4,-4(fp)
        if( pxNewQueue != NULL )
 4001614:	e0bfff17 	ldw	r2,-4(fp)
 4001618:	10000b26 	beq	r2,zero,4001648 <prvInitialiseMutex+0x48>
        {
            /* The queue create function will set all the queue structure members
            * correctly for a generic queue, but this function is creating a
            * mutex.  Overwrite those members that need to be set differently -
            * in particular the information required for priority inheritance. */
            pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 400161c:	e0bfff17 	ldw	r2,-4(fp)
 4001620:	10000215 	stw	zero,8(r2)
            pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 4001624:	e0bfff17 	ldw	r2,-4(fp)
 4001628:	10000015 	stw	zero,0(r2)

            /* In case this is a recursive mutex. */
            pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
 400162c:	e0bfff17 	ldw	r2,-4(fp)
 4001630:	10000315 	stw	zero,12(r2)

            traceCREATE_MUTEX( pxNewQueue );

            /* Start with the semaphore in the expected state. */
            ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 4001634:	000f883a 	mov	r7,zero
 4001638:	000d883a 	mov	r6,zero
 400163c:	000b883a 	mov	r5,zero
 4001640:	e13fff17 	ldw	r4,-4(fp)
 4001644:	40018580 	call	4001858 <xQueueGenericSend>
        }
        else
        {
            traceCREATE_MUTEX_FAILED();
        }
    }
 4001648:	0001883a 	nop
 400164c:	e037883a 	mov	sp,fp
 4001650:	dfc00117 	ldw	ra,4(sp)
 4001654:	df000017 	ldw	fp,0(sp)
 4001658:	dec00204 	addi	sp,sp,8
 400165c:	f800283a 	ret

04001660 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

    QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
    {
 4001660:	defffa04 	addi	sp,sp,-24
 4001664:	dfc00515 	stw	ra,20(sp)
 4001668:	df000415 	stw	fp,16(sp)
 400166c:	df000404 	addi	fp,sp,16
 4001670:	2005883a 	mov	r2,r4
 4001674:	e0bffc05 	stb	r2,-16(fp)
        QueueHandle_t xNewQueue;
        const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 4001678:	00800044 	movi	r2,1
 400167c:	e0bfff15 	stw	r2,-4(fp)
 4001680:	e03ffe15 	stw	zero,-8(fp)

        xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 4001684:	e0bffc03 	ldbu	r2,-16(fp)
 4001688:	100d883a 	mov	r6,r2
 400168c:	e17ffe17 	ldw	r5,-8(fp)
 4001690:	e13fff17 	ldw	r4,-4(fp)
 4001694:	40013d80 	call	40013d8 <xQueueGenericCreate>
 4001698:	e0bffd15 	stw	r2,-12(fp)
        prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 400169c:	e13ffd17 	ldw	r4,-12(fp)
 40016a0:	40016000 	call	4001600 <prvInitialiseMutex>

        return xNewQueue;
 40016a4:	e0bffd17 	ldw	r2,-12(fp)
    }
 40016a8:	e037883a 	mov	sp,fp
 40016ac:	dfc00117 	ldw	ra,4(sp)
 40016b0:	df000017 	ldw	fp,0(sp)
 40016b4:	dec00204 	addi	sp,sp,8
 40016b8:	f800283a 	ret

040016bc <xQueueGiveMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

    BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
    {
 40016bc:	defffa04 	addi	sp,sp,-24
 40016c0:	dfc00515 	stw	ra,20(sp)
 40016c4:	df000415 	stw	fp,16(sp)
 40016c8:	dc000315 	stw	r16,12(sp)
 40016cc:	df000404 	addi	fp,sp,16
 40016d0:	e13ffc15 	stw	r4,-16(fp)
        BaseType_t xReturn;
        Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 40016d4:	e0bffc17 	ldw	r2,-16(fp)
 40016d8:	e0bffd15 	stw	r2,-12(fp)
         * change outside of this task.  If this task does not hold the mutex then
         * pxMutexHolder can never coincidentally equal the tasks handle, and as
         * this is the only condition we are interested in it does not matter if
         * pxMutexHolder is accessed simultaneously by another task.  Therefore no
         * mutual exclusion is required to test the pxMutexHolder variable. */
        if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 40016dc:	e0bffd17 	ldw	r2,-12(fp)
 40016e0:	14000217 	ldw	r16,8(r2)
 40016e4:	40059900 	call	4005990 <xTaskGetCurrentTaskHandle>
 40016e8:	8080101e 	bne	r16,r2,400172c <xQueueGiveMutexRecursive+0x70>
            /* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
             * the task handle, therefore no underflow check is required.  Also,
             * uxRecursiveCallCount is only modified by the mutex holder, and as
             * there can only be one, no mutual exclusion is required to modify the
             * uxRecursiveCallCount member. */
            ( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
 40016ec:	e0bffd17 	ldw	r2,-12(fp)
 40016f0:	10800317 	ldw	r2,12(r2)
 40016f4:	10ffffc4 	addi	r3,r2,-1
 40016f8:	e0bffd17 	ldw	r2,-12(fp)
 40016fc:	10c00315 	stw	r3,12(r2)

            /* Has the recursive call count unwound to 0? */
            if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 4001700:	e0bffd17 	ldw	r2,-12(fp)
 4001704:	10800317 	ldw	r2,12(r2)
 4001708:	1000051e 	bne	r2,zero,4001720 <xQueueGiveMutexRecursive+0x64>
            {
                /* Return the mutex.  This will automatically unblock any other
                 * task that might be waiting to access the mutex. */
                ( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 400170c:	000f883a 	mov	r7,zero
 4001710:	000d883a 	mov	r6,zero
 4001714:	000b883a 	mov	r5,zero
 4001718:	e13ffd17 	ldw	r4,-12(fp)
 400171c:	40018580 	call	4001858 <xQueueGenericSend>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            xReturn = pdPASS;
 4001720:	00800044 	movi	r2,1
 4001724:	e0bffe15 	stw	r2,-8(fp)
 4001728:	00000106 	br	4001730 <xQueueGiveMutexRecursive+0x74>
        }
        else
        {
            /* The mutex cannot be given because the calling task is not the
             * holder. */
            xReturn = pdFAIL;
 400172c:	e03ffe15 	stw	zero,-8(fp)

            traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
        }

        return xReturn;
 4001730:	e0bffe17 	ldw	r2,-8(fp)
    }
 4001734:	e6ffff04 	addi	sp,fp,-4
 4001738:	dfc00217 	ldw	ra,8(sp)
 400173c:	df000117 	ldw	fp,4(sp)
 4001740:	dc000017 	ldw	r16,0(sp)
 4001744:	dec00304 	addi	sp,sp,12
 4001748:	f800283a 	ret

0400174c <xQueueTakeMutexRecursive>:

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

    BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex,
                                         TickType_t xTicksToWait )
    {
 400174c:	defff904 	addi	sp,sp,-28
 4001750:	dfc00615 	stw	ra,24(sp)
 4001754:	df000515 	stw	fp,20(sp)
 4001758:	dc000415 	stw	r16,16(sp)
 400175c:	df000504 	addi	fp,sp,20
 4001760:	e13ffc15 	stw	r4,-16(fp)
 4001764:	e17ffb15 	stw	r5,-20(fp)
        BaseType_t xReturn;
        Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 4001768:	e0bffc17 	ldw	r2,-16(fp)
 400176c:	e0bffd15 	stw	r2,-12(fp)
        /* Comments regarding mutual exclusion as per those within
         * xQueueGiveMutexRecursive(). */

        traceTAKE_MUTEX_RECURSIVE( pxMutex );

        if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 4001770:	e0bffd17 	ldw	r2,-12(fp)
 4001774:	14000217 	ldw	r16,8(r2)
 4001778:	40059900 	call	4005990 <xTaskGetCurrentTaskHandle>
 400177c:	8080081e 	bne	r16,r2,40017a0 <xQueueTakeMutexRecursive+0x54>
        {
            ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 4001780:	e0bffd17 	ldw	r2,-12(fp)
 4001784:	10800317 	ldw	r2,12(r2)
 4001788:	10c00044 	addi	r3,r2,1
 400178c:	e0bffd17 	ldw	r2,-12(fp)
 4001790:	10c00315 	stw	r3,12(r2)
            xReturn = pdPASS;
 4001794:	00800044 	movi	r2,1
 4001798:	e0bffe15 	stw	r2,-8(fp)
 400179c:	00000b06 	br	40017cc <xQueueTakeMutexRecursive+0x80>
        }
        else
        {
            xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
 40017a0:	e17ffb17 	ldw	r5,-20(fp)
 40017a4:	e13ffd17 	ldw	r4,-12(fp)
 40017a8:	4001dac0 	call	4001dac <xQueueSemaphoreTake>
 40017ac:	e0bffe15 	stw	r2,-8(fp)

            /* pdPASS will only be returned if the mutex was successfully
             * obtained.  The calling task may have entered the Blocked state
             * before reaching here. */
            if( xReturn != pdFAIL )
 40017b0:	e0bffe17 	ldw	r2,-8(fp)
 40017b4:	10000526 	beq	r2,zero,40017cc <xQueueTakeMutexRecursive+0x80>
            {
                ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 40017b8:	e0bffd17 	ldw	r2,-12(fp)
 40017bc:	10800317 	ldw	r2,12(r2)
 40017c0:	10c00044 	addi	r3,r2,1
 40017c4:	e0bffd17 	ldw	r2,-12(fp)
 40017c8:	10c00315 	stw	r3,12(r2)
            {
                traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
            }
        }

        return xReturn;
 40017cc:	e0bffe17 	ldw	r2,-8(fp)
    }
 40017d0:	e6ffff04 	addi	sp,fp,-4
 40017d4:	dfc00217 	ldw	ra,8(sp)
 40017d8:	df000117 	ldw	fp,4(sp)
 40017dc:	dc000017 	ldw	r16,0(sp)
 40017e0:	dec00304 	addi	sp,sp,12
 40017e4:	f800283a 	ret

040017e8 <xQueueCreateCountingSemaphore>:

#if ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

    QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount,
                                                 const UBaseType_t uxInitialCount )
    {
 40017e8:	defffb04 	addi	sp,sp,-20
 40017ec:	dfc00415 	stw	ra,16(sp)
 40017f0:	df000315 	stw	fp,12(sp)
 40017f4:	df000304 	addi	fp,sp,12
 40017f8:	e13ffe15 	stw	r4,-8(fp)
 40017fc:	e17ffd15 	stw	r5,-12(fp)
        QueueHandle_t xHandle = NULL;
 4001800:	e03fff15 	stw	zero,-4(fp)

        if( ( uxMaxCount != 0 ) &&
 4001804:	e0bffe17 	ldw	r2,-8(fp)
 4001808:	10000d26 	beq	r2,zero,4001840 <xQueueCreateCountingSemaphore+0x58>
 400180c:	e0bffd17 	ldw	r2,-12(fp)
 4001810:	e0fffe17 	ldw	r3,-8(fp)
 4001814:	18800a36 	bltu	r3,r2,4001840 <xQueueCreateCountingSemaphore+0x58>
            ( uxInitialCount <= uxMaxCount ) )
        {
            xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
 4001818:	01800084 	movi	r6,2
 400181c:	000b883a 	mov	r5,zero
 4001820:	e13ffe17 	ldw	r4,-8(fp)
 4001824:	40013d80 	call	40013d8 <xQueueGenericCreate>
 4001828:	e0bfff15 	stw	r2,-4(fp)

            if( xHandle != NULL )
 400182c:	e0bfff17 	ldw	r2,-4(fp)
 4001830:	10000326 	beq	r2,zero,4001840 <xQueueCreateCountingSemaphore+0x58>
            {
                ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 4001834:	e0bfff17 	ldw	r2,-4(fp)
 4001838:	e0fffd17 	ldw	r3,-12(fp)
 400183c:	10c00e15 	stw	r3,56(r2)
        {
            configASSERT( xHandle );
            mtCOVERAGE_TEST_MARKER();
        }

        return xHandle;
 4001840:	e0bfff17 	ldw	r2,-4(fp)
    }
 4001844:	e037883a 	mov	sp,fp
 4001848:	dfc00117 	ldw	ra,4(sp)
 400184c:	df000017 	ldw	fp,0(sp)
 4001850:	dec00204 	addi	sp,sp,8
 4001854:	f800283a 	ret

04001858 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
 4001858:	defff504 	addi	sp,sp,-44
 400185c:	dfc00a15 	stw	ra,40(sp)
 4001860:	df000915 	stw	fp,36(sp)
 4001864:	df000904 	addi	fp,sp,36
 4001868:	e13ffa15 	stw	r4,-24(fp)
 400186c:	e17ff915 	stw	r5,-28(fp)
 4001870:	e1bff815 	stw	r6,-32(fp)
 4001874:	e1fff715 	stw	r7,-36(fp)
    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 4001878:	e03fff15 	stw	zero,-4(fp)
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
 400187c:	e0bffa17 	ldw	r2,-24(fp)
 4001880:	e0bffe15 	stw	r2,-8(fp)
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
 4001884:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 4001888:	e0bffe17 	ldw	r2,-8(fp)
 400188c:	10c00e17 	ldw	r3,56(r2)
 4001890:	e0bffe17 	ldw	r2,-8(fp)
 4001894:	10800f17 	ldw	r2,60(r2)
 4001898:	18800336 	bltu	r3,r2,40018a8 <xQueueGenericSend+0x50>
 400189c:	e0bff717 	ldw	r2,-36(fp)
 40018a0:	10800098 	cmpnei	r2,r2,2
 40018a4:	1000151e 	bne	r2,zero,40018fc <xQueueGenericSend+0xa4>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 40018a8:	e1bff717 	ldw	r6,-36(fp)
 40018ac:	e17ff917 	ldw	r5,-28(fp)
 40018b0:	e13ffe17 	ldw	r4,-8(fp)
 40018b4:	40024380 	call	4002438 <prvCopyDataToQueue>
 40018b8:	e0bffd15 	stw	r2,-12(fp)

                    /* If there was a task waiting for data to arrive on the
                     * queue then unblock it now. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 40018bc:	e0bffe17 	ldw	r2,-8(fp)
 40018c0:	10800917 	ldw	r2,36(r2)
 40018c4:	10000726 	beq	r2,zero,40018e4 <xQueueGenericSend+0x8c>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 40018c8:	e0bffe17 	ldw	r2,-8(fp)
 40018cc:	10800904 	addi	r2,r2,36
 40018d0:	1009883a 	mov	r4,r2
 40018d4:	400502c0 	call	400502c <xTaskRemoveFromEventList>
 40018d8:	10000526 	beq	r2,zero,40018f0 <xQueueGenericSend+0x98>
                        {
                            /* The unblocked task has a priority higher than
                             * our own so yield immediately.  Yes it is ok to do
                             * this from within the critical section - the kernel
                             * takes care of that. */
                            queueYIELD_IF_USING_PREEMPTION();
 40018dc:	003b683a 	trap	0
 40018e0:	00000306 	br	40018f0 <xQueueGenericSend+0x98>
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                    else if( xYieldRequired != pdFALSE )
 40018e4:	e0bffd17 	ldw	r2,-12(fp)
 40018e8:	10000126 	beq	r2,zero,40018f0 <xQueueGenericSend+0x98>
                    {
                        /* This path is a special case that will only get
                         * executed if the task was holding multiple mutexes and
                         * the mutexes were given back in an order that is
                         * different to that in which they were taken. */
                        queueYIELD_IF_USING_PREEMPTION();
 40018ec:	003b683a 	trap	0
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
 40018f0:	4005fd00 	call	4005fd0 <vTaskExitCritical>
                return pdPASS;
 40018f4:	00800044 	movi	r2,1
 40018f8:	00003f06 	br	40019f8 <xQueueGenericSend+0x1a0>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
 40018fc:	e0bff817 	ldw	r2,-32(fp)
 4001900:	1000031e 	bne	r2,zero,4001910 <xQueueGenericSend+0xb8>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
 4001904:	4005fd00 	call	4005fd0 <vTaskExitCritical>

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
 4001908:	0005883a 	mov	r2,zero
 400190c:	00003a06 	br	40019f8 <xQueueGenericSend+0x1a0>
                }
                else if( xEntryTimeSet == pdFALSE )
 4001910:	e0bfff17 	ldw	r2,-4(fp)
 4001914:	1000051e 	bne	r2,zero,400192c <xQueueGenericSend+0xd4>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
 4001918:	e0bffb04 	addi	r2,fp,-20
 400191c:	1009883a 	mov	r4,r2
 4001920:	40055980 	call	4005598 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
 4001924:	00800044 	movi	r2,1
 4001928:	e0bfff15 	stw	r2,-4(fp)
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
 400192c:	4005fd00 	call	4005fd0 <vTaskExitCritical>

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
 4001930:	40046f00 	call	40046f0 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 4001934:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
 4001938:	e0bffe17 	ldw	r2,-8(fp)
 400193c:	10801103 	ldbu	r2,68(r2)
 4001940:	10803fcc 	andi	r2,r2,255
 4001944:	1080201c 	xori	r2,r2,128
 4001948:	10bfe004 	addi	r2,r2,-128
 400194c:	10bfffd8 	cmpnei	r2,r2,-1
 4001950:	1000021e 	bne	r2,zero,400195c <xQueueGenericSend+0x104>
 4001954:	e0bffe17 	ldw	r2,-8(fp)
 4001958:	10001105 	stb	zero,68(r2)
 400195c:	e0bffe17 	ldw	r2,-8(fp)
 4001960:	10801143 	ldbu	r2,69(r2)
 4001964:	10803fcc 	andi	r2,r2,255
 4001968:	1080201c 	xori	r2,r2,128
 400196c:	10bfe004 	addi	r2,r2,-128
 4001970:	10bfffd8 	cmpnei	r2,r2,-1
 4001974:	1000021e 	bne	r2,zero,4001980 <xQueueGenericSend+0x128>
 4001978:	e0bffe17 	ldw	r2,-8(fp)
 400197c:	10001145 	stb	zero,69(r2)
 4001980:	4005fd00 	call	4005fd0 <vTaskExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 4001984:	e0fff804 	addi	r3,fp,-32
 4001988:	e0bffb04 	addi	r2,fp,-20
 400198c:	180b883a 	mov	r5,r3
 4001990:	1009883a 	mov	r4,r2
 4001994:	40055d40 	call	40055d4 <xTaskCheckForTimeOut>
 4001998:	1000131e 	bne	r2,zero,40019e8 <xQueueGenericSend+0x190>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
 400199c:	e13ffe17 	ldw	r4,-8(fp)
 40019a0:	40027ec0 	call	40027ec <prvIsQueueFull>
 40019a4:	10000c26 	beq	r2,zero,40019d8 <xQueueGenericSend+0x180>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 40019a8:	e0bffe17 	ldw	r2,-8(fp)
 40019ac:	10800404 	addi	r2,r2,16
 40019b0:	e0fff817 	ldw	r3,-32(fp)
 40019b4:	180b883a 	mov	r5,r3
 40019b8:	1009883a 	mov	r4,r2
 40019bc:	4004f200 	call	4004f20 <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list. It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready list instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
 40019c0:	e13ffe17 	ldw	r4,-8(fp)
 40019c4:	40026600 	call	4002660 <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in the ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
 40019c8:	400471c0 	call	400471c <xTaskResumeAll>
 40019cc:	103fad1e 	bne	r2,zero,4001884 <xQueueGenericSend+0x2c>
                {
                    portYIELD_WITHIN_API();
 40019d0:	003b683a 	trap	0
 40019d4:	003fab06 	br	4001884 <xQueueGenericSend+0x2c>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
 40019d8:	e13ffe17 	ldw	r4,-8(fp)
 40019dc:	40026600 	call	4002660 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
 40019e0:	400471c0 	call	400471c <xTaskResumeAll>
 40019e4:	003fa706 	br	4001884 <xQueueGenericSend+0x2c>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
 40019e8:	e13ffe17 	ldw	r4,-8(fp)
 40019ec:	40026600 	call	4002660 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
 40019f0:	400471c0 	call	400471c <xTaskResumeAll>

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
 40019f4:	0005883a 	mov	r2,zero
        }
    } /*lint -restore */
}
 40019f8:	e037883a 	mov	sp,fp
 40019fc:	dfc00117 	ldw	ra,4(sp)
 4001a00:	df000017 	ldw	fp,0(sp)
 4001a04:	dec00204 	addi	sp,sp,8
 4001a08:	f800283a 	ret

04001a0c <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
 4001a0c:	defff404 	addi	sp,sp,-48
 4001a10:	dfc00b15 	stw	ra,44(sp)
 4001a14:	df000a15 	stw	fp,40(sp)
 4001a18:	df000a04 	addi	fp,sp,40
 4001a1c:	e13ff915 	stw	r4,-28(fp)
 4001a20:	e17ff815 	stw	r5,-32(fp)
 4001a24:	e1bff715 	stw	r6,-36(fp)
 4001a28:	e1fff615 	stw	r7,-40(fp)
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
 4001a2c:	e0bff917 	ldw	r2,-28(fp)
 4001a30:	e0bffe15 	stw	r2,-8(fp)
    /* Similar to xQueueGenericSend, except without blocking if there is no room
     * in the queue.  Also don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4001a34:	e03ffd15 	stw	zero,-12(fp)
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 4001a38:	e0bffe17 	ldw	r2,-8(fp)
 4001a3c:	10c00e17 	ldw	r3,56(r2)
 4001a40:	e0bffe17 	ldw	r2,-8(fp)
 4001a44:	10800f17 	ldw	r2,60(r2)
 4001a48:	18800336 	bltu	r3,r2,4001a58 <xQueueGenericSendFromISR+0x4c>
 4001a4c:	e0bff617 	ldw	r2,-40(fp)
 4001a50:	10800098 	cmpnei	r2,r2,2
 4001a54:	1000281e 	bne	r2,zero,4001af8 <xQueueGenericSendFromISR+0xec>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
 4001a58:	e0bffe17 	ldw	r2,-8(fp)
 4001a5c:	10801143 	ldbu	r2,69(r2)
 4001a60:	e0bffcc5 	stb	r2,-13(fp)
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 4001a64:	e0bffe17 	ldw	r2,-8(fp)
 4001a68:	10800e17 	ldw	r2,56(r2)
 4001a6c:	e0bffb15 	stw	r2,-20(fp)
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 4001a70:	e1bff617 	ldw	r6,-40(fp)
 4001a74:	e17ff817 	ldw	r5,-32(fp)
 4001a78:	e13ffe17 	ldw	r4,-8(fp)
 4001a7c:	40024380 	call	4002438 <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
 4001a80:	e0bffcc7 	ldb	r2,-13(fp)
 4001a84:	10bfffd8 	cmpnei	r2,r2,-1
 4001a88:	10000e1e 	bne	r2,zero,4001ac4 <xQueueGenericSendFromISR+0xb8>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 4001a8c:	e0bffe17 	ldw	r2,-8(fp)
 4001a90:	10800917 	ldw	r2,36(r2)
 4001a94:	10001526 	beq	r2,zero,4001aec <xQueueGenericSendFromISR+0xe0>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 4001a98:	e0bffe17 	ldw	r2,-8(fp)
 4001a9c:	10800904 	addi	r2,r2,36
 4001aa0:	1009883a 	mov	r4,r2
 4001aa4:	400502c0 	call	400502c <xTaskRemoveFromEventList>
 4001aa8:	10001026 	beq	r2,zero,4001aec <xQueueGenericSendFromISR+0xe0>
                        {
                            /* The task waiting has a higher priority so record that a
                             * context switch is required. */
                            if( pxHigherPriorityTaskWoken != NULL )
 4001aac:	e0bff717 	ldw	r2,-36(fp)
 4001ab0:	10000e26 	beq	r2,zero,4001aec <xQueueGenericSendFromISR+0xe0>
                            {
                                *pxHigherPriorityTaskWoken = pdTRUE;
 4001ab4:	e0bff717 	ldw	r2,-36(fp)
 4001ab8:	00c00044 	movi	r3,1
 4001abc:	10c00015 	stw	r3,0(r2)
 4001ac0:	00000a06 	br	4001aec <xQueueGenericSendFromISR+0xe0>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                prvIncrementQueueTxLock( pxQueue, cTxLock );
 4001ac4:	4004a440 	call	4004a44 <uxTaskGetNumberOfTasks>
 4001ac8:	e0bffa15 	stw	r2,-24(fp)
 4001acc:	e0fffcc7 	ldb	r3,-13(fp)
 4001ad0:	e0bffa17 	ldw	r2,-24(fp)
 4001ad4:	1880052e 	bgeu	r3,r2,4001aec <xQueueGenericSendFromISR+0xe0>
 4001ad8:	e0bffcc3 	ldbu	r2,-13(fp)
 4001adc:	10800044 	addi	r2,r2,1
 4001ae0:	1007883a 	mov	r3,r2
 4001ae4:	e0bffe17 	ldw	r2,-8(fp)
 4001ae8:	10c01145 	stb	r3,69(r2)
            }

            xReturn = pdPASS;
 4001aec:	00800044 	movi	r2,1
 4001af0:	e0bfff15 	stw	r2,-4(fp)
        {
 4001af4:	00000106 	br	4001afc <xQueueGenericSendFromISR+0xf0>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
 4001af8:	e03fff15 	stw	zero,-4(fp)
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 4001afc:	e0bfff17 	ldw	r2,-4(fp)
}
 4001b00:	e037883a 	mov	sp,fp
 4001b04:	dfc00117 	ldw	ra,4(sp)
 4001b08:	df000017 	ldw	fp,0(sp)
 4001b0c:	dec00204 	addi	sp,sp,8
 4001b10:	f800283a 	ret

04001b14 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
 4001b14:	defff604 	addi	sp,sp,-40
 4001b18:	dfc00915 	stw	ra,36(sp)
 4001b1c:	df000815 	stw	fp,32(sp)
 4001b20:	df000804 	addi	fp,sp,32
 4001b24:	e13ff915 	stw	r4,-28(fp)
 4001b28:	e17ff815 	stw	r5,-32(fp)
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
 4001b2c:	e0bff917 	ldw	r2,-28(fp)
 4001b30:	e0bffe15 	stw	r2,-8(fp)
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4001b34:	e03ffd15 	stw	zero,-12(fp)
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 4001b38:	e0bffe17 	ldw	r2,-8(fp)
 4001b3c:	10800e17 	ldw	r2,56(r2)
 4001b40:	e0bffc15 	stw	r2,-16(fp)

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
 4001b44:	e0bffe17 	ldw	r2,-8(fp)
 4001b48:	10800f17 	ldw	r2,60(r2)
 4001b4c:	e0fffc17 	ldw	r3,-16(fp)
 4001b50:	1880252e 	bgeu	r3,r2,4001be8 <xQueueGiveFromISR+0xd4>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
 4001b54:	e0bffe17 	ldw	r2,-8(fp)
 4001b58:	10801143 	ldbu	r2,69(r2)
 4001b5c:	e0bffbc5 	stb	r2,-17(fp)
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 4001b60:	e0bffc17 	ldw	r2,-16(fp)
 4001b64:	10c00044 	addi	r3,r2,1
 4001b68:	e0bffe17 	ldw	r2,-8(fp)
 4001b6c:	10c00e15 	stw	r3,56(r2)

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
 4001b70:	e0bffbc7 	ldb	r2,-17(fp)
 4001b74:	10bfffd8 	cmpnei	r2,r2,-1
 4001b78:	10000e1e 	bne	r2,zero,4001bb4 <xQueueGiveFromISR+0xa0>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 4001b7c:	e0bffe17 	ldw	r2,-8(fp)
 4001b80:	10800917 	ldw	r2,36(r2)
 4001b84:	10001526 	beq	r2,zero,4001bdc <xQueueGiveFromISR+0xc8>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 4001b88:	e0bffe17 	ldw	r2,-8(fp)
 4001b8c:	10800904 	addi	r2,r2,36
 4001b90:	1009883a 	mov	r4,r2
 4001b94:	400502c0 	call	400502c <xTaskRemoveFromEventList>
 4001b98:	10001026 	beq	r2,zero,4001bdc <xQueueGiveFromISR+0xc8>
                        {
                            /* The task waiting has a higher priority so record that a
                             * context switch is required. */
                            if( pxHigherPriorityTaskWoken != NULL )
 4001b9c:	e0bff817 	ldw	r2,-32(fp)
 4001ba0:	10000e26 	beq	r2,zero,4001bdc <xQueueGiveFromISR+0xc8>
                            {
                                *pxHigherPriorityTaskWoken = pdTRUE;
 4001ba4:	e0bff817 	ldw	r2,-32(fp)
 4001ba8:	00c00044 	movi	r3,1
 4001bac:	10c00015 	stw	r3,0(r2)
 4001bb0:	00000a06 	br	4001bdc <xQueueGiveFromISR+0xc8>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                prvIncrementQueueTxLock( pxQueue, cTxLock );
 4001bb4:	4004a440 	call	4004a44 <uxTaskGetNumberOfTasks>
 4001bb8:	e0bffa15 	stw	r2,-24(fp)
 4001bbc:	e0fffbc7 	ldb	r3,-17(fp)
 4001bc0:	e0bffa17 	ldw	r2,-24(fp)
 4001bc4:	1880052e 	bgeu	r3,r2,4001bdc <xQueueGiveFromISR+0xc8>
 4001bc8:	e0bffbc3 	ldbu	r2,-17(fp)
 4001bcc:	10800044 	addi	r2,r2,1
 4001bd0:	1007883a 	mov	r3,r2
 4001bd4:	e0bffe17 	ldw	r2,-8(fp)
 4001bd8:	10c01145 	stb	r3,69(r2)
            }

            xReturn = pdPASS;
 4001bdc:	00800044 	movi	r2,1
 4001be0:	e0bfff15 	stw	r2,-4(fp)
 4001be4:	00000106 	br	4001bec <xQueueGiveFromISR+0xd8>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
 4001be8:	e03fff15 	stw	zero,-4(fp)
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 4001bec:	e0bfff17 	ldw	r2,-4(fp)
}
 4001bf0:	e037883a 	mov	sp,fp
 4001bf4:	dfc00117 	ldw	ra,4(sp)
 4001bf8:	df000017 	ldw	fp,0(sp)
 4001bfc:	dec00204 	addi	sp,sp,8
 4001c00:	f800283a 	ret

04001c04 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
 4001c04:	defff604 	addi	sp,sp,-40
 4001c08:	dfc00915 	stw	ra,36(sp)
 4001c0c:	df000815 	stw	fp,32(sp)
 4001c10:	df000804 	addi	fp,sp,32
 4001c14:	e13ffa15 	stw	r4,-24(fp)
 4001c18:	e17ff915 	stw	r5,-28(fp)
 4001c1c:	e1bff815 	stw	r6,-32(fp)
    BaseType_t xEntryTimeSet = pdFALSE;
 4001c20:	e03fff15 	stw	zero,-4(fp)
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
 4001c24:	e0bffa17 	ldw	r2,-24(fp)
 4001c28:	e0bffe15 	stw	r2,-8(fp)
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
 4001c2c:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 4001c30:	e0bffe17 	ldw	r2,-8(fp)
 4001c34:	10800e17 	ldw	r2,56(r2)
 4001c38:	e0bffd15 	stw	r2,-12(fp)

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 4001c3c:	e0bffd17 	ldw	r2,-12(fp)
 4001c40:	10001326 	beq	r2,zero,4001c90 <xQueueReceive+0x8c>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
 4001c44:	e17ff917 	ldw	r5,-28(fp)
 4001c48:	e13ffe17 	ldw	r4,-8(fp)
 4001c4c:	40025c40 	call	40025c4 <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 4001c50:	e0bffd17 	ldw	r2,-12(fp)
 4001c54:	10ffffc4 	addi	r3,r2,-1
 4001c58:	e0bffe17 	ldw	r2,-8(fp)
 4001c5c:	10c00e15 	stw	r3,56(r2)

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 4001c60:	e0bffe17 	ldw	r2,-8(fp)
 4001c64:	10800417 	ldw	r2,16(r2)
 4001c68:	10000626 	beq	r2,zero,4001c84 <xQueueReceive+0x80>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 4001c6c:	e0bffe17 	ldw	r2,-8(fp)
 4001c70:	10800404 	addi	r2,r2,16
 4001c74:	1009883a 	mov	r4,r2
 4001c78:	400502c0 	call	400502c <xTaskRemoveFromEventList>
 4001c7c:	10000126 	beq	r2,zero,4001c84 <xQueueReceive+0x80>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
 4001c80:	003b683a 	trap	0
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
 4001c84:	4005fd00 	call	4005fd0 <vTaskExitCritical>
                return pdPASS;
 4001c88:	00800044 	movi	r2,1
 4001c8c:	00004206 	br	4001d98 <xQueueReceive+0x194>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
 4001c90:	e0bff817 	ldw	r2,-32(fp)
 4001c94:	1000031e 	bne	r2,zero,4001ca4 <xQueueReceive+0xa0>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
 4001c98:	4005fd00 	call	4005fd0 <vTaskExitCritical>
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
 4001c9c:	0005883a 	mov	r2,zero
 4001ca0:	00003d06 	br	4001d98 <xQueueReceive+0x194>
                }
                else if( xEntryTimeSet == pdFALSE )
 4001ca4:	e0bfff17 	ldw	r2,-4(fp)
 4001ca8:	1000051e 	bne	r2,zero,4001cc0 <xQueueReceive+0xbc>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
 4001cac:	e0bffb04 	addi	r2,fp,-20
 4001cb0:	1009883a 	mov	r4,r2
 4001cb4:	40055980 	call	4005598 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
 4001cb8:	00800044 	movi	r2,1
 4001cbc:	e0bfff15 	stw	r2,-4(fp)
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
 4001cc0:	4005fd00 	call	4005fd0 <vTaskExitCritical>

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
 4001cc4:	40046f00 	call	40046f0 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 4001cc8:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
 4001ccc:	e0bffe17 	ldw	r2,-8(fp)
 4001cd0:	10801103 	ldbu	r2,68(r2)
 4001cd4:	10803fcc 	andi	r2,r2,255
 4001cd8:	1080201c 	xori	r2,r2,128
 4001cdc:	10bfe004 	addi	r2,r2,-128
 4001ce0:	10bfffd8 	cmpnei	r2,r2,-1
 4001ce4:	1000021e 	bne	r2,zero,4001cf0 <xQueueReceive+0xec>
 4001ce8:	e0bffe17 	ldw	r2,-8(fp)
 4001cec:	10001105 	stb	zero,68(r2)
 4001cf0:	e0bffe17 	ldw	r2,-8(fp)
 4001cf4:	10801143 	ldbu	r2,69(r2)
 4001cf8:	10803fcc 	andi	r2,r2,255
 4001cfc:	1080201c 	xori	r2,r2,128
 4001d00:	10bfe004 	addi	r2,r2,-128
 4001d04:	10bfffd8 	cmpnei	r2,r2,-1
 4001d08:	1000021e 	bne	r2,zero,4001d14 <xQueueReceive+0x110>
 4001d0c:	e0bffe17 	ldw	r2,-8(fp)
 4001d10:	10001145 	stb	zero,69(r2)
 4001d14:	4005fd00 	call	4005fd0 <vTaskExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 4001d18:	e0fff804 	addi	r3,fp,-32
 4001d1c:	e0bffb04 	addi	r2,fp,-20
 4001d20:	180b883a 	mov	r5,r3
 4001d24:	1009883a 	mov	r4,r2
 4001d28:	40055d40 	call	40055d4 <xTaskCheckForTimeOut>
 4001d2c:	1000131e 	bne	r2,zero,4001d7c <xQueueReceive+0x178>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 4001d30:	e13ffe17 	ldw	r4,-8(fp)
 4001d34:	40027540 	call	4002754 <prvIsQueueEmpty>
 4001d38:	10000c26 	beq	r2,zero,4001d6c <xQueueReceive+0x168>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 4001d3c:	e0bffe17 	ldw	r2,-8(fp)
 4001d40:	10800904 	addi	r2,r2,36
 4001d44:	e0fff817 	ldw	r3,-32(fp)
 4001d48:	180b883a 	mov	r5,r3
 4001d4c:	1009883a 	mov	r4,r2
 4001d50:	4004f200 	call	4004f20 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
 4001d54:	e13ffe17 	ldw	r4,-8(fp)
 4001d58:	40026600 	call	4002660 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
 4001d5c:	400471c0 	call	400471c <xTaskResumeAll>
 4001d60:	103fb21e 	bne	r2,zero,4001c2c <xQueueReceive+0x28>
                {
                    portYIELD_WITHIN_API();
 4001d64:	003b683a 	trap	0
 4001d68:	003fb006 	br	4001c2c <xQueueReceive+0x28>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
 4001d6c:	e13ffe17 	ldw	r4,-8(fp)
 4001d70:	40026600 	call	4002660 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
 4001d74:	400471c0 	call	400471c <xTaskResumeAll>
 4001d78:	003fac06 	br	4001c2c <xQueueReceive+0x28>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
 4001d7c:	e13ffe17 	ldw	r4,-8(fp)
 4001d80:	40026600 	call	4002660 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
 4001d84:	400471c0 	call	400471c <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 4001d88:	e13ffe17 	ldw	r4,-8(fp)
 4001d8c:	40027540 	call	4002754 <prvIsQueueEmpty>
 4001d90:	103fa626 	beq	r2,zero,4001c2c <xQueueReceive+0x28>
            {
                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
 4001d94:	0005883a 	mov	r2,zero
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
 4001d98:	e037883a 	mov	sp,fp
 4001d9c:	dfc00117 	ldw	ra,4(sp)
 4001da0:	df000017 	ldw	fp,0(sp)
 4001da4:	dec00204 	addi	sp,sp,8
 4001da8:	f800283a 	ret

04001dac <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
 4001dac:	defff504 	addi	sp,sp,-44
 4001db0:	dfc00a15 	stw	ra,40(sp)
 4001db4:	df000915 	stw	fp,36(sp)
 4001db8:	df000904 	addi	fp,sp,36
 4001dbc:	e13ff815 	stw	r4,-32(fp)
 4001dc0:	e17ff715 	stw	r5,-36(fp)
    BaseType_t xEntryTimeSet = pdFALSE;
 4001dc4:	e03fff15 	stw	zero,-4(fp)
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
 4001dc8:	e0bff817 	ldw	r2,-32(fp)
 4001dcc:	e0bffd15 	stw	r2,-12(fp)

    #if ( configUSE_MUTEXES == 1 )
        BaseType_t xInheritanceOccurred = pdFALSE;
 4001dd0:	e03ffe15 	stw	zero,-8(fp)
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
 4001dd4:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 4001dd8:	e0bffd17 	ldw	r2,-12(fp)
 4001ddc:	10800e17 	ldw	r2,56(r2)
 4001de0:	e0bffc15 	stw	r2,-16(fp)

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 4001de4:	e0bffc17 	ldw	r2,-16(fp)
 4001de8:	10001726 	beq	r2,zero,4001e48 <xQueueSemaphoreTake+0x9c>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
 4001dec:	e0bffc17 	ldw	r2,-16(fp)
 4001df0:	10ffffc4 	addi	r3,r2,-1
 4001df4:	e0bffd17 	ldw	r2,-12(fp)
 4001df8:	10c00e15 	stw	r3,56(r2)

                #if ( configUSE_MUTEXES == 1 )
                {
                    if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 4001dfc:	e0bffd17 	ldw	r2,-12(fp)
 4001e00:	10800017 	ldw	r2,0(r2)
 4001e04:	1000041e 	bne	r2,zero,4001e18 <xQueueSemaphoreTake+0x6c>
                    {
                        /* Record the information required to implement
                         * priority inheritance should it become necessary. */
                        pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
 4001e08:	40060780 	call	4006078 <pvTaskIncrementMutexHeldCount>
 4001e0c:	1007883a 	mov	r3,r2
 4001e10:	e0bffd17 	ldw	r2,-12(fp)
 4001e14:	10c00215 	stw	r3,8(r2)
                }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 4001e18:	e0bffd17 	ldw	r2,-12(fp)
 4001e1c:	10800417 	ldw	r2,16(r2)
 4001e20:	10000626 	beq	r2,zero,4001e3c <xQueueSemaphoreTake+0x90>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 4001e24:	e0bffd17 	ldw	r2,-12(fp)
 4001e28:	10800404 	addi	r2,r2,16
 4001e2c:	1009883a 	mov	r4,r2
 4001e30:	400502c0 	call	400502c <xTaskRemoveFromEventList>
 4001e34:	10000126 	beq	r2,zero,4001e3c <xQueueSemaphoreTake+0x90>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
 4001e38:	003b683a 	trap	0
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
 4001e3c:	4005fd00 	call	4005fd0 <vTaskExitCritical>
                return pdPASS;
 4001e40:	00800044 	movi	r2,1
 4001e44:	00005806 	br	4001fa8 <xQueueSemaphoreTake+0x1fc>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
 4001e48:	e0bff717 	ldw	r2,-36(fp)
 4001e4c:	1000031e 	bne	r2,zero,4001e5c <xQueueSemaphoreTake+0xb0>
                {
                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
 4001e50:	4005fd00 	call	4005fd0 <vTaskExitCritical>
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
 4001e54:	0005883a 	mov	r2,zero
 4001e58:	00005306 	br	4001fa8 <xQueueSemaphoreTake+0x1fc>
                }
                else if( xEntryTimeSet == pdFALSE )
 4001e5c:	e0bfff17 	ldw	r2,-4(fp)
 4001e60:	1000051e 	bne	r2,zero,4001e78 <xQueueSemaphoreTake+0xcc>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
 4001e64:	e0bff904 	addi	r2,fp,-28
 4001e68:	1009883a 	mov	r4,r2
 4001e6c:	40055980 	call	4005598 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
 4001e70:	00800044 	movi	r2,1
 4001e74:	e0bfff15 	stw	r2,-4(fp)
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
 4001e78:	4005fd00 	call	4005fd0 <vTaskExitCritical>

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
 4001e7c:	40046f00 	call	40046f0 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 4001e80:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
 4001e84:	e0bffd17 	ldw	r2,-12(fp)
 4001e88:	10801103 	ldbu	r2,68(r2)
 4001e8c:	10803fcc 	andi	r2,r2,255
 4001e90:	1080201c 	xori	r2,r2,128
 4001e94:	10bfe004 	addi	r2,r2,-128
 4001e98:	10bfffd8 	cmpnei	r2,r2,-1
 4001e9c:	1000021e 	bne	r2,zero,4001ea8 <xQueueSemaphoreTake+0xfc>
 4001ea0:	e0bffd17 	ldw	r2,-12(fp)
 4001ea4:	10001105 	stb	zero,68(r2)
 4001ea8:	e0bffd17 	ldw	r2,-12(fp)
 4001eac:	10801143 	ldbu	r2,69(r2)
 4001eb0:	10803fcc 	andi	r2,r2,255
 4001eb4:	1080201c 	xori	r2,r2,128
 4001eb8:	10bfe004 	addi	r2,r2,-128
 4001ebc:	10bfffd8 	cmpnei	r2,r2,-1
 4001ec0:	1000021e 	bne	r2,zero,4001ecc <xQueueSemaphoreTake+0x120>
 4001ec4:	e0bffd17 	ldw	r2,-12(fp)
 4001ec8:	10001145 	stb	zero,69(r2)
 4001ecc:	4005fd00 	call	4005fd0 <vTaskExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 4001ed0:	e0fff704 	addi	r3,fp,-36
 4001ed4:	e0bff904 	addi	r2,fp,-28
 4001ed8:	180b883a 	mov	r5,r3
 4001edc:	1009883a 	mov	r4,r2
 4001ee0:	40055d40 	call	40055d4 <xTaskCheckForTimeOut>
 4001ee4:	10001d1e 	bne	r2,zero,4001f5c <xQueueSemaphoreTake+0x1b0>
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 4001ee8:	e13ffd17 	ldw	r4,-12(fp)
 4001eec:	40027540 	call	4002754 <prvIsQueueEmpty>
 4001ef0:	10001626 	beq	r2,zero,4001f4c <xQueueSemaphoreTake+0x1a0>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

                #if ( configUSE_MUTEXES == 1 )
                {
                    if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 4001ef4:	e0bffd17 	ldw	r2,-12(fp)
 4001ef8:	10800017 	ldw	r2,0(r2)
 4001efc:	1000071e 	bne	r2,zero,4001f1c <xQueueSemaphoreTake+0x170>
                    {
                        taskENTER_CRITICAL();
 4001f00:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
                        {
                            xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
 4001f04:	e0bffd17 	ldw	r2,-12(fp)
 4001f08:	10800217 	ldw	r2,8(r2)
 4001f0c:	1009883a 	mov	r4,r2
 4001f10:	40059b80 	call	40059b8 <xTaskPriorityInherit>
 4001f14:	e0bffe15 	stw	r2,-8(fp)
                        }
                        taskEXIT_CRITICAL();
 4001f18:	4005fd00 	call	4005fd0 <vTaskExitCritical>
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 4001f1c:	e0bffd17 	ldw	r2,-12(fp)
 4001f20:	10800904 	addi	r2,r2,36
 4001f24:	e0fff717 	ldw	r3,-36(fp)
 4001f28:	180b883a 	mov	r5,r3
 4001f2c:	1009883a 	mov	r4,r2
 4001f30:	4004f200 	call	4004f20 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
 4001f34:	e13ffd17 	ldw	r4,-12(fp)
 4001f38:	40026600 	call	4002660 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
 4001f3c:	400471c0 	call	400471c <xTaskResumeAll>
 4001f40:	103fa41e 	bne	r2,zero,4001dd4 <xQueueSemaphoreTake+0x28>
                {
                    portYIELD_WITHIN_API();
 4001f44:	003b683a 	trap	0
 4001f48:	003fa206 	br	4001dd4 <xQueueSemaphoreTake+0x28>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
 4001f4c:	e13ffd17 	ldw	r4,-12(fp)
 4001f50:	40026600 	call	4002660 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
 4001f54:	400471c0 	call	400471c <xTaskResumeAll>
 4001f58:	003f9e06 	br	4001dd4 <xQueueSemaphoreTake+0x28>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
 4001f5c:	e13ffd17 	ldw	r4,-12(fp)
 4001f60:	40026600 	call	4002660 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
 4001f64:	400471c0 	call	400471c <xTaskResumeAll>

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 4001f68:	e13ffd17 	ldw	r4,-12(fp)
 4001f6c:	40027540 	call	4002754 <prvIsQueueEmpty>
 4001f70:	103f9826 	beq	r2,zero,4001dd4 <xQueueSemaphoreTake+0x28>
                #if ( configUSE_MUTEXES == 1 )
                {
                    /* xInheritanceOccurred could only have be set if
                     * pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
                     * test the mutex type again to check it is actually a mutex. */
                    if( xInheritanceOccurred != pdFALSE )
 4001f74:	e0bffe17 	ldw	r2,-8(fp)
 4001f78:	10000a26 	beq	r2,zero,4001fa4 <xQueueSemaphoreTake+0x1f8>
                    {
                        taskENTER_CRITICAL();
 4001f7c:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
                            /* This task blocking on the mutex caused another
                             * task to inherit this task's priority.  Now this task
                             * has timed out the priority should be disinherited
                             * again, but only as low as the next highest priority
                             * task that is waiting for the same mutex. */
                            uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
 4001f80:	e13ffd17 	ldw	r4,-12(fp)
 4001f84:	40023e80 	call	40023e8 <prvGetDisinheritPriorityAfterTimeout>
 4001f88:	e0bffb15 	stw	r2,-20(fp)
                            vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
 4001f8c:	e0bffd17 	ldw	r2,-12(fp)
 4001f90:	10800217 	ldw	r2,8(r2)
 4001f94:	e17ffb17 	ldw	r5,-20(fp)
 4001f98:	1009883a 	mov	r4,r2
 4001f9c:	4005d780 	call	4005d78 <vTaskPriorityDisinheritAfterTimeout>
                        }
                        taskEXIT_CRITICAL();
 4001fa0:	4005fd00 	call	4005fd0 <vTaskExitCritical>
                    }
                }
                #endif /* configUSE_MUTEXES */

                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
 4001fa4:	0005883a 	mov	r2,zero
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
 4001fa8:	e037883a 	mov	sp,fp
 4001fac:	dfc00117 	ldw	ra,4(sp)
 4001fb0:	df000017 	ldw	fp,0(sp)
 4001fb4:	dec00204 	addi	sp,sp,8
 4001fb8:	f800283a 	ret

04001fbc <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
 4001fbc:	defff504 	addi	sp,sp,-44
 4001fc0:	dfc00a15 	stw	ra,40(sp)
 4001fc4:	df000915 	stw	fp,36(sp)
 4001fc8:	df000904 	addi	fp,sp,36
 4001fcc:	e13ff915 	stw	r4,-28(fp)
 4001fd0:	e17ff815 	stw	r5,-32(fp)
 4001fd4:	e1bff715 	stw	r6,-36(fp)
    BaseType_t xEntryTimeSet = pdFALSE;
 4001fd8:	e03fff15 	stw	zero,-4(fp)
    TimeOut_t xTimeOut;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
 4001fdc:	e0bff917 	ldw	r2,-28(fp)
 4001fe0:	e0bffe15 	stw	r2,-8(fp)
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
 4001fe4:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 4001fe8:	e0bffe17 	ldw	r2,-8(fp)
 4001fec:	10800e17 	ldw	r2,56(r2)
 4001ff0:	e0bffd15 	stw	r2,-12(fp)

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 4001ff4:	e0bffd17 	ldw	r2,-12(fp)
 4001ff8:	10001526 	beq	r2,zero,4002050 <xQueuePeek+0x94>
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 4001ffc:	e0bffe17 	ldw	r2,-8(fp)
 4002000:	10800317 	ldw	r2,12(r2)
 4002004:	e0bffc15 	stw	r2,-16(fp)

                prvCopyDataFromQueue( pxQueue, pvBuffer );
 4002008:	e17ff817 	ldw	r5,-32(fp)
 400200c:	e13ffe17 	ldw	r4,-8(fp)
 4002010:	40025c40 	call	40025c4 <prvCopyDataFromQueue>
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 4002014:	e0bffe17 	ldw	r2,-8(fp)
 4002018:	e0fffc17 	ldw	r3,-16(fp)
 400201c:	10c00315 	stw	r3,12(r2)

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 4002020:	e0bffe17 	ldw	r2,-8(fp)
 4002024:	10800917 	ldw	r2,36(r2)
 4002028:	10000626 	beq	r2,zero,4002044 <xQueuePeek+0x88>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 400202c:	e0bffe17 	ldw	r2,-8(fp)
 4002030:	10800904 	addi	r2,r2,36
 4002034:	1009883a 	mov	r4,r2
 4002038:	400502c0 	call	400502c <xTaskRemoveFromEventList>
 400203c:	10000126 	beq	r2,zero,4002044 <xQueuePeek+0x88>
                    {
                        /* The task waiting has a higher priority than this task. */
                        queueYIELD_IF_USING_PREEMPTION();
 4002040:	003b683a 	trap	0
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
 4002044:	4005fd00 	call	4005fd0 <vTaskExitCritical>
                return pdPASS;
 4002048:	00800044 	movi	r2,1
 400204c:	00004206 	br	4002158 <xQueuePeek+0x19c>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
 4002050:	e0bff717 	ldw	r2,-36(fp)
 4002054:	1000031e 	bne	r2,zero,4002064 <xQueuePeek+0xa8>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
 4002058:	4005fd00 	call	4005fd0 <vTaskExitCritical>
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
 400205c:	0005883a 	mov	r2,zero
 4002060:	00003d06 	br	4002158 <xQueuePeek+0x19c>
                }
                else if( xEntryTimeSet == pdFALSE )
 4002064:	e0bfff17 	ldw	r2,-4(fp)
 4002068:	1000051e 	bne	r2,zero,4002080 <xQueuePeek+0xc4>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
 400206c:	e0bffa04 	addi	r2,fp,-24
 4002070:	1009883a 	mov	r4,r2
 4002074:	40055980 	call	4005598 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
 4002078:	00800044 	movi	r2,1
 400207c:	e0bfff15 	stw	r2,-4(fp)
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
 4002080:	4005fd00 	call	4005fd0 <vTaskExitCritical>

        /* Interrupts and other tasks can send to and receive from the queue
         * now that the critical section has been exited. */

        vTaskSuspendAll();
 4002084:	40046f00 	call	40046f0 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 4002088:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
 400208c:	e0bffe17 	ldw	r2,-8(fp)
 4002090:	10801103 	ldbu	r2,68(r2)
 4002094:	10803fcc 	andi	r2,r2,255
 4002098:	1080201c 	xori	r2,r2,128
 400209c:	10bfe004 	addi	r2,r2,-128
 40020a0:	10bfffd8 	cmpnei	r2,r2,-1
 40020a4:	1000021e 	bne	r2,zero,40020b0 <xQueuePeek+0xf4>
 40020a8:	e0bffe17 	ldw	r2,-8(fp)
 40020ac:	10001105 	stb	zero,68(r2)
 40020b0:	e0bffe17 	ldw	r2,-8(fp)
 40020b4:	10801143 	ldbu	r2,69(r2)
 40020b8:	10803fcc 	andi	r2,r2,255
 40020bc:	1080201c 	xori	r2,r2,128
 40020c0:	10bfe004 	addi	r2,r2,-128
 40020c4:	10bfffd8 	cmpnei	r2,r2,-1
 40020c8:	1000021e 	bne	r2,zero,40020d4 <xQueuePeek+0x118>
 40020cc:	e0bffe17 	ldw	r2,-8(fp)
 40020d0:	10001145 	stb	zero,69(r2)
 40020d4:	4005fd00 	call	4005fd0 <vTaskExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 40020d8:	e0fff704 	addi	r3,fp,-36
 40020dc:	e0bffa04 	addi	r2,fp,-24
 40020e0:	180b883a 	mov	r5,r3
 40020e4:	1009883a 	mov	r4,r2
 40020e8:	40055d40 	call	40055d4 <xTaskCheckForTimeOut>
 40020ec:	1000131e 	bne	r2,zero,400213c <xQueuePeek+0x180>
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 40020f0:	e13ffe17 	ldw	r4,-8(fp)
 40020f4:	40027540 	call	4002754 <prvIsQueueEmpty>
 40020f8:	10000c26 	beq	r2,zero,400212c <xQueuePeek+0x170>
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 40020fc:	e0bffe17 	ldw	r2,-8(fp)
 4002100:	10800904 	addi	r2,r2,36
 4002104:	e0fff717 	ldw	r3,-36(fp)
 4002108:	180b883a 	mov	r5,r3
 400210c:	1009883a 	mov	r4,r2
 4002110:	4004f200 	call	4004f20 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
 4002114:	e13ffe17 	ldw	r4,-8(fp)
 4002118:	40026600 	call	4002660 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
 400211c:	400471c0 	call	400471c <xTaskResumeAll>
 4002120:	103fb01e 	bne	r2,zero,4001fe4 <xQueuePeek+0x28>
                {
                    portYIELD_WITHIN_API();
 4002124:	003b683a 	trap	0
 4002128:	003fae06 	br	4001fe4 <xQueuePeek+0x28>
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
 400212c:	e13ffe17 	ldw	r4,-8(fp)
 4002130:	40026600 	call	4002660 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
 4002134:	400471c0 	call	400471c <xTaskResumeAll>
 4002138:	003faa06 	br	4001fe4 <xQueuePeek+0x28>
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
 400213c:	e13ffe17 	ldw	r4,-8(fp)
 4002140:	40026600 	call	4002660 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
 4002144:	400471c0 	call	400471c <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 4002148:	e13ffe17 	ldw	r4,-8(fp)
 400214c:	40027540 	call	4002754 <prvIsQueueEmpty>
 4002150:	103fa426 	beq	r2,zero,4001fe4 <xQueuePeek+0x28>
            {
                traceQUEUE_PEEK_FAILED( pxQueue );
                return errQUEUE_EMPTY;
 4002154:	0005883a 	mov	r2,zero
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
 4002158:	e037883a 	mov	sp,fp
 400215c:	dfc00117 	ldw	ra,4(sp)
 4002160:	df000017 	ldw	fp,0(sp)
 4002164:	dec00204 	addi	sp,sp,8
 4002168:	f800283a 	ret

0400216c <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
 400216c:	defff504 	addi	sp,sp,-44
 4002170:	dfc00a15 	stw	ra,40(sp)
 4002174:	df000915 	stw	fp,36(sp)
 4002178:	df000904 	addi	fp,sp,36
 400217c:	e13ff915 	stw	r4,-28(fp)
 4002180:	e17ff815 	stw	r5,-32(fp)
 4002184:	e1bff715 	stw	r6,-36(fp)
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
 4002188:	e0bff917 	ldw	r2,-28(fp)
 400218c:	e0bffe15 	stw	r2,-8(fp)
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4002190:	e03ffd15 	stw	zero,-12(fp)
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 4002194:	e0bffe17 	ldw	r2,-8(fp)
 4002198:	10800e17 	ldw	r2,56(r2)
 400219c:	e0bffc15 	stw	r2,-16(fp)

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 40021a0:	e0bffc17 	ldw	r2,-16(fp)
 40021a4:	10002826 	beq	r2,zero,4002248 <xQueueReceiveFromISR+0xdc>
        {
            const int8_t cRxLock = pxQueue->cRxLock;
 40021a8:	e0bffe17 	ldw	r2,-8(fp)
 40021ac:	10801103 	ldbu	r2,68(r2)
 40021b0:	e0bffbc5 	stb	r2,-17(fp)

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
 40021b4:	e17ff817 	ldw	r5,-32(fp)
 40021b8:	e13ffe17 	ldw	r4,-8(fp)
 40021bc:	40025c40 	call	40025c4 <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 40021c0:	e0bffc17 	ldw	r2,-16(fp)
 40021c4:	10ffffc4 	addi	r3,r2,-1
 40021c8:	e0bffe17 	ldw	r2,-8(fp)
 40021cc:	10c00e15 	stw	r3,56(r2)

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
 40021d0:	e0bffbc7 	ldb	r2,-17(fp)
 40021d4:	10bfffd8 	cmpnei	r2,r2,-1
 40021d8:	10000e1e 	bne	r2,zero,4002214 <xQueueReceiveFromISR+0xa8>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 40021dc:	e0bffe17 	ldw	r2,-8(fp)
 40021e0:	10800417 	ldw	r2,16(r2)
 40021e4:	10001526 	beq	r2,zero,400223c <xQueueReceiveFromISR+0xd0>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 40021e8:	e0bffe17 	ldw	r2,-8(fp)
 40021ec:	10800404 	addi	r2,r2,16
 40021f0:	1009883a 	mov	r4,r2
 40021f4:	400502c0 	call	400502c <xTaskRemoveFromEventList>
 40021f8:	10001026 	beq	r2,zero,400223c <xQueueReceiveFromISR+0xd0>
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
 40021fc:	e0bff717 	ldw	r2,-36(fp)
 4002200:	10000e26 	beq	r2,zero,400223c <xQueueReceiveFromISR+0xd0>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
 4002204:	e0bff717 	ldw	r2,-36(fp)
 4002208:	00c00044 	movi	r3,1
 400220c:	10c00015 	stw	r3,0(r2)
 4002210:	00000a06 	br	400223c <xQueueReceiveFromISR+0xd0>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                prvIncrementQueueRxLock( pxQueue, cRxLock );
 4002214:	4004a440 	call	4004a44 <uxTaskGetNumberOfTasks>
 4002218:	e0bffa15 	stw	r2,-24(fp)
 400221c:	e0fffbc7 	ldb	r3,-17(fp)
 4002220:	e0bffa17 	ldw	r2,-24(fp)
 4002224:	1880052e 	bgeu	r3,r2,400223c <xQueueReceiveFromISR+0xd0>
 4002228:	e0bffbc3 	ldbu	r2,-17(fp)
 400222c:	10800044 	addi	r2,r2,1
 4002230:	1007883a 	mov	r3,r2
 4002234:	e0bffe17 	ldw	r2,-8(fp)
 4002238:	10c01105 	stb	r3,68(r2)
            }

            xReturn = pdPASS;
 400223c:	00800044 	movi	r2,1
 4002240:	e0bfff15 	stw	r2,-4(fp)
 4002244:	00000106 	br	400224c <xQueueReceiveFromISR+0xe0>
        }
        else
        {
            xReturn = pdFAIL;
 4002248:	e03fff15 	stw	zero,-4(fp)
            traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 400224c:	e0bfff17 	ldw	r2,-4(fp)
}
 4002250:	e037883a 	mov	sp,fp
 4002254:	dfc00117 	ldw	ra,4(sp)
 4002258:	df000017 	ldw	fp,0(sp)
 400225c:	dec00204 	addi	sp,sp,8
 4002260:	f800283a 	ret

04002264 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
 4002264:	defff804 	addi	sp,sp,-32
 4002268:	dfc00715 	stw	ra,28(sp)
 400226c:	df000615 	stw	fp,24(sp)
 4002270:	df000604 	addi	fp,sp,24
 4002274:	e13ffb15 	stw	r4,-20(fp)
 4002278:	e17ffa15 	stw	r5,-24(fp)
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
 400227c:	e0bffb17 	ldw	r2,-20(fp)
 4002280:	e0bffe15 	stw	r2,-8(fp)
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4002284:	e03ffd15 	stw	zero,-12(fp)
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 4002288:	e0bffe17 	ldw	r2,-8(fp)
 400228c:	10800e17 	ldw	r2,56(r2)
 4002290:	10000c26 	beq	r2,zero,40022c4 <xQueuePeekFromISR+0x60>
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 4002294:	e0bffe17 	ldw	r2,-8(fp)
 4002298:	10800317 	ldw	r2,12(r2)
 400229c:	e0bffc15 	stw	r2,-16(fp)
            prvCopyDataFromQueue( pxQueue, pvBuffer );
 40022a0:	e17ffa17 	ldw	r5,-24(fp)
 40022a4:	e13ffe17 	ldw	r4,-8(fp)
 40022a8:	40025c40 	call	40025c4 <prvCopyDataFromQueue>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 40022ac:	e0bffe17 	ldw	r2,-8(fp)
 40022b0:	e0fffc17 	ldw	r3,-16(fp)
 40022b4:	10c00315 	stw	r3,12(r2)

            xReturn = pdPASS;
 40022b8:	00800044 	movi	r2,1
 40022bc:	e0bfff15 	stw	r2,-4(fp)
 40022c0:	00000106 	br	40022c8 <xQueuePeekFromISR+0x64>
        }
        else
        {
            xReturn = pdFAIL;
 40022c4:	e03fff15 	stw	zero,-4(fp)
            traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 40022c8:	e0bfff17 	ldw	r2,-4(fp)
}
 40022cc:	e037883a 	mov	sp,fp
 40022d0:	dfc00117 	ldw	ra,4(sp)
 40022d4:	df000017 	ldw	fp,0(sp)
 40022d8:	dec00204 	addi	sp,sp,8
 40022dc:	f800283a 	ret

040022e0 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
 40022e0:	defffc04 	addi	sp,sp,-16
 40022e4:	dfc00315 	stw	ra,12(sp)
 40022e8:	df000215 	stw	fp,8(sp)
 40022ec:	df000204 	addi	fp,sp,8
 40022f0:	e13ffe15 	stw	r4,-8(fp)
    UBaseType_t uxReturn;

    configASSERT( xQueue );

    taskENTER_CRITICAL();
 40022f4:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 40022f8:	e0bffe17 	ldw	r2,-8(fp)
 40022fc:	10800e17 	ldw	r2,56(r2)
 4002300:	e0bfff15 	stw	r2,-4(fp)
    }
    taskEXIT_CRITICAL();
 4002304:	4005fd00 	call	4005fd0 <vTaskExitCritical>

    return uxReturn;
 4002308:	e0bfff17 	ldw	r2,-4(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 400230c:	e037883a 	mov	sp,fp
 4002310:	dfc00117 	ldw	ra,4(sp)
 4002314:	df000017 	ldw	fp,0(sp)
 4002318:	dec00204 	addi	sp,sp,8
 400231c:	f800283a 	ret

04002320 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
 4002320:	defffb04 	addi	sp,sp,-20
 4002324:	dfc00415 	stw	ra,16(sp)
 4002328:	df000315 	stw	fp,12(sp)
 400232c:	df000304 	addi	fp,sp,12
 4002330:	e13ffd15 	stw	r4,-12(fp)
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
 4002334:	e0bffd17 	ldw	r2,-12(fp)
 4002338:	e0bfff15 	stw	r2,-4(fp)

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
 400233c:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
 4002340:	e0bfff17 	ldw	r2,-4(fp)
 4002344:	10c00f17 	ldw	r3,60(r2)
 4002348:	e0bfff17 	ldw	r2,-4(fp)
 400234c:	10800e17 	ldw	r2,56(r2)
 4002350:	1885c83a 	sub	r2,r3,r2
 4002354:	e0bffe15 	stw	r2,-8(fp)
    }
    taskEXIT_CRITICAL();
 4002358:	4005fd00 	call	4005fd0 <vTaskExitCritical>

    return uxReturn;
 400235c:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 4002360:	e037883a 	mov	sp,fp
 4002364:	dfc00117 	ldw	ra,4(sp)
 4002368:	df000017 	ldw	fp,0(sp)
 400236c:	dec00204 	addi	sp,sp,8
 4002370:	f800283a 	ret

04002374 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
 4002374:	defffc04 	addi	sp,sp,-16
 4002378:	df000315 	stw	fp,12(sp)
 400237c:	df000304 	addi	fp,sp,12
 4002380:	e13ffd15 	stw	r4,-12(fp)
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
 4002384:	e0bffd17 	ldw	r2,-12(fp)
 4002388:	e0bfff15 	stw	r2,-4(fp)

    configASSERT( pxQueue );
    uxReturn = pxQueue->uxMessagesWaiting;
 400238c:	e0bfff17 	ldw	r2,-4(fp)
 4002390:	10800e17 	ldw	r2,56(r2)
 4002394:	e0bffe15 	stw	r2,-8(fp)

    return uxReturn;
 4002398:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 400239c:	e037883a 	mov	sp,fp
 40023a0:	df000017 	ldw	fp,0(sp)
 40023a4:	dec00104 	addi	sp,sp,4
 40023a8:	f800283a 	ret

040023ac <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
 40023ac:	defffc04 	addi	sp,sp,-16
 40023b0:	dfc00315 	stw	ra,12(sp)
 40023b4:	df000215 	stw	fp,8(sp)
 40023b8:	df000204 	addi	fp,sp,8
 40023bc:	e13ffe15 	stw	r4,-8(fp)
    Queue_t * const pxQueue = xQueue;
 40023c0:	e0bffe17 	ldw	r2,-8(fp)
 40023c4:	e0bfff15 	stw	r2,-4(fp)

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
    {
        /* The queue can only have been allocated dynamically - free it
         * again. */
        vPortFree( pxQueue );
 40023c8:	e13fff17 	ldw	r4,-4(fp)
 40023cc:	40011240 	call	4001124 <vPortFree>
        /* The queue must have been statically allocated, so is not going to be
         * deleted.  Avoid compiler warnings about the unused parameter. */
        ( void ) pxQueue;
    }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
 40023d0:	0001883a 	nop
 40023d4:	e037883a 	mov	sp,fp
 40023d8:	dfc00117 	ldw	ra,4(sp)
 40023dc:	df000017 	ldw	fp,0(sp)
 40023e0:	dec00204 	addi	sp,sp,8
 40023e4:	f800283a 	ret

040023e8 <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
    {
 40023e8:	defffd04 	addi	sp,sp,-12
 40023ec:	df000215 	stw	fp,8(sp)
 40023f0:	df000204 	addi	fp,sp,8
 40023f4:	e13ffe15 	stw	r4,-8(fp)
         * priority, but the waiting task times out, then the holder should
         * disinherit the priority - but only down to the highest priority of any
         * other tasks that are waiting for the same mutex.  For this purpose,
         * return the priority of the highest priority task that is waiting for the
         * mutex. */
        if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
 40023f8:	e0bffe17 	ldw	r2,-8(fp)
 40023fc:	10800917 	ldw	r2,36(r2)
 4002400:	10000726 	beq	r2,zero,4002420 <prvGetDisinheritPriorityAfterTimeout+0x38>
        {
            uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
 4002404:	e0bffe17 	ldw	r2,-8(fp)
 4002408:	10800c17 	ldw	r2,48(r2)
 400240c:	10800017 	ldw	r2,0(r2)
 4002410:	00c00144 	movi	r3,5
 4002414:	1885c83a 	sub	r2,r3,r2
 4002418:	e0bfff15 	stw	r2,-4(fp)
 400241c:	00000106 	br	4002424 <prvGetDisinheritPriorityAfterTimeout+0x3c>
        }
        else
        {
            uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
 4002420:	e03fff15 	stw	zero,-4(fp)
        }

        return uxHighestPriorityOfWaitingTasks;
 4002424:	e0bfff17 	ldw	r2,-4(fp)
    }
 4002428:	e037883a 	mov	sp,fp
 400242c:	df000017 	ldw	fp,0(sp)
 4002430:	dec00104 	addi	sp,sp,4
 4002434:	f800283a 	ret

04002438 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
 4002438:	defff904 	addi	sp,sp,-28
 400243c:	dfc00615 	stw	ra,24(sp)
 4002440:	df000515 	stw	fp,20(sp)
 4002444:	df000504 	addi	fp,sp,20
 4002448:	e13ffd15 	stw	r4,-12(fp)
 400244c:	e17ffc15 	stw	r5,-16(fp)
 4002450:	e1bffb15 	stw	r6,-20(fp)
    BaseType_t xReturn = pdFALSE;
 4002454:	e03fff15 	stw	zero,-4(fp)
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 4002458:	e0bffd17 	ldw	r2,-12(fp)
 400245c:	10800e17 	ldw	r2,56(r2)
 4002460:	e0bffe15 	stw	r2,-8(fp)

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 4002464:	e0bffd17 	ldw	r2,-12(fp)
 4002468:	10801017 	ldw	r2,64(r2)
 400246c:	10000b1e 	bne	r2,zero,400249c <prvCopyDataToQueue+0x64>
    {
        #if ( configUSE_MUTEXES == 1 )
        {
            if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 4002470:	e0bffd17 	ldw	r2,-12(fp)
 4002474:	10800017 	ldw	r2,0(r2)
 4002478:	1000481e 	bne	r2,zero,400259c <prvCopyDataToQueue+0x164>
            {
                /* The mutex is no longer being held. */
                xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
 400247c:	e0bffd17 	ldw	r2,-12(fp)
 4002480:	10800217 	ldw	r2,8(r2)
 4002484:	1009883a 	mov	r4,r2
 4002488:	4005bc00 	call	4005bc0 <xTaskPriorityDisinherit>
 400248c:	e0bfff15 	stw	r2,-4(fp)
                pxQueue->u.xSemaphore.xMutexHolder = NULL;
 4002490:	e0bffd17 	ldw	r2,-12(fp)
 4002494:	10000215 	stw	zero,8(r2)
 4002498:	00004006 	br	400259c <prvCopyDataToQueue+0x164>
                mtCOVERAGE_TEST_MARKER();
            }
        }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
 400249c:	e0bffb17 	ldw	r2,-20(fp)
 40024a0:	1000191e 	bne	r2,zero,4002508 <prvCopyDataToQueue+0xd0>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 40024a4:	e0bffd17 	ldw	r2,-12(fp)
 40024a8:	10c00117 	ldw	r3,4(r2)
 40024ac:	e0bffd17 	ldw	r2,-12(fp)
 40024b0:	10801017 	ldw	r2,64(r2)
 40024b4:	100d883a 	mov	r6,r2
 40024b8:	e17ffc17 	ldw	r5,-16(fp)
 40024bc:	1809883a 	mov	r4,r3
 40024c0:	40075cc0 	call	40075cc <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 40024c4:	e0bffd17 	ldw	r2,-12(fp)
 40024c8:	10c00117 	ldw	r3,4(r2)
 40024cc:	e0bffd17 	ldw	r2,-12(fp)
 40024d0:	10801017 	ldw	r2,64(r2)
 40024d4:	1887883a 	add	r3,r3,r2
 40024d8:	e0bffd17 	ldw	r2,-12(fp)
 40024dc:	10c00115 	stw	r3,4(r2)

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 40024e0:	e0bffd17 	ldw	r2,-12(fp)
 40024e4:	10c00117 	ldw	r3,4(r2)
 40024e8:	e0bffd17 	ldw	r2,-12(fp)
 40024ec:	10800217 	ldw	r2,8(r2)
 40024f0:	18802a36 	bltu	r3,r2,400259c <prvCopyDataToQueue+0x164>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
 40024f4:	e0bffd17 	ldw	r2,-12(fp)
 40024f8:	10c00017 	ldw	r3,0(r2)
 40024fc:	e0bffd17 	ldw	r2,-12(fp)
 4002500:	10c00115 	stw	r3,4(r2)
 4002504:	00002506 	br	400259c <prvCopyDataToQueue+0x164>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
 4002508:	e0bffd17 	ldw	r2,-12(fp)
 400250c:	10c00317 	ldw	r3,12(r2)
 4002510:	e0bffd17 	ldw	r2,-12(fp)
 4002514:	10801017 	ldw	r2,64(r2)
 4002518:	100d883a 	mov	r6,r2
 400251c:	e17ffc17 	ldw	r5,-16(fp)
 4002520:	1809883a 	mov	r4,r3
 4002524:	40075cc0 	call	40075cc <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 4002528:	e0bffd17 	ldw	r2,-12(fp)
 400252c:	10c00317 	ldw	r3,12(r2)
 4002530:	e0bffd17 	ldw	r2,-12(fp)
 4002534:	10801017 	ldw	r2,64(r2)
 4002538:	0085c83a 	sub	r2,zero,r2
 400253c:	1887883a 	add	r3,r3,r2
 4002540:	e0bffd17 	ldw	r2,-12(fp)
 4002544:	10c00315 	stw	r3,12(r2)

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 4002548:	e0bffd17 	ldw	r2,-12(fp)
 400254c:	10c00317 	ldw	r3,12(r2)
 4002550:	e0bffd17 	ldw	r2,-12(fp)
 4002554:	10800017 	ldw	r2,0(r2)
 4002558:	1880082e 	bgeu	r3,r2,400257c <prvCopyDataToQueue+0x144>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
 400255c:	e0bffd17 	ldw	r2,-12(fp)
 4002560:	10c00217 	ldw	r3,8(r2)
 4002564:	e0bffd17 	ldw	r2,-12(fp)
 4002568:	10801017 	ldw	r2,64(r2)
 400256c:	0085c83a 	sub	r2,zero,r2
 4002570:	1887883a 	add	r3,r3,r2
 4002574:	e0bffd17 	ldw	r2,-12(fp)
 4002578:	10c00315 	stw	r3,12(r2)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
 400257c:	e0bffb17 	ldw	r2,-20(fp)
 4002580:	10800098 	cmpnei	r2,r2,2
 4002584:	1000051e 	bne	r2,zero,400259c <prvCopyDataToQueue+0x164>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 4002588:	e0bffe17 	ldw	r2,-8(fp)
 400258c:	10000326 	beq	r2,zero,400259c <prvCopyDataToQueue+0x164>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
 4002590:	e0bffe17 	ldw	r2,-8(fp)
 4002594:	10bfffc4 	addi	r2,r2,-1
 4002598:	e0bffe15 	stw	r2,-8(fp)
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 400259c:	e0bffe17 	ldw	r2,-8(fp)
 40025a0:	10c00044 	addi	r3,r2,1
 40025a4:	e0bffd17 	ldw	r2,-12(fp)
 40025a8:	10c00e15 	stw	r3,56(r2)

    return xReturn;
 40025ac:	e0bfff17 	ldw	r2,-4(fp)
}
 40025b0:	e037883a 	mov	sp,fp
 40025b4:	dfc00117 	ldw	ra,4(sp)
 40025b8:	df000017 	ldw	fp,0(sp)
 40025bc:	dec00204 	addi	sp,sp,8
 40025c0:	f800283a 	ret

040025c4 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
 40025c4:	defffc04 	addi	sp,sp,-16
 40025c8:	dfc00315 	stw	ra,12(sp)
 40025cc:	df000215 	stw	fp,8(sp)
 40025d0:	df000204 	addi	fp,sp,8
 40025d4:	e13fff15 	stw	r4,-4(fp)
 40025d8:	e17ffe15 	stw	r5,-8(fp)
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 40025dc:	e0bfff17 	ldw	r2,-4(fp)
 40025e0:	10801017 	ldw	r2,64(r2)
 40025e4:	10001826 	beq	r2,zero,4002648 <prvCopyDataFromQueue+0x84>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 40025e8:	e0bfff17 	ldw	r2,-4(fp)
 40025ec:	10c00317 	ldw	r3,12(r2)
 40025f0:	e0bfff17 	ldw	r2,-4(fp)
 40025f4:	10801017 	ldw	r2,64(r2)
 40025f8:	1887883a 	add	r3,r3,r2
 40025fc:	e0bfff17 	ldw	r2,-4(fp)
 4002600:	10c00315 	stw	r3,12(r2)

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 4002604:	e0bfff17 	ldw	r2,-4(fp)
 4002608:	10c00317 	ldw	r3,12(r2)
 400260c:	e0bfff17 	ldw	r2,-4(fp)
 4002610:	10800217 	ldw	r2,8(r2)
 4002614:	18800436 	bltu	r3,r2,4002628 <prvCopyDataFromQueue+0x64>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 4002618:	e0bfff17 	ldw	r2,-4(fp)
 400261c:	10c00017 	ldw	r3,0(r2)
 4002620:	e0bfff17 	ldw	r2,-4(fp)
 4002624:	10c00315 	stw	r3,12(r2)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 4002628:	e0bfff17 	ldw	r2,-4(fp)
 400262c:	10c00317 	ldw	r3,12(r2)
 4002630:	e0bfff17 	ldw	r2,-4(fp)
 4002634:	10801017 	ldw	r2,64(r2)
 4002638:	100d883a 	mov	r6,r2
 400263c:	180b883a 	mov	r5,r3
 4002640:	e13ffe17 	ldw	r4,-8(fp)
 4002644:	40075cc0 	call	40075cc <memcpy>
    }
}
 4002648:	0001883a 	nop
 400264c:	e037883a 	mov	sp,fp
 4002650:	dfc00117 	ldw	ra,4(sp)
 4002654:	df000017 	ldw	fp,0(sp)
 4002658:	dec00204 	addi	sp,sp,8
 400265c:	f800283a 	ret

04002660 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 4002660:	defffc04 	addi	sp,sp,-16
 4002664:	dfc00315 	stw	ra,12(sp)
 4002668:	df000215 	stw	fp,8(sp)
 400266c:	df000204 	addi	fp,sp,8
 4002670:	e13ffe15 	stw	r4,-8(fp)

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
 4002674:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
    {
        int8_t cTxLock = pxQueue->cTxLock;
 4002678:	e0bffe17 	ldw	r2,-8(fp)
 400267c:	10801143 	ldbu	r2,69(r2)
 4002680:	e0bfffc5 	stb	r2,-1(fp)

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
 4002684:	00000c06 	br	40026b8 <prvUnlockQueue+0x58>
            }
            #else /* configUSE_QUEUE_SETS */
            {
                /* Tasks that are removed from the event list will get added to
                 * the pending ready list as the scheduler is still suspended. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 4002688:	e0bffe17 	ldw	r2,-8(fp)
 400268c:	10800917 	ldw	r2,36(r2)
 4002690:	10000c26 	beq	r2,zero,40026c4 <prvUnlockQueue+0x64>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 4002694:	e0bffe17 	ldw	r2,-8(fp)
 4002698:	10800904 	addi	r2,r2,36
 400269c:	1009883a 	mov	r4,r2
 40026a0:	400502c0 	call	400502c <xTaskRemoveFromEventList>
 40026a4:	10000126 	beq	r2,zero,40026ac <prvUnlockQueue+0x4c>
                    {
                        /* The task waiting has a higher priority so record that
                         * a context switch is required. */
                        vTaskMissedYield();
 40026a8:	40056bc0 	call	40056bc <vTaskMissedYield>
                    break;
                }
            }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
 40026ac:	e0bfffc3 	ldbu	r2,-1(fp)
 40026b0:	10bfffc4 	addi	r2,r2,-1
 40026b4:	e0bfffc5 	stb	r2,-1(fp)
        while( cTxLock > queueLOCKED_UNMODIFIED )
 40026b8:	e0bfffc7 	ldb	r2,-1(fp)
 40026bc:	00bff216 	blt	zero,r2,4002688 <prvUnlockQueue+0x28>
 40026c0:	00000106 	br	40026c8 <prvUnlockQueue+0x68>
                    break;
 40026c4:	0001883a 	nop
        }

        pxQueue->cTxLock = queueUNLOCKED;
 40026c8:	e0bffe17 	ldw	r2,-8(fp)
 40026cc:	00ffffc4 	movi	r3,-1
 40026d0:	10c01145 	stb	r3,69(r2)
    }
    taskEXIT_CRITICAL();
 40026d4:	4005fd00 	call	4005fd0 <vTaskExitCritical>

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
 40026d8:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
    {
        int8_t cRxLock = pxQueue->cRxLock;
 40026dc:	e0bffe17 	ldw	r2,-8(fp)
 40026e0:	10801103 	ldbu	r2,68(r2)
 40026e4:	e0bfff85 	stb	r2,-2(fp)

        while( cRxLock > queueLOCKED_UNMODIFIED )
 40026e8:	00000c06 	br	400271c <prvUnlockQueue+0xbc>
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 40026ec:	e0bffe17 	ldw	r2,-8(fp)
 40026f0:	10800417 	ldw	r2,16(r2)
 40026f4:	10000c26 	beq	r2,zero,4002728 <prvUnlockQueue+0xc8>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 40026f8:	e0bffe17 	ldw	r2,-8(fp)
 40026fc:	10800404 	addi	r2,r2,16
 4002700:	1009883a 	mov	r4,r2
 4002704:	400502c0 	call	400502c <xTaskRemoveFromEventList>
 4002708:	10000126 	beq	r2,zero,4002710 <prvUnlockQueue+0xb0>
                {
                    vTaskMissedYield();
 400270c:	40056bc0 	call	40056bc <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
 4002710:	e0bfff83 	ldbu	r2,-2(fp)
 4002714:	10bfffc4 	addi	r2,r2,-1
 4002718:	e0bfff85 	stb	r2,-2(fp)
        while( cRxLock > queueLOCKED_UNMODIFIED )
 400271c:	e0bfff87 	ldb	r2,-2(fp)
 4002720:	00bff216 	blt	zero,r2,40026ec <prvUnlockQueue+0x8c>
 4002724:	00000106 	br	400272c <prvUnlockQueue+0xcc>
            }
            else
            {
                break;
 4002728:	0001883a 	nop
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
 400272c:	e0bffe17 	ldw	r2,-8(fp)
 4002730:	00ffffc4 	movi	r3,-1
 4002734:	10c01105 	stb	r3,68(r2)
    }
    taskEXIT_CRITICAL();
 4002738:	4005fd00 	call	4005fd0 <vTaskExitCritical>
}
 400273c:	0001883a 	nop
 4002740:	e037883a 	mov	sp,fp
 4002744:	dfc00117 	ldw	ra,4(sp)
 4002748:	df000017 	ldw	fp,0(sp)
 400274c:	dec00204 	addi	sp,sp,8
 4002750:	f800283a 	ret

04002754 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
 4002754:	defffc04 	addi	sp,sp,-16
 4002758:	dfc00315 	stw	ra,12(sp)
 400275c:	df000215 	stw	fp,8(sp)
 4002760:	df000204 	addi	fp,sp,8
 4002764:	e13ffe15 	stw	r4,-8(fp)
    BaseType_t xReturn;

    taskENTER_CRITICAL();
 4002768:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 400276c:	e0bffe17 	ldw	r2,-8(fp)
 4002770:	10800e17 	ldw	r2,56(r2)
 4002774:	1000031e 	bne	r2,zero,4002784 <prvIsQueueEmpty+0x30>
        {
            xReturn = pdTRUE;
 4002778:	00800044 	movi	r2,1
 400277c:	e0bfff15 	stw	r2,-4(fp)
 4002780:	00000106 	br	4002788 <prvIsQueueEmpty+0x34>
        }
        else
        {
            xReturn = pdFALSE;
 4002784:	e03fff15 	stw	zero,-4(fp)
        }
    }
    taskEXIT_CRITICAL();
 4002788:	4005fd00 	call	4005fd0 <vTaskExitCritical>

    return xReturn;
 400278c:	e0bfff17 	ldw	r2,-4(fp)
}
 4002790:	e037883a 	mov	sp,fp
 4002794:	dfc00117 	ldw	ra,4(sp)
 4002798:	df000017 	ldw	fp,0(sp)
 400279c:	dec00204 	addi	sp,sp,8
 40027a0:	f800283a 	ret

040027a4 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
 40027a4:	defffc04 	addi	sp,sp,-16
 40027a8:	df000315 	stw	fp,12(sp)
 40027ac:	df000304 	addi	fp,sp,12
 40027b0:	e13ffd15 	stw	r4,-12(fp)
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
 40027b4:	e0bffd17 	ldw	r2,-12(fp)
 40027b8:	e0bffe15 	stw	r2,-8(fp)

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 40027bc:	e0bffe17 	ldw	r2,-8(fp)
 40027c0:	10800e17 	ldw	r2,56(r2)
 40027c4:	1000031e 	bne	r2,zero,40027d4 <xQueueIsQueueEmptyFromISR+0x30>
    {
        xReturn = pdTRUE;
 40027c8:	00800044 	movi	r2,1
 40027cc:	e0bfff15 	stw	r2,-4(fp)
 40027d0:	00000106 	br	40027d8 <xQueueIsQueueEmptyFromISR+0x34>
    }
    else
    {
        xReturn = pdFALSE;
 40027d4:	e03fff15 	stw	zero,-4(fp)
    }

    return xReturn;
 40027d8:	e0bfff17 	ldw	r2,-4(fp)
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 40027dc:	e037883a 	mov	sp,fp
 40027e0:	df000017 	ldw	fp,0(sp)
 40027e4:	dec00104 	addi	sp,sp,4
 40027e8:	f800283a 	ret

040027ec <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
 40027ec:	defffc04 	addi	sp,sp,-16
 40027f0:	dfc00315 	stw	ra,12(sp)
 40027f4:	df000215 	stw	fp,8(sp)
 40027f8:	df000204 	addi	fp,sp,8
 40027fc:	e13ffe15 	stw	r4,-8(fp)
    BaseType_t xReturn;

    taskENTER_CRITICAL();
 4002800:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 4002804:	e0bffe17 	ldw	r2,-8(fp)
 4002808:	10c00e17 	ldw	r3,56(r2)
 400280c:	e0bffe17 	ldw	r2,-8(fp)
 4002810:	10800f17 	ldw	r2,60(r2)
 4002814:	1880031e 	bne	r3,r2,4002824 <prvIsQueueFull+0x38>
        {
            xReturn = pdTRUE;
 4002818:	00800044 	movi	r2,1
 400281c:	e0bfff15 	stw	r2,-4(fp)
 4002820:	00000106 	br	4002828 <prvIsQueueFull+0x3c>
        }
        else
        {
            xReturn = pdFALSE;
 4002824:	e03fff15 	stw	zero,-4(fp)
        }
    }
    taskEXIT_CRITICAL();
 4002828:	4005fd00 	call	4005fd0 <vTaskExitCritical>

    return xReturn;
 400282c:	e0bfff17 	ldw	r2,-4(fp)
}
 4002830:	e037883a 	mov	sp,fp
 4002834:	dfc00117 	ldw	ra,4(sp)
 4002838:	df000017 	ldw	fp,0(sp)
 400283c:	dec00204 	addi	sp,sp,8
 4002840:	f800283a 	ret

04002844 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
 4002844:	defffc04 	addi	sp,sp,-16
 4002848:	df000315 	stw	fp,12(sp)
 400284c:	df000304 	addi	fp,sp,12
 4002850:	e13ffd15 	stw	r4,-12(fp)
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
 4002854:	e0bffd17 	ldw	r2,-12(fp)
 4002858:	e0bffe15 	stw	r2,-8(fp)

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 400285c:	e0bffe17 	ldw	r2,-8(fp)
 4002860:	10c00e17 	ldw	r3,56(r2)
 4002864:	e0bffe17 	ldw	r2,-8(fp)
 4002868:	10800f17 	ldw	r2,60(r2)
 400286c:	1880031e 	bne	r3,r2,400287c <xQueueIsQueueFullFromISR+0x38>
    {
        xReturn = pdTRUE;
 4002870:	00800044 	movi	r2,1
 4002874:	e0bfff15 	stw	r2,-4(fp)
 4002878:	00000106 	br	4002880 <xQueueIsQueueFullFromISR+0x3c>
    }
    else
    {
        xReturn = pdFALSE;
 400287c:	e03fff15 	stw	zero,-4(fp)
    }

    return xReturn;
 4002880:	e0bfff17 	ldw	r2,-4(fp)
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 4002884:	e037883a 	mov	sp,fp
 4002888:	df000017 	ldw	fp,0(sp)
 400288c:	dec00104 	addi	sp,sp,4
 4002890:	f800283a 	ret

04002894 <xStreamBufferGenericCreate>:
    StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,
                                                     size_t xTriggerLevelBytes,
                                                     BaseType_t xIsMessageBuffer,
                                                     StreamBufferCallbackFunction_t pxSendCompletedCallback,
                                                     StreamBufferCallbackFunction_t pxReceiveCompletedCallback )
    {
 4002894:	defff504 	addi	sp,sp,-44
 4002898:	dfc00a15 	stw	ra,40(sp)
 400289c:	df000915 	stw	fp,36(sp)
 40028a0:	df000904 	addi	fp,sp,36
 40028a4:	e13ffd15 	stw	r4,-12(fp)
 40028a8:	e17ffc15 	stw	r5,-16(fp)
 40028ac:	e1bffb15 	stw	r6,-20(fp)
 40028b0:	e1fffa15 	stw	r7,-24(fp)

        /* In case the stream buffer is going to be used as a message buffer
         * (that is, it will hold discrete messages with a little meta data that
         * says how big the next message is) check the buffer will be large enough
         * to hold at least one message. */
        if( xIsMessageBuffer == pdTRUE )
 40028b4:	e0bffb17 	ldw	r2,-20(fp)
 40028b8:	10800058 	cmpnei	r2,r2,1
 40028bc:	1000031e 	bne	r2,zero,40028cc <xStreamBufferGenericCreate+0x38>
        {
            /* Is a message buffer but not statically allocated. */
            ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
 40028c0:	00800044 	movi	r2,1
 40028c4:	e0bffec5 	stb	r2,-5(fp)
 40028c8:	00000106 	br	40028d0 <xStreamBufferGenericCreate+0x3c>
            configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
        }
        else
        {
            /* Not a message buffer and not statically allocated. */
            ucFlags = 0;
 40028cc:	e03ffec5 	stb	zero,-5(fp)

        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

        /* A trigger level of 0 would cause a waiting task to unblock even when
         * the buffer was empty. */
        if( xTriggerLevelBytes == ( size_t ) 0 )
 40028d0:	e0bffc17 	ldw	r2,-16(fp)
 40028d4:	1000021e 	bne	r2,zero,40028e0 <xStreamBufferGenericCreate+0x4c>
        {
            xTriggerLevelBytes = ( size_t ) 1;
 40028d8:	00800044 	movi	r2,1
 40028dc:	e0bffc15 	stw	r2,-16(fp)
         * and the buffer follows immediately after.  The requested size is
         * incremented so the free space is returned as the user would expect -
         * this is a quirk of the implementation that means otherwise the free
         * space would be reported as one byte smaller than would be logically
         * expected. */
        if( xBufferSizeBytes < ( xBufferSizeBytes + 1 + sizeof( StreamBuffer_t ) ) )
 40028e0:	e0bffd17 	ldw	r2,-12(fp)
 40028e4:	00fff784 	movi	r3,-34
 40028e8:	18800936 	bltu	r3,r2,4002910 <xStreamBufferGenericCreate+0x7c>
        {
            xBufferSizeBytes++;
 40028ec:	e0bffd17 	ldw	r2,-12(fp)
 40028f0:	10800044 	addi	r2,r2,1
 40028f4:	e0bffd15 	stw	r2,-12(fp)
            pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
 40028f8:	e0bffd17 	ldw	r2,-12(fp)
 40028fc:	10800804 	addi	r2,r2,32
 4002900:	1009883a 	mov	r4,r2
 4002904:	400103c0 	call	400103c <pvPortMalloc>
 4002908:	e0bfff15 	stw	r2,-4(fp)
 400290c:	00000106 	br	4002914 <xStreamBufferGenericCreate+0x80>
        }
        else
        {
            pucAllocatedMemory = NULL;
 4002910:	e03fff15 	stw	zero,-4(fp)
        }

        if( pucAllocatedMemory != NULL )
 4002914:	e0bfff17 	ldw	r2,-4(fp)
 4002918:	10000d26 	beq	r2,zero,4002950 <xStreamBufferGenericCreate+0xbc>
        {
            prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory,       /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
 400291c:	e0bfff17 	ldw	r2,-4(fp)
 4002920:	11000804 	addi	r4,r2,32
 4002924:	e0bffec3 	ldbu	r2,-5(fp)
 4002928:	e0c00217 	ldw	r3,8(fp)
 400292c:	d8c00215 	stw	r3,8(sp)
 4002930:	e0fffa17 	ldw	r3,-24(fp)
 4002934:	d8c00115 	stw	r3,4(sp)
 4002938:	d8800015 	stw	r2,0(sp)
 400293c:	e1fffc17 	ldw	r7,-16(fp)
 4002940:	e1bffd17 	ldw	r6,-12(fp)
 4002944:	200b883a 	mov	r5,r4
 4002948:	e13fff17 	ldw	r4,-4(fp)
 400294c:	40037340 	call	4003734 <prvInitialiseNewStreamBuffer>
        else
        {
            traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
        }

        return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
 4002950:	e0bfff17 	ldw	r2,-4(fp)
    }
 4002954:	e037883a 	mov	sp,fp
 4002958:	dfc00117 	ldw	ra,4(sp)
 400295c:	df000017 	ldw	fp,0(sp)
 4002960:	dec00204 	addi	sp,sp,8
 4002964:	f800283a 	ret

04002968 <vStreamBufferDelete>:
    }
#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
 4002968:	defffc04 	addi	sp,sp,-16
 400296c:	dfc00315 	stw	ra,12(sp)
 4002970:	df000215 	stw	fp,8(sp)
 4002974:	df000204 	addi	fp,sp,8
 4002978:	e13ffe15 	stw	r4,-8(fp)
    StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
 400297c:	e0bffe17 	ldw	r2,-8(fp)
 4002980:	e0bfff15 	stw	r2,-4(fp)

    configASSERT( pxStreamBuffer );

    traceSTREAM_BUFFER_DELETE( xStreamBuffer );

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
 4002984:	e0bfff17 	ldw	r2,-4(fp)
 4002988:	10800703 	ldbu	r2,28(r2)
 400298c:	10803fcc 	andi	r2,r2,255
 4002990:	1080008c 	andi	r2,r2,2
 4002994:	1000031e 	bne	r2,zero,40029a4 <vStreamBufferDelete+0x3c>
    {
        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
        {
            /* Both the structure and the buffer were allocated using a single call
            * to pvPortMalloc(), hence only one call to vPortFree() is required. */
            vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
 4002998:	e13fff17 	ldw	r4,-4(fp)
 400299c:	40011240 	call	4001124 <vPortFree>
    {
        /* The structure and buffer were not allocated dynamically and cannot be
         * freed - just scrub the structure so future use will assert. */
        ( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    }
}
 40029a0:	00000406 	br	40029b4 <vStreamBufferDelete+0x4c>
        ( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
 40029a4:	01800804 	movi	r6,32
 40029a8:	000b883a 	mov	r5,zero
 40029ac:	e13fff17 	ldw	r4,-4(fp)
 40029b0:	40077540 	call	4007754 <memset>
}
 40029b4:	0001883a 	nop
 40029b8:	e037883a 	mov	sp,fp
 40029bc:	dfc00117 	ldw	ra,4(sp)
 40029c0:	df000017 	ldw	fp,0(sp)
 40029c4:	dec00204 	addi	sp,sp,8
 40029c8:	f800283a 	ret

040029cc <xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
 40029cc:	defff604 	addi	sp,sp,-40
 40029d0:	dfc00915 	stw	ra,36(sp)
 40029d4:	df000815 	stw	fp,32(sp)
 40029d8:	df000804 	addi	fp,sp,32
 40029dc:	e13ffb15 	stw	r4,-20(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 40029e0:	e0bffb17 	ldw	r2,-20(fp)
 40029e4:	e0bffe15 	stw	r2,-8(fp)
    BaseType_t xReturn = pdFAIL;
 40029e8:	e03fff15 	stw	zero,-4(fp)
    StreamBufferCallbackFunction_t pxSendCallback = NULL, pxReceiveCallback = NULL;
 40029ec:	e03ffd15 	stw	zero,-12(fp)
 40029f0:	e03ffc15 	stw	zero,-16(fp)
        uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
    }
    #endif

    /* Can only reset a message buffer if there are no tasks blocked on it. */
    taskENTER_CRITICAL();
 40029f4:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
    {
        if( ( pxStreamBuffer->xTaskWaitingToReceive == NULL ) && ( pxStreamBuffer->xTaskWaitingToSend == NULL ) )
 40029f8:	e0bffe17 	ldw	r2,-8(fp)
 40029fc:	10800417 	ldw	r2,16(r2)
 4002a00:	1000181e 	bne	r2,zero,4002a64 <xStreamBufferReset+0x98>
 4002a04:	e0bffe17 	ldw	r2,-8(fp)
 4002a08:	10800517 	ldw	r2,20(r2)
 4002a0c:	1000151e 	bne	r2,zero,4002a64 <xStreamBufferReset+0x98>
                pxSendCallback = pxStreamBuffer->pxSendCompletedCallback;
                pxReceiveCallback = pxStreamBuffer->pxReceiveCompletedCallback;
            }
            #endif

            prvInitialiseNewStreamBuffer( pxStreamBuffer,
 4002a10:	e0bffe17 	ldw	r2,-8(fp)
 4002a14:	11000617 	ldw	r4,24(r2)
 4002a18:	e0bffe17 	ldw	r2,-8(fp)
 4002a1c:	11400217 	ldw	r5,8(r2)
 4002a20:	e0bffe17 	ldw	r2,-8(fp)
 4002a24:	11800317 	ldw	r6,12(r2)
                                          pxStreamBuffer->pucBuffer,
                                          pxStreamBuffer->xLength,
                                          pxStreamBuffer->xTriggerLevelBytes,
                                          pxStreamBuffer->ucFlags,
 4002a28:	e0bffe17 	ldw	r2,-8(fp)
 4002a2c:	10800703 	ldbu	r2,28(r2)
            prvInitialiseNewStreamBuffer( pxStreamBuffer,
 4002a30:	10803fcc 	andi	r2,r2,255
 4002a34:	e0fffc17 	ldw	r3,-16(fp)
 4002a38:	d8c00215 	stw	r3,8(sp)
 4002a3c:	e0fffd17 	ldw	r3,-12(fp)
 4002a40:	d8c00115 	stw	r3,4(sp)
 4002a44:	d8800015 	stw	r2,0(sp)
 4002a48:	300f883a 	mov	r7,r6
 4002a4c:	280d883a 	mov	r6,r5
 4002a50:	200b883a 	mov	r5,r4
 4002a54:	e13ffe17 	ldw	r4,-8(fp)
 4002a58:	40037340 	call	4003734 <prvInitialiseNewStreamBuffer>
            }
            #endif

            traceSTREAM_BUFFER_RESET( xStreamBuffer );

            xReturn = pdPASS;
 4002a5c:	00800044 	movi	r2,1
 4002a60:	e0bfff15 	stw	r2,-4(fp)
        }
    }
    taskEXIT_CRITICAL();
 4002a64:	4005fd00 	call	4005fd0 <vTaskExitCritical>

    return xReturn;
 4002a68:	e0bfff17 	ldw	r2,-4(fp)
}
 4002a6c:	e037883a 	mov	sp,fp
 4002a70:	dfc00117 	ldw	ra,4(sp)
 4002a74:	df000017 	ldw	fp,0(sp)
 4002a78:	dec00204 	addi	sp,sp,8
 4002a7c:	f800283a 	ret

04002a80 <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer,
                                         size_t xTriggerLevel )
{
 4002a80:	defffb04 	addi	sp,sp,-20
 4002a84:	df000415 	stw	fp,16(sp)
 4002a88:	df000404 	addi	fp,sp,16
 4002a8c:	e13ffd15 	stw	r4,-12(fp)
 4002a90:	e17ffc15 	stw	r5,-16(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4002a94:	e0bffd17 	ldw	r2,-12(fp)
 4002a98:	e0bffe15 	stw	r2,-8(fp)
    BaseType_t xReturn;

    configASSERT( pxStreamBuffer );

    /* It is not valid for the trigger level to be 0. */
    if( xTriggerLevel == ( size_t ) 0 )
 4002a9c:	e0bffc17 	ldw	r2,-16(fp)
 4002aa0:	1000021e 	bne	r2,zero,4002aac <xStreamBufferSetTriggerLevel+0x2c>
    {
        xTriggerLevel = ( size_t ) 1;
 4002aa4:	00800044 	movi	r2,1
 4002aa8:	e0bffc15 	stw	r2,-16(fp)
    }

    /* The trigger level is the number of bytes that must be in the stream
     * buffer before a task that is waiting for data is unblocked. */
    if( xTriggerLevel < pxStreamBuffer->xLength )
 4002aac:	e0bffe17 	ldw	r2,-8(fp)
 4002ab0:	10800217 	ldw	r2,8(r2)
 4002ab4:	e0fffc17 	ldw	r3,-16(fp)
 4002ab8:	1880062e 	bgeu	r3,r2,4002ad4 <xStreamBufferSetTriggerLevel+0x54>
    {
        pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
 4002abc:	e0bffe17 	ldw	r2,-8(fp)
 4002ac0:	e0fffc17 	ldw	r3,-16(fp)
 4002ac4:	10c00315 	stw	r3,12(r2)
        xReturn = pdPASS;
 4002ac8:	00800044 	movi	r2,1
 4002acc:	e0bfff15 	stw	r2,-4(fp)
 4002ad0:	00000106 	br	4002ad8 <xStreamBufferSetTriggerLevel+0x58>
    }
    else
    {
        xReturn = pdFALSE;
 4002ad4:	e03fff15 	stw	zero,-4(fp)
    }

    return xReturn;
 4002ad8:	e0bfff17 	ldw	r2,-4(fp)
}
 4002adc:	e037883a 	mov	sp,fp
 4002ae0:	df000017 	ldw	fp,0(sp)
 4002ae4:	dec00104 	addi	sp,sp,4
 4002ae8:	f800283a 	ret

04002aec <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
 4002aec:	defffb04 	addi	sp,sp,-20
 4002af0:	df000415 	stw	fp,16(sp)
 4002af4:	df000404 	addi	fp,sp,16
 4002af8:	e13ffc15 	stw	r4,-16(fp)
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4002afc:	e0bffc17 	ldw	r2,-16(fp)
 4002b00:	e0bffe15 	stw	r2,-8(fp)
    /* The code below reads xTail and then xHead.  This is safe if the stream
     * buffer is updated once between the two reads - but not if the stream buffer
     * is updated more than once between the two reads - hence the loop. */
    do
    {
        xOriginalTail = pxStreamBuffer->xTail;
 4002b04:	e0bffe17 	ldw	r2,-8(fp)
 4002b08:	10800017 	ldw	r2,0(r2)
 4002b0c:	e0bffd15 	stw	r2,-12(fp)
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
 4002b10:	e0bffe17 	ldw	r2,-8(fp)
 4002b14:	10c00217 	ldw	r3,8(r2)
 4002b18:	e0bffe17 	ldw	r2,-8(fp)
 4002b1c:	10800017 	ldw	r2,0(r2)
 4002b20:	1885883a 	add	r2,r3,r2
 4002b24:	e0bfff15 	stw	r2,-4(fp)
        xSpace -= pxStreamBuffer->xHead;
 4002b28:	e0bffe17 	ldw	r2,-8(fp)
 4002b2c:	10800117 	ldw	r2,4(r2)
 4002b30:	e0ffff17 	ldw	r3,-4(fp)
 4002b34:	1885c83a 	sub	r2,r3,r2
 4002b38:	e0bfff15 	stw	r2,-4(fp)
    } while( xOriginalTail != pxStreamBuffer->xTail );
 4002b3c:	e0bffe17 	ldw	r2,-8(fp)
 4002b40:	10800017 	ldw	r2,0(r2)
 4002b44:	e0fffd17 	ldw	r3,-12(fp)
 4002b48:	18bfee1e 	bne	r3,r2,4002b04 <xStreamBufferSpacesAvailable+0x18>

    xSpace -= ( size_t ) 1;
 4002b4c:	e0bfff17 	ldw	r2,-4(fp)
 4002b50:	10bfffc4 	addi	r2,r2,-1
 4002b54:	e0bfff15 	stw	r2,-4(fp)

    if( xSpace >= pxStreamBuffer->xLength )
 4002b58:	e0bffe17 	ldw	r2,-8(fp)
 4002b5c:	10800217 	ldw	r2,8(r2)
 4002b60:	e0ffff17 	ldw	r3,-4(fp)
 4002b64:	18800536 	bltu	r3,r2,4002b7c <xStreamBufferSpacesAvailable+0x90>
    {
        xSpace -= pxStreamBuffer->xLength;
 4002b68:	e0bffe17 	ldw	r2,-8(fp)
 4002b6c:	10800217 	ldw	r2,8(r2)
 4002b70:	e0ffff17 	ldw	r3,-4(fp)
 4002b74:	1885c83a 	sub	r2,r3,r2
 4002b78:	e0bfff15 	stw	r2,-4(fp)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xSpace;
 4002b7c:	e0bfff17 	ldw	r2,-4(fp)
}
 4002b80:	e037883a 	mov	sp,fp
 4002b84:	df000017 	ldw	fp,0(sp)
 4002b88:	dec00104 	addi	sp,sp,4
 4002b8c:	f800283a 	ret

04002b90 <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
 4002b90:	defffb04 	addi	sp,sp,-20
 4002b94:	dfc00415 	stw	ra,16(sp)
 4002b98:	df000315 	stw	fp,12(sp)
 4002b9c:	df000304 	addi	fp,sp,12
 4002ba0:	e13ffd15 	stw	r4,-12(fp)
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4002ba4:	e0bffd17 	ldw	r2,-12(fp)
 4002ba8:	e0bfff15 	stw	r2,-4(fp)
    size_t xReturn;

    configASSERT( pxStreamBuffer );

    xReturn = prvBytesInBuffer( pxStreamBuffer );
 4002bac:	e13fff17 	ldw	r4,-4(fp)
 4002bb0:	40036c00 	call	40036c0 <prvBytesInBuffer>
 4002bb4:	e0bffe15 	stw	r2,-8(fp)
    return xReturn;
 4002bb8:	e0bffe17 	ldw	r2,-8(fp)
}
 4002bbc:	e037883a 	mov	sp,fp
 4002bc0:	dfc00117 	ldw	ra,4(sp)
 4002bc4:	df000017 	ldw	fp,0(sp)
 4002bc8:	dec00204 	addi	sp,sp,8
 4002bcc:	f800283a 	ret

04002bd0 <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
                          const void * pvTxData,
                          size_t xDataLengthBytes,
                          TickType_t xTicksToWait )
{
 4002bd0:	defff204 	addi	sp,sp,-56
 4002bd4:	dfc00d15 	stw	ra,52(sp)
 4002bd8:	df000c15 	stw	fp,48(sp)
 4002bdc:	df000c04 	addi	fp,sp,48
 4002be0:	e13ff815 	stw	r4,-32(fp)
 4002be4:	e17ff715 	stw	r5,-36(fp)
 4002be8:	e1bff615 	stw	r6,-40(fp)
 4002bec:	e1fff515 	stw	r7,-44(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4002bf0:	e0bff817 	ldw	r2,-32(fp)
 4002bf4:	e0bffd15 	stw	r2,-12(fp)
    size_t xReturn, xSpace = 0;
 4002bf8:	e03fff15 	stw	zero,-4(fp)
    size_t xRequiredSpace = xDataLengthBytes;
 4002bfc:	e0bff617 	ldw	r2,-40(fp)
 4002c00:	e0bffe15 	stw	r2,-8(fp)
    TimeOut_t xTimeOut;
    size_t xMaxReportedSpace = 0;
 4002c04:	e03ffc15 	stw	zero,-16(fp)
    configASSERT( pvTxData );
    configASSERT( pxStreamBuffer );

    /* The maximum amount of space a stream buffer will ever report is its length
     * minus 1. */
    xMaxReportedSpace = pxStreamBuffer->xLength - ( size_t ) 1;
 4002c08:	e0bffd17 	ldw	r2,-12(fp)
 4002c0c:	10800217 	ldw	r2,8(r2)
 4002c10:	10bfffc4 	addi	r2,r2,-1
 4002c14:	e0bffc15 	stw	r2,-16(fp)

    /* This send function is used to write to both message buffers and stream
     * buffers.  If this is a message buffer then the space needed must be
     * increased by the amount of bytes needed to store the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 4002c18:	e0bffd17 	ldw	r2,-12(fp)
 4002c1c:	10800703 	ldbu	r2,28(r2)
 4002c20:	10803fcc 	andi	r2,r2,255
 4002c24:	1080004c 	andi	r2,r2,1
 4002c28:	10000826 	beq	r2,zero,4002c4c <xStreamBufferSend+0x7c>
    {
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
 4002c2c:	e0bffe17 	ldw	r2,-8(fp)
 4002c30:	10800104 	addi	r2,r2,4
 4002c34:	e0bffe15 	stw	r2,-8(fp)
        /* Overflow? */
        configASSERT( xRequiredSpace > xDataLengthBytes );

        /* If this is a message buffer then it must be possible to write the
         * whole message. */
        if( xRequiredSpace > xMaxReportedSpace )
 4002c38:	e0bffe17 	ldw	r2,-8(fp)
 4002c3c:	e0fffc17 	ldw	r3,-16(fp)
 4002c40:	1880072e 	bgeu	r3,r2,4002c60 <xStreamBufferSend+0x90>
        {
            /* The message would not fit even if the entire buffer was empty,
             * so don't wait for space. */
            xTicksToWait = ( TickType_t ) 0;
 4002c44:	e03ff515 	stw	zero,-44(fp)
 4002c48:	00000506 	br	4002c60 <xStreamBufferSend+0x90>
    else
    {
        /* If this is a stream buffer then it is acceptable to write only part
         * of the message to the buffer.  Cap the length to the total length of
         * the buffer. */
        if( xRequiredSpace > xMaxReportedSpace )
 4002c4c:	e0bffe17 	ldw	r2,-8(fp)
 4002c50:	e0fffc17 	ldw	r3,-16(fp)
 4002c54:	1880022e 	bgeu	r3,r2,4002c60 <xStreamBufferSend+0x90>
        {
            xRequiredSpace = xMaxReportedSpace;
 4002c58:	e0bffc17 	ldw	r2,-16(fp)
 4002c5c:	e0bffe15 	stw	r2,-8(fp)
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    if( xTicksToWait != ( TickType_t ) 0 )
 4002c60:	e0bff517 	ldw	r2,-44(fp)
 4002c64:	10002426 	beq	r2,zero,4002cf8 <xStreamBufferSend+0x128>
    {
        vTaskSetTimeOutState( &xTimeOut );
 4002c68:	e0bff904 	addi	r2,fp,-28
 4002c6c:	1009883a 	mov	r4,r2
 4002c70:	400554c0 	call	400554c <vTaskSetTimeOutState>

        do
        {
            /* Wait until the required number of bytes are free in the message
             * buffer. */
            taskENTER_CRITICAL();
 4002c74:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
            {
                xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
 4002c78:	e13ffd17 	ldw	r4,-12(fp)
 4002c7c:	4002aec0 	call	4002aec <xStreamBufferSpacesAvailable>
 4002c80:	e0bfff15 	stw	r2,-4(fp)

                if( xSpace < xRequiredSpace )
 4002c84:	e0ffff17 	ldw	r3,-4(fp)
 4002c88:	e0bffe17 	ldw	r2,-8(fp)
 4002c8c:	1880082e 	bgeu	r3,r2,4002cb0 <xStreamBufferSend+0xe0>
                {
                    /* Clear notification state as going to wait for space. */
                    ( void ) xTaskNotifyStateClear( NULL );
 4002c90:	000b883a 	mov	r5,zero
 4002c94:	0009883a 	mov	r4,zero
 4002c98:	4006d040 	call	4006d04 <xTaskGenericNotifyStateClear>

                    /* Should only be one writer. */
                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
 4002c9c:	40059900 	call	4005990 <xTaskGetCurrentTaskHandle>
 4002ca0:	1007883a 	mov	r3,r2
 4002ca4:	e0bffd17 	ldw	r2,-12(fp)
 4002ca8:	10c00515 	stw	r3,20(r2)
 4002cac:	00000206 	br	4002cb8 <xStreamBufferSend+0xe8>
                }
                else
                {
                    taskEXIT_CRITICAL();
 4002cb0:	4005fd00 	call	4005fd0 <vTaskExitCritical>
                    break;
 4002cb4:	00001006 	br	4002cf8 <xStreamBufferSend+0x128>
                }
            }
            taskEXIT_CRITICAL();
 4002cb8:	4005fd00 	call	4005fd0 <vTaskExitCritical>

            traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
 4002cbc:	e0bff517 	ldw	r2,-44(fp)
 4002cc0:	d8800015 	stw	r2,0(sp)
 4002cc4:	000f883a 	mov	r7,zero
 4002cc8:	000d883a 	mov	r6,zero
 4002ccc:	000b883a 	mov	r5,zero
 4002cd0:	0009883a 	mov	r4,zero
 4002cd4:	40061b40 	call	40061b4 <xTaskGenericNotifyWait>
            pxStreamBuffer->xTaskWaitingToSend = NULL;
 4002cd8:	e0bffd17 	ldw	r2,-12(fp)
 4002cdc:	10000515 	stw	zero,20(r2)
        } while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
 4002ce0:	e0fff504 	addi	r3,fp,-44
 4002ce4:	e0bff904 	addi	r2,fp,-28
 4002ce8:	180b883a 	mov	r5,r3
 4002cec:	1009883a 	mov	r4,r2
 4002cf0:	40055d40 	call	40055d4 <xTaskCheckForTimeOut>
 4002cf4:	103fdf26 	beq	r2,zero,4002c74 <xStreamBufferSend+0xa4>
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    if( xSpace == ( size_t ) 0 )
 4002cf8:	e0bfff17 	ldw	r2,-4(fp)
 4002cfc:	1000031e 	bne	r2,zero,4002d0c <xStreamBufferSend+0x13c>
    {
        xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
 4002d00:	e13ffd17 	ldw	r4,-12(fp)
 4002d04:	4002aec0 	call	4002aec <xStreamBufferSpacesAvailable>
 4002d08:	e0bfff15 	stw	r2,-4(fp)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
 4002d0c:	e0bffe17 	ldw	r2,-8(fp)
 4002d10:	d8800015 	stw	r2,0(sp)
 4002d14:	e1ffff17 	ldw	r7,-4(fp)
 4002d18:	e1bff617 	ldw	r6,-40(fp)
 4002d1c:	e17ff717 	ldw	r5,-36(fp)
 4002d20:	e13ffd17 	ldw	r4,-12(fp)
 4002d24:	4002e940 	call	4002e94 <prvWriteMessageToBuffer>
 4002d28:	e0bffb15 	stw	r2,-20(fp)

    if( xReturn > ( size_t ) 0 )
 4002d2c:	e0bffb17 	ldw	r2,-20(fp)
 4002d30:	10001526 	beq	r2,zero,4002d88 <xStreamBufferSend+0x1b8>
    {
        traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

        /* Was a task waiting for the data? */
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
 4002d34:	e13ffd17 	ldw	r4,-12(fp)
 4002d38:	40036c00 	call	40036c0 <prvBytesInBuffer>
 4002d3c:	1007883a 	mov	r3,r2
 4002d40:	e0bffd17 	ldw	r2,-12(fp)
 4002d44:	10800317 	ldw	r2,12(r2)
 4002d48:	18800f36 	bltu	r3,r2,4002d88 <xStreamBufferSend+0x1b8>
        {
            prvSEND_COMPLETED( pxStreamBuffer );
 4002d4c:	40046f00 	call	40046f0 <vTaskSuspendAll>
 4002d50:	e0bffd17 	ldw	r2,-12(fp)
 4002d54:	10800417 	ldw	r2,16(r2)
 4002d58:	10000a26 	beq	r2,zero,4002d84 <xStreamBufferSend+0x1b4>
 4002d5c:	e0bffd17 	ldw	r2,-12(fp)
 4002d60:	10800417 	ldw	r2,16(r2)
 4002d64:	d8000015 	stw	zero,0(sp)
 4002d68:	000f883a 	mov	r7,zero
 4002d6c:	000d883a 	mov	r6,zero
 4002d70:	000b883a 	mov	r5,zero
 4002d74:	1009883a 	mov	r4,r2
 4002d78:	40063180 	call	4006318 <xTaskGenericNotify>
 4002d7c:	e0bffd17 	ldw	r2,-12(fp)
 4002d80:	10000415 	stw	zero,16(r2)
 4002d84:	400471c0 	call	400471c <xTaskResumeAll>
    {
        mtCOVERAGE_TEST_MARKER();
        traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
    }

    return xReturn;
 4002d88:	e0bffb17 	ldw	r2,-20(fp)
}
 4002d8c:	e037883a 	mov	sp,fp
 4002d90:	dfc00117 	ldw	ra,4(sp)
 4002d94:	df000017 	ldw	fp,0(sp)
 4002d98:	dec00204 	addi	sp,sp,8
 4002d9c:	f800283a 	ret

04002da0 <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
                                 const void * pvTxData,
                                 size_t xDataLengthBytes,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
 4002da0:	defff304 	addi	sp,sp,-52
 4002da4:	dfc00c15 	stw	ra,48(sp)
 4002da8:	df000b15 	stw	fp,44(sp)
 4002dac:	df000b04 	addi	fp,sp,44
 4002db0:	e13ffa15 	stw	r4,-24(fp)
 4002db4:	e17ff915 	stw	r5,-28(fp)
 4002db8:	e1bff815 	stw	r6,-32(fp)
 4002dbc:	e1fff715 	stw	r7,-36(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4002dc0:	e0bffa17 	ldw	r2,-24(fp)
 4002dc4:	e0bffe15 	stw	r2,-8(fp)
    size_t xReturn, xSpace;
    size_t xRequiredSpace = xDataLengthBytes;
 4002dc8:	e0bff817 	ldw	r2,-32(fp)
 4002dcc:	e0bfff15 	stw	r2,-4(fp)

    /* This send function is used to write to both message buffers and stream
     * buffers.  If this is a message buffer then the space needed must be
     * increased by the amount of bytes needed to store the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 4002dd0:	e0bffe17 	ldw	r2,-8(fp)
 4002dd4:	10800703 	ldbu	r2,28(r2)
 4002dd8:	10803fcc 	andi	r2,r2,255
 4002ddc:	1080004c 	andi	r2,r2,1
 4002de0:	10000326 	beq	r2,zero,4002df0 <xStreamBufferSendFromISR+0x50>
    {
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
 4002de4:	e0bfff17 	ldw	r2,-4(fp)
 4002de8:	10800104 	addi	r2,r2,4
 4002dec:	e0bfff15 	stw	r2,-4(fp)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
 4002df0:	e13ffe17 	ldw	r4,-8(fp)
 4002df4:	4002aec0 	call	4002aec <xStreamBufferSpacesAvailable>
 4002df8:	e0bffd15 	stw	r2,-12(fp)
    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
 4002dfc:	e0bfff17 	ldw	r2,-4(fp)
 4002e00:	d8800015 	stw	r2,0(sp)
 4002e04:	e1fffd17 	ldw	r7,-12(fp)
 4002e08:	e1bff817 	ldw	r6,-32(fp)
 4002e0c:	e17ff917 	ldw	r5,-28(fp)
 4002e10:	e13ffe17 	ldw	r4,-8(fp)
 4002e14:	4002e940 	call	4002e94 <prvWriteMessageToBuffer>
 4002e18:	e0bffc15 	stw	r2,-16(fp)

    if( xReturn > ( size_t ) 0 )
 4002e1c:	e0bffc17 	ldw	r2,-16(fp)
 4002e20:	10001626 	beq	r2,zero,4002e7c <xStreamBufferSendFromISR+0xdc>
    {
        /* Was a task waiting for the data? */
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
 4002e24:	e13ffe17 	ldw	r4,-8(fp)
 4002e28:	40036c00 	call	40036c0 <prvBytesInBuffer>
 4002e2c:	1007883a 	mov	r3,r2
 4002e30:	e0bffe17 	ldw	r2,-8(fp)
 4002e34:	10800317 	ldw	r2,12(r2)
 4002e38:	18801036 	bltu	r3,r2,4002e7c <xStreamBufferSendFromISR+0xdc>
        {
            prvSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
 4002e3c:	e03ffb15 	stw	zero,-20(fp)
 4002e40:	e0bffe17 	ldw	r2,-8(fp)
 4002e44:	10800417 	ldw	r2,16(r2)
 4002e48:	10000c26 	beq	r2,zero,4002e7c <xStreamBufferSendFromISR+0xdc>
 4002e4c:	e0bffe17 	ldw	r2,-8(fp)
 4002e50:	10c00417 	ldw	r3,16(r2)
 4002e54:	e0bff717 	ldw	r2,-36(fp)
 4002e58:	d8800115 	stw	r2,4(sp)
 4002e5c:	d8000015 	stw	zero,0(sp)
 4002e60:	000f883a 	mov	r7,zero
 4002e64:	000d883a 	mov	r6,zero
 4002e68:	000b883a 	mov	r5,zero
 4002e6c:	1809883a 	mov	r4,r3
 4002e70:	40066600 	call	4006660 <xTaskGenericNotifyFromISR>
 4002e74:	e0bffe17 	ldw	r2,-8(fp)
 4002e78:	10000415 	stw	zero,16(r2)
        mtCOVERAGE_TEST_MARKER();
    }

    traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

    return xReturn;
 4002e7c:	e0bffc17 	ldw	r2,-16(fp)
}
 4002e80:	e037883a 	mov	sp,fp
 4002e84:	dfc00117 	ldw	ra,4(sp)
 4002e88:	df000017 	ldw	fp,0(sp)
 4002e8c:	dec00204 	addi	sp,sp,8
 4002e90:	f800283a 	ret

04002e94 <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
                                       const void * pvTxData,
                                       size_t xDataLengthBytes,
                                       size_t xSpace,
                                       size_t xRequiredSpace )
{
 4002e94:	defff804 	addi	sp,sp,-32
 4002e98:	dfc00715 	stw	ra,28(sp)
 4002e9c:	df000615 	stw	fp,24(sp)
 4002ea0:	df000604 	addi	fp,sp,24
 4002ea4:	e13ffd15 	stw	r4,-12(fp)
 4002ea8:	e17ffc15 	stw	r5,-16(fp)
 4002eac:	e1bffb15 	stw	r6,-20(fp)
 4002eb0:	e1fffa15 	stw	r7,-24(fp)
    size_t xNextHead = pxStreamBuffer->xHead;
 4002eb4:	e0bffd17 	ldw	r2,-12(fp)
 4002eb8:	10800117 	ldw	r2,4(r2)
 4002ebc:	e0bfff15 	stw	r2,-4(fp)
    configMESSAGE_BUFFER_LENGTH_TYPE xMessageLength;

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 4002ec0:	e0bffd17 	ldw	r2,-12(fp)
 4002ec4:	10800703 	ldbu	r2,28(r2)
 4002ec8:	10803fcc 	andi	r2,r2,255
 4002ecc:	1080004c 	andi	r2,r2,1
 4002ed0:	10000f26 	beq	r2,zero,4002f10 <prvWriteMessageToBuffer+0x7c>
    {
        /* This is a message buffer, as opposed to a stream buffer. */

        /* Convert xDataLengthBytes to the message length type. */
        xMessageLength = ( configMESSAGE_BUFFER_LENGTH_TYPE ) xDataLengthBytes;
 4002ed4:	e0bffb17 	ldw	r2,-20(fp)
 4002ed8:	e0bffe15 	stw	r2,-8(fp)

        /* Ensure the data length given fits within configMESSAGE_BUFFER_LENGTH_TYPE. */
        configASSERT( ( size_t ) xMessageLength == xDataLengthBytes );

        if( xSpace >= xRequiredSpace )
 4002edc:	e0fffa17 	ldw	r3,-24(fp)
 4002ee0:	e0800217 	ldw	r2,8(fp)
 4002ee4:	18800836 	bltu	r3,r2,4002f08 <prvWriteMessageToBuffer+0x74>
        {
            /* There is enough space to write both the message length and the message
             * itself into the buffer.  Start by writing the length of the data, the data
             * itself will be written later in this function. */
            xNextHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xMessageLength ), sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextHead );
 4002ee8:	e0bffe04 	addi	r2,fp,-8
 4002eec:	e1ffff17 	ldw	r7,-4(fp)
 4002ef0:	01800104 	movi	r6,4
 4002ef4:	100b883a 	mov	r5,r2
 4002ef8:	e13ffd17 	ldw	r4,-12(fp)
 4002efc:	40035000 	call	4003500 <prvWriteBytesToBuffer>
 4002f00:	e0bfff15 	stw	r2,-4(fp)
 4002f04:	00000706 	br	4002f24 <prvWriteMessageToBuffer+0x90>
        }
        else
        {
            /* Not enough space, so do not write data to the buffer. */
            xDataLengthBytes = 0;
 4002f08:	e03ffb15 	stw	zero,-20(fp)
 4002f0c:	00000506 	br	4002f24 <prvWriteMessageToBuffer+0x90>
    else
    {
        /* This is a stream buffer, as opposed to a message buffer, so writing a
         * stream of bytes rather than discrete messages.  Plan to write as many
         * bytes as possible. */
        xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
 4002f10:	e0fffb17 	ldw	r3,-20(fp)
 4002f14:	e0bffa17 	ldw	r2,-24(fp)
 4002f18:	1880012e 	bgeu	r3,r2,4002f20 <prvWriteMessageToBuffer+0x8c>
 4002f1c:	1805883a 	mov	r2,r3
 4002f20:	e0bffb15 	stw	r2,-20(fp)
    }

    if( xDataLengthBytes != ( size_t ) 0 )
 4002f24:	e0bffb17 	ldw	r2,-20(fp)
 4002f28:	10000826 	beq	r2,zero,4002f4c <prvWriteMessageToBuffer+0xb8>
    {
        /* Write the data to the buffer. */
        pxStreamBuffer->xHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes, xNextHead ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alignment and access. */
 4002f2c:	e1ffff17 	ldw	r7,-4(fp)
 4002f30:	e1bffb17 	ldw	r6,-20(fp)
 4002f34:	e17ffc17 	ldw	r5,-16(fp)
 4002f38:	e13ffd17 	ldw	r4,-12(fp)
 4002f3c:	40035000 	call	4003500 <prvWriteBytesToBuffer>
 4002f40:	1007883a 	mov	r3,r2
 4002f44:	e0bffd17 	ldw	r2,-12(fp)
 4002f48:	10c00115 	stw	r3,4(r2)
    }

    return xDataLengthBytes;
 4002f4c:	e0bffb17 	ldw	r2,-20(fp)
}
 4002f50:	e037883a 	mov	sp,fp
 4002f54:	dfc00117 	ldw	ra,4(sp)
 4002f58:	df000017 	ldw	fp,0(sp)
 4002f5c:	dec00204 	addi	sp,sp,8
 4002f60:	f800283a 	ret

04002f64 <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
                             void * pvRxData,
                             size_t xBufferLengthBytes,
                             TickType_t xTicksToWait )
{
 4002f64:	defff504 	addi	sp,sp,-44
 4002f68:	dfc00a15 	stw	ra,40(sp)
 4002f6c:	df000915 	stw	fp,36(sp)
 4002f70:	df000904 	addi	fp,sp,36
 4002f74:	e13ffb15 	stw	r4,-20(fp)
 4002f78:	e17ffa15 	stw	r5,-24(fp)
 4002f7c:	e1bff915 	stw	r6,-28(fp)
 4002f80:	e1fff815 	stw	r7,-32(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4002f84:	e0bffb17 	ldw	r2,-20(fp)
 4002f88:	e0bffc15 	stw	r2,-16(fp)
    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
 4002f8c:	e03fff15 	stw	zero,-4(fp)
    /* This receive function is used by both message buffers, which store
     * discrete messages, and stream buffers, which store a continuous stream of
     * bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 4002f90:	e0bffc17 	ldw	r2,-16(fp)
 4002f94:	10800703 	ldbu	r2,28(r2)
 4002f98:	10803fcc 	andi	r2,r2,255
 4002f9c:	1080004c 	andi	r2,r2,1
 4002fa0:	10000326 	beq	r2,zero,4002fb0 <xStreamBufferReceive+0x4c>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
 4002fa4:	00800104 	movi	r2,4
 4002fa8:	e0bffd15 	stw	r2,-12(fp)
 4002fac:	00000106 	br	4002fb4 <xStreamBufferReceive+0x50>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
 4002fb0:	e03ffd15 	stw	zero,-12(fp)
    }

    if( xTicksToWait != ( TickType_t ) 0 )
 4002fb4:	e0bff817 	ldw	r2,-32(fp)
 4002fb8:	10001f26 	beq	r2,zero,4003038 <xStreamBufferReceive+0xd4>
    {
        /* Checking if there is data and clearing the notification state must be
         * performed atomically. */
        taskENTER_CRITICAL();
 4002fbc:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
        {
            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 4002fc0:	e13ffc17 	ldw	r4,-16(fp)
 4002fc4:	40036c00 	call	40036c0 <prvBytesInBuffer>
 4002fc8:	e0bffe15 	stw	r2,-8(fp)
            /* If this function was invoked by a message buffer read then
             * xBytesToStoreMessageLength holds the number of bytes used to hold
             * the length of the next discrete message.  If this function was
             * invoked by a stream buffer read then xBytesToStoreMessageLength will
             * be 0. */
            if( xBytesAvailable <= xBytesToStoreMessageLength )
 4002fcc:	e0bffe17 	ldw	r2,-8(fp)
 4002fd0:	e0fffd17 	ldw	r3,-12(fp)
 4002fd4:	18800736 	bltu	r3,r2,4002ff4 <xStreamBufferReceive+0x90>
            {
                /* Clear notification state as going to wait for data. */
                ( void ) xTaskNotifyStateClear( NULL );
 4002fd8:	000b883a 	mov	r5,zero
 4002fdc:	0009883a 	mov	r4,zero
 4002fe0:	4006d040 	call	4006d04 <xTaskGenericNotifyStateClear>

                /* Should only be one reader. */
                configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
                pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
 4002fe4:	40059900 	call	4005990 <xTaskGetCurrentTaskHandle>
 4002fe8:	1007883a 	mov	r3,r2
 4002fec:	e0bffc17 	ldw	r2,-16(fp)
 4002ff0:	10c00415 	stw	r3,16(r2)
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
 4002ff4:	4005fd00 	call	4005fd0 <vTaskExitCritical>

        if( xBytesAvailable <= xBytesToStoreMessageLength )
 4002ff8:	e0bffe17 	ldw	r2,-8(fp)
 4002ffc:	e0fffd17 	ldw	r3,-12(fp)
 4003000:	18801036 	bltu	r3,r2,4003044 <xStreamBufferReceive+0xe0>
        {
            /* Wait for data to be available. */
            traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
 4003004:	e0bff817 	ldw	r2,-32(fp)
 4003008:	d8800015 	stw	r2,0(sp)
 400300c:	000f883a 	mov	r7,zero
 4003010:	000d883a 	mov	r6,zero
 4003014:	000b883a 	mov	r5,zero
 4003018:	0009883a 	mov	r4,zero
 400301c:	40061b40 	call	40061b4 <xTaskGenericNotifyWait>
            pxStreamBuffer->xTaskWaitingToReceive = NULL;
 4003020:	e0bffc17 	ldw	r2,-16(fp)
 4003024:	10000415 	stw	zero,16(r2)

            /* Recheck the data available after blocking. */
            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 4003028:	e13ffc17 	ldw	r4,-16(fp)
 400302c:	40036c00 	call	40036c0 <prvBytesInBuffer>
 4003030:	e0bffe15 	stw	r2,-8(fp)
 4003034:	00000306 	br	4003044 <xStreamBufferReceive+0xe0>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 4003038:	e13ffc17 	ldw	r4,-16(fp)
 400303c:	40036c00 	call	40036c0 <prvBytesInBuffer>
 4003040:	e0bffe15 	stw	r2,-8(fp)
    /* Whether receiving a discrete message (where xBytesToStoreMessageLength
     * holds the number of bytes used to store the message length) or a stream of
     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
     * available must be greater than xBytesToStoreMessageLength to be able to
     * read bytes from the buffer. */
    if( xBytesAvailable > xBytesToStoreMessageLength )
 4003044:	e0bffe17 	ldw	r2,-8(fp)
 4003048:	e0fffd17 	ldw	r3,-12(fp)
 400304c:	1880172e 	bgeu	r3,r2,40030ac <xStreamBufferReceive+0x148>
    {
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );
 4003050:	e1fffe17 	ldw	r7,-8(fp)
 4003054:	e1bff917 	ldw	r6,-28(fp)
 4003058:	e17ffa17 	ldw	r5,-24(fp)
 400305c:	e13ffc17 	ldw	r4,-16(fp)
 4003060:	400323c0 	call	400323c <prvReadMessageFromBuffer>
 4003064:	e0bfff15 	stw	r2,-4(fp)

        /* Was a task waiting for space in the buffer? */
        if( xReceivedLength != ( size_t ) 0 )
 4003068:	e0bfff17 	ldw	r2,-4(fp)
 400306c:	10000f26 	beq	r2,zero,40030ac <xStreamBufferReceive+0x148>
        {
            traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
            prvRECEIVE_COMPLETED( xStreamBuffer );
 4003070:	40046f00 	call	40046f0 <vTaskSuspendAll>
 4003074:	e0bffb17 	ldw	r2,-20(fp)
 4003078:	10800517 	ldw	r2,20(r2)
 400307c:	10000a26 	beq	r2,zero,40030a8 <xStreamBufferReceive+0x144>
 4003080:	e0bffb17 	ldw	r2,-20(fp)
 4003084:	10800517 	ldw	r2,20(r2)
 4003088:	d8000015 	stw	zero,0(sp)
 400308c:	000f883a 	mov	r7,zero
 4003090:	000d883a 	mov	r6,zero
 4003094:	000b883a 	mov	r5,zero
 4003098:	1009883a 	mov	r4,r2
 400309c:	40063180 	call	4006318 <xTaskGenericNotify>
 40030a0:	e0bffb17 	ldw	r2,-20(fp)
 40030a4:	10000515 	stw	zero,20(r2)
 40030a8:	400471c0 	call	400471c <xTaskResumeAll>
    {
        traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
        mtCOVERAGE_TEST_MARKER();
    }

    return xReceivedLength;
 40030ac:	e0bfff17 	ldw	r2,-4(fp)
}
 40030b0:	e037883a 	mov	sp,fp
 40030b4:	dfc00117 	ldw	ra,4(sp)
 40030b8:	df000017 	ldw	fp,0(sp)
 40030bc:	dec00204 	addi	sp,sp,8
 40030c0:	f800283a 	ret

040030c4 <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
 40030c4:	defff904 	addi	sp,sp,-28
 40030c8:	dfc00615 	stw	ra,24(sp)
 40030cc:	df000515 	stw	fp,20(sp)
 40030d0:	df000504 	addi	fp,sp,20
 40030d4:	e13ffb15 	stw	r4,-20(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 40030d8:	e0bffb17 	ldw	r2,-20(fp)
 40030dc:	e0bffe15 	stw	r2,-8(fp)
    configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

    configASSERT( pxStreamBuffer );

    /* Ensure the stream buffer is being used as a message buffer. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 40030e0:	e0bffe17 	ldw	r2,-8(fp)
 40030e4:	10800703 	ldbu	r2,28(r2)
 40030e8:	10803fcc 	andi	r2,r2,255
 40030ec:	1080004c 	andi	r2,r2,1
 40030f0:	10001326 	beq	r2,zero,4003140 <xStreamBufferNextMessageLengthBytes+0x7c>
    {
        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 40030f4:	e13ffe17 	ldw	r4,-8(fp)
 40030f8:	40036c00 	call	40036c0 <prvBytesInBuffer>
 40030fc:	e0bffd15 	stw	r2,-12(fp)

        if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
 4003100:	e0bffd17 	ldw	r2,-12(fp)
 4003104:	10800170 	cmpltui	r2,r2,5
 4003108:	10000b1e 	bne	r2,zero,4003138 <xStreamBufferNextMessageLengthBytes+0x74>
        {
            /* The number of bytes available is greater than the number of bytes
             * required to hold the length of the next message, so another message
             * is available. */
            ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, pxStreamBuffer->xTail );
 400310c:	e0bffe17 	ldw	r2,-8(fp)
 4003110:	10c00017 	ldw	r3,0(r2)
 4003114:	e0bffc04 	addi	r2,fp,-16
 4003118:	180f883a 	mov	r7,r3
 400311c:	01800104 	movi	r6,4
 4003120:	100b883a 	mov	r5,r2
 4003124:	e13ffe17 	ldw	r4,-8(fp)
 4003128:	40035e00 	call	40035e0 <prvReadBytesFromBuffer>
            xReturn = ( size_t ) xTempReturn;
 400312c:	e0bffc17 	ldw	r2,-16(fp)
 4003130:	e0bfff15 	stw	r2,-4(fp)
 4003134:	00000306 	br	4003144 <xStreamBufferNextMessageLengthBytes+0x80>
            /* The minimum amount of bytes in a message buffer is
             * ( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
             * less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
             * value is 0. */
            configASSERT( xBytesAvailable == 0 );
            xReturn = 0;
 4003138:	e03fff15 	stw	zero,-4(fp)
 400313c:	00000106 	br	4003144 <xStreamBufferNextMessageLengthBytes+0x80>
        }
    }
    else
    {
        xReturn = 0;
 4003140:	e03fff15 	stw	zero,-4(fp)
    }

    return xReturn;
 4003144:	e0bfff17 	ldw	r2,-4(fp)
}
 4003148:	e037883a 	mov	sp,fp
 400314c:	dfc00117 	ldw	ra,4(sp)
 4003150:	df000017 	ldw	fp,0(sp)
 4003154:	dec00204 	addi	sp,sp,8
 4003158:	f800283a 	ret

0400315c <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
                                    void * pvRxData,
                                    size_t xBufferLengthBytes,
                                    BaseType_t * const pxHigherPriorityTaskWoken )
{
 400315c:	defff304 	addi	sp,sp,-52
 4003160:	dfc00c15 	stw	ra,48(sp)
 4003164:	df000b15 	stw	fp,44(sp)
 4003168:	df000b04 	addi	fp,sp,44
 400316c:	e13ffa15 	stw	r4,-24(fp)
 4003170:	e17ff915 	stw	r5,-28(fp)
 4003174:	e1bff815 	stw	r6,-32(fp)
 4003178:	e1fff715 	stw	r7,-36(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 400317c:	e0bffa17 	ldw	r2,-24(fp)
 4003180:	e0bffd15 	stw	r2,-12(fp)
    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
 4003184:	e03fff15 	stw	zero,-4(fp)
    /* This receive function is used by both message buffers, which store
     * discrete messages, and stream buffers, which store a continuous stream of
     * bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 4003188:	e0bffd17 	ldw	r2,-12(fp)
 400318c:	10800703 	ldbu	r2,28(r2)
 4003190:	10803fcc 	andi	r2,r2,255
 4003194:	1080004c 	andi	r2,r2,1
 4003198:	10000326 	beq	r2,zero,40031a8 <xStreamBufferReceiveFromISR+0x4c>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
 400319c:	00800104 	movi	r2,4
 40031a0:	e0bffe15 	stw	r2,-8(fp)
 40031a4:	00000106 	br	40031ac <xStreamBufferReceiveFromISR+0x50>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
 40031a8:	e03ffe15 	stw	zero,-8(fp)
    }

    xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 40031ac:	e13ffd17 	ldw	r4,-12(fp)
 40031b0:	40036c00 	call	40036c0 <prvBytesInBuffer>
 40031b4:	e0bffc15 	stw	r2,-16(fp)
    /* Whether receiving a discrete message (where xBytesToStoreMessageLength
     * holds the number of bytes used to store the message length) or a stream of
     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
     * available must be greater than xBytesToStoreMessageLength to be able to
     * read bytes from the buffer. */
    if( xBytesAvailable > xBytesToStoreMessageLength )
 40031b8:	e0bffc17 	ldw	r2,-16(fp)
 40031bc:	e0fffe17 	ldw	r3,-8(fp)
 40031c0:	1880182e 	bgeu	r3,r2,4003224 <xStreamBufferReceiveFromISR+0xc8>
    {
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );
 40031c4:	e1fffc17 	ldw	r7,-16(fp)
 40031c8:	e1bff817 	ldw	r6,-32(fp)
 40031cc:	e17ff917 	ldw	r5,-28(fp)
 40031d0:	e13ffd17 	ldw	r4,-12(fp)
 40031d4:	400323c0 	call	400323c <prvReadMessageFromBuffer>
 40031d8:	e0bfff15 	stw	r2,-4(fp)

        /* Was a task waiting for space in the buffer? */
        if( xReceivedLength != ( size_t ) 0 )
 40031dc:	e0bfff17 	ldw	r2,-4(fp)
 40031e0:	10001026 	beq	r2,zero,4003224 <xStreamBufferReceiveFromISR+0xc8>
        {
            prvRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
 40031e4:	e03ffb15 	stw	zero,-20(fp)
 40031e8:	e0bffd17 	ldw	r2,-12(fp)
 40031ec:	10800517 	ldw	r2,20(r2)
 40031f0:	10000c26 	beq	r2,zero,4003224 <xStreamBufferReceiveFromISR+0xc8>
 40031f4:	e0bffd17 	ldw	r2,-12(fp)
 40031f8:	10c00517 	ldw	r3,20(r2)
 40031fc:	e0bff717 	ldw	r2,-36(fp)
 4003200:	d8800115 	stw	r2,4(sp)
 4003204:	d8000015 	stw	zero,0(sp)
 4003208:	000f883a 	mov	r7,zero
 400320c:	000d883a 	mov	r6,zero
 4003210:	000b883a 	mov	r5,zero
 4003214:	1809883a 	mov	r4,r3
 4003218:	40066600 	call	4006660 <xTaskGenericNotifyFromISR>
 400321c:	e0bffd17 	ldw	r2,-12(fp)
 4003220:	10000515 	stw	zero,20(r2)
        mtCOVERAGE_TEST_MARKER();
    }

    traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

    return xReceivedLength;
 4003224:	e0bfff17 	ldw	r2,-4(fp)
}
 4003228:	e037883a 	mov	sp,fp
 400322c:	dfc00117 	ldw	ra,4(sp)
 4003230:	df000017 	ldw	fp,0(sp)
 4003234:	dec00204 	addi	sp,sp,8
 4003238:	f800283a 	ret

0400323c <prvReadMessageFromBuffer>:

static size_t prvReadMessageFromBuffer( StreamBuffer_t * pxStreamBuffer,
                                        void * pvRxData,
                                        size_t xBufferLengthBytes,
                                        size_t xBytesAvailable )
{
 400323c:	defff604 	addi	sp,sp,-40
 4003240:	dfc00915 	stw	ra,36(sp)
 4003244:	df000815 	stw	fp,32(sp)
 4003248:	df000804 	addi	fp,sp,32
 400324c:	e13ffb15 	stw	r4,-20(fp)
 4003250:	e17ffa15 	stw	r5,-24(fp)
 4003254:	e1bff915 	stw	r6,-28(fp)
 4003258:	e1fff815 	stw	r7,-32(fp)
    size_t xCount, xNextMessageLength;
    configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;
    size_t xNextTail = pxStreamBuffer->xTail;
 400325c:	e0bffb17 	ldw	r2,-20(fp)
 4003260:	10800017 	ldw	r2,0(r2)
 4003264:	e0bffe15 	stw	r2,-8(fp)

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 4003268:	e0bffb17 	ldw	r2,-20(fp)
 400326c:	10800703 	ldbu	r2,28(r2)
 4003270:	10803fcc 	andi	r2,r2,255
 4003274:	1080004c 	andi	r2,r2,1
 4003278:	10001126 	beq	r2,zero,40032c0 <prvReadMessageFromBuffer+0x84>
    {
        /* A discrete message is being received.  First receive the length
         * of the message. */
        xNextTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextTail );
 400327c:	e0bffc04 	addi	r2,fp,-16
 4003280:	e1fffe17 	ldw	r7,-8(fp)
 4003284:	01800104 	movi	r6,4
 4003288:	100b883a 	mov	r5,r2
 400328c:	e13ffb17 	ldw	r4,-20(fp)
 4003290:	40035e00 	call	40035e0 <prvReadBytesFromBuffer>
 4003294:	e0bffe15 	stw	r2,-8(fp)
        xNextMessageLength = ( size_t ) xTempNextMessageLength;
 4003298:	e0bffc17 	ldw	r2,-16(fp)
 400329c:	e0bfff15 	stw	r2,-4(fp)

        /* Reduce the number of bytes available by the number of bytes just
         * read out. */
        xBytesAvailable -= sbBYTES_TO_STORE_MESSAGE_LENGTH;
 40032a0:	e0bff817 	ldw	r2,-32(fp)
 40032a4:	10bfff04 	addi	r2,r2,-4
 40032a8:	e0bff815 	stw	r2,-32(fp)

        /* Check there is enough space in the buffer provided by the
         * user. */
        if( xNextMessageLength > xBufferLengthBytes )
 40032ac:	e0bfff17 	ldw	r2,-4(fp)
 40032b0:	e0fff917 	ldw	r3,-28(fp)
 40032b4:	1880042e 	bgeu	r3,r2,40032c8 <prvReadMessageFromBuffer+0x8c>
        {
            /* The user has provided insufficient space to read the message. */
            xNextMessageLength = 0;
 40032b8:	e03fff15 	stw	zero,-4(fp)
 40032bc:	00000206 	br	40032c8 <prvReadMessageFromBuffer+0x8c>
    }
    else
    {
        /* A stream of bytes is being received (as opposed to a discrete
         * message), so read as many bytes as possible. */
        xNextMessageLength = xBufferLengthBytes;
 40032c0:	e0bff917 	ldw	r2,-28(fp)
 40032c4:	e0bfff15 	stw	r2,-4(fp)
    }

    /* Use the minimum of the wanted bytes and the available bytes. */
    xCount = configMIN( xNextMessageLength, xBytesAvailable );
 40032c8:	e0ffff17 	ldw	r3,-4(fp)
 40032cc:	e0bff817 	ldw	r2,-32(fp)
 40032d0:	1880012e 	bgeu	r3,r2,40032d8 <prvReadMessageFromBuffer+0x9c>
 40032d4:	1805883a 	mov	r2,r3
 40032d8:	e0bffd15 	stw	r2,-12(fp)

    if( xCount != ( size_t ) 0 )
 40032dc:	e0bffd17 	ldw	r2,-12(fp)
 40032e0:	10000826 	beq	r2,zero,4003304 <prvReadMessageFromBuffer+0xc8>
    {
        /* Read the actual data and update the tail to mark the data as officially consumed. */
        pxStreamBuffer->xTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xCount, xNextTail ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
 40032e4:	e1fffe17 	ldw	r7,-8(fp)
 40032e8:	e1bffd17 	ldw	r6,-12(fp)
 40032ec:	e17ffa17 	ldw	r5,-24(fp)
 40032f0:	e13ffb17 	ldw	r4,-20(fp)
 40032f4:	40035e00 	call	40035e0 <prvReadBytesFromBuffer>
 40032f8:	1007883a 	mov	r3,r2
 40032fc:	e0bffb17 	ldw	r2,-20(fp)
 4003300:	10c00015 	stw	r3,0(r2)
    }

    return xCount;
 4003304:	e0bffd17 	ldw	r2,-12(fp)
}
 4003308:	e037883a 	mov	sp,fp
 400330c:	dfc00117 	ldw	ra,4(sp)
 4003310:	df000017 	ldw	fp,0(sp)
 4003314:	dec00204 	addi	sp,sp,8
 4003318:	f800283a 	ret

0400331c <xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
 400331c:	defffb04 	addi	sp,sp,-20
 4003320:	df000415 	stw	fp,16(sp)
 4003324:	df000404 	addi	fp,sp,16
 4003328:	e13ffc15 	stw	r4,-16(fp)
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 400332c:	e0bffc17 	ldw	r2,-16(fp)
 4003330:	e0bffe15 	stw	r2,-8(fp)
    size_t xTail;

    configASSERT( pxStreamBuffer );

    /* True if no bytes are available. */
    xTail = pxStreamBuffer->xTail;
 4003334:	e0bffe17 	ldw	r2,-8(fp)
 4003338:	10800017 	ldw	r2,0(r2)
 400333c:	e0bffd15 	stw	r2,-12(fp)

    if( pxStreamBuffer->xHead == xTail )
 4003340:	e0bffe17 	ldw	r2,-8(fp)
 4003344:	10800117 	ldw	r2,4(r2)
 4003348:	e0fffd17 	ldw	r3,-12(fp)
 400334c:	1880031e 	bne	r3,r2,400335c <xStreamBufferIsEmpty+0x40>
    {
        xReturn = pdTRUE;
 4003350:	00800044 	movi	r2,1
 4003354:	e0bfff15 	stw	r2,-4(fp)
 4003358:	00000106 	br	4003360 <xStreamBufferIsEmpty+0x44>
    }
    else
    {
        xReturn = pdFALSE;
 400335c:	e03fff15 	stw	zero,-4(fp)
    }

    return xReturn;
 4003360:	e0bfff17 	ldw	r2,-4(fp)
}
 4003364:	e037883a 	mov	sp,fp
 4003368:	df000017 	ldw	fp,0(sp)
 400336c:	dec00104 	addi	sp,sp,4
 4003370:	f800283a 	ret

04003374 <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
 4003374:	defffa04 	addi	sp,sp,-24
 4003378:	dfc00515 	stw	ra,20(sp)
 400337c:	df000415 	stw	fp,16(sp)
 4003380:	df000404 	addi	fp,sp,16
 4003384:	e13ffc15 	stw	r4,-16(fp)
    BaseType_t xReturn;
    size_t xBytesToStoreMessageLength;
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4003388:	e0bffc17 	ldw	r2,-16(fp)
 400338c:	e0bffd15 	stw	r2,-12(fp)

    /* This generic version of the receive function is used by both message
     * buffers, which store discrete messages, and stream buffers, which store a
     * continuous stream of bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 4003390:	e0bffd17 	ldw	r2,-12(fp)
 4003394:	10800703 	ldbu	r2,28(r2)
 4003398:	10803fcc 	andi	r2,r2,255
 400339c:	1080004c 	andi	r2,r2,1
 40033a0:	10000326 	beq	r2,zero,40033b0 <xStreamBufferIsFull+0x3c>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
 40033a4:	00800104 	movi	r2,4
 40033a8:	e0bffe15 	stw	r2,-8(fp)
 40033ac:	00000106 	br	40033b4 <xStreamBufferIsFull+0x40>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
 40033b0:	e03ffe15 	stw	zero,-8(fp)
    }

    /* True if the available space equals zero. */
    if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
 40033b4:	e13ffc17 	ldw	r4,-16(fp)
 40033b8:	4002aec0 	call	4002aec <xStreamBufferSpacesAvailable>
 40033bc:	1007883a 	mov	r3,r2
 40033c0:	e0bffe17 	ldw	r2,-8(fp)
 40033c4:	10c00336 	bltu	r2,r3,40033d4 <xStreamBufferIsFull+0x60>
    {
        xReturn = pdTRUE;
 40033c8:	00800044 	movi	r2,1
 40033cc:	e0bfff15 	stw	r2,-4(fp)
 40033d0:	00000106 	br	40033d8 <xStreamBufferIsFull+0x64>
    }
    else
    {
        xReturn = pdFALSE;
 40033d4:	e03fff15 	stw	zero,-4(fp)
    }

    return xReturn;
 40033d8:	e0bfff17 	ldw	r2,-4(fp)
}
 40033dc:	e037883a 	mov	sp,fp
 40033e0:	dfc00117 	ldw	ra,4(sp)
 40033e4:	df000017 	ldw	fp,0(sp)
 40033e8:	dec00204 	addi	sp,sp,8
 40033ec:	f800283a 	ret

040033f0 <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
                                              BaseType_t * pxHigherPriorityTaskWoken )
{
 40033f0:	defff704 	addi	sp,sp,-36
 40033f4:	dfc00815 	stw	ra,32(sp)
 40033f8:	df000715 	stw	fp,28(sp)
 40033fc:	df000704 	addi	fp,sp,28
 4003400:	e13ffc15 	stw	r4,-16(fp)
 4003404:	e17ffb15 	stw	r5,-20(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4003408:	e0bffc17 	ldw	r2,-16(fp)
 400340c:	e0bffe15 	stw	r2,-8(fp)
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;

    configASSERT( pxStreamBuffer );

    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
 4003410:	e03ffd15 	stw	zero,-12(fp)
    {
        if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
 4003414:	e0bffe17 	ldw	r2,-8(fp)
 4003418:	10800417 	ldw	r2,16(r2)
 400341c:	10000f26 	beq	r2,zero,400345c <xStreamBufferSendCompletedFromISR+0x6c>
        {
            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
 4003420:	e0bffe17 	ldw	r2,-8(fp)
 4003424:	10c00417 	ldw	r3,16(r2)
 4003428:	e0bffb17 	ldw	r2,-20(fp)
 400342c:	d8800115 	stw	r2,4(sp)
 4003430:	d8000015 	stw	zero,0(sp)
 4003434:	000f883a 	mov	r7,zero
 4003438:	000d883a 	mov	r6,zero
 400343c:	000b883a 	mov	r5,zero
 4003440:	1809883a 	mov	r4,r3
 4003444:	40066600 	call	4006660 <xTaskGenericNotifyFromISR>
                                         ( uint32_t ) 0,
                                         eNoAction,
                                         pxHigherPriorityTaskWoken );
            ( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
 4003448:	e0bffe17 	ldw	r2,-8(fp)
 400344c:	10000415 	stw	zero,16(r2)
            xReturn = pdTRUE;
 4003450:	00800044 	movi	r2,1
 4003454:	e0bfff15 	stw	r2,-4(fp)
 4003458:	00000106 	br	4003460 <xStreamBufferSendCompletedFromISR+0x70>
        }
        else
        {
            xReturn = pdFALSE;
 400345c:	e03fff15 	stw	zero,-4(fp)
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 4003460:	e0bfff17 	ldw	r2,-4(fp)
}
 4003464:	e037883a 	mov	sp,fp
 4003468:	dfc00117 	ldw	ra,4(sp)
 400346c:	df000017 	ldw	fp,0(sp)
 4003470:	dec00204 	addi	sp,sp,8
 4003474:	f800283a 	ret

04003478 <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
                                                 BaseType_t * pxHigherPriorityTaskWoken )
{
 4003478:	defff704 	addi	sp,sp,-36
 400347c:	dfc00815 	stw	ra,32(sp)
 4003480:	df000715 	stw	fp,28(sp)
 4003484:	df000704 	addi	fp,sp,28
 4003488:	e13ffc15 	stw	r4,-16(fp)
 400348c:	e17ffb15 	stw	r5,-20(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4003490:	e0bffc17 	ldw	r2,-16(fp)
 4003494:	e0bffe15 	stw	r2,-8(fp)
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;

    configASSERT( pxStreamBuffer );

    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
 4003498:	e03ffd15 	stw	zero,-12(fp)
    {
        if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
 400349c:	e0bffe17 	ldw	r2,-8(fp)
 40034a0:	10800517 	ldw	r2,20(r2)
 40034a4:	10000f26 	beq	r2,zero,40034e4 <xStreamBufferReceiveCompletedFromISR+0x6c>
        {
            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
 40034a8:	e0bffe17 	ldw	r2,-8(fp)
 40034ac:	10c00517 	ldw	r3,20(r2)
 40034b0:	e0bffb17 	ldw	r2,-20(fp)
 40034b4:	d8800115 	stw	r2,4(sp)
 40034b8:	d8000015 	stw	zero,0(sp)
 40034bc:	000f883a 	mov	r7,zero
 40034c0:	000d883a 	mov	r6,zero
 40034c4:	000b883a 	mov	r5,zero
 40034c8:	1809883a 	mov	r4,r3
 40034cc:	40066600 	call	4006660 <xTaskGenericNotifyFromISR>
                                         ( uint32_t ) 0,
                                         eNoAction,
                                         pxHigherPriorityTaskWoken );
            ( pxStreamBuffer )->xTaskWaitingToSend = NULL;
 40034d0:	e0bffe17 	ldw	r2,-8(fp)
 40034d4:	10000515 	stw	zero,20(r2)
            xReturn = pdTRUE;
 40034d8:	00800044 	movi	r2,1
 40034dc:	e0bfff15 	stw	r2,-4(fp)
 40034e0:	00000106 	br	40034e8 <xStreamBufferReceiveCompletedFromISR+0x70>
        }
        else
        {
            xReturn = pdFALSE;
 40034e4:	e03fff15 	stw	zero,-4(fp)
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 40034e8:	e0bfff17 	ldw	r2,-4(fp)
}
 40034ec:	e037883a 	mov	sp,fp
 40034f0:	dfc00117 	ldw	ra,4(sp)
 40034f4:	df000017 	ldw	fp,0(sp)
 40034f8:	dec00204 	addi	sp,sp,8
 40034fc:	f800283a 	ret

04003500 <prvWriteBytesToBuffer>:

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer,
                                     const uint8_t * pucData,
                                     size_t xCount,
                                     size_t xHead )
{
 4003500:	defff904 	addi	sp,sp,-28
 4003504:	dfc00615 	stw	ra,24(sp)
 4003508:	df000515 	stw	fp,20(sp)
 400350c:	df000504 	addi	fp,sp,20
 4003510:	e13ffe15 	stw	r4,-8(fp)
 4003514:	e17ffd15 	stw	r5,-12(fp)
 4003518:	e1bffc15 	stw	r6,-16(fp)
 400351c:	e1fffb15 	stw	r7,-20(fp)
    configASSERT( xCount > ( size_t ) 0 );

    /* Calculate the number of bytes that can be added in the first write -
     * which may be less than the total number of bytes that need to be added if
     * the buffer will wrap back to the beginning. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xHead, xCount );
 4003520:	e0bffe17 	ldw	r2,-8(fp)
 4003524:	10c00217 	ldw	r3,8(r2)
 4003528:	e0bffb17 	ldw	r2,-20(fp)
 400352c:	1887c83a 	sub	r3,r3,r2
 4003530:	e0bffc17 	ldw	r2,-16(fp)
 4003534:	1880012e 	bgeu	r3,r2,400353c <prvWriteBytesToBuffer+0x3c>
 4003538:	1805883a 	mov	r2,r3
 400353c:	e0bfff15 	stw	r2,-4(fp)

    /* Write as many bytes as can be written in the first write. */
    configASSERT( ( xHead + xFirstLength ) <= pxStreamBuffer->xLength );
    ( void ) memcpy( ( void * ) ( &( pxStreamBuffer->pucBuffer[ xHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
 4003540:	e0bffe17 	ldw	r2,-8(fp)
 4003544:	10c00617 	ldw	r3,24(r2)
 4003548:	e0bffb17 	ldw	r2,-20(fp)
 400354c:	1885883a 	add	r2,r3,r2
 4003550:	e1bfff17 	ldw	r6,-4(fp)
 4003554:	e17ffd17 	ldw	r5,-12(fp)
 4003558:	1009883a 	mov	r4,r2
 400355c:	40075cc0 	call	40075cc <memcpy>

    /* If the number of bytes written was less than the number that could be
     * written in the first write... */
    if( xCount > xFirstLength )
 4003560:	e0bffc17 	ldw	r2,-16(fp)
 4003564:	e0ffff17 	ldw	r3,-4(fp)
 4003568:	18800a2e 	bgeu	r3,r2,4003594 <prvWriteBytesToBuffer+0x94>
    {
        /* ...then write the remaining bytes to the start of the buffer. */
        configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
        ( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
 400356c:	e0bffe17 	ldw	r2,-8(fp)
 4003570:	11000617 	ldw	r4,24(r2)
 4003574:	e0fffd17 	ldw	r3,-12(fp)
 4003578:	e0bfff17 	ldw	r2,-4(fp)
 400357c:	188b883a 	add	r5,r3,r2
 4003580:	e0fffc17 	ldw	r3,-16(fp)
 4003584:	e0bfff17 	ldw	r2,-4(fp)
 4003588:	1885c83a 	sub	r2,r3,r2
 400358c:	100d883a 	mov	r6,r2
 4003590:	40075cc0 	call	40075cc <memcpy>
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xHead += xCount;
 4003594:	e0fffb17 	ldw	r3,-20(fp)
 4003598:	e0bffc17 	ldw	r2,-16(fp)
 400359c:	1885883a 	add	r2,r3,r2
 40035a0:	e0bffb15 	stw	r2,-20(fp)

    if( xHead >= pxStreamBuffer->xLength )
 40035a4:	e0bffe17 	ldw	r2,-8(fp)
 40035a8:	10800217 	ldw	r2,8(r2)
 40035ac:	e0fffb17 	ldw	r3,-20(fp)
 40035b0:	18800536 	bltu	r3,r2,40035c8 <prvWriteBytesToBuffer+0xc8>
    {
        xHead -= pxStreamBuffer->xLength;
 40035b4:	e0bffe17 	ldw	r2,-8(fp)
 40035b8:	10800217 	ldw	r2,8(r2)
 40035bc:	e0fffb17 	ldw	r3,-20(fp)
 40035c0:	1885c83a 	sub	r2,r3,r2
 40035c4:	e0bffb15 	stw	r2,-20(fp)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xHead;
 40035c8:	e0bffb17 	ldw	r2,-20(fp)
}
 40035cc:	e037883a 	mov	sp,fp
 40035d0:	dfc00117 	ldw	ra,4(sp)
 40035d4:	df000017 	ldw	fp,0(sp)
 40035d8:	dec00204 	addi	sp,sp,8
 40035dc:	f800283a 	ret

040035e0 <prvReadBytesFromBuffer>:

static size_t prvReadBytesFromBuffer( StreamBuffer_t * pxStreamBuffer,
                                      uint8_t * pucData,
                                      size_t xCount,
                                      size_t xTail )
{
 40035e0:	defff904 	addi	sp,sp,-28
 40035e4:	dfc00615 	stw	ra,24(sp)
 40035e8:	df000515 	stw	fp,20(sp)
 40035ec:	df000504 	addi	fp,sp,20
 40035f0:	e13ffe15 	stw	r4,-8(fp)
 40035f4:	e17ffd15 	stw	r5,-12(fp)
 40035f8:	e1bffc15 	stw	r6,-16(fp)
 40035fc:	e1fffb15 	stw	r7,-20(fp)
    configASSERT( xCount != ( size_t ) 0 );

    /* Calculate the number of bytes that can be read - which may be
     * less than the number wanted if the data wraps around to the start of
     * the buffer. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xTail, xCount );
 4003600:	e0bffe17 	ldw	r2,-8(fp)
 4003604:	10c00217 	ldw	r3,8(r2)
 4003608:	e0bffb17 	ldw	r2,-20(fp)
 400360c:	1887c83a 	sub	r3,r3,r2
 4003610:	e0bffc17 	ldw	r2,-16(fp)
 4003614:	1880012e 	bgeu	r3,r2,400361c <prvReadBytesFromBuffer+0x3c>
 4003618:	1805883a 	mov	r2,r3
 400361c:	e0bfff15 	stw	r2,-4(fp)

    /* Obtain the number of bytes it is possible to obtain in the first
     * read.  Asserts check bounds of read and write. */
    configASSERT( xFirstLength <= xCount );
    configASSERT( ( xTail + xFirstLength ) <= pxStreamBuffer->xLength );
    ( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
 4003620:	e0bffe17 	ldw	r2,-8(fp)
 4003624:	10c00617 	ldw	r3,24(r2)
 4003628:	e0bffb17 	ldw	r2,-20(fp)
 400362c:	1885883a 	add	r2,r3,r2
 4003630:	e1bfff17 	ldw	r6,-4(fp)
 4003634:	100b883a 	mov	r5,r2
 4003638:	e13ffd17 	ldw	r4,-12(fp)
 400363c:	40075cc0 	call	40075cc <memcpy>

    /* If the total number of wanted bytes is greater than the number
     * that could be read in the first read... */
    if( xCount > xFirstLength )
 4003640:	e0bffc17 	ldw	r2,-16(fp)
 4003644:	e0ffff17 	ldw	r3,-4(fp)
 4003648:	18800a2e 	bgeu	r3,r2,4003674 <prvReadBytesFromBuffer+0x94>
    {
        /* ...then read the remaining bytes from the start of the buffer. */
        ( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
 400364c:	e0fffd17 	ldw	r3,-12(fp)
 4003650:	e0bfff17 	ldw	r2,-4(fp)
 4003654:	1889883a 	add	r4,r3,r2
 4003658:	e0bffe17 	ldw	r2,-8(fp)
 400365c:	11400617 	ldw	r5,24(r2)
 4003660:	e0fffc17 	ldw	r3,-16(fp)
 4003664:	e0bfff17 	ldw	r2,-4(fp)
 4003668:	1885c83a 	sub	r2,r3,r2
 400366c:	100d883a 	mov	r6,r2
 4003670:	40075cc0 	call	40075cc <memcpy>
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* Move the tail pointer to effectively remove the data read from the buffer. */
    xTail += xCount;
 4003674:	e0fffb17 	ldw	r3,-20(fp)
 4003678:	e0bffc17 	ldw	r2,-16(fp)
 400367c:	1885883a 	add	r2,r3,r2
 4003680:	e0bffb15 	stw	r2,-20(fp)

    if( xTail >= pxStreamBuffer->xLength )
 4003684:	e0bffe17 	ldw	r2,-8(fp)
 4003688:	10800217 	ldw	r2,8(r2)
 400368c:	e0fffb17 	ldw	r3,-20(fp)
 4003690:	18800536 	bltu	r3,r2,40036a8 <prvReadBytesFromBuffer+0xc8>
    {
        xTail -= pxStreamBuffer->xLength;
 4003694:	e0bffe17 	ldw	r2,-8(fp)
 4003698:	10800217 	ldw	r2,8(r2)
 400369c:	e0fffb17 	ldw	r3,-20(fp)
 40036a0:	1885c83a 	sub	r2,r3,r2
 40036a4:	e0bffb15 	stw	r2,-20(fp)
    }

    return xTail;
 40036a8:	e0bffb17 	ldw	r2,-20(fp)
}
 40036ac:	e037883a 	mov	sp,fp
 40036b0:	dfc00117 	ldw	ra,4(sp)
 40036b4:	df000017 	ldw	fp,0(sp)
 40036b8:	dec00204 	addi	sp,sp,8
 40036bc:	f800283a 	ret

040036c0 <prvBytesInBuffer>:
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
 40036c0:	defffd04 	addi	sp,sp,-12
 40036c4:	df000215 	stw	fp,8(sp)
 40036c8:	df000204 	addi	fp,sp,8
 40036cc:	e13ffe15 	stw	r4,-8(fp)
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 40036d0:	e0bffe17 	ldw	r2,-8(fp)
 40036d4:	10c00217 	ldw	r3,8(r2)
 40036d8:	e0bffe17 	ldw	r2,-8(fp)
 40036dc:	10800117 	ldw	r2,4(r2)
 40036e0:	1885883a 	add	r2,r3,r2
 40036e4:	e0bfff15 	stw	r2,-4(fp)
    xCount -= pxStreamBuffer->xTail;
 40036e8:	e0bffe17 	ldw	r2,-8(fp)
 40036ec:	10800017 	ldw	r2,0(r2)
 40036f0:	e0ffff17 	ldw	r3,-4(fp)
 40036f4:	1885c83a 	sub	r2,r3,r2
 40036f8:	e0bfff15 	stw	r2,-4(fp)

    if( xCount >= pxStreamBuffer->xLength )
 40036fc:	e0bffe17 	ldw	r2,-8(fp)
 4003700:	10800217 	ldw	r2,8(r2)
 4003704:	e0ffff17 	ldw	r3,-4(fp)
 4003708:	18800536 	bltu	r3,r2,4003720 <prvBytesInBuffer+0x60>
    {
        xCount -= pxStreamBuffer->xLength;
 400370c:	e0bffe17 	ldw	r2,-8(fp)
 4003710:	10800217 	ldw	r2,8(r2)
 4003714:	e0ffff17 	ldw	r3,-4(fp)
 4003718:	1885c83a 	sub	r2,r3,r2
 400371c:	e0bfff15 	stw	r2,-4(fp)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xCount;
 4003720:	e0bfff17 	ldw	r2,-4(fp)
}
 4003724:	e037883a 	mov	sp,fp
 4003728:	df000017 	ldw	fp,0(sp)
 400372c:	dec00104 	addi	sp,sp,4
 4003730:	f800283a 	ret

04003734 <prvInitialiseNewStreamBuffer>:
                                          size_t xBufferSizeBytes,
                                          size_t xTriggerLevelBytes,
                                          uint8_t ucFlags,
                                          StreamBufferCallbackFunction_t pxSendCompletedCallback,
                                          StreamBufferCallbackFunction_t pxReceiveCompletedCallback )
{
 4003734:	defff904 	addi	sp,sp,-28
 4003738:	dfc00615 	stw	ra,24(sp)
 400373c:	df000515 	stw	fp,20(sp)
 4003740:	df000504 	addi	fp,sp,20
 4003744:	e13fff15 	stw	r4,-4(fp)
 4003748:	e17ffe15 	stw	r5,-8(fp)
 400374c:	e1bffd15 	stw	r6,-12(fp)
 4003750:	e1fffc15 	stw	r7,-16(fp)
 4003754:	e0800217 	ldw	r2,8(fp)
 4003758:	e0bffb05 	stb	r2,-20(fp)
        const BaseType_t xWriteValue = 0x55;
        configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
    } /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
    #endif

    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
 400375c:	01800804 	movi	r6,32
 4003760:	000b883a 	mov	r5,zero
 4003764:	e13fff17 	ldw	r4,-4(fp)
 4003768:	40077540 	call	4007754 <memset>
    pxStreamBuffer->pucBuffer = pucBuffer;
 400376c:	e0bfff17 	ldw	r2,-4(fp)
 4003770:	e0fffe17 	ldw	r3,-8(fp)
 4003774:	10c00615 	stw	r3,24(r2)
    pxStreamBuffer->xLength = xBufferSizeBytes;
 4003778:	e0bfff17 	ldw	r2,-4(fp)
 400377c:	e0fffd17 	ldw	r3,-12(fp)
 4003780:	10c00215 	stw	r3,8(r2)
    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
 4003784:	e0bfff17 	ldw	r2,-4(fp)
 4003788:	e0fffc17 	ldw	r3,-16(fp)
 400378c:	10c00315 	stw	r3,12(r2)
    pxStreamBuffer->ucFlags = ucFlags;
 4003790:	e0bfff17 	ldw	r2,-4(fp)
 4003794:	e0fffb03 	ldbu	r3,-20(fp)
 4003798:	10c00705 	stb	r3,28(r2)
    {
        ( void ) pxSendCompletedCallback;
        ( void ) pxReceiveCompletedCallback;
    }
    #endif
}
 400379c:	0001883a 	nop
 40037a0:	e037883a 	mov	sp,fp
 40037a4:	dfc00117 	ldw	ra,4(sp)
 40037a8:	df000017 	ldw	fp,0(sp)
 40037ac:	dec00204 	addi	sp,sp,8
 40037b0:	f800283a 	ret

040037b4 <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
 40037b4:	defff304 	addi	sp,sp,-52
 40037b8:	dfc00c15 	stw	ra,48(sp)
 40037bc:	df000b15 	stw	fp,44(sp)
 40037c0:	df000b04 	addi	fp,sp,44
 40037c4:	e13ffc15 	stw	r4,-16(fp)
 40037c8:	e17ffb15 	stw	r5,-20(fp)
 40037cc:	3005883a 	mov	r2,r6
 40037d0:	e1fff915 	stw	r7,-28(fp)
 40037d4:	e0bffa0d 	sth	r2,-24(fp)
        #else /* portSTACK_GROWTH */
        {
            StackType_t * pxStack;

            /* Allocate space for the stack used by the task being created. */
            pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 40037d8:	e0bffa0b 	ldhu	r2,-24(fp)
 40037dc:	100490ba 	slli	r2,r2,2
 40037e0:	1009883a 	mov	r4,r2
 40037e4:	400103c0 	call	400103c <pvPortMalloc>
 40037e8:	e0bffd15 	stw	r2,-12(fp)

            if( pxStack != NULL )
 40037ec:	e0bffd17 	ldw	r2,-12(fp)
 40037f0:	10001026 	beq	r2,zero,4003834 <xTaskCreate+0x80>
            {
                /* Allocate space for the TCB. */
                pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
 40037f4:	01001404 	movi	r4,80
 40037f8:	400103c0 	call	400103c <pvPortMalloc>
 40037fc:	e0bfff15 	stw	r2,-4(fp)

                if( pxNewTCB != NULL )
 4003800:	e0bfff17 	ldw	r2,-4(fp)
 4003804:	10000826 	beq	r2,zero,4003828 <xTaskCreate+0x74>
                {
                    memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
 4003808:	01801404 	movi	r6,80
 400380c:	000b883a 	mov	r5,zero
 4003810:	e13fff17 	ldw	r4,-4(fp)
 4003814:	40077540 	call	4007754 <memset>

                    /* Store the stack location in the TCB. */
                    pxNewTCB->pxStack = pxStack;
 4003818:	e0bfff17 	ldw	r2,-4(fp)
 400381c:	e0fffd17 	ldw	r3,-12(fp)
 4003820:	10c00c15 	stw	r3,48(r2)
 4003824:	00000406 	br	4003838 <xTaskCreate+0x84>
                }
                else
                {
                    /* The stack cannot be used as the TCB was not created.  Free
                     * it again. */
                    vPortFreeStack( pxStack );
 4003828:	e13ffd17 	ldw	r4,-12(fp)
 400382c:	40011240 	call	4001124 <vPortFree>
 4003830:	00000106 	br	4003838 <xTaskCreate+0x84>
                }
            }
            else
            {
                pxNewTCB = NULL;
 4003834:	e03fff15 	stw	zero,-4(fp)
            }
        }
        #endif /* portSTACK_GROWTH */

        if( pxNewTCB != NULL )
 4003838:	e0bfff17 	ldw	r2,-4(fp)
 400383c:	10001226 	beq	r2,zero,4003888 <xTaskCreate+0xd4>
                 * task was created dynamically in case it is later deleted. */
                pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
            }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 4003840:	e0fffa0b 	ldhu	r3,-24(fp)
 4003844:	d8000315 	stw	zero,12(sp)
 4003848:	e0bfff17 	ldw	r2,-4(fp)
 400384c:	d8800215 	stw	r2,8(sp)
 4003850:	e0800317 	ldw	r2,12(fp)
 4003854:	d8800115 	stw	r2,4(sp)
 4003858:	e0800217 	ldw	r2,8(fp)
 400385c:	d8800015 	stw	r2,0(sp)
 4003860:	e1fff917 	ldw	r7,-28(fp)
 4003864:	180d883a 	mov	r6,r3
 4003868:	e17ffb17 	ldw	r5,-20(fp)
 400386c:	e13ffc17 	ldw	r4,-16(fp)
 4003870:	40038a80 	call	40038a8 <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
 4003874:	e13fff17 	ldw	r4,-4(fp)
 4003878:	4003a540 	call	4003a54 <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
 400387c:	00800044 	movi	r2,1
 4003880:	e0bffe15 	stw	r2,-8(fp)
 4003884:	00000206 	br	4003890 <xTaskCreate+0xdc>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 4003888:	00bfffc4 	movi	r2,-1
 400388c:	e0bffe15 	stw	r2,-8(fp)
        }

        return xReturn;
 4003890:	e0bffe17 	ldw	r2,-8(fp)
    }
 4003894:	e037883a 	mov	sp,fp
 4003898:	dfc00117 	ldw	ra,4(sp)
 400389c:	df000017 	ldw	fp,0(sp)
 40038a0:	dec00204 	addi	sp,sp,8
 40038a4:	f800283a 	ret

040038a8 <prvInitialiseNewTask>:
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions )
{
 40038a8:	defff804 	addi	sp,sp,-32
 40038ac:	dfc00715 	stw	ra,28(sp)
 40038b0:	df000615 	stw	fp,24(sp)
 40038b4:	df000604 	addi	fp,sp,24
 40038b8:	e13ffd15 	stw	r4,-12(fp)
 40038bc:	e17ffc15 	stw	r5,-16(fp)
 40038c0:	e1bffb15 	stw	r6,-20(fp)
 40038c4:	e1fffa15 	stw	r7,-24(fp)

    /* Avoid dependency on memset() if it is not required. */
    #if ( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
    {
        /* Fill the stack with a known value to assist debugging. */
        ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 40038c8:	e0800417 	ldw	r2,16(fp)
 40038cc:	10c00c17 	ldw	r3,48(r2)
 40038d0:	e0bffb17 	ldw	r2,-20(fp)
 40038d4:	100490ba 	slli	r2,r2,2
 40038d8:	100d883a 	mov	r6,r2
 40038dc:	01402944 	movi	r5,165
 40038e0:	1809883a 	mov	r4,r3
 40038e4:	40077540 	call	4007754 <memset>
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
    {
        pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 40038e8:	e0800417 	ldw	r2,16(fp)
 40038ec:	10c00c17 	ldw	r3,48(r2)
 40038f0:	e13ffb17 	ldw	r4,-20(fp)
 40038f4:	00900034 	movhi	r2,16384
 40038f8:	10bfffc4 	addi	r2,r2,-1
 40038fc:	2085883a 	add	r2,r4,r2
 4003900:	100490ba 	slli	r2,r2,2
 4003904:	1885883a 	add	r2,r3,r2
 4003908:	e0bffe15 	stw	r2,-8(fp)
        pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 400390c:	e0fffe17 	ldw	r3,-8(fp)
 4003910:	00bfff04 	movi	r2,-4
 4003914:	1884703a 	and	r2,r3,r2
 4003918:	e0bffe15 	stw	r2,-8(fp)
        pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
 400391c:	e0bffc17 	ldw	r2,-16(fp)
 4003920:	10001c26 	beq	r2,zero,4003994 <prvInitialiseNewTask+0xec>
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 4003924:	e03fff15 	stw	zero,-4(fp)
 4003928:	00001306 	br	4003978 <prvInitialiseNewTask+0xd0>
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 400392c:	e0fffc17 	ldw	r3,-16(fp)
 4003930:	e0bfff17 	ldw	r2,-4(fp)
 4003934:	1885883a 	add	r2,r3,r2
 4003938:	10c00003 	ldbu	r3,0(r2)
 400393c:	e1000417 	ldw	r4,16(fp)
 4003940:	e0bfff17 	ldw	r2,-4(fp)
 4003944:	2085883a 	add	r2,r4,r2
 4003948:	10c00d05 	stb	r3,52(r2)

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
 400394c:	e0fffc17 	ldw	r3,-16(fp)
 4003950:	e0bfff17 	ldw	r2,-4(fp)
 4003954:	1885883a 	add	r2,r3,r2
 4003958:	10800003 	ldbu	r2,0(r2)
 400395c:	10803fcc 	andi	r2,r2,255
 4003960:	1080201c 	xori	r2,r2,128
 4003964:	10bfe004 	addi	r2,r2,-128
 4003968:	10000726 	beq	r2,zero,4003988 <prvInitialiseNewTask+0xe0>
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 400396c:	e0bfff17 	ldw	r2,-4(fp)
 4003970:	10800044 	addi	r2,r2,1
 4003974:	e0bfff15 	stw	r2,-4(fp)
 4003978:	e0bfff17 	ldw	r2,-4(fp)
 400397c:	10800230 	cmpltui	r2,r2,8
 4003980:	103fea1e 	bne	r2,zero,400392c <prvInitialiseNewTask+0x84>
 4003984:	00000106 	br	400398c <prvInitialiseNewTask+0xe4>
            {
                break;
 4003988:	0001883a 	nop
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 400398c:	e0800417 	ldw	r2,16(fp)
 4003990:	10000ec5 	stb	zero,59(r2)
    }

    /* This is used as an array index so must ensure it's not too large. */
    configASSERT( uxPriority < configMAX_PRIORITIES );

    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 4003994:	e0800217 	ldw	r2,8(fp)
 4003998:	10800170 	cmpltui	r2,r2,5
 400399c:	1000021e 	bne	r2,zero,40039a8 <prvInitialiseNewTask+0x100>
    {
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 40039a0:	00800104 	movi	r2,4
 40039a4:	e0800215 	stw	r2,8(fp)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
 40039a8:	e0800417 	ldw	r2,16(fp)
 40039ac:	e0c00217 	ldw	r3,8(fp)
 40039b0:	10c00b15 	stw	r3,44(r2)
    #if ( configUSE_MUTEXES == 1 )
    {
        pxNewTCB->uxBasePriority = uxPriority;
 40039b4:	e0800417 	ldw	r2,16(fp)
 40039b8:	e0c00217 	ldw	r3,8(fp)
 40039bc:	10c01015 	stw	r3,64(r2)
    }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 40039c0:	e0800417 	ldw	r2,16(fp)
 40039c4:	10800104 	addi	r2,r2,4
 40039c8:	1009883a 	mov	r4,r2
 40039cc:	4000b080 	call	4000b08 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 40039d0:	e0800417 	ldw	r2,16(fp)
 40039d4:	10800604 	addi	r2,r2,24
 40039d8:	1009883a 	mov	r4,r2
 40039dc:	4000b080 	call	4000b08 <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 40039e0:	e0800417 	ldw	r2,16(fp)
 40039e4:	e0c00417 	ldw	r3,16(fp)
 40039e8:	10c00415 	stw	r3,16(r2)

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 40039ec:	00c00144 	movi	r3,5
 40039f0:	e0800217 	ldw	r2,8(fp)
 40039f4:	1887c83a 	sub	r3,r3,r2
 40039f8:	e0800417 	ldw	r2,16(fp)
 40039fc:	10c00615 	stw	r3,24(r2)
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 4003a00:	e0800417 	ldw	r2,16(fp)
 4003a04:	e0c00417 	ldw	r3,16(fp)
 4003a08:	10c00915 	stw	r3,36(r2)
            }
            #endif /* portSTACK_GROWTH */
        }
        #else /* portHAS_STACK_OVERFLOW_CHECKING */
        {
            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 4003a0c:	e1bffa17 	ldw	r6,-24(fp)
 4003a10:	e17ffd17 	ldw	r5,-12(fp)
 4003a14:	e13ffe17 	ldw	r4,-8(fp)
 4003a18:	4000d5c0 	call	4000d5c <pxPortInitialiseStack>
 4003a1c:	1007883a 	mov	r3,r2
 4003a20:	e0800417 	ldw	r2,16(fp)
 4003a24:	10c00015 	stw	r3,0(r2)
        }
        #endif /* portHAS_STACK_OVERFLOW_CHECKING */
    }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
 4003a28:	e0800317 	ldw	r2,12(fp)
 4003a2c:	10000326 	beq	r2,zero,4003a3c <prvInitialiseNewTask+0x194>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 4003a30:	e0800317 	ldw	r2,12(fp)
 4003a34:	e0c00417 	ldw	r3,16(fp)
 4003a38:	10c00015 	stw	r3,0(r2)
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
 4003a3c:	0001883a 	nop
 4003a40:	e037883a 	mov	sp,fp
 4003a44:	dfc00117 	ldw	ra,4(sp)
 4003a48:	df000017 	ldw	fp,0(sp)
 4003a4c:	dec00204 	addi	sp,sp,8
 4003a50:	f800283a 	ret

04003a54 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
 4003a54:	defffa04 	addi	sp,sp,-24
 4003a58:	dfc00515 	stw	ra,20(sp)
 4003a5c:	df000415 	stw	fp,16(sp)
 4003a60:	dc400315 	stw	r17,12(sp)
 4003a64:	dc000215 	stw	r16,8(sp)
 4003a68:	df000404 	addi	fp,sp,16
 4003a6c:	e13ffc15 	stw	r4,-16(fp)
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
 4003a70:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
    {
        uxCurrentNumberOfTasks++;
 4003a74:	d0a71717 	ldw	r2,-25508(gp)
 4003a78:	10800044 	addi	r2,r2,1
 4003a7c:	d0a71715 	stw	r2,-25508(gp)

        if( pxCurrentTCB == NULL )
 4003a80:	d0a71317 	ldw	r2,-25524(gp)
 4003a84:	1000071e 	bne	r2,zero,4003aa4 <prvAddNewTaskToReadyList+0x50>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
 4003a88:	e0bffc17 	ldw	r2,-16(fp)
 4003a8c:	d0a71315 	stw	r2,-25524(gp)

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 4003a90:	d0a71717 	ldw	r2,-25508(gp)
 4003a94:	10800058 	cmpnei	r2,r2,1
 4003a98:	10000b1e 	bne	r2,zero,4003ac8 <prvAddNewTaskToReadyList+0x74>
            {
                /* This is the first task to be created so do the preliminary
                 * initialisation required.  We will not recover if this call
                 * fails, but we will report the failure. */
                prvInitialiseTaskLists();
 4003a9c:	40057000 	call	4005700 <prvInitialiseTaskLists>
 4003aa0:	00000906 	br	4003ac8 <prvAddNewTaskToReadyList+0x74>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
 4003aa4:	d0a71a17 	ldw	r2,-25496(gp)
 4003aa8:	1000071e 	bne	r2,zero,4003ac8 <prvAddNewTaskToReadyList+0x74>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 4003aac:	d0a71317 	ldw	r2,-25524(gp)
 4003ab0:	10800b17 	ldw	r2,44(r2)
 4003ab4:	e0fffc17 	ldw	r3,-16(fp)
 4003ab8:	18c00b17 	ldw	r3,44(r3)
 4003abc:	18800236 	bltu	r3,r2,4003ac8 <prvAddNewTaskToReadyList+0x74>
                {
                    pxCurrentTCB = pxNewTCB;
 4003ac0:	e0bffc17 	ldw	r2,-16(fp)
 4003ac4:	d0a71315 	stw	r2,-25524(gp)
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
 4003ac8:	d0a71e17 	ldw	r2,-25480(gp)
 4003acc:	10800044 	addi	r2,r2,1
 4003ad0:	d0a71e15 	stw	r2,-25480(gp)
            pxNewTCB->uxTCBNumber = uxTaskNumber;
        }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
 4003ad4:	e0bffc17 	ldw	r2,-16(fp)
 4003ad8:	10800b17 	ldw	r2,44(r2)
 4003adc:	d0e71917 	ldw	r3,-25500(gp)
 4003ae0:	1880032e 	bgeu	r3,r2,4003af0 <prvAddNewTaskToReadyList+0x9c>
 4003ae4:	e0bffc17 	ldw	r2,-16(fp)
 4003ae8:	10800b17 	ldw	r2,44(r2)
 4003aec:	d0a71915 	stw	r2,-25500(gp)
 4003af0:	e0bffc17 	ldw	r2,-16(fp)
 4003af4:	10800b17 	ldw	r2,44(r2)
 4003af8:	01400504 	movi	r5,20
 4003afc:	1009883a 	mov	r4,r2
 4003b00:	40075a40 	call	40075a4 <__mulsi3>
 4003b04:	1007883a 	mov	r3,r2
 4003b08:	008120b4 	movhi	r2,1154
 4003b0c:	1885883a 	add	r2,r3,r2
 4003b10:	10baf517 	ldw	r2,-5164(r2)
 4003b14:	e0bffd15 	stw	r2,-12(fp)
 4003b18:	e0bffc17 	ldw	r2,-16(fp)
 4003b1c:	e0fffd17 	ldw	r3,-12(fp)
 4003b20:	10c00215 	stw	r3,8(r2)
 4003b24:	e0bffd17 	ldw	r2,-12(fp)
 4003b28:	10c00217 	ldw	r3,8(r2)
 4003b2c:	e0bffc17 	ldw	r2,-16(fp)
 4003b30:	10c00315 	stw	r3,12(r2)
 4003b34:	e0bffd17 	ldw	r2,-12(fp)
 4003b38:	10800217 	ldw	r2,8(r2)
 4003b3c:	e0fffc17 	ldw	r3,-16(fp)
 4003b40:	18c00104 	addi	r3,r3,4
 4003b44:	10c00115 	stw	r3,4(r2)
 4003b48:	e0bffc17 	ldw	r2,-16(fp)
 4003b4c:	10c00104 	addi	r3,r2,4
 4003b50:	e0bffd17 	ldw	r2,-12(fp)
 4003b54:	10c00215 	stw	r3,8(r2)
 4003b58:	e0bffc17 	ldw	r2,-16(fp)
 4003b5c:	10800b17 	ldw	r2,44(r2)
 4003b60:	01400504 	movi	r5,20
 4003b64:	1009883a 	mov	r4,r2
 4003b68:	40075a40 	call	40075a4 <__mulsi3>
 4003b6c:	1007883a 	mov	r3,r2
 4003b70:	008120b4 	movhi	r2,1154
 4003b74:	10baf404 	addi	r2,r2,-5168
 4003b78:	1887883a 	add	r3,r3,r2
 4003b7c:	e0bffc17 	ldw	r2,-16(fp)
 4003b80:	10c00515 	stw	r3,20(r2)
 4003b84:	e0bffc17 	ldw	r2,-16(fp)
 4003b88:	14400b17 	ldw	r17,44(r2)
 4003b8c:	01400504 	movi	r5,20
 4003b90:	8809883a 	mov	r4,r17
 4003b94:	40075a40 	call	40075a4 <__mulsi3>
 4003b98:	1007883a 	mov	r3,r2
 4003b9c:	008120b4 	movhi	r2,1154
 4003ba0:	1885883a 	add	r2,r3,r2
 4003ba4:	10baf417 	ldw	r2,-5168(r2)
 4003ba8:	14000044 	addi	r16,r2,1
 4003bac:	01400504 	movi	r5,20
 4003bb0:	8809883a 	mov	r4,r17
 4003bb4:	40075a40 	call	40075a4 <__mulsi3>
 4003bb8:	1007883a 	mov	r3,r2
 4003bbc:	008120b4 	movhi	r2,1154
 4003bc0:	1885883a 	add	r2,r3,r2
 4003bc4:	143af415 	stw	r16,-5168(r2)

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
 4003bc8:	4005fd00 	call	4005fd0 <vTaskExitCritical>

    if( xSchedulerRunning != pdFALSE )
 4003bcc:	d0a71a17 	ldw	r2,-25496(gp)
 4003bd0:	10000626 	beq	r2,zero,4003bec <prvAddNewTaskToReadyList+0x198>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 4003bd4:	d0a71317 	ldw	r2,-25524(gp)
 4003bd8:	10c00b17 	ldw	r3,44(r2)
 4003bdc:	e0bffc17 	ldw	r2,-16(fp)
 4003be0:	10800b17 	ldw	r2,44(r2)
 4003be4:	1880012e 	bgeu	r3,r2,4003bec <prvAddNewTaskToReadyList+0x198>
        {
            taskYIELD_IF_USING_PREEMPTION();
 4003be8:	003b683a 	trap	0
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
 4003bec:	0001883a 	nop
 4003bf0:	e6fffe04 	addi	sp,fp,-8
 4003bf4:	dfc00317 	ldw	ra,12(sp)
 4003bf8:	df000217 	ldw	fp,8(sp)
 4003bfc:	dc400117 	ldw	r17,4(sp)
 4003c00:	dc000017 	ldw	r16,0(sp)
 4003c04:	dec00404 	addi	sp,sp,16
 4003c08:	f800283a 	ret

04003c0c <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
 4003c0c:	defffc04 	addi	sp,sp,-16
 4003c10:	dfc00315 	stw	ra,12(sp)
 4003c14:	df000215 	stw	fp,8(sp)
 4003c18:	df000204 	addi	fp,sp,8
 4003c1c:	e13ffe15 	stw	r4,-8(fp)
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
 4003c20:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
        {
            /* If null is passed in here then it is the calling task that is
             * being deleted. */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 4003c24:	e0bffe17 	ldw	r2,-8(fp)
 4003c28:	1000021e 	bne	r2,zero,4003c34 <vTaskDelete+0x28>
 4003c2c:	d0a71317 	ldw	r2,-25524(gp)
 4003c30:	00000106 	br	4003c38 <vTaskDelete+0x2c>
 4003c34:	e0bffe17 	ldw	r2,-8(fp)
 4003c38:	e0bfff15 	stw	r2,-4(fp)

            /* Remove task from the ready/delayed list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4003c3c:	e0bfff17 	ldw	r2,-4(fp)
 4003c40:	10800104 	addi	r2,r2,4
 4003c44:	1009883a 	mov	r4,r2
 4003c48:	4000c980 	call	4000c98 <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 4003c4c:	e0bfff17 	ldw	r2,-4(fp)
 4003c50:	10800a17 	ldw	r2,40(r2)
 4003c54:	10000426 	beq	r2,zero,4003c68 <vTaskDelete+0x5c>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 4003c58:	e0bfff17 	ldw	r2,-4(fp)
 4003c5c:	10800604 	addi	r2,r2,24
 4003c60:	1009883a 	mov	r4,r2
 4003c64:	4000c980 	call	4000c98 <uxListRemove>

            /* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. */
            uxTaskNumber++;
 4003c68:	d0a71e17 	ldw	r2,-25480(gp)
 4003c6c:	10800044 	addi	r2,r2,1
 4003c70:	d0a71e15 	stw	r2,-25480(gp)

            if( pxTCB == pxCurrentTCB )
 4003c74:	d0a71317 	ldw	r2,-25524(gp)
 4003c78:	e0ffff17 	ldw	r3,-4(fp)
 4003c7c:	18800a1e 	bne	r3,r2,4003ca8 <vTaskDelete+0x9c>
                /* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
 4003c80:	e0bfff17 	ldw	r2,-4(fp)
 4003c84:	10800104 	addi	r2,r2,4
 4003c88:	100b883a 	mov	r5,r2
 4003c8c:	010120b4 	movhi	r4,1154
 4003c90:	213b1c04 	addi	r4,r4,-5008
 4003c94:	4000b340 	call	4000b34 <vListInsertEnd>

                /* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. */
                ++uxDeletedTasksWaitingCleanUp;
 4003c98:	d0a71617 	ldw	r2,-25512(gp)
 4003c9c:	10800044 	addi	r2,r2,1
 4003ca0:	d0a71615 	stw	r2,-25512(gp)
 4003ca4:	00000406 	br	4003cb8 <vTaskDelete+0xac>
                 * required. */
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
            }
            else
            {
                --uxCurrentNumberOfTasks;
 4003ca8:	d0a71717 	ldw	r2,-25508(gp)
 4003cac:	10bfffc4 	addi	r2,r2,-1
 4003cb0:	d0a71715 	stw	r2,-25508(gp)
                traceTASK_DELETE( pxTCB );

                /* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. */
                prvResetNextTaskUnblockTime();
 4003cb4:	40059480 	call	4005948 <prvResetNextTaskUnblockTime>
            }
        }
        taskEXIT_CRITICAL();
 4003cb8:	4005fd00 	call	4005fd0 <vTaskExitCritical>

        /* If the task is not deleting itself, call prvDeleteTCB from outside of
         * critical section. If a task deletes itself, prvDeleteTCB is called
         * from prvCheckTasksWaitingTermination which is called from Idle task. */
        if( pxTCB != pxCurrentTCB )
 4003cbc:	d0a71317 	ldw	r2,-25524(gp)
 4003cc0:	e0ffff17 	ldw	r3,-4(fp)
 4003cc4:	18800226 	beq	r3,r2,4003cd0 <vTaskDelete+0xc4>
        {
            prvDeleteTCB( pxTCB );
 4003cc8:	e13fff17 	ldw	r4,-4(fp)
 4003ccc:	40059040 	call	4005904 <prvDeleteTCB>
        }

        /* Force a reschedule if it is the currently running task that has just
         * been deleted. */
        if( xSchedulerRunning != pdFALSE )
 4003cd0:	d0a71a17 	ldw	r2,-25496(gp)
 4003cd4:	10000426 	beq	r2,zero,4003ce8 <vTaskDelete+0xdc>
        {
            if( pxTCB == pxCurrentTCB )
 4003cd8:	d0a71317 	ldw	r2,-25524(gp)
 4003cdc:	e0ffff17 	ldw	r3,-4(fp)
 4003ce0:	1880011e 	bne	r3,r2,4003ce8 <vTaskDelete+0xdc>
            {
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
 4003ce4:	003b683a 	trap	0
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
 4003ce8:	0001883a 	nop
 4003cec:	e037883a 	mov	sp,fp
 4003cf0:	dfc00117 	ldw	ra,4(sp)
 4003cf4:	df000017 	ldw	fp,0(sp)
 4003cf8:	dec00204 	addi	sp,sp,8
 4003cfc:	f800283a 	ret

04003d00 <xTaskDelayUntil>:

#if ( INCLUDE_xTaskDelayUntil == 1 )

    BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                                const TickType_t xTimeIncrement )
    {
 4003d00:	defff804 	addi	sp,sp,-32
 4003d04:	dfc00715 	stw	ra,28(sp)
 4003d08:	df000615 	stw	fp,24(sp)
 4003d0c:	df000604 	addi	fp,sp,24
 4003d10:	e13ffb15 	stw	r4,-20(fp)
 4003d14:	e17ffa15 	stw	r5,-24(fp)
        TickType_t xTimeToWake;
        BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
 4003d18:	e03fff15 	stw	zero,-4(fp)

        configASSERT( pxPreviousWakeTime );
        configASSERT( ( xTimeIncrement > 0U ) );
        configASSERT( uxSchedulerSuspended == 0 );

        vTaskSuspendAll();
 4003d1c:	40046f00 	call	40046f0 <vTaskSuspendAll>
        {
            /* Minor optimisation.  The tick count cannot change in this
             * block. */
            const TickType_t xConstTickCount = xTickCount;
 4003d20:	d0a71817 	ldw	r2,-25504(gp)
 4003d24:	e0bffe15 	stw	r2,-8(fp)

            /* Generate the tick time at which the task wants to wake. */
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 4003d28:	e0bffb17 	ldw	r2,-20(fp)
 4003d2c:	10800017 	ldw	r2,0(r2)
 4003d30:	e0fffa17 	ldw	r3,-24(fp)
 4003d34:	1885883a 	add	r2,r3,r2
 4003d38:	e0bffd15 	stw	r2,-12(fp)

            if( xConstTickCount < *pxPreviousWakeTime )
 4003d3c:	e0bffb17 	ldw	r2,-20(fp)
 4003d40:	10800017 	ldw	r2,0(r2)
 4003d44:	e0fffe17 	ldw	r3,-8(fp)
 4003d48:	18800a2e 	bgeu	r3,r2,4003d74 <xTaskDelayUntil+0x74>
                /* The tick count has overflowed since this function was
                 * lasted called.  In this case the only time we should ever
                 * actually delay is if the wake time has also  overflowed,
                 * and the wake time is greater than the tick time.  When this
                 * is the case it is as if neither time had overflowed. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 4003d4c:	e0bffb17 	ldw	r2,-20(fp)
 4003d50:	10800017 	ldw	r2,0(r2)
 4003d54:	e0fffd17 	ldw	r3,-12(fp)
 4003d58:	18800f2e 	bgeu	r3,r2,4003d98 <xTaskDelayUntil+0x98>
 4003d5c:	e0bffd17 	ldw	r2,-12(fp)
 4003d60:	e0fffe17 	ldw	r3,-8(fp)
 4003d64:	18800c2e 	bgeu	r3,r2,4003d98 <xTaskDelayUntil+0x98>
                {
                    xShouldDelay = pdTRUE;
 4003d68:	00800044 	movi	r2,1
 4003d6c:	e0bfff15 	stw	r2,-4(fp)
 4003d70:	00000906 	br	4003d98 <xTaskDelayUntil+0x98>
            else
            {
                /* The tick time has not overflowed.  In this case we will
                 * delay if either the wake time has overflowed, and/or the
                 * tick time is less than the wake time. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 4003d74:	e0bffb17 	ldw	r2,-20(fp)
 4003d78:	10800017 	ldw	r2,0(r2)
 4003d7c:	e0fffd17 	ldw	r3,-12(fp)
 4003d80:	18800336 	bltu	r3,r2,4003d90 <xTaskDelayUntil+0x90>
 4003d84:	e0bffd17 	ldw	r2,-12(fp)
 4003d88:	e0fffe17 	ldw	r3,-8(fp)
 4003d8c:	1880022e 	bgeu	r3,r2,4003d98 <xTaskDelayUntil+0x98>
                {
                    xShouldDelay = pdTRUE;
 4003d90:	00800044 	movi	r2,1
 4003d94:	e0bfff15 	stw	r2,-4(fp)
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            /* Update the wake time ready for the next call. */
            *pxPreviousWakeTime = xTimeToWake;
 4003d98:	e0bffb17 	ldw	r2,-20(fp)
 4003d9c:	e0fffd17 	ldw	r3,-12(fp)
 4003da0:	10c00015 	stw	r3,0(r2)

            if( xShouldDelay != pdFALSE )
 4003da4:	e0bfff17 	ldw	r2,-4(fp)
 4003da8:	10000626 	beq	r2,zero,4003dc4 <xTaskDelayUntil+0xc4>
            {
                traceTASK_DELAY_UNTIL( xTimeToWake );

                /* prvAddCurrentTaskToDelayedList() needs the block time, not
                 * the time to wake, so subtract the current tick count. */
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
 4003dac:	e0fffd17 	ldw	r3,-12(fp)
 4003db0:	e0bffe17 	ldw	r2,-8(fp)
 4003db4:	1885c83a 	sub	r2,r3,r2
 4003db8:	000b883a 	mov	r5,zero
 4003dbc:	1009883a 	mov	r4,r2
 4003dc0:	4006e3c0 	call	4006e3c <prvAddCurrentTaskToDelayedList>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        xAlreadyYielded = xTaskResumeAll();
 4003dc4:	400471c0 	call	400471c <xTaskResumeAll>
 4003dc8:	e0bffc15 	stw	r2,-16(fp)

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
 4003dcc:	e0bffc17 	ldw	r2,-16(fp)
 4003dd0:	1000011e 	bne	r2,zero,4003dd8 <xTaskDelayUntil+0xd8>
        {
            portYIELD_WITHIN_API();
 4003dd4:	003b683a 	trap	0
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xShouldDelay;
 4003dd8:	e0bfff17 	ldw	r2,-4(fp)
    }
 4003ddc:	e037883a 	mov	sp,fp
 4003de0:	dfc00117 	ldw	ra,4(sp)
 4003de4:	df000017 	ldw	fp,0(sp)
 4003de8:	dec00204 	addi	sp,sp,8
 4003dec:	f800283a 	ret

04003df0 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
 4003df0:	defffc04 	addi	sp,sp,-16
 4003df4:	dfc00315 	stw	ra,12(sp)
 4003df8:	df000215 	stw	fp,8(sp)
 4003dfc:	df000204 	addi	fp,sp,8
 4003e00:	e13ffe15 	stw	r4,-8(fp)
        BaseType_t xAlreadyYielded = pdFALSE;
 4003e04:	e03fff15 	stw	zero,-4(fp)

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
 4003e08:	e0bffe17 	ldw	r2,-8(fp)
 4003e0c:	10000626 	beq	r2,zero,4003e28 <vTaskDelay+0x38>
        {
            configASSERT( uxSchedulerSuspended == 0 );
            vTaskSuspendAll();
 4003e10:	40046f00 	call	40046f0 <vTaskSuspendAll>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 4003e14:	000b883a 	mov	r5,zero
 4003e18:	e13ffe17 	ldw	r4,-8(fp)
 4003e1c:	4006e3c0 	call	4006e3c <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
 4003e20:	400471c0 	call	400471c <xTaskResumeAll>
 4003e24:	e0bfff15 	stw	r2,-4(fp)
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
 4003e28:	e0bfff17 	ldw	r2,-4(fp)
 4003e2c:	1000011e 	bne	r2,zero,4003e34 <vTaskDelay+0x44>
        {
            portYIELD_WITHIN_API();
 4003e30:	003b683a 	trap	0
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
 4003e34:	0001883a 	nop
 4003e38:	e037883a 	mov	sp,fp
 4003e3c:	dfc00117 	ldw	ra,4(sp)
 4003e40:	df000017 	ldw	fp,0(sp)
 4003e44:	dec00204 	addi	sp,sp,8
 4003e48:	f800283a 	ret

04003e4c <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

    UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
    {
 4003e4c:	defffb04 	addi	sp,sp,-20
 4003e50:	dfc00415 	stw	ra,16(sp)
 4003e54:	df000315 	stw	fp,12(sp)
 4003e58:	df000304 	addi	fp,sp,12
 4003e5c:	e13ffd15 	stw	r4,-12(fp)
        TCB_t const * pxTCB;
        UBaseType_t uxReturn;

        taskENTER_CRITICAL();
 4003e60:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
        {
            /* If null is passed in here then it is the priority of the task
             * that called uxTaskPriorityGet() that is being queried. */
            pxTCB = prvGetTCBFromHandle( xTask );
 4003e64:	e0bffd17 	ldw	r2,-12(fp)
 4003e68:	1000021e 	bne	r2,zero,4003e74 <uxTaskPriorityGet+0x28>
 4003e6c:	d0a71317 	ldw	r2,-25524(gp)
 4003e70:	00000106 	br	4003e78 <uxTaskPriorityGet+0x2c>
 4003e74:	e0bffd17 	ldw	r2,-12(fp)
 4003e78:	e0bfff15 	stw	r2,-4(fp)
            uxReturn = pxTCB->uxPriority;
 4003e7c:	e0bfff17 	ldw	r2,-4(fp)
 4003e80:	10800b17 	ldw	r2,44(r2)
 4003e84:	e0bffe15 	stw	r2,-8(fp)
        }
        taskEXIT_CRITICAL();
 4003e88:	4005fd00 	call	4005fd0 <vTaskExitCritical>

        return uxReturn;
 4003e8c:	e0bffe17 	ldw	r2,-8(fp)
    }
 4003e90:	e037883a 	mov	sp,fp
 4003e94:	dfc00117 	ldw	ra,4(sp)
 4003e98:	df000017 	ldw	fp,0(sp)
 4003e9c:	dec00204 	addi	sp,sp,8
 4003ea0:	f800283a 	ret

04003ea4 <uxTaskPriorityGetFromISR>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

    UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
    {
 4003ea4:	defffb04 	addi	sp,sp,-20
 4003ea8:	df000415 	stw	fp,16(sp)
 4003eac:	df000404 	addi	fp,sp,16
 4003eb0:	e13ffc15 	stw	r4,-16(fp)
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
 4003eb4:	e03fff15 	stw	zero,-4(fp)
        {
            /* If null is passed in here then it is the priority of the calling
             * task that is being queried. */
            pxTCB = prvGetTCBFromHandle( xTask );
 4003eb8:	e0bffc17 	ldw	r2,-16(fp)
 4003ebc:	1000021e 	bne	r2,zero,4003ec8 <uxTaskPriorityGetFromISR+0x24>
 4003ec0:	d0a71317 	ldw	r2,-25524(gp)
 4003ec4:	00000106 	br	4003ecc <uxTaskPriorityGetFromISR+0x28>
 4003ec8:	e0bffc17 	ldw	r2,-16(fp)
 4003ecc:	e0bffe15 	stw	r2,-8(fp)
            uxReturn = pxTCB->uxPriority;
 4003ed0:	e0bffe17 	ldw	r2,-8(fp)
 4003ed4:	10800b17 	ldw	r2,44(r2)
 4003ed8:	e0bffd15 	stw	r2,-12(fp)
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

        return uxReturn;
 4003edc:	e0bffd17 	ldw	r2,-12(fp)
    }
 4003ee0:	e037883a 	mov	sp,fp
 4003ee4:	df000017 	ldw	fp,0(sp)
 4003ee8:	dec00104 	addi	sp,sp,4
 4003eec:	f800283a 	ret

04003ef0 <vTaskPrioritySet>:

#if ( INCLUDE_vTaskPrioritySet == 1 )

    void vTaskPrioritySet( TaskHandle_t xTask,
                           UBaseType_t uxNewPriority )
    {
 4003ef0:	defff504 	addi	sp,sp,-44
 4003ef4:	dfc00a15 	stw	ra,40(sp)
 4003ef8:	df000915 	stw	fp,36(sp)
 4003efc:	dc400815 	stw	r17,32(sp)
 4003f00:	dc000715 	stw	r16,28(sp)
 4003f04:	df000904 	addi	fp,sp,36
 4003f08:	e13ff815 	stw	r4,-32(fp)
 4003f0c:	e17ff715 	stw	r5,-36(fp)
        TCB_t * pxTCB;
        UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
        BaseType_t xYieldRequired = pdFALSE;
 4003f10:	e03ffd15 	stw	zero,-12(fp)

        configASSERT( uxNewPriority < configMAX_PRIORITIES );

        /* Ensure the new priority is valid. */
        if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 4003f14:	e0bff717 	ldw	r2,-36(fp)
 4003f18:	10800170 	cmpltui	r2,r2,5
 4003f1c:	1000021e 	bne	r2,zero,4003f28 <vTaskPrioritySet+0x38>
        {
            uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 4003f20:	00800104 	movi	r2,4
 4003f24:	e0bff715 	stw	r2,-36(fp)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        taskENTER_CRITICAL();
 4003f28:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
        {
            /* If null is passed in here then it is the priority of the calling
             * task that is being changed. */
            pxTCB = prvGetTCBFromHandle( xTask );
 4003f2c:	e0bff817 	ldw	r2,-32(fp)
 4003f30:	1000021e 	bne	r2,zero,4003f3c <vTaskPrioritySet+0x4c>
 4003f34:	d0a71317 	ldw	r2,-25524(gp)
 4003f38:	00000106 	br	4003f40 <vTaskPrioritySet+0x50>
 4003f3c:	e0bff817 	ldw	r2,-32(fp)
 4003f40:	e0bffc15 	stw	r2,-16(fp)

            traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

            #if ( configUSE_MUTEXES == 1 )
            {
                uxCurrentBasePriority = pxTCB->uxBasePriority;
 4003f44:	e0bffc17 	ldw	r2,-16(fp)
 4003f48:	10801017 	ldw	r2,64(r2)
 4003f4c:	e0bffb15 	stw	r2,-20(fp)
            {
                uxCurrentBasePriority = pxTCB->uxPriority;
            }
            #endif

            if( uxCurrentBasePriority != uxNewPriority )
 4003f50:	e0fffb17 	ldw	r3,-20(fp)
 4003f54:	e0bff717 	ldw	r2,-36(fp)
 4003f58:	18807626 	beq	r3,r2,4004134 <vTaskPrioritySet+0x244>
            {
                /* The priority change may have readied a task of higher
                 * priority than the calling task. */
                if( uxNewPriority > uxCurrentBasePriority )
 4003f5c:	e0bff717 	ldw	r2,-36(fp)
 4003f60:	e0fffb17 	ldw	r3,-20(fp)
 4003f64:	18800a2e 	bgeu	r3,r2,4003f90 <vTaskPrioritySet+0xa0>
                {
                    if( pxTCB != pxCurrentTCB )
 4003f68:	d0a71317 	ldw	r2,-25524(gp)
 4003f6c:	e0fffc17 	ldw	r3,-16(fp)
 4003f70:	18800c26 	beq	r3,r2,4003fa4 <vTaskPrioritySet+0xb4>
                    {
                        /* The priority of a task other than the currently
                         * running task is being raised.  Is the priority being
                         * raised above that of the running task? */
                        if( uxNewPriority >= pxCurrentTCB->uxPriority )
 4003f74:	d0a71317 	ldw	r2,-25524(gp)
 4003f78:	10800b17 	ldw	r2,44(r2)
 4003f7c:	e0fff717 	ldw	r3,-36(fp)
 4003f80:	18800836 	bltu	r3,r2,4003fa4 <vTaskPrioritySet+0xb4>
                        {
                            xYieldRequired = pdTRUE;
 4003f84:	00800044 	movi	r2,1
 4003f88:	e0bffd15 	stw	r2,-12(fp)
 4003f8c:	00000506 	br	4003fa4 <vTaskPrioritySet+0xb4>
                        /* The priority of the running task is being raised,
                         * but the running task must already be the highest
                         * priority task able to run so no yield is required. */
                    }
                }
                else if( pxTCB == pxCurrentTCB )
 4003f90:	d0a71317 	ldw	r2,-25524(gp)
 4003f94:	e0fffc17 	ldw	r3,-16(fp)
 4003f98:	1880021e 	bne	r3,r2,4003fa4 <vTaskPrioritySet+0xb4>
                {
                    /* Setting the priority of the running task down means
                     * there may now be another task of higher priority that
                     * is ready to execute. */
                    xYieldRequired = pdTRUE;
 4003f9c:	00800044 	movi	r2,1
 4003fa0:	e0bffd15 	stw	r2,-12(fp)
                }

                /* Remember the ready list the task might be referenced from
                 * before its uxPriority member is changed so the
                 * taskRESET_READY_PRIORITY() macro can function correctly. */
                uxPriorityUsedOnEntry = pxTCB->uxPriority;
 4003fa4:	e0bffc17 	ldw	r2,-16(fp)
 4003fa8:	10800b17 	ldw	r2,44(r2)
 4003fac:	e0bffa15 	stw	r2,-24(fp)

                #if ( configUSE_MUTEXES == 1 )
                {
                    /* Only change the priority being used if the task is not
                     * currently using an inherited priority. */
                    if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 4003fb0:	e0bffc17 	ldw	r2,-16(fp)
 4003fb4:	10c01017 	ldw	r3,64(r2)
 4003fb8:	e0bffc17 	ldw	r2,-16(fp)
 4003fbc:	10800b17 	ldw	r2,44(r2)
 4003fc0:	1880031e 	bne	r3,r2,4003fd0 <vTaskPrioritySet+0xe0>
                    {
                        pxTCB->uxPriority = uxNewPriority;
 4003fc4:	e0bffc17 	ldw	r2,-16(fp)
 4003fc8:	e0fff717 	ldw	r3,-36(fp)
 4003fcc:	10c00b15 	stw	r3,44(r2)
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* The base priority gets set whatever. */
                    pxTCB->uxBasePriority = uxNewPriority;
 4003fd0:	e0bffc17 	ldw	r2,-16(fp)
 4003fd4:	e0fff717 	ldw	r3,-36(fp)
 4003fd8:	10c01015 	stw	r3,64(r2)
                }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                /* Only reset the event list item value if the value is not
                 * being used for anything else. */
                if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 4003fdc:	e0bffc17 	ldw	r2,-16(fp)
 4003fe0:	10800617 	ldw	r2,24(r2)
 4003fe4:	10000516 	blt	r2,zero,4003ffc <vTaskPrioritySet+0x10c>
                {
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 4003fe8:	00c00144 	movi	r3,5
 4003fec:	e0bff717 	ldw	r2,-36(fp)
 4003ff0:	1887c83a 	sub	r3,r3,r2
 4003ff4:	e0bffc17 	ldw	r2,-16(fp)
 4003ff8:	10c00615 	stw	r3,24(r2)

                /* If the task is in the blocked or suspended list we need do
                 * nothing more than change its priority variable. However, if
                 * the task is in a ready list it needs to be removed and placed
                 * in the list appropriate to its new priority. */
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 4003ffc:	e0bffc17 	ldw	r2,-16(fp)
 4004000:	14000517 	ldw	r16,20(r2)
 4004004:	01400504 	movi	r5,20
 4004008:	e13ffa17 	ldw	r4,-24(fp)
 400400c:	40075a40 	call	40075a4 <__mulsi3>
 4004010:	1007883a 	mov	r3,r2
 4004014:	008120b4 	movhi	r2,1154
 4004018:	10baf404 	addi	r2,r2,-5168
 400401c:	1885883a 	add	r2,r3,r2
 4004020:	8080411e 	bne	r16,r2,4004128 <vTaskPrioritySet+0x238>
                {
                    /* The task is currently in its ready list - remove before
                     * adding it to its new ready list.  As we are in a critical
                     * section we can do this even if the scheduler is suspended. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4004024:	e0bffc17 	ldw	r2,-16(fp)
 4004028:	10800104 	addi	r2,r2,4
 400402c:	1009883a 	mov	r4,r2
 4004030:	4000c980 	call	4000c98 <uxListRemove>
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    prvAddTaskToReadyList( pxTCB );
 4004034:	e0bffc17 	ldw	r2,-16(fp)
 4004038:	10800b17 	ldw	r2,44(r2)
 400403c:	d0e71917 	ldw	r3,-25500(gp)
 4004040:	1880032e 	bgeu	r3,r2,4004050 <vTaskPrioritySet+0x160>
 4004044:	e0bffc17 	ldw	r2,-16(fp)
 4004048:	10800b17 	ldw	r2,44(r2)
 400404c:	d0a71915 	stw	r2,-25500(gp)
 4004050:	e0bffc17 	ldw	r2,-16(fp)
 4004054:	10800b17 	ldw	r2,44(r2)
 4004058:	01400504 	movi	r5,20
 400405c:	1009883a 	mov	r4,r2
 4004060:	40075a40 	call	40075a4 <__mulsi3>
 4004064:	1007883a 	mov	r3,r2
 4004068:	008120b4 	movhi	r2,1154
 400406c:	1885883a 	add	r2,r3,r2
 4004070:	10baf517 	ldw	r2,-5164(r2)
 4004074:	e0bff915 	stw	r2,-28(fp)
 4004078:	e0bffc17 	ldw	r2,-16(fp)
 400407c:	e0fff917 	ldw	r3,-28(fp)
 4004080:	10c00215 	stw	r3,8(r2)
 4004084:	e0bff917 	ldw	r2,-28(fp)
 4004088:	10c00217 	ldw	r3,8(r2)
 400408c:	e0bffc17 	ldw	r2,-16(fp)
 4004090:	10c00315 	stw	r3,12(r2)
 4004094:	e0bff917 	ldw	r2,-28(fp)
 4004098:	10800217 	ldw	r2,8(r2)
 400409c:	e0fffc17 	ldw	r3,-16(fp)
 40040a0:	18c00104 	addi	r3,r3,4
 40040a4:	10c00115 	stw	r3,4(r2)
 40040a8:	e0bffc17 	ldw	r2,-16(fp)
 40040ac:	10c00104 	addi	r3,r2,4
 40040b0:	e0bff917 	ldw	r2,-28(fp)
 40040b4:	10c00215 	stw	r3,8(r2)
 40040b8:	e0bffc17 	ldw	r2,-16(fp)
 40040bc:	10800b17 	ldw	r2,44(r2)
 40040c0:	01400504 	movi	r5,20
 40040c4:	1009883a 	mov	r4,r2
 40040c8:	40075a40 	call	40075a4 <__mulsi3>
 40040cc:	1007883a 	mov	r3,r2
 40040d0:	008120b4 	movhi	r2,1154
 40040d4:	10baf404 	addi	r2,r2,-5168
 40040d8:	1887883a 	add	r3,r3,r2
 40040dc:	e0bffc17 	ldw	r2,-16(fp)
 40040e0:	10c00515 	stw	r3,20(r2)
 40040e4:	e0bffc17 	ldw	r2,-16(fp)
 40040e8:	14400b17 	ldw	r17,44(r2)
 40040ec:	01400504 	movi	r5,20
 40040f0:	8809883a 	mov	r4,r17
 40040f4:	40075a40 	call	40075a4 <__mulsi3>
 40040f8:	1007883a 	mov	r3,r2
 40040fc:	008120b4 	movhi	r2,1154
 4004100:	1885883a 	add	r2,r3,r2
 4004104:	10baf417 	ldw	r2,-5168(r2)
 4004108:	14000044 	addi	r16,r2,1
 400410c:	01400504 	movi	r5,20
 4004110:	8809883a 	mov	r4,r17
 4004114:	40075a40 	call	40075a4 <__mulsi3>
 4004118:	1007883a 	mov	r3,r2
 400411c:	008120b4 	movhi	r2,1154
 4004120:	1885883a 	add	r2,r3,r2
 4004124:	143af415 	stw	r16,-5168(r2)
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                if( xYieldRequired != pdFALSE )
 4004128:	e0bffd17 	ldw	r2,-12(fp)
 400412c:	10000126 	beq	r2,zero,4004134 <vTaskPrioritySet+0x244>
                {
                    taskYIELD_IF_USING_PREEMPTION();
 4004130:	003b683a 	trap	0
                /* Remove compiler warning about unused variables when the port
                 * optimised task selection is not being used. */
                ( void ) uxPriorityUsedOnEntry;
            }
        }
        taskEXIT_CRITICAL();
 4004134:	4005fd00 	call	4005fd0 <vTaskExitCritical>
    }
 4004138:	0001883a 	nop
 400413c:	e6fffe04 	addi	sp,fp,-8
 4004140:	dfc00317 	ldw	ra,12(sp)
 4004144:	df000217 	ldw	fp,8(sp)
 4004148:	dc400117 	ldw	r17,4(sp)
 400414c:	dc000017 	ldw	r16,0(sp)
 4004150:	dec00404 	addi	sp,sp,16
 4004154:	f800283a 	ret

04004158 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    void vTaskSuspend( TaskHandle_t xTaskToSuspend )
    {
 4004158:	defffb04 	addi	sp,sp,-20
 400415c:	dfc00415 	stw	ra,16(sp)
 4004160:	df000315 	stw	fp,12(sp)
 4004164:	df000304 	addi	fp,sp,12
 4004168:	e13ffd15 	stw	r4,-12(fp)
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
 400416c:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
        {
            /* If null is passed in here then it is the running task that is
             * being suspended. */
            pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 4004170:	e0bffd17 	ldw	r2,-12(fp)
 4004174:	1000021e 	bne	r2,zero,4004180 <vTaskSuspend+0x28>
 4004178:	d0a71317 	ldw	r2,-25524(gp)
 400417c:	00000106 	br	4004184 <vTaskSuspend+0x2c>
 4004180:	e0bffd17 	ldw	r2,-12(fp)
 4004184:	e0bffe15 	stw	r2,-8(fp)

            traceTASK_SUSPEND( pxTCB );

            /* Remove task from the ready/delayed list and place in the
             * suspended list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4004188:	e0bffe17 	ldw	r2,-8(fp)
 400418c:	10800104 	addi	r2,r2,4
 4004190:	1009883a 	mov	r4,r2
 4004194:	4000c980 	call	4000c98 <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 4004198:	e0bffe17 	ldw	r2,-8(fp)
 400419c:	10800a17 	ldw	r2,40(r2)
 40041a0:	10000426 	beq	r2,zero,40041b4 <vTaskSuspend+0x5c>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 40041a4:	e0bffe17 	ldw	r2,-8(fp)
 40041a8:	10800604 	addi	r2,r2,24
 40041ac:	1009883a 	mov	r4,r2
 40041b0:	4000c980 	call	4000c98 <uxListRemove>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 40041b4:	e0bffe17 	ldw	r2,-8(fp)
 40041b8:	10800104 	addi	r2,r2,4
 40041bc:	100b883a 	mov	r5,r2
 40041c0:	010120b4 	movhi	r4,1154
 40041c4:	213b2104 	addi	r4,r4,-4988
 40041c8:	4000b340 	call	4000b34 <vListInsertEnd>

            #if ( configUSE_TASK_NOTIFICATIONS == 1 )
            {
                BaseType_t x;

                for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
 40041cc:	e03fff15 	stw	zero,-4(fp)
 40041d0:	00000e06 	br	400420c <vTaskSuspend+0xb4>
                {
                    if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
 40041d4:	e0fffe17 	ldw	r3,-8(fp)
 40041d8:	e0bfff17 	ldw	r2,-4(fp)
 40041dc:	1885883a 	add	r2,r3,r2
 40041e0:	10801303 	ldbu	r2,76(r2)
 40041e4:	10803fcc 	andi	r2,r2,255
 40041e8:	10800058 	cmpnei	r2,r2,1
 40041ec:	1000041e 	bne	r2,zero,4004200 <vTaskSuspend+0xa8>
                    {
                        /* The task was blocked to wait for a notification, but is
                         * now suspended, so no notification was received. */
                        pxTCB->ucNotifyState[ x ] = taskNOT_WAITING_NOTIFICATION;
 40041f0:	e0fffe17 	ldw	r3,-8(fp)
 40041f4:	e0bfff17 	ldw	r2,-4(fp)
 40041f8:	1885883a 	add	r2,r3,r2
 40041fc:	10001305 	stb	zero,76(r2)
                for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
 4004200:	e0bfff17 	ldw	r2,-4(fp)
 4004204:	10800044 	addi	r2,r2,1
 4004208:	e0bfff15 	stw	r2,-4(fp)
 400420c:	e0bfff17 	ldw	r2,-4(fp)
 4004210:	00bff00e 	bge	zero,r2,40041d4 <vTaskSuspend+0x7c>
                    }
                }
            }
            #endif /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
        }
        taskEXIT_CRITICAL();
 4004214:	4005fd00 	call	4005fd0 <vTaskExitCritical>

        if( xSchedulerRunning != pdFALSE )
 4004218:	d0a71a17 	ldw	r2,-25496(gp)
 400421c:	10000326 	beq	r2,zero,400422c <vTaskSuspend+0xd4>
        {
            /* Reset the next expected unblock time in case it referred to the
             * task that is now in the Suspended state. */
            taskENTER_CRITICAL();
 4004220:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
            {
                prvResetNextTaskUnblockTime();
 4004224:	40059480 	call	4005948 <prvResetNextTaskUnblockTime>
            }
            taskEXIT_CRITICAL();
 4004228:	4005fd00 	call	4005fd0 <vTaskExitCritical>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( pxTCB == pxCurrentTCB )
 400422c:	d0a71317 	ldw	r2,-25524(gp)
 4004230:	e0fffe17 	ldw	r3,-8(fp)
 4004234:	18800b1e 	bne	r3,r2,4004264 <vTaskSuspend+0x10c>
        {
            if( xSchedulerRunning != pdFALSE )
 4004238:	d0a71a17 	ldw	r2,-25496(gp)
 400423c:	10000226 	beq	r2,zero,4004248 <vTaskSuspend+0xf0>
            {
                /* The current task has just been suspended. */
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
 4004240:	003b683a 	trap	0
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
 4004244:	00000706 	br	4004264 <vTaskSuspend+0x10c>
                if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
 4004248:	008120b4 	movhi	r2,1154
 400424c:	10fb2117 	ldw	r3,-4988(r2)
 4004250:	d0a71717 	ldw	r2,-25508(gp)
 4004254:	1880021e 	bne	r3,r2,4004260 <vTaskSuspend+0x108>
                    pxCurrentTCB = NULL;
 4004258:	d0271315 	stw	zero,-25524(gp)
    }
 400425c:	00000106 	br	4004264 <vTaskSuspend+0x10c>
                    vTaskSwitchContext();
 4004260:	4004e300 	call	4004e30 <vTaskSwitchContext>
    }
 4004264:	0001883a 	nop
 4004268:	e037883a 	mov	sp,fp
 400426c:	dfc00117 	ldw	ra,4(sp)
 4004270:	df000017 	ldw	fp,0(sp)
 4004274:	dec00204 	addi	sp,sp,8
 4004278:	f800283a 	ret

0400427c <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
    {
 400427c:	defffc04 	addi	sp,sp,-16
 4004280:	df000315 	stw	fp,12(sp)
 4004284:	df000304 	addi	fp,sp,12
 4004288:	e13ffd15 	stw	r4,-12(fp)
        BaseType_t xReturn = pdFALSE;
 400428c:	e03fff15 	stw	zero,-4(fp)
        const TCB_t * const pxTCB = xTask;
 4004290:	e0bffd17 	ldw	r2,-12(fp)
 4004294:	e0bffe15 	stw	r2,-8(fp)

        /* It does not make sense to check if the calling task is suspended. */
        configASSERT( xTask );

        /* Is the task being resumed actually in the suspended list? */
        if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
 4004298:	e0bffe17 	ldw	r2,-8(fp)
 400429c:	10c00517 	ldw	r3,20(r2)
 40042a0:	008120b4 	movhi	r2,1154
 40042a4:	10bb2104 	addi	r2,r2,-4988
 40042a8:	18800a1e 	bne	r3,r2,40042d4 <prvTaskIsTaskSuspended+0x58>
        {
            /* Has the task already been resumed from within an ISR? */
            if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 40042ac:	e0bffe17 	ldw	r2,-8(fp)
 40042b0:	10c00a17 	ldw	r3,40(r2)
 40042b4:	008120b4 	movhi	r2,1154
 40042b8:	10bb1704 	addi	r2,r2,-5028
 40042bc:	18800526 	beq	r3,r2,40042d4 <prvTaskIsTaskSuspended+0x58>
            {
                /* Is it in the suspended list because it is in the Suspended
                 * state, or because is is blocked with no timeout? */
                if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
 40042c0:	e0bffe17 	ldw	r2,-8(fp)
 40042c4:	10800a17 	ldw	r2,40(r2)
 40042c8:	1000021e 	bne	r2,zero,40042d4 <prvTaskIsTaskSuspended+0x58>
                {
                    xReturn = pdTRUE;
 40042cc:	00800044 	movi	r2,1
 40042d0:	e0bfff15 	stw	r2,-4(fp)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
 40042d4:	e0bfff17 	ldw	r2,-4(fp)
    } /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 40042d8:	e037883a 	mov	sp,fp
 40042dc:	df000017 	ldw	fp,0(sp)
 40042e0:	dec00104 	addi	sp,sp,4
 40042e4:	f800283a 	ret

040042e8 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    void vTaskResume( TaskHandle_t xTaskToResume )
    {
 40042e8:	defff904 	addi	sp,sp,-28
 40042ec:	dfc00615 	stw	ra,24(sp)
 40042f0:	df000515 	stw	fp,20(sp)
 40042f4:	dc400415 	stw	r17,16(sp)
 40042f8:	dc000315 	stw	r16,12(sp)
 40042fc:	df000504 	addi	fp,sp,20
 4004300:	e13ffb15 	stw	r4,-20(fp)
        TCB_t * const pxTCB = xTaskToResume;
 4004304:	e0bffb17 	ldw	r2,-20(fp)
 4004308:	e0bffd15 	stw	r2,-12(fp)
        /* It does not make sense to resume the calling task. */
        configASSERT( xTaskToResume );

        /* The parameter cannot be NULL as it is impossible to resume the
         * currently executing task. */
        if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
 400430c:	d0a71317 	ldw	r2,-25524(gp)
 4004310:	e0fffd17 	ldw	r3,-12(fp)
 4004314:	18804e26 	beq	r3,r2,4004450 <vTaskResume+0x168>
 4004318:	e0bffd17 	ldw	r2,-12(fp)
 400431c:	10004c26 	beq	r2,zero,4004450 <vTaskResume+0x168>
        {
            taskENTER_CRITICAL();
 4004320:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
            {
                if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 4004324:	e13ffd17 	ldw	r4,-12(fp)
 4004328:	400427c0 	call	400427c <prvTaskIsTaskSuspended>
 400432c:	10004726 	beq	r2,zero,400444c <vTaskResume+0x164>
                {
                    traceTASK_RESUME( pxTCB );

                    /* The ready list can be accessed even if the scheduler is
                     * suspended because this is inside a critical section. */
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 4004330:	e0bffd17 	ldw	r2,-12(fp)
 4004334:	10800104 	addi	r2,r2,4
 4004338:	1009883a 	mov	r4,r2
 400433c:	4000c980 	call	4000c98 <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
 4004340:	e0bffd17 	ldw	r2,-12(fp)
 4004344:	10800b17 	ldw	r2,44(r2)
 4004348:	d0e71917 	ldw	r3,-25500(gp)
 400434c:	1880032e 	bgeu	r3,r2,400435c <vTaskResume+0x74>
 4004350:	e0bffd17 	ldw	r2,-12(fp)
 4004354:	10800b17 	ldw	r2,44(r2)
 4004358:	d0a71915 	stw	r2,-25500(gp)
 400435c:	e0bffd17 	ldw	r2,-12(fp)
 4004360:	10800b17 	ldw	r2,44(r2)
 4004364:	01400504 	movi	r5,20
 4004368:	1009883a 	mov	r4,r2
 400436c:	40075a40 	call	40075a4 <__mulsi3>
 4004370:	1007883a 	mov	r3,r2
 4004374:	008120b4 	movhi	r2,1154
 4004378:	1885883a 	add	r2,r3,r2
 400437c:	10baf517 	ldw	r2,-5164(r2)
 4004380:	e0bffc15 	stw	r2,-16(fp)
 4004384:	e0bffd17 	ldw	r2,-12(fp)
 4004388:	e0fffc17 	ldw	r3,-16(fp)
 400438c:	10c00215 	stw	r3,8(r2)
 4004390:	e0bffc17 	ldw	r2,-16(fp)
 4004394:	10c00217 	ldw	r3,8(r2)
 4004398:	e0bffd17 	ldw	r2,-12(fp)
 400439c:	10c00315 	stw	r3,12(r2)
 40043a0:	e0bffc17 	ldw	r2,-16(fp)
 40043a4:	10800217 	ldw	r2,8(r2)
 40043a8:	e0fffd17 	ldw	r3,-12(fp)
 40043ac:	18c00104 	addi	r3,r3,4
 40043b0:	10c00115 	stw	r3,4(r2)
 40043b4:	e0bffd17 	ldw	r2,-12(fp)
 40043b8:	10c00104 	addi	r3,r2,4
 40043bc:	e0bffc17 	ldw	r2,-16(fp)
 40043c0:	10c00215 	stw	r3,8(r2)
 40043c4:	e0bffd17 	ldw	r2,-12(fp)
 40043c8:	10800b17 	ldw	r2,44(r2)
 40043cc:	01400504 	movi	r5,20
 40043d0:	1009883a 	mov	r4,r2
 40043d4:	40075a40 	call	40075a4 <__mulsi3>
 40043d8:	1007883a 	mov	r3,r2
 40043dc:	008120b4 	movhi	r2,1154
 40043e0:	10baf404 	addi	r2,r2,-5168
 40043e4:	1887883a 	add	r3,r3,r2
 40043e8:	e0bffd17 	ldw	r2,-12(fp)
 40043ec:	10c00515 	stw	r3,20(r2)
 40043f0:	e0bffd17 	ldw	r2,-12(fp)
 40043f4:	14400b17 	ldw	r17,44(r2)
 40043f8:	01400504 	movi	r5,20
 40043fc:	8809883a 	mov	r4,r17
 4004400:	40075a40 	call	40075a4 <__mulsi3>
 4004404:	1007883a 	mov	r3,r2
 4004408:	008120b4 	movhi	r2,1154
 400440c:	1885883a 	add	r2,r3,r2
 4004410:	10baf417 	ldw	r2,-5168(r2)
 4004414:	14000044 	addi	r16,r2,1
 4004418:	01400504 	movi	r5,20
 400441c:	8809883a 	mov	r4,r17
 4004420:	40075a40 	call	40075a4 <__mulsi3>
 4004424:	1007883a 	mov	r3,r2
 4004428:	008120b4 	movhi	r2,1154
 400442c:	1885883a 	add	r2,r3,r2
 4004430:	143af415 	stw	r16,-5168(r2)

                    /* A higher priority task may have just been resumed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 4004434:	e0bffd17 	ldw	r2,-12(fp)
 4004438:	10c00b17 	ldw	r3,44(r2)
 400443c:	d0a71317 	ldw	r2,-25524(gp)
 4004440:	10800b17 	ldw	r2,44(r2)
 4004444:	18800136 	bltu	r3,r2,400444c <vTaskResume+0x164>
                    {
                        /* This yield may not cause the task just resumed to run,
                         * but will leave the lists in the correct state for the
                         * next yield. */
                        taskYIELD_IF_USING_PREEMPTION();
 4004448:	003b683a 	trap	0
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
 400444c:	4005fd00 	call	4005fd0 <vTaskExitCritical>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
 4004450:	0001883a 	nop
 4004454:	e6fffe04 	addi	sp,fp,-8
 4004458:	dfc00317 	ldw	ra,12(sp)
 400445c:	df000217 	ldw	fp,8(sp)
 4004460:	dc400117 	ldw	r17,4(sp)
 4004464:	dc000017 	ldw	r16,0(sp)
 4004468:	dec00404 	addi	sp,sp,16
 400446c:	f800283a 	ret

04004470 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

    BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
    {
 4004470:	defff704 	addi	sp,sp,-36
 4004474:	dfc00815 	stw	ra,32(sp)
 4004478:	df000715 	stw	fp,28(sp)
 400447c:	dc400615 	stw	r17,24(sp)
 4004480:	dc000515 	stw	r16,20(sp)
 4004484:	df000704 	addi	fp,sp,28
 4004488:	e13ff915 	stw	r4,-28(fp)
        BaseType_t xYieldRequired = pdFALSE;
 400448c:	e03ffd15 	stw	zero,-12(fp)
        TCB_t * const pxTCB = xTaskToResume;
 4004490:	e0bff917 	ldw	r2,-28(fp)
 4004494:	e0bffc15 	stw	r2,-16(fp)
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4004498:	e03ffb15 	stw	zero,-20(fp)
        {
            if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 400449c:	e13ffc17 	ldw	r4,-16(fp)
 40044a0:	400427c0 	call	400427c <prvTaskIsTaskSuspended>
 40044a4:	10005326 	beq	r2,zero,40045f4 <xTaskResumeFromISR+0x184>
            {
                traceTASK_RESUME_FROM_ISR( pxTCB );

                /* Check the ready lists can be accessed. */
                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 40044a8:	d0a72117 	ldw	r2,-25468(gp)
 40044ac:	10004b1e 	bne	r2,zero,40045dc <xTaskResumeFromISR+0x16c>
                {
                    /* Ready lists can be accessed so move the task from the
                     * suspended list to the ready list directly. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 40044b0:	e0bffc17 	ldw	r2,-16(fp)
 40044b4:	10c00b17 	ldw	r3,44(r2)
 40044b8:	d0a71317 	ldw	r2,-25524(gp)
 40044bc:	10800b17 	ldw	r2,44(r2)
 40044c0:	18800436 	bltu	r3,r2,40044d4 <xTaskResumeFromISR+0x64>
                    {
                        xYieldRequired = pdTRUE;
 40044c4:	00800044 	movi	r2,1
 40044c8:	e0bffd15 	stw	r2,-12(fp)

                        /* Mark that a yield is pending in case the user is not
                         * using the return value to initiate a context switch
                         * from the ISR using portYIELD_FROM_ISR. */
                        xYieldPending = pdTRUE;
 40044cc:	00800044 	movi	r2,1
 40044d0:	d0a71c15 	stw	r2,-25488(gp)
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 40044d4:	e0bffc17 	ldw	r2,-16(fp)
 40044d8:	10800104 	addi	r2,r2,4
 40044dc:	1009883a 	mov	r4,r2
 40044e0:	4000c980 	call	4000c98 <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
 40044e4:	e0bffc17 	ldw	r2,-16(fp)
 40044e8:	10800b17 	ldw	r2,44(r2)
 40044ec:	d0e71917 	ldw	r3,-25500(gp)
 40044f0:	1880032e 	bgeu	r3,r2,4004500 <xTaskResumeFromISR+0x90>
 40044f4:	e0bffc17 	ldw	r2,-16(fp)
 40044f8:	10800b17 	ldw	r2,44(r2)
 40044fc:	d0a71915 	stw	r2,-25500(gp)
 4004500:	e0bffc17 	ldw	r2,-16(fp)
 4004504:	10800b17 	ldw	r2,44(r2)
 4004508:	01400504 	movi	r5,20
 400450c:	1009883a 	mov	r4,r2
 4004510:	40075a40 	call	40075a4 <__mulsi3>
 4004514:	1007883a 	mov	r3,r2
 4004518:	008120b4 	movhi	r2,1154
 400451c:	1885883a 	add	r2,r3,r2
 4004520:	10baf517 	ldw	r2,-5164(r2)
 4004524:	e0bffa15 	stw	r2,-24(fp)
 4004528:	e0bffc17 	ldw	r2,-16(fp)
 400452c:	e0fffa17 	ldw	r3,-24(fp)
 4004530:	10c00215 	stw	r3,8(r2)
 4004534:	e0bffa17 	ldw	r2,-24(fp)
 4004538:	10c00217 	ldw	r3,8(r2)
 400453c:	e0bffc17 	ldw	r2,-16(fp)
 4004540:	10c00315 	stw	r3,12(r2)
 4004544:	e0bffa17 	ldw	r2,-24(fp)
 4004548:	10800217 	ldw	r2,8(r2)
 400454c:	e0fffc17 	ldw	r3,-16(fp)
 4004550:	18c00104 	addi	r3,r3,4
 4004554:	10c00115 	stw	r3,4(r2)
 4004558:	e0bffc17 	ldw	r2,-16(fp)
 400455c:	10c00104 	addi	r3,r2,4
 4004560:	e0bffa17 	ldw	r2,-24(fp)
 4004564:	10c00215 	stw	r3,8(r2)
 4004568:	e0bffc17 	ldw	r2,-16(fp)
 400456c:	10800b17 	ldw	r2,44(r2)
 4004570:	01400504 	movi	r5,20
 4004574:	1009883a 	mov	r4,r2
 4004578:	40075a40 	call	40075a4 <__mulsi3>
 400457c:	1007883a 	mov	r3,r2
 4004580:	008120b4 	movhi	r2,1154
 4004584:	10baf404 	addi	r2,r2,-5168
 4004588:	1887883a 	add	r3,r3,r2
 400458c:	e0bffc17 	ldw	r2,-16(fp)
 4004590:	10c00515 	stw	r3,20(r2)
 4004594:	e0bffc17 	ldw	r2,-16(fp)
 4004598:	14400b17 	ldw	r17,44(r2)
 400459c:	01400504 	movi	r5,20
 40045a0:	8809883a 	mov	r4,r17
 40045a4:	40075a40 	call	40075a4 <__mulsi3>
 40045a8:	1007883a 	mov	r3,r2
 40045ac:	008120b4 	movhi	r2,1154
 40045b0:	1885883a 	add	r2,r3,r2
 40045b4:	10baf417 	ldw	r2,-5168(r2)
 40045b8:	14000044 	addi	r16,r2,1
 40045bc:	01400504 	movi	r5,20
 40045c0:	8809883a 	mov	r4,r17
 40045c4:	40075a40 	call	40075a4 <__mulsi3>
 40045c8:	1007883a 	mov	r3,r2
 40045cc:	008120b4 	movhi	r2,1154
 40045d0:	1885883a 	add	r2,r3,r2
 40045d4:	143af415 	stw	r16,-5168(r2)
 40045d8:	00000606 	br	40045f4 <xTaskResumeFromISR+0x184>
                else
                {
                    /* The delayed or ready lists cannot be accessed so the task
                     * is held in the pending ready list until the scheduler is
                     * unsuspended. */
                    vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 40045dc:	e0bffc17 	ldw	r2,-16(fp)
 40045e0:	10800604 	addi	r2,r2,24
 40045e4:	100b883a 	mov	r5,r2
 40045e8:	010120b4 	movhi	r4,1154
 40045ec:	213b1704 	addi	r4,r4,-5028
 40045f0:	4000b340 	call	4000b34 <vListInsertEnd>
                mtCOVERAGE_TEST_MARKER();
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xYieldRequired;
 40045f4:	e0bffd17 	ldw	r2,-12(fp)
    }
 40045f8:	e6fffe04 	addi	sp,fp,-8
 40045fc:	dfc00317 	ldw	ra,12(sp)
 4004600:	df000217 	ldw	fp,8(sp)
 4004604:	dc400117 	ldw	r17,4(sp)
 4004608:	dc000017 	ldw	r16,0(sp)
 400460c:	dec00404 	addi	sp,sp,16
 4004610:	f800283a 	ret

04004614 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 4004614:	defffa04 	addi	sp,sp,-24
 4004618:	dfc00515 	stw	ra,20(sp)
 400461c:	df000415 	stw	fp,16(sp)
 4004620:	df000404 	addi	fp,sp,16
        }
    }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
    {
        /* The Idle task is being created using dynamically allocated RAM. */
        xReturn = xTaskCreate( prvIdleTask,
 4004624:	d0a72004 	addi	r2,gp,-25472
 4004628:	d8800115 	stw	r2,4(sp)
 400462c:	d8000015 	stw	zero,0(sp)
 4004630:	000f883a 	mov	r7,zero
 4004634:	01810004 	movi	r6,1024
 4004638:	014100b4 	movhi	r5,1026
 400463c:	296af204 	addi	r5,r5,-21560
 4004640:	01010034 	movhi	r4,1024
 4004644:	2115b904 	addi	r4,r4,22244
 4004648:	40037b40 	call	40037b4 <xTaskCreate>
 400464c:	e0bfff15 	stw	r2,-4(fp)
            mtCOVERAGE_TEST_MARKER();
        }
    }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
 4004650:	e0bfff17 	ldw	r2,-4(fp)
 4004654:	10800058 	cmpnei	r2,r2,1
 4004658:	10000c1e 	bne	r2,zero,400468c <vTaskStartScheduler+0x78>
  NIOS2_READ_STATUS (context);
 400465c:	0005303a 	rdctl	r2,status
 4004660:	e0bffe15 	stw	r2,-8(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 4004664:	e0fffe17 	ldw	r3,-8(fp)
 4004668:	00bfff84 	movi	r2,-2
 400466c:	1884703a 	and	r2,r3,r2
 4004670:	1001703a 	wrctl	status,r2
             * block specific to the task that will run first. */
            configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );
        }
        #endif

        xNextTaskUnblockTime = portMAX_DELAY;
 4004674:	00bfffc4 	movi	r2,-1
 4004678:	d0a71f15 	stw	r2,-25476(gp)
        xSchedulerRunning = pdTRUE;
 400467c:	00800044 	movi	r2,1
 4004680:	d0a71a15 	stw	r2,-25496(gp)
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 4004684:	d0271815 	stw	zero,-25504(gp)

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        xPortStartScheduler();
 4004688:	4000e3c0 	call	4000e3c <xPortStartScheduler>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
 400468c:	d0a00017 	ldw	r2,-32768(gp)
}
 4004690:	0001883a 	nop
 4004694:	e037883a 	mov	sp,fp
 4004698:	dfc00117 	ldw	ra,4(sp)
 400469c:	df000017 	ldw	fp,0(sp)
 40046a0:	dec00204 	addi	sp,sp,8
 40046a4:	f800283a 	ret

040046a8 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
 40046a8:	defffd04 	addi	sp,sp,-12
 40046ac:	dfc00215 	stw	ra,8(sp)
 40046b0:	df000115 	stw	fp,4(sp)
 40046b4:	df000104 	addi	fp,sp,4
  NIOS2_READ_STATUS (context);
 40046b8:	0005303a 	rdctl	r2,status
 40046bc:	e0bfff15 	stw	r2,-4(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 40046c0:	e0ffff17 	ldw	r3,-4(fp)
 40046c4:	00bfff84 	movi	r2,-2
 40046c8:	1884703a 	and	r2,r3,r2
 40046cc:	1001703a 	wrctl	status,r2
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    xSchedulerRunning = pdFALSE;
 40046d0:	d0271a15 	stw	zero,-25496(gp)
    vPortEndScheduler();
 40046d4:	4000e740 	call	4000e74 <vPortEndScheduler>
}
 40046d8:	0001883a 	nop
 40046dc:	e037883a 	mov	sp,fp
 40046e0:	dfc00117 	ldw	ra,4(sp)
 40046e4:	df000017 	ldw	fp,0(sp)
 40046e8:	dec00204 	addi	sp,sp,8
 40046ec:	f800283a 	ret

040046f0 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
 40046f0:	deffff04 	addi	sp,sp,-4
 40046f4:	df000015 	stw	fp,0(sp)
 40046f8:	d839883a 	mov	fp,sp
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
 40046fc:	d0a72117 	ldw	r2,-25468(gp)
 4004700:	10800044 	addi	r2,r2,1
 4004704:	d0a72115 	stw	r2,-25468(gp)

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
 4004708:	0001883a 	nop
 400470c:	e037883a 	mov	sp,fp
 4004710:	df000017 	ldw	fp,0(sp)
 4004714:	dec00104 	addi	sp,sp,4
 4004718:	f800283a 	ret

0400471c <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 400471c:	defff604 	addi	sp,sp,-40
 4004720:	dfc00915 	stw	ra,36(sp)
 4004724:	df000815 	stw	fp,32(sp)
 4004728:	dc400715 	stw	r17,28(sp)
 400472c:	dc000615 	stw	r16,24(sp)
 4004730:	df000804 	addi	fp,sp,32
    TCB_t * pxTCB = NULL;
 4004734:	e03ffd15 	stw	zero,-12(fp)
    BaseType_t xAlreadyYielded = pdFALSE;
 4004738:	e03ffc15 	stw	zero,-16(fp)
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
 400473c:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
    {
        --uxSchedulerSuspended;
 4004740:	d0a72117 	ldw	r2,-25468(gp)
 4004744:	10bfffc4 	addi	r2,r2,-1
 4004748:	d0a72115 	stw	r2,-25468(gp)

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 400474c:	d0a72117 	ldw	r2,-25468(gp)
 4004750:	10009e1e 	bne	r2,zero,40049cc <xTaskResumeAll+0x2b0>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 4004754:	d0a71717 	ldw	r2,-25508(gp)
 4004758:	10009c26 	beq	r2,zero,40049cc <xTaskResumeAll+0x2b0>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 400475c:	00008206 	br	4004968 <xTaskResumeAll+0x24c>
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 4004760:	008120b4 	movhi	r2,1154
 4004764:	10bb1a17 	ldw	r2,-5016(r2)
 4004768:	10800317 	ldw	r2,12(r2)
 400476c:	e0bffd15 	stw	r2,-12(fp)
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
 4004770:	e0bffd17 	ldw	r2,-12(fp)
 4004774:	10800a17 	ldw	r2,40(r2)
 4004778:	e0bffa15 	stw	r2,-24(fp)
 400477c:	e0bffd17 	ldw	r2,-12(fp)
 4004780:	10800717 	ldw	r2,28(r2)
 4004784:	e0fffd17 	ldw	r3,-12(fp)
 4004788:	18c00817 	ldw	r3,32(r3)
 400478c:	10c00215 	stw	r3,8(r2)
 4004790:	e0bffd17 	ldw	r2,-12(fp)
 4004794:	10800817 	ldw	r2,32(r2)
 4004798:	e0fffd17 	ldw	r3,-12(fp)
 400479c:	18c00717 	ldw	r3,28(r3)
 40047a0:	10c00115 	stw	r3,4(r2)
 40047a4:	e0bffa17 	ldw	r2,-24(fp)
 40047a8:	10c00117 	ldw	r3,4(r2)
 40047ac:	e0bffd17 	ldw	r2,-12(fp)
 40047b0:	10800604 	addi	r2,r2,24
 40047b4:	1880041e 	bne	r3,r2,40047c8 <xTaskResumeAll+0xac>
 40047b8:	e0bffd17 	ldw	r2,-12(fp)
 40047bc:	10c00817 	ldw	r3,32(r2)
 40047c0:	e0bffa17 	ldw	r2,-24(fp)
 40047c4:	10c00115 	stw	r3,4(r2)
 40047c8:	e0bffd17 	ldw	r2,-12(fp)
 40047cc:	10000a15 	stw	zero,40(r2)
 40047d0:	e0bffa17 	ldw	r2,-24(fp)
 40047d4:	10800017 	ldw	r2,0(r2)
 40047d8:	10ffffc4 	addi	r3,r2,-1
 40047dc:	e0bffa17 	ldw	r2,-24(fp)
 40047e0:	10c00015 	stw	r3,0(r2)
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 40047e4:	e0bffd17 	ldw	r2,-12(fp)
 40047e8:	10800517 	ldw	r2,20(r2)
 40047ec:	e0bff915 	stw	r2,-28(fp)
 40047f0:	e0bffd17 	ldw	r2,-12(fp)
 40047f4:	10800217 	ldw	r2,8(r2)
 40047f8:	e0fffd17 	ldw	r3,-12(fp)
 40047fc:	18c00317 	ldw	r3,12(r3)
 4004800:	10c00215 	stw	r3,8(r2)
 4004804:	e0bffd17 	ldw	r2,-12(fp)
 4004808:	10800317 	ldw	r2,12(r2)
 400480c:	e0fffd17 	ldw	r3,-12(fp)
 4004810:	18c00217 	ldw	r3,8(r3)
 4004814:	10c00115 	stw	r3,4(r2)
 4004818:	e0bff917 	ldw	r2,-28(fp)
 400481c:	10c00117 	ldw	r3,4(r2)
 4004820:	e0bffd17 	ldw	r2,-12(fp)
 4004824:	10800104 	addi	r2,r2,4
 4004828:	1880041e 	bne	r3,r2,400483c <xTaskResumeAll+0x120>
 400482c:	e0bffd17 	ldw	r2,-12(fp)
 4004830:	10c00317 	ldw	r3,12(r2)
 4004834:	e0bff917 	ldw	r2,-28(fp)
 4004838:	10c00115 	stw	r3,4(r2)
 400483c:	e0bffd17 	ldw	r2,-12(fp)
 4004840:	10000515 	stw	zero,20(r2)
 4004844:	e0bff917 	ldw	r2,-28(fp)
 4004848:	10800017 	ldw	r2,0(r2)
 400484c:	10ffffc4 	addi	r3,r2,-1
 4004850:	e0bff917 	ldw	r2,-28(fp)
 4004854:	10c00015 	stw	r3,0(r2)
                    prvAddTaskToReadyList( pxTCB );
 4004858:	e0bffd17 	ldw	r2,-12(fp)
 400485c:	10800b17 	ldw	r2,44(r2)
 4004860:	d0e71917 	ldw	r3,-25500(gp)
 4004864:	1880032e 	bgeu	r3,r2,4004874 <xTaskResumeAll+0x158>
 4004868:	e0bffd17 	ldw	r2,-12(fp)
 400486c:	10800b17 	ldw	r2,44(r2)
 4004870:	d0a71915 	stw	r2,-25500(gp)
 4004874:	e0bffd17 	ldw	r2,-12(fp)
 4004878:	10800b17 	ldw	r2,44(r2)
 400487c:	01400504 	movi	r5,20
 4004880:	1009883a 	mov	r4,r2
 4004884:	40075a40 	call	40075a4 <__mulsi3>
 4004888:	1007883a 	mov	r3,r2
 400488c:	008120b4 	movhi	r2,1154
 4004890:	1885883a 	add	r2,r3,r2
 4004894:	10baf517 	ldw	r2,-5164(r2)
 4004898:	e0bff815 	stw	r2,-32(fp)
 400489c:	e0bffd17 	ldw	r2,-12(fp)
 40048a0:	e0fff817 	ldw	r3,-32(fp)
 40048a4:	10c00215 	stw	r3,8(r2)
 40048a8:	e0bff817 	ldw	r2,-32(fp)
 40048ac:	10c00217 	ldw	r3,8(r2)
 40048b0:	e0bffd17 	ldw	r2,-12(fp)
 40048b4:	10c00315 	stw	r3,12(r2)
 40048b8:	e0bff817 	ldw	r2,-32(fp)
 40048bc:	10800217 	ldw	r2,8(r2)
 40048c0:	e0fffd17 	ldw	r3,-12(fp)
 40048c4:	18c00104 	addi	r3,r3,4
 40048c8:	10c00115 	stw	r3,4(r2)
 40048cc:	e0bffd17 	ldw	r2,-12(fp)
 40048d0:	10c00104 	addi	r3,r2,4
 40048d4:	e0bff817 	ldw	r2,-32(fp)
 40048d8:	10c00215 	stw	r3,8(r2)
 40048dc:	e0bffd17 	ldw	r2,-12(fp)
 40048e0:	10800b17 	ldw	r2,44(r2)
 40048e4:	01400504 	movi	r5,20
 40048e8:	1009883a 	mov	r4,r2
 40048ec:	40075a40 	call	40075a4 <__mulsi3>
 40048f0:	1007883a 	mov	r3,r2
 40048f4:	008120b4 	movhi	r2,1154
 40048f8:	10baf404 	addi	r2,r2,-5168
 40048fc:	1887883a 	add	r3,r3,r2
 4004900:	e0bffd17 	ldw	r2,-12(fp)
 4004904:	10c00515 	stw	r3,20(r2)
 4004908:	e0bffd17 	ldw	r2,-12(fp)
 400490c:	14400b17 	ldw	r17,44(r2)
 4004910:	01400504 	movi	r5,20
 4004914:	8809883a 	mov	r4,r17
 4004918:	40075a40 	call	40075a4 <__mulsi3>
 400491c:	1007883a 	mov	r3,r2
 4004920:	008120b4 	movhi	r2,1154
 4004924:	1885883a 	add	r2,r3,r2
 4004928:	10baf417 	ldw	r2,-5168(r2)
 400492c:	14000044 	addi	r16,r2,1
 4004930:	01400504 	movi	r5,20
 4004934:	8809883a 	mov	r4,r17
 4004938:	40075a40 	call	40075a4 <__mulsi3>
 400493c:	1007883a 	mov	r3,r2
 4004940:	008120b4 	movhi	r2,1154
 4004944:	1885883a 	add	r2,r3,r2
 4004948:	143af415 	stw	r16,-5168(r2)

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 400494c:	e0bffd17 	ldw	r2,-12(fp)
 4004950:	10c00b17 	ldw	r3,44(r2)
 4004954:	d0a71317 	ldw	r2,-25524(gp)
 4004958:	10800b17 	ldw	r2,44(r2)
 400495c:	18800236 	bltu	r3,r2,4004968 <xTaskResumeAll+0x24c>
                    {
                        xYieldPending = pdTRUE;
 4004960:	00800044 	movi	r2,1
 4004964:	d0a71c15 	stw	r2,-25488(gp)
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 4004968:	008120b4 	movhi	r2,1154
 400496c:	10bb1717 	ldw	r2,-5028(r2)
 4004970:	103f7b1e 	bne	r2,zero,4004760 <xTaskResumeAll+0x44>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
 4004974:	e0bffd17 	ldw	r2,-12(fp)
 4004978:	10000126 	beq	r2,zero,4004980 <xTaskResumeAll+0x264>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
 400497c:	40059480 	call	4005948 <prvResetNextTaskUnblockTime>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
 4004980:	d0a71b17 	ldw	r2,-25492(gp)
 4004984:	e0bffb15 	stw	r2,-20(fp)

                    if( xPendedCounts > ( TickType_t ) 0U )
 4004988:	e0bffb17 	ldw	r2,-20(fp)
 400498c:	10000a26 	beq	r2,zero,40049b8 <xTaskResumeAll+0x29c>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
 4004990:	4004af40 	call	4004af4 <xTaskIncrementTick>
 4004994:	10000226 	beq	r2,zero,40049a0 <xTaskResumeAll+0x284>
                            {
                                xYieldPending = pdTRUE;
 4004998:	00800044 	movi	r2,1
 400499c:	d0a71c15 	stw	r2,-25488(gp)
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
 40049a0:	e0bffb17 	ldw	r2,-20(fp)
 40049a4:	10bfffc4 	addi	r2,r2,-1
 40049a8:	e0bffb15 	stw	r2,-20(fp)
                        } while( xPendedCounts > ( TickType_t ) 0U );
 40049ac:	e0bffb17 	ldw	r2,-20(fp)
 40049b0:	103ff71e 	bne	r2,zero,4004990 <xTaskResumeAll+0x274>

                        xPendedTicks = 0;
 40049b4:	d0271b15 	stw	zero,-25492(gp)
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
 40049b8:	d0a71c17 	ldw	r2,-25488(gp)
 40049bc:	10000326 	beq	r2,zero,40049cc <xTaskResumeAll+0x2b0>
                {
                    #if ( configUSE_PREEMPTION != 0 )
                    {
                        xAlreadyYielded = pdTRUE;
 40049c0:	00800044 	movi	r2,1
 40049c4:	e0bffc15 	stw	r2,-16(fp)
                    }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
 40049c8:	003b683a 	trap	0
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
 40049cc:	4005fd00 	call	4005fd0 <vTaskExitCritical>

    return xAlreadyYielded;
 40049d0:	e0bffc17 	ldw	r2,-16(fp)
}
 40049d4:	e6fffe04 	addi	sp,fp,-8
 40049d8:	dfc00317 	ldw	ra,12(sp)
 40049dc:	df000217 	ldw	fp,8(sp)
 40049e0:	dc400117 	ldw	r17,4(sp)
 40049e4:	dc000017 	ldw	r16,0(sp)
 40049e8:	dec00404 	addi	sp,sp,16
 40049ec:	f800283a 	ret

040049f0 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
 40049f0:	defffe04 	addi	sp,sp,-8
 40049f4:	df000115 	stw	fp,4(sp)
 40049f8:	df000104 	addi	fp,sp,4
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    {
        xTicks = xTickCount;
 40049fc:	d0a71817 	ldw	r2,-25504(gp)
 4004a00:	e0bfff15 	stw	r2,-4(fp)
    }
    portTICK_TYPE_EXIT_CRITICAL();

    return xTicks;
 4004a04:	e0bfff17 	ldw	r2,-4(fp)
}
 4004a08:	e037883a 	mov	sp,fp
 4004a0c:	df000017 	ldw	fp,0(sp)
 4004a10:	dec00104 	addi	sp,sp,4
 4004a14:	f800283a 	ret

04004a18 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
 4004a18:	defffd04 	addi	sp,sp,-12
 4004a1c:	df000215 	stw	fp,8(sp)
 4004a20:	df000204 	addi	fp,sp,8
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
 4004a24:	e03fff15 	stw	zero,-4(fp)
    {
        xReturn = xTickCount;
 4004a28:	d0a71817 	ldw	r2,-25504(gp)
 4004a2c:	e0bffe15 	stw	r2,-8(fp)
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 4004a30:	e0bffe17 	ldw	r2,-8(fp)
}
 4004a34:	e037883a 	mov	sp,fp
 4004a38:	df000017 	ldw	fp,0(sp)
 4004a3c:	dec00104 	addi	sp,sp,4
 4004a40:	f800283a 	ret

04004a44 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
 4004a44:	deffff04 	addi	sp,sp,-4
 4004a48:	df000015 	stw	fp,0(sp)
 4004a4c:	d839883a 	mov	fp,sp
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
 4004a50:	d0a71717 	ldw	r2,-25508(gp)
}
 4004a54:	e037883a 	mov	sp,fp
 4004a58:	df000017 	ldw	fp,0(sp)
 4004a5c:	dec00104 	addi	sp,sp,4
 4004a60:	f800283a 	ret

04004a64 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char * pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
 4004a64:	defffd04 	addi	sp,sp,-12
 4004a68:	df000215 	stw	fp,8(sp)
 4004a6c:	df000204 	addi	fp,sp,8
 4004a70:	e13ffe15 	stw	r4,-8(fp)
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 4004a74:	e0bffe17 	ldw	r2,-8(fp)
 4004a78:	1000021e 	bne	r2,zero,4004a84 <pcTaskGetName+0x20>
 4004a7c:	d0a71317 	ldw	r2,-25524(gp)
 4004a80:	00000106 	br	4004a88 <pcTaskGetName+0x24>
 4004a84:	e0bffe17 	ldw	r2,-8(fp)
 4004a88:	e0bfff15 	stw	r2,-4(fp)
    configASSERT( pxTCB );
    return &( pxTCB->pcTaskName[ 0 ] );
 4004a8c:	e0bfff17 	ldw	r2,-4(fp)
 4004a90:	10800d04 	addi	r2,r2,52
}
 4004a94:	e037883a 	mov	sp,fp
 4004a98:	df000017 	ldw	fp,0(sp)
 4004a9c:	dec00104 	addi	sp,sp,4
 4004aa0:	f800283a 	ret

04004aa4 <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
 4004aa4:	defffc04 	addi	sp,sp,-16
 4004aa8:	dfc00315 	stw	ra,12(sp)
 4004aac:	df000215 	stw	fp,8(sp)
 4004ab0:	df000204 	addi	fp,sp,8
 4004ab4:	e13ffe15 	stw	r4,-8(fp)
     * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
    configASSERT( uxSchedulerSuspended == 0 );

    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();
 4004ab8:	40046f00 	call	40046f0 <vTaskSuspendAll>

    /* Prevent the tick interrupt modifying xPendedTicks simultaneously. */
    taskENTER_CRITICAL();
 4004abc:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
    {
        xPendedTicks += xTicksToCatchUp;
 4004ac0:	d0e71b17 	ldw	r3,-25492(gp)
 4004ac4:	e0bffe17 	ldw	r2,-8(fp)
 4004ac8:	1885883a 	add	r2,r3,r2
 4004acc:	d0a71b15 	stw	r2,-25492(gp)
    }
    taskEXIT_CRITICAL();
 4004ad0:	4005fd00 	call	4005fd0 <vTaskExitCritical>
    xYieldOccurred = xTaskResumeAll();
 4004ad4:	400471c0 	call	400471c <xTaskResumeAll>
 4004ad8:	e0bfff15 	stw	r2,-4(fp)

    return xYieldOccurred;
 4004adc:	e0bfff17 	ldw	r2,-4(fp)
}
 4004ae0:	e037883a 	mov	sp,fp
 4004ae4:	dfc00117 	ldw	ra,4(sp)
 4004ae8:	df000017 	ldw	fp,0(sp)
 4004aec:	dec00204 	addi	sp,sp,8
 4004af0:	f800283a 	ret

04004af4 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 4004af4:	defff404 	addi	sp,sp,-48
 4004af8:	dfc00b15 	stw	ra,44(sp)
 4004afc:	df000a15 	stw	fp,40(sp)
 4004b00:	dc400915 	stw	r17,36(sp)
 4004b04:	dc000815 	stw	r16,32(sp)
 4004b08:	df000a04 	addi	fp,sp,40
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
 4004b0c:	e03ffd15 	stw	zero,-12(fp)
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 4004b10:	d0a72117 	ldw	r2,-25468(gp)
 4004b14:	1000bb1e 	bne	r2,zero,4004e04 <xTaskIncrementTick+0x310>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 4004b18:	d0a71817 	ldw	r2,-25504(gp)
 4004b1c:	10800044 	addi	r2,r2,1
 4004b20:	e0bffc15 	stw	r2,-16(fp)

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
 4004b24:	e0bffc17 	ldw	r2,-16(fp)
 4004b28:	d0a71815 	stw	r2,-25504(gp)

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 4004b2c:	e0bffc17 	ldw	r2,-16(fp)
 4004b30:	10000a1e 	bne	r2,zero,4004b5c <xTaskIncrementTick+0x68>
        {
            taskSWITCH_DELAYED_LISTS();
 4004b34:	d0a71417 	ldw	r2,-25520(gp)
 4004b38:	e0bffb15 	stw	r2,-20(fp)
 4004b3c:	d0a71517 	ldw	r2,-25516(gp)
 4004b40:	d0a71415 	stw	r2,-25520(gp)
 4004b44:	e0bffb17 	ldw	r2,-20(fp)
 4004b48:	d0a71515 	stw	r2,-25516(gp)
 4004b4c:	d0a71d17 	ldw	r2,-25484(gp)
 4004b50:	10800044 	addi	r2,r2,1
 4004b54:	d0a71d15 	stw	r2,-25484(gp)
 4004b58:	40059480 	call	4005948 <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
 4004b5c:	d0a71f17 	ldw	r2,-25476(gp)
 4004b60:	e0fffc17 	ldw	r3,-16(fp)
 4004b64:	18809536 	bltu	r3,r2,4004dbc <xTaskIncrementTick+0x2c8>
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 4004b68:	d0a71417 	ldw	r2,-25520(gp)
 4004b6c:	10800017 	ldw	r2,0(r2)
 4004b70:	1000031e 	bne	r2,zero,4004b80 <xTaskIncrementTick+0x8c>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 4004b74:	00bfffc4 	movi	r2,-1
 4004b78:	d0a71f15 	stw	r2,-25476(gp)
                    break;
 4004b7c:	00008f06 	br	4004dbc <xTaskIncrementTick+0x2c8>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 4004b80:	d0a71417 	ldw	r2,-25520(gp)
 4004b84:	10800317 	ldw	r2,12(r2)
 4004b88:	10800317 	ldw	r2,12(r2)
 4004b8c:	e0bffa15 	stw	r2,-24(fp)
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 4004b90:	e0bffa17 	ldw	r2,-24(fp)
 4004b94:	10800117 	ldw	r2,4(r2)
 4004b98:	e0bff915 	stw	r2,-28(fp)

                    if( xConstTickCount < xItemValue )
 4004b9c:	e0fffc17 	ldw	r3,-16(fp)
 4004ba0:	e0bff917 	ldw	r2,-28(fp)
 4004ba4:	1880032e 	bgeu	r3,r2,4004bb4 <xTaskIncrementTick+0xc0>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
 4004ba8:	e0bff917 	ldw	r2,-28(fp)
 4004bac:	d0a71f15 	stw	r2,-25476(gp)
                        break; /*lint !e9011 Code structure here is deemed easier to understand with multiple breaks. */
 4004bb0:	00008206 	br	4004dbc <xTaskIncrementTick+0x2c8>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 4004bb4:	e0bffa17 	ldw	r2,-24(fp)
 4004bb8:	10800517 	ldw	r2,20(r2)
 4004bbc:	e0bff815 	stw	r2,-32(fp)
 4004bc0:	e0bffa17 	ldw	r2,-24(fp)
 4004bc4:	10800217 	ldw	r2,8(r2)
 4004bc8:	e0fffa17 	ldw	r3,-24(fp)
 4004bcc:	18c00317 	ldw	r3,12(r3)
 4004bd0:	10c00215 	stw	r3,8(r2)
 4004bd4:	e0bffa17 	ldw	r2,-24(fp)
 4004bd8:	10800317 	ldw	r2,12(r2)
 4004bdc:	e0fffa17 	ldw	r3,-24(fp)
 4004be0:	18c00217 	ldw	r3,8(r3)
 4004be4:	10c00115 	stw	r3,4(r2)
 4004be8:	e0bff817 	ldw	r2,-32(fp)
 4004bec:	10c00117 	ldw	r3,4(r2)
 4004bf0:	e0bffa17 	ldw	r2,-24(fp)
 4004bf4:	10800104 	addi	r2,r2,4
 4004bf8:	1880041e 	bne	r3,r2,4004c0c <xTaskIncrementTick+0x118>
 4004bfc:	e0bffa17 	ldw	r2,-24(fp)
 4004c00:	10c00317 	ldw	r3,12(r2)
 4004c04:	e0bff817 	ldw	r2,-32(fp)
 4004c08:	10c00115 	stw	r3,4(r2)
 4004c0c:	e0bffa17 	ldw	r2,-24(fp)
 4004c10:	10000515 	stw	zero,20(r2)
 4004c14:	e0bff817 	ldw	r2,-32(fp)
 4004c18:	10800017 	ldw	r2,0(r2)
 4004c1c:	10ffffc4 	addi	r3,r2,-1
 4004c20:	e0bff817 	ldw	r2,-32(fp)
 4004c24:	10c00015 	stw	r3,0(r2)

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 4004c28:	e0bffa17 	ldw	r2,-24(fp)
 4004c2c:	10800a17 	ldw	r2,40(r2)
 4004c30:	10001d26 	beq	r2,zero,4004ca8 <xTaskIncrementTick+0x1b4>
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
 4004c34:	e0bffa17 	ldw	r2,-24(fp)
 4004c38:	10800a17 	ldw	r2,40(r2)
 4004c3c:	e0bff715 	stw	r2,-36(fp)
 4004c40:	e0bffa17 	ldw	r2,-24(fp)
 4004c44:	10800717 	ldw	r2,28(r2)
 4004c48:	e0fffa17 	ldw	r3,-24(fp)
 4004c4c:	18c00817 	ldw	r3,32(r3)
 4004c50:	10c00215 	stw	r3,8(r2)
 4004c54:	e0bffa17 	ldw	r2,-24(fp)
 4004c58:	10800817 	ldw	r2,32(r2)
 4004c5c:	e0fffa17 	ldw	r3,-24(fp)
 4004c60:	18c00717 	ldw	r3,28(r3)
 4004c64:	10c00115 	stw	r3,4(r2)
 4004c68:	e0bff717 	ldw	r2,-36(fp)
 4004c6c:	10c00117 	ldw	r3,4(r2)
 4004c70:	e0bffa17 	ldw	r2,-24(fp)
 4004c74:	10800604 	addi	r2,r2,24
 4004c78:	1880041e 	bne	r3,r2,4004c8c <xTaskIncrementTick+0x198>
 4004c7c:	e0bffa17 	ldw	r2,-24(fp)
 4004c80:	10c00817 	ldw	r3,32(r2)
 4004c84:	e0bff717 	ldw	r2,-36(fp)
 4004c88:	10c00115 	stw	r3,4(r2)
 4004c8c:	e0bffa17 	ldw	r2,-24(fp)
 4004c90:	10000a15 	stw	zero,40(r2)
 4004c94:	e0bff717 	ldw	r2,-36(fp)
 4004c98:	10800017 	ldw	r2,0(r2)
 4004c9c:	10ffffc4 	addi	r3,r2,-1
 4004ca0:	e0bff717 	ldw	r2,-36(fp)
 4004ca4:	10c00015 	stw	r3,0(r2)
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
 4004ca8:	e0bffa17 	ldw	r2,-24(fp)
 4004cac:	10800b17 	ldw	r2,44(r2)
 4004cb0:	d0e71917 	ldw	r3,-25500(gp)
 4004cb4:	1880032e 	bgeu	r3,r2,4004cc4 <xTaskIncrementTick+0x1d0>
 4004cb8:	e0bffa17 	ldw	r2,-24(fp)
 4004cbc:	10800b17 	ldw	r2,44(r2)
 4004cc0:	d0a71915 	stw	r2,-25500(gp)
 4004cc4:	e0bffa17 	ldw	r2,-24(fp)
 4004cc8:	10800b17 	ldw	r2,44(r2)
 4004ccc:	01400504 	movi	r5,20
 4004cd0:	1009883a 	mov	r4,r2
 4004cd4:	40075a40 	call	40075a4 <__mulsi3>
 4004cd8:	1007883a 	mov	r3,r2
 4004cdc:	008120b4 	movhi	r2,1154
 4004ce0:	1885883a 	add	r2,r3,r2
 4004ce4:	10baf517 	ldw	r2,-5164(r2)
 4004ce8:	e0bff615 	stw	r2,-40(fp)
 4004cec:	e0bffa17 	ldw	r2,-24(fp)
 4004cf0:	e0fff617 	ldw	r3,-40(fp)
 4004cf4:	10c00215 	stw	r3,8(r2)
 4004cf8:	e0bff617 	ldw	r2,-40(fp)
 4004cfc:	10c00217 	ldw	r3,8(r2)
 4004d00:	e0bffa17 	ldw	r2,-24(fp)
 4004d04:	10c00315 	stw	r3,12(r2)
 4004d08:	e0bff617 	ldw	r2,-40(fp)
 4004d0c:	10800217 	ldw	r2,8(r2)
 4004d10:	e0fffa17 	ldw	r3,-24(fp)
 4004d14:	18c00104 	addi	r3,r3,4
 4004d18:	10c00115 	stw	r3,4(r2)
 4004d1c:	e0bffa17 	ldw	r2,-24(fp)
 4004d20:	10c00104 	addi	r3,r2,4
 4004d24:	e0bff617 	ldw	r2,-40(fp)
 4004d28:	10c00215 	stw	r3,8(r2)
 4004d2c:	e0bffa17 	ldw	r2,-24(fp)
 4004d30:	10800b17 	ldw	r2,44(r2)
 4004d34:	01400504 	movi	r5,20
 4004d38:	1009883a 	mov	r4,r2
 4004d3c:	40075a40 	call	40075a4 <__mulsi3>
 4004d40:	1007883a 	mov	r3,r2
 4004d44:	008120b4 	movhi	r2,1154
 4004d48:	10baf404 	addi	r2,r2,-5168
 4004d4c:	1887883a 	add	r3,r3,r2
 4004d50:	e0bffa17 	ldw	r2,-24(fp)
 4004d54:	10c00515 	stw	r3,20(r2)
 4004d58:	e0bffa17 	ldw	r2,-24(fp)
 4004d5c:	14400b17 	ldw	r17,44(r2)
 4004d60:	01400504 	movi	r5,20
 4004d64:	8809883a 	mov	r4,r17
 4004d68:	40075a40 	call	40075a4 <__mulsi3>
 4004d6c:	1007883a 	mov	r3,r2
 4004d70:	008120b4 	movhi	r2,1154
 4004d74:	1885883a 	add	r2,r3,r2
 4004d78:	10baf417 	ldw	r2,-5168(r2)
 4004d7c:	14000044 	addi	r16,r2,1
 4004d80:	01400504 	movi	r5,20
 4004d84:	8809883a 	mov	r4,r17
 4004d88:	40075a40 	call	40075a4 <__mulsi3>
 4004d8c:	1007883a 	mov	r3,r2
 4004d90:	008120b4 	movhi	r2,1154
 4004d94:	1885883a 	add	r2,r3,r2
 4004d98:	143af415 	stw	r16,-5168(r2)
                         * task.
                         * The case of equal priority tasks sharing
                         * processing time (which happens when both
                         * preemption and time slicing are on) is
                         * handled below.*/
                        if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 4004d9c:	e0bffa17 	ldw	r2,-24(fp)
 4004da0:	10800b17 	ldw	r2,44(r2)
 4004da4:	d0e71317 	ldw	r3,-25524(gp)
 4004da8:	18c00b17 	ldw	r3,44(r3)
 4004dac:	18bf6e2e 	bgeu	r3,r2,4004b68 <xTaskIncrementTick+0x74>
                        {
                            xSwitchRequired = pdTRUE;
 4004db0:	00800044 	movi	r2,1
 4004db4:	e0bffd15 	stw	r2,-12(fp)
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 4004db8:	003f6b06 	br	4004b68 <xTaskIncrementTick+0x74>
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
        {
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 4004dbc:	d0a71317 	ldw	r2,-25524(gp)
 4004dc0:	10800b17 	ldw	r2,44(r2)
 4004dc4:	01400504 	movi	r5,20
 4004dc8:	1009883a 	mov	r4,r2
 4004dcc:	40075a40 	call	40075a4 <__mulsi3>
 4004dd0:	1007883a 	mov	r3,r2
 4004dd4:	008120b4 	movhi	r2,1154
 4004dd8:	1885883a 	add	r2,r3,r2
 4004ddc:	10baf417 	ldw	r2,-5168(r2)
 4004de0:	108000b0 	cmpltui	r2,r2,2
 4004de4:	1000021e 	bne	r2,zero,4004df0 <xTaskIncrementTick+0x2fc>
            {
                xSwitchRequired = pdTRUE;
 4004de8:	00800044 	movi	r2,1
 4004dec:	e0bffd15 	stw	r2,-12(fp)
        }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
        {
            if( xYieldPending != pdFALSE )
 4004df0:	d0a71c17 	ldw	r2,-25488(gp)
 4004df4:	10000626 	beq	r2,zero,4004e10 <xTaskIncrementTick+0x31c>
            {
                xSwitchRequired = pdTRUE;
 4004df8:	00800044 	movi	r2,1
 4004dfc:	e0bffd15 	stw	r2,-12(fp)
 4004e00:	00000306 	br	4004e10 <xTaskIncrementTick+0x31c>
        }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
 4004e04:	d0a71b17 	ldw	r2,-25492(gp)
 4004e08:	10800044 	addi	r2,r2,1
 4004e0c:	d0a71b15 	stw	r2,-25492(gp)
            vApplicationTickHook();
        }
        #endif
    }

    return xSwitchRequired;
 4004e10:	e0bffd17 	ldw	r2,-12(fp)
}
 4004e14:	e6fffe04 	addi	sp,fp,-8
 4004e18:	dfc00317 	ldw	ra,12(sp)
 4004e1c:	df000217 	ldw	fp,8(sp)
 4004e20:	dc400117 	ldw	r17,4(sp)
 4004e24:	dc000017 	ldw	r16,0(sp)
 4004e28:	dec00404 	addi	sp,sp,16
 4004e2c:	f800283a 	ret

04004e30 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 4004e30:	defffc04 	addi	sp,sp,-16
 4004e34:	dfc00315 	stw	ra,12(sp)
 4004e38:	df000215 	stw	fp,8(sp)
 4004e3c:	df000204 	addi	fp,sp,8
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 4004e40:	d0a72117 	ldw	r2,-25468(gp)
 4004e44:	10000326 	beq	r2,zero,4004e54 <vTaskSwitchContext+0x24>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
 4004e48:	00800044 	movi	r2,1
 4004e4c:	d0a71c15 	stw	r2,-25488(gp)
             * Block specific to this task. */
            configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );
        }
        #endif
    }
}
 4004e50:	00002d06 	br	4004f08 <vTaskSwitchContext+0xd8>
        xYieldPending = pdFALSE;
 4004e54:	d0271c15 	stw	zero,-25488(gp)
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 4004e58:	d0a71917 	ldw	r2,-25500(gp)
 4004e5c:	e0bfff15 	stw	r2,-4(fp)
 4004e60:	00000306 	br	4004e70 <vTaskSwitchContext+0x40>
 4004e64:	e0bfff17 	ldw	r2,-4(fp)
 4004e68:	10bfffc4 	addi	r2,r2,-1
 4004e6c:	e0bfff15 	stw	r2,-4(fp)
 4004e70:	e0bfff17 	ldw	r2,-4(fp)
 4004e74:	01400504 	movi	r5,20
 4004e78:	1009883a 	mov	r4,r2
 4004e7c:	40075a40 	call	40075a4 <__mulsi3>
 4004e80:	1007883a 	mov	r3,r2
 4004e84:	008120b4 	movhi	r2,1154
 4004e88:	1885883a 	add	r2,r3,r2
 4004e8c:	10baf417 	ldw	r2,-5168(r2)
 4004e90:	103ff426 	beq	r2,zero,4004e64 <vTaskSwitchContext+0x34>
 4004e94:	01400504 	movi	r5,20
 4004e98:	e13fff17 	ldw	r4,-4(fp)
 4004e9c:	40075a40 	call	40075a4 <__mulsi3>
 4004ea0:	1007883a 	mov	r3,r2
 4004ea4:	008120b4 	movhi	r2,1154
 4004ea8:	10baf404 	addi	r2,r2,-5168
 4004eac:	1885883a 	add	r2,r3,r2
 4004eb0:	e0bffe15 	stw	r2,-8(fp)
 4004eb4:	e0bffe17 	ldw	r2,-8(fp)
 4004eb8:	10800117 	ldw	r2,4(r2)
 4004ebc:	10c00117 	ldw	r3,4(r2)
 4004ec0:	e0bffe17 	ldw	r2,-8(fp)
 4004ec4:	10c00115 	stw	r3,4(r2)
 4004ec8:	e0bffe17 	ldw	r2,-8(fp)
 4004ecc:	10c00117 	ldw	r3,4(r2)
 4004ed0:	e0bffe17 	ldw	r2,-8(fp)
 4004ed4:	10800204 	addi	r2,r2,8
 4004ed8:	1880051e 	bne	r3,r2,4004ef0 <vTaskSwitchContext+0xc0>
 4004edc:	e0bffe17 	ldw	r2,-8(fp)
 4004ee0:	10800117 	ldw	r2,4(r2)
 4004ee4:	10c00117 	ldw	r3,4(r2)
 4004ee8:	e0bffe17 	ldw	r2,-8(fp)
 4004eec:	10c00115 	stw	r3,4(r2)
 4004ef0:	e0bffe17 	ldw	r2,-8(fp)
 4004ef4:	10800117 	ldw	r2,4(r2)
 4004ef8:	10800317 	ldw	r2,12(r2)
 4004efc:	d0a71315 	stw	r2,-25524(gp)
 4004f00:	e0bfff17 	ldw	r2,-4(fp)
 4004f04:	d0a71915 	stw	r2,-25500(gp)
}
 4004f08:	0001883a 	nop
 4004f0c:	e037883a 	mov	sp,fp
 4004f10:	dfc00117 	ldw	ra,4(sp)
 4004f14:	df000017 	ldw	fp,0(sp)
 4004f18:	dec00204 	addi	sp,sp,8
 4004f1c:	f800283a 	ret

04004f20 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
 4004f20:	defffc04 	addi	sp,sp,-16
 4004f24:	dfc00315 	stw	ra,12(sp)
 4004f28:	df000215 	stw	fp,8(sp)
 4004f2c:	df000204 	addi	fp,sp,8
 4004f30:	e13fff15 	stw	r4,-4(fp)
 4004f34:	e17ffe15 	stw	r5,-8(fp)
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 4004f38:	d0a71317 	ldw	r2,-25524(gp)
 4004f3c:	10800604 	addi	r2,r2,24
 4004f40:	100b883a 	mov	r5,r2
 4004f44:	e13fff17 	ldw	r4,-4(fp)
 4004f48:	4000bc00 	call	4000bc0 <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 4004f4c:	01400044 	movi	r5,1
 4004f50:	e13ffe17 	ldw	r4,-8(fp)
 4004f54:	4006e3c0 	call	4006e3c <prvAddCurrentTaskToDelayedList>
}
 4004f58:	0001883a 	nop
 4004f5c:	e037883a 	mov	sp,fp
 4004f60:	dfc00117 	ldw	ra,4(sp)
 4004f64:	df000017 	ldw	fp,0(sp)
 4004f68:	dec00204 	addi	sp,sp,8
 4004f6c:	f800283a 	ret

04004f70 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
 4004f70:	defffa04 	addi	sp,sp,-24
 4004f74:	dfc00515 	stw	ra,20(sp)
 4004f78:	df000415 	stw	fp,16(sp)
 4004f7c:	df000404 	addi	fp,sp,16
 4004f80:	e13ffe15 	stw	r4,-8(fp)
 4004f84:	e17ffd15 	stw	r5,-12(fp)
 4004f88:	e1bffc15 	stw	r6,-16(fp)
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 4004f8c:	d0a71317 	ldw	r2,-25524(gp)
 4004f90:	e0fffd17 	ldw	r3,-12(fp)
 4004f94:	18e00034 	orhi	r3,r3,32768
 4004f98:	10c00615 	stw	r3,24(r2)
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 4004f9c:	e0bffe17 	ldw	r2,-8(fp)
 4004fa0:	10800117 	ldw	r2,4(r2)
 4004fa4:	e0bfff15 	stw	r2,-4(fp)
 4004fa8:	d0a71317 	ldw	r2,-25524(gp)
 4004fac:	e0ffff17 	ldw	r3,-4(fp)
 4004fb0:	10c00715 	stw	r3,28(r2)
 4004fb4:	d0a71317 	ldw	r2,-25524(gp)
 4004fb8:	e0ffff17 	ldw	r3,-4(fp)
 4004fbc:	18c00217 	ldw	r3,8(r3)
 4004fc0:	10c00815 	stw	r3,32(r2)
 4004fc4:	d0e71317 	ldw	r3,-25524(gp)
 4004fc8:	e0bfff17 	ldw	r2,-4(fp)
 4004fcc:	10800217 	ldw	r2,8(r2)
 4004fd0:	18c00604 	addi	r3,r3,24
 4004fd4:	10c00115 	stw	r3,4(r2)
 4004fd8:	d0a71317 	ldw	r2,-25524(gp)
 4004fdc:	10c00604 	addi	r3,r2,24
 4004fe0:	e0bfff17 	ldw	r2,-4(fp)
 4004fe4:	10c00215 	stw	r3,8(r2)
 4004fe8:	d0a71317 	ldw	r2,-25524(gp)
 4004fec:	e0fffe17 	ldw	r3,-8(fp)
 4004ff0:	10c00a15 	stw	r3,40(r2)
 4004ff4:	e0bffe17 	ldw	r2,-8(fp)
 4004ff8:	10800017 	ldw	r2,0(r2)
 4004ffc:	10c00044 	addi	r3,r2,1
 4005000:	e0bffe17 	ldw	r2,-8(fp)
 4005004:	10c00015 	stw	r3,0(r2)

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 4005008:	01400044 	movi	r5,1
 400500c:	e13ffc17 	ldw	r4,-16(fp)
 4005010:	4006e3c0 	call	4006e3c <prvAddCurrentTaskToDelayedList>
}
 4005014:	0001883a 	nop
 4005018:	e037883a 	mov	sp,fp
 400501c:	dfc00117 	ldw	ra,4(sp)
 4005020:	df000017 	ldw	fp,0(sp)
 4005024:	dec00204 	addi	sp,sp,8
 4005028:	f800283a 	ret

0400502c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
 400502c:	defff504 	addi	sp,sp,-44
 4005030:	dfc00a15 	stw	ra,40(sp)
 4005034:	df000915 	stw	fp,36(sp)
 4005038:	dc400815 	stw	r17,32(sp)
 400503c:	dc000715 	stw	r16,28(sp)
 4005040:	df000904 	addi	fp,sp,36
 4005044:	e13ff715 	stw	r4,-36(fp)
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 4005048:	e0bff717 	ldw	r2,-36(fp)
 400504c:	10800317 	ldw	r2,12(r2)
 4005050:	10800317 	ldw	r2,12(r2)
 4005054:	e0bffc15 	stw	r2,-16(fp)
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
 4005058:	e0bffc17 	ldw	r2,-16(fp)
 400505c:	10800a17 	ldw	r2,40(r2)
 4005060:	e0bffb15 	stw	r2,-20(fp)
 4005064:	e0bffc17 	ldw	r2,-16(fp)
 4005068:	10800717 	ldw	r2,28(r2)
 400506c:	e0fffc17 	ldw	r3,-16(fp)
 4005070:	18c00817 	ldw	r3,32(r3)
 4005074:	10c00215 	stw	r3,8(r2)
 4005078:	e0bffc17 	ldw	r2,-16(fp)
 400507c:	10800817 	ldw	r2,32(r2)
 4005080:	e0fffc17 	ldw	r3,-16(fp)
 4005084:	18c00717 	ldw	r3,28(r3)
 4005088:	10c00115 	stw	r3,4(r2)
 400508c:	e0bffb17 	ldw	r2,-20(fp)
 4005090:	10c00117 	ldw	r3,4(r2)
 4005094:	e0bffc17 	ldw	r2,-16(fp)
 4005098:	10800604 	addi	r2,r2,24
 400509c:	1880041e 	bne	r3,r2,40050b0 <xTaskRemoveFromEventList+0x84>
 40050a0:	e0bffc17 	ldw	r2,-16(fp)
 40050a4:	10c00817 	ldw	r3,32(r2)
 40050a8:	e0bffb17 	ldw	r2,-20(fp)
 40050ac:	10c00115 	stw	r3,4(r2)
 40050b0:	e0bffc17 	ldw	r2,-16(fp)
 40050b4:	10000a15 	stw	zero,40(r2)
 40050b8:	e0bffb17 	ldw	r2,-20(fp)
 40050bc:	10800017 	ldw	r2,0(r2)
 40050c0:	10ffffc4 	addi	r3,r2,-1
 40050c4:	e0bffb17 	ldw	r2,-20(fp)
 40050c8:	10c00015 	stw	r3,0(r2)

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 40050cc:	d0a72117 	ldw	r2,-25468(gp)
 40050d0:	10005b1e 	bne	r2,zero,4005240 <xTaskRemoveFromEventList+0x214>
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
 40050d4:	e0bffc17 	ldw	r2,-16(fp)
 40050d8:	10800517 	ldw	r2,20(r2)
 40050dc:	e0bff915 	stw	r2,-28(fp)
 40050e0:	e0bffc17 	ldw	r2,-16(fp)
 40050e4:	10800217 	ldw	r2,8(r2)
 40050e8:	e0fffc17 	ldw	r3,-16(fp)
 40050ec:	18c00317 	ldw	r3,12(r3)
 40050f0:	10c00215 	stw	r3,8(r2)
 40050f4:	e0bffc17 	ldw	r2,-16(fp)
 40050f8:	10800317 	ldw	r2,12(r2)
 40050fc:	e0fffc17 	ldw	r3,-16(fp)
 4005100:	18c00217 	ldw	r3,8(r3)
 4005104:	10c00115 	stw	r3,4(r2)
 4005108:	e0bff917 	ldw	r2,-28(fp)
 400510c:	10c00117 	ldw	r3,4(r2)
 4005110:	e0bffc17 	ldw	r2,-16(fp)
 4005114:	10800104 	addi	r2,r2,4
 4005118:	1880041e 	bne	r3,r2,400512c <xTaskRemoveFromEventList+0x100>
 400511c:	e0bffc17 	ldw	r2,-16(fp)
 4005120:	10c00317 	ldw	r3,12(r2)
 4005124:	e0bff917 	ldw	r2,-28(fp)
 4005128:	10c00115 	stw	r3,4(r2)
 400512c:	e0bffc17 	ldw	r2,-16(fp)
 4005130:	10000515 	stw	zero,20(r2)
 4005134:	e0bff917 	ldw	r2,-28(fp)
 4005138:	10800017 	ldw	r2,0(r2)
 400513c:	10ffffc4 	addi	r3,r2,-1
 4005140:	e0bff917 	ldw	r2,-28(fp)
 4005144:	10c00015 	stw	r3,0(r2)
        prvAddTaskToReadyList( pxUnblockedTCB );
 4005148:	e0bffc17 	ldw	r2,-16(fp)
 400514c:	10800b17 	ldw	r2,44(r2)
 4005150:	d0e71917 	ldw	r3,-25500(gp)
 4005154:	1880032e 	bgeu	r3,r2,4005164 <xTaskRemoveFromEventList+0x138>
 4005158:	e0bffc17 	ldw	r2,-16(fp)
 400515c:	10800b17 	ldw	r2,44(r2)
 4005160:	d0a71915 	stw	r2,-25500(gp)
 4005164:	e0bffc17 	ldw	r2,-16(fp)
 4005168:	10800b17 	ldw	r2,44(r2)
 400516c:	01400504 	movi	r5,20
 4005170:	1009883a 	mov	r4,r2
 4005174:	40075a40 	call	40075a4 <__mulsi3>
 4005178:	1007883a 	mov	r3,r2
 400517c:	008120b4 	movhi	r2,1154
 4005180:	1885883a 	add	r2,r3,r2
 4005184:	10baf517 	ldw	r2,-5164(r2)
 4005188:	e0bff815 	stw	r2,-32(fp)
 400518c:	e0bffc17 	ldw	r2,-16(fp)
 4005190:	e0fff817 	ldw	r3,-32(fp)
 4005194:	10c00215 	stw	r3,8(r2)
 4005198:	e0bff817 	ldw	r2,-32(fp)
 400519c:	10c00217 	ldw	r3,8(r2)
 40051a0:	e0bffc17 	ldw	r2,-16(fp)
 40051a4:	10c00315 	stw	r3,12(r2)
 40051a8:	e0bff817 	ldw	r2,-32(fp)
 40051ac:	10800217 	ldw	r2,8(r2)
 40051b0:	e0fffc17 	ldw	r3,-16(fp)
 40051b4:	18c00104 	addi	r3,r3,4
 40051b8:	10c00115 	stw	r3,4(r2)
 40051bc:	e0bffc17 	ldw	r2,-16(fp)
 40051c0:	10c00104 	addi	r3,r2,4
 40051c4:	e0bff817 	ldw	r2,-32(fp)
 40051c8:	10c00215 	stw	r3,8(r2)
 40051cc:	e0bffc17 	ldw	r2,-16(fp)
 40051d0:	10800b17 	ldw	r2,44(r2)
 40051d4:	01400504 	movi	r5,20
 40051d8:	1009883a 	mov	r4,r2
 40051dc:	40075a40 	call	40075a4 <__mulsi3>
 40051e0:	1007883a 	mov	r3,r2
 40051e4:	008120b4 	movhi	r2,1154
 40051e8:	10baf404 	addi	r2,r2,-5168
 40051ec:	1887883a 	add	r3,r3,r2
 40051f0:	e0bffc17 	ldw	r2,-16(fp)
 40051f4:	10c00515 	stw	r3,20(r2)
 40051f8:	e0bffc17 	ldw	r2,-16(fp)
 40051fc:	14400b17 	ldw	r17,44(r2)
 4005200:	01400504 	movi	r5,20
 4005204:	8809883a 	mov	r4,r17
 4005208:	40075a40 	call	40075a4 <__mulsi3>
 400520c:	1007883a 	mov	r3,r2
 4005210:	008120b4 	movhi	r2,1154
 4005214:	1885883a 	add	r2,r3,r2
 4005218:	10baf417 	ldw	r2,-5168(r2)
 400521c:	14000044 	addi	r16,r2,1
 4005220:	01400504 	movi	r5,20
 4005224:	8809883a 	mov	r4,r17
 4005228:	40075a40 	call	40075a4 <__mulsi3>
 400522c:	1007883a 	mov	r3,r2
 4005230:	008120b4 	movhi	r2,1154
 4005234:	1885883a 	add	r2,r3,r2
 4005238:	143af415 	stw	r16,-5168(r2)
 400523c:	00001c06 	br	40052b0 <xTaskRemoveFromEventList+0x284>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 4005240:	008120b4 	movhi	r2,1154
 4005244:	10bb1817 	ldw	r2,-5024(r2)
 4005248:	e0bffa15 	stw	r2,-24(fp)
 400524c:	e0bffc17 	ldw	r2,-16(fp)
 4005250:	e0fffa17 	ldw	r3,-24(fp)
 4005254:	10c00715 	stw	r3,28(r2)
 4005258:	e0bffa17 	ldw	r2,-24(fp)
 400525c:	10c00217 	ldw	r3,8(r2)
 4005260:	e0bffc17 	ldw	r2,-16(fp)
 4005264:	10c00815 	stw	r3,32(r2)
 4005268:	e0bffa17 	ldw	r2,-24(fp)
 400526c:	10800217 	ldw	r2,8(r2)
 4005270:	e0fffc17 	ldw	r3,-16(fp)
 4005274:	18c00604 	addi	r3,r3,24
 4005278:	10c00115 	stw	r3,4(r2)
 400527c:	e0bffc17 	ldw	r2,-16(fp)
 4005280:	10c00604 	addi	r3,r2,24
 4005284:	e0bffa17 	ldw	r2,-24(fp)
 4005288:	10c00215 	stw	r3,8(r2)
 400528c:	e0fffc17 	ldw	r3,-16(fp)
 4005290:	008120b4 	movhi	r2,1154
 4005294:	10bb1704 	addi	r2,r2,-5028
 4005298:	18800a15 	stw	r2,40(r3)
 400529c:	008120b4 	movhi	r2,1154
 40052a0:	10bb1717 	ldw	r2,-5028(r2)
 40052a4:	10c00044 	addi	r3,r2,1
 40052a8:	008120b4 	movhi	r2,1154
 40052ac:	10fb1715 	stw	r3,-5028(r2)
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 40052b0:	e0bffc17 	ldw	r2,-16(fp)
 40052b4:	10800b17 	ldw	r2,44(r2)
 40052b8:	d0e71317 	ldw	r3,-25524(gp)
 40052bc:	18c00b17 	ldw	r3,44(r3)
 40052c0:	1880052e 	bgeu	r3,r2,40052d8 <xTaskRemoveFromEventList+0x2ac>
    {
        /* Return true if the task removed from the event list has a higher
         * priority than the calling task.  This allows the calling task to know if
         * it should force a context switch now. */
        xReturn = pdTRUE;
 40052c4:	00800044 	movi	r2,1
 40052c8:	e0bffd15 	stw	r2,-12(fp)

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
 40052cc:	00800044 	movi	r2,1
 40052d0:	d0a71c15 	stw	r2,-25488(gp)
 40052d4:	00000106 	br	40052dc <xTaskRemoveFromEventList+0x2b0>
    }
    else
    {
        xReturn = pdFALSE;
 40052d8:	e03ffd15 	stw	zero,-12(fp)
    }

    return xReturn;
 40052dc:	e0bffd17 	ldw	r2,-12(fp)
}
 40052e0:	e6fffe04 	addi	sp,fp,-8
 40052e4:	dfc00317 	ldw	ra,12(sp)
 40052e8:	df000217 	ldw	fp,8(sp)
 40052ec:	dc400117 	ldw	r17,4(sp)
 40052f0:	dc000017 	ldw	r16,0(sp)
 40052f4:	dec00404 	addi	sp,sp,16
 40052f8:	f800283a 	ret

040052fc <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
 40052fc:	defff604 	addi	sp,sp,-40
 4005300:	dfc00915 	stw	ra,36(sp)
 4005304:	df000815 	stw	fp,32(sp)
 4005308:	dc400715 	stw	r17,28(sp)
 400530c:	dc000615 	stw	r16,24(sp)
 4005310:	df000804 	addi	fp,sp,32
 4005314:	e13ff915 	stw	r4,-28(fp)
 4005318:	e17ff815 	stw	r5,-32(fp)
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 400531c:	e0bff817 	ldw	r2,-32(fp)
 4005320:	10e00034 	orhi	r3,r2,32768
 4005324:	e0bff917 	ldw	r2,-28(fp)
 4005328:	10c00015 	stw	r3,0(r2)

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 400532c:	e0bff917 	ldw	r2,-28(fp)
 4005330:	10800317 	ldw	r2,12(r2)
 4005334:	e0bffd15 	stw	r2,-12(fp)
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( pxEventListItem );
 4005338:	e0bff917 	ldw	r2,-28(fp)
 400533c:	10800417 	ldw	r2,16(r2)
 4005340:	e0bffc15 	stw	r2,-16(fp)
 4005344:	e0bff917 	ldw	r2,-28(fp)
 4005348:	10800117 	ldw	r2,4(r2)
 400534c:	e0fff917 	ldw	r3,-28(fp)
 4005350:	18c00217 	ldw	r3,8(r3)
 4005354:	10c00215 	stw	r3,8(r2)
 4005358:	e0bff917 	ldw	r2,-28(fp)
 400535c:	10800217 	ldw	r2,8(r2)
 4005360:	e0fff917 	ldw	r3,-28(fp)
 4005364:	18c00117 	ldw	r3,4(r3)
 4005368:	10c00115 	stw	r3,4(r2)
 400536c:	e0bffc17 	ldw	r2,-16(fp)
 4005370:	10800117 	ldw	r2,4(r2)
 4005374:	e0fff917 	ldw	r3,-28(fp)
 4005378:	1880041e 	bne	r3,r2,400538c <vTaskRemoveFromUnorderedEventList+0x90>
 400537c:	e0bff917 	ldw	r2,-28(fp)
 4005380:	10c00217 	ldw	r3,8(r2)
 4005384:	e0bffc17 	ldw	r2,-16(fp)
 4005388:	10c00115 	stw	r3,4(r2)
 400538c:	e0bff917 	ldw	r2,-28(fp)
 4005390:	10000415 	stw	zero,16(r2)
 4005394:	e0bffc17 	ldw	r2,-16(fp)
 4005398:	10800017 	ldw	r2,0(r2)
 400539c:	10ffffc4 	addi	r3,r2,-1
 40053a0:	e0bffc17 	ldw	r2,-16(fp)
 40053a4:	10c00015 	stw	r3,0(r2)
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
 40053a8:	e0bffd17 	ldw	r2,-12(fp)
 40053ac:	10800517 	ldw	r2,20(r2)
 40053b0:	e0bffb15 	stw	r2,-20(fp)
 40053b4:	e0bffd17 	ldw	r2,-12(fp)
 40053b8:	10800217 	ldw	r2,8(r2)
 40053bc:	e0fffd17 	ldw	r3,-12(fp)
 40053c0:	18c00317 	ldw	r3,12(r3)
 40053c4:	10c00215 	stw	r3,8(r2)
 40053c8:	e0bffd17 	ldw	r2,-12(fp)
 40053cc:	10800317 	ldw	r2,12(r2)
 40053d0:	e0fffd17 	ldw	r3,-12(fp)
 40053d4:	18c00217 	ldw	r3,8(r3)
 40053d8:	10c00115 	stw	r3,4(r2)
 40053dc:	e0bffb17 	ldw	r2,-20(fp)
 40053e0:	10c00117 	ldw	r3,4(r2)
 40053e4:	e0bffd17 	ldw	r2,-12(fp)
 40053e8:	10800104 	addi	r2,r2,4
 40053ec:	1880041e 	bne	r3,r2,4005400 <vTaskRemoveFromUnorderedEventList+0x104>
 40053f0:	e0bffd17 	ldw	r2,-12(fp)
 40053f4:	10c00317 	ldw	r3,12(r2)
 40053f8:	e0bffb17 	ldw	r2,-20(fp)
 40053fc:	10c00115 	stw	r3,4(r2)
 4005400:	e0bffd17 	ldw	r2,-12(fp)
 4005404:	10000515 	stw	zero,20(r2)
 4005408:	e0bffb17 	ldw	r2,-20(fp)
 400540c:	10800017 	ldw	r2,0(r2)
 4005410:	10ffffc4 	addi	r3,r2,-1
 4005414:	e0bffb17 	ldw	r2,-20(fp)
 4005418:	10c00015 	stw	r3,0(r2)
    prvAddTaskToReadyList( pxUnblockedTCB );
 400541c:	e0bffd17 	ldw	r2,-12(fp)
 4005420:	10800b17 	ldw	r2,44(r2)
 4005424:	d0e71917 	ldw	r3,-25500(gp)
 4005428:	1880032e 	bgeu	r3,r2,4005438 <vTaskRemoveFromUnorderedEventList+0x13c>
 400542c:	e0bffd17 	ldw	r2,-12(fp)
 4005430:	10800b17 	ldw	r2,44(r2)
 4005434:	d0a71915 	stw	r2,-25500(gp)
 4005438:	e0bffd17 	ldw	r2,-12(fp)
 400543c:	10800b17 	ldw	r2,44(r2)
 4005440:	01400504 	movi	r5,20
 4005444:	1009883a 	mov	r4,r2
 4005448:	40075a40 	call	40075a4 <__mulsi3>
 400544c:	1007883a 	mov	r3,r2
 4005450:	008120b4 	movhi	r2,1154
 4005454:	1885883a 	add	r2,r3,r2
 4005458:	10baf517 	ldw	r2,-5164(r2)
 400545c:	e0bffa15 	stw	r2,-24(fp)
 4005460:	e0bffd17 	ldw	r2,-12(fp)
 4005464:	e0fffa17 	ldw	r3,-24(fp)
 4005468:	10c00215 	stw	r3,8(r2)
 400546c:	e0bffa17 	ldw	r2,-24(fp)
 4005470:	10c00217 	ldw	r3,8(r2)
 4005474:	e0bffd17 	ldw	r2,-12(fp)
 4005478:	10c00315 	stw	r3,12(r2)
 400547c:	e0bffa17 	ldw	r2,-24(fp)
 4005480:	10800217 	ldw	r2,8(r2)
 4005484:	e0fffd17 	ldw	r3,-12(fp)
 4005488:	18c00104 	addi	r3,r3,4
 400548c:	10c00115 	stw	r3,4(r2)
 4005490:	e0bffd17 	ldw	r2,-12(fp)
 4005494:	10c00104 	addi	r3,r2,4
 4005498:	e0bffa17 	ldw	r2,-24(fp)
 400549c:	10c00215 	stw	r3,8(r2)
 40054a0:	e0bffd17 	ldw	r2,-12(fp)
 40054a4:	10800b17 	ldw	r2,44(r2)
 40054a8:	01400504 	movi	r5,20
 40054ac:	1009883a 	mov	r4,r2
 40054b0:	40075a40 	call	40075a4 <__mulsi3>
 40054b4:	1007883a 	mov	r3,r2
 40054b8:	008120b4 	movhi	r2,1154
 40054bc:	10baf404 	addi	r2,r2,-5168
 40054c0:	1887883a 	add	r3,r3,r2
 40054c4:	e0bffd17 	ldw	r2,-12(fp)
 40054c8:	10c00515 	stw	r3,20(r2)
 40054cc:	e0bffd17 	ldw	r2,-12(fp)
 40054d0:	14400b17 	ldw	r17,44(r2)
 40054d4:	01400504 	movi	r5,20
 40054d8:	8809883a 	mov	r4,r17
 40054dc:	40075a40 	call	40075a4 <__mulsi3>
 40054e0:	1007883a 	mov	r3,r2
 40054e4:	008120b4 	movhi	r2,1154
 40054e8:	1885883a 	add	r2,r3,r2
 40054ec:	10baf417 	ldw	r2,-5168(r2)
 40054f0:	14000044 	addi	r16,r2,1
 40054f4:	01400504 	movi	r5,20
 40054f8:	8809883a 	mov	r4,r17
 40054fc:	40075a40 	call	40075a4 <__mulsi3>
 4005500:	1007883a 	mov	r3,r2
 4005504:	008120b4 	movhi	r2,1154
 4005508:	1885883a 	add	r2,r3,r2
 400550c:	143af415 	stw	r16,-5168(r2)

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 4005510:	e0bffd17 	ldw	r2,-12(fp)
 4005514:	10800b17 	ldw	r2,44(r2)
 4005518:	d0e71317 	ldw	r3,-25524(gp)
 400551c:	18c00b17 	ldw	r3,44(r3)
 4005520:	1880022e 	bgeu	r3,r2,400552c <vTaskRemoveFromUnorderedEventList+0x230>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
 4005524:	00800044 	movi	r2,1
 4005528:	d0a71c15 	stw	r2,-25488(gp)
    }
}
 400552c:	0001883a 	nop
 4005530:	e6fffe04 	addi	sp,fp,-8
 4005534:	dfc00317 	ldw	ra,12(sp)
 4005538:	df000217 	ldw	fp,8(sp)
 400553c:	dc400117 	ldw	r17,4(sp)
 4005540:	dc000017 	ldw	r16,0(sp)
 4005544:	dec00404 	addi	sp,sp,16
 4005548:	f800283a 	ret

0400554c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
 400554c:	defffd04 	addi	sp,sp,-12
 4005550:	dfc00215 	stw	ra,8(sp)
 4005554:	df000115 	stw	fp,4(sp)
 4005558:	df000104 	addi	fp,sp,4
 400555c:	e13fff15 	stw	r4,-4(fp)
    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
 4005560:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
 4005564:	d0e71d17 	ldw	r3,-25484(gp)
 4005568:	e0bfff17 	ldw	r2,-4(fp)
 400556c:	10c00015 	stw	r3,0(r2)
        pxTimeOut->xTimeOnEntering = xTickCount;
 4005570:	d0e71817 	ldw	r3,-25504(gp)
 4005574:	e0bfff17 	ldw	r2,-4(fp)
 4005578:	10c00115 	stw	r3,4(r2)
    }
    taskEXIT_CRITICAL();
 400557c:	4005fd00 	call	4005fd0 <vTaskExitCritical>
}
 4005580:	0001883a 	nop
 4005584:	e037883a 	mov	sp,fp
 4005588:	dfc00117 	ldw	ra,4(sp)
 400558c:	df000017 	ldw	fp,0(sp)
 4005590:	dec00204 	addi	sp,sp,8
 4005594:	f800283a 	ret

04005598 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
 4005598:	defffe04 	addi	sp,sp,-8
 400559c:	df000115 	stw	fp,4(sp)
 40055a0:	df000104 	addi	fp,sp,4
 40055a4:	e13fff15 	stw	r4,-4(fp)
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
 40055a8:	d0e71d17 	ldw	r3,-25484(gp)
 40055ac:	e0bfff17 	ldw	r2,-4(fp)
 40055b0:	10c00015 	stw	r3,0(r2)
    pxTimeOut->xTimeOnEntering = xTickCount;
 40055b4:	d0e71817 	ldw	r3,-25504(gp)
 40055b8:	e0bfff17 	ldw	r2,-4(fp)
 40055bc:	10c00115 	stw	r3,4(r2)
}
 40055c0:	0001883a 	nop
 40055c4:	e037883a 	mov	sp,fp
 40055c8:	df000017 	ldw	fp,0(sp)
 40055cc:	dec00104 	addi	sp,sp,4
 40055d0:	f800283a 	ret

040055d4 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
 40055d4:	defff904 	addi	sp,sp,-28
 40055d8:	dfc00615 	stw	ra,24(sp)
 40055dc:	df000515 	stw	fp,20(sp)
 40055e0:	df000504 	addi	fp,sp,20
 40055e4:	e13ffc15 	stw	r4,-16(fp)
 40055e8:	e17ffb15 	stw	r5,-20(fp)
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
 40055ec:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
 40055f0:	d0a71817 	ldw	r2,-25504(gp)
 40055f4:	e0bffe15 	stw	r2,-8(fp)
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 40055f8:	e0bffc17 	ldw	r2,-16(fp)
 40055fc:	10800117 	ldw	r2,4(r2)
 4005600:	e0fffe17 	ldw	r3,-8(fp)
 4005604:	1885c83a 	sub	r2,r3,r2
 4005608:	e0bffd15 	stw	r2,-12(fp)
            }
            else
        #endif

        #if ( INCLUDE_vTaskSuspend == 1 )
            if( *pxTicksToWait == portMAX_DELAY )
 400560c:	e0bffb17 	ldw	r2,-20(fp)
 4005610:	10800017 	ldw	r2,0(r2)
 4005614:	10bfffd8 	cmpnei	r2,r2,-1
 4005618:	1000021e 	bne	r2,zero,4005624 <xTaskCheckForTimeOut+0x50>
            {
                /* If INCLUDE_vTaskSuspend is set to 1 and the block time
                 * specified is the maximum block time then the task should block
                 * indefinitely, and therefore never time out. */
                xReturn = pdFALSE;
 400561c:	e03fff15 	stw	zero,-4(fp)
 4005620:	00001f06 	br	40056a0 <xTaskCheckForTimeOut+0xcc>
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 4005624:	e0bffc17 	ldw	r2,-16(fp)
 4005628:	10c00017 	ldw	r3,0(r2)
 400562c:	d0a71d17 	ldw	r2,-25484(gp)
 4005630:	18800926 	beq	r3,r2,4005658 <xTaskCheckForTimeOut+0x84>
 4005634:	e0bffc17 	ldw	r2,-16(fp)
 4005638:	10800117 	ldw	r2,4(r2)
 400563c:	e0fffe17 	ldw	r3,-8(fp)
 4005640:	18800536 	bltu	r3,r2,4005658 <xTaskCheckForTimeOut+0x84>
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
 4005644:	00800044 	movi	r2,1
 4005648:	e0bfff15 	stw	r2,-4(fp)
            *pxTicksToWait = ( TickType_t ) 0;
 400564c:	e0bffb17 	ldw	r2,-20(fp)
 4005650:	10000015 	stw	zero,0(r2)
 4005654:	00001206 	br	40056a0 <xTaskCheckForTimeOut+0xcc>
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 4005658:	e0bffb17 	ldw	r2,-20(fp)
 400565c:	10800017 	ldw	r2,0(r2)
 4005660:	e0fffd17 	ldw	r3,-12(fp)
 4005664:	18800a2e 	bgeu	r3,r2,4005690 <xTaskCheckForTimeOut+0xbc>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
 4005668:	e0bffb17 	ldw	r2,-20(fp)
 400566c:	10c00017 	ldw	r3,0(r2)
 4005670:	e0bffd17 	ldw	r2,-12(fp)
 4005674:	1887c83a 	sub	r3,r3,r2
 4005678:	e0bffb17 	ldw	r2,-20(fp)
 400567c:	10c00015 	stw	r3,0(r2)
            vTaskInternalSetTimeOutState( pxTimeOut );
 4005680:	e13ffc17 	ldw	r4,-16(fp)
 4005684:	40055980 	call	4005598 <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
 4005688:	e03fff15 	stw	zero,-4(fp)
 400568c:	00000406 	br	40056a0 <xTaskCheckForTimeOut+0xcc>
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
 4005690:	e0bffb17 	ldw	r2,-20(fp)
 4005694:	10000015 	stw	zero,0(r2)
            xReturn = pdTRUE;
 4005698:	00800044 	movi	r2,1
 400569c:	e0bfff15 	stw	r2,-4(fp)
        }
    }
    taskEXIT_CRITICAL();
 40056a0:	4005fd00 	call	4005fd0 <vTaskExitCritical>

    return xReturn;
 40056a4:	e0bfff17 	ldw	r2,-4(fp)
}
 40056a8:	e037883a 	mov	sp,fp
 40056ac:	dfc00117 	ldw	ra,4(sp)
 40056b0:	df000017 	ldw	fp,0(sp)
 40056b4:	dec00204 	addi	sp,sp,8
 40056b8:	f800283a 	ret

040056bc <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
 40056bc:	deffff04 	addi	sp,sp,-4
 40056c0:	df000015 	stw	fp,0(sp)
 40056c4:	d839883a 	mov	fp,sp
    xYieldPending = pdTRUE;
 40056c8:	00800044 	movi	r2,1
 40056cc:	d0a71c15 	stw	r2,-25488(gp)
}
 40056d0:	0001883a 	nop
 40056d4:	e037883a 	mov	sp,fp
 40056d8:	df000017 	ldw	fp,0(sp)
 40056dc:	dec00104 	addi	sp,sp,4
 40056e0:	f800283a 	ret

040056e4 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 40056e4:	defffd04 	addi	sp,sp,-12
 40056e8:	dfc00215 	stw	ra,8(sp)
 40056ec:	df000115 	stw	fp,4(sp)
 40056f0:	df000104 	addi	fp,sp,4
 40056f4:	e13fff15 	stw	r4,-4(fp)

    for( ; ; )
    {
        /* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();
 40056f8:	40057c00 	call	40057c0 <prvCheckTasksWaitingTermination>
 40056fc:	003ffe06 	br	40056f8 <prvIdleTask+0x14>

04005700 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
 4005700:	defffd04 	addi	sp,sp,-12
 4005704:	dfc00215 	stw	ra,8(sp)
 4005708:	df000115 	stw	fp,4(sp)
 400570c:	df000104 	addi	fp,sp,4
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 4005710:	e03fff15 	stw	zero,-4(fp)
 4005714:	00000c06 	br	4005748 <prvInitialiseTaskLists+0x48>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 4005718:	01400504 	movi	r5,20
 400571c:	e13fff17 	ldw	r4,-4(fp)
 4005720:	40075a40 	call	40075a4 <__mulsi3>
 4005724:	1007883a 	mov	r3,r2
 4005728:	008120b4 	movhi	r2,1154
 400572c:	10baf404 	addi	r2,r2,-5168
 4005730:	1885883a 	add	r2,r3,r2
 4005734:	1009883a 	mov	r4,r2
 4005738:	4000aa00 	call	4000aa0 <vListInitialise>
    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 400573c:	e0bfff17 	ldw	r2,-4(fp)
 4005740:	10800044 	addi	r2,r2,1
 4005744:	e0bfff15 	stw	r2,-4(fp)
 4005748:	e0bfff17 	ldw	r2,-4(fp)
 400574c:	10800170 	cmpltui	r2,r2,5
 4005750:	103ff11e 	bne	r2,zero,4005718 <prvInitialiseTaskLists+0x18>
    }

    vListInitialise( &xDelayedTaskList1 );
 4005754:	010120b4 	movhi	r4,1154
 4005758:	213b0d04 	addi	r4,r4,-5068
 400575c:	4000aa00 	call	4000aa0 <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
 4005760:	010120b4 	movhi	r4,1154
 4005764:	213b1204 	addi	r4,r4,-5048
 4005768:	4000aa00 	call	4000aa0 <vListInitialise>
    vListInitialise( &xPendingReadyList );
 400576c:	010120b4 	movhi	r4,1154
 4005770:	213b1704 	addi	r4,r4,-5028
 4005774:	4000aa00 	call	4000aa0 <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        vListInitialise( &xTasksWaitingTermination );
 4005778:	010120b4 	movhi	r4,1154
 400577c:	213b1c04 	addi	r4,r4,-5008
 4005780:	4000aa00 	call	4000aa0 <vListInitialise>
    }
    #endif /* INCLUDE_vTaskDelete */

    #if ( INCLUDE_vTaskSuspend == 1 )
    {
        vListInitialise( &xSuspendedTaskList );
 4005784:	010120b4 	movhi	r4,1154
 4005788:	213b2104 	addi	r4,r4,-4988
 400578c:	4000aa00 	call	4000aa0 <vListInitialise>
    }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
 4005790:	008120b4 	movhi	r2,1154
 4005794:	10bb0d04 	addi	r2,r2,-5068
 4005798:	d0a71415 	stw	r2,-25520(gp)
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
 400579c:	008120b4 	movhi	r2,1154
 40057a0:	10bb1204 	addi	r2,r2,-5048
 40057a4:	d0a71515 	stw	r2,-25516(gp)
}
 40057a8:	0001883a 	nop
 40057ac:	e037883a 	mov	sp,fp
 40057b0:	dfc00117 	ldw	ra,4(sp)
 40057b4:	df000017 	ldw	fp,0(sp)
 40057b8:	dec00204 	addi	sp,sp,8
 40057bc:	f800283a 	ret

040057c0 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
 40057c0:	defffd04 	addi	sp,sp,-12
 40057c4:	dfc00215 	stw	ra,8(sp)
 40057c8:	df000115 	stw	fp,4(sp)
 40057cc:	df000104 	addi	fp,sp,4
    {
        TCB_t * pxTCB;

        /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
         * being called too often in the idle task. */
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 40057d0:	00001206 	br	400581c <prvCheckTasksWaitingTermination+0x5c>
        {
            taskENTER_CRITICAL();
 40057d4:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
            {
                pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 40057d8:	008120b4 	movhi	r2,1154
 40057dc:	10bb1f17 	ldw	r2,-4996(r2)
 40057e0:	10800317 	ldw	r2,12(r2)
 40057e4:	e0bfff15 	stw	r2,-4(fp)
                ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 40057e8:	e0bfff17 	ldw	r2,-4(fp)
 40057ec:	10800104 	addi	r2,r2,4
 40057f0:	1009883a 	mov	r4,r2
 40057f4:	4000c980 	call	4000c98 <uxListRemove>
                --uxCurrentNumberOfTasks;
 40057f8:	d0a71717 	ldw	r2,-25508(gp)
 40057fc:	10bfffc4 	addi	r2,r2,-1
 4005800:	d0a71715 	stw	r2,-25508(gp)
                --uxDeletedTasksWaitingCleanUp;
 4005804:	d0a71617 	ldw	r2,-25512(gp)
 4005808:	10bfffc4 	addi	r2,r2,-1
 400580c:	d0a71615 	stw	r2,-25512(gp)
            }
            taskEXIT_CRITICAL();
 4005810:	4005fd00 	call	4005fd0 <vTaskExitCritical>

            prvDeleteTCB( pxTCB );
 4005814:	e13fff17 	ldw	r4,-4(fp)
 4005818:	40059040 	call	4005904 <prvDeleteTCB>
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 400581c:	d0a71617 	ldw	r2,-25512(gp)
 4005820:	103fec1e 	bne	r2,zero,40057d4 <prvCheckTasksWaitingTermination+0x14>
        }
    }
    #endif /* INCLUDE_vTaskDelete */
}
 4005824:	0001883a 	nop
 4005828:	0001883a 	nop
 400582c:	e037883a 	mov	sp,fp
 4005830:	dfc00117 	ldw	ra,4(sp)
 4005834:	df000017 	ldw	fp,0(sp)
 4005838:	dec00204 	addi	sp,sp,8
 400583c:	f800283a 	ret

04005840 <prvTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )

    static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
    {
 4005840:	defffd04 	addi	sp,sp,-12
 4005844:	df000215 	stw	fp,8(sp)
 4005848:	df000204 	addi	fp,sp,8
 400584c:	e13ffe15 	stw	r4,-8(fp)
        uint32_t ulCount = 0U;
 4005850:	e03fff15 	stw	zero,-4(fp)

        while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 4005854:	00000606 	br	4005870 <prvTaskCheckFreeStackSpace+0x30>
        {
            pucStackByte -= portSTACK_GROWTH;
 4005858:	e0bffe17 	ldw	r2,-8(fp)
 400585c:	10800044 	addi	r2,r2,1
 4005860:	e0bffe15 	stw	r2,-8(fp)
            ulCount++;
 4005864:	e0bfff17 	ldw	r2,-4(fp)
 4005868:	10800044 	addi	r2,r2,1
 400586c:	e0bfff15 	stw	r2,-4(fp)
        while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 4005870:	e0bffe17 	ldw	r2,-8(fp)
 4005874:	10800003 	ldbu	r2,0(r2)
 4005878:	10803fcc 	andi	r2,r2,255
 400587c:	10802960 	cmpeqi	r2,r2,165
 4005880:	103ff51e 	bne	r2,zero,4005858 <prvTaskCheckFreeStackSpace+0x18>
        }

        ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
 4005884:	e0bfff17 	ldw	r2,-4(fp)
 4005888:	1004d0ba 	srli	r2,r2,2
 400588c:	e0bfff15 	stw	r2,-4(fp)

        return ( configSTACK_DEPTH_TYPE ) ulCount;
 4005890:	e0bfff17 	ldw	r2,-4(fp)
    }
 4005894:	e037883a 	mov	sp,fp
 4005898:	df000017 	ldw	fp,0(sp)
 400589c:	dec00104 	addi	sp,sp,4
 40058a0:	f800283a 	ret

040058a4 <uxTaskGetStackHighWaterMark>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

    UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
    {
 40058a4:	defffa04 	addi	sp,sp,-24
 40058a8:	dfc00515 	stw	ra,20(sp)
 40058ac:	df000415 	stw	fp,16(sp)
 40058b0:	df000404 	addi	fp,sp,16
 40058b4:	e13ffc15 	stw	r4,-16(fp)
        TCB_t * pxTCB;
        uint8_t * pucEndOfStack;
        UBaseType_t uxReturn;

        pxTCB = prvGetTCBFromHandle( xTask );
 40058b8:	e0bffc17 	ldw	r2,-16(fp)
 40058bc:	1000021e 	bne	r2,zero,40058c8 <uxTaskGetStackHighWaterMark+0x24>
 40058c0:	d0a71317 	ldw	r2,-25524(gp)
 40058c4:	00000106 	br	40058cc <uxTaskGetStackHighWaterMark+0x28>
 40058c8:	e0bffc17 	ldw	r2,-16(fp)
 40058cc:	e0bfff15 	stw	r2,-4(fp)

        #if portSTACK_GROWTH < 0
        {
            pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
 40058d0:	e0bfff17 	ldw	r2,-4(fp)
 40058d4:	10800c17 	ldw	r2,48(r2)
 40058d8:	e0bffe15 	stw	r2,-8(fp)
        {
            pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
        }
        #endif

        uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
 40058dc:	e13ffe17 	ldw	r4,-8(fp)
 40058e0:	40058400 	call	4005840 <prvTaskCheckFreeStackSpace>
 40058e4:	10bfffcc 	andi	r2,r2,65535
 40058e8:	e0bffd15 	stw	r2,-12(fp)

        return uxReturn;
 40058ec:	e0bffd17 	ldw	r2,-12(fp)
    }
 40058f0:	e037883a 	mov	sp,fp
 40058f4:	dfc00117 	ldw	ra,4(sp)
 40058f8:	df000017 	ldw	fp,0(sp)
 40058fc:	dec00204 	addi	sp,sp,8
 4005900:	f800283a 	ret

04005904 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
 4005904:	defffd04 	addi	sp,sp,-12
 4005908:	dfc00215 	stw	ra,8(sp)
 400590c:	df000115 	stw	fp,4(sp)
 4005910:	df000104 	addi	fp,sp,4
 4005914:	e13fff15 	stw	r4,-4(fp)

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
        {
            /* The task can only have been allocated dynamically - free both
             * the stack and TCB. */
            vPortFreeStack( pxTCB->pxStack );
 4005918:	e0bfff17 	ldw	r2,-4(fp)
 400591c:	10800c17 	ldw	r2,48(r2)
 4005920:	1009883a 	mov	r4,r2
 4005924:	40011240 	call	4001124 <vPortFree>
            vPortFree( pxTCB );
 4005928:	e13fff17 	ldw	r4,-4(fp)
 400592c:	40011240 	call	4001124 <vPortFree>
                configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                mtCOVERAGE_TEST_MARKER();
            }
        }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
 4005930:	0001883a 	nop
 4005934:	e037883a 	mov	sp,fp
 4005938:	dfc00117 	ldw	ra,4(sp)
 400593c:	df000017 	ldw	fp,0(sp)
 4005940:	dec00204 	addi	sp,sp,8
 4005944:	f800283a 	ret

04005948 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
 4005948:	deffff04 	addi	sp,sp,-4
 400594c:	df000015 	stw	fp,0(sp)
 4005950:	d839883a 	mov	fp,sp
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 4005954:	d0a71417 	ldw	r2,-25520(gp)
 4005958:	10800017 	ldw	r2,0(r2)
 400595c:	1000031e 	bne	r2,zero,400596c <prvResetNextTaskUnblockTime+0x24>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
 4005960:	00bfffc4 	movi	r2,-1
 4005964:	d0a71f15 	stw	r2,-25476(gp)
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    }
}
 4005968:	00000406 	br	400597c <prvResetNextTaskUnblockTime+0x34>
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
 400596c:	d0a71417 	ldw	r2,-25520(gp)
 4005970:	10800317 	ldw	r2,12(r2)
 4005974:	10800017 	ldw	r2,0(r2)
 4005978:	d0a71f15 	stw	r2,-25476(gp)
}
 400597c:	0001883a 	nop
 4005980:	e037883a 	mov	sp,fp
 4005984:	df000017 	ldw	fp,0(sp)
 4005988:	dec00104 	addi	sp,sp,4
 400598c:	f800283a 	ret

04005990 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

    TaskHandle_t xTaskGetCurrentTaskHandle( void )
    {
 4005990:	defffe04 	addi	sp,sp,-8
 4005994:	df000115 	stw	fp,4(sp)
 4005998:	df000104 	addi	fp,sp,4
        TaskHandle_t xReturn;

        /* A critical section is not required as this is not called from
         * an interrupt and the current TCB will always be the same for any
         * individual execution thread. */
        xReturn = pxCurrentTCB;
 400599c:	d0a71317 	ldw	r2,-25524(gp)
 40059a0:	e0bfff15 	stw	r2,-4(fp)

        return xReturn;
 40059a4:	e0bfff17 	ldw	r2,-4(fp)
    }
 40059a8:	e037883a 	mov	sp,fp
 40059ac:	df000017 	ldw	fp,0(sp)
 40059b0:	dec00104 	addi	sp,sp,4
 40059b4:	f800283a 	ret

040059b8 <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
    {
 40059b8:	defff804 	addi	sp,sp,-32
 40059bc:	dfc00715 	stw	ra,28(sp)
 40059c0:	df000615 	stw	fp,24(sp)
 40059c4:	dc400515 	stw	r17,20(sp)
 40059c8:	dc000415 	stw	r16,16(sp)
 40059cc:	df000604 	addi	fp,sp,24
 40059d0:	e13ffa15 	stw	r4,-24(fp)
        TCB_t * const pxMutexHolderTCB = pxMutexHolder;
 40059d4:	e0bffa17 	ldw	r2,-24(fp)
 40059d8:	e0bffc15 	stw	r2,-16(fp)
        BaseType_t xReturn = pdFALSE;
 40059dc:	e03ffd15 	stw	zero,-12(fp)

        /* If the mutex was given back by an interrupt while the queue was
         * locked then the mutex holder might now be NULL.  _RB_ Is this still
         * needed as interrupts can no longer use mutexes? */
        if( pxMutexHolder != NULL )
 40059e0:	e0bffa17 	ldw	r2,-24(fp)
 40059e4:	10006e26 	beq	r2,zero,4005ba0 <xTaskPriorityInherit+0x1e8>
        {
            /* If the holder of the mutex has a priority below the priority of
             * the task attempting to obtain the mutex then it will temporarily
             * inherit the priority of the task attempting to obtain the mutex. */
            if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
 40059e8:	e0bffc17 	ldw	r2,-16(fp)
 40059ec:	10c00b17 	ldw	r3,44(r2)
 40059f0:	d0a71317 	ldw	r2,-25524(gp)
 40059f4:	10800b17 	ldw	r2,44(r2)
 40059f8:	1880622e 	bgeu	r3,r2,4005b84 <xTaskPriorityInherit+0x1cc>
            {
                /* Adjust the mutex holder state to account for its new
                 * priority.  Only reset the event list item value if the value is
                 * not being used for anything else. */
                if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 40059fc:	e0bffc17 	ldw	r2,-16(fp)
 4005a00:	10800617 	ldw	r2,24(r2)
 4005a04:	10000616 	blt	r2,zero,4005a20 <xTaskPriorityInherit+0x68>
                {
                    listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 4005a08:	d0a71317 	ldw	r2,-25524(gp)
 4005a0c:	10800b17 	ldw	r2,44(r2)
 4005a10:	00c00144 	movi	r3,5
 4005a14:	1887c83a 	sub	r3,r3,r2
 4005a18:	e0bffc17 	ldw	r2,-16(fp)
 4005a1c:	10c00615 	stw	r3,24(r2)
                    mtCOVERAGE_TEST_MARKER();
                }

                /* If the task being modified is in the ready state it will need
                 * to be moved into a new list. */
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 4005a20:	e0bffc17 	ldw	r2,-16(fp)
 4005a24:	14000517 	ldw	r16,20(r2)
 4005a28:	e0bffc17 	ldw	r2,-16(fp)
 4005a2c:	10800b17 	ldw	r2,44(r2)
 4005a30:	01400504 	movi	r5,20
 4005a34:	1009883a 	mov	r4,r2
 4005a38:	40075a40 	call	40075a4 <__mulsi3>
 4005a3c:	1007883a 	mov	r3,r2
 4005a40:	008120b4 	movhi	r2,1154
 4005a44:	10baf404 	addi	r2,r2,-5168
 4005a48:	1885883a 	add	r2,r3,r2
 4005a4c:	8080461e 	bne	r16,r2,4005b68 <xTaskPriorityInherit+0x1b0>
                {
                    if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4005a50:	e0bffc17 	ldw	r2,-16(fp)
 4005a54:	10800104 	addi	r2,r2,4
 4005a58:	1009883a 	mov	r4,r2
 4005a5c:	4000c980 	call	4000c98 <uxListRemove>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Inherit the priority before being moved into the new list. */
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 4005a60:	d0a71317 	ldw	r2,-25524(gp)
 4005a64:	10c00b17 	ldw	r3,44(r2)
 4005a68:	e0bffc17 	ldw	r2,-16(fp)
 4005a6c:	10c00b15 	stw	r3,44(r2)
                    prvAddTaskToReadyList( pxMutexHolderTCB );
 4005a70:	e0bffc17 	ldw	r2,-16(fp)
 4005a74:	10800b17 	ldw	r2,44(r2)
 4005a78:	d0e71917 	ldw	r3,-25500(gp)
 4005a7c:	1880032e 	bgeu	r3,r2,4005a8c <xTaskPriorityInherit+0xd4>
 4005a80:	e0bffc17 	ldw	r2,-16(fp)
 4005a84:	10800b17 	ldw	r2,44(r2)
 4005a88:	d0a71915 	stw	r2,-25500(gp)
 4005a8c:	e0bffc17 	ldw	r2,-16(fp)
 4005a90:	10800b17 	ldw	r2,44(r2)
 4005a94:	01400504 	movi	r5,20
 4005a98:	1009883a 	mov	r4,r2
 4005a9c:	40075a40 	call	40075a4 <__mulsi3>
 4005aa0:	1007883a 	mov	r3,r2
 4005aa4:	008120b4 	movhi	r2,1154
 4005aa8:	1885883a 	add	r2,r3,r2
 4005aac:	10baf517 	ldw	r2,-5164(r2)
 4005ab0:	e0bffb15 	stw	r2,-20(fp)
 4005ab4:	e0bffc17 	ldw	r2,-16(fp)
 4005ab8:	e0fffb17 	ldw	r3,-20(fp)
 4005abc:	10c00215 	stw	r3,8(r2)
 4005ac0:	e0bffb17 	ldw	r2,-20(fp)
 4005ac4:	10c00217 	ldw	r3,8(r2)
 4005ac8:	e0bffc17 	ldw	r2,-16(fp)
 4005acc:	10c00315 	stw	r3,12(r2)
 4005ad0:	e0bffb17 	ldw	r2,-20(fp)
 4005ad4:	10800217 	ldw	r2,8(r2)
 4005ad8:	e0fffc17 	ldw	r3,-16(fp)
 4005adc:	18c00104 	addi	r3,r3,4
 4005ae0:	10c00115 	stw	r3,4(r2)
 4005ae4:	e0bffc17 	ldw	r2,-16(fp)
 4005ae8:	10c00104 	addi	r3,r2,4
 4005aec:	e0bffb17 	ldw	r2,-20(fp)
 4005af0:	10c00215 	stw	r3,8(r2)
 4005af4:	e0bffc17 	ldw	r2,-16(fp)
 4005af8:	10800b17 	ldw	r2,44(r2)
 4005afc:	01400504 	movi	r5,20
 4005b00:	1009883a 	mov	r4,r2
 4005b04:	40075a40 	call	40075a4 <__mulsi3>
 4005b08:	1007883a 	mov	r3,r2
 4005b0c:	008120b4 	movhi	r2,1154
 4005b10:	10baf404 	addi	r2,r2,-5168
 4005b14:	1887883a 	add	r3,r3,r2
 4005b18:	e0bffc17 	ldw	r2,-16(fp)
 4005b1c:	10c00515 	stw	r3,20(r2)
 4005b20:	e0bffc17 	ldw	r2,-16(fp)
 4005b24:	14400b17 	ldw	r17,44(r2)
 4005b28:	01400504 	movi	r5,20
 4005b2c:	8809883a 	mov	r4,r17
 4005b30:	40075a40 	call	40075a4 <__mulsi3>
 4005b34:	1007883a 	mov	r3,r2
 4005b38:	008120b4 	movhi	r2,1154
 4005b3c:	1885883a 	add	r2,r3,r2
 4005b40:	10baf417 	ldw	r2,-5168(r2)
 4005b44:	14000044 	addi	r16,r2,1
 4005b48:	01400504 	movi	r5,20
 4005b4c:	8809883a 	mov	r4,r17
 4005b50:	40075a40 	call	40075a4 <__mulsi3>
 4005b54:	1007883a 	mov	r3,r2
 4005b58:	008120b4 	movhi	r2,1154
 4005b5c:	1885883a 	add	r2,r3,r2
 4005b60:	143af415 	stw	r16,-5168(r2)
 4005b64:	00000406 	br	4005b78 <xTaskPriorityInherit+0x1c0>
                }
                else
                {
                    /* Just inherit the priority. */
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 4005b68:	d0a71317 	ldw	r2,-25524(gp)
 4005b6c:	10c00b17 	ldw	r3,44(r2)
 4005b70:	e0bffc17 	ldw	r2,-16(fp)
 4005b74:	10c00b15 	stw	r3,44(r2)
                }

                traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

                /* Inheritance occurred. */
                xReturn = pdTRUE;
 4005b78:	00800044 	movi	r2,1
 4005b7c:	e0bffd15 	stw	r2,-12(fp)
 4005b80:	00000706 	br	4005ba0 <xTaskPriorityInherit+0x1e8>
            }
            else
            {
                if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
 4005b84:	e0bffc17 	ldw	r2,-16(fp)
 4005b88:	10c01017 	ldw	r3,64(r2)
 4005b8c:	d0a71317 	ldw	r2,-25524(gp)
 4005b90:	10800b17 	ldw	r2,44(r2)
 4005b94:	1880022e 	bgeu	r3,r2,4005ba0 <xTaskPriorityInherit+0x1e8>
                     * current priority of the mutex holder is not lower than the
                     * priority of the task attempting to take the mutex.
                     * Therefore the mutex holder must have already inherited a
                     * priority, but inheritance would have occurred if that had
                     * not been the case. */
                    xReturn = pdTRUE;
 4005b98:	00800044 	movi	r2,1
 4005b9c:	e0bffd15 	stw	r2,-12(fp)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
 4005ba0:	e0bffd17 	ldw	r2,-12(fp)
    }
 4005ba4:	e6fffe04 	addi	sp,fp,-8
 4005ba8:	dfc00317 	ldw	ra,12(sp)
 4005bac:	df000217 	ldw	fp,8(sp)
 4005bb0:	dc400117 	ldw	r17,4(sp)
 4005bb4:	dc000017 	ldw	r16,0(sp)
 4005bb8:	dec00404 	addi	sp,sp,16
 4005bbc:	f800283a 	ret

04005bc0 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
 4005bc0:	defff804 	addi	sp,sp,-32
 4005bc4:	dfc00715 	stw	ra,28(sp)
 4005bc8:	df000615 	stw	fp,24(sp)
 4005bcc:	dc400515 	stw	r17,20(sp)
 4005bd0:	dc000415 	stw	r16,16(sp)
 4005bd4:	df000604 	addi	fp,sp,24
 4005bd8:	e13ffa15 	stw	r4,-24(fp)
        TCB_t * const pxTCB = pxMutexHolder;
 4005bdc:	e0bffa17 	ldw	r2,-24(fp)
 4005be0:	e0bffc15 	stw	r2,-16(fp)
        BaseType_t xReturn = pdFALSE;
 4005be4:	e03ffd15 	stw	zero,-12(fp)

        if( pxMutexHolder != NULL )
 4005be8:	e0bffa17 	ldw	r2,-24(fp)
 4005bec:	10005a26 	beq	r2,zero,4005d58 <xTaskPriorityDisinherit+0x198>
             * If the mutex is held by a task then it cannot be given from an
             * interrupt, and if a mutex is given by the holding task then it must
             * be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
            configASSERT( pxTCB->uxMutexesHeld );
            ( pxTCB->uxMutexesHeld )--;
 4005bf0:	e0bffc17 	ldw	r2,-16(fp)
 4005bf4:	10801117 	ldw	r2,68(r2)
 4005bf8:	10ffffc4 	addi	r3,r2,-1
 4005bfc:	e0bffc17 	ldw	r2,-16(fp)
 4005c00:	10c01115 	stw	r3,68(r2)

            /* Has the holder of the mutex inherited the priority of another
             * task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 4005c04:	e0bffc17 	ldw	r2,-16(fp)
 4005c08:	10c00b17 	ldw	r3,44(r2)
 4005c0c:	e0bffc17 	ldw	r2,-16(fp)
 4005c10:	10801017 	ldw	r2,64(r2)
 4005c14:	18805026 	beq	r3,r2,4005d58 <xTaskPriorityDisinherit+0x198>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 4005c18:	e0bffc17 	ldw	r2,-16(fp)
 4005c1c:	10801117 	ldw	r2,68(r2)
 4005c20:	10004d1e 	bne	r2,zero,4005d58 <xTaskPriorityDisinherit+0x198>
                    /* A task can only have an inherited priority if it holds
                     * the mutex.  If the mutex is held by a task then it cannot be
                     * given from an interrupt, and if a mutex is given by the
                     * holding task then it must be the running state task.  Remove
                     * the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4005c24:	e0bffc17 	ldw	r2,-16(fp)
 4005c28:	10800104 	addi	r2,r2,4
 4005c2c:	1009883a 	mov	r4,r2
 4005c30:	4000c980 	call	4000c98 <uxListRemove>
                    }

                    /* Disinherit the priority before adding the task into the
                     * new  ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
 4005c34:	e0bffc17 	ldw	r2,-16(fp)
 4005c38:	10c01017 	ldw	r3,64(r2)
 4005c3c:	e0bffc17 	ldw	r2,-16(fp)
 4005c40:	10c00b15 	stw	r3,44(r2)

                    /* Reset the event list item value.  It cannot be in use for
                     * any other purpose if this task is running, and it must be
                     * running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 4005c44:	e0bffc17 	ldw	r2,-16(fp)
 4005c48:	10800b17 	ldw	r2,44(r2)
 4005c4c:	00c00144 	movi	r3,5
 4005c50:	1887c83a 	sub	r3,r3,r2
 4005c54:	e0bffc17 	ldw	r2,-16(fp)
 4005c58:	10c00615 	stw	r3,24(r2)
                    prvAddTaskToReadyList( pxTCB );
 4005c5c:	e0bffc17 	ldw	r2,-16(fp)
 4005c60:	10800b17 	ldw	r2,44(r2)
 4005c64:	d0e71917 	ldw	r3,-25500(gp)
 4005c68:	1880032e 	bgeu	r3,r2,4005c78 <xTaskPriorityDisinherit+0xb8>
 4005c6c:	e0bffc17 	ldw	r2,-16(fp)
 4005c70:	10800b17 	ldw	r2,44(r2)
 4005c74:	d0a71915 	stw	r2,-25500(gp)
 4005c78:	e0bffc17 	ldw	r2,-16(fp)
 4005c7c:	10800b17 	ldw	r2,44(r2)
 4005c80:	01400504 	movi	r5,20
 4005c84:	1009883a 	mov	r4,r2
 4005c88:	40075a40 	call	40075a4 <__mulsi3>
 4005c8c:	1007883a 	mov	r3,r2
 4005c90:	008120b4 	movhi	r2,1154
 4005c94:	1885883a 	add	r2,r3,r2
 4005c98:	10baf517 	ldw	r2,-5164(r2)
 4005c9c:	e0bffb15 	stw	r2,-20(fp)
 4005ca0:	e0bffc17 	ldw	r2,-16(fp)
 4005ca4:	e0fffb17 	ldw	r3,-20(fp)
 4005ca8:	10c00215 	stw	r3,8(r2)
 4005cac:	e0bffb17 	ldw	r2,-20(fp)
 4005cb0:	10c00217 	ldw	r3,8(r2)
 4005cb4:	e0bffc17 	ldw	r2,-16(fp)
 4005cb8:	10c00315 	stw	r3,12(r2)
 4005cbc:	e0bffb17 	ldw	r2,-20(fp)
 4005cc0:	10800217 	ldw	r2,8(r2)
 4005cc4:	e0fffc17 	ldw	r3,-16(fp)
 4005cc8:	18c00104 	addi	r3,r3,4
 4005ccc:	10c00115 	stw	r3,4(r2)
 4005cd0:	e0bffc17 	ldw	r2,-16(fp)
 4005cd4:	10c00104 	addi	r3,r2,4
 4005cd8:	e0bffb17 	ldw	r2,-20(fp)
 4005cdc:	10c00215 	stw	r3,8(r2)
 4005ce0:	e0bffc17 	ldw	r2,-16(fp)
 4005ce4:	10800b17 	ldw	r2,44(r2)
 4005ce8:	01400504 	movi	r5,20
 4005cec:	1009883a 	mov	r4,r2
 4005cf0:	40075a40 	call	40075a4 <__mulsi3>
 4005cf4:	1007883a 	mov	r3,r2
 4005cf8:	008120b4 	movhi	r2,1154
 4005cfc:	10baf404 	addi	r2,r2,-5168
 4005d00:	1887883a 	add	r3,r3,r2
 4005d04:	e0bffc17 	ldw	r2,-16(fp)
 4005d08:	10c00515 	stw	r3,20(r2)
 4005d0c:	e0bffc17 	ldw	r2,-16(fp)
 4005d10:	14400b17 	ldw	r17,44(r2)
 4005d14:	01400504 	movi	r5,20
 4005d18:	8809883a 	mov	r4,r17
 4005d1c:	40075a40 	call	40075a4 <__mulsi3>
 4005d20:	1007883a 	mov	r3,r2
 4005d24:	008120b4 	movhi	r2,1154
 4005d28:	1885883a 	add	r2,r3,r2
 4005d2c:	10baf417 	ldw	r2,-5168(r2)
 4005d30:	14000044 	addi	r16,r2,1
 4005d34:	01400504 	movi	r5,20
 4005d38:	8809883a 	mov	r4,r17
 4005d3c:	40075a40 	call	40075a4 <__mulsi3>
 4005d40:	1007883a 	mov	r3,r2
 4005d44:	008120b4 	movhi	r2,1154
 4005d48:	1885883a 	add	r2,r3,r2
 4005d4c:	143af415 	stw	r16,-5168(r2)
                     * in an order different to that in which they were taken.
                     * If a context switch did not occur when the first mutex was
                     * returned, even if a task was waiting on it, then a context
                     * switch should occur when the last mutex is returned whether
                     * a task is waiting on it or not. */
                    xReturn = pdTRUE;
 4005d50:	00800044 	movi	r2,1
 4005d54:	e0bffd15 	stw	r2,-12(fp)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
 4005d58:	e0bffd17 	ldw	r2,-12(fp)
    }
 4005d5c:	e6fffe04 	addi	sp,fp,-8
 4005d60:	dfc00317 	ldw	ra,12(sp)
 4005d64:	df000217 	ldw	fp,8(sp)
 4005d68:	dc400117 	ldw	r17,4(sp)
 4005d6c:	dc000017 	ldw	r16,0(sp)
 4005d70:	dec00404 	addi	sp,sp,16
 4005d74:	f800283a 	ret

04005d78 <vTaskPriorityDisinheritAfterTimeout>:

#if ( configUSE_MUTEXES == 1 )

    void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder,
                                              UBaseType_t uxHighestPriorityWaitingTask )
    {
 4005d78:	defff504 	addi	sp,sp,-44
 4005d7c:	dfc00a15 	stw	ra,40(sp)
 4005d80:	df000915 	stw	fp,36(sp)
 4005d84:	dc400815 	stw	r17,32(sp)
 4005d88:	dc000715 	stw	r16,28(sp)
 4005d8c:	df000904 	addi	fp,sp,36
 4005d90:	e13ff815 	stw	r4,-32(fp)
 4005d94:	e17ff715 	stw	r5,-36(fp)
        TCB_t * const pxTCB = pxMutexHolder;
 4005d98:	e0bff817 	ldw	r2,-32(fp)
 4005d9c:	e0bffc15 	stw	r2,-16(fp)
        UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
        const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
 4005da0:	00800044 	movi	r2,1
 4005da4:	e0bffb15 	stw	r2,-20(fp)

        if( pxMutexHolder != NULL )
 4005da8:	e0bff817 	ldw	r2,-32(fp)
 4005dac:	10006b26 	beq	r2,zero,4005f5c <vTaskPriorityDisinheritAfterTimeout+0x1e4>

            /* Determine the priority to which the priority of the task that
             * holds the mutex should be set.  This will be the greater of the
             * holding task's base priority and the priority of the highest
             * priority task that is waiting to obtain the mutex. */
            if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
 4005db0:	e0bffc17 	ldw	r2,-16(fp)
 4005db4:	10c01017 	ldw	r3,64(r2)
 4005db8:	e0bff717 	ldw	r2,-36(fp)
 4005dbc:	1880032e 	bgeu	r3,r2,4005dcc <vTaskPriorityDisinheritAfterTimeout+0x54>
            {
                uxPriorityToUse = uxHighestPriorityWaitingTask;
 4005dc0:	e0bff717 	ldw	r2,-36(fp)
 4005dc4:	e0bffd15 	stw	r2,-12(fp)
 4005dc8:	00000306 	br	4005dd8 <vTaskPriorityDisinheritAfterTimeout+0x60>
            }
            else
            {
                uxPriorityToUse = pxTCB->uxBasePriority;
 4005dcc:	e0bffc17 	ldw	r2,-16(fp)
 4005dd0:	10801017 	ldw	r2,64(r2)
 4005dd4:	e0bffd15 	stw	r2,-12(fp)
            }

            /* Does the priority need to change? */
            if( pxTCB->uxPriority != uxPriorityToUse )
 4005dd8:	e0bffc17 	ldw	r2,-16(fp)
 4005ddc:	10800b17 	ldw	r2,44(r2)
 4005de0:	e0fffd17 	ldw	r3,-12(fp)
 4005de4:	18805d26 	beq	r3,r2,4005f5c <vTaskPriorityDisinheritAfterTimeout+0x1e4>
            {
                /* Only disinherit if no other mutexes are held.  This is a
                 * simplification in the priority inheritance implementation.  If
                 * the task that holds the mutex is also holding other mutexes then
                 * the other mutexes may have caused the priority inheritance. */
                if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
 4005de8:	e0bffc17 	ldw	r2,-16(fp)
 4005dec:	10801117 	ldw	r2,68(r2)
 4005df0:	e0fffb17 	ldw	r3,-20(fp)
 4005df4:	1880591e 	bne	r3,r2,4005f5c <vTaskPriorityDisinheritAfterTimeout+0x1e4>

                    /* Disinherit the priority, remembering the previous
                     * priority to facilitate determining the subject task's
                     * state. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, uxPriorityToUse );
                    uxPriorityUsedOnEntry = pxTCB->uxPriority;
 4005df8:	e0bffc17 	ldw	r2,-16(fp)
 4005dfc:	10800b17 	ldw	r2,44(r2)
 4005e00:	e0bffa15 	stw	r2,-24(fp)
                    pxTCB->uxPriority = uxPriorityToUse;
 4005e04:	e0bffc17 	ldw	r2,-16(fp)
 4005e08:	e0fffd17 	ldw	r3,-12(fp)
 4005e0c:	10c00b15 	stw	r3,44(r2)

                    /* Only reset the event list item value if the value is not
                     * being used for anything else. */
                    if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 4005e10:	e0bffc17 	ldw	r2,-16(fp)
 4005e14:	10800617 	ldw	r2,24(r2)
 4005e18:	10000516 	blt	r2,zero,4005e30 <vTaskPriorityDisinheritAfterTimeout+0xb8>
                    {
                        listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 4005e1c:	00c00144 	movi	r3,5
 4005e20:	e0bffd17 	ldw	r2,-12(fp)
 4005e24:	1887c83a 	sub	r3,r3,r2
 4005e28:	e0bffc17 	ldw	r2,-16(fp)
 4005e2c:	10c00615 	stw	r3,24(r2)
                     * then the task that holds the mutex could be in either the
                     * Ready, Blocked or Suspended states.  Only remove the task
                     * from its current state list if it is in the Ready state as
                     * the task's priority is going to change and there is one
                     * Ready list per priority. */
                    if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 4005e30:	e0bffc17 	ldw	r2,-16(fp)
 4005e34:	14000517 	ldw	r16,20(r2)
 4005e38:	01400504 	movi	r5,20
 4005e3c:	e13ffa17 	ldw	r4,-24(fp)
 4005e40:	40075a40 	call	40075a4 <__mulsi3>
 4005e44:	1007883a 	mov	r3,r2
 4005e48:	008120b4 	movhi	r2,1154
 4005e4c:	10baf404 	addi	r2,r2,-5168
 4005e50:	1885883a 	add	r2,r3,r2
 4005e54:	8080411e 	bne	r16,r2,4005f5c <vTaskPriorityDisinheritAfterTimeout+0x1e4>
                    {
                        if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4005e58:	e0bffc17 	ldw	r2,-16(fp)
 4005e5c:	10800104 	addi	r2,r2,4
 4005e60:	1009883a 	mov	r4,r2
 4005e64:	4000c980 	call	4000c98 <uxListRemove>
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }

                        prvAddTaskToReadyList( pxTCB );
 4005e68:	e0bffc17 	ldw	r2,-16(fp)
 4005e6c:	10800b17 	ldw	r2,44(r2)
 4005e70:	d0e71917 	ldw	r3,-25500(gp)
 4005e74:	1880032e 	bgeu	r3,r2,4005e84 <vTaskPriorityDisinheritAfterTimeout+0x10c>
 4005e78:	e0bffc17 	ldw	r2,-16(fp)
 4005e7c:	10800b17 	ldw	r2,44(r2)
 4005e80:	d0a71915 	stw	r2,-25500(gp)
 4005e84:	e0bffc17 	ldw	r2,-16(fp)
 4005e88:	10800b17 	ldw	r2,44(r2)
 4005e8c:	01400504 	movi	r5,20
 4005e90:	1009883a 	mov	r4,r2
 4005e94:	40075a40 	call	40075a4 <__mulsi3>
 4005e98:	1007883a 	mov	r3,r2
 4005e9c:	008120b4 	movhi	r2,1154
 4005ea0:	1885883a 	add	r2,r3,r2
 4005ea4:	10baf517 	ldw	r2,-5164(r2)
 4005ea8:	e0bff915 	stw	r2,-28(fp)
 4005eac:	e0bffc17 	ldw	r2,-16(fp)
 4005eb0:	e0fff917 	ldw	r3,-28(fp)
 4005eb4:	10c00215 	stw	r3,8(r2)
 4005eb8:	e0bff917 	ldw	r2,-28(fp)
 4005ebc:	10c00217 	ldw	r3,8(r2)
 4005ec0:	e0bffc17 	ldw	r2,-16(fp)
 4005ec4:	10c00315 	stw	r3,12(r2)
 4005ec8:	e0bff917 	ldw	r2,-28(fp)
 4005ecc:	10800217 	ldw	r2,8(r2)
 4005ed0:	e0fffc17 	ldw	r3,-16(fp)
 4005ed4:	18c00104 	addi	r3,r3,4
 4005ed8:	10c00115 	stw	r3,4(r2)
 4005edc:	e0bffc17 	ldw	r2,-16(fp)
 4005ee0:	10c00104 	addi	r3,r2,4
 4005ee4:	e0bff917 	ldw	r2,-28(fp)
 4005ee8:	10c00215 	stw	r3,8(r2)
 4005eec:	e0bffc17 	ldw	r2,-16(fp)
 4005ef0:	10800b17 	ldw	r2,44(r2)
 4005ef4:	01400504 	movi	r5,20
 4005ef8:	1009883a 	mov	r4,r2
 4005efc:	40075a40 	call	40075a4 <__mulsi3>
 4005f00:	1007883a 	mov	r3,r2
 4005f04:	008120b4 	movhi	r2,1154
 4005f08:	10baf404 	addi	r2,r2,-5168
 4005f0c:	1887883a 	add	r3,r3,r2
 4005f10:	e0bffc17 	ldw	r2,-16(fp)
 4005f14:	10c00515 	stw	r3,20(r2)
 4005f18:	e0bffc17 	ldw	r2,-16(fp)
 4005f1c:	14400b17 	ldw	r17,44(r2)
 4005f20:	01400504 	movi	r5,20
 4005f24:	8809883a 	mov	r4,r17
 4005f28:	40075a40 	call	40075a4 <__mulsi3>
 4005f2c:	1007883a 	mov	r3,r2
 4005f30:	008120b4 	movhi	r2,1154
 4005f34:	1885883a 	add	r2,r3,r2
 4005f38:	10baf417 	ldw	r2,-5168(r2)
 4005f3c:	14000044 	addi	r16,r2,1
 4005f40:	01400504 	movi	r5,20
 4005f44:	8809883a 	mov	r4,r17
 4005f48:	40075a40 	call	40075a4 <__mulsi3>
 4005f4c:	1007883a 	mov	r3,r2
 4005f50:	008120b4 	movhi	r2,1154
 4005f54:	1885883a 	add	r2,r3,r2
 4005f58:	143af415 	stw	r16,-5168(r2)
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
 4005f5c:	0001883a 	nop
 4005f60:	e6fffe04 	addi	sp,fp,-8
 4005f64:	dfc00317 	ldw	ra,12(sp)
 4005f68:	df000217 	ldw	fp,8(sp)
 4005f6c:	dc400117 	ldw	r17,4(sp)
 4005f70:	dc000017 	ldw	r16,0(sp)
 4005f74:	dec00404 	addi	sp,sp,16
 4005f78:	f800283a 	ret

04005f7c <vTaskEnterCritical>:
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

    void vTaskEnterCritical( void )
    {
 4005f7c:	defffe04 	addi	sp,sp,-8
 4005f80:	df000115 	stw	fp,4(sp)
 4005f84:	df000104 	addi	fp,sp,4
  NIOS2_READ_STATUS (context);
 4005f88:	0005303a 	rdctl	r2,status
 4005f8c:	e0bfff15 	stw	r2,-4(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 4005f90:	e0ffff17 	ldw	r3,-4(fp)
 4005f94:	00bfff84 	movi	r2,-2
 4005f98:	1884703a 	and	r2,r3,r2
 4005f9c:	1001703a 	wrctl	status,r2
        portDISABLE_INTERRUPTS();

        if( xSchedulerRunning != pdFALSE )
 4005fa0:	d0a71a17 	ldw	r2,-25496(gp)
 4005fa4:	10000526 	beq	r2,zero,4005fbc <vTaskEnterCritical+0x40>
        {
            ( pxCurrentTCB->uxCriticalNesting )++;
 4005fa8:	d0a71317 	ldw	r2,-25524(gp)
 4005fac:	10c00f17 	ldw	r3,60(r2)
 4005fb0:	18c00044 	addi	r3,r3,1
 4005fb4:	10c00f15 	stw	r3,60(r2)
             * function so  assert() if it is being called from an interrupt
             * context.  Only API functions that end in "FromISR" can be used in an
             * interrupt.  Only assert if the critical nesting count is 1 to
             * protect against recursive calls if the assert function also uses a
             * critical section. */
            if( pxCurrentTCB->uxCriticalNesting == 1 )
 4005fb8:	d0a71317 	ldw	r2,-25524(gp)
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
 4005fbc:	0001883a 	nop
 4005fc0:	e037883a 	mov	sp,fp
 4005fc4:	df000017 	ldw	fp,0(sp)
 4005fc8:	dec00104 	addi	sp,sp,4
 4005fcc:	f800283a 	ret

04005fd0 <vTaskExitCritical>:
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

    void vTaskExitCritical( void )
    {
 4005fd0:	defffe04 	addi	sp,sp,-8
 4005fd4:	df000115 	stw	fp,4(sp)
 4005fd8:	df000104 	addi	fp,sp,4
        if( xSchedulerRunning != pdFALSE )
 4005fdc:	d0a71a17 	ldw	r2,-25496(gp)
 4005fe0:	10000f26 	beq	r2,zero,4006020 <vTaskExitCritical+0x50>
        {
            if( pxCurrentTCB->uxCriticalNesting > 0U )
 4005fe4:	d0a71317 	ldw	r2,-25524(gp)
 4005fe8:	10800f17 	ldw	r2,60(r2)
 4005fec:	10000c26 	beq	r2,zero,4006020 <vTaskExitCritical+0x50>
            {
                ( pxCurrentTCB->uxCriticalNesting )--;
 4005ff0:	d0a71317 	ldw	r2,-25524(gp)
 4005ff4:	10c00f17 	ldw	r3,60(r2)
 4005ff8:	18ffffc4 	addi	r3,r3,-1
 4005ffc:	10c00f15 	stw	r3,60(r2)

                if( pxCurrentTCB->uxCriticalNesting == 0U )
 4006000:	d0a71317 	ldw	r2,-25524(gp)
 4006004:	10800f17 	ldw	r2,60(r2)
 4006008:	1000051e 	bne	r2,zero,4006020 <vTaskExitCritical+0x50>
 400600c:	00800044 	movi	r2,1
 4006010:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 4006014:	e0bfff17 	ldw	r2,-4(fp)
 4006018:	1001703a 	wrctl	status,r2
#endif
}
 400601c:	0001883a 	nop
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
 4006020:	0001883a 	nop
 4006024:	e037883a 	mov	sp,fp
 4006028:	df000017 	ldw	fp,0(sp)
 400602c:	dec00104 	addi	sp,sp,4
 4006030:	f800283a 	ret

04006034 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
 4006034:	defffe04 	addi	sp,sp,-8
 4006038:	df000115 	stw	fp,4(sp)
 400603c:	df000104 	addi	fp,sp,4
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 4006040:	d0a71317 	ldw	r2,-25524(gp)
 4006044:	10800617 	ldw	r2,24(r2)
 4006048:	e0bfff15 	stw	r2,-4(fp)

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 400604c:	d0a71317 	ldw	r2,-25524(gp)
 4006050:	10c00b17 	ldw	r3,44(r2)
 4006054:	d0a71317 	ldw	r2,-25524(gp)
 4006058:	01000144 	movi	r4,5
 400605c:	20c7c83a 	sub	r3,r4,r3
 4006060:	10c00615 	stw	r3,24(r2)

    return uxReturn;
 4006064:	e0bfff17 	ldw	r2,-4(fp)
}
 4006068:	e037883a 	mov	sp,fp
 400606c:	df000017 	ldw	fp,0(sp)
 4006070:	dec00104 	addi	sp,sp,4
 4006074:	f800283a 	ret

04006078 <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    TaskHandle_t pvTaskIncrementMutexHeldCount( void )
    {
 4006078:	deffff04 	addi	sp,sp,-4
 400607c:	df000015 	stw	fp,0(sp)
 4006080:	d839883a 	mov	fp,sp
        /* If xSemaphoreCreateMutex() is called before any tasks have been created
         * then pxCurrentTCB will be NULL. */
        if( pxCurrentTCB != NULL )
 4006084:	d0a71317 	ldw	r2,-25524(gp)
 4006088:	10000426 	beq	r2,zero,400609c <pvTaskIncrementMutexHeldCount+0x24>
        {
            ( pxCurrentTCB->uxMutexesHeld )++;
 400608c:	d0a71317 	ldw	r2,-25524(gp)
 4006090:	10c01117 	ldw	r3,68(r2)
 4006094:	18c00044 	addi	r3,r3,1
 4006098:	10c01115 	stw	r3,68(r2)
        }

        return pxCurrentTCB;
 400609c:	d0a71317 	ldw	r2,-25524(gp)
    }
 40060a0:	e037883a 	mov	sp,fp
 40060a4:	df000017 	ldw	fp,0(sp)
 40060a8:	dec00104 	addi	sp,sp,4
 40060ac:	f800283a 	ret

040060b0 <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
 40060b0:	defffa04 	addi	sp,sp,-24
 40060b4:	dfc00515 	stw	ra,20(sp)
 40060b8:	df000415 	stw	fp,16(sp)
 40060bc:	df000404 	addi	fp,sp,16
 40060c0:	e13ffe15 	stw	r4,-8(fp)
 40060c4:	e17ffd15 	stw	r5,-12(fp)
 40060c8:	e1bffc15 	stw	r6,-16(fp)
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
 40060cc:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
 40060d0:	d0e71317 	ldw	r3,-25524(gp)
 40060d4:	e0bffe17 	ldw	r2,-8(fp)
 40060d8:	10800484 	addi	r2,r2,18
 40060dc:	100490ba 	slli	r2,r2,2
 40060e0:	1885883a 	add	r2,r3,r2
 40060e4:	10800017 	ldw	r2,0(r2)
 40060e8:	10000b1e 	bne	r2,zero,4006118 <ulTaskGenericNotifyTake+0x68>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
 40060ec:	d0e71317 	ldw	r3,-25524(gp)
 40060f0:	e0bffe17 	ldw	r2,-8(fp)
 40060f4:	1885883a 	add	r2,r3,r2
 40060f8:	00c00044 	movi	r3,1
 40060fc:	10c01305 	stb	r3,76(r2)

                if( xTicksToWait > ( TickType_t ) 0 )
 4006100:	e0bffc17 	ldw	r2,-16(fp)
 4006104:	10000426 	beq	r2,zero,4006118 <ulTaskGenericNotifyTake+0x68>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 4006108:	01400044 	movi	r5,1
 400610c:	e13ffc17 	ldw	r4,-16(fp)
 4006110:	4006e3c0 	call	4006e3c <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
 4006114:	003b683a 	trap	0
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
 4006118:	4005fd00 	call	4005fd0 <vTaskExitCritical>

        taskENTER_CRITICAL();
 400611c:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
 4006120:	d0e71317 	ldw	r3,-25524(gp)
 4006124:	e0bffe17 	ldw	r2,-8(fp)
 4006128:	10800484 	addi	r2,r2,18
 400612c:	100490ba 	slli	r2,r2,2
 4006130:	1885883a 	add	r2,r3,r2
 4006134:	10800017 	ldw	r2,0(r2)
 4006138:	e0bfff15 	stw	r2,-4(fp)

            if( ulReturn != 0UL )
 400613c:	e0bfff17 	ldw	r2,-4(fp)
 4006140:	10001126 	beq	r2,zero,4006188 <ulTaskGenericNotifyTake+0xd8>
            {
                if( xClearCountOnExit != pdFALSE )
 4006144:	e0bffd17 	ldw	r2,-12(fp)
 4006148:	10000726 	beq	r2,zero,4006168 <ulTaskGenericNotifyTake+0xb8>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
 400614c:	d0e71317 	ldw	r3,-25524(gp)
 4006150:	e0bffe17 	ldw	r2,-8(fp)
 4006154:	10800484 	addi	r2,r2,18
 4006158:	100490ba 	slli	r2,r2,2
 400615c:	1885883a 	add	r2,r3,r2
 4006160:	10000015 	stw	zero,0(r2)
 4006164:	00000806 	br	4006188 <ulTaskGenericNotifyTake+0xd8>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
 4006168:	d1271317 	ldw	r4,-25524(gp)
 400616c:	e0bfff17 	ldw	r2,-4(fp)
 4006170:	10ffffc4 	addi	r3,r2,-1
 4006174:	e0bffe17 	ldw	r2,-8(fp)
 4006178:	10800484 	addi	r2,r2,18
 400617c:	100490ba 	slli	r2,r2,2
 4006180:	2085883a 	add	r2,r4,r2
 4006184:	10c00015 	stw	r3,0(r2)
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
 4006188:	d0e71317 	ldw	r3,-25524(gp)
 400618c:	e0bffe17 	ldw	r2,-8(fp)
 4006190:	1885883a 	add	r2,r3,r2
 4006194:	10001305 	stb	zero,76(r2)
        }
        taskEXIT_CRITICAL();
 4006198:	4005fd00 	call	4005fd0 <vTaskExitCritical>

        return ulReturn;
 400619c:	e0bfff17 	ldw	r2,-4(fp)
    }
 40061a0:	e037883a 	mov	sp,fp
 40061a4:	dfc00117 	ldw	ra,4(sp)
 40061a8:	df000017 	ldw	fp,0(sp)
 40061ac:	dec00204 	addi	sp,sp,8
 40061b0:	f800283a 	ret

040061b4 <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
 40061b4:	defff904 	addi	sp,sp,-28
 40061b8:	dfc00615 	stw	ra,24(sp)
 40061bc:	df000515 	stw	fp,20(sp)
 40061c0:	df000504 	addi	fp,sp,20
 40061c4:	e13ffe15 	stw	r4,-8(fp)
 40061c8:	e17ffd15 	stw	r5,-12(fp)
 40061cc:	e1bffc15 	stw	r6,-16(fp)
 40061d0:	e1fffb15 	stw	r7,-20(fp)
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
 40061d4:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
 40061d8:	d0e71317 	ldw	r3,-25524(gp)
 40061dc:	e0bffe17 	ldw	r2,-8(fp)
 40061e0:	1885883a 	add	r2,r3,r2
 40061e4:	10801303 	ldbu	r2,76(r2)
 40061e8:	10803fcc 	andi	r2,r2,255
 40061ec:	108000a0 	cmpeqi	r2,r2,2
 40061f0:	1000191e 	bne	r2,zero,4006258 <xTaskGenericNotifyWait+0xa4>
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
 40061f4:	d0a71317 	ldw	r2,-25524(gp)
 40061f8:	e0fffe17 	ldw	r3,-8(fp)
 40061fc:	18c00484 	addi	r3,r3,18
 4006200:	180690ba 	slli	r3,r3,2
 4006204:	10c7883a 	add	r3,r2,r3
 4006208:	19000017 	ldw	r4,0(r3)
 400620c:	e0fffd17 	ldw	r3,-12(fp)
 4006210:	00c6303a 	nor	r3,zero,r3
 4006214:	20c6703a 	and	r3,r4,r3
 4006218:	e13ffe17 	ldw	r4,-8(fp)
 400621c:	21000484 	addi	r4,r4,18
 4006220:	200890ba 	slli	r4,r4,2
 4006224:	1105883a 	add	r2,r2,r4
 4006228:	10c00015 	stw	r3,0(r2)

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
 400622c:	d0e71317 	ldw	r3,-25524(gp)
 4006230:	e0bffe17 	ldw	r2,-8(fp)
 4006234:	1885883a 	add	r2,r3,r2
 4006238:	00c00044 	movi	r3,1
 400623c:	10c01305 	stb	r3,76(r2)

                if( xTicksToWait > ( TickType_t ) 0 )
 4006240:	e0800217 	ldw	r2,8(fp)
 4006244:	10000426 	beq	r2,zero,4006258 <xTaskGenericNotifyWait+0xa4>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 4006248:	01400044 	movi	r5,1
 400624c:	e1000217 	ldw	r4,8(fp)
 4006250:	4006e3c0 	call	4006e3c <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
 4006254:	003b683a 	trap	0
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
 4006258:	4005fd00 	call	4005fd0 <vTaskExitCritical>

        taskENTER_CRITICAL();
 400625c:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
 4006260:	e0bffb17 	ldw	r2,-20(fp)
 4006264:	10000826 	beq	r2,zero,4006288 <xTaskGenericNotifyWait+0xd4>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
 4006268:	d0e71317 	ldw	r3,-25524(gp)
 400626c:	e0bffe17 	ldw	r2,-8(fp)
 4006270:	10800484 	addi	r2,r2,18
 4006274:	100490ba 	slli	r2,r2,2
 4006278:	1885883a 	add	r2,r3,r2
 400627c:	10c00017 	ldw	r3,0(r2)
 4006280:	e0bffb17 	ldw	r2,-20(fp)
 4006284:	10c00015 	stw	r3,0(r2)

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
 4006288:	d0e71317 	ldw	r3,-25524(gp)
 400628c:	e0bffe17 	ldw	r2,-8(fp)
 4006290:	1885883a 	add	r2,r3,r2
 4006294:	10801303 	ldbu	r2,76(r2)
 4006298:	10803fcc 	andi	r2,r2,255
 400629c:	108000a0 	cmpeqi	r2,r2,2
 40062a0:	1000021e 	bne	r2,zero,40062ac <xTaskGenericNotifyWait+0xf8>
            {
                /* A notification was not received. */
                xReturn = pdFALSE;
 40062a4:	e03fff15 	stw	zero,-4(fp)
 40062a8:	00001006 	br	40062ec <xTaskGenericNotifyWait+0x138>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
 40062ac:	d0a71317 	ldw	r2,-25524(gp)
 40062b0:	e0fffe17 	ldw	r3,-8(fp)
 40062b4:	18c00484 	addi	r3,r3,18
 40062b8:	180690ba 	slli	r3,r3,2
 40062bc:	10c7883a 	add	r3,r2,r3
 40062c0:	19000017 	ldw	r4,0(r3)
 40062c4:	e0fffc17 	ldw	r3,-16(fp)
 40062c8:	00c6303a 	nor	r3,zero,r3
 40062cc:	20c6703a 	and	r3,r4,r3
 40062d0:	e13ffe17 	ldw	r4,-8(fp)
 40062d4:	21000484 	addi	r4,r4,18
 40062d8:	200890ba 	slli	r4,r4,2
 40062dc:	1105883a 	add	r2,r2,r4
 40062e0:	10c00015 	stw	r3,0(r2)
                xReturn = pdTRUE;
 40062e4:	00800044 	movi	r2,1
 40062e8:	e0bfff15 	stw	r2,-4(fp)
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
 40062ec:	d0e71317 	ldw	r3,-25524(gp)
 40062f0:	e0bffe17 	ldw	r2,-8(fp)
 40062f4:	1885883a 	add	r2,r3,r2
 40062f8:	10001305 	stb	zero,76(r2)
        }
        taskEXIT_CRITICAL();
 40062fc:	4005fd00 	call	4005fd0 <vTaskExitCritical>

        return xReturn;
 4006300:	e0bfff17 	ldw	r2,-4(fp)
    }
 4006304:	e037883a 	mov	sp,fp
 4006308:	dfc00117 	ldw	ra,4(sp)
 400630c:	df000017 	ldw	fp,0(sp)
 4006310:	dec00204 	addi	sp,sp,8
 4006314:	f800283a 	ret

04006318 <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
 4006318:	defff304 	addi	sp,sp,-52
 400631c:	dfc00c15 	stw	ra,48(sp)
 4006320:	df000b15 	stw	fp,44(sp)
 4006324:	dc400a15 	stw	r17,40(sp)
 4006328:	dc000915 	stw	r16,36(sp)
 400632c:	df000b04 	addi	fp,sp,44
 4006330:	e13ff815 	stw	r4,-32(fp)
 4006334:	e17ff715 	stw	r5,-36(fp)
 4006338:	e1bff615 	stw	r6,-40(fp)
 400633c:	e1fff515 	stw	r7,-44(fp)
        TCB_t * pxTCB;
        BaseType_t xReturn = pdPASS;
 4006340:	00800044 	movi	r2,1
 4006344:	e0bffd15 	stw	r2,-12(fp)
        uint8_t ucOriginalNotifyState;

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;
 4006348:	e0bff817 	ldw	r2,-32(fp)
 400634c:	e0bffc15 	stw	r2,-16(fp)

        taskENTER_CRITICAL();
 4006350:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
        {
            if( pulPreviousNotificationValue != NULL )
 4006354:	e0800217 	ldw	r2,8(fp)
 4006358:	10000826 	beq	r2,zero,400637c <xTaskGenericNotify+0x64>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
 400635c:	e0fffc17 	ldw	r3,-16(fp)
 4006360:	e0bff717 	ldw	r2,-36(fp)
 4006364:	10800484 	addi	r2,r2,18
 4006368:	100490ba 	slli	r2,r2,2
 400636c:	1885883a 	add	r2,r3,r2
 4006370:	10c00017 	ldw	r3,0(r2)
 4006374:	e0800217 	ldw	r2,8(fp)
 4006378:	10c00015 	stw	r3,0(r2)
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 400637c:	e0fffc17 	ldw	r3,-16(fp)
 4006380:	e0bff717 	ldw	r2,-36(fp)
 4006384:	1885883a 	add	r2,r3,r2
 4006388:	10801303 	ldbu	r2,76(r2)
 400638c:	e0bffbc5 	stb	r2,-17(fp)

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 4006390:	e0fffc17 	ldw	r3,-16(fp)
 4006394:	e0bff717 	ldw	r2,-36(fp)
 4006398:	1885883a 	add	r2,r3,r2
 400639c:	00c00084 	movi	r3,2
 40063a0:	10c01305 	stb	r3,76(r2)
 40063a4:	e0bff517 	ldw	r2,-44(fp)
 40063a8:	10800168 	cmpgeui	r2,r2,5
 40063ac:	10003d1e 	bne	r2,zero,40064a4 <xTaskGenericNotify+0x18c>
 40063b0:	e0bff517 	ldw	r2,-44(fp)
 40063b4:	100690ba 	slli	r3,r2,2
 40063b8:	00810034 	movhi	r2,1024
 40063bc:	1885883a 	add	r2,r3,r2
 40063c0:	1098f217 	ldw	r2,25544(r2)
 40063c4:	1000683a 	jmp	r2
 40063c8:	040064ac 	andhi	r16,zero,402
 40063cc:	040063dc 	xori	r16,zero,399
 40063d0:	04006418 	cmpnei	r16,zero,400
 40063d4:	04006450 	cmplti	r16,zero,401
 40063d8:	04006470 	cmpltui	r16,zero,401

            switch( eAction )
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
 40063dc:	e0fffc17 	ldw	r3,-16(fp)
 40063e0:	e0bff717 	ldw	r2,-36(fp)
 40063e4:	10800484 	addi	r2,r2,18
 40063e8:	100490ba 	slli	r2,r2,2
 40063ec:	1885883a 	add	r2,r3,r2
 40063f0:	10c00017 	ldw	r3,0(r2)
 40063f4:	e0bff617 	ldw	r2,-40(fp)
 40063f8:	1886b03a 	or	r3,r3,r2
 40063fc:	e13ffc17 	ldw	r4,-16(fp)
 4006400:	e0bff717 	ldw	r2,-36(fp)
 4006404:	10800484 	addi	r2,r2,18
 4006408:	100490ba 	slli	r2,r2,2
 400640c:	2085883a 	add	r2,r4,r2
 4006410:	10c00015 	stw	r3,0(r2)
                    break;
 4006414:	00002606 	br	40064b0 <xTaskGenericNotify+0x198>

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
 4006418:	e0fffc17 	ldw	r3,-16(fp)
 400641c:	e0bff717 	ldw	r2,-36(fp)
 4006420:	10800484 	addi	r2,r2,18
 4006424:	100490ba 	slli	r2,r2,2
 4006428:	1885883a 	add	r2,r3,r2
 400642c:	10800017 	ldw	r2,0(r2)
 4006430:	10c00044 	addi	r3,r2,1
 4006434:	e13ffc17 	ldw	r4,-16(fp)
 4006438:	e0bff717 	ldw	r2,-36(fp)
 400643c:	10800484 	addi	r2,r2,18
 4006440:	100490ba 	slli	r2,r2,2
 4006444:	2085883a 	add	r2,r4,r2
 4006448:	10c00015 	stw	r3,0(r2)
                    break;
 400644c:	00001806 	br	40064b0 <xTaskGenericNotify+0x198>

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 4006450:	e0fffc17 	ldw	r3,-16(fp)
 4006454:	e0bff717 	ldw	r2,-36(fp)
 4006458:	10800484 	addi	r2,r2,18
 400645c:	100490ba 	slli	r2,r2,2
 4006460:	1885883a 	add	r2,r3,r2
 4006464:	e0fff617 	ldw	r3,-40(fp)
 4006468:	10c00015 	stw	r3,0(r2)
                    break;
 400646c:	00001006 	br	40064b0 <xTaskGenericNotify+0x198>

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 4006470:	e0bffbc3 	ldbu	r2,-17(fp)
 4006474:	108000a0 	cmpeqi	r2,r2,2
 4006478:	1000081e 	bne	r2,zero,400649c <xTaskGenericNotify+0x184>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 400647c:	e0fffc17 	ldw	r3,-16(fp)
 4006480:	e0bff717 	ldw	r2,-36(fp)
 4006484:	10800484 	addi	r2,r2,18
 4006488:	100490ba 	slli	r2,r2,2
 400648c:	1885883a 	add	r2,r3,r2
 4006490:	e0fff617 	ldw	r3,-40(fp)
 4006494:	10c00015 	stw	r3,0(r2)
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
                    }

                    break;
 4006498:	00000506 	br	40064b0 <xTaskGenericNotify+0x198>
                        xReturn = pdFAIL;
 400649c:	e03ffd15 	stw	zero,-12(fp)
                    break;
 40064a0:	00000306 	br	40064b0 <xTaskGenericNotify+0x198>
                    /* Should not get here if all enums are handled.
                     * Artificially force an assert by testing a value the
                     * compiler can't assume is const. */
                    configASSERT( xTickCount == ( TickType_t ) 0 );

                    break;
 40064a4:	0001883a 	nop
 40064a8:	00000106 	br	40064b0 <xTaskGenericNotify+0x198>
                    break;
 40064ac:	0001883a 	nop

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 40064b0:	e0bffbc3 	ldbu	r2,-17(fp)
 40064b4:	10800058 	cmpnei	r2,r2,1
 40064b8:	1000601e 	bne	r2,zero,400663c <xTaskGenericNotify+0x324>
            {
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 40064bc:	e0bffc17 	ldw	r2,-16(fp)
 40064c0:	10800517 	ldw	r2,20(r2)
 40064c4:	e0bffa15 	stw	r2,-24(fp)
 40064c8:	e0bffc17 	ldw	r2,-16(fp)
 40064cc:	10800217 	ldw	r2,8(r2)
 40064d0:	e0fffc17 	ldw	r3,-16(fp)
 40064d4:	18c00317 	ldw	r3,12(r3)
 40064d8:	10c00215 	stw	r3,8(r2)
 40064dc:	e0bffc17 	ldw	r2,-16(fp)
 40064e0:	10800317 	ldw	r2,12(r2)
 40064e4:	e0fffc17 	ldw	r3,-16(fp)
 40064e8:	18c00217 	ldw	r3,8(r3)
 40064ec:	10c00115 	stw	r3,4(r2)
 40064f0:	e0bffa17 	ldw	r2,-24(fp)
 40064f4:	10c00117 	ldw	r3,4(r2)
 40064f8:	e0bffc17 	ldw	r2,-16(fp)
 40064fc:	10800104 	addi	r2,r2,4
 4006500:	1880041e 	bne	r3,r2,4006514 <xTaskGenericNotify+0x1fc>
 4006504:	e0bffc17 	ldw	r2,-16(fp)
 4006508:	10c00317 	ldw	r3,12(r2)
 400650c:	e0bffa17 	ldw	r2,-24(fp)
 4006510:	10c00115 	stw	r3,4(r2)
 4006514:	e0bffc17 	ldw	r2,-16(fp)
 4006518:	10000515 	stw	zero,20(r2)
 400651c:	e0bffa17 	ldw	r2,-24(fp)
 4006520:	10800017 	ldw	r2,0(r2)
 4006524:	10ffffc4 	addi	r3,r2,-1
 4006528:	e0bffa17 	ldw	r2,-24(fp)
 400652c:	10c00015 	stw	r3,0(r2)
                prvAddTaskToReadyList( pxTCB );
 4006530:	e0bffc17 	ldw	r2,-16(fp)
 4006534:	10800b17 	ldw	r2,44(r2)
 4006538:	d0e71917 	ldw	r3,-25500(gp)
 400653c:	1880032e 	bgeu	r3,r2,400654c <xTaskGenericNotify+0x234>
 4006540:	e0bffc17 	ldw	r2,-16(fp)
 4006544:	10800b17 	ldw	r2,44(r2)
 4006548:	d0a71915 	stw	r2,-25500(gp)
 400654c:	e0bffc17 	ldw	r2,-16(fp)
 4006550:	10800b17 	ldw	r2,44(r2)
 4006554:	01400504 	movi	r5,20
 4006558:	1009883a 	mov	r4,r2
 400655c:	40075a40 	call	40075a4 <__mulsi3>
 4006560:	1007883a 	mov	r3,r2
 4006564:	008120b4 	movhi	r2,1154
 4006568:	1885883a 	add	r2,r3,r2
 400656c:	10baf517 	ldw	r2,-5164(r2)
 4006570:	e0bff915 	stw	r2,-28(fp)
 4006574:	e0bffc17 	ldw	r2,-16(fp)
 4006578:	e0fff917 	ldw	r3,-28(fp)
 400657c:	10c00215 	stw	r3,8(r2)
 4006580:	e0bff917 	ldw	r2,-28(fp)
 4006584:	10c00217 	ldw	r3,8(r2)
 4006588:	e0bffc17 	ldw	r2,-16(fp)
 400658c:	10c00315 	stw	r3,12(r2)
 4006590:	e0bff917 	ldw	r2,-28(fp)
 4006594:	10800217 	ldw	r2,8(r2)
 4006598:	e0fffc17 	ldw	r3,-16(fp)
 400659c:	18c00104 	addi	r3,r3,4
 40065a0:	10c00115 	stw	r3,4(r2)
 40065a4:	e0bffc17 	ldw	r2,-16(fp)
 40065a8:	10c00104 	addi	r3,r2,4
 40065ac:	e0bff917 	ldw	r2,-28(fp)
 40065b0:	10c00215 	stw	r3,8(r2)
 40065b4:	e0bffc17 	ldw	r2,-16(fp)
 40065b8:	10800b17 	ldw	r2,44(r2)
 40065bc:	01400504 	movi	r5,20
 40065c0:	1009883a 	mov	r4,r2
 40065c4:	40075a40 	call	40075a4 <__mulsi3>
 40065c8:	1007883a 	mov	r3,r2
 40065cc:	008120b4 	movhi	r2,1154
 40065d0:	10baf404 	addi	r2,r2,-5168
 40065d4:	1887883a 	add	r3,r3,r2
 40065d8:	e0bffc17 	ldw	r2,-16(fp)
 40065dc:	10c00515 	stw	r3,20(r2)
 40065e0:	e0bffc17 	ldw	r2,-16(fp)
 40065e4:	14400b17 	ldw	r17,44(r2)
 40065e8:	01400504 	movi	r5,20
 40065ec:	8809883a 	mov	r4,r17
 40065f0:	40075a40 	call	40075a4 <__mulsi3>
 40065f4:	1007883a 	mov	r3,r2
 40065f8:	008120b4 	movhi	r2,1154
 40065fc:	1885883a 	add	r2,r3,r2
 4006600:	10baf417 	ldw	r2,-5168(r2)
 4006604:	14000044 	addi	r16,r2,1
 4006608:	01400504 	movi	r5,20
 400660c:	8809883a 	mov	r4,r17
 4006610:	40075a40 	call	40075a4 <__mulsi3>
 4006614:	1007883a 	mov	r3,r2
 4006618:	008120b4 	movhi	r2,1154
 400661c:	1885883a 	add	r2,r3,r2
 4006620:	143af415 	stw	r16,-5168(r2)
                     * earliest possible time. */
                    prvResetNextTaskUnblockTime();
                }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 4006624:	e0bffc17 	ldw	r2,-16(fp)
 4006628:	10800b17 	ldw	r2,44(r2)
 400662c:	d0e71317 	ldw	r3,-25524(gp)
 4006630:	18c00b17 	ldw	r3,44(r3)
 4006634:	1880012e 	bgeu	r3,r2,400663c <xTaskGenericNotify+0x324>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
 4006638:	003b683a 	trap	0
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
 400663c:	4005fd00 	call	4005fd0 <vTaskExitCritical>

        return xReturn;
 4006640:	e0bffd17 	ldw	r2,-12(fp)
    }
 4006644:	e6fffe04 	addi	sp,fp,-8
 4006648:	dfc00317 	ldw	ra,12(sp)
 400664c:	df000217 	ldw	fp,8(sp)
 4006650:	dc400117 	ldw	r17,4(sp)
 4006654:	dc000017 	ldw	r16,0(sp)
 4006658:	dec00404 	addi	sp,sp,16
 400665c:	f800283a 	ret

04006660 <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
 4006660:	defff104 	addi	sp,sp,-60
 4006664:	dfc00e15 	stw	ra,56(sp)
 4006668:	df000d15 	stw	fp,52(sp)
 400666c:	dc400c15 	stw	r17,48(sp)
 4006670:	dc000b15 	stw	r16,44(sp)
 4006674:	df000d04 	addi	fp,sp,52
 4006678:	e13ff615 	stw	r4,-40(fp)
 400667c:	e17ff515 	stw	r5,-44(fp)
 4006680:	e1bff415 	stw	r6,-48(fp)
 4006684:	e1fff315 	stw	r7,-52(fp)
        TCB_t * pxTCB;
        uint8_t ucOriginalNotifyState;
        BaseType_t xReturn = pdPASS;
 4006688:	00800044 	movi	r2,1
 400668c:	e0bffd15 	stw	r2,-12(fp)
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
 4006690:	e0bff617 	ldw	r2,-40(fp)
 4006694:	e0bffc15 	stw	r2,-16(fp)

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4006698:	e03ffb15 	stw	zero,-20(fp)
        {
            if( pulPreviousNotificationValue != NULL )
 400669c:	e0800217 	ldw	r2,8(fp)
 40066a0:	10000826 	beq	r2,zero,40066c4 <xTaskGenericNotifyFromISR+0x64>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
 40066a4:	e0fffc17 	ldw	r3,-16(fp)
 40066a8:	e0bff517 	ldw	r2,-44(fp)
 40066ac:	10800484 	addi	r2,r2,18
 40066b0:	100490ba 	slli	r2,r2,2
 40066b4:	1885883a 	add	r2,r3,r2
 40066b8:	10c00017 	ldw	r3,0(r2)
 40066bc:	e0800217 	ldw	r2,8(fp)
 40066c0:	10c00015 	stw	r3,0(r2)
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 40066c4:	e0fffc17 	ldw	r3,-16(fp)
 40066c8:	e0bff517 	ldw	r2,-44(fp)
 40066cc:	1885883a 	add	r2,r3,r2
 40066d0:	10801303 	ldbu	r2,76(r2)
 40066d4:	e0bffac5 	stb	r2,-21(fp)
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 40066d8:	e0fffc17 	ldw	r3,-16(fp)
 40066dc:	e0bff517 	ldw	r2,-44(fp)
 40066e0:	1885883a 	add	r2,r3,r2
 40066e4:	00c00084 	movi	r3,2
 40066e8:	10c01305 	stb	r3,76(r2)
 40066ec:	e0bff317 	ldw	r2,-52(fp)
 40066f0:	10800168 	cmpgeui	r2,r2,5
 40066f4:	10003d1e 	bne	r2,zero,40067ec <xTaskGenericNotifyFromISR+0x18c>
 40066f8:	e0bff317 	ldw	r2,-52(fp)
 40066fc:	100690ba 	slli	r3,r2,2
 4006700:	00810034 	movhi	r2,1024
 4006704:	1885883a 	add	r2,r3,r2
 4006708:	1099c417 	ldw	r2,26384(r2)
 400670c:	1000683a 	jmp	r2
 4006710:	040067f4 	movhi	r16,415
 4006714:	04006724 	muli	r16,zero,412
 4006718:	04006760 	cmpeqi	r16,zero,413
 400671c:	04006798 	cmpnei	r16,zero,414
 4006720:	040067b8 	rdprs	r16,zero,414

            switch( eAction )
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
 4006724:	e0fffc17 	ldw	r3,-16(fp)
 4006728:	e0bff517 	ldw	r2,-44(fp)
 400672c:	10800484 	addi	r2,r2,18
 4006730:	100490ba 	slli	r2,r2,2
 4006734:	1885883a 	add	r2,r3,r2
 4006738:	10c00017 	ldw	r3,0(r2)
 400673c:	e0bff417 	ldw	r2,-48(fp)
 4006740:	1886b03a 	or	r3,r3,r2
 4006744:	e13ffc17 	ldw	r4,-16(fp)
 4006748:	e0bff517 	ldw	r2,-44(fp)
 400674c:	10800484 	addi	r2,r2,18
 4006750:	100490ba 	slli	r2,r2,2
 4006754:	2085883a 	add	r2,r4,r2
 4006758:	10c00015 	stw	r3,0(r2)
                    break;
 400675c:	00002606 	br	40067f8 <xTaskGenericNotifyFromISR+0x198>

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
 4006760:	e0fffc17 	ldw	r3,-16(fp)
 4006764:	e0bff517 	ldw	r2,-44(fp)
 4006768:	10800484 	addi	r2,r2,18
 400676c:	100490ba 	slli	r2,r2,2
 4006770:	1885883a 	add	r2,r3,r2
 4006774:	10800017 	ldw	r2,0(r2)
 4006778:	10c00044 	addi	r3,r2,1
 400677c:	e13ffc17 	ldw	r4,-16(fp)
 4006780:	e0bff517 	ldw	r2,-44(fp)
 4006784:	10800484 	addi	r2,r2,18
 4006788:	100490ba 	slli	r2,r2,2
 400678c:	2085883a 	add	r2,r4,r2
 4006790:	10c00015 	stw	r3,0(r2)
                    break;
 4006794:	00001806 	br	40067f8 <xTaskGenericNotifyFromISR+0x198>

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 4006798:	e0fffc17 	ldw	r3,-16(fp)
 400679c:	e0bff517 	ldw	r2,-44(fp)
 40067a0:	10800484 	addi	r2,r2,18
 40067a4:	100490ba 	slli	r2,r2,2
 40067a8:	1885883a 	add	r2,r3,r2
 40067ac:	e0fff417 	ldw	r3,-48(fp)
 40067b0:	10c00015 	stw	r3,0(r2)
                    break;
 40067b4:	00001006 	br	40067f8 <xTaskGenericNotifyFromISR+0x198>

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 40067b8:	e0bffac3 	ldbu	r2,-21(fp)
 40067bc:	108000a0 	cmpeqi	r2,r2,2
 40067c0:	1000081e 	bne	r2,zero,40067e4 <xTaskGenericNotifyFromISR+0x184>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 40067c4:	e0fffc17 	ldw	r3,-16(fp)
 40067c8:	e0bff517 	ldw	r2,-44(fp)
 40067cc:	10800484 	addi	r2,r2,18
 40067d0:	100490ba 	slli	r2,r2,2
 40067d4:	1885883a 	add	r2,r3,r2
 40067d8:	e0fff417 	ldw	r3,-48(fp)
 40067dc:	10c00015 	stw	r3,0(r2)
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
                    }

                    break;
 40067e0:	00000506 	br	40067f8 <xTaskGenericNotifyFromISR+0x198>
                        xReturn = pdFAIL;
 40067e4:	e03ffd15 	stw	zero,-12(fp)
                    break;
 40067e8:	00000306 	br	40067f8 <xTaskGenericNotifyFromISR+0x198>

                    /* Should not get here if all enums are handled.
                     * Artificially force an assert by testing a value the
                     * compiler can't assume is const. */
                    configASSERT( xTickCount == ( TickType_t ) 0 );
                    break;
 40067ec:	0001883a 	nop
 40067f0:	00000106 	br	40067f8 <xTaskGenericNotifyFromISR+0x198>
                    break;
 40067f4:	0001883a 	nop

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 40067f8:	e0bffac3 	ldbu	r2,-21(fp)
 40067fc:	10800058 	cmpnei	r2,r2,1
 4006800:	1000851e 	bne	r2,zero,4006a18 <xTaskGenericNotifyFromISR+0x3b8>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 4006804:	d0a72117 	ldw	r2,-25468(gp)
 4006808:	10005b1e 	bne	r2,zero,4006978 <xTaskGenericNotifyFromISR+0x318>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 400680c:	e0bffc17 	ldw	r2,-16(fp)
 4006810:	10800517 	ldw	r2,20(r2)
 4006814:	e0bff815 	stw	r2,-32(fp)
 4006818:	e0bffc17 	ldw	r2,-16(fp)
 400681c:	10800217 	ldw	r2,8(r2)
 4006820:	e0fffc17 	ldw	r3,-16(fp)
 4006824:	18c00317 	ldw	r3,12(r3)
 4006828:	10c00215 	stw	r3,8(r2)
 400682c:	e0bffc17 	ldw	r2,-16(fp)
 4006830:	10800317 	ldw	r2,12(r2)
 4006834:	e0fffc17 	ldw	r3,-16(fp)
 4006838:	18c00217 	ldw	r3,8(r3)
 400683c:	10c00115 	stw	r3,4(r2)
 4006840:	e0bff817 	ldw	r2,-32(fp)
 4006844:	10c00117 	ldw	r3,4(r2)
 4006848:	e0bffc17 	ldw	r2,-16(fp)
 400684c:	10800104 	addi	r2,r2,4
 4006850:	1880041e 	bne	r3,r2,4006864 <xTaskGenericNotifyFromISR+0x204>
 4006854:	e0bffc17 	ldw	r2,-16(fp)
 4006858:	10c00317 	ldw	r3,12(r2)
 400685c:	e0bff817 	ldw	r2,-32(fp)
 4006860:	10c00115 	stw	r3,4(r2)
 4006864:	e0bffc17 	ldw	r2,-16(fp)
 4006868:	10000515 	stw	zero,20(r2)
 400686c:	e0bff817 	ldw	r2,-32(fp)
 4006870:	10800017 	ldw	r2,0(r2)
 4006874:	10ffffc4 	addi	r3,r2,-1
 4006878:	e0bff817 	ldw	r2,-32(fp)
 400687c:	10c00015 	stw	r3,0(r2)
                    prvAddTaskToReadyList( pxTCB );
 4006880:	e0bffc17 	ldw	r2,-16(fp)
 4006884:	10800b17 	ldw	r2,44(r2)
 4006888:	d0e71917 	ldw	r3,-25500(gp)
 400688c:	1880032e 	bgeu	r3,r2,400689c <xTaskGenericNotifyFromISR+0x23c>
 4006890:	e0bffc17 	ldw	r2,-16(fp)
 4006894:	10800b17 	ldw	r2,44(r2)
 4006898:	d0a71915 	stw	r2,-25500(gp)
 400689c:	e0bffc17 	ldw	r2,-16(fp)
 40068a0:	10800b17 	ldw	r2,44(r2)
 40068a4:	01400504 	movi	r5,20
 40068a8:	1009883a 	mov	r4,r2
 40068ac:	40075a40 	call	40075a4 <__mulsi3>
 40068b0:	1007883a 	mov	r3,r2
 40068b4:	008120b4 	movhi	r2,1154
 40068b8:	1885883a 	add	r2,r3,r2
 40068bc:	10baf517 	ldw	r2,-5164(r2)
 40068c0:	e0bff715 	stw	r2,-36(fp)
 40068c4:	e0bffc17 	ldw	r2,-16(fp)
 40068c8:	e0fff717 	ldw	r3,-36(fp)
 40068cc:	10c00215 	stw	r3,8(r2)
 40068d0:	e0bff717 	ldw	r2,-36(fp)
 40068d4:	10c00217 	ldw	r3,8(r2)
 40068d8:	e0bffc17 	ldw	r2,-16(fp)
 40068dc:	10c00315 	stw	r3,12(r2)
 40068e0:	e0bff717 	ldw	r2,-36(fp)
 40068e4:	10800217 	ldw	r2,8(r2)
 40068e8:	e0fffc17 	ldw	r3,-16(fp)
 40068ec:	18c00104 	addi	r3,r3,4
 40068f0:	10c00115 	stw	r3,4(r2)
 40068f4:	e0bffc17 	ldw	r2,-16(fp)
 40068f8:	10c00104 	addi	r3,r2,4
 40068fc:	e0bff717 	ldw	r2,-36(fp)
 4006900:	10c00215 	stw	r3,8(r2)
 4006904:	e0bffc17 	ldw	r2,-16(fp)
 4006908:	10800b17 	ldw	r2,44(r2)
 400690c:	01400504 	movi	r5,20
 4006910:	1009883a 	mov	r4,r2
 4006914:	40075a40 	call	40075a4 <__mulsi3>
 4006918:	1007883a 	mov	r3,r2
 400691c:	008120b4 	movhi	r2,1154
 4006920:	10baf404 	addi	r2,r2,-5168
 4006924:	1887883a 	add	r3,r3,r2
 4006928:	e0bffc17 	ldw	r2,-16(fp)
 400692c:	10c00515 	stw	r3,20(r2)
 4006930:	e0bffc17 	ldw	r2,-16(fp)
 4006934:	14400b17 	ldw	r17,44(r2)
 4006938:	01400504 	movi	r5,20
 400693c:	8809883a 	mov	r4,r17
 4006940:	40075a40 	call	40075a4 <__mulsi3>
 4006944:	1007883a 	mov	r3,r2
 4006948:	008120b4 	movhi	r2,1154
 400694c:	1885883a 	add	r2,r3,r2
 4006950:	10baf417 	ldw	r2,-5168(r2)
 4006954:	14000044 	addi	r16,r2,1
 4006958:	01400504 	movi	r5,20
 400695c:	8809883a 	mov	r4,r17
 4006960:	40075a40 	call	40075a4 <__mulsi3>
 4006964:	1007883a 	mov	r3,r2
 4006968:	008120b4 	movhi	r2,1154
 400696c:	1885883a 	add	r2,r3,r2
 4006970:	143af415 	stw	r16,-5168(r2)
 4006974:	00001c06 	br	40069e8 <xTaskGenericNotifyFromISR+0x388>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 4006978:	008120b4 	movhi	r2,1154
 400697c:	10bb1817 	ldw	r2,-5024(r2)
 4006980:	e0bff915 	stw	r2,-28(fp)
 4006984:	e0bffc17 	ldw	r2,-16(fp)
 4006988:	e0fff917 	ldw	r3,-28(fp)
 400698c:	10c00715 	stw	r3,28(r2)
 4006990:	e0bff917 	ldw	r2,-28(fp)
 4006994:	10c00217 	ldw	r3,8(r2)
 4006998:	e0bffc17 	ldw	r2,-16(fp)
 400699c:	10c00815 	stw	r3,32(r2)
 40069a0:	e0bff917 	ldw	r2,-28(fp)
 40069a4:	10800217 	ldw	r2,8(r2)
 40069a8:	e0fffc17 	ldw	r3,-16(fp)
 40069ac:	18c00604 	addi	r3,r3,24
 40069b0:	10c00115 	stw	r3,4(r2)
 40069b4:	e0bffc17 	ldw	r2,-16(fp)
 40069b8:	10c00604 	addi	r3,r2,24
 40069bc:	e0bff917 	ldw	r2,-28(fp)
 40069c0:	10c00215 	stw	r3,8(r2)
 40069c4:	e0fffc17 	ldw	r3,-16(fp)
 40069c8:	008120b4 	movhi	r2,1154
 40069cc:	10bb1704 	addi	r2,r2,-5028
 40069d0:	18800a15 	stw	r2,40(r3)
 40069d4:	008120b4 	movhi	r2,1154
 40069d8:	10bb1717 	ldw	r2,-5028(r2)
 40069dc:	10c00044 	addi	r3,r2,1
 40069e0:	008120b4 	movhi	r2,1154
 40069e4:	10fb1715 	stw	r3,-5028(r2)
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 40069e8:	e0bffc17 	ldw	r2,-16(fp)
 40069ec:	10800b17 	ldw	r2,44(r2)
 40069f0:	d0e71317 	ldw	r3,-25524(gp)
 40069f4:	18c00b17 	ldw	r3,44(r3)
 40069f8:	1880072e 	bgeu	r3,r2,4006a18 <xTaskGenericNotifyFromISR+0x3b8>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
 40069fc:	e0800317 	ldw	r2,12(fp)
 4006a00:	10000326 	beq	r2,zero,4006a10 <xTaskGenericNotifyFromISR+0x3b0>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
 4006a04:	e0800317 	ldw	r2,12(fp)
 4006a08:	00c00044 	movi	r3,1
 4006a0c:	10c00015 	stw	r3,0(r2)
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
 4006a10:	00800044 	movi	r2,1
 4006a14:	d0a71c15 	stw	r2,-25488(gp)
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
 4006a18:	e0bffd17 	ldw	r2,-12(fp)
    }
 4006a1c:	e6fffe04 	addi	sp,fp,-8
 4006a20:	dfc00317 	ldw	ra,12(sp)
 4006a24:	df000217 	ldw	fp,8(sp)
 4006a28:	dc400117 	ldw	r17,4(sp)
 4006a2c:	dc000017 	ldw	r16,0(sp)
 4006a30:	dec00404 	addi	sp,sp,16
 4006a34:	f800283a 	ret

04006a38 <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
 4006a38:	defff304 	addi	sp,sp,-52
 4006a3c:	dfc00c15 	stw	ra,48(sp)
 4006a40:	df000b15 	stw	fp,44(sp)
 4006a44:	dc400a15 	stw	r17,40(sp)
 4006a48:	dc000915 	stw	r16,36(sp)
 4006a4c:	df000b04 	addi	fp,sp,44
 4006a50:	e13ff715 	stw	r4,-36(fp)
 4006a54:	e17ff615 	stw	r5,-40(fp)
 4006a58:	e1bff515 	stw	r6,-44(fp)
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
 4006a5c:	e0bff717 	ldw	r2,-36(fp)
 4006a60:	e0bffd15 	stw	r2,-12(fp)

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4006a64:	e03ffc15 	stw	zero,-16(fp)
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 4006a68:	e0fffd17 	ldw	r3,-12(fp)
 4006a6c:	e0bff617 	ldw	r2,-40(fp)
 4006a70:	1885883a 	add	r2,r3,r2
 4006a74:	10801303 	ldbu	r2,76(r2)
 4006a78:	e0bffbc5 	stb	r2,-17(fp)
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 4006a7c:	e0fffd17 	ldw	r3,-12(fp)
 4006a80:	e0bff617 	ldw	r2,-40(fp)
 4006a84:	1885883a 	add	r2,r3,r2
 4006a88:	00c00084 	movi	r3,2
 4006a8c:	10c01305 	stb	r3,76(r2)

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
 4006a90:	e0fffd17 	ldw	r3,-12(fp)
 4006a94:	e0bff617 	ldw	r2,-40(fp)
 4006a98:	10800484 	addi	r2,r2,18
 4006a9c:	100490ba 	slli	r2,r2,2
 4006aa0:	1885883a 	add	r2,r3,r2
 4006aa4:	10800017 	ldw	r2,0(r2)
 4006aa8:	10c00044 	addi	r3,r2,1
 4006aac:	e13ffd17 	ldw	r4,-12(fp)
 4006ab0:	e0bff617 	ldw	r2,-40(fp)
 4006ab4:	10800484 	addi	r2,r2,18
 4006ab8:	100490ba 	slli	r2,r2,2
 4006abc:	2085883a 	add	r2,r4,r2
 4006ac0:	10c00015 	stw	r3,0(r2)

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 4006ac4:	e0bffbc3 	ldbu	r2,-17(fp)
 4006ac8:	10800058 	cmpnei	r2,r2,1
 4006acc:	1000851e 	bne	r2,zero,4006ce4 <vTaskGenericNotifyGiveFromISR+0x2ac>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 4006ad0:	d0a72117 	ldw	r2,-25468(gp)
 4006ad4:	10005b1e 	bne	r2,zero,4006c44 <vTaskGenericNotifyGiveFromISR+0x20c>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 4006ad8:	e0bffd17 	ldw	r2,-12(fp)
 4006adc:	10800517 	ldw	r2,20(r2)
 4006ae0:	e0bff915 	stw	r2,-28(fp)
 4006ae4:	e0bffd17 	ldw	r2,-12(fp)
 4006ae8:	10800217 	ldw	r2,8(r2)
 4006aec:	e0fffd17 	ldw	r3,-12(fp)
 4006af0:	18c00317 	ldw	r3,12(r3)
 4006af4:	10c00215 	stw	r3,8(r2)
 4006af8:	e0bffd17 	ldw	r2,-12(fp)
 4006afc:	10800317 	ldw	r2,12(r2)
 4006b00:	e0fffd17 	ldw	r3,-12(fp)
 4006b04:	18c00217 	ldw	r3,8(r3)
 4006b08:	10c00115 	stw	r3,4(r2)
 4006b0c:	e0bff917 	ldw	r2,-28(fp)
 4006b10:	10c00117 	ldw	r3,4(r2)
 4006b14:	e0bffd17 	ldw	r2,-12(fp)
 4006b18:	10800104 	addi	r2,r2,4
 4006b1c:	1880041e 	bne	r3,r2,4006b30 <vTaskGenericNotifyGiveFromISR+0xf8>
 4006b20:	e0bffd17 	ldw	r2,-12(fp)
 4006b24:	10c00317 	ldw	r3,12(r2)
 4006b28:	e0bff917 	ldw	r2,-28(fp)
 4006b2c:	10c00115 	stw	r3,4(r2)
 4006b30:	e0bffd17 	ldw	r2,-12(fp)
 4006b34:	10000515 	stw	zero,20(r2)
 4006b38:	e0bff917 	ldw	r2,-28(fp)
 4006b3c:	10800017 	ldw	r2,0(r2)
 4006b40:	10ffffc4 	addi	r3,r2,-1
 4006b44:	e0bff917 	ldw	r2,-28(fp)
 4006b48:	10c00015 	stw	r3,0(r2)
                    prvAddTaskToReadyList( pxTCB );
 4006b4c:	e0bffd17 	ldw	r2,-12(fp)
 4006b50:	10800b17 	ldw	r2,44(r2)
 4006b54:	d0e71917 	ldw	r3,-25500(gp)
 4006b58:	1880032e 	bgeu	r3,r2,4006b68 <vTaskGenericNotifyGiveFromISR+0x130>
 4006b5c:	e0bffd17 	ldw	r2,-12(fp)
 4006b60:	10800b17 	ldw	r2,44(r2)
 4006b64:	d0a71915 	stw	r2,-25500(gp)
 4006b68:	e0bffd17 	ldw	r2,-12(fp)
 4006b6c:	10800b17 	ldw	r2,44(r2)
 4006b70:	01400504 	movi	r5,20
 4006b74:	1009883a 	mov	r4,r2
 4006b78:	40075a40 	call	40075a4 <__mulsi3>
 4006b7c:	1007883a 	mov	r3,r2
 4006b80:	008120b4 	movhi	r2,1154
 4006b84:	1885883a 	add	r2,r3,r2
 4006b88:	10baf517 	ldw	r2,-5164(r2)
 4006b8c:	e0bff815 	stw	r2,-32(fp)
 4006b90:	e0bffd17 	ldw	r2,-12(fp)
 4006b94:	e0fff817 	ldw	r3,-32(fp)
 4006b98:	10c00215 	stw	r3,8(r2)
 4006b9c:	e0bff817 	ldw	r2,-32(fp)
 4006ba0:	10c00217 	ldw	r3,8(r2)
 4006ba4:	e0bffd17 	ldw	r2,-12(fp)
 4006ba8:	10c00315 	stw	r3,12(r2)
 4006bac:	e0bff817 	ldw	r2,-32(fp)
 4006bb0:	10800217 	ldw	r2,8(r2)
 4006bb4:	e0fffd17 	ldw	r3,-12(fp)
 4006bb8:	18c00104 	addi	r3,r3,4
 4006bbc:	10c00115 	stw	r3,4(r2)
 4006bc0:	e0bffd17 	ldw	r2,-12(fp)
 4006bc4:	10c00104 	addi	r3,r2,4
 4006bc8:	e0bff817 	ldw	r2,-32(fp)
 4006bcc:	10c00215 	stw	r3,8(r2)
 4006bd0:	e0bffd17 	ldw	r2,-12(fp)
 4006bd4:	10800b17 	ldw	r2,44(r2)
 4006bd8:	01400504 	movi	r5,20
 4006bdc:	1009883a 	mov	r4,r2
 4006be0:	40075a40 	call	40075a4 <__mulsi3>
 4006be4:	1007883a 	mov	r3,r2
 4006be8:	008120b4 	movhi	r2,1154
 4006bec:	10baf404 	addi	r2,r2,-5168
 4006bf0:	1887883a 	add	r3,r3,r2
 4006bf4:	e0bffd17 	ldw	r2,-12(fp)
 4006bf8:	10c00515 	stw	r3,20(r2)
 4006bfc:	e0bffd17 	ldw	r2,-12(fp)
 4006c00:	14400b17 	ldw	r17,44(r2)
 4006c04:	01400504 	movi	r5,20
 4006c08:	8809883a 	mov	r4,r17
 4006c0c:	40075a40 	call	40075a4 <__mulsi3>
 4006c10:	1007883a 	mov	r3,r2
 4006c14:	008120b4 	movhi	r2,1154
 4006c18:	1885883a 	add	r2,r3,r2
 4006c1c:	10baf417 	ldw	r2,-5168(r2)
 4006c20:	14000044 	addi	r16,r2,1
 4006c24:	01400504 	movi	r5,20
 4006c28:	8809883a 	mov	r4,r17
 4006c2c:	40075a40 	call	40075a4 <__mulsi3>
 4006c30:	1007883a 	mov	r3,r2
 4006c34:	008120b4 	movhi	r2,1154
 4006c38:	1885883a 	add	r2,r3,r2
 4006c3c:	143af415 	stw	r16,-5168(r2)
 4006c40:	00001c06 	br	4006cb4 <vTaskGenericNotifyGiveFromISR+0x27c>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 4006c44:	008120b4 	movhi	r2,1154
 4006c48:	10bb1817 	ldw	r2,-5024(r2)
 4006c4c:	e0bffa15 	stw	r2,-24(fp)
 4006c50:	e0bffd17 	ldw	r2,-12(fp)
 4006c54:	e0fffa17 	ldw	r3,-24(fp)
 4006c58:	10c00715 	stw	r3,28(r2)
 4006c5c:	e0bffa17 	ldw	r2,-24(fp)
 4006c60:	10c00217 	ldw	r3,8(r2)
 4006c64:	e0bffd17 	ldw	r2,-12(fp)
 4006c68:	10c00815 	stw	r3,32(r2)
 4006c6c:	e0bffa17 	ldw	r2,-24(fp)
 4006c70:	10800217 	ldw	r2,8(r2)
 4006c74:	e0fffd17 	ldw	r3,-12(fp)
 4006c78:	18c00604 	addi	r3,r3,24
 4006c7c:	10c00115 	stw	r3,4(r2)
 4006c80:	e0bffd17 	ldw	r2,-12(fp)
 4006c84:	10c00604 	addi	r3,r2,24
 4006c88:	e0bffa17 	ldw	r2,-24(fp)
 4006c8c:	10c00215 	stw	r3,8(r2)
 4006c90:	e0fffd17 	ldw	r3,-12(fp)
 4006c94:	008120b4 	movhi	r2,1154
 4006c98:	10bb1704 	addi	r2,r2,-5028
 4006c9c:	18800a15 	stw	r2,40(r3)
 4006ca0:	008120b4 	movhi	r2,1154
 4006ca4:	10bb1717 	ldw	r2,-5028(r2)
 4006ca8:	10c00044 	addi	r3,r2,1
 4006cac:	008120b4 	movhi	r2,1154
 4006cb0:	10fb1715 	stw	r3,-5028(r2)
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 4006cb4:	e0bffd17 	ldw	r2,-12(fp)
 4006cb8:	10800b17 	ldw	r2,44(r2)
 4006cbc:	d0e71317 	ldw	r3,-25524(gp)
 4006cc0:	18c00b17 	ldw	r3,44(r3)
 4006cc4:	1880072e 	bgeu	r3,r2,4006ce4 <vTaskGenericNotifyGiveFromISR+0x2ac>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
 4006cc8:	e0bff517 	ldw	r2,-44(fp)
 4006ccc:	10000326 	beq	r2,zero,4006cdc <vTaskGenericNotifyGiveFromISR+0x2a4>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
 4006cd0:	e0bff517 	ldw	r2,-44(fp)
 4006cd4:	00c00044 	movi	r3,1
 4006cd8:	10c00015 	stw	r3,0(r2)
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
 4006cdc:	00800044 	movi	r2,1
 4006ce0:	d0a71c15 	stw	r2,-25488(gp)
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
 4006ce4:	0001883a 	nop
 4006ce8:	e6fffe04 	addi	sp,fp,-8
 4006cec:	dfc00317 	ldw	ra,12(sp)
 4006cf0:	df000217 	ldw	fp,8(sp)
 4006cf4:	dc400117 	ldw	r17,4(sp)
 4006cf8:	dc000017 	ldw	r16,0(sp)
 4006cfc:	dec00404 	addi	sp,sp,16
 4006d00:	f800283a 	ret

04006d04 <xTaskGenericNotifyStateClear>:

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                             UBaseType_t uxIndexToClear )
    {
 4006d04:	defffa04 	addi	sp,sp,-24
 4006d08:	dfc00515 	stw	ra,20(sp)
 4006d0c:	df000415 	stw	fp,16(sp)
 4006d10:	df000404 	addi	fp,sp,16
 4006d14:	e13ffd15 	stw	r4,-12(fp)
 4006d18:	e17ffc15 	stw	r5,-16(fp)

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
 4006d1c:	e0bffd17 	ldw	r2,-12(fp)
 4006d20:	1000021e 	bne	r2,zero,4006d2c <xTaskGenericNotifyStateClear+0x28>
 4006d24:	d0a71317 	ldw	r2,-25524(gp)
 4006d28:	00000106 	br	4006d30 <xTaskGenericNotifyStateClear+0x2c>
 4006d2c:	e0bffd17 	ldw	r2,-12(fp)
 4006d30:	e0bffe15 	stw	r2,-8(fp)

        taskENTER_CRITICAL();
 4006d34:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
 4006d38:	e0fffe17 	ldw	r3,-8(fp)
 4006d3c:	e0bffc17 	ldw	r2,-16(fp)
 4006d40:	1885883a 	add	r2,r3,r2
 4006d44:	10801303 	ldbu	r2,76(r2)
 4006d48:	10803fcc 	andi	r2,r2,255
 4006d4c:	10800098 	cmpnei	r2,r2,2
 4006d50:	1000071e 	bne	r2,zero,4006d70 <xTaskGenericNotifyStateClear+0x6c>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
 4006d54:	e0fffe17 	ldw	r3,-8(fp)
 4006d58:	e0bffc17 	ldw	r2,-16(fp)
 4006d5c:	1885883a 	add	r2,r3,r2
 4006d60:	10001305 	stb	zero,76(r2)
                xReturn = pdPASS;
 4006d64:	00800044 	movi	r2,1
 4006d68:	e0bfff15 	stw	r2,-4(fp)
 4006d6c:	00000106 	br	4006d74 <xTaskGenericNotifyStateClear+0x70>
            }
            else
            {
                xReturn = pdFAIL;
 4006d70:	e03fff15 	stw	zero,-4(fp)
            }
        }
        taskEXIT_CRITICAL();
 4006d74:	4005fd00 	call	4005fd0 <vTaskExitCritical>

        return xReturn;
 4006d78:	e0bfff17 	ldw	r2,-4(fp)
    }
 4006d7c:	e037883a 	mov	sp,fp
 4006d80:	dfc00117 	ldw	ra,4(sp)
 4006d84:	df000017 	ldw	fp,0(sp)
 4006d88:	dec00204 	addi	sp,sp,8
 4006d8c:	f800283a 	ret

04006d90 <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
 4006d90:	defff904 	addi	sp,sp,-28
 4006d94:	dfc00615 	stw	ra,24(sp)
 4006d98:	df000515 	stw	fp,20(sp)
 4006d9c:	df000504 	addi	fp,sp,20
 4006da0:	e13ffd15 	stw	r4,-12(fp)
 4006da4:	e17ffc15 	stw	r5,-16(fp)
 4006da8:	e1bffb15 	stw	r6,-20(fp)
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
 4006dac:	e0bffd17 	ldw	r2,-12(fp)
 4006db0:	1000021e 	bne	r2,zero,4006dbc <ulTaskGenericNotifyValueClear+0x2c>
 4006db4:	d0a71317 	ldw	r2,-25524(gp)
 4006db8:	00000106 	br	4006dc0 <ulTaskGenericNotifyValueClear+0x30>
 4006dbc:	e0bffd17 	ldw	r2,-12(fp)
 4006dc0:	e0bfff15 	stw	r2,-4(fp)

        taskENTER_CRITICAL();
 4006dc4:	4005f7c0 	call	4005f7c <vTaskEnterCritical>
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
 4006dc8:	e0ffff17 	ldw	r3,-4(fp)
 4006dcc:	e0bffc17 	ldw	r2,-16(fp)
 4006dd0:	10800484 	addi	r2,r2,18
 4006dd4:	100490ba 	slli	r2,r2,2
 4006dd8:	1885883a 	add	r2,r3,r2
 4006ddc:	10800017 	ldw	r2,0(r2)
 4006de0:	e0bffe15 	stw	r2,-8(fp)
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
 4006de4:	e0ffff17 	ldw	r3,-4(fp)
 4006de8:	e0bffc17 	ldw	r2,-16(fp)
 4006dec:	10800484 	addi	r2,r2,18
 4006df0:	100490ba 	slli	r2,r2,2
 4006df4:	1885883a 	add	r2,r3,r2
 4006df8:	10c00017 	ldw	r3,0(r2)
 4006dfc:	e0bffb17 	ldw	r2,-20(fp)
 4006e00:	0084303a 	nor	r2,zero,r2
 4006e04:	1886703a 	and	r3,r3,r2
 4006e08:	e13fff17 	ldw	r4,-4(fp)
 4006e0c:	e0bffc17 	ldw	r2,-16(fp)
 4006e10:	10800484 	addi	r2,r2,18
 4006e14:	100490ba 	slli	r2,r2,2
 4006e18:	2085883a 	add	r2,r4,r2
 4006e1c:	10c00015 	stw	r3,0(r2)
        }
        taskEXIT_CRITICAL();
 4006e20:	4005fd00 	call	4005fd0 <vTaskExitCritical>

        return ulReturn;
 4006e24:	e0bffe17 	ldw	r2,-8(fp)
    }
 4006e28:	e037883a 	mov	sp,fp
 4006e2c:	dfc00117 	ldw	ra,4(sp)
 4006e30:	df000017 	ldw	fp,0(sp)
 4006e34:	dec00204 	addi	sp,sp,8
 4006e38:	f800283a 	ret

04006e3c <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
 4006e3c:	defff904 	addi	sp,sp,-28
 4006e40:	dfc00615 	stw	ra,24(sp)
 4006e44:	df000515 	stw	fp,20(sp)
 4006e48:	df000504 	addi	fp,sp,20
 4006e4c:	e13ffc15 	stw	r4,-16(fp)
 4006e50:	e17ffb15 	stw	r5,-20(fp)
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
 4006e54:	d0a71817 	ldw	r2,-25504(gp)
 4006e58:	e0bfff15 	stw	r2,-4(fp)
    }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4006e5c:	d0a71317 	ldw	r2,-25524(gp)
 4006e60:	10800104 	addi	r2,r2,4
 4006e64:	1009883a 	mov	r4,r2
 4006e68:	4000c980 	call	4000c98 <uxListRemove>
        mtCOVERAGE_TEST_MARKER();
    }

    #if ( INCLUDE_vTaskSuspend == 1 )
    {
        if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 4006e6c:	e0bffc17 	ldw	r2,-16(fp)
 4006e70:	10bfffd8 	cmpnei	r2,r2,-1
 4006e74:	1000201e 	bne	r2,zero,4006ef8 <prvAddCurrentTaskToDelayedList+0xbc>
 4006e78:	e0bffb17 	ldw	r2,-20(fp)
 4006e7c:	10001e26 	beq	r2,zero,4006ef8 <prvAddCurrentTaskToDelayedList+0xbc>
        {
            /* Add the task to the suspended task list instead of a delayed task
             * list to ensure it is not woken by a timing event.  It will block
             * indefinitely. */
            listINSERT_END( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 4006e80:	008120b4 	movhi	r2,1154
 4006e84:	10bb2217 	ldw	r2,-4984(r2)
 4006e88:	e0bffe15 	stw	r2,-8(fp)
 4006e8c:	d0a71317 	ldw	r2,-25524(gp)
 4006e90:	e0fffe17 	ldw	r3,-8(fp)
 4006e94:	10c00215 	stw	r3,8(r2)
 4006e98:	d0a71317 	ldw	r2,-25524(gp)
 4006e9c:	e0fffe17 	ldw	r3,-8(fp)
 4006ea0:	18c00217 	ldw	r3,8(r3)
 4006ea4:	10c00315 	stw	r3,12(r2)
 4006ea8:	d0e71317 	ldw	r3,-25524(gp)
 4006eac:	e0bffe17 	ldw	r2,-8(fp)
 4006eb0:	10800217 	ldw	r2,8(r2)
 4006eb4:	18c00104 	addi	r3,r3,4
 4006eb8:	10c00115 	stw	r3,4(r2)
 4006ebc:	d0a71317 	ldw	r2,-25524(gp)
 4006ec0:	10c00104 	addi	r3,r2,4
 4006ec4:	e0bffe17 	ldw	r2,-8(fp)
 4006ec8:	10c00215 	stw	r3,8(r2)
 4006ecc:	d0e71317 	ldw	r3,-25524(gp)
 4006ed0:	008120b4 	movhi	r2,1154
 4006ed4:	10bb2104 	addi	r2,r2,-4988
 4006ed8:	18800515 	stw	r2,20(r3)
 4006edc:	008120b4 	movhi	r2,1154
 4006ee0:	10bb2117 	ldw	r2,-4988(r2)
 4006ee4:	10c00044 	addi	r3,r2,1
 4006ee8:	008120b4 	movhi	r2,1154
 4006eec:	10fb2115 	stw	r3,-4988(r2)
 4006ef0:	0001883a 	nop

        /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
        ( void ) xCanBlockIndefinitely;
    }
    #endif /* INCLUDE_vTaskSuspend */
}
 4006ef4:	00001c06 	br	4006f68 <prvAddCurrentTaskToDelayedList+0x12c>
            xTimeToWake = xConstTickCount + xTicksToWait;
 4006ef8:	e0ffff17 	ldw	r3,-4(fp)
 4006efc:	e0bffc17 	ldw	r2,-16(fp)
 4006f00:	1885883a 	add	r2,r3,r2
 4006f04:	e0bffd15 	stw	r2,-12(fp)
            listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 4006f08:	d0a71317 	ldw	r2,-25524(gp)
 4006f0c:	e0fffd17 	ldw	r3,-12(fp)
 4006f10:	10c00115 	stw	r3,4(r2)
            if( xTimeToWake < xConstTickCount )
 4006f14:	e0fffd17 	ldw	r3,-12(fp)
 4006f18:	e0bfff17 	ldw	r2,-4(fp)
 4006f1c:	1880072e 	bgeu	r3,r2,4006f3c <prvAddCurrentTaskToDelayedList+0x100>
                vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 4006f20:	d0e71517 	ldw	r3,-25516(gp)
 4006f24:	d0a71317 	ldw	r2,-25524(gp)
 4006f28:	10800104 	addi	r2,r2,4
 4006f2c:	100b883a 	mov	r5,r2
 4006f30:	1809883a 	mov	r4,r3
 4006f34:	4000bc00 	call	4000bc0 <vListInsert>
}
 4006f38:	00000b06 	br	4006f68 <prvAddCurrentTaskToDelayedList+0x12c>
                vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 4006f3c:	d0e71417 	ldw	r3,-25520(gp)
 4006f40:	d0a71317 	ldw	r2,-25524(gp)
 4006f44:	10800104 	addi	r2,r2,4
 4006f48:	100b883a 	mov	r5,r2
 4006f4c:	1809883a 	mov	r4,r3
 4006f50:	4000bc00 	call	4000bc0 <vListInsert>
                if( xTimeToWake < xNextTaskUnblockTime )
 4006f54:	d0a71f17 	ldw	r2,-25476(gp)
 4006f58:	e0fffd17 	ldw	r3,-12(fp)
 4006f5c:	1880022e 	bgeu	r3,r2,4006f68 <prvAddCurrentTaskToDelayedList+0x12c>
                    xNextTaskUnblockTime = xTimeToWake;
 4006f60:	e0bffd17 	ldw	r2,-12(fp)
 4006f64:	d0a71f15 	stw	r2,-25476(gp)
}
 4006f68:	0001883a 	nop
 4006f6c:	e037883a 	mov	sp,fp
 4006f70:	dfc00117 	ldw	ra,4(sp)
 4006f74:	df000017 	ldw	fp,0(sp)
 4006f78:	dec00204 	addi	sp,sp,8
 4006f7c:	f800283a 	ret

04006f80 <convertData>:
#include "task.h"

int score = 0;

unsigned convertData( int x )
{
 4006f80:	defffe04 	addi	sp,sp,-8
 4006f84:	df000115 	stw	fp,4(sp)
 4006f88:	df000104 	addi	fp,sp,4
 4006f8c:	e13fff15 	stw	r4,-4(fp)
    if (x == 0)
 4006f90:	e0bfff17 	ldw	r2,-4(fp)
 4006f94:	1000021e 	bne	r2,zero,4006fa0 <convertData+0x20>
    {
      return 0b1000000;
 4006f98:	00801004 	movi	r2,64
 4006f9c:	00002e06 	br	4007058 <convertData+0xd8>
    }
    else if (x == 1)
 4006fa0:	e0bfff17 	ldw	r2,-4(fp)
 4006fa4:	10800058 	cmpnei	r2,r2,1
 4006fa8:	1000021e 	bne	r2,zero,4006fb4 <convertData+0x34>
    {
      return 0b1111001;
 4006fac:	00801e44 	movi	r2,121
 4006fb0:	00002906 	br	4007058 <convertData+0xd8>
    }
    else if (x == 2)
 4006fb4:	e0bfff17 	ldw	r2,-4(fp)
 4006fb8:	10800098 	cmpnei	r2,r2,2
 4006fbc:	1000021e 	bne	r2,zero,4006fc8 <convertData+0x48>
    {
      return 0b0100100;
 4006fc0:	00800904 	movi	r2,36
 4006fc4:	00002406 	br	4007058 <convertData+0xd8>
    }
    else if (x == 3)
 4006fc8:	e0bfff17 	ldw	r2,-4(fp)
 4006fcc:	108000d8 	cmpnei	r2,r2,3
 4006fd0:	1000021e 	bne	r2,zero,4006fdc <convertData+0x5c>
    {
      return 0b0110000;
 4006fd4:	00800c04 	movi	r2,48
 4006fd8:	00001f06 	br	4007058 <convertData+0xd8>
    }
    else if (x == 4)
 4006fdc:	e0bfff17 	ldw	r2,-4(fp)
 4006fe0:	10800118 	cmpnei	r2,r2,4
 4006fe4:	1000021e 	bne	r2,zero,4006ff0 <convertData+0x70>
    {
      return 0b00011001;
 4006fe8:	00800644 	movi	r2,25
 4006fec:	00001a06 	br	4007058 <convertData+0xd8>
    }
    else if (x == 5)
 4006ff0:	e0bfff17 	ldw	r2,-4(fp)
 4006ff4:	10800158 	cmpnei	r2,r2,5
 4006ff8:	1000021e 	bne	r2,zero,4007004 <convertData+0x84>
    {
      return 0b0010010;
 4006ffc:	00800484 	movi	r2,18
 4007000:	00001506 	br	4007058 <convertData+0xd8>
    }
    else if (x == 6)
 4007004:	e0bfff17 	ldw	r2,-4(fp)
 4007008:	10800198 	cmpnei	r2,r2,6
 400700c:	1000021e 	bne	r2,zero,4007018 <convertData+0x98>
    {
      return 0b0000010;
 4007010:	00800084 	movi	r2,2
 4007014:	00001006 	br	4007058 <convertData+0xd8>
    }
    else if (x == 7)
 4007018:	e0bfff17 	ldw	r2,-4(fp)
 400701c:	108001d8 	cmpnei	r2,r2,7
 4007020:	1000021e 	bne	r2,zero,400702c <convertData+0xac>
    {
      return 0b1111000;
 4007024:	00801e04 	movi	r2,120
 4007028:	00000b06 	br	4007058 <convertData+0xd8>
    }
    else if(x == 8)
 400702c:	e0bfff17 	ldw	r2,-4(fp)
 4007030:	10800218 	cmpnei	r2,r2,8
 4007034:	1000021e 	bne	r2,zero,4007040 <convertData+0xc0>
    {
      return 0b0000000;
 4007038:	0005883a 	mov	r2,zero
 400703c:	00000606 	br	4007058 <convertData+0xd8>
    }
    else if(x == 9)
 4007040:	e0bfff17 	ldw	r2,-4(fp)
 4007044:	10800258 	cmpnei	r2,r2,9
 4007048:	1000021e 	bne	r2,zero,4007054 <convertData+0xd4>
    {
      return 0b0011000;
 400704c:	00800604 	movi	r2,24
 4007050:	00000106 	br	4007058 <convertData+0xd8>
    }
  return 0;
 4007054:	0005883a 	mov	r2,zero
}
 4007058:	e037883a 	mov	sp,fp
 400705c:	df000017 	ldw	fp,0(sp)
 4007060:	dec00104 	addi	sp,sp,4
 4007064:	f800283a 	ret

04007068 <reversBits>:

uint32_t reversBits(uint32_t n) {
 4007068:	defffc04 	addi	sp,sp,-16
 400706c:	df000315 	stw	fp,12(sp)
 4007070:	df000304 	addi	fp,sp,12
 4007074:	e13ffd15 	stw	r4,-12(fp)
    uint32_t x = 0;
 4007078:	e03fff15 	stw	zero,-4(fp)
    int d = 0;
 400707c:	e03ffe15 	stw	zero,-8(fp)
    while(n>0){
 4007080:	00000f06 	br	40070c0 <reversBits+0x58>
        x+=(n%2) << (31-d);
 4007084:	e0bffd17 	ldw	r2,-12(fp)
 4007088:	10c0004c 	andi	r3,r2,1
 400708c:	010007c4 	movi	r4,31
 4007090:	e0bffe17 	ldw	r2,-8(fp)
 4007094:	2085c83a 	sub	r2,r4,r2
 4007098:	1884983a 	sll	r2,r3,r2
 400709c:	e0ffff17 	ldw	r3,-4(fp)
 40070a0:	1885883a 	add	r2,r3,r2
 40070a4:	e0bfff15 	stw	r2,-4(fp)
        n >>= 1;
 40070a8:	e0bffd17 	ldw	r2,-12(fp)
 40070ac:	1004d07a 	srli	r2,r2,1
 40070b0:	e0bffd15 	stw	r2,-12(fp)
        d++;
 40070b4:	e0bffe17 	ldw	r2,-8(fp)
 40070b8:	10800044 	addi	r2,r2,1
 40070bc:	e0bffe15 	stw	r2,-8(fp)
    while(n>0){
 40070c0:	e0bffd17 	ldw	r2,-12(fp)
 40070c4:	103fef1e 	bne	r2,zero,4007084 <reversBits+0x1c>
    }
    return x;
 40070c8:	e0bfff17 	ldw	r2,-4(fp)
}
 40070cc:	e037883a 	mov	sp,fp
 40070d0:	df000017 	ldw	fp,0(sp)
 40070d4:	dec00104 	addi	sp,sp,4
 40070d8:	f800283a 	ret

040070dc <writeScore>:

void writeScore(int s)
{
 40070dc:	defff604 	addi	sp,sp,-40
 40070e0:	dfc00915 	stw	ra,36(sp)
 40070e4:	df000815 	stw	fp,32(sp)
 40070e8:	df000804 	addi	fp,sp,32
 40070ec:	e13ff815 	stw	r4,-32(fp)
  int arr[6] = {0, 0, 0, 0, 0, 0};
 40070f0:	e03ff915 	stw	zero,-28(fp)
 40070f4:	e03ffa15 	stw	zero,-24(fp)
 40070f8:	e03ffb15 	stw	zero,-20(fp)
 40070fc:	e03ffc15 	stw	zero,-16(fp)
 4007100:	e03ffd15 	stw	zero,-12(fp)
 4007104:	e03ffe15 	stw	zero,-8(fp)
  for (int i = 0; i < 6; i++)
 4007108:	e03fff15 	stw	zero,-4(fp)
 400710c:	00001306 	br	400715c <writeScore+0x80>
  {
    arr[i] = s%10;
 4007110:	e0bff817 	ldw	r2,-32(fp)
 4007114:	01400284 	movi	r5,10
 4007118:	1009883a 	mov	r4,r2
 400711c:	40074700 	call	4007470 <__modsi3>
 4007120:	1007883a 	mov	r3,r2
 4007124:	e0bfff17 	ldw	r2,-4(fp)
 4007128:	100490ba 	slli	r2,r2,2
 400712c:	e085883a 	add	r2,fp,r2
 4007130:	10fff915 	stw	r3,-28(r2)
    s = s / 10;
 4007134:	e0bff817 	ldw	r2,-32(fp)
 4007138:	01400284 	movi	r5,10
 400713c:	1009883a 	mov	r4,r2
 4007140:	40073f00 	call	40073f0 <__divsi3>
 4007144:	e0bff815 	stw	r2,-32(fp)
    if (s == 0)
 4007148:	e0bff817 	ldw	r2,-32(fp)
 400714c:	10000726 	beq	r2,zero,400716c <writeScore+0x90>
  for (int i = 0; i < 6; i++)
 4007150:	e0bfff17 	ldw	r2,-4(fp)
 4007154:	10800044 	addi	r2,r2,1
 4007158:	e0bfff15 	stw	r2,-4(fp)
 400715c:	e0bfff17 	ldw	r2,-4(fp)
 4007160:	10800190 	cmplti	r2,r2,6
 4007164:	103fea1e 	bne	r2,zero,4007110 <writeScore+0x34>
 4007168:	00000106 	br	4007170 <writeScore+0x94>
    {
      break;
 400716c:	0001883a 	nop
    }
  }
  IOWR_ALTERA_AVALON_PIO_DATA(HEX_0_BASE, 0);
 4007170:	0007883a 	mov	r3,zero
 4007174:	00820034 	movhi	r2,2048
 4007178:	10c42435 	stwio	r3,4240(r2)
  IOWR_ALTERA_AVALON_PIO_DATA(HEX_1_BASE, 0);
 400717c:	0007883a 	mov	r3,zero
 4007180:	00820034 	movhi	r2,2048
 4007184:	10c42035 	stwio	r3,4224(r2)
  IOWR_ALTERA_AVALON_PIO_DATA(HEX_2_BASE, 0);
 4007188:	0007883a 	mov	r3,zero
 400718c:	00820034 	movhi	r2,2048
 4007190:	10c41c35 	stwio	r3,4208(r2)
  IOWR_ALTERA_AVALON_PIO_DATA(HEX_3_BASE, convertData(arr[3]));
 4007194:	e0bffc17 	ldw	r2,-16(fp)
 4007198:	1009883a 	mov	r4,r2
 400719c:	4006f800 	call	4006f80 <convertData>
 40071a0:	1007883a 	mov	r3,r2
 40071a4:	00820034 	movhi	r2,2048
 40071a8:	10c41835 	stwio	r3,4192(r2)
  IOWR_ALTERA_AVALON_PIO_DATA(HEX_4_BASE, convertData(arr[4]));
 40071ac:	e0bffd17 	ldw	r2,-12(fp)
 40071b0:	1009883a 	mov	r4,r2
 40071b4:	4006f800 	call	4006f80 <convertData>
 40071b8:	1007883a 	mov	r3,r2
 40071bc:	00820034 	movhi	r2,2048
 40071c0:	10c41435 	stwio	r3,4176(r2)
  IOWR_ALTERA_AVALON_PIO_DATA(HEX_5_BASE, convertData(arr[5]));
 40071c4:	e0bffe17 	ldw	r2,-8(fp)
 40071c8:	1009883a 	mov	r4,r2
 40071cc:	4006f800 	call	4006f80 <convertData>
 40071d0:	1007883a 	mov	r3,r2
 40071d4:	00820034 	movhi	r2,2048
 40071d8:	10c41035 	stwio	r3,4160(r2)
  // printf("str: %d\n", s);
}
 40071dc:	0001883a 	nop
 40071e0:	e037883a 	mov	sp,fp
 40071e4:	dfc00117 	ldw	ra,4(sp)
 40071e8:	df000017 	ldw	fp,0(sp)
 40071ec:	dec00204 	addi	sp,sp,8
 40071f0:	f800283a 	ret

040071f4 <sendReading>:




void sendReading ( alt_32 x ) 
{
 40071f4:	defffe04 	addi	sp,sp,-8
 40071f8:	df000115 	stw	fp,4(sp)
 40071fc:	df000104 	addi	fp,sp,4
 4007200:	e13fff15 	stw	r4,-4(fp)
  if ( IORD_ALTERA_AVALON_SPI_STATUS(ESP32_SPI_BASE) && 0b01000000 )
 4007204:	00820034 	movhi	r2,2048
 4007208:	10840a37 	ldwio	r2,4136(r2)
 400720c:	10000326 	beq	r2,zero,400721c <sendReading+0x28>
  {
    IOWR_ALTERA_AVALON_SPI_TXDATA(ESP32_SPI_BASE, (int) x);
 4007210:	e0ffff17 	ldw	r3,-4(fp)
 4007214:	00820034 	movhi	r2,2048
 4007218:	10c40935 	stwio	r3,4132(r2)
    // printf("txreg: %d\n", IORD_ALTERA_AVALON_SPI_TXDATA(ESP32_SPI_BASE));
    // printf("data: %ld\n", (x & 0b111111111));
  }
}
 400721c:	0001883a 	nop
 4007220:	e037883a 	mov	sp,fp
 4007224:	df000017 	ldw	fp,0(sp)
 4007228:	dec00104 	addi	sp,sp,4
 400722c:	f800283a 	ret

04007230 <getScore>:

unsigned getScore ()
{
 4007230:	defffe04 	addi	sp,sp,-8
 4007234:	dfc00115 	stw	ra,4(sp)
 4007238:	df000015 	stw	fp,0(sp)
 400723c:	d839883a 	mov	fp,sp
  if ( IORD_ALTERA_AVALON_SPI_STATUS(ESP32_SPI_BASE) && 0b010000000 )
 4007240:	00820034 	movhi	r2,2048
 4007244:	10840a37 	ldwio	r2,4136(r2)
 4007248:	10000526 	beq	r2,zero,4007260 <getScore+0x30>
  {
    return reversBits(IORD_ALTERA_AVALON_SPI_RXDATA(ESP32_SPI_BASE));
 400724c:	00820034 	movhi	r2,2048
 4007250:	10840837 	ldwio	r2,4128(r2)
 4007254:	1009883a 	mov	r4,r2
 4007258:	40070680 	call	4007068 <reversBits>
 400725c:	00000106 	br	4007264 <getScore+0x34>
    // printf("txreg: %d\n", IORD_ALTERA_AVALON_SPI_TXDATA(ESP32_SPI_BASE));
    // printf("data: %ld\n", (x & 0b111111111));
  }
  // score += 10;
  // return score;
  return 0;
 4007260:	0005883a 	mov	r2,zero
}
 4007264:	e037883a 	mov	sp,fp
 4007268:	dfc00117 	ldw	ra,4(sp)
 400726c:	df000017 	ldw	fp,0(sp)
 4007270:	dec00204 	addi	sp,sp,8
 4007274:	f800283a 	ret

04007278 <task1>:

void task1()
{
 4007278:	defffa04 	addi	sp,sp,-24
 400727c:	dfc00515 	stw	ra,20(sp)
 4007280:	df000415 	stw	fp,16(sp)
 4007284:	df000404 	addi	fp,sp,16

  alt_32 x_read, y_read;
  int buttons;
  alt_up_accelerometer_spi_dev *accDev;
  accDev = alt_up_accelerometer_spi_open_dev(ACCELEROMETER_SPI_NAME);
 4007288:	010100b4 	movhi	r4,1026
 400728c:	212af404 	addi	r4,r4,-21552
 4007290:	40198000 	call	4019800 <alt_up_accelerometer_spi_open_dev>
 4007294:	e0bfff15 	stw	r2,-4(fp)

  if ( accDev == NULL )
 4007298:	e0bfff17 	ldw	r2,-4(fp)
 400729c:	10002226 	beq	r2,zero,4007328 <task1+0xb0>
    return;
  } 

  while ( 1 )
  {
    buttons = (~IORD_ALTERA_AVALON_PIO_DATA(KEYS_0_BASE)) & 0x3;
 40072a0:	00820034 	movhi	r2,2048
 40072a4:	10842837 	ldwio	r2,4256(r2)
 40072a8:	0084303a 	nor	r2,zero,r2
 40072ac:	108000cc 	andi	r2,r2,3
 40072b0:	e0bffe15 	stw	r2,-8(fp)
    alt_up_accelerometer_spi_read_x_axis(accDev, &x_read);
 40072b4:	e0bffd04 	addi	r2,fp,-12
 40072b8:	100b883a 	mov	r5,r2
 40072bc:	e13fff17 	ldw	r4,-4(fp)
 40072c0:	40199500 	call	4019950 <alt_up_accelerometer_spi_read_x_axis>
    alt_up_accelerometer_spi_read_y_axis(accDev, &y_read);
 40072c4:	e0bffc04 	addi	r2,fp,-16
 40072c8:	100b883a 	mov	r5,r2
 40072cc:	e13fff17 	ldw	r4,-4(fp)
 40072d0:	4019a240 	call	4019a24 <alt_up_accelerometer_spi_read_y_axis>
    printf("%ld\n", x_read);
 40072d4:	e0bffd17 	ldw	r2,-12(fp)
 40072d8:	100b883a 	mov	r5,r2
 40072dc:	010100b4 	movhi	r4,1026
 40072e0:	212afa04 	addi	r4,r4,-21528
 40072e4:	400797c0 	call	400797c <printf>
    sendReading(((x_read & 0b1111111111) + ((y_read & 0b1111111111) << 9)) + (buttons << 24));
 40072e8:	e0bffd17 	ldw	r2,-12(fp)
 40072ec:	10c0ffcc 	andi	r3,r2,1023
 40072f0:	e0bffc17 	ldw	r2,-16(fp)
 40072f4:	1008927a 	slli	r4,r2,9
 40072f8:	00800234 	movhi	r2,8
 40072fc:	10bf8004 	addi	r2,r2,-512
 4007300:	2084703a 	and	r2,r4,r2
 4007304:	1887883a 	add	r3,r3,r2
 4007308:	e0bffe17 	ldw	r2,-8(fp)
 400730c:	1004963a 	slli	r2,r2,24
 4007310:	1885883a 	add	r2,r3,r2
 4007314:	1009883a 	mov	r4,r2
 4007318:	40071f40 	call	40071f4 <sendReading>
    vTaskDelay(1);
 400731c:	01000044 	movi	r4,1
 4007320:	4003df00 	call	4003df0 <vTaskDelay>
    buttons = (~IORD_ALTERA_AVALON_PIO_DATA(KEYS_0_BASE)) & 0x3;
 4007324:	003fde06 	br	40072a0 <task1+0x28>
    return;
 4007328:	0001883a 	nop
  }
 
}
 400732c:	e037883a 	mov	sp,fp
 4007330:	dfc00117 	ldw	ra,4(sp)
 4007334:	df000017 	ldw	fp,0(sp)
 4007338:	dec00204 	addi	sp,sp,8
 400733c:	f800283a 	ret

04007340 <task2>:


void task2()
{
 4007340:	defffe04 	addi	sp,sp,-8
 4007344:	dfc00115 	stw	ra,4(sp)
 4007348:	df000015 	stw	fp,0(sp)
 400734c:	d839883a 	mov	fp,sp
  while (1)
  {
    writeScore(getScore());
 4007350:	40072300 	call	4007230 <getScore>
 4007354:	1009883a 	mov	r4,r2
 4007358:	40070dc0 	call	40070dc <writeScore>
    printf("wrote score\n");
 400735c:	010100b4 	movhi	r4,1026
 4007360:	212afc04 	addi	r4,r4,-21520
 4007364:	4007afc0 	call	4007afc <puts>
    vTaskDelay(5000);
 4007368:	0104e204 	movi	r4,5000
 400736c:	4003df00 	call	4003df0 <vTaskDelay>
    writeScore(getScore());
 4007370:	003ff706 	br	4007350 <task2+0x10>

04007374 <main>:
}



int main()
{
 4007374:	defffc04 	addi	sp,sp,-16
 4007378:	dfc00315 	stw	ra,12(sp)
 400737c:	df000215 	stw	fp,8(sp)
 4007380:	df000204 	addi	fp,sp,8
  xTaskCreate(task1, "Task 1", 1024, NULL, 1, NULL);
 4007384:	d8000115 	stw	zero,4(sp)
 4007388:	00800044 	movi	r2,1
 400738c:	d8800015 	stw	r2,0(sp)
 4007390:	000f883a 	mov	r7,zero
 4007394:	01810004 	movi	r6,1024
 4007398:	014100b4 	movhi	r5,1026
 400739c:	296aff04 	addi	r5,r5,-21508
 40073a0:	01010034 	movhi	r4,1024
 40073a4:	211c9e04 	addi	r4,r4,29304
 40073a8:	40037b40 	call	40037b4 <xTaskCreate>
  xTaskCreate(task2, "Task 2", 1024, NULL, 2, NULL);
 40073ac:	d8000115 	stw	zero,4(sp)
 40073b0:	00800084 	movi	r2,2
 40073b4:	d8800015 	stw	r2,0(sp)
 40073b8:	000f883a 	mov	r7,zero
 40073bc:	01810004 	movi	r6,1024
 40073c0:	014100b4 	movhi	r5,1026
 40073c4:	296b0104 	addi	r5,r5,-21500
 40073c8:	01010034 	movhi	r4,1024
 40073cc:	211cd004 	addi	r4,r4,29504
 40073d0:	40037b40 	call	40037b4 <xTaskCreate>

  vTaskStartScheduler();
 40073d4:	40046140 	call	4004614 <vTaskStartScheduler>
  return 0;
 40073d8:	0005883a 	mov	r2,zero
}
 40073dc:	e037883a 	mov	sp,fp
 40073e0:	dfc00117 	ldw	ra,4(sp)
 40073e4:	df000017 	ldw	fp,0(sp)
 40073e8:	dec00204 	addi	sp,sp,8
 40073ec:	f800283a 	ret

040073f0 <__divsi3>:
 40073f0:	20001a16 	blt	r4,zero,400745c <__divsi3+0x6c>
 40073f4:	000f883a 	mov	r7,zero
 40073f8:	2800020e 	bge	r5,zero,4007404 <__divsi3+0x14>
 40073fc:	014bc83a 	sub	r5,zero,r5
 4007400:	39c0005c 	xori	r7,r7,1
 4007404:	200d883a 	mov	r6,r4
 4007408:	00c00044 	movi	r3,1
 400740c:	2900092e 	bgeu	r5,r4,4007434 <__divsi3+0x44>
 4007410:	00800804 	movi	r2,32
 4007414:	00c00044 	movi	r3,1
 4007418:	00000106 	br	4007420 <__divsi3+0x30>
 400741c:	10001226 	beq	r2,zero,4007468 <__divsi3+0x78>
 4007420:	294b883a 	add	r5,r5,r5
 4007424:	10bfffc4 	addi	r2,r2,-1
 4007428:	18c7883a 	add	r3,r3,r3
 400742c:	293ffb36 	bltu	r5,r4,400741c <__divsi3+0x2c>
 4007430:	18000d26 	beq	r3,zero,4007468 <__divsi3+0x78>
 4007434:	0005883a 	mov	r2,zero
 4007438:	31400236 	bltu	r6,r5,4007444 <__divsi3+0x54>
 400743c:	314dc83a 	sub	r6,r6,r5
 4007440:	10c4b03a 	or	r2,r2,r3
 4007444:	1806d07a 	srli	r3,r3,1
 4007448:	280ad07a 	srli	r5,r5,1
 400744c:	183ffa1e 	bne	r3,zero,4007438 <__divsi3+0x48>
 4007450:	38000126 	beq	r7,zero,4007458 <__divsi3+0x68>
 4007454:	0085c83a 	sub	r2,zero,r2
 4007458:	f800283a 	ret
 400745c:	0109c83a 	sub	r4,zero,r4
 4007460:	01c00044 	movi	r7,1
 4007464:	003fe406 	br	40073f8 <__divsi3+0x8>
 4007468:	0005883a 	mov	r2,zero
 400746c:	003ff806 	br	4007450 <__divsi3+0x60>

04007470 <__modsi3>:
 4007470:	20001916 	blt	r4,zero,40074d8 <__modsi3+0x68>
 4007474:	000f883a 	mov	r7,zero
 4007478:	2005883a 	mov	r2,r4
 400747c:	2800010e 	bge	r5,zero,4007484 <__modsi3+0x14>
 4007480:	014bc83a 	sub	r5,zero,r5
 4007484:	00c00044 	movi	r3,1
 4007488:	2900092e 	bgeu	r5,r4,40074b0 <__modsi3+0x40>
 400748c:	01800804 	movi	r6,32
 4007490:	00c00044 	movi	r3,1
 4007494:	00000106 	br	400749c <__modsi3+0x2c>
 4007498:	30000d26 	beq	r6,zero,40074d0 <__modsi3+0x60>
 400749c:	294b883a 	add	r5,r5,r5
 40074a0:	31bfffc4 	addi	r6,r6,-1
 40074a4:	18c7883a 	add	r3,r3,r3
 40074a8:	293ffb36 	bltu	r5,r4,4007498 <__modsi3+0x28>
 40074ac:	18000826 	beq	r3,zero,40074d0 <__modsi3+0x60>
 40074b0:	1806d07a 	srli	r3,r3,1
 40074b4:	11400136 	bltu	r2,r5,40074bc <__modsi3+0x4c>
 40074b8:	1145c83a 	sub	r2,r2,r5
 40074bc:	280ad07a 	srli	r5,r5,1
 40074c0:	183ffb1e 	bne	r3,zero,40074b0 <__modsi3+0x40>
 40074c4:	38000126 	beq	r7,zero,40074cc <__modsi3+0x5c>
 40074c8:	0085c83a 	sub	r2,zero,r2
 40074cc:	f800283a 	ret
 40074d0:	2005883a 	mov	r2,r4
 40074d4:	003ffb06 	br	40074c4 <__modsi3+0x54>
 40074d8:	0109c83a 	sub	r4,zero,r4
 40074dc:	01c00044 	movi	r7,1
 40074e0:	003fe506 	br	4007478 <__modsi3+0x8>

040074e4 <__udivsi3>:
 40074e4:	200d883a 	mov	r6,r4
 40074e8:	2900152e 	bgeu	r5,r4,4007540 <__udivsi3+0x5c>
 40074ec:	28001416 	blt	r5,zero,4007540 <__udivsi3+0x5c>
 40074f0:	00800804 	movi	r2,32
 40074f4:	00c00044 	movi	r3,1
 40074f8:	00000206 	br	4007504 <__udivsi3+0x20>
 40074fc:	10000e26 	beq	r2,zero,4007538 <__udivsi3+0x54>
 4007500:	28000516 	blt	r5,zero,4007518 <__udivsi3+0x34>
 4007504:	294b883a 	add	r5,r5,r5
 4007508:	10bfffc4 	addi	r2,r2,-1
 400750c:	18c7883a 	add	r3,r3,r3
 4007510:	293ffa36 	bltu	r5,r4,40074fc <__udivsi3+0x18>
 4007514:	18000826 	beq	r3,zero,4007538 <__udivsi3+0x54>
 4007518:	0005883a 	mov	r2,zero
 400751c:	31400236 	bltu	r6,r5,4007528 <__udivsi3+0x44>
 4007520:	314dc83a 	sub	r6,r6,r5
 4007524:	10c4b03a 	or	r2,r2,r3
 4007528:	1806d07a 	srli	r3,r3,1
 400752c:	280ad07a 	srli	r5,r5,1
 4007530:	183ffa1e 	bne	r3,zero,400751c <__udivsi3+0x38>
 4007534:	f800283a 	ret
 4007538:	0005883a 	mov	r2,zero
 400753c:	f800283a 	ret
 4007540:	00c00044 	movi	r3,1
 4007544:	003ff406 	br	4007518 <__udivsi3+0x34>

04007548 <__umodsi3>:
 4007548:	2005883a 	mov	r2,r4
 400754c:	2900132e 	bgeu	r5,r4,400759c <__umodsi3+0x54>
 4007550:	28001216 	blt	r5,zero,400759c <__umodsi3+0x54>
 4007554:	01800804 	movi	r6,32
 4007558:	00c00044 	movi	r3,1
 400755c:	00000206 	br	4007568 <__umodsi3+0x20>
 4007560:	30000c26 	beq	r6,zero,4007594 <__umodsi3+0x4c>
 4007564:	28000516 	blt	r5,zero,400757c <__umodsi3+0x34>
 4007568:	294b883a 	add	r5,r5,r5
 400756c:	31bfffc4 	addi	r6,r6,-1
 4007570:	18c7883a 	add	r3,r3,r3
 4007574:	293ffa36 	bltu	r5,r4,4007560 <__umodsi3+0x18>
 4007578:	18000626 	beq	r3,zero,4007594 <__umodsi3+0x4c>
 400757c:	1806d07a 	srli	r3,r3,1
 4007580:	11400136 	bltu	r2,r5,4007588 <__umodsi3+0x40>
 4007584:	1145c83a 	sub	r2,r2,r5
 4007588:	280ad07a 	srli	r5,r5,1
 400758c:	183ffb1e 	bne	r3,zero,400757c <__umodsi3+0x34>
 4007590:	f800283a 	ret
 4007594:	2005883a 	mov	r2,r4
 4007598:	f800283a 	ret
 400759c:	00c00044 	movi	r3,1
 40075a0:	003ff606 	br	400757c <__umodsi3+0x34>

040075a4 <__mulsi3>:
 40075a4:	0005883a 	mov	r2,zero
 40075a8:	20000726 	beq	r4,zero,40075c8 <__mulsi3+0x24>
 40075ac:	20c0004c 	andi	r3,r4,1
 40075b0:	2008d07a 	srli	r4,r4,1
 40075b4:	18000126 	beq	r3,zero,40075bc <__mulsi3+0x18>
 40075b8:	1145883a 	add	r2,r2,r5
 40075bc:	294b883a 	add	r5,r5,r5
 40075c0:	203ffa1e 	bne	r4,zero,40075ac <__mulsi3+0x8>
 40075c4:	f800283a 	ret
 40075c8:	f800283a 	ret

040075cc <memcpy>:
void *
__inhibit_loop_to_libcall
memcpy (void *__restrict dst0,
	const void *__restrict src0,
	size_t len0)
{
 40075cc:	defff804 	addi	sp,sp,-32
 40075d0:	df000715 	stw	fp,28(sp)
 40075d4:	df000704 	addi	fp,sp,28
 40075d8:	e13ffb15 	stw	r4,-20(fp)
 40075dc:	e17ffa15 	stw	r5,-24(fp)
 40075e0:	e1bff915 	stw	r6,-28(fp)
      *dst++ = *src++;
    }

  return save;
#else
  char *dst = dst0;
 40075e4:	e0bffb17 	ldw	r2,-20(fp)
 40075e8:	e0bfff15 	stw	r2,-4(fp)
  const char *src = src0;
 40075ec:	e0bffa17 	ldw	r2,-24(fp)
 40075f0:	e0bffe15 	stw	r2,-8(fp)
  long *aligned_dst;
  const long *aligned_src;

  /* If the size is small, or either SRC or DST is unaligned,
     then punt into the byte copy loop.  This should be rare.  */
  if (!TOO_SMALL(len0) && !UNALIGNED (src, dst))
 40075f4:	e0bff917 	ldw	r2,-28(fp)
 40075f8:	10800430 	cmpltui	r2,r2,16
 40075fc:	10004c1e 	bne	r2,zero,4007730 <memcpy+0x164>
 4007600:	e0fffe17 	ldw	r3,-8(fp)
 4007604:	e0bfff17 	ldw	r2,-4(fp)
 4007608:	1884b03a 	or	r2,r3,r2
 400760c:	108000cc 	andi	r2,r2,3
 4007610:	1000471e 	bne	r2,zero,4007730 <memcpy+0x164>
    {
      aligned_dst = (long*)dst;
 4007614:	e0bfff17 	ldw	r2,-4(fp)
 4007618:	e0bffd15 	stw	r2,-12(fp)
      aligned_src = (long*)src;
 400761c:	e0bffe17 	ldw	r2,-8(fp)
 4007620:	e0bffc15 	stw	r2,-16(fp)

      /* Copy 4X long words at a time if possible.  */
      while (len0 >= BIGBLOCKSIZE)
 4007624:	00002306 	br	40076b4 <memcpy+0xe8>
        {
          *aligned_dst++ = *aligned_src++;
 4007628:	e0fffc17 	ldw	r3,-16(fp)
 400762c:	18800104 	addi	r2,r3,4
 4007630:	e0bffc15 	stw	r2,-16(fp)
 4007634:	e0bffd17 	ldw	r2,-12(fp)
 4007638:	11000104 	addi	r4,r2,4
 400763c:	e13ffd15 	stw	r4,-12(fp)
 4007640:	18c00017 	ldw	r3,0(r3)
 4007644:	10c00015 	stw	r3,0(r2)
          *aligned_dst++ = *aligned_src++;
 4007648:	e0fffc17 	ldw	r3,-16(fp)
 400764c:	18800104 	addi	r2,r3,4
 4007650:	e0bffc15 	stw	r2,-16(fp)
 4007654:	e0bffd17 	ldw	r2,-12(fp)
 4007658:	11000104 	addi	r4,r2,4
 400765c:	e13ffd15 	stw	r4,-12(fp)
 4007660:	18c00017 	ldw	r3,0(r3)
 4007664:	10c00015 	stw	r3,0(r2)
          *aligned_dst++ = *aligned_src++;
 4007668:	e0fffc17 	ldw	r3,-16(fp)
 400766c:	18800104 	addi	r2,r3,4
 4007670:	e0bffc15 	stw	r2,-16(fp)
 4007674:	e0bffd17 	ldw	r2,-12(fp)
 4007678:	11000104 	addi	r4,r2,4
 400767c:	e13ffd15 	stw	r4,-12(fp)
 4007680:	18c00017 	ldw	r3,0(r3)
 4007684:	10c00015 	stw	r3,0(r2)
          *aligned_dst++ = *aligned_src++;
 4007688:	e0fffc17 	ldw	r3,-16(fp)
 400768c:	18800104 	addi	r2,r3,4
 4007690:	e0bffc15 	stw	r2,-16(fp)
 4007694:	e0bffd17 	ldw	r2,-12(fp)
 4007698:	11000104 	addi	r4,r2,4
 400769c:	e13ffd15 	stw	r4,-12(fp)
 40076a0:	18c00017 	ldw	r3,0(r3)
 40076a4:	10c00015 	stw	r3,0(r2)
          len0 -= BIGBLOCKSIZE;
 40076a8:	e0bff917 	ldw	r2,-28(fp)
 40076ac:	10bffc04 	addi	r2,r2,-16
 40076b0:	e0bff915 	stw	r2,-28(fp)
      while (len0 >= BIGBLOCKSIZE)
 40076b4:	e0bff917 	ldw	r2,-28(fp)
 40076b8:	10800428 	cmpgeui	r2,r2,16
 40076bc:	103fda1e 	bne	r2,zero,4007628 <memcpy+0x5c>
        }

      /* Copy one long word at a time if possible.  */
      while (len0 >= LITTLEBLOCKSIZE)
 40076c0:	00000b06 	br	40076f0 <memcpy+0x124>
        {
          *aligned_dst++ = *aligned_src++;
 40076c4:	e0fffc17 	ldw	r3,-16(fp)
 40076c8:	18800104 	addi	r2,r3,4
 40076cc:	e0bffc15 	stw	r2,-16(fp)
 40076d0:	e0bffd17 	ldw	r2,-12(fp)
 40076d4:	11000104 	addi	r4,r2,4
 40076d8:	e13ffd15 	stw	r4,-12(fp)
 40076dc:	18c00017 	ldw	r3,0(r3)
 40076e0:	10c00015 	stw	r3,0(r2)
          len0 -= LITTLEBLOCKSIZE;
 40076e4:	e0bff917 	ldw	r2,-28(fp)
 40076e8:	10bfff04 	addi	r2,r2,-4
 40076ec:	e0bff915 	stw	r2,-28(fp)
      while (len0 >= LITTLEBLOCKSIZE)
 40076f0:	e0bff917 	ldw	r2,-28(fp)
 40076f4:	10800128 	cmpgeui	r2,r2,4
 40076f8:	103ff21e 	bne	r2,zero,40076c4 <memcpy+0xf8>
        }

       /* Pick up any residual with a byte copier.  */
      dst = (char*)aligned_dst;
 40076fc:	e0bffd17 	ldw	r2,-12(fp)
 4007700:	e0bfff15 	stw	r2,-4(fp)
      src = (char*)aligned_src;
 4007704:	e0bffc17 	ldw	r2,-16(fp)
 4007708:	e0bffe15 	stw	r2,-8(fp)
    }

  while (len0--)
 400770c:	00000806 	br	4007730 <memcpy+0x164>
    *dst++ = *src++;
 4007710:	e0fffe17 	ldw	r3,-8(fp)
 4007714:	18800044 	addi	r2,r3,1
 4007718:	e0bffe15 	stw	r2,-8(fp)
 400771c:	e0bfff17 	ldw	r2,-4(fp)
 4007720:	11000044 	addi	r4,r2,1
 4007724:	e13fff15 	stw	r4,-4(fp)
 4007728:	18c00003 	ldbu	r3,0(r3)
 400772c:	10c00005 	stb	r3,0(r2)
  while (len0--)
 4007730:	e0bff917 	ldw	r2,-28(fp)
 4007734:	10ffffc4 	addi	r3,r2,-1
 4007738:	e0fff915 	stw	r3,-28(fp)
 400773c:	103ff41e 	bne	r2,zero,4007710 <memcpy+0x144>

  return dst0;
 4007740:	e0bffb17 	ldw	r2,-20(fp)
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 4007744:	e037883a 	mov	sp,fp
 4007748:	df000017 	ldw	fp,0(sp)
 400774c:	dec00104 	addi	sp,sp,4
 4007750:	f800283a 	ret

04007754 <memset>:
void *
__inhibit_loop_to_libcall
memset (void *m,
	int c,
	size_t n)
{
 4007754:	defff704 	addi	sp,sp,-36
 4007758:	df000815 	stw	fp,32(sp)
 400775c:	df000804 	addi	fp,sp,32
 4007760:	e13ffa15 	stw	r4,-24(fp)
 4007764:	e17ff915 	stw	r5,-28(fp)
 4007768:	e1bff815 	stw	r6,-32(fp)
  char *s = (char *) m;
 400776c:	e0bffa17 	ldw	r2,-24(fp)
 4007770:	e0bfff15 	stw	r2,-4(fp)

#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned int i;
  unsigned long buffer;
  unsigned long *aligned_addr;
  unsigned int d = c & 0xff;	/* To avoid sign extension, copy C to an
 4007774:	e0bff917 	ldw	r2,-28(fp)
 4007778:	10803fcc 	andi	r2,r2,255
 400777c:	e0bffb15 	stw	r2,-20(fp)
				   unsigned variable.  */

  while (UNALIGNED (s))
 4007780:	00000c06 	br	40077b4 <memset+0x60>
    {
      if (n--)
 4007784:	e0bff817 	ldw	r2,-32(fp)
 4007788:	10ffffc4 	addi	r3,r2,-1
 400778c:	e0fff815 	stw	r3,-32(fp)
 4007790:	10000626 	beq	r2,zero,40077ac <memset+0x58>
        *s++ = (char) c;
 4007794:	e0bfff17 	ldw	r2,-4(fp)
 4007798:	10c00044 	addi	r3,r2,1
 400779c:	e0ffff15 	stw	r3,-4(fp)
 40077a0:	e0fff917 	ldw	r3,-28(fp)
 40077a4:	10c00005 	stb	r3,0(r2)
 40077a8:	00000206 	br	40077b4 <memset+0x60>
      else
        return m;
 40077ac:	e0bffa17 	ldw	r2,-24(fp)
 40077b0:	00005506 	br	4007908 <memset+0x1b4>
  while (UNALIGNED (s))
 40077b4:	e0bfff17 	ldw	r2,-4(fp)
 40077b8:	108000cc 	andi	r2,r2,3
 40077bc:	103ff11e 	bne	r2,zero,4007784 <memset+0x30>
    }

  if (!TOO_SMALL (n))
 40077c0:	e0bff817 	ldw	r2,-32(fp)
 40077c4:	10800130 	cmpltui	r2,r2,4
 40077c8:	10004a1e 	bne	r2,zero,40078f4 <memset+0x1a0>
    {
      /* If we get this far, we know that n is large and s is word-aligned. */
      aligned_addr = (unsigned long *) s;
 40077cc:	e0bfff17 	ldw	r2,-4(fp)
 40077d0:	e0bffc15 	stw	r2,-16(fp)

      /* Store D into each char sized location in BUFFER so that
         we can set large blocks quickly.  */
      buffer = (d << 8) | d;
 40077d4:	e0bffb17 	ldw	r2,-20(fp)
 40077d8:	1004923a 	slli	r2,r2,8
 40077dc:	e0fffb17 	ldw	r3,-20(fp)
 40077e0:	1884b03a 	or	r2,r3,r2
 40077e4:	e0bffd15 	stw	r2,-12(fp)
      buffer |= (buffer << 16);
 40077e8:	e0bffd17 	ldw	r2,-12(fp)
 40077ec:	1004943a 	slli	r2,r2,16
 40077f0:	e0fffd17 	ldw	r3,-12(fp)
 40077f4:	1884b03a 	or	r2,r3,r2
 40077f8:	e0bffd15 	stw	r2,-12(fp)
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
 40077fc:	00800804 	movi	r2,32
 4007800:	e0bffe15 	stw	r2,-8(fp)
 4007804:	00000906 	br	400782c <memset+0xd8>
        buffer = (buffer << i) | buffer;
 4007808:	e0fffd17 	ldw	r3,-12(fp)
 400780c:	e0bffe17 	ldw	r2,-8(fp)
 4007810:	1884983a 	sll	r2,r3,r2
 4007814:	e0fffd17 	ldw	r3,-12(fp)
 4007818:	1884b03a 	or	r2,r3,r2
 400781c:	e0bffd15 	stw	r2,-12(fp)
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
 4007820:	e0bffe17 	ldw	r2,-8(fp)
 4007824:	1085883a 	add	r2,r2,r2
 4007828:	e0bffe15 	stw	r2,-8(fp)
 400782c:	e0bffe17 	ldw	r2,-8(fp)
 4007830:	10800830 	cmpltui	r2,r2,32
 4007834:	103ff41e 	bne	r2,zero,4007808 <memset+0xb4>

      /* Unroll the loop.  */
      while (n >= LBLOCKSIZE*4)
 4007838:	00001706 	br	4007898 <memset+0x144>
        {
          *aligned_addr++ = buffer;
 400783c:	e0bffc17 	ldw	r2,-16(fp)
 4007840:	10c00104 	addi	r3,r2,4
 4007844:	e0fffc15 	stw	r3,-16(fp)
 4007848:	e0fffd17 	ldw	r3,-12(fp)
 400784c:	10c00015 	stw	r3,0(r2)
          *aligned_addr++ = buffer;
 4007850:	e0bffc17 	ldw	r2,-16(fp)
 4007854:	10c00104 	addi	r3,r2,4
 4007858:	e0fffc15 	stw	r3,-16(fp)
 400785c:	e0fffd17 	ldw	r3,-12(fp)
 4007860:	10c00015 	stw	r3,0(r2)
          *aligned_addr++ = buffer;
 4007864:	e0bffc17 	ldw	r2,-16(fp)
 4007868:	10c00104 	addi	r3,r2,4
 400786c:	e0fffc15 	stw	r3,-16(fp)
 4007870:	e0fffd17 	ldw	r3,-12(fp)
 4007874:	10c00015 	stw	r3,0(r2)
          *aligned_addr++ = buffer;
 4007878:	e0bffc17 	ldw	r2,-16(fp)
 400787c:	10c00104 	addi	r3,r2,4
 4007880:	e0fffc15 	stw	r3,-16(fp)
 4007884:	e0fffd17 	ldw	r3,-12(fp)
 4007888:	10c00015 	stw	r3,0(r2)
          n -= 4*LBLOCKSIZE;
 400788c:	e0bff817 	ldw	r2,-32(fp)
 4007890:	10bffc04 	addi	r2,r2,-16
 4007894:	e0bff815 	stw	r2,-32(fp)
      while (n >= LBLOCKSIZE*4)
 4007898:	e0bff817 	ldw	r2,-32(fp)
 400789c:	10800428 	cmpgeui	r2,r2,16
 40078a0:	103fe61e 	bne	r2,zero,400783c <memset+0xe8>
        }

      while (n >= LBLOCKSIZE)
 40078a4:	00000806 	br	40078c8 <memset+0x174>
        {
          *aligned_addr++ = buffer;
 40078a8:	e0bffc17 	ldw	r2,-16(fp)
 40078ac:	10c00104 	addi	r3,r2,4
 40078b0:	e0fffc15 	stw	r3,-16(fp)
 40078b4:	e0fffd17 	ldw	r3,-12(fp)
 40078b8:	10c00015 	stw	r3,0(r2)
          n -= LBLOCKSIZE;
 40078bc:	e0bff817 	ldw	r2,-32(fp)
 40078c0:	10bfff04 	addi	r2,r2,-4
 40078c4:	e0bff815 	stw	r2,-32(fp)
      while (n >= LBLOCKSIZE)
 40078c8:	e0bff817 	ldw	r2,-32(fp)
 40078cc:	10800128 	cmpgeui	r2,r2,4
 40078d0:	103ff51e 	bne	r2,zero,40078a8 <memset+0x154>
        }
      /* Pick up the remainder with a bytewise loop.  */
      s = (char*)aligned_addr;
 40078d4:	e0bffc17 	ldw	r2,-16(fp)
 40078d8:	e0bfff15 	stw	r2,-4(fp)
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (n--)
 40078dc:	00000506 	br	40078f4 <memset+0x1a0>
    *s++ = (char) c;
 40078e0:	e0bfff17 	ldw	r2,-4(fp)
 40078e4:	10c00044 	addi	r3,r2,1
 40078e8:	e0ffff15 	stw	r3,-4(fp)
 40078ec:	e0fff917 	ldw	r3,-28(fp)
 40078f0:	10c00005 	stb	r3,0(r2)
  while (n--)
 40078f4:	e0bff817 	ldw	r2,-32(fp)
 40078f8:	10ffffc4 	addi	r3,r2,-1
 40078fc:	e0fff815 	stw	r3,-32(fp)
 4007900:	103ff71e 	bne	r2,zero,40078e0 <memset+0x18c>

  return m;
 4007904:	e0bffa17 	ldw	r2,-24(fp)
}
 4007908:	e037883a 	mov	sp,fp
 400790c:	df000017 	ldw	fp,0(sp)
 4007910:	dec00104 	addi	sp,sp,4
 4007914:	f800283a 	ret

04007918 <_printf_r>:
#include "fvwrite.h"    /* IntelSpecific */

int
_printf_r (struct _reent *ptr,
       const char *__restrict fmt, ...)
{
 4007918:	defff804 	addi	sp,sp,-32
 400791c:	dfc00515 	stw	ra,20(sp)
 4007920:	df000415 	stw	fp,16(sp)
 4007924:	df000404 	addi	fp,sp,16
 4007928:	e13ffd15 	stw	r4,-12(fp)
 400792c:	e17ffc15 	stw	r5,-16(fp)
 4007930:	e1800215 	stw	r6,8(fp)
 4007934:	e1c00315 	stw	r7,12(fp)
  int ret;
  va_list ap;

  _REENT_SMALL_CHECK_INIT (ptr);
  _FILE_INIT_DEV_WRITE (_stdout_r (ptr));    /* IntelSpecific */
  va_start (ap, fmt);
 4007938:	e0800204 	addi	r2,fp,8
 400793c:	e0bffe15 	stw	r2,-8(fp)
/*ret =   _vfprintf_r          (ptr, _stdout_r (ptr), fmt, ap);	*/	/*1.16.0*/	/* IntelSpecific */
/*ret = ___vfprintf_internal_r (ptr, _stdout_r (ptr), fmt, ap);	*/	/*1.16  */	/* IntelSpecific */
/*ret =   _vfprintf_r          (ptr, _stdout_r (ptr), fmt, ap);	*/	/*1.18.0*/	/* IntelSpecific */
/*ret =   _vfprintf_r          (ptr, _stdout_r (ptr), fmt, ap);	*/	/* try1 */	/* IntelSpecific */
  ret = ___vfprintf_internal_r (ptr, _stdout_r (ptr), fmt, ap);		/* try2 */	/* IntelSpecific */
 4007940:	e0bffd17 	ldw	r2,-12(fp)
 4007944:	10800217 	ldw	r2,8(r2)
 4007948:	e0fffe17 	ldw	r3,-8(fp)
 400794c:	180f883a 	mov	r7,r3
 4007950:	e1bffc17 	ldw	r6,-16(fp)
 4007954:	100b883a 	mov	r5,r2
 4007958:	e13ffd17 	ldw	r4,-12(fp)
 400795c:	4007d680 	call	4007d68 <___vfprintf_internal_r>
 4007960:	e0bfff15 	stw	r2,-4(fp)
  va_end (ap);
  return ret;
 4007964:	e0bfff17 	ldw	r2,-4(fp)
}
 4007968:	e037883a 	mov	sp,fp
 400796c:	dfc00117 	ldw	ra,4(sp)
 4007970:	df000017 	ldw	fp,0(sp)
 4007974:	dec00404 	addi	sp,sp,16
 4007978:	f800283a 	ret

0400797c <printf>:

#ifndef _REENT_ONLY

int
printf (const char *__restrict fmt, ...)
{
 400797c:	defff704 	addi	sp,sp,-36
 4007980:	dfc00515 	stw	ra,20(sp)
 4007984:	df000415 	stw	fp,16(sp)
 4007988:	df000404 	addi	fp,sp,16
 400798c:	e13ffc15 	stw	r4,-16(fp)
 4007990:	e1400215 	stw	r5,8(fp)
 4007994:	e1800315 	stw	r6,12(fp)
 4007998:	e1c00415 	stw	r7,16(fp)
  int ret;
  va_list ap;
  struct _reent *ptr = _REENT;
 400799c:	d0a00117 	ldw	r2,-32764(gp)
 40079a0:	e0bfff15 	stw	r2,-4(fp)

  _REENT_SMALL_CHECK_INIT (ptr);
  _FILE_INIT_DEV_WRITE (_stdout_r (_REENT));    /* IntelSpecific. Mirror changes here in iprintf.c */
  va_start (ap, fmt);
 40079a4:	e0800204 	addi	r2,fp,8
 40079a8:	e0bffd15 	stw	r2,-12(fp)
/*ret =  _vfprintf_r        (ptr, _stdout_r    (ptr), fmt, ap);	*/ /*1.16.0*/	/* IntelSpecific */
/*ret = __vfprintf_internal (     _stdout_r (_REENT), fmt, ap);	*/ /*1.16  */	/* IntelSpecific */
/*ret =  _vfprintf_r        (ptr, _stdout_r    (ptr), fmt, ap);	*/ /*1.18.0*/	/* IntelSpecific */
/*ret =  _vfprintf_r        (ptr, _stdout_r    (ptr), fmt, ap); */ /* try1 */	/* IntelSpecific */
  ret = __vfprintf_internal (     _stdout_r (_REENT), fmt, ap);    /* try2 */	/* IntelSpecific */
 40079ac:	d0a00117 	ldw	r2,-32764(gp)
 40079b0:	10800217 	ldw	r2,8(r2)
 40079b4:	e0fffd17 	ldw	r3,-12(fp)
 40079b8:	180d883a 	mov	r6,r3
 40079bc:	e17ffc17 	ldw	r5,-16(fp)
 40079c0:	1009883a 	mov	r4,r2
 40079c4:	4007d180 	call	4007d18 <__vfprintf_internal>
 40079c8:	e0bffe15 	stw	r2,-8(fp)
  va_end (ap);
  return ret;
 40079cc:	e0bffe17 	ldw	r2,-8(fp)
}
 40079d0:	e037883a 	mov	sp,fp
 40079d4:	dfc00117 	ldw	ra,4(sp)
 40079d8:	df000017 	ldw	fp,0(sp)
 40079dc:	dec00504 	addi	sp,sp,20
 40079e0:	f800283a 	ret

040079e4 <_puts_r>:
 */

int
_puts_r (struct _reent *ptr,
       const char * s)
{
 40079e4:	defff104 	addi	sp,sp,-60
 40079e8:	dfc00e15 	stw	ra,56(sp)
 40079ec:	df000d15 	stw	fp,52(sp)
 40079f0:	df000d04 	addi	fp,sp,52
 40079f4:	e13ff415 	stw	r4,-48(fp)
 40079f8:	e17ff315 	stw	r5,-52(fp)
#ifdef _FVWRITE_IN_STREAMIO
  int result;
  size_t c = strlen (s);
 40079fc:	e13ff317 	ldw	r4,-52(fp)
 4007a00:	4007b340 	call	4007b34 <strlen>
 4007a04:	e0bfff15 	stw	r2,-4(fp)
  struct __suio uio;
  struct __siov iov[2];
  FILE *fp;

  iov[0].iov_base = s;
 4007a08:	e0bff317 	ldw	r2,-52(fp)
 4007a0c:	e0bff515 	stw	r2,-44(fp)
  iov[0].iov_len = c;
 4007a10:	e0bfff17 	ldw	r2,-4(fp)
 4007a14:	e0bff615 	stw	r2,-40(fp)
  iov[1].iov_base = "\n";
 4007a18:	008100b4 	movhi	r2,1026
 4007a1c:	10ab0304 	addi	r2,r2,-21492
 4007a20:	e0bff715 	stw	r2,-36(fp)
  iov[1].iov_len = 1;
 4007a24:	00800044 	movi	r2,1
 4007a28:	e0bff815 	stw	r2,-32(fp)
  uio.uio_resid = c + 1;
 4007a2c:	e0bfff17 	ldw	r2,-4(fp)
 4007a30:	10800044 	addi	r2,r2,1
 4007a34:	e0bffb15 	stw	r2,-20(fp)
  uio.uio_iov = &iov[0];
 4007a38:	e0bff504 	addi	r2,fp,-44
 4007a3c:	e0bff915 	stw	r2,-28(fp)
  uio.uio_iovcnt = 2;
 4007a40:	00800084 	movi	r2,2
 4007a44:	e0bffa15 	stw	r2,-24(fp)

  _REENT_SMALL_CHECK_INIT (ptr);
  fp = _stdout_r (ptr);
 4007a48:	e0bff417 	ldw	r2,-48(fp)
 4007a4c:	10800217 	ldw	r2,8(r2)
 4007a50:	e0bffe15 	stw	r2,-8(fp)
  CHECK_INIT (ptr, fp);
 4007a54:	e0bff417 	ldw	r2,-48(fp)
 4007a58:	e0bffd15 	stw	r2,-12(fp)
 4007a5c:	e0bffd17 	ldw	r2,-12(fp)
 4007a60:	10000526 	beq	r2,zero,4007a78 <_puts_r+0x94>
 4007a64:	e0bffd17 	ldw	r2,-12(fp)
 4007a68:	10800e17 	ldw	r2,56(r2)
 4007a6c:	1000021e 	bne	r2,zero,4007a78 <_puts_r+0x94>
 4007a70:	e13ffd17 	ldw	r4,-12(fp)
 4007a74:	400cbdc0 	call	400cbdc <__sinit>
  _newlib_flockfile_start (fp);
  ORIENT (fp, -1);
 4007a78:	e0bffe17 	ldw	r2,-8(fp)
 4007a7c:	1080030b 	ldhu	r2,12(r2)
 4007a80:	10bfffcc 	andi	r2,r2,65535
 4007a84:	1088000c 	andi	r2,r2,8192
 4007a88:	10000c1e 	bne	r2,zero,4007abc <_puts_r+0xd8>
 4007a8c:	e0bffe17 	ldw	r2,-8(fp)
 4007a90:	1080030b 	ldhu	r2,12(r2)
 4007a94:	10880014 	ori	r2,r2,8192
 4007a98:	1007883a 	mov	r3,r2
 4007a9c:	e0bffe17 	ldw	r2,-8(fp)
 4007aa0:	10c0030d 	sth	r3,12(r2)
 4007aa4:	e0bffe17 	ldw	r2,-8(fp)
 4007aa8:	10c01917 	ldw	r3,100(r2)
 4007aac:	00b7ffc4 	movi	r2,-8193
 4007ab0:	1886703a 	and	r3,r3,r2
 4007ab4:	e0bffe17 	ldw	r2,-8(fp)
 4007ab8:	10c01915 	stw	r3,100(r2)
  result = (__sfvwrite_r (ptr, fp, &uio) ? EOF : '\n');
 4007abc:	e0bff904 	addi	r2,fp,-28
 4007ac0:	100d883a 	mov	r6,r2
 4007ac4:	e17ffe17 	ldw	r5,-8(fp)
 4007ac8:	e13ff417 	ldw	r4,-48(fp)
 4007acc:	400d4f40 	call	400d4f4 <__sfvwrite_r>
 4007ad0:	10000226 	beq	r2,zero,4007adc <_puts_r+0xf8>
 4007ad4:	00bfffc4 	movi	r2,-1
 4007ad8:	00000106 	br	4007ae0 <_puts_r+0xfc>
 4007adc:	00800284 	movi	r2,10
 4007ae0:	e0bffc15 	stw	r2,-16(fp)
  _newlib_flockfile_end (fp);
  return result;
 4007ae4:	e0bffc17 	ldw	r2,-16(fp)

err:
  _newlib_flockfile_end (fp);
  return result;
#endif
}
 4007ae8:	e037883a 	mov	sp,fp
 4007aec:	dfc00117 	ldw	ra,4(sp)
 4007af0:	df000017 	ldw	fp,0(sp)
 4007af4:	dec00204 	addi	sp,sp,8
 4007af8:	f800283a 	ret

04007afc <puts>:

#ifndef _REENT_ONLY

int
puts (char const * s)
{
 4007afc:	defffd04 	addi	sp,sp,-12
 4007b00:	dfc00215 	stw	ra,8(sp)
 4007b04:	df000115 	stw	fp,4(sp)
 4007b08:	df000104 	addi	fp,sp,4
 4007b0c:	e13fff15 	stw	r4,-4(fp)
  return _puts_r (_REENT, s);
 4007b10:	d0a00117 	ldw	r2,-32764(gp)
 4007b14:	e17fff17 	ldw	r5,-4(fp)
 4007b18:	1009883a 	mov	r4,r2
 4007b1c:	40079e40 	call	40079e4 <_puts_r>
}
 4007b20:	e037883a 	mov	sp,fp
 4007b24:	dfc00117 	ldw	ra,4(sp)
 4007b28:	df000017 	ldw	fp,0(sp)
 4007b2c:	dec00204 	addi	sp,sp,8
 4007b30:	f800283a 	ret

04007b34 <strlen>:
#error long int is not a 32bit or 64bit byte
#endif

size_t
strlen (const char *str)
{
 4007b34:	defffc04 	addi	sp,sp,-16
 4007b38:	df000315 	stw	fp,12(sp)
 4007b3c:	df000304 	addi	fp,sp,12
 4007b40:	e13ffd15 	stw	r4,-12(fp)
  const char *start = str;
 4007b44:	e0bffd17 	ldw	r2,-12(fp)
 4007b48:	e0bffe15 	stw	r2,-8(fp)

#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *aligned_addr;

  /* Align the pointer, so we can search a word at a time.  */
  while (UNALIGNED (str))
 4007b4c:	00000d06 	br	4007b84 <strlen+0x50>
    {
      if (!*str)
 4007b50:	e0bffd17 	ldw	r2,-12(fp)
 4007b54:	10800003 	ldbu	r2,0(r2)
 4007b58:	10803fcc 	andi	r2,r2,255
 4007b5c:	1080201c 	xori	r2,r2,128
 4007b60:	10bfe004 	addi	r2,r2,-128
 4007b64:	1000041e 	bne	r2,zero,4007b78 <strlen+0x44>
	return str - start;
 4007b68:	e0fffd17 	ldw	r3,-12(fp)
 4007b6c:	e0bffe17 	ldw	r2,-8(fp)
 4007b70:	1885c83a 	sub	r2,r3,r2
 4007b74:	00002806 	br	4007c18 <strlen+0xe4>
      str++;
 4007b78:	e0bffd17 	ldw	r2,-12(fp)
 4007b7c:	10800044 	addi	r2,r2,1
 4007b80:	e0bffd15 	stw	r2,-12(fp)
  while (UNALIGNED (str))
 4007b84:	e0bffd17 	ldw	r2,-12(fp)
 4007b88:	108000cc 	andi	r2,r2,3
 4007b8c:	103ff01e 	bne	r2,zero,4007b50 <strlen+0x1c>
    }

  /* If the string is word-aligned, we can check for the presence of
     a null in each word-sized block.  */
  aligned_addr = (unsigned long *)str;
 4007b90:	e0bffd17 	ldw	r2,-12(fp)
 4007b94:	e0bfff15 	stw	r2,-4(fp)
  while (!DETECTNULL (*aligned_addr))
 4007b98:	00000306 	br	4007ba8 <strlen+0x74>
    aligned_addr++;
 4007b9c:	e0bfff17 	ldw	r2,-4(fp)
 4007ba0:	10800104 	addi	r2,r2,4
 4007ba4:	e0bfff15 	stw	r2,-4(fp)
  while (!DETECTNULL (*aligned_addr))
 4007ba8:	e0bfff17 	ldw	r2,-4(fp)
 4007bac:	10c00017 	ldw	r3,0(r2)
 4007bb0:	00bfbff4 	movhi	r2,65279
 4007bb4:	10bfbfc4 	addi	r2,r2,-257
 4007bb8:	1887883a 	add	r3,r3,r2
 4007bbc:	e0bfff17 	ldw	r2,-4(fp)
 4007bc0:	10800017 	ldw	r2,0(r2)
 4007bc4:	0084303a 	nor	r2,zero,r2
 4007bc8:	1886703a 	and	r3,r3,r2
 4007bcc:	00a02074 	movhi	r2,32897
 4007bd0:	10a02004 	addi	r2,r2,-32640
 4007bd4:	1884703a 	and	r2,r3,r2
 4007bd8:	103ff026 	beq	r2,zero,4007b9c <strlen+0x68>

  /* Once a null is detected, we check each byte in that block for a
     precise position of the null.  */
  str = (char *) aligned_addr;
 4007bdc:	e0bfff17 	ldw	r2,-4(fp)
 4007be0:	e0bffd15 	stw	r2,-12(fp)

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (*str)
 4007be4:	00000306 	br	4007bf4 <strlen+0xc0>
    str++;
 4007be8:	e0bffd17 	ldw	r2,-12(fp)
 4007bec:	10800044 	addi	r2,r2,1
 4007bf0:	e0bffd15 	stw	r2,-12(fp)
  while (*str)
 4007bf4:	e0bffd17 	ldw	r2,-12(fp)
 4007bf8:	10800003 	ldbu	r2,0(r2)
 4007bfc:	10803fcc 	andi	r2,r2,255
 4007c00:	1080201c 	xori	r2,r2,128
 4007c04:	10bfe004 	addi	r2,r2,-128
 4007c08:	103ff71e 	bne	r2,zero,4007be8 <strlen+0xb4>
  return str - start;
 4007c0c:	e0fffd17 	ldw	r3,-12(fp)
 4007c10:	e0bffe17 	ldw	r2,-8(fp)
 4007c14:	1885c83a 	sub	r2,r3,r2
}
 4007c18:	e037883a 	mov	sp,fp
 4007c1c:	df000017 	ldw	fp,0(sp)
 4007c20:	dec00104 	addi	sp,sp,4
 4007c24:	f800283a 	ret

04007c28 <__sbprintf>:
_NOINLINE_STATIC int
__sbprintf (struct _reent *rptr,
       register FILE *fp,
       const char *fmt,
       va_list ap)
{
 4007c28:	defedf04 	addi	sp,sp,-1156
 4007c2c:	dfc12015 	stw	ra,1152(sp)
 4007c30:	df011f15 	stw	fp,1148(sp)
 4007c34:	dc011e15 	stw	r16,1144(sp)
 4007c38:	df011f04 	addi	fp,sp,1148
 4007c3c:	e13ee315 	stw	r4,-1140(fp)
 4007c40:	2821883a 	mov	r16,r5
 4007c44:	e1bee215 	stw	r6,-1144(fp)
 4007c48:	e1fee115 	stw	r7,-1148(fp)
	int ret;
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
 4007c4c:	80c0030b 	ldhu	r3,12(r16)
 4007c50:	00bfff44 	movi	r2,-3
 4007c54:	1884703a 	and	r2,r3,r2
 4007c58:	e0bfe70d 	sth	r2,-100(fp)
	fake._flags2 = fp->_flags2;
 4007c5c:	80801917 	ldw	r2,100(r16)
 4007c60:	e0bffd15 	stw	r2,-12(fp)
	fake._file = fp->_file;
 4007c64:	8080038b 	ldhu	r2,14(r16)
 4007c68:	e0bfe78d 	sth	r2,-98(fp)
	fake._cookie = fp->_cookie;
 4007c6c:	80800717 	ldw	r2,28(r16)
 4007c70:	e0bfeb15 	stw	r2,-84(fp)
	fake._write = fp->_write;
 4007c74:	80800917 	ldw	r2,36(r16)
 4007c78:	e0bfed15 	stw	r2,-76(fp)

	/* set up the buffer */
	fake._bf._base = fake._p = buf;
 4007c7c:	e0bee404 	addi	r2,fp,-1136
 4007c80:	e0bfe415 	stw	r2,-112(fp)
 4007c84:	e0bfe417 	ldw	r2,-112(fp)
 4007c88:	e0bfe815 	stw	r2,-96(fp)
	fake._bf._size = fake._w = sizeof (buf);
 4007c8c:	00810004 	movi	r2,1024
 4007c90:	e0bfe615 	stw	r2,-104(fp)
 4007c94:	e0bfe617 	ldw	r2,-104(fp)
 4007c98:	e0bfe915 	stw	r2,-92(fp)
	fake._lbfsize = 0;	/* not actually used, but Just In Case */
 4007c9c:	e03fea15 	stw	zero,-88(fp)
#ifndef __SINGLE_THREAD__
	__lock_init_recursive (fake._lock);
#endif

	/* do the work, then copy any error status */
	ret = _VFPRINTF_R (rptr, &fake, fmt, ap);
 4007ca0:	e0bfe404 	addi	r2,fp,-112
 4007ca4:	e1fee117 	ldw	r7,-1148(fp)
 4007ca8:	e1bee217 	ldw	r6,-1144(fp)
 4007cac:	100b883a 	mov	r5,r2
 4007cb0:	e13ee317 	ldw	r4,-1140(fp)
 4007cb4:	4007d680 	call	4007d68 <___vfprintf_internal_r>
 4007cb8:	e0bffe15 	stw	r2,-8(fp)
	if (ret >= 0 && _fflush_r (rptr, &fake))
 4007cbc:	e0bffe17 	ldw	r2,-8(fp)
 4007cc0:	10000716 	blt	r2,zero,4007ce0 <__sbprintf+0xb8>
 4007cc4:	e0bfe404 	addi	r2,fp,-112
 4007cc8:	100b883a 	mov	r5,r2
 4007ccc:	e13ee317 	ldw	r4,-1140(fp)
 4007cd0:	400c6940 	call	400c694 <_fflush_r>
 4007cd4:	10000226 	beq	r2,zero,4007ce0 <__sbprintf+0xb8>
		ret = EOF;
 4007cd8:	00bfffc4 	movi	r2,-1
 4007cdc:	e0bffe15 	stw	r2,-8(fp)
	if (fake._flags & __SERR)
 4007ce0:	e0bfe70b 	ldhu	r2,-100(fp)
 4007ce4:	10bfffcc 	andi	r2,r2,65535
 4007ce8:	1080100c 	andi	r2,r2,64
 4007cec:	10000326 	beq	r2,zero,4007cfc <__sbprintf+0xd4>
		fp->_flags |= __SERR;
 4007cf0:	8080030b 	ldhu	r2,12(r16)
 4007cf4:	10801014 	ori	r2,r2,64
 4007cf8:	8080030d 	sth	r2,12(r16)

#ifndef __SINGLE_THREAD__
	__lock_close_recursive (fake._lock);
#endif
	return (ret);
 4007cfc:	e0bffe17 	ldw	r2,-8(fp)
}
 4007d00:	e6ffff04 	addi	sp,fp,-4
 4007d04:	dfc00217 	ldw	ra,8(sp)
 4007d08:	df000117 	ldw	fp,4(sp)
 4007d0c:	dc000017 	ldw	r16,0(sp)
 4007d10:	dec00304 	addi	sp,sp,12
 4007d14:	f800283a 	ret

04007d18 <__vfprintf_internal>:
#ifndef STRING_ONLY
int
VFPRINTF (FILE * fp,
       const char *fmt0,
       va_list ap)
{
 4007d18:	defffa04 	addi	sp,sp,-24
 4007d1c:	dfc00515 	stw	ra,20(sp)
 4007d20:	df000415 	stw	fp,16(sp)
 4007d24:	df000404 	addi	fp,sp,16
 4007d28:	e13ffe15 	stw	r4,-8(fp)
 4007d2c:	e17ffd15 	stw	r5,-12(fp)
 4007d30:	e1bffc15 	stw	r6,-16(fp)
  int result;
  result = _VFPRINTF_R (_REENT, fp, fmt0, ap);
 4007d34:	d0a00117 	ldw	r2,-32764(gp)
 4007d38:	e1fffc17 	ldw	r7,-16(fp)
 4007d3c:	e1bffd17 	ldw	r6,-12(fp)
 4007d40:	e17ffe17 	ldw	r5,-8(fp)
 4007d44:	1009883a 	mov	r4,r2
 4007d48:	4007d680 	call	4007d68 <___vfprintf_internal_r>
 4007d4c:	e0bfff15 	stw	r2,-4(fp)
  return result;
 4007d50:	e0bfff17 	ldw	r2,-4(fp)
}
 4007d54:	e037883a 	mov	sp,fp
 4007d58:	dfc00117 	ldw	ra,4(sp)
 4007d5c:	df000017 	ldw	fp,0(sp)
 4007d60:	dec00204 	addi	sp,sp,8
 4007d64:	f800283a 	ret

04007d68 <___vfprintf_internal_r>:
int
_VFPRINTF_R (struct _reent *data,
       FILE * fp,
       const char *fmt0,
       va_list ap)
{
 4007d68:	deffa804 	addi	sp,sp,-352
 4007d6c:	dfc05715 	stw	ra,348(sp)
 4007d70:	df005615 	stw	fp,344(sp)
 4007d74:	ddc05515 	stw	r23,340(sp)
 4007d78:	dd805415 	stw	r22,336(sp)
 4007d7c:	dd405315 	stw	r21,332(sp)
 4007d80:	dd005215 	stw	r20,328(sp)
 4007d84:	dcc05115 	stw	r19,324(sp)
 4007d88:	dc805015 	stw	r18,320(sp)
 4007d8c:	dc404f15 	stw	r17,316(sp)
 4007d90:	dc004e15 	stw	r16,312(sp)
 4007d94:	df005604 	addi	fp,sp,344
 4007d98:	e13fbd15 	stw	r4,-268(fp)
 4007d9c:	e17fbc15 	stw	r5,-272(fp)
 4007da0:	e1bfbb15 	stw	r6,-276(fp)
 4007da4:	e1ffba15 	stw	r7,-280(fp)
	char *thousands_sep = NULL;
	size_t thsnd_len = 0;
	const char *grouping = NULL;
#endif
#ifdef FLOATING_POINT
	char *decimal_point = _localeconv_r (data)->decimal_point;
 4007da8:	e13fbd17 	ldw	r4,-268(fp)
 4007dac:	400dd540 	call	400dd54 <_localeconv_r>
 4007db0:	10800017 	ldw	r2,0(r2)
 4007db4:	e0bfe815 	stw	r2,-96(fp)
	size_t decp_len = strlen (decimal_point);
 4007db8:	e13fe817 	ldw	r4,-96(fp)
 4007dbc:	4007b340 	call	4007b34 <strlen>
 4007dc0:	e0bfe715 	stw	r2,-100(fp)
	char softsign;		/* temporary negative sign for floats */
	union { int i; _PRINTF_FLOAT_TYPE fp; } _double_ = {0};
 4007dc4:	e03fe015 	stw	zero,-128(fp)
 4007dc8:	e03fe115 	stw	zero,-124(fp)
# define _fpvalue (_double_.fp)
	int expt;		/* integer value of exponent */
	int expsize = 0;	/* character count for expstr */
 4007dcc:	e03ff415 	stw	zero,-48(fp)
	char expstr[MAXEXPLEN];	/* buffer for exponent string */
	int lead;		/* sig figs before decimal or group sep */
#endif /* FLOATING_POINT */
#if defined (FLOATING_POINT) || defined (_WANT_IO_C99_FORMATS)
	int ndig = 0;		/* actual number of digits returned by cvt */
 4007dd0:	e03fdc15 	stw	zero,-144(fp)
	u_quad_t _uquad;	/* integer arguments %[diouxX] */
	enum { OCT, DEC, HEX } base;/* base for [diouxX] conversion */
	int dprec;		/* a copy of prec if [diouxX], 0 otherwise */
	int realsz;		/* field size expanded by dprec */
	int size;		/* size of converted field or string */
	char *xdigs = NULL;	/* digits for [xX] conversion */
 4007dd4:	e03fec15 	stw	zero,-80(fp)
	char ox[2];		/* space for 0x hex-prefix */
#ifdef _MB_CAPABLE
	wchar_t wc;
	mbstate_t state;        /* mbtowc calls from library must not change state */
#endif
	char *malloc_buf = NULL;/* handy pointer for malloced buffers */
 4007dd8:	e03feb15 	stw	zero,-84(fp)
	    (u_long)GET_ARG (N, ap, u_int))
#endif

#ifndef STRING_ONLY
	/* Initialize std streams if not dealing with sprintf family.  */
	CHECK_INIT (data, fp);
 4007ddc:	e0bfbd17 	ldw	r2,-268(fp)
 4007de0:	e0bfe615 	stw	r2,-104(fp)
 4007de4:	e0bfe617 	ldw	r2,-104(fp)
 4007de8:	10000526 	beq	r2,zero,4007e00 <___vfprintf_internal_r+0x98>
 4007dec:	e0bfe617 	ldw	r2,-104(fp)
 4007df0:	10800e17 	ldw	r2,56(r2)
 4007df4:	1000021e 	bne	r2,zero,4007e00 <___vfprintf_internal_r+0x98>
 4007df8:	e13fe617 	ldw	r4,-104(fp)
 4007dfc:	400cbdc0 	call	400cbdc <__sinit>
	_newlib_flockfile_start (fp);

	ORIENT(fp, -1);
 4007e00:	e0bfbc17 	ldw	r2,-272(fp)
 4007e04:	1080030b 	ldhu	r2,12(r2)
 4007e08:	10bfffcc 	andi	r2,r2,65535
 4007e0c:	1088000c 	andi	r2,r2,8192
 4007e10:	10000c1e 	bne	r2,zero,4007e44 <___vfprintf_internal_r+0xdc>
 4007e14:	e0bfbc17 	ldw	r2,-272(fp)
 4007e18:	1080030b 	ldhu	r2,12(r2)
 4007e1c:	10880014 	ori	r2,r2,8192
 4007e20:	1007883a 	mov	r3,r2
 4007e24:	e0bfbc17 	ldw	r2,-272(fp)
 4007e28:	10c0030d 	sth	r3,12(r2)
 4007e2c:	e0bfbc17 	ldw	r2,-272(fp)
 4007e30:	10c01917 	ldw	r3,100(r2)
 4007e34:	00b7ffc4 	movi	r2,-8193
 4007e38:	1886703a 	and	r3,r3,r2
 4007e3c:	e0bfbc17 	ldw	r2,-272(fp)
 4007e40:	10c01915 	stw	r3,100(r2)

	/* sorry, fprintf(read_only_file, "") returns EOF, not 0 */
	if (cantwrite (data, fp)) {
 4007e44:	e0bfbc17 	ldw	r2,-272(fp)
 4007e48:	1080030b 	ldhu	r2,12(r2)
 4007e4c:	10bfffcc 	andi	r2,r2,65535
 4007e50:	1080020c 	andi	r2,r2,8
 4007e54:	10000326 	beq	r2,zero,4007e64 <___vfprintf_internal_r+0xfc>
 4007e58:	e0bfbc17 	ldw	r2,-272(fp)
 4007e5c:	10800417 	ldw	r2,16(r2)
 4007e60:	1000061e 	bne	r2,zero,4007e7c <___vfprintf_internal_r+0x114>
 4007e64:	e17fbc17 	ldw	r5,-272(fp)
 4007e68:	e13fbd17 	ldw	r4,-268(fp)
 4007e6c:	400a2180 	call	400a218 <__swsetup_r>
 4007e70:	10000226 	beq	r2,zero,4007e7c <___vfprintf_internal_r+0x114>
		_newlib_flockfile_exit (fp);
		return (EOF);
 4007e74:	00bfffc4 	movi	r2,-1
 4007e78:	00080606 	br	4009e94 <___vfprintf_internal_r+0x212c>
	}

#ifdef _UNBUF_STREAM_OPT
	/* optimise fprintf(stderr) (and other unbuffered Unix files) */
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
 4007e7c:	e0bfbc17 	ldw	r2,-272(fp)
 4007e80:	1080030b 	ldhu	r2,12(r2)
 4007e84:	10bfffcc 	andi	r2,r2,65535
 4007e88:	1080068c 	andi	r2,r2,26
 4007e8c:	10800298 	cmpnei	r2,r2,10
 4007e90:	10000d1e 	bne	r2,zero,4007ec8 <___vfprintf_internal_r+0x160>
	    fp->_file >= 0) {
 4007e94:	e0bfbc17 	ldw	r2,-272(fp)
 4007e98:	1080038b 	ldhu	r2,14(r2)
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
 4007e9c:	10bfffcc 	andi	r2,r2,65535
 4007ea0:	10a0001c 	xori	r2,r2,32768
 4007ea4:	10a00004 	addi	r2,r2,-32768
 4007ea8:	10000716 	blt	r2,zero,4007ec8 <___vfprintf_internal_r+0x160>
		_newlib_flockfile_exit (fp);
		return (__sbprintf (data, fp, fmt0, ap));
 4007eac:	e0bfba17 	ldw	r2,-280(fp)
 4007eb0:	100f883a 	mov	r7,r2
 4007eb4:	e1bfbb17 	ldw	r6,-276(fp)
 4007eb8:	e17fbc17 	ldw	r5,-272(fp)
 4007ebc:	e13fbd17 	ldw	r4,-268(fp)
 4007ec0:	4007c280 	call	4007c28 <__sbprintf>
 4007ec4:	0007f306 	br	4009e94 <___vfprintf_internal_r+0x212c>
		}
		fp->_bf._size = 64;
        }
#endif /* STRING_ONLY */

	fmt = (char *)fmt0;
 4007ec8:	e57fbb17 	ldw	r21,-276(fp)
#ifdef _FVWRITE_IN_STREAMIO
	uio.uio_iov = iovp = iov;
 4007ecc:	e43fc904 	addi	r16,fp,-220
 4007ed0:	e43fd915 	stw	r16,-156(fp)
	uio.uio_resid = 0;
 4007ed4:	e03fdb15 	stw	zero,-148(fp)
	uio.uio_iovcnt = 0;
 4007ed8:	e03fda15 	stw	zero,-152(fp)
#endif
	ret = 0;
 4007edc:	e03ff715 	stw	zero,-36(fp)

	/*
	 * Scan the format for conversions (`%' character).
	 */
	for (;;) {
	        cp = fmt;
 4007ee0:	a825883a 	mov	r18,r21
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
 4007ee4:	00000106 	br	4007eec <___vfprintf_internal_r+0x184>
                    fmt += 1;
 4007ee8:	ad400044 	addi	r21,r21,1
                while (*fmt != '\0' && *fmt != '%')
 4007eec:	a8800003 	ldbu	r2,0(r21)
 4007ef0:	10803fcc 	andi	r2,r2,255
 4007ef4:	1080201c 	xori	r2,r2,128
 4007ef8:	10bfe004 	addi	r2,r2,-128
 4007efc:	10000626 	beq	r2,zero,4007f18 <___vfprintf_internal_r+0x1b0>
 4007f00:	a8800003 	ldbu	r2,0(r21)
 4007f04:	10803fcc 	andi	r2,r2,255
 4007f08:	1080201c 	xori	r2,r2,128
 4007f0c:	10bfe004 	addi	r2,r2,-128
 4007f10:	10800958 	cmpnei	r2,r2,37
 4007f14:	103ff41e 	bne	r2,zero,4007ee8 <___vfprintf_internal_r+0x180>
#endif
		if ((m = fmt - cp) != 0) {
 4007f18:	aca3c83a 	sub	r17,r21,r18
 4007f1c:	88001826 	beq	r17,zero,4007f80 <___vfprintf_internal_r+0x218>
			PRINT (cp, m);
 4007f20:	84800015 	stw	r18,0(r16)
 4007f24:	8805883a 	mov	r2,r17
 4007f28:	80800115 	stw	r2,4(r16)
 4007f2c:	e0bfdb17 	ldw	r2,-148(fp)
 4007f30:	8807883a 	mov	r3,r17
 4007f34:	10c5883a 	add	r2,r2,r3
 4007f38:	e0bfdb15 	stw	r2,-148(fp)
 4007f3c:	84000204 	addi	r16,r16,8
 4007f40:	e0bfda17 	ldw	r2,-152(fp)
 4007f44:	10800044 	addi	r2,r2,1
 4007f48:	e0bfda15 	stw	r2,-152(fp)
 4007f4c:	e0bfda17 	ldw	r2,-152(fp)
 4007f50:	10800210 	cmplti	r2,r2,8
 4007f54:	1000071e 	bne	r2,zero,4007f74 <___vfprintf_internal_r+0x20c>
 4007f58:	e0bfd904 	addi	r2,fp,-156
 4007f5c:	100d883a 	mov	r6,r2
 4007f60:	e17fbc17 	ldw	r5,-272(fp)
 4007f64:	e13fbd17 	ldw	r4,-268(fp)
 4007f68:	40121340 	call	4012134 <__sprint_r>
 4007f6c:	1007731e 	bne	r2,zero,4009d3c <___vfprintf_internal_r+0x1fd4>
 4007f70:	e43fc904 	addi	r16,fp,-220
			ret += m;
 4007f74:	e0bff717 	ldw	r2,-36(fp)
 4007f78:	1445883a 	add	r2,r2,r17
 4007f7c:	e0bff715 	stw	r2,-36(fp)
		}
#ifdef _MB_CAPABLE
		if (n <= 0)
                    goto done;
#else
                if (*fmt == '\0')
 4007f80:	a8800003 	ldbu	r2,0(r21)
 4007f84:	10803fcc 	andi	r2,r2,255
 4007f88:	1080201c 	xori	r2,r2,128
 4007f8c:	10bfe004 	addi	r2,r2,-128
 4007f90:	10075c26 	beq	r2,zero,4009d04 <___vfprintf_internal_r+0x1f9c>
                    goto done;
#endif
		fmt_anchor = fmt;
 4007f94:	e57fe515 	stw	r21,-108(fp)
		fmt++;		/* skip over '%' */
 4007f98:	ad400044 	addi	r21,r21,1

		flags = 0;
 4007f9c:	0023883a 	mov	r17,zero
		dprec = 0;
 4007fa0:	e03fef15 	stw	zero,-68(fp)
		width = 0;
 4007fa4:	e03ff615 	stw	zero,-40(fp)
		prec = -1;
 4007fa8:	00bfffc4 	movi	r2,-1
 4007fac:	e0bff515 	stw	r2,-44(fp)
		sign = '\0';
 4007fb0:	e03fe2c5 	stb	zero,-117(fp)
#ifdef FLOATING_POINT
		lead = 0;
 4007fb4:	e03ff315 	stw	zero,-52(fp)
#ifndef _NO_POS_ARGS
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
 4007fb8:	a805883a 	mov	r2,r21
 4007fbc:	15400044 	addi	r21,r2,1
 4007fc0:	10800003 	ldbu	r2,0(r2)
 4007fc4:	15003fcc 	andi	r20,r2,255
 4007fc8:	a500201c 	xori	r20,r20,128
 4007fcc:	a53fe004 	addi	r20,r20,-128
 4007fd0:	a0bff804 	addi	r2,r20,-32
 4007fd4:	10c01668 	cmpgeui	r3,r2,89
 4007fd8:	1803731e 	bne	r3,zero,4008da8 <___vfprintf_internal_r+0x1040>
 4007fdc:	100690ba 	slli	r3,r2,2
 4007fe0:	00810034 	movhi	r2,1024
 4007fe4:	1885883a 	add	r2,r3,r2
 4007fe8:	109ffc17 	ldw	r2,32752(r2)
 4007fec:	1000683a 	jmp	r2
 4007ff0:	04008154 	movui	r16,517
 4007ff4:	04008da8 	cmpgeui	r16,zero,566
 4007ff8:	04008da8 	cmpgeui	r16,zero,566
 4007ffc:	04008174 	movhi	r16,517
 4008000:	04008da8 	cmpgeui	r16,zero,566
 4008004:	04008da8 	cmpgeui	r16,zero,566
 4008008:	04008da8 	cmpgeui	r16,zero,566
 400800c:	04008da8 	cmpgeui	r16,zero,566
 4008010:	04008da8 	cmpgeui	r16,zero,566
 4008014:	04008da8 	cmpgeui	r16,zero,566
 4008018:	0400817c 	xorhi	r16,zero,517
 400801c:	040081b0 	cmpltui	r16,zero,518
 4008020:	04008da8 	cmpgeui	r16,zero,566
 4008024:	040081a8 	cmpgeui	r16,zero,518
 4008028:	040081bc 	xorhi	r16,zero,518
 400802c:	04008da8 	cmpgeui	r16,zero,566
 4008030:	04008260 	cmpeqi	r16,zero,521
 4008034:	04008268 	cmpgeui	r16,zero,521
 4008038:	04008268 	cmpgeui	r16,zero,521
 400803c:	04008268 	cmpgeui	r16,zero,521
 4008040:	04008268 	cmpgeui	r16,zero,521
 4008044:	04008268 	cmpgeui	r16,zero,521
 4008048:	04008268 	cmpgeui	r16,zero,521
 400804c:	04008268 	cmpgeui	r16,zero,521
 4008050:	04008268 	cmpgeui	r16,zero,521
 4008054:	04008268 	cmpgeui	r16,zero,521
 4008058:	04008da8 	cmpgeui	r16,zero,566
 400805c:	04008da8 	cmpgeui	r16,zero,566
 4008060:	04008da8 	cmpgeui	r16,zero,566
 4008064:	04008da8 	cmpgeui	r16,zero,566
 4008068:	04008da8 	cmpgeui	r16,zero,566
 400806c:	04008da8 	cmpgeui	r16,zero,566
 4008070:	04008da8 	cmpgeui	r16,zero,566
 4008074:	04008da8 	cmpgeui	r16,zero,566
 4008078:	04008da8 	cmpgeui	r16,zero,566
 400807c:	04008da8 	cmpgeui	r16,zero,566
 4008080:	04008320 	cmpeqi	r16,zero,524
 4008084:	04008420 	cmpeqi	r16,zero,528
 4008088:	04008da8 	cmpgeui	r16,zero,566
 400808c:	04008420 	cmpeqi	r16,zero,528
 4008090:	04008da8 	cmpgeui	r16,zero,566
 4008094:	04008da8 	cmpgeui	r16,zero,566
 4008098:	04008da8 	cmpgeui	r16,zero,566
 400809c:	04008da8 	cmpgeui	r16,zero,566
 40080a0:	040082b4 	movhi	r16,522
 40080a4:	04008da8 	cmpgeui	r16,zero,566
 40080a8:	04008da8 	cmpgeui	r16,zero,566
 40080ac:	04008860 	cmpeqi	r16,zero,545
 40080b0:	04008da8 	cmpgeui	r16,zero,566
 40080b4:	04008da8 	cmpgeui	r16,zero,566
 40080b8:	04008da8 	cmpgeui	r16,zero,566
 40080bc:	04008da8 	cmpgeui	r16,zero,566
 40080c0:	04008da8 	cmpgeui	r16,zero,566
 40080c4:	040089cc 	andi	r16,zero,551
 40080c8:	04008da8 	cmpgeui	r16,zero,566
 40080cc:	04008da8 	cmpgeui	r16,zero,566
 40080d0:	04008a78 	rdprs	r16,zero,553
 40080d4:	04008da8 	cmpgeui	r16,zero,566
 40080d8:	04008da8 	cmpgeui	r16,zero,566
 40080dc:	04008da8 	cmpgeui	r16,zero,566
 40080e0:	04008da8 	cmpgeui	r16,zero,566
 40080e4:	04008da8 	cmpgeui	r16,zero,566
 40080e8:	04008da8 	cmpgeui	r16,zero,566
 40080ec:	04008da8 	cmpgeui	r16,zero,566
 40080f0:	04008da8 	cmpgeui	r16,zero,566
 40080f4:	04008da8 	cmpgeui	r16,zero,566
 40080f8:	04008da8 	cmpgeui	r16,zero,566
 40080fc:	040082f8 	rdprs	r16,zero,523
 4008100:	04008324 	muli	r16,zero,524
 4008104:	04008420 	cmpeqi	r16,zero,528
 4008108:	04008420 	cmpeqi	r16,zero,528
 400810c:	04008420 	cmpeqi	r16,zero,528
 4008110:	040082bc 	xorhi	r16,zero,522
 4008114:	04008324 	muli	r16,zero,524
 4008118:	04008da8 	cmpgeui	r16,zero,566
 400811c:	04008da8 	cmpgeui	r16,zero,566
 4008120:	040082c4 	movi	r16,523
 4008124:	04008da8 	cmpgeui	r16,zero,566
 4008128:	040087c0 	call	40087c <__alt_mem_dram-0x3bff784>
 400812c:	04008864 	muli	r16,zero,545
 4008130:	040088f8 	rdprs	r16,zero,547
 4008134:	040082f0 	cmpltui	r16,zero,523
 4008138:	04008da8 	cmpgeui	r16,zero,566
 400813c:	04008940 	call	400894 <__alt_mem_dram-0x3bff76c>
 4008140:	04008da8 	cmpgeui	r16,zero,566
 4008144:	040089d0 	cmplti	r16,zero,551
 4008148:	04008da8 	cmpgeui	r16,zero,566
 400814c:	04008da8 	cmpgeui	r16,zero,566
 4008150:	04008a88 	cmpgei	r16,zero,554
			/*
			 * ``If the space and + flags both appear, the space
			 * flag will be ignored.''
			 *	-- ANSI X3J11
			 */
			if (!sign)
 4008154:	e0bfe2c3 	ldbu	r2,-117(fp)
 4008158:	10803fcc 	andi	r2,r2,255
 400815c:	1080201c 	xori	r2,r2,128
 4008160:	10bfe004 	addi	r2,r2,-128
 4008164:	103f941e 	bne	r2,zero,4007fb8 <___vfprintf_internal_r+0x250>
				sign = ' ';
 4008168:	00800804 	movi	r2,32
 400816c:	e0bfe2c5 	stb	r2,-117(fp)
			goto rflag;
 4008170:	003f9106 	br	4007fb8 <___vfprintf_internal_r+0x250>
		case '#':
			flags |= ALT;
 4008174:	8c400054 	ori	r17,r17,1
			goto rflag;
 4008178:	003f8f06 	br	4007fb8 <___vfprintf_internal_r+0x250>
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
 400817c:	e0bfba17 	ldw	r2,-280(fp)
 4008180:	10c00104 	addi	r3,r2,4
 4008184:	e0ffba15 	stw	r3,-280(fp)
 4008188:	10800017 	ldw	r2,0(r2)
 400818c:	e0bff615 	stw	r2,-40(fp)
#ifndef _NO_POS_ARGS
			is_pos_arg = old_is_pos_arg;
#endif
			if (width >= 0)
 4008190:	e0bff617 	ldw	r2,-40(fp)
 4008194:	10000116 	blt	r2,zero,400819c <___vfprintf_internal_r+0x434>
				goto rflag;
 4008198:	003f8706 	br	4007fb8 <___vfprintf_internal_r+0x250>
			width = -width;
 400819c:	e0bff617 	ldw	r2,-40(fp)
 40081a0:	0085c83a 	sub	r2,zero,r2
 40081a4:	e0bff615 	stw	r2,-40(fp)
			/* FALLTHROUGH */
		case '-':
			flags |= LADJUST;
 40081a8:	8c400114 	ori	r17,r17,4
			goto rflag;
 40081ac:	003f8206 	br	4007fb8 <___vfprintf_internal_r+0x250>
		case '+':
			sign = '+';
 40081b0:	00800ac4 	movi	r2,43
 40081b4:	e0bfe2c5 	stb	r2,-117(fp)
			goto rflag;
 40081b8:	003f7f06 	br	4007fb8 <___vfprintf_internal_r+0x250>
		case '.':
			if ((ch = *fmt++) == '*') {
 40081bc:	a805883a 	mov	r2,r21
 40081c0:	15400044 	addi	r21,r2,1
 40081c4:	10800003 	ldbu	r2,0(r2)
 40081c8:	15003fcc 	andi	r20,r2,255
 40081cc:	a500201c 	xori	r20,r20,128
 40081d0:	a53fe004 	addi	r20,r20,-128
 40081d4:	a0800a98 	cmpnei	r2,r20,42
 40081d8:	10000a1e 	bne	r2,zero,4008204 <___vfprintf_internal_r+0x49c>
						fmt = old_fmt;
						goto rflag;
					}
				}
#endif /* !_NO_POS_ARGS */
				prec = GET_ARG (n, ap, int);
 40081dc:	e0bfba17 	ldw	r2,-280(fp)
 40081e0:	10c00104 	addi	r3,r2,4
 40081e4:	e0ffba15 	stw	r3,-280(fp)
 40081e8:	10800017 	ldw	r2,0(r2)
 40081ec:	e0bff515 	stw	r2,-44(fp)
#ifndef _NO_POS_ARGS
				is_pos_arg = old_is_pos_arg;
#endif
				if (prec < 0)
 40081f0:	e0bff517 	ldw	r2,-44(fp)
 40081f4:	103f700e 	bge	r2,zero,4007fb8 <___vfprintf_internal_r+0x250>
					prec = -1;
 40081f8:	00bfffc4 	movi	r2,-1
 40081fc:	e0bff515 	stw	r2,-44(fp)
				goto rflag;
 4008200:	003f6d06 	br	4007fb8 <___vfprintf_internal_r+0x250>
			}
			n = 0;
 4008204:	0027883a 	mov	r19,zero
			while (is_digit (ch)) {
 4008208:	00000d06 	br	4008240 <___vfprintf_internal_r+0x4d8>
				n = 10 * n + to_digit (ch);
 400820c:	9805883a 	mov	r2,r19
 4008210:	100490ba 	slli	r2,r2,2
 4008214:	14c5883a 	add	r2,r2,r19
 4008218:	1085883a 	add	r2,r2,r2
 400821c:	1007883a 	mov	r3,r2
 4008220:	a0bff404 	addi	r2,r20,-48
 4008224:	18a7883a 	add	r19,r3,r2
				ch = *fmt++;
 4008228:	a805883a 	mov	r2,r21
 400822c:	15400044 	addi	r21,r2,1
 4008230:	10800003 	ldbu	r2,0(r2)
 4008234:	15003fcc 	andi	r20,r2,255
 4008238:	a500201c 	xori	r20,r20,128
 400823c:	a53fe004 	addi	r20,r20,-128
			while (is_digit (ch)) {
 4008240:	a0bff404 	addi	r2,r20,-48
 4008244:	108002b0 	cmpltui	r2,r2,10
 4008248:	103ff01e 	bne	r2,zero,400820c <___vfprintf_internal_r+0x4a4>
			}
			prec = n < 0 ? -1 : n;
 400824c:	9805883a 	mov	r2,r19
 4008250:	1000010e 	bge	r2,zero,4008258 <___vfprintf_internal_r+0x4f0>
 4008254:	00bfffc4 	movi	r2,-1
 4008258:	e0bff515 	stw	r2,-44(fp)
			goto reswitch;
 400825c:	003f5c06 	br	4007fd0 <___vfprintf_internal_r+0x268>
			/*
			 * ``Note that 0 is taken as a flag, not as the
			 * beginning of a field width.''
			 *	-- ANSI X3J11
			 */
			flags |= ZEROPAD;
 4008260:	8c402014 	ori	r17,r17,128
			goto rflag;
 4008264:	003f5406 	br	4007fb8 <___vfprintf_internal_r+0x250>
		case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
 4008268:	0027883a 	mov	r19,zero
			do {
				n = 10 * n + to_digit (ch);
 400826c:	9805883a 	mov	r2,r19
 4008270:	100490ba 	slli	r2,r2,2
 4008274:	14c5883a 	add	r2,r2,r19
 4008278:	1085883a 	add	r2,r2,r2
 400827c:	1007883a 	mov	r3,r2
 4008280:	a0bff404 	addi	r2,r20,-48
 4008284:	18a7883a 	add	r19,r3,r2
				ch = *fmt++;
 4008288:	a805883a 	mov	r2,r21
 400828c:	15400044 	addi	r21,r2,1
 4008290:	10800003 	ldbu	r2,0(r2)
 4008294:	15003fcc 	andi	r20,r2,255
 4008298:	a500201c 	xori	r20,r20,128
 400829c:	a53fe004 	addi	r20,r20,-128
			} while (is_digit (ch));
 40082a0:	a0bff404 	addi	r2,r20,-48
 40082a4:	108002b0 	cmpltui	r2,r2,10
 40082a8:	103ff01e 	bne	r2,zero,400826c <___vfprintf_internal_r+0x504>
				}
				else
					goto error;
			}
#endif /* !_NO_POS_ARGS */
			width = n;
 40082ac:	e4fff615 	stw	r19,-40(fp)
			goto reswitch;
 40082b0:	003f4706 	br	4007fd0 <___vfprintf_internal_r+0x268>
#ifdef FLOATING_POINT
		case 'L':
			flags |= LONGDBL;
 40082b4:	8c400214 	ori	r17,r17,8
			goto rflag;
 40082b8:	003f3f06 	br	4007fb8 <___vfprintf_internal_r+0x250>
			if (*fmt == 'h') {
				fmt++;
				flags |= CHARINT;
			} else
#endif
				flags |= SHORTINT;
 40082bc:	8c401014 	ori	r17,r17,64
			goto rflag;
 40082c0:	003f3d06 	br	4007fb8 <___vfprintf_internal_r+0x250>
		case 'l':
#if defined _WANT_IO_C99_FORMATS || !defined _NO_LONGLONG
			if (*fmt == 'l') {
 40082c4:	a8800003 	ldbu	r2,0(r21)
 40082c8:	10803fcc 	andi	r2,r2,255
 40082cc:	1080201c 	xori	r2,r2,128
 40082d0:	10bfe004 	addi	r2,r2,-128
 40082d4:	10801b18 	cmpnei	r2,r2,108
 40082d8:	1000031e 	bne	r2,zero,40082e8 <___vfprintf_internal_r+0x580>
				fmt++;
 40082dc:	ad400044 	addi	r21,r21,1
				flags |= QUADINT;
 40082e0:	8c400814 	ori	r17,r17,32
 40082e4:	003f3406 	br	4007fb8 <___vfprintf_internal_r+0x250>
			} else
#endif
				flags |= LONGINT;
 40082e8:	8c400414 	ori	r17,r17,16
			goto rflag;
 40082ec:	003f3206 	br	4007fb8 <___vfprintf_internal_r+0x250>
		case 'q': /* extension */
			flags |= QUADINT;
 40082f0:	8c400814 	ori	r17,r17,32
			goto rflag;
 40082f4:	003f3006 	br	4007fb8 <___vfprintf_internal_r+0x250>
		    flags |= QUADINT;
		  goto rflag;
		case 'C':
#endif /* _WANT_IO_C99_FORMATS */
		case 'c':
			cp = buf;
 40082f8:	e4bfbf04 	addi	r18,fp,-260
				}
			}
			else
#endif /* _MB_CAPABLE */
			{
				*cp = GET_ARG (N, ap, int);
 40082fc:	e0bfba17 	ldw	r2,-280(fp)
 4008300:	10c00104 	addi	r3,r2,4
 4008304:	e0ffba15 	stw	r3,-280(fp)
 4008308:	10800017 	ldw	r2,0(r2)
 400830c:	90800005 	stb	r2,0(r18)
				size = 1;
 4008310:	00800044 	movi	r2,1
 4008314:	e0bfed15 	stw	r2,-76(fp)
			}
			sign = '\0';
 4008318:	e03fe2c5 	stb	zero,-117(fp)
			break;
 400831c:	0002ab06 	br	4008dcc <___vfprintf_internal_r+0x1064>
		case 'D':  /* extension */
			flags |= LONGINT;
 4008320:	8c400414 	ori	r17,r17,16
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			_uquad = SARG ();
 4008324:	8880080c 	andi	r2,r17,32
 4008328:	10000826 	beq	r2,zero,400834c <___vfprintf_internal_r+0x5e4>
 400832c:	e13fba17 	ldw	r4,-280(fp)
 4008330:	20800204 	addi	r2,r4,8
 4008334:	e0bfba15 	stw	r2,-280(fp)
 4008338:	20800017 	ldw	r2,0(r4)
 400833c:	20c00117 	ldw	r3,4(r4)
 4008340:	e0bfb815 	stw	r2,-288(fp)
 4008344:	e0ffb915 	stw	r3,-284(fp)
 4008348:	00001e06 	br	40083c4 <___vfprintf_internal_r+0x65c>
 400834c:	8880040c 	andi	r2,r17,16
 4008350:	10000826 	beq	r2,zero,4008374 <___vfprintf_internal_r+0x60c>
 4008354:	e0bfba17 	ldw	r2,-280(fp)
 4008358:	10c00104 	addi	r3,r2,4
 400835c:	e0ffba15 	stw	r3,-280(fp)
 4008360:	10800017 	ldw	r2,0(r2)
 4008364:	e0bfb815 	stw	r2,-288(fp)
 4008368:	1005d7fa 	srai	r2,r2,31
 400836c:	e0bfb915 	stw	r2,-284(fp)
 4008370:	00001406 	br	40083c4 <___vfprintf_internal_r+0x65c>
 4008374:	8880100c 	andi	r2,r17,64
 4008378:	10000b26 	beq	r2,zero,40083a8 <___vfprintf_internal_r+0x640>
 400837c:	e0bfba17 	ldw	r2,-280(fp)
 4008380:	10c00104 	addi	r3,r2,4
 4008384:	e0ffba15 	stw	r3,-280(fp)
 4008388:	10800017 	ldw	r2,0(r2)
 400838c:	10bfffcc 	andi	r2,r2,65535
 4008390:	10a0001c 	xori	r2,r2,32768
 4008394:	10a00004 	addi	r2,r2,-32768
 4008398:	e0bfb815 	stw	r2,-288(fp)
 400839c:	1005d7fa 	srai	r2,r2,31
 40083a0:	e0bfb915 	stw	r2,-284(fp)
 40083a4:	00000706 	br	40083c4 <___vfprintf_internal_r+0x65c>
 40083a8:	e0bfba17 	ldw	r2,-280(fp)
 40083ac:	10c00104 	addi	r3,r2,4
 40083b0:	e0ffba15 	stw	r3,-280(fp)
 40083b4:	10800017 	ldw	r2,0(r2)
 40083b8:	e0bfb815 	stw	r2,-288(fp)
 40083bc:	1005d7fa 	srai	r2,r2,31
 40083c0:	e0bfb915 	stw	r2,-284(fp)
 40083c4:	e0bfb817 	ldw	r2,-288(fp)
 40083c8:	e0bff115 	stw	r2,-60(fp)
 40083cc:	e0bfb917 	ldw	r2,-284(fp)
 40083d0:	e0bff215 	stw	r2,-56(fp)
#ifndef _NO_LONGLONG
			if ((quad_t)_uquad < 0)
 40083d4:	e0bff117 	ldw	r2,-60(fp)
 40083d8:	e0fff217 	ldw	r3,-56(fp)
 40083dc:	18000d0e 	bge	r3,zero,4008414 <___vfprintf_internal_r+0x6ac>
#else
			if ((long) _uquad < 0)
#endif
			{

				_uquad = -_uquad;
 40083e0:	000d883a 	mov	r6,zero
 40083e4:	000f883a 	mov	r7,zero
 40083e8:	e13ff117 	ldw	r4,-60(fp)
 40083ec:	e17ff217 	ldw	r5,-56(fp)
 40083f0:	3105c83a 	sub	r2,r6,r4
 40083f4:	3091803a 	cmpltu	r8,r6,r2
 40083f8:	3947c83a 	sub	r3,r7,r5
 40083fc:	1a09c83a 	sub	r4,r3,r8
 4008400:	2007883a 	mov	r3,r4
 4008404:	e0bff115 	stw	r2,-60(fp)
 4008408:	e0fff215 	stw	r3,-56(fp)
				sign = '-';
 400840c:	00800b44 	movi	r2,45
 4008410:	e0bfe2c5 	stb	r2,-117(fp)
			}
			base = DEC;
 4008414:	00800044 	movi	r2,1
 4008418:	e0bff015 	stw	r2,-64(fp)
			goto number;
 400841c:	0001d406 	br	4008b70 <___vfprintf_internal_r+0xe08>
		case 'E':
		case 'f':
		case 'g':
		case 'G':
# ifdef _NO_LONGDBL
			if (flags & LONGDBL) {
 4008420:	8880020c 	andi	r2,r17,8
 4008424:	10000826 	beq	r2,zero,4008448 <___vfprintf_internal_r+0x6e0>
				_fpvalue = (double) GET_ARG (N, ap, _LONG_DOUBLE);
 4008428:	e13fba17 	ldw	r4,-280(fp)
 400842c:	20800204 	addi	r2,r4,8
 4008430:	e0bfba15 	stw	r2,-280(fp)
 4008434:	20800017 	ldw	r2,0(r4)
 4008438:	20c00117 	ldw	r3,4(r4)
 400843c:	e0bfe015 	stw	r2,-128(fp)
 4008440:	e0ffe115 	stw	r3,-124(fp)
 4008444:	00000706 	br	4008464 <___vfprintf_internal_r+0x6fc>
			} else {
				_fpvalue = GET_ARG (N, ap, double);
 4008448:	e13fba17 	ldw	r4,-280(fp)
 400844c:	20800204 	addi	r2,r4,8
 4008450:	e0bfba15 	stw	r2,-280(fp)
 4008454:	20800017 	ldw	r2,0(r4)
 4008458:	20c00117 	ldw	r3,4(r4)
 400845c:	e0bfe015 	stw	r2,-128(fp)
 4008460:	e0ffe115 	stw	r3,-124(fp)

			   If the output is infinite or NaN, leading
			   zeros are not permitted.  Otherwise, scanf
			   could not read what printf wrote.
			 */
			if (isinf (_fpvalue)) {
 4008464:	e0bfe017 	ldw	r2,-128(fp)
 4008468:	e0ffe117 	ldw	r3,-124(fp)
 400846c:	e0bfb215 	stw	r2,-312(fp)
 4008470:	01200034 	movhi	r4,32768
 4008474:	213fffc4 	addi	r4,r4,-1
 4008478:	1904703a 	and	r2,r3,r4
 400847c:	e0bfb315 	stw	r2,-308(fp)
 4008480:	04c00044 	movi	r19,1
 4008484:	01bfffc4 	movi	r6,-1
 4008488:	01dffc34 	movhi	r7,32752
 400848c:	39ffffc4 	addi	r7,r7,-1
 4008490:	e13fb217 	ldw	r4,-312(fp)
 4008494:	e17fb317 	ldw	r5,-308(fp)
 4008498:	4017b400 	call	4017b40 <__unorddf2>
 400849c:	1000081e 	bne	r2,zero,40084c0 <___vfprintf_internal_r+0x758>
 40084a0:	01bfffc4 	movi	r6,-1
 40084a4:	01dffc34 	movhi	r7,32752
 40084a8:	39ffffc4 	addi	r7,r7,-1
 40084ac:	e13fb217 	ldw	r4,-312(fp)
 40084b0:	e17fb317 	ldw	r5,-308(fp)
 40084b4:	40169740 	call	4016974 <__ledf2>
 40084b8:	0080010e 	bge	zero,r2,40084c0 <___vfprintf_internal_r+0x758>
 40084bc:	0027883a 	mov	r19,zero
 40084c0:	9880005c 	xori	r2,r19,1
 40084c4:	10803fcc 	andi	r2,r2,255
 40084c8:	10000226 	beq	r2,zero,40084d4 <___vfprintf_internal_r+0x76c>
 40084cc:	00800044 	movi	r2,1
 40084d0:	00000106 	br	40084d8 <___vfprintf_internal_r+0x770>
 40084d4:	0005883a 	mov	r2,zero
 40084d8:	10803fcc 	andi	r2,r2,255
 40084dc:	10001626 	beq	r2,zero,4008538 <___vfprintf_internal_r+0x7d0>
				if (_fpvalue < 0)
 40084e0:	e0bfe017 	ldw	r2,-128(fp)
 40084e4:	e0ffe117 	ldw	r3,-124(fp)
 40084e8:	000d883a 	mov	r6,zero
 40084ec:	000f883a 	mov	r7,zero
 40084f0:	1009883a 	mov	r4,r2
 40084f4:	180b883a 	mov	r5,r3
 40084f8:	40169740 	call	4016974 <__ledf2>
 40084fc:	1000020e 	bge	r2,zero,4008508 <___vfprintf_internal_r+0x7a0>
					sign = '-';
 4008500:	00800b44 	movi	r2,45
 4008504:	e0bfe2c5 	stb	r2,-117(fp)
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
 4008508:	a0801208 	cmpgei	r2,r20,72
 400850c:	1000031e 	bne	r2,zero,400851c <___vfprintf_internal_r+0x7b4>
					cp = "INF";
 4008510:	048100b4 	movhi	r18,1026
 4008514:	94ab0404 	addi	r18,r18,-21488
 4008518:	00000206 	br	4008524 <___vfprintf_internal_r+0x7bc>
				else
					cp = "inf";
 400851c:	048100b4 	movhi	r18,1026
 4008520:	94ab0504 	addi	r18,r18,-21484
				size = 3;
 4008524:	008000c4 	movi	r2,3
 4008528:	e0bfed15 	stw	r2,-76(fp)
				flags &= ~ZEROPAD;
 400852c:	00bfdfc4 	movi	r2,-129
 4008530:	88a2703a 	and	r17,r17,r2
				break;
 4008534:	00022506 	br	4008dcc <___vfprintf_internal_r+0x1064>
			}
			if (isnan (_fpvalue)) {
 4008538:	e0bfe017 	ldw	r2,-128(fp)
 400853c:	e0ffe117 	ldw	r3,-124(fp)
 4008540:	100d883a 	mov	r6,r2
 4008544:	180f883a 	mov	r7,r3
 4008548:	1009883a 	mov	r4,r2
 400854c:	180b883a 	mov	r5,r3
 4008550:	4017b400 	call	4017b40 <__unorddf2>
 4008554:	10001326 	beq	r2,zero,40085a4 <___vfprintf_internal_r+0x83c>
				if (signbit (_fpvalue))
 4008558:	e0bfe017 	ldw	r2,-128(fp)
 400855c:	e0ffe117 	ldw	r3,-124(fp)
 4008560:	1805883a 	mov	r2,r3
 4008564:	10a0002c 	andhi	r2,r2,32768
 4008568:	10000226 	beq	r2,zero,4008574 <___vfprintf_internal_r+0x80c>
					sign = '-';
 400856c:	00800b44 	movi	r2,45
 4008570:	e0bfe2c5 	stb	r2,-117(fp)
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
 4008574:	a0801208 	cmpgei	r2,r20,72
 4008578:	1000031e 	bne	r2,zero,4008588 <___vfprintf_internal_r+0x820>
					cp = "NAN";
 400857c:	048100b4 	movhi	r18,1026
 4008580:	94ab0604 	addi	r18,r18,-21480
 4008584:	00000206 	br	4008590 <___vfprintf_internal_r+0x828>
				else
					cp = "nan";
 4008588:	048100b4 	movhi	r18,1026
 400858c:	94ab0704 	addi	r18,r18,-21476
				size = 3;
 4008590:	008000c4 	movi	r2,3
 4008594:	e0bfed15 	stw	r2,-76(fp)
				flags &= ~ZEROPAD;
 4008598:	00bfdfc4 	movi	r2,-129
 400859c:	88a2703a 	and	r17,r17,r2
				break;
 40085a0:	00020a06 	br	4008dcc <___vfprintf_internal_r+0x1064>
				  }
				else
				  cp = buf;
			} else
# endif /* _WANT_IO_C99_FORMATS */
			if (prec == -1) {
 40085a4:	e0bff517 	ldw	r2,-44(fp)
 40085a8:	10bfffd8 	cmpnei	r2,r2,-1
 40085ac:	1000031e 	bne	r2,zero,40085bc <___vfprintf_internal_r+0x854>
				prec = DEFPREC;
 40085b0:	00800184 	movi	r2,6
 40085b4:	e0bff515 	stw	r2,-44(fp)
 40085b8:	00000806 	br	40085dc <___vfprintf_internal_r+0x874>
			} else if ((ch == 'g' || ch == 'G') && prec == 0) {
 40085bc:	a08019e0 	cmpeqi	r2,r20,103
 40085c0:	1000021e 	bne	r2,zero,40085cc <___vfprintf_internal_r+0x864>
 40085c4:	a08011d8 	cmpnei	r2,r20,71
 40085c8:	1000041e 	bne	r2,zero,40085dc <___vfprintf_internal_r+0x874>
 40085cc:	e0bff517 	ldw	r2,-44(fp)
 40085d0:	1000021e 	bne	r2,zero,40085dc <___vfprintf_internal_r+0x874>
				prec = 1;
 40085d4:	00800044 	movi	r2,1
 40085d8:	e0bff515 	stw	r2,-44(fp)
			}

			flags |= FPT;
 40085dc:	8c404014 	ori	r17,r17,256

			cp = cvt (data, _fpvalue, prec, flags, &softsign,
 40085e0:	e0bfe017 	ldw	r2,-128(fp)
 40085e4:	e0ffe117 	ldw	r3,-124(fp)
 40085e8:	dc800515 	stw	r18,20(sp)
 40085ec:	e13fdc04 	addi	r4,fp,-144
 40085f0:	d9000415 	stw	r4,16(sp)
 40085f4:	dd000315 	stw	r20,12(sp)
 40085f8:	e13fdf04 	addi	r4,fp,-132
 40085fc:	d9000215 	stw	r4,8(sp)
 4008600:	e13fe284 	addi	r4,fp,-118
 4008604:	d9000115 	stw	r4,4(sp)
 4008608:	dc400015 	stw	r17,0(sp)
 400860c:	e1fff517 	ldw	r7,-44(fp)
 4008610:	100b883a 	mov	r5,r2
 4008614:	180d883a 	mov	r6,r3
 4008618:	e13fbd17 	ldw	r4,-268(fp)
 400861c:	4009ec80 	call	4009ec8 <cvt>
 4008620:	1025883a 	mov	r18,r2
				  &expt, ch, &ndig, cp);

			if (ch == 'g' || ch == 'G') {
 4008624:	a08019e0 	cmpeqi	r2,r20,103
 4008628:	1000021e 	bne	r2,zero,4008634 <___vfprintf_internal_r+0x8cc>
 400862c:	a08011d8 	cmpnei	r2,r20,71
 4008630:	1000091e 	bne	r2,zero,4008658 <___vfprintf_internal_r+0x8f0>
				if (expt <= -4 || expt > prec)
 4008634:	e0bfdf17 	ldw	r2,-132(fp)
 4008638:	10bfff50 	cmplti	r2,r2,-3
 400863c:	1000031e 	bne	r2,zero,400864c <___vfprintf_internal_r+0x8e4>
 4008640:	e0bfdf17 	ldw	r2,-132(fp)
 4008644:	e0fff517 	ldw	r3,-44(fp)
 4008648:	1880020e 	bge	r3,r2,4008654 <___vfprintf_internal_r+0x8ec>
					ch -= 2; /* 'e' or 'E' */
 400864c:	a53fff84 	addi	r20,r20,-2
 4008650:	00000106 	br	4008658 <___vfprintf_internal_r+0x8f0>
				else
					ch = 'g';
 4008654:	050019c4 	movi	r20,103
			}
# ifdef _WANT_IO_C99_FORMATS
			else if (ch == 'F')
				ch = 'f';
# endif
			if (ch <= 'e') {	/* 'a', 'A', 'e', or 'E' fmt */
 4008658:	a0801988 	cmpgei	r2,r20,102
 400865c:	1000181e 	bne	r2,zero,40086c0 <___vfprintf_internal_r+0x958>
				--expt;
 4008660:	e0bfdf17 	ldw	r2,-132(fp)
 4008664:	10bfffc4 	addi	r2,r2,-1
 4008668:	e0bfdf15 	stw	r2,-132(fp)
				expsize = exponent (expstr, expt, ch);
 400866c:	e0ffdf17 	ldw	r3,-132(fp)
 4008670:	e0bfdd44 	addi	r2,fp,-139
 4008674:	a00d883a 	mov	r6,r20
 4008678:	180b883a 	mov	r5,r3
 400867c:	1009883a 	mov	r4,r2
 4008680:	400a0d00 	call	400a0d0 <exponent>
 4008684:	e0bff415 	stw	r2,-48(fp)
				size = expsize + ndig;
 4008688:	e0bfdc17 	ldw	r2,-144(fp)
 400868c:	e0fff417 	ldw	r3,-48(fp)
 4008690:	1885883a 	add	r2,r3,r2
 4008694:	e0bfed15 	stw	r2,-76(fp)
				if (ndig > 1 || flags & ALT)
 4008698:	e0bfdc17 	ldw	r2,-144(fp)
 400869c:	10800088 	cmpgei	r2,r2,2
 40086a0:	1000021e 	bne	r2,zero,40086ac <___vfprintf_internal_r+0x944>
 40086a4:	8880004c 	andi	r2,r17,1
 40086a8:	10003d26 	beq	r2,zero,40087a0 <___vfprintf_internal_r+0xa38>
					size += decp_len;
 40086ac:	e0ffed17 	ldw	r3,-76(fp)
 40086b0:	e0bfe717 	ldw	r2,-100(fp)
 40086b4:	1885883a 	add	r2,r3,r2
 40086b8:	e0bfed15 	stw	r2,-76(fp)
 40086bc:	00003806 	br	40087a0 <___vfprintf_internal_r+0xa38>
# ifdef _WANT_IO_C99_FORMATS
				flags &= ~GROUPING;
# endif
			} else {
				if (ch == 'f') {		/* f fmt */
 40086c0:	a0801998 	cmpnei	r2,r20,102
 40086c4:	10001b1e 	bne	r2,zero,4008734 <___vfprintf_internal_r+0x9cc>
					if (expt > 0) {
 40086c8:	e0bfdf17 	ldw	r2,-132(fp)
 40086cc:	00800d0e 	bge	zero,r2,4008704 <___vfprintf_internal_r+0x99c>
						size = expt;
 40086d0:	e0bfdf17 	ldw	r2,-132(fp)
 40086d4:	e0bfed15 	stw	r2,-76(fp)
						if (prec || flags & ALT)
 40086d8:	e0bff517 	ldw	r2,-44(fp)
 40086dc:	1000021e 	bne	r2,zero,40086e8 <___vfprintf_internal_r+0x980>
 40086e0:	8880004c 	andi	r2,r17,1
 40086e4:	10002c26 	beq	r2,zero,4008798 <___vfprintf_internal_r+0xa30>
							size += prec + decp_len;
 40086e8:	e0fff517 	ldw	r3,-44(fp)
 40086ec:	e0bfe717 	ldw	r2,-100(fp)
 40086f0:	1887883a 	add	r3,r3,r2
 40086f4:	e0bfed17 	ldw	r2,-76(fp)
 40086f8:	1885883a 	add	r2,r3,r2
 40086fc:	e0bfed15 	stw	r2,-76(fp)
 4008700:	00002506 	br	4008798 <___vfprintf_internal_r+0xa30>
					} else	/* "0.X" */
						size = (prec || flags & ALT)
							  ? prec + 1 + decp_len
							  : 1;
 4008704:	e0bff517 	ldw	r2,-44(fp)
 4008708:	1000021e 	bne	r2,zero,4008714 <___vfprintf_internal_r+0x9ac>
						size = (prec || flags & ALT)
 400870c:	8880004c 	andi	r2,r17,1
 4008710:	10000526 	beq	r2,zero,4008728 <___vfprintf_internal_r+0x9c0>
							  ? prec + 1 + decp_len
 4008714:	e0fff517 	ldw	r3,-44(fp)
 4008718:	e0bfe717 	ldw	r2,-100(fp)
 400871c:	1885883a 	add	r2,r3,r2
 4008720:	10800044 	addi	r2,r2,1
							  : 1;
 4008724:	00000106 	br	400872c <___vfprintf_internal_r+0x9c4>
 4008728:	00800044 	movi	r2,1
						size = (prec || flags & ALT)
 400872c:	e0bfed15 	stw	r2,-76(fp)
 4008730:	00001906 	br	4008798 <___vfprintf_internal_r+0xa30>
				} else if (expt >= ndig) { /* fixed g fmt */
 4008734:	e0ffdf17 	ldw	r3,-132(fp)
 4008738:	e0bfdc17 	ldw	r2,-144(fp)
 400873c:	18800916 	blt	r3,r2,4008764 <___vfprintf_internal_r+0x9fc>
					size = expt;
 4008740:	e0bfdf17 	ldw	r2,-132(fp)
 4008744:	e0bfed15 	stw	r2,-76(fp)
					if (flags & ALT)
 4008748:	8880004c 	andi	r2,r17,1
 400874c:	10001226 	beq	r2,zero,4008798 <___vfprintf_internal_r+0xa30>
						size += decp_len;
 4008750:	e0ffed17 	ldw	r3,-76(fp)
 4008754:	e0bfe717 	ldw	r2,-100(fp)
 4008758:	1885883a 	add	r2,r3,r2
 400875c:	e0bfed15 	stw	r2,-76(fp)
 4008760:	00000d06 	br	4008798 <___vfprintf_internal_r+0xa30>
				} else {
					size = ndig + decp_len;
 4008764:	e0bfdc17 	ldw	r2,-144(fp)
 4008768:	1007883a 	mov	r3,r2
 400876c:	e0bfe717 	ldw	r2,-100(fp)
 4008770:	1885883a 	add	r2,r3,r2
 4008774:	e0bfed15 	stw	r2,-76(fp)
					if (expt <= 0)
 4008778:	e0bfdf17 	ldw	r2,-132(fp)
 400877c:	00800616 	blt	zero,r2,4008798 <___vfprintf_internal_r+0xa30>
						size += 1 - expt;
 4008780:	e0bfdf17 	ldw	r2,-132(fp)
 4008784:	00c00044 	movi	r3,1
 4008788:	1885c83a 	sub	r2,r3,r2
 400878c:	e0ffed17 	ldw	r3,-76(fp)
 4008790:	1885883a 	add	r2,r3,r2
 4008794:	e0bfed15 	stw	r2,-76(fp)
							nrepeats++;
					}
					size += (nseps + nrepeats) * thsnd_len;
				} else
# endif
					lead = expt;
 4008798:	e0bfdf17 	ldw	r2,-132(fp)
 400879c:	e0bff315 	stw	r2,-52(fp)
			}

			if (softsign)
 40087a0:	e0bfe283 	ldbu	r2,-118(fp)
 40087a4:	10803fcc 	andi	r2,r2,255
 40087a8:	1080201c 	xori	r2,r2,128
 40087ac:	10bfe004 	addi	r2,r2,-128
 40087b0:	10018526 	beq	r2,zero,4008dc8 <___vfprintf_internal_r+0x1060>
				sign = '-';
 40087b4:	00800b44 	movi	r2,45
 40087b8:	e0bfe2c5 	stb	r2,-117(fp)
			break;
 40087bc:	00018206 	br	4008dc8 <___vfprintf_internal_r+0x1060>
			flags &= ~LONGINT;
			goto string;
#endif
		case 'n':
#ifndef _NO_LONGLONG
			if (flags & QUADINT)
 40087c0:	8880080c 	andi	r2,r17,32
 40087c4:	10000d26 	beq	r2,zero,40087fc <___vfprintf_internal_r+0xa94>
				*GET_ARG (N, ap, quad_ptr_t) = ret;
 40087c8:	e0bfba17 	ldw	r2,-280(fp)
 40087cc:	10c00104 	addi	r3,r2,4
 40087d0:	e0ffba15 	stw	r3,-280(fp)
 40087d4:	10800017 	ldw	r2,0(r2)
 40087d8:	e0fff717 	ldw	r3,-36(fp)
 40087dc:	e0ffb015 	stw	r3,-320(fp)
 40087e0:	1807d7fa 	srai	r3,r3,31
 40087e4:	e0ffb115 	stw	r3,-316(fp)
 40087e8:	e0ffb017 	ldw	r3,-320(fp)
 40087ec:	10c00015 	stw	r3,0(r2)
 40087f0:	e0ffb117 	ldw	r3,-316(fp)
 40087f4:	10c00115 	stw	r3,4(r2)
			else if (flags & CHARINT)
				*GET_ARG (N, ap, char_ptr_t) = ret;
#endif
			else
				*GET_ARG (N, ap, int_ptr_t) = ret;
			continue;	/* no output */
 40087f8:	00054106 	br	4009d00 <___vfprintf_internal_r+0x1f98>
			if (flags & LONGINT)
 40087fc:	8880040c 	andi	r2,r17,16
 4008800:	10000726 	beq	r2,zero,4008820 <___vfprintf_internal_r+0xab8>
				*GET_ARG (N, ap, long_ptr_t) = ret;
 4008804:	e0bfba17 	ldw	r2,-280(fp)
 4008808:	10c00104 	addi	r3,r2,4
 400880c:	e0ffba15 	stw	r3,-280(fp)
 4008810:	10800017 	ldw	r2,0(r2)
 4008814:	e0fff717 	ldw	r3,-36(fp)
 4008818:	10c00015 	stw	r3,0(r2)
			continue;	/* no output */
 400881c:	00053806 	br	4009d00 <___vfprintf_internal_r+0x1f98>
			else if (flags & SHORTINT)
 4008820:	8880100c 	andi	r2,r17,64
 4008824:	10000726 	beq	r2,zero,4008844 <___vfprintf_internal_r+0xadc>
				*GET_ARG (N, ap, short_ptr_t) = ret;
 4008828:	e0bfba17 	ldw	r2,-280(fp)
 400882c:	10c00104 	addi	r3,r2,4
 4008830:	e0ffba15 	stw	r3,-280(fp)
 4008834:	10800017 	ldw	r2,0(r2)
 4008838:	e0fff717 	ldw	r3,-36(fp)
 400883c:	10c0000d 	sth	r3,0(r2)
			continue;	/* no output */
 4008840:	00052f06 	br	4009d00 <___vfprintf_internal_r+0x1f98>
				*GET_ARG (N, ap, int_ptr_t) = ret;
 4008844:	e0bfba17 	ldw	r2,-280(fp)
 4008848:	10c00104 	addi	r3,r2,4
 400884c:	e0ffba15 	stw	r3,-280(fp)
 4008850:	10800017 	ldw	r2,0(r2)
 4008854:	e0fff717 	ldw	r3,-36(fp)
 4008858:	10c00015 	stw	r3,0(r2)
			continue;	/* no output */
 400885c:	00052806 	br	4009d00 <___vfprintf_internal_r+0x1f98>
		case 'O': /* extension */
			flags |= LONGINT;
 4008860:	8c400414 	ori	r17,r17,16
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
 4008864:	8880080c 	andi	r2,r17,32
 4008868:	10000626 	beq	r2,zero,4008884 <___vfprintf_internal_r+0xb1c>
 400886c:	e0bfba17 	ldw	r2,-280(fp)
 4008870:	10c00204 	addi	r3,r2,8
 4008874:	e0ffba15 	stw	r3,-280(fp)
 4008878:	15800017 	ldw	r22,0(r2)
 400887c:	15c00117 	ldw	r23,4(r2)
 4008880:	00001906 	br	40088e8 <___vfprintf_internal_r+0xb80>
 4008884:	8880040c 	andi	r2,r17,16
 4008888:	10000726 	beq	r2,zero,40088a8 <___vfprintf_internal_r+0xb40>
 400888c:	e0bfba17 	ldw	r2,-280(fp)
 4008890:	10c00104 	addi	r3,r2,4
 4008894:	e0ffba15 	stw	r3,-280(fp)
 4008898:	10800017 	ldw	r2,0(r2)
 400889c:	102d883a 	mov	r22,r2
 40088a0:	002f883a 	mov	r23,zero
 40088a4:	00001006 	br	40088e8 <___vfprintf_internal_r+0xb80>
 40088a8:	8880100c 	andi	r2,r17,64
 40088ac:	10000826 	beq	r2,zero,40088d0 <___vfprintf_internal_r+0xb68>
 40088b0:	e0bfba17 	ldw	r2,-280(fp)
 40088b4:	10c00104 	addi	r3,r2,4
 40088b8:	e0ffba15 	stw	r3,-280(fp)
 40088bc:	10800017 	ldw	r2,0(r2)
 40088c0:	10bfffcc 	andi	r2,r2,65535
 40088c4:	102d883a 	mov	r22,r2
 40088c8:	002f883a 	mov	r23,zero
 40088cc:	00000606 	br	40088e8 <___vfprintf_internal_r+0xb80>
 40088d0:	e0bfba17 	ldw	r2,-280(fp)
 40088d4:	10c00104 	addi	r3,r2,4
 40088d8:	e0ffba15 	stw	r3,-280(fp)
 40088dc:	10800017 	ldw	r2,0(r2)
 40088e0:	102d883a 	mov	r22,r2
 40088e4:	002f883a 	mov	r23,zero
 40088e8:	e5bff115 	stw	r22,-60(fp)
 40088ec:	e5fff215 	stw	r23,-56(fp)
			base = OCT;
 40088f0:	e03ff015 	stw	zero,-64(fp)
#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			goto nosign;
 40088f4:	00009d06 	br	4008b6c <___vfprintf_internal_r+0xe04>
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
 40088f8:	e0bfba17 	ldw	r2,-280(fp)
 40088fc:	10c00104 	addi	r3,r2,4
 4008900:	e0ffba15 	stw	r3,-280(fp)
 4008904:	10800017 	ldw	r2,0(r2)
 4008908:	e0bff115 	stw	r2,-60(fp)
 400890c:	e03ff215 	stw	zero,-56(fp)
			base = HEX;
 4008910:	00800084 	movi	r2,2
 4008914:	e0bff015 	stw	r2,-64(fp)
			xdigs = "0123456789abcdef";
 4008918:	008100b4 	movhi	r2,1026
 400891c:	10ab0804 	addi	r2,r2,-21472
 4008920:	e0bfec15 	stw	r2,-80(fp)
			flags |= HEXPREFIX;
 4008924:	8c400094 	ori	r17,r17,2
			ox[0] = '0';
 4008928:	00800c04 	movi	r2,48
 400892c:	e0bfbe85 	stb	r2,-262(fp)
			ox[1] = ch = 'x';
 4008930:	05001e04 	movi	r20,120
 4008934:	00801e04 	movi	r2,120
 4008938:	e0bfbec5 	stb	r2,-261(fp)
			goto nosign;
 400893c:	00008b06 	br	4008b6c <___vfprintf_internal_r+0xe04>
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
 4008940:	e0bfba17 	ldw	r2,-280(fp)
 4008944:	10c00104 	addi	r3,r2,4
 4008948:	e0ffba15 	stw	r3,-280(fp)
 400894c:	14800017 	ldw	r18,0(r2)
#ifdef _GLIBC_EXTENSION
string:
#endif
			sign = '\0';
 4008950:	e03fe2c5 	stb	zero,-117(fp)
#ifndef __OPTIMIZE_SIZE__
			/* Behavior is undefined if the user passed a
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
 4008954:	9000081e 	bne	r18,zero,4008978 <___vfprintf_internal_r+0xc10>
				cp = "(null)";
 4008958:	048100b4 	movhi	r18,1026
 400895c:	94ab0d04 	addi	r18,r18,-21452
				size = ((unsigned) prec > 6U) ? 6 : prec;
 4008960:	e0bff517 	ldw	r2,-44(fp)
 4008964:	10c001f0 	cmpltui	r3,r2,7
 4008968:	1800011e 	bne	r3,zero,4008970 <___vfprintf_internal_r+0xc08>
 400896c:	00800184 	movi	r2,6
 4008970:	e0bfed15 	stw	r2,-76(fp)
				else
					size = prec;
			} else
				size = strlen (cp);

			break;
 4008974:	00011506 	br	4008dcc <___vfprintf_internal_r+0x1064>
			if (prec >= 0) {
 4008978:	e0bff517 	ldw	r2,-44(fp)
 400897c:	10000f16 	blt	r2,zero,40089bc <___vfprintf_internal_r+0xc54>
				char *p = memchr (cp, 0, prec);
 4008980:	e0bff517 	ldw	r2,-44(fp)
 4008984:	100d883a 	mov	r6,r2
 4008988:	000b883a 	mov	r5,zero
 400898c:	9009883a 	mov	r4,r18
 4008990:	400f1f00 	call	400f1f0 <memchr>
 4008994:	e0bfe415 	stw	r2,-112(fp)
				if (p != NULL)
 4008998:	e0bfe417 	ldw	r2,-112(fp)
 400899c:	10000426 	beq	r2,zero,40089b0 <___vfprintf_internal_r+0xc48>
					size = p - cp;
 40089a0:	e0bfe417 	ldw	r2,-112(fp)
 40089a4:	1485c83a 	sub	r2,r2,r18
 40089a8:	e0bfed15 	stw	r2,-76(fp)
			break;
 40089ac:	00010706 	br	4008dcc <___vfprintf_internal_r+0x1064>
					size = prec;
 40089b0:	e0bff517 	ldw	r2,-44(fp)
 40089b4:	e0bfed15 	stw	r2,-76(fp)
			break;
 40089b8:	00010406 	br	4008dcc <___vfprintf_internal_r+0x1064>
				size = strlen (cp);
 40089bc:	9009883a 	mov	r4,r18
 40089c0:	4007b340 	call	4007b34 <strlen>
 40089c4:	e0bfed15 	stw	r2,-76(fp)
			break;
 40089c8:	00010006 	br	4008dcc <___vfprintf_internal_r+0x1064>
		case 'U': /* extension */
			flags |= LONGINT;
 40089cc:	8c400414 	ori	r17,r17,16
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
 40089d0:	8880080c 	andi	r2,r17,32
 40089d4:	10000826 	beq	r2,zero,40089f8 <___vfprintf_internal_r+0xc90>
 40089d8:	e0bfba17 	ldw	r2,-280(fp)
 40089dc:	10c00204 	addi	r3,r2,8
 40089e0:	e0ffba15 	stw	r3,-280(fp)
 40089e4:	10c00017 	ldw	r3,0(r2)
 40089e8:	e0ffb615 	stw	r3,-296(fp)
 40089ec:	10800117 	ldw	r2,4(r2)
 40089f0:	e0bfb715 	stw	r2,-292(fp)
 40089f4:	00001906 	br	4008a5c <___vfprintf_internal_r+0xcf4>
 40089f8:	8880040c 	andi	r2,r17,16
 40089fc:	10000726 	beq	r2,zero,4008a1c <___vfprintf_internal_r+0xcb4>
 4008a00:	e0bfba17 	ldw	r2,-280(fp)
 4008a04:	10c00104 	addi	r3,r2,4
 4008a08:	e0ffba15 	stw	r3,-280(fp)
 4008a0c:	10800017 	ldw	r2,0(r2)
 4008a10:	e0bfb615 	stw	r2,-296(fp)
 4008a14:	e03fb715 	stw	zero,-292(fp)
 4008a18:	00001006 	br	4008a5c <___vfprintf_internal_r+0xcf4>
 4008a1c:	8880100c 	andi	r2,r17,64
 4008a20:	10000826 	beq	r2,zero,4008a44 <___vfprintf_internal_r+0xcdc>
 4008a24:	e0bfba17 	ldw	r2,-280(fp)
 4008a28:	10c00104 	addi	r3,r2,4
 4008a2c:	e0ffba15 	stw	r3,-280(fp)
 4008a30:	10800017 	ldw	r2,0(r2)
 4008a34:	10bfffcc 	andi	r2,r2,65535
 4008a38:	e0bfb615 	stw	r2,-296(fp)
 4008a3c:	e03fb715 	stw	zero,-292(fp)
 4008a40:	00000606 	br	4008a5c <___vfprintf_internal_r+0xcf4>
 4008a44:	e0bfba17 	ldw	r2,-280(fp)
 4008a48:	10c00104 	addi	r3,r2,4
 4008a4c:	e0ffba15 	stw	r3,-280(fp)
 4008a50:	10800017 	ldw	r2,0(r2)
 4008a54:	e0bfb615 	stw	r2,-296(fp)
 4008a58:	e03fb715 	stw	zero,-292(fp)
 4008a5c:	e0bfb617 	ldw	r2,-296(fp)
 4008a60:	e0bff115 	stw	r2,-60(fp)
 4008a64:	e0bfb717 	ldw	r2,-292(fp)
 4008a68:	e0bff215 	stw	r2,-56(fp)
			base = DEC;
 4008a6c:	00800044 	movi	r2,1
 4008a70:	e0bff015 	stw	r2,-64(fp)
			goto nosign;
 4008a74:	00003d06 	br	4008b6c <___vfprintf_internal_r+0xe04>
		case 'X':
			xdigs = "0123456789ABCDEF";
 4008a78:	008100b4 	movhi	r2,1026
 4008a7c:	10ab0f04 	addi	r2,r2,-21444
 4008a80:	e0bfec15 	stw	r2,-80(fp)
			goto hex;
 4008a84:	00000306 	br	4008a94 <___vfprintf_internal_r+0xd2c>
		case 'x':
			xdigs = "0123456789abcdef";
 4008a88:	008100b4 	movhi	r2,1026
 4008a8c:	10ab0804 	addi	r2,r2,-21472
 4008a90:	e0bfec15 	stw	r2,-80(fp)
hex:			_uquad = UARG ();
 4008a94:	8880080c 	andi	r2,r17,32
 4008a98:	10000826 	beq	r2,zero,4008abc <___vfprintf_internal_r+0xd54>
 4008a9c:	e0bfba17 	ldw	r2,-280(fp)
 4008aa0:	10c00204 	addi	r3,r2,8
 4008aa4:	e0ffba15 	stw	r3,-280(fp)
 4008aa8:	10c00017 	ldw	r3,0(r2)
 4008aac:	e0ffb415 	stw	r3,-304(fp)
 4008ab0:	10800117 	ldw	r2,4(r2)
 4008ab4:	e0bfb515 	stw	r2,-300(fp)
 4008ab8:	00001906 	br	4008b20 <___vfprintf_internal_r+0xdb8>
 4008abc:	8880040c 	andi	r2,r17,16
 4008ac0:	10000726 	beq	r2,zero,4008ae0 <___vfprintf_internal_r+0xd78>
 4008ac4:	e0bfba17 	ldw	r2,-280(fp)
 4008ac8:	10c00104 	addi	r3,r2,4
 4008acc:	e0ffba15 	stw	r3,-280(fp)
 4008ad0:	10800017 	ldw	r2,0(r2)
 4008ad4:	e0bfb415 	stw	r2,-304(fp)
 4008ad8:	e03fb515 	stw	zero,-300(fp)
 4008adc:	00001006 	br	4008b20 <___vfprintf_internal_r+0xdb8>
 4008ae0:	8880100c 	andi	r2,r17,64
 4008ae4:	10000826 	beq	r2,zero,4008b08 <___vfprintf_internal_r+0xda0>
 4008ae8:	e0bfba17 	ldw	r2,-280(fp)
 4008aec:	10c00104 	addi	r3,r2,4
 4008af0:	e0ffba15 	stw	r3,-280(fp)
 4008af4:	10800017 	ldw	r2,0(r2)
 4008af8:	10bfffcc 	andi	r2,r2,65535
 4008afc:	e0bfb415 	stw	r2,-304(fp)
 4008b00:	e03fb515 	stw	zero,-300(fp)
 4008b04:	00000606 	br	4008b20 <___vfprintf_internal_r+0xdb8>
 4008b08:	e0bfba17 	ldw	r2,-280(fp)
 4008b0c:	10c00104 	addi	r3,r2,4
 4008b10:	e0ffba15 	stw	r3,-280(fp)
 4008b14:	10800017 	ldw	r2,0(r2)
 4008b18:	e0bfb415 	stw	r2,-304(fp)
 4008b1c:	e03fb515 	stw	zero,-300(fp)
 4008b20:	e0bfb417 	ldw	r2,-304(fp)
 4008b24:	e0bff115 	stw	r2,-60(fp)
 4008b28:	e0bfb517 	ldw	r2,-300(fp)
 4008b2c:	e0bff215 	stw	r2,-56(fp)
			base = HEX;
 4008b30:	00800084 	movi	r2,2
 4008b34:	e0bff015 	stw	r2,-64(fp)
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _uquad != 0) {
 4008b38:	8880004c 	andi	r2,r17,1
 4008b3c:	10000a26 	beq	r2,zero,4008b68 <___vfprintf_internal_r+0xe00>
 4008b40:	e0bff117 	ldw	r2,-60(fp)
 4008b44:	e0fff217 	ldw	r3,-56(fp)
 4008b48:	10c4b03a 	or	r2,r2,r3
 4008b4c:	10000726 	beq	r2,zero,4008b6c <___vfprintf_internal_r+0xe04>
				ox[0] = '0';
 4008b50:	00800c04 	movi	r2,48
 4008b54:	e0bfbe85 	stb	r2,-262(fp)
				ox[1] = ch;
 4008b58:	a005883a 	mov	r2,r20
 4008b5c:	e0bfbec5 	stb	r2,-261(fp)
				flags |= HEXPREFIX;
 4008b60:	8c400094 	ori	r17,r17,2
 4008b64:	00000106 	br	4008b6c <___vfprintf_internal_r+0xe04>

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
 4008b68:	0001883a 	nop
 4008b6c:	e03fe2c5 	stb	zero,-117(fp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
 4008b70:	e0bff517 	ldw	r2,-44(fp)
 4008b74:	e0bfef15 	stw	r2,-68(fp)
 4008b78:	e0bfef17 	ldw	r2,-68(fp)
 4008b7c:	10000216 	blt	r2,zero,4008b88 <___vfprintf_internal_r+0xe20>
				flags &= ~ZEROPAD;
 4008b80:	00bfdfc4 	movi	r2,-129
 4008b84:	88a2703a 	and	r17,r17,r2
			/*
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
 4008b88:	e4bfbf04 	addi	r18,fp,-260
 4008b8c:	94800a04 	addi	r18,r18,40
			if (_uquad != 0 || prec != 0) {
 4008b90:	e0bff117 	ldw	r2,-60(fp)
 4008b94:	e0fff217 	ldw	r3,-56(fp)
 4008b98:	10c4b03a 	or	r2,r2,r3
 4008b9c:	1000021e 	bne	r2,zero,4008ba8 <___vfprintf_internal_r+0xe40>
 4008ba0:	e0bff517 	ldw	r2,-44(fp)
 4008ba4:	10007426 	beq	r2,zero,4008d78 <___vfprintf_internal_r+0x1010>
 4008ba8:	e0bff017 	ldw	r2,-64(fp)
 4008bac:	108000a0 	cmpeqi	r2,r2,2
 4008bb0:	1000531e 	bne	r2,zero,4008d00 <___vfprintf_internal_r+0xf98>
 4008bb4:	e0bff017 	ldw	r2,-64(fp)
 4008bb8:	108000e8 	cmpgeui	r2,r2,3
 4008bbc:	1000651e 	bne	r2,zero,4008d54 <___vfprintf_internal_r+0xfec>
 4008bc0:	e0bff017 	ldw	r2,-64(fp)
 4008bc4:	10000526 	beq	r2,zero,4008bdc <___vfprintf_internal_r+0xe74>
 4008bc8:	e0bff017 	ldw	r2,-64(fp)
 4008bcc:	10800060 	cmpeqi	r2,r2,1
 4008bd0:	1000201e 	bne	r2,zero,4008c54 <___vfprintf_internal_r+0xeec>
 4008bd4:	00005f06 	br	4008d54 <___vfprintf_internal_r+0xfec>
				 * Unsigned mod is hard, and unsigned mod
				 * by a constant is easier than that by
				 * a variable; hence this switch.
				 */
				switch (base) {
				case OCT:
 4008bd8:	0001883a 	nop
					do {
						*--cp = to_char (_uquad & 7);
 4008bdc:	e0bff117 	ldw	r2,-60(fp)
 4008be0:	108001cc 	andi	r2,r2,7
 4008be4:	10800c04 	addi	r2,r2,48
 4008be8:	94bfffc4 	addi	r18,r18,-1
 4008bec:	90800005 	stb	r2,0(r18)
						_uquad >>= 3;
 4008bf0:	e0bff217 	ldw	r2,-56(fp)
 4008bf4:	1004977a 	slli	r2,r2,29
 4008bf8:	e0fff117 	ldw	r3,-60(fp)
 4008bfc:	1806d0fa 	srli	r3,r3,3
 4008c00:	1884b03a 	or	r2,r3,r2
 4008c04:	e0bff115 	stw	r2,-60(fp)
 4008c08:	e0bff217 	ldw	r2,-56(fp)
 4008c0c:	1004d0fa 	srli	r2,r2,3
 4008c10:	e0bff215 	stw	r2,-56(fp)
					} while (_uquad);
 4008c14:	e0bff117 	ldw	r2,-60(fp)
 4008c18:	e0fff217 	ldw	r3,-56(fp)
 4008c1c:	10c4b03a 	or	r2,r2,r3
 4008c20:	103fed1e 	bne	r2,zero,4008bd8 <___vfprintf_internal_r+0xe70>
					/* handle octal leading 0 */
					if (flags & ALT && *cp != '0')
 4008c24:	8880004c 	andi	r2,r17,1
 4008c28:	10005126 	beq	r2,zero,4008d70 <___vfprintf_internal_r+0x1008>
 4008c2c:	90800003 	ldbu	r2,0(r18)
 4008c30:	10803fcc 	andi	r2,r2,255
 4008c34:	1080201c 	xori	r2,r2,128
 4008c38:	10bfe004 	addi	r2,r2,-128
 4008c3c:	10800c20 	cmpeqi	r2,r2,48
 4008c40:	10004b1e 	bne	r2,zero,4008d70 <___vfprintf_internal_r+0x1008>
						*--cp = '0';
 4008c44:	94bfffc4 	addi	r18,r18,-1
 4008c48:	00800c04 	movi	r2,48
 4008c4c:	90800005 	stb	r2,0(r18)
					break;
 4008c50:	00004706 	br	4008d70 <___vfprintf_internal_r+0x1008>

				case DEC:
					/* many numbers are 1 digit */
					if (_uquad < 10) {
 4008c54:	e0bff217 	ldw	r2,-56(fp)
 4008c58:	10000a1e 	bne	r2,zero,4008c84 <___vfprintf_internal_r+0xf1c>
 4008c5c:	e0bff217 	ldw	r2,-56(fp)
 4008c60:	1000031e 	bne	r2,zero,4008c70 <___vfprintf_internal_r+0xf08>
 4008c64:	e0bff117 	ldw	r2,-60(fp)
 4008c68:	108002a8 	cmpgeui	r2,r2,10
 4008c6c:	1000051e 	bne	r2,zero,4008c84 <___vfprintf_internal_r+0xf1c>
						*--cp = to_char(_uquad);
 4008c70:	e0bff117 	ldw	r2,-60(fp)
 4008c74:	10800c04 	addi	r2,r2,48
 4008c78:	94bfffc4 	addi	r18,r18,-1
 4008c7c:	90800005 	stb	r2,0(r18)
						break;
 4008c80:	00003c06 	br	4008d74 <___vfprintf_internal_r+0x100c>
					}
#ifdef _WANT_IO_C99_FORMATS
					ndig = 0;
#endif
					do {
					  *--cp = to_char (_uquad % 10);
 4008c84:	e0bff117 	ldw	r2,-60(fp)
 4008c88:	e0fff217 	ldw	r3,-56(fp)
 4008c8c:	01800284 	movi	r6,10
 4008c90:	000f883a 	mov	r7,zero
 4008c94:	1009883a 	mov	r4,r2
 4008c98:	180b883a 	mov	r5,r3
 4008c9c:	4014f940 	call	4014f94 <__umoddi3>
 4008ca0:	1009883a 	mov	r4,r2
 4008ca4:	180b883a 	mov	r5,r3
 4008ca8:	2005883a 	mov	r2,r4
 4008cac:	2807883a 	mov	r3,r5
 4008cb0:	10800c04 	addi	r2,r2,48
 4008cb4:	94bfffc4 	addi	r18,r18,-1
 4008cb8:	90800005 	stb	r2,0(r18)
					       next cases. */
					    if (grouping[1] != '\0')
					      grouping++;
					  }
#endif
					  _uquad /= 10;
 4008cbc:	e0bff117 	ldw	r2,-60(fp)
 4008cc0:	e0fff217 	ldw	r3,-56(fp)
 4008cc4:	01800284 	movi	r6,10
 4008cc8:	000f883a 	mov	r7,zero
 4008ccc:	1009883a 	mov	r4,r2
 4008cd0:	180b883a 	mov	r5,r3
 4008cd4:	40149780 	call	4014978 <__udivdi3>
 4008cd8:	1009883a 	mov	r4,r2
 4008cdc:	180b883a 	mov	r5,r3
 4008ce0:	e13ff115 	stw	r4,-60(fp)
 4008ce4:	e17ff215 	stw	r5,-56(fp)
					} while (_uquad != 0);
 4008ce8:	e0bff117 	ldw	r2,-60(fp)
 4008cec:	e0fff217 	ldw	r3,-56(fp)
 4008cf0:	10c4b03a 	or	r2,r2,r3
 4008cf4:	103fe31e 	bne	r2,zero,4008c84 <___vfprintf_internal_r+0xf1c>
					break;
 4008cf8:	00001e06 	br	4008d74 <___vfprintf_internal_r+0x100c>

				case HEX:
 4008cfc:	0001883a 	nop
					do {
						*--cp = xdigs[_uquad & 15];
 4008d00:	e0bff117 	ldw	r2,-60(fp)
 4008d04:	108003cc 	andi	r2,r2,15
 4008d08:	e0ffec17 	ldw	r3,-80(fp)
 4008d0c:	1885883a 	add	r2,r3,r2
 4008d10:	94bfffc4 	addi	r18,r18,-1
 4008d14:	10800003 	ldbu	r2,0(r2)
 4008d18:	90800005 	stb	r2,0(r18)
						_uquad >>= 4;
 4008d1c:	e0bff217 	ldw	r2,-56(fp)
 4008d20:	1004973a 	slli	r2,r2,28
 4008d24:	e0fff117 	ldw	r3,-60(fp)
 4008d28:	1806d13a 	srli	r3,r3,4
 4008d2c:	1884b03a 	or	r2,r3,r2
 4008d30:	e0bff115 	stw	r2,-60(fp)
 4008d34:	e0bff217 	ldw	r2,-56(fp)
 4008d38:	1004d13a 	srli	r2,r2,4
 4008d3c:	e0bff215 	stw	r2,-56(fp)
					} while (_uquad);
 4008d40:	e0bff117 	ldw	r2,-60(fp)
 4008d44:	e0fff217 	ldw	r3,-56(fp)
 4008d48:	10c4b03a 	or	r2,r2,r3
 4008d4c:	103feb1e 	bne	r2,zero,4008cfc <___vfprintf_internal_r+0xf94>
					break;
 4008d50:	00000806 	br	4008d74 <___vfprintf_internal_r+0x100c>

				default:
					cp = "bug in vfprintf: bad base";
 4008d54:	048100b4 	movhi	r18,1026
 4008d58:	94ab1404 	addi	r18,r18,-21424
					size = strlen (cp);
 4008d5c:	9009883a 	mov	r4,r18
 4008d60:	4007b340 	call	4007b34 <strlen>
 4008d64:	e0bfed15 	stw	r2,-76(fp)
					goto skipsize;
 4008d68:	0001883a 	nop
                       else if (base == OCT && (flags & ALT))
                         *--cp = '0';

			size = buf + BUF - cp;
		skipsize:
			break;
 4008d6c:	00001706 	br	4008dcc <___vfprintf_internal_r+0x1064>
					break;
 4008d70:	0001883a 	nop
				switch (base) {
 4008d74:	00000706 	br	4008d94 <___vfprintf_internal_r+0x102c>
                       else if (base == OCT && (flags & ALT))
 4008d78:	e0bff017 	ldw	r2,-64(fp)
 4008d7c:	1000051e 	bne	r2,zero,4008d94 <___vfprintf_internal_r+0x102c>
 4008d80:	8880004c 	andi	r2,r17,1
 4008d84:	10000326 	beq	r2,zero,4008d94 <___vfprintf_internal_r+0x102c>
                         *--cp = '0';
 4008d88:	94bfffc4 	addi	r18,r18,-1
 4008d8c:	00800c04 	movi	r2,48
 4008d90:	90800005 	stb	r2,0(r18)
			size = buf + BUF - cp;
 4008d94:	e0bfbf04 	addi	r2,fp,-260
 4008d98:	10800a04 	addi	r2,r2,40
 4008d9c:	1485c83a 	sub	r2,r2,r18
 4008da0:	e0bfed15 	stw	r2,-76(fp)
			break;
 4008da4:	00000906 	br	4008dcc <___vfprintf_internal_r+0x1064>
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
 4008da8:	a003d826 	beq	r20,zero,4009d0c <___vfprintf_internal_r+0x1fa4>
				goto done;
			/* pretend it was %c with argument ch */
			cp = buf;
 4008dac:	e4bfbf04 	addi	r18,fp,-260
			*cp = ch;
 4008db0:	a005883a 	mov	r2,r20
 4008db4:	90800005 	stb	r2,0(r18)
			size = 1;
 4008db8:	00800044 	movi	r2,1
 4008dbc:	e0bfed15 	stw	r2,-76(fp)
			sign = '\0';
 4008dc0:	e03fe2c5 	stb	zero,-117(fp)
			break;
 4008dc4:	00000106 	br	4008dcc <___vfprintf_internal_r+0x1064>
			break;
 4008dc8:	0001883a 	nop
		 * If flags&FPT, ch must be in [aAeEfg].
		 *
		 * Compute actual size, so we know how much to pad.
		 * size excludes decimal prec; realsz includes it.
		 */
		realsz = dprec > size ? dprec : size;
 4008dcc:	e0ffef17 	ldw	r3,-68(fp)
 4008dd0:	e0bfed17 	ldw	r2,-76(fp)
 4008dd4:	10c0010e 	bge	r2,r3,4008ddc <___vfprintf_internal_r+0x1074>
 4008dd8:	1805883a 	mov	r2,r3
 4008ddc:	e0bfee15 	stw	r2,-72(fp)
		if (sign)
 4008de0:	e0bfe2c3 	ldbu	r2,-117(fp)
 4008de4:	10803fcc 	andi	r2,r2,255
 4008de8:	1080201c 	xori	r2,r2,128
 4008dec:	10bfe004 	addi	r2,r2,-128
 4008df0:	10000326 	beq	r2,zero,4008e00 <___vfprintf_internal_r+0x1098>
			realsz++;
 4008df4:	e0bfee17 	ldw	r2,-72(fp)
 4008df8:	10800044 	addi	r2,r2,1
 4008dfc:	e0bfee15 	stw	r2,-72(fp)
		if (flags & HEXPREFIX)
 4008e00:	8880008c 	andi	r2,r17,2
 4008e04:	10000326 	beq	r2,zero,4008e14 <___vfprintf_internal_r+0x10ac>
			realsz+= 2;
 4008e08:	e0bfee17 	ldw	r2,-72(fp)
 4008e0c:	10800084 	addi	r2,r2,2
 4008e10:	e0bfee15 	stw	r2,-72(fp)

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
 4008e14:	8880210c 	andi	r2,r17,132
 4008e18:	1000351e 	bne	r2,zero,4008ef0 <___vfprintf_internal_r+0x1188>
			PAD (width - realsz, blanks);
 4008e1c:	e0fff617 	ldw	r3,-40(fp)
 4008e20:	e0bfee17 	ldw	r2,-72(fp)
 4008e24:	18a7c83a 	sub	r19,r3,r2
 4008e28:	04c0310e 	bge	zero,r19,4008ef0 <___vfprintf_internal_r+0x1188>
 4008e2c:	00001706 	br	4008e8c <___vfprintf_internal_r+0x1124>
 4008e30:	008100b4 	movhi	r2,1026
 4008e34:	10ab1c04 	addi	r2,r2,-21392
 4008e38:	80800015 	stw	r2,0(r16)
 4008e3c:	00800404 	movi	r2,16
 4008e40:	80800115 	stw	r2,4(r16)
 4008e44:	e0bfdb17 	ldw	r2,-148(fp)
 4008e48:	10800404 	addi	r2,r2,16
 4008e4c:	e0bfdb15 	stw	r2,-148(fp)
 4008e50:	84000204 	addi	r16,r16,8
 4008e54:	e0bfda17 	ldw	r2,-152(fp)
 4008e58:	10800044 	addi	r2,r2,1
 4008e5c:	e0bfda15 	stw	r2,-152(fp)
 4008e60:	e0bfda17 	ldw	r2,-152(fp)
 4008e64:	10800210 	cmplti	r2,r2,8
 4008e68:	1000071e 	bne	r2,zero,4008e88 <___vfprintf_internal_r+0x1120>
 4008e6c:	e0bfd904 	addi	r2,fp,-156
 4008e70:	100d883a 	mov	r6,r2
 4008e74:	e17fbc17 	ldw	r5,-272(fp)
 4008e78:	e13fbd17 	ldw	r4,-268(fp)
 4008e7c:	40121340 	call	4012134 <__sprint_r>
 4008e80:	1003b01e 	bne	r2,zero,4009d44 <___vfprintf_internal_r+0x1fdc>
 4008e84:	e43fc904 	addi	r16,fp,-220
 4008e88:	9cfffc04 	addi	r19,r19,-16
 4008e8c:	98800448 	cmpgei	r2,r19,17
 4008e90:	103fe71e 	bne	r2,zero,4008e30 <___vfprintf_internal_r+0x10c8>
 4008e94:	008100b4 	movhi	r2,1026
 4008e98:	10ab1c04 	addi	r2,r2,-21392
 4008e9c:	80800015 	stw	r2,0(r16)
 4008ea0:	9805883a 	mov	r2,r19
 4008ea4:	80800115 	stw	r2,4(r16)
 4008ea8:	e0bfdb17 	ldw	r2,-148(fp)
 4008eac:	9807883a 	mov	r3,r19
 4008eb0:	10c5883a 	add	r2,r2,r3
 4008eb4:	e0bfdb15 	stw	r2,-148(fp)
 4008eb8:	84000204 	addi	r16,r16,8
 4008ebc:	e0bfda17 	ldw	r2,-152(fp)
 4008ec0:	10800044 	addi	r2,r2,1
 4008ec4:	e0bfda15 	stw	r2,-152(fp)
 4008ec8:	e0bfda17 	ldw	r2,-152(fp)
 4008ecc:	10800210 	cmplti	r2,r2,8
 4008ed0:	1000071e 	bne	r2,zero,4008ef0 <___vfprintf_internal_r+0x1188>
 4008ed4:	e0bfd904 	addi	r2,fp,-156
 4008ed8:	100d883a 	mov	r6,r2
 4008edc:	e17fbc17 	ldw	r5,-272(fp)
 4008ee0:	e13fbd17 	ldw	r4,-268(fp)
 4008ee4:	40121340 	call	4012134 <__sprint_r>
 4008ee8:	1003981e 	bne	r2,zero,4009d4c <___vfprintf_internal_r+0x1fe4>
 4008eec:	e43fc904 	addi	r16,fp,-220

		/* prefix */
		if (sign)
 4008ef0:	e0bfe2c3 	ldbu	r2,-117(fp)
 4008ef4:	10803fcc 	andi	r2,r2,255
 4008ef8:	1080201c 	xori	r2,r2,128
 4008efc:	10bfe004 	addi	r2,r2,-128
 4008f00:	10001526 	beq	r2,zero,4008f58 <___vfprintf_internal_r+0x11f0>
			PRINT (&sign, 1);
 4008f04:	e0bfe2c4 	addi	r2,fp,-117
 4008f08:	80800015 	stw	r2,0(r16)
 4008f0c:	00800044 	movi	r2,1
 4008f10:	80800115 	stw	r2,4(r16)
 4008f14:	e0bfdb17 	ldw	r2,-148(fp)
 4008f18:	10800044 	addi	r2,r2,1
 4008f1c:	e0bfdb15 	stw	r2,-148(fp)
 4008f20:	84000204 	addi	r16,r16,8
 4008f24:	e0bfda17 	ldw	r2,-152(fp)
 4008f28:	10800044 	addi	r2,r2,1
 4008f2c:	e0bfda15 	stw	r2,-152(fp)
 4008f30:	e0bfda17 	ldw	r2,-152(fp)
 4008f34:	10800210 	cmplti	r2,r2,8
 4008f38:	1000071e 	bne	r2,zero,4008f58 <___vfprintf_internal_r+0x11f0>
 4008f3c:	e0bfd904 	addi	r2,fp,-156
 4008f40:	100d883a 	mov	r6,r2
 4008f44:	e17fbc17 	ldw	r5,-272(fp)
 4008f48:	e13fbd17 	ldw	r4,-268(fp)
 4008f4c:	40121340 	call	4012134 <__sprint_r>
 4008f50:	1003801e 	bne	r2,zero,4009d54 <___vfprintf_internal_r+0x1fec>
 4008f54:	e43fc904 	addi	r16,fp,-220
		if (flags & HEXPREFIX)
 4008f58:	8880008c 	andi	r2,r17,2
 4008f5c:	10001526 	beq	r2,zero,4008fb4 <___vfprintf_internal_r+0x124c>
			PRINT (ox, 2);
 4008f60:	e0bfbe84 	addi	r2,fp,-262
 4008f64:	80800015 	stw	r2,0(r16)
 4008f68:	00800084 	movi	r2,2
 4008f6c:	80800115 	stw	r2,4(r16)
 4008f70:	e0bfdb17 	ldw	r2,-148(fp)
 4008f74:	10800084 	addi	r2,r2,2
 4008f78:	e0bfdb15 	stw	r2,-148(fp)
 4008f7c:	84000204 	addi	r16,r16,8
 4008f80:	e0bfda17 	ldw	r2,-152(fp)
 4008f84:	10800044 	addi	r2,r2,1
 4008f88:	e0bfda15 	stw	r2,-152(fp)
 4008f8c:	e0bfda17 	ldw	r2,-152(fp)
 4008f90:	10800210 	cmplti	r2,r2,8
 4008f94:	1000071e 	bne	r2,zero,4008fb4 <___vfprintf_internal_r+0x124c>
 4008f98:	e0bfd904 	addi	r2,fp,-156
 4008f9c:	100d883a 	mov	r6,r2
 4008fa0:	e17fbc17 	ldw	r5,-272(fp)
 4008fa4:	e13fbd17 	ldw	r4,-268(fp)
 4008fa8:	40121340 	call	4012134 <__sprint_r>
 4008fac:	10036b1e 	bne	r2,zero,4009d5c <___vfprintf_internal_r+0x1ff4>
 4008fb0:	e43fc904 	addi	r16,fp,-220

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
 4008fb4:	8880210c 	andi	r2,r17,132
 4008fb8:	10802018 	cmpnei	r2,r2,128
 4008fbc:	1000351e 	bne	r2,zero,4009094 <___vfprintf_internal_r+0x132c>
			PAD (width - realsz, zeroes);
 4008fc0:	e0fff617 	ldw	r3,-40(fp)
 4008fc4:	e0bfee17 	ldw	r2,-72(fp)
 4008fc8:	18a7c83a 	sub	r19,r3,r2
 4008fcc:	04c0310e 	bge	zero,r19,4009094 <___vfprintf_internal_r+0x132c>
 4008fd0:	00001706 	br	4009030 <___vfprintf_internal_r+0x12c8>
 4008fd4:	008100b4 	movhi	r2,1026
 4008fd8:	10ab2004 	addi	r2,r2,-21376
 4008fdc:	80800015 	stw	r2,0(r16)
 4008fe0:	00800404 	movi	r2,16
 4008fe4:	80800115 	stw	r2,4(r16)
 4008fe8:	e0bfdb17 	ldw	r2,-148(fp)
 4008fec:	10800404 	addi	r2,r2,16
 4008ff0:	e0bfdb15 	stw	r2,-148(fp)
 4008ff4:	84000204 	addi	r16,r16,8
 4008ff8:	e0bfda17 	ldw	r2,-152(fp)
 4008ffc:	10800044 	addi	r2,r2,1
 4009000:	e0bfda15 	stw	r2,-152(fp)
 4009004:	e0bfda17 	ldw	r2,-152(fp)
 4009008:	10800210 	cmplti	r2,r2,8
 400900c:	1000071e 	bne	r2,zero,400902c <___vfprintf_internal_r+0x12c4>
 4009010:	e0bfd904 	addi	r2,fp,-156
 4009014:	100d883a 	mov	r6,r2
 4009018:	e17fbc17 	ldw	r5,-272(fp)
 400901c:	e13fbd17 	ldw	r4,-268(fp)
 4009020:	40121340 	call	4012134 <__sprint_r>
 4009024:	10034f1e 	bne	r2,zero,4009d64 <___vfprintf_internal_r+0x1ffc>
 4009028:	e43fc904 	addi	r16,fp,-220
 400902c:	9cfffc04 	addi	r19,r19,-16
 4009030:	98800448 	cmpgei	r2,r19,17
 4009034:	103fe71e 	bne	r2,zero,4008fd4 <___vfprintf_internal_r+0x126c>
 4009038:	008100b4 	movhi	r2,1026
 400903c:	10ab2004 	addi	r2,r2,-21376
 4009040:	80800015 	stw	r2,0(r16)
 4009044:	9805883a 	mov	r2,r19
 4009048:	80800115 	stw	r2,4(r16)
 400904c:	e0bfdb17 	ldw	r2,-148(fp)
 4009050:	9807883a 	mov	r3,r19
 4009054:	10c5883a 	add	r2,r2,r3
 4009058:	e0bfdb15 	stw	r2,-148(fp)
 400905c:	84000204 	addi	r16,r16,8
 4009060:	e0bfda17 	ldw	r2,-152(fp)
 4009064:	10800044 	addi	r2,r2,1
 4009068:	e0bfda15 	stw	r2,-152(fp)
 400906c:	e0bfda17 	ldw	r2,-152(fp)
 4009070:	10800210 	cmplti	r2,r2,8
 4009074:	1000071e 	bne	r2,zero,4009094 <___vfprintf_internal_r+0x132c>
 4009078:	e0bfd904 	addi	r2,fp,-156
 400907c:	100d883a 	mov	r6,r2
 4009080:	e17fbc17 	ldw	r5,-272(fp)
 4009084:	e13fbd17 	ldw	r4,-268(fp)
 4009088:	40121340 	call	4012134 <__sprint_r>
 400908c:	1003371e 	bne	r2,zero,4009d6c <___vfprintf_internal_r+0x2004>
 4009090:	e43fc904 	addi	r16,fp,-220

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
 4009094:	e0ffef17 	ldw	r3,-68(fp)
 4009098:	e0bfed17 	ldw	r2,-76(fp)
 400909c:	18a7c83a 	sub	r19,r3,r2
 40090a0:	04c0310e 	bge	zero,r19,4009168 <___vfprintf_internal_r+0x1400>
 40090a4:	00001706 	br	4009104 <___vfprintf_internal_r+0x139c>
 40090a8:	008100b4 	movhi	r2,1026
 40090ac:	10ab2004 	addi	r2,r2,-21376
 40090b0:	80800015 	stw	r2,0(r16)
 40090b4:	00800404 	movi	r2,16
 40090b8:	80800115 	stw	r2,4(r16)
 40090bc:	e0bfdb17 	ldw	r2,-148(fp)
 40090c0:	10800404 	addi	r2,r2,16
 40090c4:	e0bfdb15 	stw	r2,-148(fp)
 40090c8:	84000204 	addi	r16,r16,8
 40090cc:	e0bfda17 	ldw	r2,-152(fp)
 40090d0:	10800044 	addi	r2,r2,1
 40090d4:	e0bfda15 	stw	r2,-152(fp)
 40090d8:	e0bfda17 	ldw	r2,-152(fp)
 40090dc:	10800210 	cmplti	r2,r2,8
 40090e0:	1000071e 	bne	r2,zero,4009100 <___vfprintf_internal_r+0x1398>
 40090e4:	e0bfd904 	addi	r2,fp,-156
 40090e8:	100d883a 	mov	r6,r2
 40090ec:	e17fbc17 	ldw	r5,-272(fp)
 40090f0:	e13fbd17 	ldw	r4,-268(fp)
 40090f4:	40121340 	call	4012134 <__sprint_r>
 40090f8:	10031e1e 	bne	r2,zero,4009d74 <___vfprintf_internal_r+0x200c>
 40090fc:	e43fc904 	addi	r16,fp,-220
 4009100:	9cfffc04 	addi	r19,r19,-16
 4009104:	98800448 	cmpgei	r2,r19,17
 4009108:	103fe71e 	bne	r2,zero,40090a8 <___vfprintf_internal_r+0x1340>
 400910c:	008100b4 	movhi	r2,1026
 4009110:	10ab2004 	addi	r2,r2,-21376
 4009114:	80800015 	stw	r2,0(r16)
 4009118:	9805883a 	mov	r2,r19
 400911c:	80800115 	stw	r2,4(r16)
 4009120:	e0bfdb17 	ldw	r2,-148(fp)
 4009124:	9807883a 	mov	r3,r19
 4009128:	10c5883a 	add	r2,r2,r3
 400912c:	e0bfdb15 	stw	r2,-148(fp)
 4009130:	84000204 	addi	r16,r16,8
 4009134:	e0bfda17 	ldw	r2,-152(fp)
 4009138:	10800044 	addi	r2,r2,1
 400913c:	e0bfda15 	stw	r2,-152(fp)
 4009140:	e0bfda17 	ldw	r2,-152(fp)
 4009144:	10800210 	cmplti	r2,r2,8
 4009148:	1000071e 	bne	r2,zero,4009168 <___vfprintf_internal_r+0x1400>
 400914c:	e0bfd904 	addi	r2,fp,-156
 4009150:	100d883a 	mov	r6,r2
 4009154:	e17fbc17 	ldw	r5,-272(fp)
 4009158:	e13fbd17 	ldw	r4,-268(fp)
 400915c:	40121340 	call	4012134 <__sprint_r>
 4009160:	1003061e 	bne	r2,zero,4009d7c <___vfprintf_internal_r+0x2014>
 4009164:	e43fc904 	addi	r16,fp,-220

		/* the string or number proper */
#ifdef FLOATING_POINT
		if ((flags & FPT) == 0) {
 4009168:	8880400c 	andi	r2,r17,256
 400916c:	1000161e 	bne	r2,zero,40091c8 <___vfprintf_internal_r+0x1460>
			PRINT (cp, size);
 4009170:	84800015 	stw	r18,0(r16)
 4009174:	e0bfed17 	ldw	r2,-76(fp)
 4009178:	80800115 	stw	r2,4(r16)
 400917c:	e0ffdb17 	ldw	r3,-148(fp)
 4009180:	e0bfed17 	ldw	r2,-76(fp)
 4009184:	1885883a 	add	r2,r3,r2
 4009188:	e0bfdb15 	stw	r2,-148(fp)
 400918c:	84000204 	addi	r16,r16,8
 4009190:	e0bfda17 	ldw	r2,-152(fp)
 4009194:	10800044 	addi	r2,r2,1
 4009198:	e0bfda15 	stw	r2,-152(fp)
 400919c:	e0bfda17 	ldw	r2,-152(fp)
 40091a0:	10800210 	cmplti	r2,r2,8
 40091a4:	1002881e 	bne	r2,zero,4009bc8 <___vfprintf_internal_r+0x1e60>
 40091a8:	e0bfd904 	addi	r2,fp,-156
 40091ac:	100d883a 	mov	r6,r2
 40091b0:	e17fbc17 	ldw	r5,-272(fp)
 40091b4:	e13fbd17 	ldw	r4,-268(fp)
 40091b8:	40121340 	call	4012134 <__sprint_r>
 40091bc:	1002f11e 	bne	r2,zero,4009d84 <___vfprintf_internal_r+0x201c>
 40091c0:	e43fc904 	addi	r16,fp,-220
 40091c4:	00028006 	br	4009bc8 <___vfprintf_internal_r+0x1e60>
		} else {	/* glue together f_p fragments */
			if (ch >= 'f') {	/* 'f' or 'g' */
 40091c8:	a0801990 	cmplti	r2,r20,102
 40091cc:	1001cd1e 	bne	r2,zero,4009904 <___vfprintf_internal_r+0x1b9c>
				if (_fpvalue == 0) {
 40091d0:	e0bfe017 	ldw	r2,-128(fp)
 40091d4:	e0ffe117 	ldw	r3,-124(fp)
 40091d8:	000d883a 	mov	r6,zero
 40091dc:	000f883a 	mov	r7,zero
 40091e0:	1009883a 	mov	r4,r2
 40091e4:	180b883a 	mov	r5,r3
 40091e8:	40168040 	call	4016804 <__eqdf2>
 40091ec:	1000661e 	bne	r2,zero,4009388 <___vfprintf_internal_r+0x1620>
					/* kludge for __dtoa irregularity */
					PRINT ("0", 1);
 40091f0:	008100b4 	movhi	r2,1026
 40091f4:	10ab1b04 	addi	r2,r2,-21396
 40091f8:	80800015 	stw	r2,0(r16)
 40091fc:	00800044 	movi	r2,1
 4009200:	80800115 	stw	r2,4(r16)
 4009204:	e0bfdb17 	ldw	r2,-148(fp)
 4009208:	10800044 	addi	r2,r2,1
 400920c:	e0bfdb15 	stw	r2,-148(fp)
 4009210:	84000204 	addi	r16,r16,8
 4009214:	e0bfda17 	ldw	r2,-152(fp)
 4009218:	10800044 	addi	r2,r2,1
 400921c:	e0bfda15 	stw	r2,-152(fp)
 4009220:	e0bfda17 	ldw	r2,-152(fp)
 4009224:	10800210 	cmplti	r2,r2,8
 4009228:	1000071e 	bne	r2,zero,4009248 <___vfprintf_internal_r+0x14e0>
 400922c:	e0bfd904 	addi	r2,fp,-156
 4009230:	100d883a 	mov	r6,r2
 4009234:	e17fbc17 	ldw	r5,-272(fp)
 4009238:	e13fbd17 	ldw	r4,-268(fp)
 400923c:	40121340 	call	4012134 <__sprint_r>
 4009240:	1002d21e 	bne	r2,zero,4009d8c <___vfprintf_internal_r+0x2024>
 4009244:	e43fc904 	addi	r16,fp,-220
					if (expt < ndig || flags & ALT) {
 4009248:	e0ffdf17 	ldw	r3,-132(fp)
 400924c:	e0bfdc17 	ldw	r2,-144(fp)
 4009250:	18800216 	blt	r3,r2,400925c <___vfprintf_internal_r+0x14f4>
 4009254:	8880004c 	andi	r2,r17,1
 4009258:	10025b26 	beq	r2,zero,4009bc8 <___vfprintf_internal_r+0x1e60>
						PRINT (decimal_point, decp_len);
 400925c:	e0bfe817 	ldw	r2,-96(fp)
 4009260:	80800015 	stw	r2,0(r16)
 4009264:	e0bfe717 	ldw	r2,-100(fp)
 4009268:	80800115 	stw	r2,4(r16)
 400926c:	e0ffdb17 	ldw	r3,-148(fp)
 4009270:	e0bfe717 	ldw	r2,-100(fp)
 4009274:	1885883a 	add	r2,r3,r2
 4009278:	e0bfdb15 	stw	r2,-148(fp)
 400927c:	84000204 	addi	r16,r16,8
 4009280:	e0bfda17 	ldw	r2,-152(fp)
 4009284:	10800044 	addi	r2,r2,1
 4009288:	e0bfda15 	stw	r2,-152(fp)
 400928c:	e0bfda17 	ldw	r2,-152(fp)
 4009290:	10800210 	cmplti	r2,r2,8
 4009294:	1000071e 	bne	r2,zero,40092b4 <___vfprintf_internal_r+0x154c>
 4009298:	e0bfd904 	addi	r2,fp,-156
 400929c:	100d883a 	mov	r6,r2
 40092a0:	e17fbc17 	ldw	r5,-272(fp)
 40092a4:	e13fbd17 	ldw	r4,-268(fp)
 40092a8:	40121340 	call	4012134 <__sprint_r>
 40092ac:	1002b91e 	bne	r2,zero,4009d94 <___vfprintf_internal_r+0x202c>
 40092b0:	e43fc904 	addi	r16,fp,-220
						PAD (ndig - 1, zeroes);
 40092b4:	e0bfdc17 	ldw	r2,-144(fp)
 40092b8:	14ffffc4 	addi	r19,r2,-1
 40092bc:	04c2420e 	bge	zero,r19,4009bc8 <___vfprintf_internal_r+0x1e60>
 40092c0:	00001706 	br	4009320 <___vfprintf_internal_r+0x15b8>
 40092c4:	008100b4 	movhi	r2,1026
 40092c8:	10ab2004 	addi	r2,r2,-21376
 40092cc:	80800015 	stw	r2,0(r16)
 40092d0:	00800404 	movi	r2,16
 40092d4:	80800115 	stw	r2,4(r16)
 40092d8:	e0bfdb17 	ldw	r2,-148(fp)
 40092dc:	10800404 	addi	r2,r2,16
 40092e0:	e0bfdb15 	stw	r2,-148(fp)
 40092e4:	84000204 	addi	r16,r16,8
 40092e8:	e0bfda17 	ldw	r2,-152(fp)
 40092ec:	10800044 	addi	r2,r2,1
 40092f0:	e0bfda15 	stw	r2,-152(fp)
 40092f4:	e0bfda17 	ldw	r2,-152(fp)
 40092f8:	10800210 	cmplti	r2,r2,8
 40092fc:	1000071e 	bne	r2,zero,400931c <___vfprintf_internal_r+0x15b4>
 4009300:	e0bfd904 	addi	r2,fp,-156
 4009304:	100d883a 	mov	r6,r2
 4009308:	e17fbc17 	ldw	r5,-272(fp)
 400930c:	e13fbd17 	ldw	r4,-268(fp)
 4009310:	40121340 	call	4012134 <__sprint_r>
 4009314:	1002a11e 	bne	r2,zero,4009d9c <___vfprintf_internal_r+0x2034>
 4009318:	e43fc904 	addi	r16,fp,-220
 400931c:	9cfffc04 	addi	r19,r19,-16
 4009320:	98800448 	cmpgei	r2,r19,17
 4009324:	103fe71e 	bne	r2,zero,40092c4 <___vfprintf_internal_r+0x155c>
 4009328:	008100b4 	movhi	r2,1026
 400932c:	10ab2004 	addi	r2,r2,-21376
 4009330:	80800015 	stw	r2,0(r16)
 4009334:	9805883a 	mov	r2,r19
 4009338:	80800115 	stw	r2,4(r16)
 400933c:	e0bfdb17 	ldw	r2,-148(fp)
 4009340:	9807883a 	mov	r3,r19
 4009344:	10c5883a 	add	r2,r2,r3
 4009348:	e0bfdb15 	stw	r2,-148(fp)
 400934c:	84000204 	addi	r16,r16,8
 4009350:	e0bfda17 	ldw	r2,-152(fp)
 4009354:	10800044 	addi	r2,r2,1
 4009358:	e0bfda15 	stw	r2,-152(fp)
 400935c:	e0bfda17 	ldw	r2,-152(fp)
 4009360:	10800210 	cmplti	r2,r2,8
 4009364:	1002181e 	bne	r2,zero,4009bc8 <___vfprintf_internal_r+0x1e60>
 4009368:	e0bfd904 	addi	r2,fp,-156
 400936c:	100d883a 	mov	r6,r2
 4009370:	e17fbc17 	ldw	r5,-272(fp)
 4009374:	e13fbd17 	ldw	r4,-268(fp)
 4009378:	40121340 	call	4012134 <__sprint_r>
 400937c:	1002891e 	bne	r2,zero,4009da4 <___vfprintf_internal_r+0x203c>
 4009380:	e43fc904 	addi	r16,fp,-220
 4009384:	00021006 	br	4009bc8 <___vfprintf_internal_r+0x1e60>
					}
				} else if (expt <= 0) {
 4009388:	e0bfdf17 	ldw	r2,-132(fp)
 400938c:	00807c16 	blt	zero,r2,4009580 <___vfprintf_internal_r+0x1818>
					PRINT ("0", 1);
 4009390:	008100b4 	movhi	r2,1026
 4009394:	10ab1b04 	addi	r2,r2,-21396
 4009398:	80800015 	stw	r2,0(r16)
 400939c:	00800044 	movi	r2,1
 40093a0:	80800115 	stw	r2,4(r16)
 40093a4:	e0bfdb17 	ldw	r2,-148(fp)
 40093a8:	10800044 	addi	r2,r2,1
 40093ac:	e0bfdb15 	stw	r2,-148(fp)
 40093b0:	84000204 	addi	r16,r16,8
 40093b4:	e0bfda17 	ldw	r2,-152(fp)
 40093b8:	10800044 	addi	r2,r2,1
 40093bc:	e0bfda15 	stw	r2,-152(fp)
 40093c0:	e0bfda17 	ldw	r2,-152(fp)
 40093c4:	10800210 	cmplti	r2,r2,8
 40093c8:	1000071e 	bne	r2,zero,40093e8 <___vfprintf_internal_r+0x1680>
 40093cc:	e0bfd904 	addi	r2,fp,-156
 40093d0:	100d883a 	mov	r6,r2
 40093d4:	e17fbc17 	ldw	r5,-272(fp)
 40093d8:	e13fbd17 	ldw	r4,-268(fp)
 40093dc:	40121340 	call	4012134 <__sprint_r>
 40093e0:	1002721e 	bne	r2,zero,4009dac <___vfprintf_internal_r+0x2044>
 40093e4:	e43fc904 	addi	r16,fp,-220
					if (expt || ndig || flags & ALT) {
 40093e8:	e0bfdf17 	ldw	r2,-132(fp)
 40093ec:	1000041e 	bne	r2,zero,4009400 <___vfprintf_internal_r+0x1698>
 40093f0:	e0bfdc17 	ldw	r2,-144(fp)
 40093f4:	1000021e 	bne	r2,zero,4009400 <___vfprintf_internal_r+0x1698>
 40093f8:	8880004c 	andi	r2,r17,1
 40093fc:	1001f226 	beq	r2,zero,4009bc8 <___vfprintf_internal_r+0x1e60>
						PRINT (decimal_point, decp_len);
 4009400:	e0bfe817 	ldw	r2,-96(fp)
 4009404:	80800015 	stw	r2,0(r16)
 4009408:	e0bfe717 	ldw	r2,-100(fp)
 400940c:	80800115 	stw	r2,4(r16)
 4009410:	e0ffdb17 	ldw	r3,-148(fp)
 4009414:	e0bfe717 	ldw	r2,-100(fp)
 4009418:	1885883a 	add	r2,r3,r2
 400941c:	e0bfdb15 	stw	r2,-148(fp)
 4009420:	84000204 	addi	r16,r16,8
 4009424:	e0bfda17 	ldw	r2,-152(fp)
 4009428:	10800044 	addi	r2,r2,1
 400942c:	e0bfda15 	stw	r2,-152(fp)
 4009430:	e0bfda17 	ldw	r2,-152(fp)
 4009434:	10800210 	cmplti	r2,r2,8
 4009438:	1000071e 	bne	r2,zero,4009458 <___vfprintf_internal_r+0x16f0>
 400943c:	e0bfd904 	addi	r2,fp,-156
 4009440:	100d883a 	mov	r6,r2
 4009444:	e17fbc17 	ldw	r5,-272(fp)
 4009448:	e13fbd17 	ldw	r4,-268(fp)
 400944c:	40121340 	call	4012134 <__sprint_r>
 4009450:	1002581e 	bne	r2,zero,4009db4 <___vfprintf_internal_r+0x204c>
 4009454:	e43fc904 	addi	r16,fp,-220
						PAD (-expt, zeroes);
 4009458:	e0bfdf17 	ldw	r2,-132(fp)
 400945c:	00a7c83a 	sub	r19,zero,r2
 4009460:	04c0310e 	bge	zero,r19,4009528 <___vfprintf_internal_r+0x17c0>
 4009464:	00001706 	br	40094c4 <___vfprintf_internal_r+0x175c>
 4009468:	008100b4 	movhi	r2,1026
 400946c:	10ab2004 	addi	r2,r2,-21376
 4009470:	80800015 	stw	r2,0(r16)
 4009474:	00800404 	movi	r2,16
 4009478:	80800115 	stw	r2,4(r16)
 400947c:	e0bfdb17 	ldw	r2,-148(fp)
 4009480:	10800404 	addi	r2,r2,16
 4009484:	e0bfdb15 	stw	r2,-148(fp)
 4009488:	84000204 	addi	r16,r16,8
 400948c:	e0bfda17 	ldw	r2,-152(fp)
 4009490:	10800044 	addi	r2,r2,1
 4009494:	e0bfda15 	stw	r2,-152(fp)
 4009498:	e0bfda17 	ldw	r2,-152(fp)
 400949c:	10800210 	cmplti	r2,r2,8
 40094a0:	1000071e 	bne	r2,zero,40094c0 <___vfprintf_internal_r+0x1758>
 40094a4:	e0bfd904 	addi	r2,fp,-156
 40094a8:	100d883a 	mov	r6,r2
 40094ac:	e17fbc17 	ldw	r5,-272(fp)
 40094b0:	e13fbd17 	ldw	r4,-268(fp)
 40094b4:	40121340 	call	4012134 <__sprint_r>
 40094b8:	1002401e 	bne	r2,zero,4009dbc <___vfprintf_internal_r+0x2054>
 40094bc:	e43fc904 	addi	r16,fp,-220
 40094c0:	9cfffc04 	addi	r19,r19,-16
 40094c4:	98800448 	cmpgei	r2,r19,17
 40094c8:	103fe71e 	bne	r2,zero,4009468 <___vfprintf_internal_r+0x1700>
 40094cc:	008100b4 	movhi	r2,1026
 40094d0:	10ab2004 	addi	r2,r2,-21376
 40094d4:	80800015 	stw	r2,0(r16)
 40094d8:	9805883a 	mov	r2,r19
 40094dc:	80800115 	stw	r2,4(r16)
 40094e0:	e0bfdb17 	ldw	r2,-148(fp)
 40094e4:	9807883a 	mov	r3,r19
 40094e8:	10c5883a 	add	r2,r2,r3
 40094ec:	e0bfdb15 	stw	r2,-148(fp)
 40094f0:	84000204 	addi	r16,r16,8
 40094f4:	e0bfda17 	ldw	r2,-152(fp)
 40094f8:	10800044 	addi	r2,r2,1
 40094fc:	e0bfda15 	stw	r2,-152(fp)
 4009500:	e0bfda17 	ldw	r2,-152(fp)
 4009504:	10800210 	cmplti	r2,r2,8
 4009508:	1000071e 	bne	r2,zero,4009528 <___vfprintf_internal_r+0x17c0>
 400950c:	e0bfd904 	addi	r2,fp,-156
 4009510:	100d883a 	mov	r6,r2
 4009514:	e17fbc17 	ldw	r5,-272(fp)
 4009518:	e13fbd17 	ldw	r4,-268(fp)
 400951c:	40121340 	call	4012134 <__sprint_r>
 4009520:	1002281e 	bne	r2,zero,4009dc4 <___vfprintf_internal_r+0x205c>
 4009524:	e43fc904 	addi	r16,fp,-220
						PRINT (cp, ndig);
 4009528:	84800015 	stw	r18,0(r16)
 400952c:	e0bfdc17 	ldw	r2,-144(fp)
 4009530:	80800115 	stw	r2,4(r16)
 4009534:	e0bfdb17 	ldw	r2,-148(fp)
 4009538:	e0ffdc17 	ldw	r3,-144(fp)
 400953c:	10c5883a 	add	r2,r2,r3
 4009540:	e0bfdb15 	stw	r2,-148(fp)
 4009544:	84000204 	addi	r16,r16,8
 4009548:	e0bfda17 	ldw	r2,-152(fp)
 400954c:	10800044 	addi	r2,r2,1
 4009550:	e0bfda15 	stw	r2,-152(fp)
 4009554:	e0bfda17 	ldw	r2,-152(fp)
 4009558:	10800210 	cmplti	r2,r2,8
 400955c:	10019a1e 	bne	r2,zero,4009bc8 <___vfprintf_internal_r+0x1e60>
 4009560:	e0bfd904 	addi	r2,fp,-156
 4009564:	100d883a 	mov	r6,r2
 4009568:	e17fbc17 	ldw	r5,-272(fp)
 400956c:	e13fbd17 	ldw	r4,-268(fp)
 4009570:	40121340 	call	4012134 <__sprint_r>
 4009574:	1002151e 	bne	r2,zero,4009dcc <___vfprintf_internal_r+0x2064>
 4009578:	e43fc904 	addi	r16,fp,-220
 400957c:	00019206 	br	4009bc8 <___vfprintf_internal_r+0x1e60>
					}
				} else {
					char *convbuf = cp;
 4009580:	e4bfe315 	stw	r18,-116(fp)
					PRINTANDPAD(cp, convbuf + ndig,
 4009584:	e0bfdc17 	ldw	r2,-144(fp)
 4009588:	1007883a 	mov	r3,r2
 400958c:	e0bfe317 	ldw	r2,-116(fp)
 4009590:	10c5883a 	add	r2,r2,r3
 4009594:	1485c83a 	sub	r2,r2,r18
 4009598:	e0bfea15 	stw	r2,-88(fp)
 400959c:	e0bfea17 	ldw	r2,-88(fp)
 40095a0:	e0fff317 	ldw	r3,-52(fp)
 40095a4:	1880020e 	bge	r3,r2,40095b0 <___vfprintf_internal_r+0x1848>
 40095a8:	e0bff317 	ldw	r2,-52(fp)
 40095ac:	e0bfea15 	stw	r2,-88(fp)
 40095b0:	e0bfea17 	ldw	r2,-88(fp)
 40095b4:	0080150e 	bge	zero,r2,400960c <___vfprintf_internal_r+0x18a4>
 40095b8:	84800015 	stw	r18,0(r16)
 40095bc:	e0bfea17 	ldw	r2,-88(fp)
 40095c0:	80800115 	stw	r2,4(r16)
 40095c4:	e0ffdb17 	ldw	r3,-148(fp)
 40095c8:	e0bfea17 	ldw	r2,-88(fp)
 40095cc:	1885883a 	add	r2,r3,r2
 40095d0:	e0bfdb15 	stw	r2,-148(fp)
 40095d4:	84000204 	addi	r16,r16,8
 40095d8:	e0bfda17 	ldw	r2,-152(fp)
 40095dc:	10800044 	addi	r2,r2,1
 40095e0:	e0bfda15 	stw	r2,-152(fp)
 40095e4:	e0bfda17 	ldw	r2,-152(fp)
 40095e8:	10800210 	cmplti	r2,r2,8
 40095ec:	1000071e 	bne	r2,zero,400960c <___vfprintf_internal_r+0x18a4>
 40095f0:	e0bfd904 	addi	r2,fp,-156
 40095f4:	100d883a 	mov	r6,r2
 40095f8:	e17fbc17 	ldw	r5,-272(fp)
 40095fc:	e13fbd17 	ldw	r4,-268(fp)
 4009600:	40121340 	call	4012134 <__sprint_r>
 4009604:	1001f31e 	bne	r2,zero,4009dd4 <___vfprintf_internal_r+0x206c>
 4009608:	e43fc904 	addi	r16,fp,-220
 400960c:	e0bfea17 	ldw	r2,-88(fp)
 4009610:	1000010e 	bge	r2,zero,4009618 <___vfprintf_internal_r+0x18b0>
 4009614:	0005883a 	mov	r2,zero
 4009618:	e0fff317 	ldw	r3,-52(fp)
 400961c:	1885c83a 	sub	r2,r3,r2
 4009620:	e0bfea15 	stw	r2,-88(fp)
 4009624:	e0bfea17 	ldw	r2,-88(fp)
 4009628:	0080340e 	bge	zero,r2,40096fc <___vfprintf_internal_r+0x1994>
 400962c:	00001906 	br	4009694 <___vfprintf_internal_r+0x192c>
 4009630:	008100b4 	movhi	r2,1026
 4009634:	10ab2004 	addi	r2,r2,-21376
 4009638:	80800015 	stw	r2,0(r16)
 400963c:	00800404 	movi	r2,16
 4009640:	80800115 	stw	r2,4(r16)
 4009644:	e0bfdb17 	ldw	r2,-148(fp)
 4009648:	10800404 	addi	r2,r2,16
 400964c:	e0bfdb15 	stw	r2,-148(fp)
 4009650:	84000204 	addi	r16,r16,8
 4009654:	e0bfda17 	ldw	r2,-152(fp)
 4009658:	10800044 	addi	r2,r2,1
 400965c:	e0bfda15 	stw	r2,-152(fp)
 4009660:	e0bfda17 	ldw	r2,-152(fp)
 4009664:	10800210 	cmplti	r2,r2,8
 4009668:	1000071e 	bne	r2,zero,4009688 <___vfprintf_internal_r+0x1920>
 400966c:	e0bfd904 	addi	r2,fp,-156
 4009670:	100d883a 	mov	r6,r2
 4009674:	e17fbc17 	ldw	r5,-272(fp)
 4009678:	e13fbd17 	ldw	r4,-268(fp)
 400967c:	40121340 	call	4012134 <__sprint_r>
 4009680:	1001d61e 	bne	r2,zero,4009ddc <___vfprintf_internal_r+0x2074>
 4009684:	e43fc904 	addi	r16,fp,-220
 4009688:	e0bfea17 	ldw	r2,-88(fp)
 400968c:	10bffc04 	addi	r2,r2,-16
 4009690:	e0bfea15 	stw	r2,-88(fp)
 4009694:	e0bfea17 	ldw	r2,-88(fp)
 4009698:	10800448 	cmpgei	r2,r2,17
 400969c:	103fe41e 	bne	r2,zero,4009630 <___vfprintf_internal_r+0x18c8>
 40096a0:	008100b4 	movhi	r2,1026
 40096a4:	10ab2004 	addi	r2,r2,-21376
 40096a8:	80800015 	stw	r2,0(r16)
 40096ac:	e0bfea17 	ldw	r2,-88(fp)
 40096b0:	80800115 	stw	r2,4(r16)
 40096b4:	e0ffdb17 	ldw	r3,-148(fp)
 40096b8:	e0bfea17 	ldw	r2,-88(fp)
 40096bc:	1885883a 	add	r2,r3,r2
 40096c0:	e0bfdb15 	stw	r2,-148(fp)
 40096c4:	84000204 	addi	r16,r16,8
 40096c8:	e0bfda17 	ldw	r2,-152(fp)
 40096cc:	10800044 	addi	r2,r2,1
 40096d0:	e0bfda15 	stw	r2,-152(fp)
 40096d4:	e0bfda17 	ldw	r2,-152(fp)
 40096d8:	10800210 	cmplti	r2,r2,8
 40096dc:	1000071e 	bne	r2,zero,40096fc <___vfprintf_internal_r+0x1994>
 40096e0:	e0bfd904 	addi	r2,fp,-156
 40096e4:	100d883a 	mov	r6,r2
 40096e8:	e17fbc17 	ldw	r5,-272(fp)
 40096ec:	e13fbd17 	ldw	r4,-268(fp)
 40096f0:	40121340 	call	4012134 <__sprint_r>
 40096f4:	1001bb1e 	bne	r2,zero,4009de4 <___vfprintf_internal_r+0x207c>
 40096f8:	e43fc904 	addi	r16,fp,-220
						    lead, zeroes);
					cp += lead;
 40096fc:	e0bff317 	ldw	r2,-52(fp)
 4009700:	90a5883a 	add	r18,r18,r2
					    }
					    if (cp > convbuf + ndig)
						cp = convbuf + ndig;
					}
#endif
					if (expt < ndig || flags & ALT)
 4009704:	e0ffdf17 	ldw	r3,-132(fp)
 4009708:	e0bfdc17 	ldw	r2,-144(fp)
 400970c:	18800216 	blt	r3,r2,4009718 <___vfprintf_internal_r+0x19b0>
 4009710:	8880004c 	andi	r2,r17,1
 4009714:	10001626 	beq	r2,zero,4009770 <___vfprintf_internal_r+0x1a08>
					    PRINT (decimal_point, decp_len);
 4009718:	e0bfe817 	ldw	r2,-96(fp)
 400971c:	80800015 	stw	r2,0(r16)
 4009720:	e0bfe717 	ldw	r2,-100(fp)
 4009724:	80800115 	stw	r2,4(r16)
 4009728:	e0ffdb17 	ldw	r3,-148(fp)
 400972c:	e0bfe717 	ldw	r2,-100(fp)
 4009730:	1885883a 	add	r2,r3,r2
 4009734:	e0bfdb15 	stw	r2,-148(fp)
 4009738:	84000204 	addi	r16,r16,8
 400973c:	e0bfda17 	ldw	r2,-152(fp)
 4009740:	10800044 	addi	r2,r2,1
 4009744:	e0bfda15 	stw	r2,-152(fp)
 4009748:	e0bfda17 	ldw	r2,-152(fp)
 400974c:	10800210 	cmplti	r2,r2,8
 4009750:	1000071e 	bne	r2,zero,4009770 <___vfprintf_internal_r+0x1a08>
 4009754:	e0bfd904 	addi	r2,fp,-156
 4009758:	100d883a 	mov	r6,r2
 400975c:	e17fbc17 	ldw	r5,-272(fp)
 4009760:	e13fbd17 	ldw	r4,-268(fp)
 4009764:	40121340 	call	4012134 <__sprint_r>
 4009768:	1001a01e 	bne	r2,zero,4009dec <___vfprintf_internal_r+0x2084>
 400976c:	e43fc904 	addi	r16,fp,-220
					PRINTANDPAD (cp, convbuf + ndig,
 4009770:	e0bfdc17 	ldw	r2,-144(fp)
 4009774:	1007883a 	mov	r3,r2
 4009778:	e0bfe317 	ldw	r2,-116(fp)
 400977c:	10c5883a 	add	r2,r2,r3
 4009780:	1485c83a 	sub	r2,r2,r18
 4009784:	e0bfe915 	stw	r2,-92(fp)
 4009788:	e0ffdc17 	ldw	r3,-144(fp)
 400978c:	e0bfdf17 	ldw	r2,-132(fp)
 4009790:	1887c83a 	sub	r3,r3,r2
 4009794:	e0bfe917 	ldw	r2,-92(fp)
 4009798:	1880040e 	bge	r3,r2,40097ac <___vfprintf_internal_r+0x1a44>
 400979c:	e0ffdc17 	ldw	r3,-144(fp)
 40097a0:	e0bfdf17 	ldw	r2,-132(fp)
 40097a4:	1885c83a 	sub	r2,r3,r2
 40097a8:	e0bfe915 	stw	r2,-92(fp)
 40097ac:	e0bfe917 	ldw	r2,-92(fp)
 40097b0:	0080150e 	bge	zero,r2,4009808 <___vfprintf_internal_r+0x1aa0>
 40097b4:	84800015 	stw	r18,0(r16)
 40097b8:	e0bfe917 	ldw	r2,-92(fp)
 40097bc:	80800115 	stw	r2,4(r16)
 40097c0:	e0ffdb17 	ldw	r3,-148(fp)
 40097c4:	e0bfe917 	ldw	r2,-92(fp)
 40097c8:	1885883a 	add	r2,r3,r2
 40097cc:	e0bfdb15 	stw	r2,-148(fp)
 40097d0:	84000204 	addi	r16,r16,8
 40097d4:	e0bfda17 	ldw	r2,-152(fp)
 40097d8:	10800044 	addi	r2,r2,1
 40097dc:	e0bfda15 	stw	r2,-152(fp)
 40097e0:	e0bfda17 	ldw	r2,-152(fp)
 40097e4:	10800210 	cmplti	r2,r2,8
 40097e8:	1000071e 	bne	r2,zero,4009808 <___vfprintf_internal_r+0x1aa0>
 40097ec:	e0bfd904 	addi	r2,fp,-156
 40097f0:	100d883a 	mov	r6,r2
 40097f4:	e17fbc17 	ldw	r5,-272(fp)
 40097f8:	e13fbd17 	ldw	r4,-268(fp)
 40097fc:	40121340 	call	4012134 <__sprint_r>
 4009800:	10017c1e 	bne	r2,zero,4009df4 <___vfprintf_internal_r+0x208c>
 4009804:	e43fc904 	addi	r16,fp,-220
 4009808:	e0ffdc17 	ldw	r3,-144(fp)
 400980c:	e0bfdf17 	ldw	r2,-132(fp)
 4009810:	1887c83a 	sub	r3,r3,r2
 4009814:	e0bfe917 	ldw	r2,-92(fp)
 4009818:	1000010e 	bge	r2,zero,4009820 <___vfprintf_internal_r+0x1ab8>
 400981c:	0005883a 	mov	r2,zero
 4009820:	1885c83a 	sub	r2,r3,r2
 4009824:	e0bfe915 	stw	r2,-92(fp)
 4009828:	e0bfe917 	ldw	r2,-92(fp)
 400982c:	0080e60e 	bge	zero,r2,4009bc8 <___vfprintf_internal_r+0x1e60>
 4009830:	00001906 	br	4009898 <___vfprintf_internal_r+0x1b30>
 4009834:	008100b4 	movhi	r2,1026
 4009838:	10ab2004 	addi	r2,r2,-21376
 400983c:	80800015 	stw	r2,0(r16)
 4009840:	00800404 	movi	r2,16
 4009844:	80800115 	stw	r2,4(r16)
 4009848:	e0bfdb17 	ldw	r2,-148(fp)
 400984c:	10800404 	addi	r2,r2,16
 4009850:	e0bfdb15 	stw	r2,-148(fp)
 4009854:	84000204 	addi	r16,r16,8
 4009858:	e0bfda17 	ldw	r2,-152(fp)
 400985c:	10800044 	addi	r2,r2,1
 4009860:	e0bfda15 	stw	r2,-152(fp)
 4009864:	e0bfda17 	ldw	r2,-152(fp)
 4009868:	10800210 	cmplti	r2,r2,8
 400986c:	1000071e 	bne	r2,zero,400988c <___vfprintf_internal_r+0x1b24>
 4009870:	e0bfd904 	addi	r2,fp,-156
 4009874:	100d883a 	mov	r6,r2
 4009878:	e17fbc17 	ldw	r5,-272(fp)
 400987c:	e13fbd17 	ldw	r4,-268(fp)
 4009880:	40121340 	call	4012134 <__sprint_r>
 4009884:	10015d1e 	bne	r2,zero,4009dfc <___vfprintf_internal_r+0x2094>
 4009888:	e43fc904 	addi	r16,fp,-220
 400988c:	e0bfe917 	ldw	r2,-92(fp)
 4009890:	10bffc04 	addi	r2,r2,-16
 4009894:	e0bfe915 	stw	r2,-92(fp)
 4009898:	e0bfe917 	ldw	r2,-92(fp)
 400989c:	10800448 	cmpgei	r2,r2,17
 40098a0:	103fe41e 	bne	r2,zero,4009834 <___vfprintf_internal_r+0x1acc>
 40098a4:	008100b4 	movhi	r2,1026
 40098a8:	10ab2004 	addi	r2,r2,-21376
 40098ac:	80800015 	stw	r2,0(r16)
 40098b0:	e0bfe917 	ldw	r2,-92(fp)
 40098b4:	80800115 	stw	r2,4(r16)
 40098b8:	e0ffdb17 	ldw	r3,-148(fp)
 40098bc:	e0bfe917 	ldw	r2,-92(fp)
 40098c0:	1885883a 	add	r2,r3,r2
 40098c4:	e0bfdb15 	stw	r2,-148(fp)
 40098c8:	84000204 	addi	r16,r16,8
 40098cc:	e0bfda17 	ldw	r2,-152(fp)
 40098d0:	10800044 	addi	r2,r2,1
 40098d4:	e0bfda15 	stw	r2,-152(fp)
 40098d8:	e0bfda17 	ldw	r2,-152(fp)
 40098dc:	10800210 	cmplti	r2,r2,8
 40098e0:	1000b91e 	bne	r2,zero,4009bc8 <___vfprintf_internal_r+0x1e60>
 40098e4:	e0bfd904 	addi	r2,fp,-156
 40098e8:	100d883a 	mov	r6,r2
 40098ec:	e17fbc17 	ldw	r5,-272(fp)
 40098f0:	e13fbd17 	ldw	r4,-268(fp)
 40098f4:	40121340 	call	4012134 <__sprint_r>
 40098f8:	1001421e 	bne	r2,zero,4009e04 <___vfprintf_internal_r+0x209c>
 40098fc:	e43fc904 	addi	r16,fp,-220
 4009900:	0000b106 	br	4009bc8 <___vfprintf_internal_r+0x1e60>
						     ndig - expt, zeroes);
				}
			} else {	/* 'a', 'A', 'e', or 'E' */
				if (ndig > 1 || flags & ALT) {
 4009904:	e0bfdc17 	ldw	r2,-144(fp)
 4009908:	10800088 	cmpgei	r2,r2,2
 400990c:	1000021e 	bne	r2,zero,4009918 <___vfprintf_internal_r+0x1bb0>
 4009910:	8880004c 	andi	r2,r17,1
 4009914:	10008026 	beq	r2,zero,4009b18 <___vfprintf_internal_r+0x1db0>
					PRINT (cp, 1);
 4009918:	84800015 	stw	r18,0(r16)
 400991c:	00800044 	movi	r2,1
 4009920:	80800115 	stw	r2,4(r16)
 4009924:	e0bfdb17 	ldw	r2,-148(fp)
 4009928:	10800044 	addi	r2,r2,1
 400992c:	e0bfdb15 	stw	r2,-148(fp)
 4009930:	84000204 	addi	r16,r16,8
 4009934:	e0bfda17 	ldw	r2,-152(fp)
 4009938:	10800044 	addi	r2,r2,1
 400993c:	e0bfda15 	stw	r2,-152(fp)
 4009940:	e0bfda17 	ldw	r2,-152(fp)
 4009944:	10800210 	cmplti	r2,r2,8
 4009948:	1000071e 	bne	r2,zero,4009968 <___vfprintf_internal_r+0x1c00>
 400994c:	e0bfd904 	addi	r2,fp,-156
 4009950:	100d883a 	mov	r6,r2
 4009954:	e17fbc17 	ldw	r5,-272(fp)
 4009958:	e13fbd17 	ldw	r4,-268(fp)
 400995c:	40121340 	call	4012134 <__sprint_r>
 4009960:	10012a1e 	bne	r2,zero,4009e0c <___vfprintf_internal_r+0x20a4>
 4009964:	e43fc904 	addi	r16,fp,-220
					cp++;
 4009968:	94800044 	addi	r18,r18,1
					PRINT (decimal_point, decp_len);
 400996c:	e0bfe817 	ldw	r2,-96(fp)
 4009970:	80800015 	stw	r2,0(r16)
 4009974:	e0bfe717 	ldw	r2,-100(fp)
 4009978:	80800115 	stw	r2,4(r16)
 400997c:	e0ffdb17 	ldw	r3,-148(fp)
 4009980:	e0bfe717 	ldw	r2,-100(fp)
 4009984:	1885883a 	add	r2,r3,r2
 4009988:	e0bfdb15 	stw	r2,-148(fp)
 400998c:	84000204 	addi	r16,r16,8
 4009990:	e0bfda17 	ldw	r2,-152(fp)
 4009994:	10800044 	addi	r2,r2,1
 4009998:	e0bfda15 	stw	r2,-152(fp)
 400999c:	e0bfda17 	ldw	r2,-152(fp)
 40099a0:	10800210 	cmplti	r2,r2,8
 40099a4:	1000071e 	bne	r2,zero,40099c4 <___vfprintf_internal_r+0x1c5c>
 40099a8:	e0bfd904 	addi	r2,fp,-156
 40099ac:	100d883a 	mov	r6,r2
 40099b0:	e17fbc17 	ldw	r5,-272(fp)
 40099b4:	e13fbd17 	ldw	r4,-268(fp)
 40099b8:	40121340 	call	4012134 <__sprint_r>
 40099bc:	1001151e 	bne	r2,zero,4009e14 <___vfprintf_internal_r+0x20ac>
 40099c0:	e43fc904 	addi	r16,fp,-220
					if (_fpvalue) {
 40099c4:	e0bfe017 	ldw	r2,-128(fp)
 40099c8:	e0ffe117 	ldw	r3,-124(fp)
 40099cc:	000d883a 	mov	r6,zero
 40099d0:	000f883a 	mov	r7,zero
 40099d4:	1009883a 	mov	r4,r2
 40099d8:	180b883a 	mov	r5,r3
 40099dc:	40168040 	call	4016804 <__eqdf2>
 40099e0:	10001826 	beq	r2,zero,4009a44 <___vfprintf_internal_r+0x1cdc>
						PRINT (cp, ndig - 1);
 40099e4:	84800015 	stw	r18,0(r16)
 40099e8:	e0bfdc17 	ldw	r2,-144(fp)
 40099ec:	10bfffc4 	addi	r2,r2,-1
 40099f0:	80800115 	stw	r2,4(r16)
 40099f4:	e0bfdb17 	ldw	r2,-148(fp)
 40099f8:	e0ffdc17 	ldw	r3,-144(fp)
 40099fc:	10c5883a 	add	r2,r2,r3
 4009a00:	10bfffc4 	addi	r2,r2,-1
 4009a04:	e0bfdb15 	stw	r2,-148(fp)
 4009a08:	84000204 	addi	r16,r16,8
 4009a0c:	e0bfda17 	ldw	r2,-152(fp)
 4009a10:	10800044 	addi	r2,r2,1
 4009a14:	e0bfda15 	stw	r2,-152(fp)
 4009a18:	e0bfda17 	ldw	r2,-152(fp)
 4009a1c:	10800210 	cmplti	r2,r2,8
 4009a20:	1000521e 	bne	r2,zero,4009b6c <___vfprintf_internal_r+0x1e04>
 4009a24:	e0bfd904 	addi	r2,fp,-156
 4009a28:	100d883a 	mov	r6,r2
 4009a2c:	e17fbc17 	ldw	r5,-272(fp)
 4009a30:	e13fbd17 	ldw	r4,-268(fp)
 4009a34:	40121340 	call	4012134 <__sprint_r>
 4009a38:	1000f81e 	bne	r2,zero,4009e1c <___vfprintf_internal_r+0x20b4>
 4009a3c:	e43fc904 	addi	r16,fp,-220
					if (_fpvalue) {
 4009a40:	00004a06 	br	4009b6c <___vfprintf_internal_r+0x1e04>
					} else	/* 0.[0..] */
						/* __dtoa irregularity */
						PAD (ndig - 1, zeroes);
 4009a44:	e0bfdc17 	ldw	r2,-144(fp)
 4009a48:	14ffffc4 	addi	r19,r2,-1
 4009a4c:	04c0470e 	bge	zero,r19,4009b6c <___vfprintf_internal_r+0x1e04>
 4009a50:	00001706 	br	4009ab0 <___vfprintf_internal_r+0x1d48>
 4009a54:	008100b4 	movhi	r2,1026
 4009a58:	10ab2004 	addi	r2,r2,-21376
 4009a5c:	80800015 	stw	r2,0(r16)
 4009a60:	00800404 	movi	r2,16
 4009a64:	80800115 	stw	r2,4(r16)
 4009a68:	e0bfdb17 	ldw	r2,-148(fp)
 4009a6c:	10800404 	addi	r2,r2,16
 4009a70:	e0bfdb15 	stw	r2,-148(fp)
 4009a74:	84000204 	addi	r16,r16,8
 4009a78:	e0bfda17 	ldw	r2,-152(fp)
 4009a7c:	10800044 	addi	r2,r2,1
 4009a80:	e0bfda15 	stw	r2,-152(fp)
 4009a84:	e0bfda17 	ldw	r2,-152(fp)
 4009a88:	10800210 	cmplti	r2,r2,8
 4009a8c:	1000071e 	bne	r2,zero,4009aac <___vfprintf_internal_r+0x1d44>
 4009a90:	e0bfd904 	addi	r2,fp,-156
 4009a94:	100d883a 	mov	r6,r2
 4009a98:	e17fbc17 	ldw	r5,-272(fp)
 4009a9c:	e13fbd17 	ldw	r4,-268(fp)
 4009aa0:	40121340 	call	4012134 <__sprint_r>
 4009aa4:	1000df1e 	bne	r2,zero,4009e24 <___vfprintf_internal_r+0x20bc>
 4009aa8:	e43fc904 	addi	r16,fp,-220
 4009aac:	9cfffc04 	addi	r19,r19,-16
 4009ab0:	98800448 	cmpgei	r2,r19,17
 4009ab4:	103fe71e 	bne	r2,zero,4009a54 <___vfprintf_internal_r+0x1cec>
 4009ab8:	008100b4 	movhi	r2,1026
 4009abc:	10ab2004 	addi	r2,r2,-21376
 4009ac0:	80800015 	stw	r2,0(r16)
 4009ac4:	9805883a 	mov	r2,r19
 4009ac8:	80800115 	stw	r2,4(r16)
 4009acc:	e0bfdb17 	ldw	r2,-148(fp)
 4009ad0:	9807883a 	mov	r3,r19
 4009ad4:	10c5883a 	add	r2,r2,r3
 4009ad8:	e0bfdb15 	stw	r2,-148(fp)
 4009adc:	84000204 	addi	r16,r16,8
 4009ae0:	e0bfda17 	ldw	r2,-152(fp)
 4009ae4:	10800044 	addi	r2,r2,1
 4009ae8:	e0bfda15 	stw	r2,-152(fp)
 4009aec:	e0bfda17 	ldw	r2,-152(fp)
 4009af0:	10800210 	cmplti	r2,r2,8
 4009af4:	10001d1e 	bne	r2,zero,4009b6c <___vfprintf_internal_r+0x1e04>
 4009af8:	e0bfd904 	addi	r2,fp,-156
 4009afc:	100d883a 	mov	r6,r2
 4009b00:	e17fbc17 	ldw	r5,-272(fp)
 4009b04:	e13fbd17 	ldw	r4,-268(fp)
 4009b08:	40121340 	call	4012134 <__sprint_r>
 4009b0c:	1000c71e 	bne	r2,zero,4009e2c <___vfprintf_internal_r+0x20c4>
 4009b10:	e43fc904 	addi	r16,fp,-220
					if (_fpvalue) {
 4009b14:	00001506 	br	4009b6c <___vfprintf_internal_r+0x1e04>
				} else	/* XeYYY */
					PRINT (cp, 1);
 4009b18:	84800015 	stw	r18,0(r16)
 4009b1c:	00800044 	movi	r2,1
 4009b20:	80800115 	stw	r2,4(r16)
 4009b24:	e0bfdb17 	ldw	r2,-148(fp)
 4009b28:	10800044 	addi	r2,r2,1
 4009b2c:	e0bfdb15 	stw	r2,-148(fp)
 4009b30:	84000204 	addi	r16,r16,8
 4009b34:	e0bfda17 	ldw	r2,-152(fp)
 4009b38:	10800044 	addi	r2,r2,1
 4009b3c:	e0bfda15 	stw	r2,-152(fp)
 4009b40:	e0bfda17 	ldw	r2,-152(fp)
 4009b44:	10800210 	cmplti	r2,r2,8
 4009b48:	1000091e 	bne	r2,zero,4009b70 <___vfprintf_internal_r+0x1e08>
 4009b4c:	e0bfd904 	addi	r2,fp,-156
 4009b50:	100d883a 	mov	r6,r2
 4009b54:	e17fbc17 	ldw	r5,-272(fp)
 4009b58:	e13fbd17 	ldw	r4,-268(fp)
 4009b5c:	40121340 	call	4012134 <__sprint_r>
 4009b60:	1000b41e 	bne	r2,zero,4009e34 <___vfprintf_internal_r+0x20cc>
 4009b64:	e43fc904 	addi	r16,fp,-220
 4009b68:	00000106 	br	4009b70 <___vfprintf_internal_r+0x1e08>
					if (_fpvalue) {
 4009b6c:	0001883a 	nop
				PRINT (expstr, expsize);
 4009b70:	e0bfdd44 	addi	r2,fp,-139
 4009b74:	80800015 	stw	r2,0(r16)
 4009b78:	e0bff417 	ldw	r2,-48(fp)
 4009b7c:	80800115 	stw	r2,4(r16)
 4009b80:	e0ffdb17 	ldw	r3,-148(fp)
 4009b84:	e0bff417 	ldw	r2,-48(fp)
 4009b88:	1885883a 	add	r2,r3,r2
 4009b8c:	e0bfdb15 	stw	r2,-148(fp)
 4009b90:	84000204 	addi	r16,r16,8
 4009b94:	e0bfda17 	ldw	r2,-152(fp)
 4009b98:	10800044 	addi	r2,r2,1
 4009b9c:	e0bfda15 	stw	r2,-152(fp)
 4009ba0:	e0bfda17 	ldw	r2,-152(fp)
 4009ba4:	10800210 	cmplti	r2,r2,8
 4009ba8:	1000071e 	bne	r2,zero,4009bc8 <___vfprintf_internal_r+0x1e60>
 4009bac:	e0bfd904 	addi	r2,fp,-156
 4009bb0:	100d883a 	mov	r6,r2
 4009bb4:	e17fbc17 	ldw	r5,-272(fp)
 4009bb8:	e13fbd17 	ldw	r4,-268(fp)
 4009bbc:	40121340 	call	4012134 <__sprint_r>
 4009bc0:	10009e1e 	bne	r2,zero,4009e3c <___vfprintf_internal_r+0x20d4>
 4009bc4:	e43fc904 	addi	r16,fp,-220
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
 4009bc8:	8880010c 	andi	r2,r17,4
 4009bcc:	10003526 	beq	r2,zero,4009ca4 <___vfprintf_internal_r+0x1f3c>
			PAD (width - realsz, blanks);
 4009bd0:	e0fff617 	ldw	r3,-40(fp)
 4009bd4:	e0bfee17 	ldw	r2,-72(fp)
 4009bd8:	18a7c83a 	sub	r19,r3,r2
 4009bdc:	04c0310e 	bge	zero,r19,4009ca4 <___vfprintf_internal_r+0x1f3c>
 4009be0:	00001706 	br	4009c40 <___vfprintf_internal_r+0x1ed8>
 4009be4:	008100b4 	movhi	r2,1026
 4009be8:	10ab1c04 	addi	r2,r2,-21392
 4009bec:	80800015 	stw	r2,0(r16)
 4009bf0:	00800404 	movi	r2,16
 4009bf4:	80800115 	stw	r2,4(r16)
 4009bf8:	e0bfdb17 	ldw	r2,-148(fp)
 4009bfc:	10800404 	addi	r2,r2,16
 4009c00:	e0bfdb15 	stw	r2,-148(fp)
 4009c04:	84000204 	addi	r16,r16,8
 4009c08:	e0bfda17 	ldw	r2,-152(fp)
 4009c0c:	10800044 	addi	r2,r2,1
 4009c10:	e0bfda15 	stw	r2,-152(fp)
 4009c14:	e0bfda17 	ldw	r2,-152(fp)
 4009c18:	10800210 	cmplti	r2,r2,8
 4009c1c:	1000071e 	bne	r2,zero,4009c3c <___vfprintf_internal_r+0x1ed4>
 4009c20:	e0bfd904 	addi	r2,fp,-156
 4009c24:	100d883a 	mov	r6,r2
 4009c28:	e17fbc17 	ldw	r5,-272(fp)
 4009c2c:	e13fbd17 	ldw	r4,-268(fp)
 4009c30:	40121340 	call	4012134 <__sprint_r>
 4009c34:	1000831e 	bne	r2,zero,4009e44 <___vfprintf_internal_r+0x20dc>
 4009c38:	e43fc904 	addi	r16,fp,-220
 4009c3c:	9cfffc04 	addi	r19,r19,-16
 4009c40:	98800448 	cmpgei	r2,r19,17
 4009c44:	103fe71e 	bne	r2,zero,4009be4 <___vfprintf_internal_r+0x1e7c>
 4009c48:	008100b4 	movhi	r2,1026
 4009c4c:	10ab1c04 	addi	r2,r2,-21392
 4009c50:	80800015 	stw	r2,0(r16)
 4009c54:	9805883a 	mov	r2,r19
 4009c58:	80800115 	stw	r2,4(r16)
 4009c5c:	e0bfdb17 	ldw	r2,-148(fp)
 4009c60:	9807883a 	mov	r3,r19
 4009c64:	10c5883a 	add	r2,r2,r3
 4009c68:	e0bfdb15 	stw	r2,-148(fp)
 4009c6c:	84000204 	addi	r16,r16,8
 4009c70:	e0bfda17 	ldw	r2,-152(fp)
 4009c74:	10800044 	addi	r2,r2,1
 4009c78:	e0bfda15 	stw	r2,-152(fp)
 4009c7c:	e0bfda17 	ldw	r2,-152(fp)
 4009c80:	10800210 	cmplti	r2,r2,8
 4009c84:	1000071e 	bne	r2,zero,4009ca4 <___vfprintf_internal_r+0x1f3c>
 4009c88:	e0bfd904 	addi	r2,fp,-156
 4009c8c:	100d883a 	mov	r6,r2
 4009c90:	e17fbc17 	ldw	r5,-272(fp)
 4009c94:	e13fbd17 	ldw	r4,-268(fp)
 4009c98:	40121340 	call	4012134 <__sprint_r>
 4009c9c:	10006b1e 	bne	r2,zero,4009e4c <___vfprintf_internal_r+0x20e4>
 4009ca0:	e43fc904 	addi	r16,fp,-220

		/* finally, adjust ret */
		ret += width > realsz ? width : realsz;
 4009ca4:	e0fff617 	ldw	r3,-40(fp)
 4009ca8:	e0bfee17 	ldw	r2,-72(fp)
 4009cac:	10c0010e 	bge	r2,r3,4009cb4 <___vfprintf_internal_r+0x1f4c>
 4009cb0:	1805883a 	mov	r2,r3
 4009cb4:	e0fff717 	ldw	r3,-36(fp)
 4009cb8:	1885883a 	add	r2,r3,r2
 4009cbc:	e0bff715 	stw	r2,-36(fp)

		FLUSH ();	/* copy out the I/O vectors */
 4009cc0:	e0bfdb17 	ldw	r2,-148(fp)
 4009cc4:	10000626 	beq	r2,zero,4009ce0 <___vfprintf_internal_r+0x1f78>
 4009cc8:	e0bfd904 	addi	r2,fp,-156
 4009ccc:	100d883a 	mov	r6,r2
 4009cd0:	e17fbc17 	ldw	r5,-272(fp)
 4009cd4:	e13fbd17 	ldw	r4,-268(fp)
 4009cd8:	40121340 	call	4012134 <__sprint_r>
 4009cdc:	10005d1e 	bne	r2,zero,4009e54 <___vfprintf_internal_r+0x20ec>
 4009ce0:	e03fda15 	stw	zero,-152(fp)
 4009ce4:	e43fc904 	addi	r16,fp,-220

                if (malloc_buf != NULL) {
 4009ce8:	e0bfeb17 	ldw	r2,-84(fp)
 4009cec:	10387c26 	beq	r2,zero,4007ee0 <___vfprintf_internal_r+0x178>
			_free_r (data, malloc_buf);
 4009cf0:	e17feb17 	ldw	r5,-84(fp)
 4009cf4:	e13fbd17 	ldw	r4,-268(fp)
 4009cf8:	400cdd80 	call	400cdd8 <_free_r>
			malloc_buf = NULL;
 4009cfc:	e03feb15 	stw	zero,-84(fp)
	        cp = fmt;
 4009d00:	00387706 	br	4007ee0 <___vfprintf_internal_r+0x178>
                    goto done;
 4009d04:	0001883a 	nop
 4009d08:	00000106 	br	4009d10 <___vfprintf_internal_r+0x1fa8>
				goto done;
 4009d0c:	0001883a 	nop
		}
	}
done:
	FLUSH ();
 4009d10:	e0bfdb17 	ldw	r2,-148(fp)
 4009d14:	10000626 	beq	r2,zero,4009d30 <___vfprintf_internal_r+0x1fc8>
 4009d18:	e0bfd904 	addi	r2,fp,-156
 4009d1c:	100d883a 	mov	r6,r2
 4009d20:	e17fbc17 	ldw	r5,-272(fp)
 4009d24:	e13fbd17 	ldw	r4,-268(fp)
 4009d28:	40121340 	call	4012134 <__sprint_r>
 4009d2c:	10004b1e 	bne	r2,zero,4009e5c <___vfprintf_internal_r+0x20f4>
 4009d30:	e03fda15 	stw	zero,-152(fp)
 4009d34:	e43fc904 	addi	r16,fp,-220
 4009d38:	00004906 	br	4009e60 <___vfprintf_internal_r+0x20f8>
			PRINT (cp, m);
 4009d3c:	0001883a 	nop
 4009d40:	00004706 	br	4009e60 <___vfprintf_internal_r+0x20f8>
			PAD (width - realsz, blanks);
 4009d44:	0001883a 	nop
 4009d48:	00004506 	br	4009e60 <___vfprintf_internal_r+0x20f8>
 4009d4c:	0001883a 	nop
 4009d50:	00004306 	br	4009e60 <___vfprintf_internal_r+0x20f8>
			PRINT (&sign, 1);
 4009d54:	0001883a 	nop
 4009d58:	00004106 	br	4009e60 <___vfprintf_internal_r+0x20f8>
			PRINT (ox, 2);
 4009d5c:	0001883a 	nop
 4009d60:	00003f06 	br	4009e60 <___vfprintf_internal_r+0x20f8>
			PAD (width - realsz, zeroes);
 4009d64:	0001883a 	nop
 4009d68:	00003d06 	br	4009e60 <___vfprintf_internal_r+0x20f8>
 4009d6c:	0001883a 	nop
 4009d70:	00003b06 	br	4009e60 <___vfprintf_internal_r+0x20f8>
		PAD (dprec - size, zeroes);
 4009d74:	0001883a 	nop
 4009d78:	00003906 	br	4009e60 <___vfprintf_internal_r+0x20f8>
 4009d7c:	0001883a 	nop
 4009d80:	00003706 	br	4009e60 <___vfprintf_internal_r+0x20f8>
			PRINT (cp, size);
 4009d84:	0001883a 	nop
 4009d88:	00003506 	br	4009e60 <___vfprintf_internal_r+0x20f8>
					PRINT ("0", 1);
 4009d8c:	0001883a 	nop
 4009d90:	00003306 	br	4009e60 <___vfprintf_internal_r+0x20f8>
						PRINT (decimal_point, decp_len);
 4009d94:	0001883a 	nop
 4009d98:	00003106 	br	4009e60 <___vfprintf_internal_r+0x20f8>
						PAD (ndig - 1, zeroes);
 4009d9c:	0001883a 	nop
 4009da0:	00002f06 	br	4009e60 <___vfprintf_internal_r+0x20f8>
 4009da4:	0001883a 	nop
 4009da8:	00002d06 	br	4009e60 <___vfprintf_internal_r+0x20f8>
					PRINT ("0", 1);
 4009dac:	0001883a 	nop
 4009db0:	00002b06 	br	4009e60 <___vfprintf_internal_r+0x20f8>
						PRINT (decimal_point, decp_len);
 4009db4:	0001883a 	nop
 4009db8:	00002906 	br	4009e60 <___vfprintf_internal_r+0x20f8>
						PAD (-expt, zeroes);
 4009dbc:	0001883a 	nop
 4009dc0:	00002706 	br	4009e60 <___vfprintf_internal_r+0x20f8>
 4009dc4:	0001883a 	nop
 4009dc8:	00002506 	br	4009e60 <___vfprintf_internal_r+0x20f8>
						PRINT (cp, ndig);
 4009dcc:	0001883a 	nop
 4009dd0:	00002306 	br	4009e60 <___vfprintf_internal_r+0x20f8>
					PRINTANDPAD(cp, convbuf + ndig,
 4009dd4:	0001883a 	nop
 4009dd8:	00002106 	br	4009e60 <___vfprintf_internal_r+0x20f8>
 4009ddc:	0001883a 	nop
 4009de0:	00001f06 	br	4009e60 <___vfprintf_internal_r+0x20f8>
 4009de4:	0001883a 	nop
 4009de8:	00001d06 	br	4009e60 <___vfprintf_internal_r+0x20f8>
					    PRINT (decimal_point, decp_len);
 4009dec:	0001883a 	nop
 4009df0:	00001b06 	br	4009e60 <___vfprintf_internal_r+0x20f8>
					PRINTANDPAD (cp, convbuf + ndig,
 4009df4:	0001883a 	nop
 4009df8:	00001906 	br	4009e60 <___vfprintf_internal_r+0x20f8>
 4009dfc:	0001883a 	nop
 4009e00:	00001706 	br	4009e60 <___vfprintf_internal_r+0x20f8>
 4009e04:	0001883a 	nop
 4009e08:	00001506 	br	4009e60 <___vfprintf_internal_r+0x20f8>
					PRINT (cp, 1);
 4009e0c:	0001883a 	nop
 4009e10:	00001306 	br	4009e60 <___vfprintf_internal_r+0x20f8>
					PRINT (decimal_point, decp_len);
 4009e14:	0001883a 	nop
 4009e18:	00001106 	br	4009e60 <___vfprintf_internal_r+0x20f8>
						PRINT (cp, ndig - 1);
 4009e1c:	0001883a 	nop
 4009e20:	00000f06 	br	4009e60 <___vfprintf_internal_r+0x20f8>
						PAD (ndig - 1, zeroes);
 4009e24:	0001883a 	nop
 4009e28:	00000d06 	br	4009e60 <___vfprintf_internal_r+0x20f8>
 4009e2c:	0001883a 	nop
 4009e30:	00000b06 	br	4009e60 <___vfprintf_internal_r+0x20f8>
					PRINT (cp, 1);
 4009e34:	0001883a 	nop
 4009e38:	00000906 	br	4009e60 <___vfprintf_internal_r+0x20f8>
				PRINT (expstr, expsize);
 4009e3c:	0001883a 	nop
 4009e40:	00000706 	br	4009e60 <___vfprintf_internal_r+0x20f8>
			PAD (width - realsz, blanks);
 4009e44:	0001883a 	nop
 4009e48:	00000506 	br	4009e60 <___vfprintf_internal_r+0x20f8>
 4009e4c:	0001883a 	nop
 4009e50:	00000306 	br	4009e60 <___vfprintf_internal_r+0x20f8>
		FLUSH ();	/* copy out the I/O vectors */
 4009e54:	0001883a 	nop
 4009e58:	00000106 	br	4009e60 <___vfprintf_internal_r+0x20f8>
	FLUSH ();
 4009e5c:	0001883a 	nop
error:
	if (malloc_buf != NULL)
 4009e60:	e0bfeb17 	ldw	r2,-84(fp)
 4009e64:	10000326 	beq	r2,zero,4009e74 <___vfprintf_internal_r+0x210c>
		_free_r (data, malloc_buf);
 4009e68:	e17feb17 	ldw	r5,-84(fp)
 4009e6c:	e13fbd17 	ldw	r4,-268(fp)
 4009e70:	400cdd80 	call	400cdd8 <_free_r>
#ifndef STRING_ONLY
	_newlib_flockfile_end (fp);
#endif
	return (__sferror (fp) ? EOF : ret);
 4009e74:	e0bfbc17 	ldw	r2,-272(fp)
 4009e78:	1080030b 	ldhu	r2,12(r2)
 4009e7c:	10bfffcc 	andi	r2,r2,65535
 4009e80:	1080100c 	andi	r2,r2,64
 4009e84:	1000021e 	bne	r2,zero,4009e90 <___vfprintf_internal_r+0x2128>
 4009e88:	e0bff717 	ldw	r2,-36(fp)
 4009e8c:	00000106 	br	4009e94 <___vfprintf_internal_r+0x212c>
 4009e90:	00bfffc4 	movi	r2,-1
	/* NOTREACHED */
}
 4009e94:	e6fff804 	addi	sp,fp,-32
 4009e98:	dfc00917 	ldw	ra,36(sp)
 4009e9c:	df000817 	ldw	fp,32(sp)
 4009ea0:	ddc00717 	ldw	r23,28(sp)
 4009ea4:	dd800617 	ldw	r22,24(sp)
 4009ea8:	dd400517 	ldw	r21,20(sp)
 4009eac:	dd000417 	ldw	r20,16(sp)
 4009eb0:	dcc00317 	ldw	r19,12(sp)
 4009eb4:	dc800217 	ldw	r18,8(sp)
 4009eb8:	dc400117 	ldw	r17,4(sp)
 4009ebc:	dc000017 	ldw	r16,0(sp)
 4009ec0:	dec00a04 	addi	sp,sp,40
 4009ec4:	f800283a 	ret

04009ec8 <cvt>:
   [aAeEfFgG]; if it is [aA], then the return string lives in BUF,
   otherwise the return value shares the mprec reentrant storage.  */
static char *
cvt(struct _reent *data, _PRINTF_FLOAT_TYPE value, int ndigits, int flags,
    char *sign, int *decpt, int ch, int *length, char *buf)
{
 4009ec8:	deffef04 	addi	sp,sp,-68
 4009ecc:	dfc01015 	stw	ra,64(sp)
 4009ed0:	df000f15 	stw	fp,60(sp)
 4009ed4:	df000f04 	addi	fp,sp,60
 4009ed8:	e13ff815 	stw	r4,-32(fp)
 4009edc:	e17ff615 	stw	r5,-40(fp)
 4009ee0:	e1bff715 	stw	r6,-36(fp)
 4009ee4:	e1fff515 	stw	r7,-44(fp)
	int mode, dsgn;
	char *digits, *bp, *rve;
# ifdef _NO_LONGDBL
	union double_union tmp;

	tmp.d = value;
 4009ee8:	e0bff617 	ldw	r2,-40(fp)
 4009eec:	e0bff915 	stw	r2,-28(fp)
 4009ef0:	e0bff717 	ldw	r2,-36(fp)
 4009ef4:	e0bffa15 	stw	r2,-24(fp)
	if (word0 (tmp) & Sign_bit) { /* this will check for < 0 and -0.0 */
 4009ef8:	e0bffa17 	ldw	r2,-24(fp)
 4009efc:	1000090e 	bge	r2,zero,4009f24 <cvt+0x5c>
		value = -value;
 4009f00:	e0bff617 	ldw	r2,-40(fp)
 4009f04:	e0bff615 	stw	r2,-40(fp)
 4009f08:	e0bff717 	ldw	r2,-36(fp)
 4009f0c:	10a0003c 	xorhi	r2,r2,32768
 4009f10:	e0bff715 	stw	r2,-36(fp)
		*sign = '-';
 4009f14:	e0800317 	ldw	r2,12(fp)
 4009f18:	00c00b44 	movi	r3,45
 4009f1c:	10c00005 	stb	r3,0(r2)
 4009f20:	00000206 	br	4009f2c <cvt+0x64>
	} else
		*sign = '\000';
 4009f24:	e0800317 	ldw	r2,12(fp)
 4009f28:	10000005 	stb	zero,0(r2)
		}
		*length = bp - buf;
		return buf;
	}
# endif /* _WANT_IO_C99_FORMATS */
	if (ch == 'f' || ch == 'F') {
 4009f2c:	e0800517 	ldw	r2,20(fp)
 4009f30:	108019a0 	cmpeqi	r2,r2,102
 4009f34:	1000031e 	bne	r2,zero,4009f44 <cvt+0x7c>
 4009f38:	e0800517 	ldw	r2,20(fp)
 4009f3c:	10801198 	cmpnei	r2,r2,70
 4009f40:	1000031e 	bne	r2,zero,4009f50 <cvt+0x88>
		mode = 3;		/* ndigits after the decimal point */
 4009f44:	008000c4 	movi	r2,3
 4009f48:	e0bfff15 	stw	r2,-4(fp)
 4009f4c:	00000b06 	br	4009f7c <cvt+0xb4>
	} else {
		/* To obtain ndigits after the decimal point for the 'e'
		 * and 'E' formats, round to ndigits + 1 significant
		 * figures.
		 */
		if (ch == 'e' || ch == 'E') {
 4009f50:	e0800517 	ldw	r2,20(fp)
 4009f54:	10801960 	cmpeqi	r2,r2,101
 4009f58:	1000031e 	bne	r2,zero,4009f68 <cvt+0xa0>
 4009f5c:	e0800517 	ldw	r2,20(fp)
 4009f60:	10801158 	cmpnei	r2,r2,69
 4009f64:	1000031e 	bne	r2,zero,4009f74 <cvt+0xac>
			ndigits++;
 4009f68:	e0bff517 	ldw	r2,-44(fp)
 4009f6c:	10800044 	addi	r2,r2,1
 4009f70:	e0bff515 	stw	r2,-44(fp)
		}
		mode = 2;		/* ndigits significant digits */
 4009f74:	00800084 	movi	r2,2
 4009f78:	e0bfff15 	stw	r2,-4(fp)
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
 4009f7c:	e0bffb04 	addi	r2,fp,-20
 4009f80:	d8800315 	stw	r2,12(sp)
 4009f84:	e0bffc04 	addi	r2,fp,-16
 4009f88:	d8800215 	stw	r2,8(sp)
 4009f8c:	e0800417 	ldw	r2,16(fp)
 4009f90:	d8800115 	stw	r2,4(sp)
 4009f94:	e0bff517 	ldw	r2,-44(fp)
 4009f98:	d8800015 	stw	r2,0(sp)
 4009f9c:	e1ffff17 	ldw	r7,-4(fp)
 4009fa0:	e17ff617 	ldw	r5,-40(fp)
 4009fa4:	e1bff717 	ldw	r6,-36(fp)
 4009fa8:	e13ff817 	ldw	r4,-32(fp)
 4009fac:	400a76c0 	call	400a76c <_dtoa_r>
 4009fb0:	e0bffd15 	stw	r2,-12(fp)

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
 4009fb4:	e0800517 	ldw	r2,20(fp)
 4009fb8:	108019e0 	cmpeqi	r2,r2,103
 4009fbc:	1000031e 	bne	r2,zero,4009fcc <cvt+0x104>
 4009fc0:	e0800517 	ldw	r2,20(fp)
 4009fc4:	108011d8 	cmpnei	r2,r2,71
 4009fc8:	1000031e 	bne	r2,zero,4009fd8 <cvt+0x110>
 4009fcc:	e0800217 	ldw	r2,8(fp)
 4009fd0:	1080004c 	andi	r2,r2,1
 4009fd4:	10003326 	beq	r2,zero,400a0a4 <cvt+0x1dc>
		bp = digits + ndigits;
 4009fd8:	e0bff517 	ldw	r2,-44(fp)
 4009fdc:	e0fffd17 	ldw	r3,-12(fp)
 4009fe0:	1885883a 	add	r2,r3,r2
 4009fe4:	e0bffe15 	stw	r2,-8(fp)
		if (ch == 'f' || ch == 'F') {
 4009fe8:	e0800517 	ldw	r2,20(fp)
 4009fec:	108019a0 	cmpeqi	r2,r2,102
 4009ff0:	1000031e 	bne	r2,zero,400a000 <cvt+0x138>
 4009ff4:	e0800517 	ldw	r2,20(fp)
 4009ff8:	10801198 	cmpnei	r2,r2,70
 4009ffc:	1000181e 	bne	r2,zero,400a060 <cvt+0x198>
			if (*digits == '0' && value)
 400a000:	e0bffd17 	ldw	r2,-12(fp)
 400a004:	10800003 	ldbu	r2,0(r2)
 400a008:	10803fcc 	andi	r2,r2,255
 400a00c:	1080201c 	xori	r2,r2,128
 400a010:	10bfe004 	addi	r2,r2,-128
 400a014:	10800c18 	cmpnei	r2,r2,48
 400a018:	10000b1e 	bne	r2,zero,400a048 <cvt+0x180>
 400a01c:	000d883a 	mov	r6,zero
 400a020:	000f883a 	mov	r7,zero
 400a024:	e13ff617 	ldw	r4,-40(fp)
 400a028:	e17ff717 	ldw	r5,-36(fp)
 400a02c:	40168040 	call	4016804 <__eqdf2>
 400a030:	10000526 	beq	r2,zero,400a048 <cvt+0x180>
				*decpt = -ndigits + 1;
 400a034:	00c00044 	movi	r3,1
 400a038:	e0bff517 	ldw	r2,-44(fp)
 400a03c:	1887c83a 	sub	r3,r3,r2
 400a040:	e0800417 	ldw	r2,16(fp)
 400a044:	10c00015 	stw	r3,0(r2)
			bp += *decpt;
 400a048:	e0800417 	ldw	r2,16(fp)
 400a04c:	10800017 	ldw	r2,0(r2)
 400a050:	1007883a 	mov	r3,r2
 400a054:	e0bffe17 	ldw	r2,-8(fp)
 400a058:	10c5883a 	add	r2,r2,r3
 400a05c:	e0bffe15 	stw	r2,-8(fp)
		}
		if (value == 0)	/* kludge for __dtoa irregularity */
 400a060:	000d883a 	mov	r6,zero
 400a064:	000f883a 	mov	r7,zero
 400a068:	e13ff617 	ldw	r4,-40(fp)
 400a06c:	e17ff717 	ldw	r5,-36(fp)
 400a070:	40168040 	call	4016804 <__eqdf2>
 400a074:	1000081e 	bne	r2,zero,400a098 <cvt+0x1d0>
			rve = bp;
 400a078:	e0bffe17 	ldw	r2,-8(fp)
 400a07c:	e0bffb15 	stw	r2,-20(fp)
		while (rve < bp)
 400a080:	00000506 	br	400a098 <cvt+0x1d0>
			*rve++ = '0';
 400a084:	e0bffb17 	ldw	r2,-20(fp)
 400a088:	10c00044 	addi	r3,r2,1
 400a08c:	e0fffb15 	stw	r3,-20(fp)
 400a090:	00c00c04 	movi	r3,48
 400a094:	10c00005 	stb	r3,0(r2)
		while (rve < bp)
 400a098:	e0fffb17 	ldw	r3,-20(fp)
 400a09c:	e0bffe17 	ldw	r2,-8(fp)
 400a0a0:	18bff836 	bltu	r3,r2,400a084 <cvt+0x1bc>
	}
	*length = rve - digits;
 400a0a4:	e0fffb17 	ldw	r3,-20(fp)
 400a0a8:	e0bffd17 	ldw	r2,-12(fp)
 400a0ac:	1887c83a 	sub	r3,r3,r2
 400a0b0:	e0800617 	ldw	r2,24(fp)
 400a0b4:	10c00015 	stw	r3,0(r2)
	return (digits);
 400a0b8:	e0bffd17 	ldw	r2,-12(fp)
}
 400a0bc:	e037883a 	mov	sp,fp
 400a0c0:	dfc00117 	ldw	ra,4(sp)
 400a0c4:	df000017 	ldw	fp,0(sp)
 400a0c8:	dec00204 	addi	sp,sp,8
 400a0cc:	f800283a 	ret

0400a0d0 <exponent>:

static int
exponent(char *p0, int exp, int fmtch)
{
 400a0d0:	defff704 	addi	sp,sp,-36
 400a0d4:	dfc00815 	stw	ra,32(sp)
 400a0d8:	df000715 	stw	fp,28(sp)
 400a0dc:	dc400615 	stw	r17,24(sp)
 400a0e0:	dc000515 	stw	r16,20(sp)
 400a0e4:	df000704 	addi	fp,sp,28
 400a0e8:	e13ffb15 	stw	r4,-20(fp)
 400a0ec:	e17ffa15 	stw	r5,-24(fp)
 400a0f0:	e1bff915 	stw	r6,-28(fp)
	int isa = fmtch == 'a' || fmtch == 'A';
# else
#  define isa 0
# endif

	p = p0;
 400a0f4:	e47ffb17 	ldw	r17,-20(fp)
	*p++ = isa ? 'p' - 'a' + fmtch : fmtch;
 400a0f8:	8805883a 	mov	r2,r17
 400a0fc:	14400044 	addi	r17,r2,1
 400a100:	e0fff917 	ldw	r3,-28(fp)
 400a104:	10c00005 	stb	r3,0(r2)
	if (exp < 0) {
 400a108:	e0bffa17 	ldw	r2,-24(fp)
 400a10c:	1000080e 	bge	r2,zero,400a130 <exponent+0x60>
		exp = -exp;
 400a110:	e0bffa17 	ldw	r2,-24(fp)
 400a114:	0085c83a 	sub	r2,zero,r2
 400a118:	e0bffa15 	stw	r2,-24(fp)
		*p++ = '-';
 400a11c:	8805883a 	mov	r2,r17
 400a120:	14400044 	addi	r17,r2,1
 400a124:	00c00b44 	movi	r3,45
 400a128:	10c00005 	stb	r3,0(r2)
 400a12c:	00000406 	br	400a140 <exponent+0x70>
	}
	else
		*p++ = '+';
 400a130:	8805883a 	mov	r2,r17
 400a134:	14400044 	addi	r17,r2,1
 400a138:	00c00ac4 	movi	r3,43
 400a13c:	10c00005 	stb	r3,0(r2)
	t = expbuf + MAXEXPLEN;
 400a140:	e43ffc44 	addi	r16,fp,-15
 400a144:	840001c4 	addi	r16,r16,7
	if (exp > 9) {
 400a148:	e0bffa17 	ldw	r2,-24(fp)
 400a14c:	10800290 	cmplti	r2,r2,10
 400a150:	10001e1e 	bne	r2,zero,400a1cc <exponent+0xfc>
		do {
			*--t = to_char (exp % 10);
 400a154:	e0bffa17 	ldw	r2,-24(fp)
 400a158:	01400284 	movi	r5,10
 400a15c:	1009883a 	mov	r4,r2
 400a160:	40074700 	call	4007470 <__modsi3>
 400a164:	10800c04 	addi	r2,r2,48
 400a168:	843fffc4 	addi	r16,r16,-1
 400a16c:	80800005 	stb	r2,0(r16)
		} while ((exp /= 10) > 9);
 400a170:	e0bffa17 	ldw	r2,-24(fp)
 400a174:	01400284 	movi	r5,10
 400a178:	1009883a 	mov	r4,r2
 400a17c:	40073f00 	call	40073f0 <__divsi3>
 400a180:	e0bffa15 	stw	r2,-24(fp)
 400a184:	e0bffa17 	ldw	r2,-24(fp)
 400a188:	10800288 	cmpgei	r2,r2,10
 400a18c:	103ff11e 	bne	r2,zero,400a154 <exponent+0x84>
		*--t = to_char (exp);
 400a190:	e0bffa17 	ldw	r2,-24(fp)
 400a194:	10800c04 	addi	r2,r2,48
 400a198:	843fffc4 	addi	r16,r16,-1
 400a19c:	80800005 	stb	r2,0(r16)
		for (; t < expbuf + MAXEXPLEN; *p++ = *t++);
 400a1a0:	00000606 	br	400a1bc <exponent+0xec>
 400a1a4:	8007883a 	mov	r3,r16
 400a1a8:	1c000044 	addi	r16,r3,1
 400a1ac:	8805883a 	mov	r2,r17
 400a1b0:	14400044 	addi	r17,r2,1
 400a1b4:	18c00003 	ldbu	r3,0(r3)
 400a1b8:	10c00005 	stb	r3,0(r2)
 400a1bc:	e0bffc44 	addi	r2,fp,-15
 400a1c0:	108001c4 	addi	r2,r2,7
 400a1c4:	80bff736 	bltu	r16,r2,400a1a4 <exponent+0xd4>
 400a1c8:	00000a06 	br	400a1f4 <exponent+0x124>
	}
	else {
		if (!isa)
			*p++ = '0';
 400a1cc:	8805883a 	mov	r2,r17
 400a1d0:	14400044 	addi	r17,r2,1
 400a1d4:	00c00c04 	movi	r3,48
 400a1d8:	10c00005 	stb	r3,0(r2)
		*p++ = to_char (exp);
 400a1dc:	e0bffa17 	ldw	r2,-24(fp)
 400a1e0:	10800c04 	addi	r2,r2,48
 400a1e4:	1007883a 	mov	r3,r2
 400a1e8:	8805883a 	mov	r2,r17
 400a1ec:	14400044 	addi	r17,r2,1
 400a1f0:	10c00005 	stb	r3,0(r2)
	}
	return (p - p0);
 400a1f4:	e0bffb17 	ldw	r2,-20(fp)
 400a1f8:	8885c83a 	sub	r2,r17,r2
}
 400a1fc:	e6fffe04 	addi	sp,fp,-8
 400a200:	dfc00317 	ldw	ra,12(sp)
 400a204:	df000217 	ldw	fp,8(sp)
 400a208:	dc400117 	ldw	r17,4(sp)
 400a20c:	dc000017 	ldw	r16,0(sp)
 400a210:	dec00404 	addi	sp,sp,16
 400a214:	f800283a 	ret

0400a218 <__swsetup_r>:
 */

int
__swsetup_r (struct _reent *ptr,
       register FILE * fp)
{
 400a218:	defffb04 	addi	sp,sp,-20
 400a21c:	dfc00415 	stw	ra,16(sp)
 400a220:	df000315 	stw	fp,12(sp)
 400a224:	dc000215 	stw	r16,8(sp)
 400a228:	df000304 	addi	fp,sp,12
 400a22c:	e13ffd15 	stw	r4,-12(fp)
 400a230:	2821883a 	mov	r16,r5
  /* Make sure stdio is set up.  */

  CHECK_INIT (_REENT, fp);
 400a234:	d0a00117 	ldw	r2,-32764(gp)
 400a238:	e0bffe15 	stw	r2,-8(fp)
 400a23c:	e0bffe17 	ldw	r2,-8(fp)
 400a240:	10000526 	beq	r2,zero,400a258 <__swsetup_r+0x40>
 400a244:	e0bffe17 	ldw	r2,-8(fp)
 400a248:	10800e17 	ldw	r2,56(r2)
 400a24c:	1000021e 	bne	r2,zero,400a258 <__swsetup_r+0x40>
 400a250:	e13ffe17 	ldw	r4,-8(fp)
 400a254:	400cbdc0 	call	400cbdc <__sinit>

  /*
   * If we are not writing, we had better be reading and writing.
   */

  if ((fp->_flags & __SWR) == 0)
 400a258:	8080030b 	ldhu	r2,12(r16)
 400a25c:	10bfffcc 	andi	r2,r2,65535
 400a260:	1080020c 	andi	r2,r2,8
 400a264:	1000241e 	bne	r2,zero,400a2f8 <__swsetup_r+0xe0>
    {
      if ((fp->_flags & __SRW) == 0)
 400a268:	8080030b 	ldhu	r2,12(r16)
 400a26c:	10bfffcc 	andi	r2,r2,65535
 400a270:	1080040c 	andi	r2,r2,16
 400a274:	1000081e 	bne	r2,zero,400a298 <__swsetup_r+0x80>
        {
	  ptr->_errno = EBADF;
 400a278:	e0bffd17 	ldw	r2,-12(fp)
 400a27c:	00c00244 	movi	r3,9
 400a280:	10c00015 	stw	r3,0(r2)
	  fp->_flags |= __SERR;
 400a284:	8080030b 	ldhu	r2,12(r16)
 400a288:	10801014 	ori	r2,r2,64
 400a28c:	8080030d 	sth	r2,12(r16)
	  return EOF;
 400a290:	00bfffc4 	movi	r2,-1
 400a294:	00004206 	br	400a3a0 <__swsetup_r+0x188>
        }
      if (fp->_flags & __SRD)
 400a298:	8080030b 	ldhu	r2,12(r16)
 400a29c:	10bfffcc 	andi	r2,r2,65535
 400a2a0:	1080010c 	andi	r2,r2,4
 400a2a4:	10001126 	beq	r2,zero,400a2ec <__swsetup_r+0xd4>
	{
	  /* clobber any ungetc data */
	  if (HASUB (fp))
 400a2a8:	80800c17 	ldw	r2,48(r16)
 400a2ac:	10000826 	beq	r2,zero,400a2d0 <__swsetup_r+0xb8>
	    FREEUB (ptr, fp);
 400a2b0:	80c00c17 	ldw	r3,48(r16)
 400a2b4:	80801004 	addi	r2,r16,64
 400a2b8:	18800426 	beq	r3,r2,400a2cc <__swsetup_r+0xb4>
 400a2bc:	80800c17 	ldw	r2,48(r16)
 400a2c0:	100b883a 	mov	r5,r2
 400a2c4:	e13ffd17 	ldw	r4,-12(fp)
 400a2c8:	400cdd80 	call	400cdd8 <_free_r>
 400a2cc:	80000c15 	stw	zero,48(r16)
	  fp->_flags &= ~(__SRD | __SEOF);
 400a2d0:	80c0030b 	ldhu	r3,12(r16)
 400a2d4:	00bff6c4 	movi	r2,-37
 400a2d8:	1884703a 	and	r2,r3,r2
 400a2dc:	8080030d 	sth	r2,12(r16)
	  fp->_r = 0;
 400a2e0:	80000115 	stw	zero,4(r16)
	  fp->_p = fp->_bf._base;
 400a2e4:	80800417 	ldw	r2,16(r16)
 400a2e8:	80800015 	stw	r2,0(r16)
	}
      fp->_flags |= __SWR;
 400a2ec:	8080030b 	ldhu	r2,12(r16)
 400a2f0:	10800214 	ori	r2,r2,8
 400a2f4:	8080030d 	sth	r2,12(r16)
  /*
   * Make a buffer if necessary, then set _w.
   * A string I/O file should not explicitly allocate a buffer
   * unless asprintf is being used.
   */
  if (fp->_bf._base == NULL
 400a2f8:	80800417 	ldw	r2,16(r16)
 400a2fc:	10000b1e 	bne	r2,zero,400a32c <__swsetup_r+0x114>
        && (!(fp->_flags & __SSTR) || (fp->_flags & __SMBF)))
 400a300:	8080030b 	ldhu	r2,12(r16)
 400a304:	10bfffcc 	andi	r2,r2,65535
 400a308:	1080800c 	andi	r2,r2,512
 400a30c:	10000426 	beq	r2,zero,400a320 <__swsetup_r+0x108>
 400a310:	8080030b 	ldhu	r2,12(r16)
 400a314:	10bfffcc 	andi	r2,r2,65535
 400a318:	1080200c 	andi	r2,r2,128
 400a31c:	10000326 	beq	r2,zero,400a32c <__swsetup_r+0x114>
    __smakebuf_r (ptr, fp);
 400a320:	800b883a 	mov	r5,r16
 400a324:	e13ffd17 	ldw	r4,-12(fp)
 400a328:	400defc0 	call	400defc <__smakebuf_r>

  if (fp->_flags & __SLBF)
 400a32c:	8080030b 	ldhu	r2,12(r16)
 400a330:	10bfffcc 	andi	r2,r2,65535
 400a334:	1080004c 	andi	r2,r2,1
 400a338:	10000526 	beq	r2,zero,400a350 <__swsetup_r+0x138>
      /*
       * It is line buffered, so make _lbfsize be -_bufsize
       * for the putc() macro.  We will change _lbfsize back
       * to 0 whenever we turn off __SWR.
       */
      fp->_w = 0;
 400a33c:	80000215 	stw	zero,8(r16)
      fp->_lbfsize = -fp->_bf._size;
 400a340:	80800517 	ldw	r2,20(r16)
 400a344:	0085c83a 	sub	r2,zero,r2
 400a348:	80800615 	stw	r2,24(r16)
 400a34c:	00000806 	br	400a370 <__swsetup_r+0x158>
    }
  else
    fp->_w = fp->_flags & __SNBF ? 0 : fp->_bf._size;
 400a350:	8080030b 	ldhu	r2,12(r16)
 400a354:	10bfffcc 	andi	r2,r2,65535
 400a358:	1080008c 	andi	r2,r2,2
 400a35c:	1000021e 	bne	r2,zero,400a368 <__swsetup_r+0x150>
 400a360:	80800517 	ldw	r2,20(r16)
 400a364:	00000106 	br	400a36c <__swsetup_r+0x154>
 400a368:	0005883a 	mov	r2,zero
 400a36c:	80800215 	stw	r2,8(r16)

  if (!fp->_bf._base && (fp->_flags & __SMBF))
 400a370:	80800417 	ldw	r2,16(r16)
 400a374:	1000091e 	bne	r2,zero,400a39c <__swsetup_r+0x184>
 400a378:	8080030b 	ldhu	r2,12(r16)
 400a37c:	10bfffcc 	andi	r2,r2,65535
 400a380:	1080200c 	andi	r2,r2,128
 400a384:	10000526 	beq	r2,zero,400a39c <__swsetup_r+0x184>
    {
      /* __smakebuf_r set errno, but not flag */
      fp->_flags |= __SERR;
 400a388:	8080030b 	ldhu	r2,12(r16)
 400a38c:	10801014 	ori	r2,r2,64
 400a390:	8080030d 	sth	r2,12(r16)
      return EOF;
 400a394:	00bfffc4 	movi	r2,-1
 400a398:	00000106 	br	400a3a0 <__swsetup_r+0x188>
    }
  return 0;
 400a39c:	0005883a 	mov	r2,zero
}
 400a3a0:	e6ffff04 	addi	sp,fp,-4
 400a3a4:	dfc00217 	ldw	ra,8(sp)
 400a3a8:	df000117 	ldw	fp,4(sp)
 400a3ac:	dc000017 	ldw	r16,0(sp)
 400a3b0:	dec00304 	addi	sp,sp,12
 400a3b4:	f800283a 	ret

0400a3b8 <quorem>:
#include <string.h>
#include "mprec.h"

static int
quorem (_Bigint * b, _Bigint * S)
{
 400a3b8:	deffef04 	addi	sp,sp,-68
 400a3bc:	dfc01015 	stw	ra,64(sp)
 400a3c0:	df000f15 	stw	fp,60(sp)
 400a3c4:	df000f04 	addi	fp,sp,60
 400a3c8:	e13ff215 	stw	r4,-56(fp)
 400a3cc:	e17ff115 	stw	r5,-60(fp)
#ifdef Pack_32
  __Long z;
  __ULong si, zs;
#endif

  n = S->_wds;
 400a3d0:	e0bff117 	ldw	r2,-60(fp)
 400a3d4:	10800417 	ldw	r2,16(r2)
 400a3d8:	e0bfff15 	stw	r2,-4(fp)
#ifdef DEBUG
  /*debug*/ if (b->_wds > n)
    /*debug*/ Bug ("oversize b in quorem");
#endif
  if (b->_wds < n)
 400a3dc:	e0bff217 	ldw	r2,-56(fp)
 400a3e0:	10c00417 	ldw	r3,16(r2)
 400a3e4:	e0bfff17 	ldw	r2,-4(fp)
 400a3e8:	1880020e 	bge	r3,r2,400a3f4 <quorem+0x3c>
    return 0;
 400a3ec:	0005883a 	mov	r2,zero
 400a3f0:	0000d906 	br	400a758 <quorem+0x3a0>
  sx = S->_x;
 400a3f4:	e0bff117 	ldw	r2,-60(fp)
 400a3f8:	10800504 	addi	r2,r2,20
 400a3fc:	e0bff915 	stw	r2,-28(fp)
  sxe = sx + --n;
 400a400:	e0bfff17 	ldw	r2,-4(fp)
 400a404:	10bfffc4 	addi	r2,r2,-1
 400a408:	e0bfff15 	stw	r2,-4(fp)
 400a40c:	e0bfff17 	ldw	r2,-4(fp)
 400a410:	100490ba 	slli	r2,r2,2
 400a414:	e0fff917 	ldw	r3,-28(fp)
 400a418:	1885883a 	add	r2,r3,r2
 400a41c:	e0bff815 	stw	r2,-32(fp)
  bx = b->_x;
 400a420:	e0bff217 	ldw	r2,-56(fp)
 400a424:	10800504 	addi	r2,r2,20
 400a428:	e0bffb15 	stw	r2,-20(fp)
  bxe = bx + n;
 400a42c:	e0bfff17 	ldw	r2,-4(fp)
 400a430:	100490ba 	slli	r2,r2,2
 400a434:	e0fffb17 	ldw	r3,-20(fp)
 400a438:	1885883a 	add	r2,r3,r2
 400a43c:	e0bffa15 	stw	r2,-24(fp)
  q = *bxe / (*sxe + 1);	/* ensure q <= true quotient */
 400a440:	e0bffa17 	ldw	r2,-24(fp)
 400a444:	10c00017 	ldw	r3,0(r2)
 400a448:	e0bff817 	ldw	r2,-32(fp)
 400a44c:	10800017 	ldw	r2,0(r2)
 400a450:	10800044 	addi	r2,r2,1
 400a454:	100b883a 	mov	r5,r2
 400a458:	1809883a 	mov	r4,r3
 400a45c:	40074e40 	call	40074e4 <__udivsi3>
 400a460:	e0bffc15 	stw	r2,-16(fp)
#ifdef DEBUG
  /*debug*/ if (q > 9)
    /*debug*/ Bug ("oversized quotient in quorem");
#endif
  if (q)
 400a464:	e0bffc17 	ldw	r2,-16(fp)
 400a468:	10005826 	beq	r2,zero,400a5cc <quorem+0x214>
    {
      borrow = 0;
 400a46c:	e03ffe15 	stw	zero,-8(fp)
      carry = 0;
 400a470:	e03ffd15 	stw	zero,-12(fp)
      do
	{
#ifdef Pack_32
	  si = *sx++;
 400a474:	e0bff917 	ldw	r2,-28(fp)
 400a478:	10c00104 	addi	r3,r2,4
 400a47c:	e0fff915 	stw	r3,-28(fp)
 400a480:	10800017 	ldw	r2,0(r2)
 400a484:	e0bff715 	stw	r2,-36(fp)
	  ys = (si & 0xffff) * q + carry;
 400a488:	e0bff717 	ldw	r2,-36(fp)
 400a48c:	10bfffcc 	andi	r2,r2,65535
 400a490:	e17ffc17 	ldw	r5,-16(fp)
 400a494:	1009883a 	mov	r4,r2
 400a498:	40075a40 	call	40075a4 <__mulsi3>
 400a49c:	1007883a 	mov	r3,r2
 400a4a0:	e0bffd17 	ldw	r2,-12(fp)
 400a4a4:	10c5883a 	add	r2,r2,r3
 400a4a8:	e0bff615 	stw	r2,-40(fp)
	  zs = (si >> 16) * q + (ys >> 16);
 400a4ac:	e0bff717 	ldw	r2,-36(fp)
 400a4b0:	1004d43a 	srli	r2,r2,16
 400a4b4:	e17ffc17 	ldw	r5,-16(fp)
 400a4b8:	1009883a 	mov	r4,r2
 400a4bc:	40075a40 	call	40075a4 <__mulsi3>
 400a4c0:	1007883a 	mov	r3,r2
 400a4c4:	e0bff617 	ldw	r2,-40(fp)
 400a4c8:	1004d43a 	srli	r2,r2,16
 400a4cc:	1885883a 	add	r2,r3,r2
 400a4d0:	e0bff515 	stw	r2,-44(fp)
	  carry = zs >> 16;
 400a4d4:	e0bff517 	ldw	r2,-44(fp)
 400a4d8:	1004d43a 	srli	r2,r2,16
 400a4dc:	e0bffd15 	stw	r2,-12(fp)
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
 400a4e0:	e0bffb17 	ldw	r2,-20(fp)
 400a4e4:	10800017 	ldw	r2,0(r2)
 400a4e8:	10ffffcc 	andi	r3,r2,65535
 400a4ec:	e0bff617 	ldw	r2,-40(fp)
 400a4f0:	10bfffcc 	andi	r2,r2,65535
 400a4f4:	1887c83a 	sub	r3,r3,r2
 400a4f8:	e0bffe17 	ldw	r2,-8(fp)
 400a4fc:	1885883a 	add	r2,r3,r2
 400a500:	e0bff415 	stw	r2,-48(fp)
	  borrow = y >> 16;
 400a504:	e0bff417 	ldw	r2,-48(fp)
 400a508:	1005d43a 	srai	r2,r2,16
 400a50c:	e0bffe15 	stw	r2,-8(fp)
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
 400a510:	e0bffb17 	ldw	r2,-20(fp)
 400a514:	10800017 	ldw	r2,0(r2)
 400a518:	1006d43a 	srli	r3,r2,16
 400a51c:	e0bff517 	ldw	r2,-44(fp)
 400a520:	10bfffcc 	andi	r2,r2,65535
 400a524:	1887c83a 	sub	r3,r3,r2
 400a528:	e0bffe17 	ldw	r2,-8(fp)
 400a52c:	1885883a 	add	r2,r3,r2
 400a530:	e0bff315 	stw	r2,-52(fp)
	  borrow = z >> 16;
 400a534:	e0bff317 	ldw	r2,-52(fp)
 400a538:	1005d43a 	srai	r2,r2,16
 400a53c:	e0bffe15 	stw	r2,-8(fp)
	  Sign_Extend (borrow, z);
	  Storeinc (bx, z, y);
 400a540:	e0bff317 	ldw	r2,-52(fp)
 400a544:	1006943a 	slli	r3,r2,16
 400a548:	e0bff417 	ldw	r2,-48(fp)
 400a54c:	10bfffcc 	andi	r2,r2,65535
 400a550:	1888b03a 	or	r4,r3,r2
 400a554:	e0bffb17 	ldw	r2,-20(fp)
 400a558:	10c00104 	addi	r3,r2,4
 400a55c:	e0fffb15 	stw	r3,-20(fp)
 400a560:	2007883a 	mov	r3,r4
 400a564:	10c00015 	stw	r3,0(r2)
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  *bx++ = y & 0xffff;
#endif
	}
      while (sx <= sxe);
 400a568:	e0bff917 	ldw	r2,-28(fp)
 400a56c:	e0fff817 	ldw	r3,-32(fp)
 400a570:	18bfc02e 	bgeu	r3,r2,400a474 <quorem+0xbc>
      if (!*bxe)
 400a574:	e0bffa17 	ldw	r2,-24(fp)
 400a578:	10800017 	ldw	r2,0(r2)
 400a57c:	1000131e 	bne	r2,zero,400a5cc <quorem+0x214>
	{
	  bx = b->_x;
 400a580:	e0bff217 	ldw	r2,-56(fp)
 400a584:	10800504 	addi	r2,r2,20
 400a588:	e0bffb15 	stw	r2,-20(fp)
	  while (--bxe > bx && !*bxe)
 400a58c:	00000306 	br	400a59c <quorem+0x1e4>
	    --n;
 400a590:	e0bfff17 	ldw	r2,-4(fp)
 400a594:	10bfffc4 	addi	r2,r2,-1
 400a598:	e0bfff15 	stw	r2,-4(fp)
	  while (--bxe > bx && !*bxe)
 400a59c:	e0bffa17 	ldw	r2,-24(fp)
 400a5a0:	10bfff04 	addi	r2,r2,-4
 400a5a4:	e0bffa15 	stw	r2,-24(fp)
 400a5a8:	e0bffa17 	ldw	r2,-24(fp)
 400a5ac:	e0fffb17 	ldw	r3,-20(fp)
 400a5b0:	1880032e 	bgeu	r3,r2,400a5c0 <quorem+0x208>
 400a5b4:	e0bffa17 	ldw	r2,-24(fp)
 400a5b8:	10800017 	ldw	r2,0(r2)
 400a5bc:	103ff426 	beq	r2,zero,400a590 <quorem+0x1d8>
	  b->_wds = n;
 400a5c0:	e0bff217 	ldw	r2,-56(fp)
 400a5c4:	e0ffff17 	ldw	r3,-4(fp)
 400a5c8:	10c00415 	stw	r3,16(r2)
	}
    }
  if (cmp (b, S) >= 0)
 400a5cc:	e17ff117 	ldw	r5,-60(fp)
 400a5d0:	e13ff217 	ldw	r4,-56(fp)
 400a5d4:	40104580 	call	4010458 <__mcmp>
 400a5d8:	10005e16 	blt	r2,zero,400a754 <quorem+0x39c>
    {
      q++;
 400a5dc:	e0bffc17 	ldw	r2,-16(fp)
 400a5e0:	10800044 	addi	r2,r2,1
 400a5e4:	e0bffc15 	stw	r2,-16(fp)
      borrow = 0;
 400a5e8:	e03ffe15 	stw	zero,-8(fp)
      carry = 0;
 400a5ec:	e03ffd15 	stw	zero,-12(fp)
      bx = b->_x;
 400a5f0:	e0bff217 	ldw	r2,-56(fp)
 400a5f4:	10800504 	addi	r2,r2,20
 400a5f8:	e0bffb15 	stw	r2,-20(fp)
      sx = S->_x;
 400a5fc:	e0bff117 	ldw	r2,-60(fp)
 400a600:	10800504 	addi	r2,r2,20
 400a604:	e0bff915 	stw	r2,-28(fp)
      do
	{
#ifdef Pack_32
	  si = *sx++;
 400a608:	e0bff917 	ldw	r2,-28(fp)
 400a60c:	10c00104 	addi	r3,r2,4
 400a610:	e0fff915 	stw	r3,-28(fp)
 400a614:	10800017 	ldw	r2,0(r2)
 400a618:	e0bff715 	stw	r2,-36(fp)
	  ys = (si & 0xffff) + carry;
 400a61c:	e0bff717 	ldw	r2,-36(fp)
 400a620:	10bfffcc 	andi	r2,r2,65535
 400a624:	e0fffd17 	ldw	r3,-12(fp)
 400a628:	1885883a 	add	r2,r3,r2
 400a62c:	e0bff615 	stw	r2,-40(fp)
	  zs = (si >> 16) + (ys >> 16);
 400a630:	e0bff717 	ldw	r2,-36(fp)
 400a634:	1006d43a 	srli	r3,r2,16
 400a638:	e0bff617 	ldw	r2,-40(fp)
 400a63c:	1004d43a 	srli	r2,r2,16
 400a640:	1885883a 	add	r2,r3,r2
 400a644:	e0bff515 	stw	r2,-44(fp)
	  carry = zs >> 16;
 400a648:	e0bff517 	ldw	r2,-44(fp)
 400a64c:	1004d43a 	srli	r2,r2,16
 400a650:	e0bffd15 	stw	r2,-12(fp)
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
 400a654:	e0bffb17 	ldw	r2,-20(fp)
 400a658:	10800017 	ldw	r2,0(r2)
 400a65c:	10ffffcc 	andi	r3,r2,65535
 400a660:	e0bff617 	ldw	r2,-40(fp)
 400a664:	10bfffcc 	andi	r2,r2,65535
 400a668:	1887c83a 	sub	r3,r3,r2
 400a66c:	e0bffe17 	ldw	r2,-8(fp)
 400a670:	1885883a 	add	r2,r3,r2
 400a674:	e0bff415 	stw	r2,-48(fp)
	  borrow = y >> 16;
 400a678:	e0bff417 	ldw	r2,-48(fp)
 400a67c:	1005d43a 	srai	r2,r2,16
 400a680:	e0bffe15 	stw	r2,-8(fp)
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
 400a684:	e0bffb17 	ldw	r2,-20(fp)
 400a688:	10800017 	ldw	r2,0(r2)
 400a68c:	1006d43a 	srli	r3,r2,16
 400a690:	e0bff517 	ldw	r2,-44(fp)
 400a694:	10bfffcc 	andi	r2,r2,65535
 400a698:	1887c83a 	sub	r3,r3,r2
 400a69c:	e0bffe17 	ldw	r2,-8(fp)
 400a6a0:	1885883a 	add	r2,r3,r2
 400a6a4:	e0bff315 	stw	r2,-52(fp)
	  borrow = z >> 16;
 400a6a8:	e0bff317 	ldw	r2,-52(fp)
 400a6ac:	1005d43a 	srai	r2,r2,16
 400a6b0:	e0bffe15 	stw	r2,-8(fp)
	  Sign_Extend (borrow, z);
	  Storeinc (bx, z, y);
 400a6b4:	e0bff317 	ldw	r2,-52(fp)
 400a6b8:	1006943a 	slli	r3,r2,16
 400a6bc:	e0bff417 	ldw	r2,-48(fp)
 400a6c0:	10bfffcc 	andi	r2,r2,65535
 400a6c4:	1888b03a 	or	r4,r3,r2
 400a6c8:	e0bffb17 	ldw	r2,-20(fp)
 400a6cc:	10c00104 	addi	r3,r2,4
 400a6d0:	e0fffb15 	stw	r3,-20(fp)
 400a6d4:	2007883a 	mov	r3,r4
 400a6d8:	10c00015 	stw	r3,0(r2)
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  *bx++ = y & 0xffff;
#endif
	}
      while (sx <= sxe);
 400a6dc:	e0bff917 	ldw	r2,-28(fp)
 400a6e0:	e0fff817 	ldw	r3,-32(fp)
 400a6e4:	18bfc82e 	bgeu	r3,r2,400a608 <quorem+0x250>
      bx = b->_x;
 400a6e8:	e0bff217 	ldw	r2,-56(fp)
 400a6ec:	10800504 	addi	r2,r2,20
 400a6f0:	e0bffb15 	stw	r2,-20(fp)
      bxe = bx + n;
 400a6f4:	e0bfff17 	ldw	r2,-4(fp)
 400a6f8:	100490ba 	slli	r2,r2,2
 400a6fc:	e0fffb17 	ldw	r3,-20(fp)
 400a700:	1885883a 	add	r2,r3,r2
 400a704:	e0bffa15 	stw	r2,-24(fp)
      if (!*bxe)
 400a708:	e0bffa17 	ldw	r2,-24(fp)
 400a70c:	10800017 	ldw	r2,0(r2)
 400a710:	1000101e 	bne	r2,zero,400a754 <quorem+0x39c>
	{
	  while (--bxe > bx && !*bxe)
 400a714:	00000306 	br	400a724 <quorem+0x36c>
	    --n;
 400a718:	e0bfff17 	ldw	r2,-4(fp)
 400a71c:	10bfffc4 	addi	r2,r2,-1
 400a720:	e0bfff15 	stw	r2,-4(fp)
	  while (--bxe > bx && !*bxe)
 400a724:	e0bffa17 	ldw	r2,-24(fp)
 400a728:	10bfff04 	addi	r2,r2,-4
 400a72c:	e0bffa15 	stw	r2,-24(fp)
 400a730:	e0bffa17 	ldw	r2,-24(fp)
 400a734:	e0fffb17 	ldw	r3,-20(fp)
 400a738:	1880032e 	bgeu	r3,r2,400a748 <quorem+0x390>
 400a73c:	e0bffa17 	ldw	r2,-24(fp)
 400a740:	10800017 	ldw	r2,0(r2)
 400a744:	103ff426 	beq	r2,zero,400a718 <quorem+0x360>
	  b->_wds = n;
 400a748:	e0bff217 	ldw	r2,-56(fp)
 400a74c:	e0ffff17 	ldw	r3,-4(fp)
 400a750:	10c00415 	stw	r3,16(r2)
	}
    }
  return q;
 400a754:	e0bffc17 	ldw	r2,-16(fp)
}
 400a758:	e037883a 	mov	sp,fp
 400a75c:	dfc00117 	ldw	ra,4(sp)
 400a760:	df000017 	ldw	fp,0(sp)
 400a764:	dec00204 	addi	sp,sp,8
 400a768:	f800283a 	ret

0400a76c <_dtoa_r>:
	int mode,
	int ndigits,
	int *decpt,
	int *sign,
	char **rve)
{
 400a76c:	deffca04 	addi	sp,sp,-216
 400a770:	dfc03515 	stw	ra,212(sp)
 400a774:	df003415 	stw	fp,208(sp)
 400a778:	dcc03315 	stw	r19,204(sp)
 400a77c:	dc803215 	stw	r18,200(sp)
 400a780:	dc403115 	stw	r17,196(sp)
 400a784:	dc003015 	stw	r16,192(sp)
 400a788:	df003404 	addi	fp,sp,208
 400a78c:	e13fd015 	stw	r4,-192(fp)
 400a790:	e17fce15 	stw	r5,-200(fp)
 400a794:	e1bfcf15 	stw	r6,-196(fp)
 400a798:	e1ffcd15 	stw	r7,-204(fp)
  __Long L;
#ifndef Sudden_Underflow
  int denorm;
  __ULong x;
#endif
  _Bigint *b, *b1, *delta, *mlo = NULL, *mhi, *S;
 400a79c:	e03fe815 	stw	zero,-96(fp)
  double ds;
  char *s, *s0;

  d.d = _d;
 400a7a0:	e0bfce17 	ldw	r2,-200(fp)
 400a7a4:	e0bfd515 	stw	r2,-172(fp)
 400a7a8:	e0bfcf17 	ldw	r2,-196(fp)
 400a7ac:	e0bfd615 	stw	r2,-168(fp)

  _REENT_CHECK_MP(ptr);
  if (_REENT_MP_RESULT(ptr))
 400a7b0:	e0bfd017 	ldw	r2,-192(fp)
 400a7b4:	10801017 	ldw	r2,64(r2)
 400a7b8:	10001326 	beq	r2,zero,400a808 <_dtoa_r+0x9c>
    {
      _REENT_MP_RESULT(ptr)->_k = _REENT_MP_RESULT_K(ptr);
 400a7bc:	e0bfd017 	ldw	r2,-192(fp)
 400a7c0:	10801017 	ldw	r2,64(r2)
 400a7c4:	e0ffd017 	ldw	r3,-192(fp)
 400a7c8:	18c01117 	ldw	r3,68(r3)
 400a7cc:	10c00115 	stw	r3,4(r2)
      _REENT_MP_RESULT(ptr)->_maxwds = 1 << _REENT_MP_RESULT_K(ptr);
 400a7d0:	e0bfd017 	ldw	r2,-192(fp)
 400a7d4:	10c01117 	ldw	r3,68(r2)
 400a7d8:	e0bfd017 	ldw	r2,-192(fp)
 400a7dc:	10801017 	ldw	r2,64(r2)
 400a7e0:	01000044 	movi	r4,1
 400a7e4:	20c6983a 	sll	r3,r4,r3
 400a7e8:	10c00215 	stw	r3,8(r2)
      Bfree (ptr, _REENT_MP_RESULT(ptr));
 400a7ec:	e0bfd017 	ldw	r2,-192(fp)
 400a7f0:	10801017 	ldw	r2,64(r2)
 400a7f4:	100b883a 	mov	r5,r2
 400a7f8:	e13fd017 	ldw	r4,-192(fp)
 400a7fc:	400f6d80 	call	400f6d8 <_Bfree>
      _REENT_MP_RESULT(ptr) = 0;
 400a800:	e0bfd017 	ldw	r2,-192(fp)
 400a804:	10001015 	stw	zero,64(r2)
    }

  if (word0 (d) & Sign_bit)
 400a808:	e0bfd617 	ldw	r2,-168(fp)
 400a80c:	1000090e 	bge	r2,zero,400a834 <_dtoa_r+0xc8>
    {
      /* set sign for everything, including 0's and NaNs */
      *sign = 1;
 400a810:	e0800417 	ldw	r2,16(fp)
 400a814:	00c00044 	movi	r3,1
 400a818:	10c00015 	stw	r3,0(r2)
      word0 (d) &= ~Sign_bit;	/* clear sign bit */
 400a81c:	e0ffd617 	ldw	r3,-168(fp)
 400a820:	00a00034 	movhi	r2,32768
 400a824:	10bfffc4 	addi	r2,r2,-1
 400a828:	1884703a 	and	r2,r3,r2
 400a82c:	e0bfd615 	stw	r2,-168(fp)
 400a830:	00000206 	br	400a83c <_dtoa_r+0xd0>
    }
  else
    *sign = 0;
 400a834:	e0800417 	ldw	r2,16(fp)
 400a838:	10000015 	stw	zero,0(r2)

#if defined(IEEE_Arith) + defined(VAX)
#ifdef IEEE_Arith
  if ((word0 (d) & Exp_mask) == Exp_mask)
 400a83c:	e0bfd617 	ldw	r2,-168(fp)
 400a840:	10dffc2c 	andhi	r3,r2,32752
 400a844:	009ffc34 	movhi	r2,32752
 400a848:	1880221e 	bne	r3,r2,400a8d4 <_dtoa_r+0x168>
#else
  if (word0 (d) == 0x8000)
#endif
    {
      /* Infinity or NaN */
      *decpt = 9999;
 400a84c:	e0800317 	ldw	r2,12(fp)
 400a850:	00c9c3c4 	movi	r3,9999
 400a854:	10c00015 	stw	r3,0(r2)
      s =
#ifdef IEEE_Arith
	!word1 (d) && !(word0 (d) & 0xfffff) ? "Infinity" :
 400a858:	e0bfd517 	ldw	r2,-172(fp)
 400a85c:	1000081e 	bne	r2,zero,400a880 <_dtoa_r+0x114>
 400a860:	e0ffd617 	ldw	r3,-168(fp)
 400a864:	00800434 	movhi	r2,16
 400a868:	10bfffc4 	addi	r2,r2,-1
 400a86c:	1884703a 	and	r2,r3,r2
 400a870:	1000031e 	bne	r2,zero,400a880 <_dtoa_r+0x114>
 400a874:	008100b4 	movhi	r2,1026
 400a878:	10ab2404 	addi	r2,r2,-21360
 400a87c:	00000206 	br	400a888 <_dtoa_r+0x11c>
 400a880:	008100b4 	movhi	r2,1026
 400a884:	10ab2704 	addi	r2,r2,-21348
      s =
 400a888:	e0bfe315 	stw	r2,-116(fp)
#endif
	"NaN";
      if (rve)
 400a88c:	e0800517 	ldw	r2,20(fp)
 400a890:	10000e26 	beq	r2,zero,400a8cc <_dtoa_r+0x160>
	*rve =
#ifdef IEEE_Arith
	  s[3] ? s + 8 :
 400a894:	e0bfe317 	ldw	r2,-116(fp)
 400a898:	108000c4 	addi	r2,r2,3
 400a89c:	10800003 	ldbu	r2,0(r2)
 400a8a0:	10803fcc 	andi	r2,r2,255
 400a8a4:	1080201c 	xori	r2,r2,128
 400a8a8:	10bfe004 	addi	r2,r2,-128
 400a8ac:	10000326 	beq	r2,zero,400a8bc <_dtoa_r+0x150>
 400a8b0:	e0bfe317 	ldw	r2,-116(fp)
 400a8b4:	10800204 	addi	r2,r2,8
 400a8b8:	00000206 	br	400a8c4 <_dtoa_r+0x158>
 400a8bc:	e0bfe317 	ldw	r2,-116(fp)
 400a8c0:	108000c4 	addi	r2,r2,3
	*rve =
 400a8c4:	e0c00517 	ldw	r3,20(fp)
 400a8c8:	18800015 	stw	r2,0(r3)
#endif
	  s + 3;
      return s;
 400a8cc:	e0bfe317 	ldw	r2,-116(fp)
 400a8d0:	0006a806 	br	400c374 <_dtoa_r+0x1c08>
    }
#endif
#ifdef IBM
  d.d += 0;			/* normalize */
#endif
  if (!d.d)
 400a8d4:	e0bfd517 	ldw	r2,-172(fp)
 400a8d8:	e0ffd617 	ldw	r3,-168(fp)
 400a8dc:	000d883a 	mov	r6,zero
 400a8e0:	000f883a 	mov	r7,zero
 400a8e4:	1009883a 	mov	r4,r2
 400a8e8:	180b883a 	mov	r5,r3
 400a8ec:	40168040 	call	4016804 <__eqdf2>
 400a8f0:	10000e1e 	bne	r2,zero,400a92c <_dtoa_r+0x1c0>
    {
      *decpt = 1;
 400a8f4:	e0800317 	ldw	r2,12(fp)
 400a8f8:	00c00044 	movi	r3,1
 400a8fc:	10c00015 	stw	r3,0(r2)
      s = "0";
 400a900:	008100b4 	movhi	r2,1026
 400a904:	10ab2804 	addi	r2,r2,-21344
 400a908:	e0bfe315 	stw	r2,-116(fp)
      if (rve)
 400a90c:	e0800517 	ldw	r2,20(fp)
 400a910:	10000426 	beq	r2,zero,400a924 <_dtoa_r+0x1b8>
	*rve = s + 1;
 400a914:	e0bfe317 	ldw	r2,-116(fp)
 400a918:	10c00044 	addi	r3,r2,1
 400a91c:	e0800517 	ldw	r2,20(fp)
 400a920:	10c00015 	stw	r3,0(r2)
      return s;
 400a924:	e0bfe317 	ldw	r2,-116(fp)
 400a928:	00069206 	br	400c374 <_dtoa_r+0x1c08>
    }

  b = d2b (ptr, d.d, &be, &bbits);
 400a92c:	e0bfd517 	ldw	r2,-172(fp)
 400a930:	e0ffd617 	ldw	r3,-168(fp)
 400a934:	e17fd704 	addi	r5,fp,-164
 400a938:	e13fd804 	addi	r4,fp,-160
 400a93c:	d9000015 	stw	r4,0(sp)
 400a940:	280f883a 	mov	r7,r5
 400a944:	100b883a 	mov	r5,r2
 400a948:	180d883a 	mov	r6,r3
 400a94c:	e13fd017 	ldw	r4,-192(fp)
 400a950:	4010b100 	call	4010b10 <__d2b>
 400a954:	e0bfe915 	stw	r2,-92(fp)
#ifdef Sudden_Underflow
  i = (int) (word0 (d) >> Exp_shift1 & (Exp_mask >> Exp_shift1));
#else
  if ((i = (int) (word0 (d) >> Exp_shift1 & (Exp_mask >> Exp_shift1))) != 0)
 400a958:	e0bfd617 	ldw	r2,-168(fp)
 400a95c:	1004d53a 	srli	r2,r2,20
 400a960:	1081ffcc 	andi	r2,r2,2047
 400a964:	e0bff815 	stw	r2,-32(fp)
 400a968:	e0bff817 	ldw	r2,-32(fp)
 400a96c:	10001126 	beq	r2,zero,400a9b4 <_dtoa_r+0x248>
    {
#endif
      d2.d = d.d;
 400a970:	e0bfd517 	ldw	r2,-172(fp)
 400a974:	e0ffd617 	ldw	r3,-168(fp)
 400a978:	e0bfd315 	stw	r2,-180(fp)
 400a97c:	e0ffd415 	stw	r3,-176(fp)
      word0 (d2) &= Frac_mask1;
 400a980:	e0ffd417 	ldw	r3,-176(fp)
 400a984:	00800434 	movhi	r2,16
 400a988:	10bfffc4 	addi	r2,r2,-1
 400a98c:	1884703a 	and	r2,r3,r2
 400a990:	e0bfd415 	stw	r2,-176(fp)
      word0 (d2) |= Exp_11;
 400a994:	e0bfd417 	ldw	r2,-176(fp)
 400a998:	108ffc34 	orhi	r2,r2,16368
 400a99c:	e0bfd415 	stw	r2,-176(fp)
		 * Hence we adjust the constant term to 0.1760912590558.
		 * (We could get a more accurate k by invoking log10,
		 *  but this is probably not worthwhile.)
		 */

      i -= Bias;
 400a9a0:	e0bff817 	ldw	r2,-32(fp)
 400a9a4:	10bf0044 	addi	r2,r2,-1023
 400a9a8:	e0bff815 	stw	r2,-32(fp)
#ifdef IBM
      i <<= 2;
      i += j;
#endif
#ifndef Sudden_Underflow
      denorm = 0;
 400a9ac:	e03fea15 	stw	zero,-88(fp)
 400a9b0:	00002806 	br	400aa54 <_dtoa_r+0x2e8>
    }
  else
    {
      /* d is denormalized */

      i = bbits + be + (Bias + (P - 1) - 1);
 400a9b4:	e0ffd817 	ldw	r3,-160(fp)
 400a9b8:	e0bfd717 	ldw	r2,-164(fp)
 400a9bc:	1885883a 	add	r2,r3,r2
 400a9c0:	10810c84 	addi	r2,r2,1074
 400a9c4:	e0bff815 	stw	r2,-32(fp)
#if defined (_DOUBLE_IS_32BITS)
      x = word0 (d) << (32 - i);
#else
      x = (i > 32) ? (word0 (d) << (64 - i)) | (word1 (d) >> (i - 32))
       : (word1 (d) << (32 - i));
 400a9c8:	e0bff817 	ldw	r2,-32(fp)
 400a9cc:	10800850 	cmplti	r2,r2,33
 400a9d0:	10000b1e 	bne	r2,zero,400aa00 <_dtoa_r+0x294>
      x = (i > 32) ? (word0 (d) << (64 - i)) | (word1 (d) >> (i - 32))
 400a9d4:	e0ffd617 	ldw	r3,-168(fp)
 400a9d8:	01001004 	movi	r4,64
 400a9dc:	e0bff817 	ldw	r2,-32(fp)
 400a9e0:	2085c83a 	sub	r2,r4,r2
 400a9e4:	1886983a 	sll	r3,r3,r2
 400a9e8:	e13fd517 	ldw	r4,-172(fp)
 400a9ec:	e0bff817 	ldw	r2,-32(fp)
 400a9f0:	10bff804 	addi	r2,r2,-32
 400a9f4:	2084d83a 	srl	r2,r4,r2
       : (word1 (d) << (32 - i));
 400a9f8:	1884b03a 	or	r2,r3,r2
 400a9fc:	00000506 	br	400aa14 <_dtoa_r+0x2a8>
 400aa00:	e0ffd517 	ldw	r3,-172(fp)
 400aa04:	01000804 	movi	r4,32
 400aa08:	e0bff817 	ldw	r2,-32(fp)
 400aa0c:	2085c83a 	sub	r2,r4,r2
 400aa10:	1884983a 	sll	r2,r3,r2
      x = (i > 32) ? (word0 (d) << (64 - i)) | (word1 (d) >> (i - 32))
 400aa14:	e0bfe215 	stw	r2,-120(fp)
#endif
      d2.d = x;
 400aa18:	e13fe217 	ldw	r4,-120(fp)
 400aa1c:	4017cd00 	call	4017cd0 <__floatunsidf>
 400aa20:	1009883a 	mov	r4,r2
 400aa24:	180b883a 	mov	r5,r3
 400aa28:	e13fd315 	stw	r4,-180(fp)
 400aa2c:	e17fd415 	stw	r5,-176(fp)
      word0 (d2) -= 31 * Exp_msk1;	/* adjust exponent */
 400aa30:	e0ffd417 	ldw	r3,-176(fp)
 400aa34:	00bf8434 	movhi	r2,65040
 400aa38:	1885883a 	add	r2,r3,r2
 400aa3c:	e0bfd415 	stw	r2,-176(fp)
      i -= (Bias + (P - 1) - 1) + 1;
 400aa40:	e0bff817 	ldw	r2,-32(fp)
 400aa44:	10bef344 	addi	r2,r2,-1075
 400aa48:	e0bff815 	stw	r2,-32(fp)
      denorm = 1;
 400aa4c:	00800044 	movi	r2,1
 400aa50:	e0bfea15 	stw	r2,-88(fp)
    }
#endif
#if defined (_DOUBLE_IS_32BITS)
  ds = (d2.d - 1.5) * 0.289529651 + 0.176091269 + i * 0.30103001;
#else
  ds = (d2.d - 1.5) * 0.289529654602168 + 0.1760912590558 + i * 0.301029995663981;
 400aa54:	e0bfd317 	ldw	r2,-180(fp)
 400aa58:	e0ffd417 	ldw	r3,-176(fp)
 400aa5c:	000d883a 	mov	r6,zero
 400aa60:	01cffe34 	movhi	r7,16376
 400aa64:	1009883a 	mov	r4,r2
 400aa68:	180b883a 	mov	r5,r3
 400aa6c:	401720c0 	call	401720c <__subdf3>
 400aa70:	1009883a 	mov	r4,r2
 400aa74:	180b883a 	mov	r5,r3
 400aa78:	2005883a 	mov	r2,r4
 400aa7c:	2807883a 	mov	r3,r5
 400aa80:	0198dbf4 	movhi	r6,25455
 400aa84:	3190d844 	addi	r6,r6,17249
 400aa88:	01cff4f4 	movhi	r7,16339
 400aa8c:	39e1e9c4 	addi	r7,r7,-30809
 400aa90:	1009883a 	mov	r4,r2
 400aa94:	180b883a 	mov	r5,r3
 400aa98:	4016a640 	call	4016a64 <__muldf3>
 400aa9c:	1009883a 	mov	r4,r2
 400aaa0:	180b883a 	mov	r5,r3
 400aaa4:	2005883a 	mov	r2,r4
 400aaa8:	2807883a 	mov	r3,r5
 400aaac:	01a2d874 	movhi	r6,35681
 400aab0:	31b22cc4 	addi	r6,r6,-14157
 400aab4:	01cff1f4 	movhi	r7,16327
 400aab8:	39e28a04 	addi	r7,r7,-30168
 400aabc:	1009883a 	mov	r4,r2
 400aac0:	180b883a 	mov	r5,r3
 400aac4:	40155580 	call	4015558 <__adddf3>
 400aac8:	1009883a 	mov	r4,r2
 400aacc:	180b883a 	mov	r5,r3
 400aad0:	2025883a 	mov	r18,r4
 400aad4:	2827883a 	mov	r19,r5
 400aad8:	e13ff817 	ldw	r4,-32(fp)
 400aadc:	4017c140 	call	4017c14 <__floatsidf>
 400aae0:	1011883a 	mov	r8,r2
 400aae4:	1813883a 	mov	r9,r3
 400aae8:	019427f4 	movhi	r6,20639
 400aaec:	319e7ec4 	addi	r6,r6,31227
 400aaf0:	01cff4f4 	movhi	r7,16339
 400aaf4:	39d104c4 	addi	r7,r7,17427
 400aaf8:	4009883a 	mov	r4,r8
 400aafc:	480b883a 	mov	r5,r9
 400ab00:	4016a640 	call	4016a64 <__muldf3>
 400ab04:	1009883a 	mov	r4,r2
 400ab08:	180b883a 	mov	r5,r3
 400ab0c:	2005883a 	mov	r2,r4
 400ab10:	2807883a 	mov	r3,r5
 400ab14:	100d883a 	mov	r6,r2
 400ab18:	180f883a 	mov	r7,r3
 400ab1c:	9009883a 	mov	r4,r18
 400ab20:	980b883a 	mov	r5,r19
 400ab24:	40155580 	call	4015558 <__adddf3>
 400ab28:	1009883a 	mov	r4,r2
 400ab2c:	180b883a 	mov	r5,r3
 400ab30:	e13fe415 	stw	r4,-112(fp)
 400ab34:	e17fe515 	stw	r5,-108(fp)
#endif
  k = (int) ds;
 400ab38:	e13fe417 	ldw	r4,-112(fp)
 400ab3c:	e17fe517 	ldw	r5,-108(fp)
 400ab40:	4017b940 	call	4017b94 <__fixdfsi>
 400ab44:	e0bff315 	stw	r2,-52(fp)
  if (ds < 0. && ds != k)
 400ab48:	000d883a 	mov	r6,zero
 400ab4c:	000f883a 	mov	r7,zero
 400ab50:	e13fe417 	ldw	r4,-112(fp)
 400ab54:	e17fe517 	ldw	r5,-108(fp)
 400ab58:	40169740 	call	4016974 <__ledf2>
 400ab5c:	10000d0e 	bge	r2,zero,400ab94 <_dtoa_r+0x428>
 400ab60:	e13ff317 	ldw	r4,-52(fp)
 400ab64:	4017c140 	call	4017c14 <__floatsidf>
 400ab68:	1009883a 	mov	r4,r2
 400ab6c:	180b883a 	mov	r5,r3
 400ab70:	200d883a 	mov	r6,r4
 400ab74:	280f883a 	mov	r7,r5
 400ab78:	e13fe417 	ldw	r4,-112(fp)
 400ab7c:	e17fe517 	ldw	r5,-108(fp)
 400ab80:	40168040 	call	4016804 <__eqdf2>
 400ab84:	10000326 	beq	r2,zero,400ab94 <_dtoa_r+0x428>
    k--;			/* want k = floor(ds) */
 400ab88:	e0bff317 	ldw	r2,-52(fp)
 400ab8c:	10bfffc4 	addi	r2,r2,-1
 400ab90:	e0bff315 	stw	r2,-52(fp)
  k_check = 1;
 400ab94:	00800044 	movi	r2,1
 400ab98:	e0bff215 	stw	r2,-56(fp)
  if (k >= 0 && k <= Ten_pmax)
 400ab9c:	e0bff317 	ldw	r2,-52(fp)
 400aba0:	10001716 	blt	r2,zero,400ac00 <_dtoa_r+0x494>
 400aba4:	e0bff317 	ldw	r2,-52(fp)
 400aba8:	108005c8 	cmpgei	r2,r2,23
 400abac:	1000141e 	bne	r2,zero,400ac00 <_dtoa_r+0x494>
    {
      if (d.d < tens[k])
 400abb0:	e0bfd517 	ldw	r2,-172(fp)
 400abb4:	e0ffd617 	ldw	r3,-168(fp)
 400abb8:	e13ff317 	ldw	r4,-52(fp)
 400abbc:	200e90fa 	slli	r7,r4,3
 400abc0:	018100b4 	movhi	r6,1026
 400abc4:	398d883a 	add	r6,r7,r6
 400abc8:	312b6617 	ldw	r4,-21096(r6)
 400abcc:	018100b4 	movhi	r6,1026
 400abd0:	398d883a 	add	r6,r7,r6
 400abd4:	316b6717 	ldw	r5,-21092(r6)
 400abd8:	200d883a 	mov	r6,r4
 400abdc:	280f883a 	mov	r7,r5
 400abe0:	1009883a 	mov	r4,r2
 400abe4:	180b883a 	mov	r5,r3
 400abe8:	40169740 	call	4016974 <__ledf2>
 400abec:	1000030e 	bge	r2,zero,400abfc <_dtoa_r+0x490>
	k--;
 400abf0:	e0bff317 	ldw	r2,-52(fp)
 400abf4:	10bfffc4 	addi	r2,r2,-1
 400abf8:	e0bff315 	stw	r2,-52(fp)
      k_check = 0;
 400abfc:	e03ff215 	stw	zero,-56(fp)
    }
  j = bbits - i - 1;
 400ac00:	e0ffd817 	ldw	r3,-160(fp)
 400ac04:	e0bff817 	ldw	r2,-32(fp)
 400ac08:	1885c83a 	sub	r2,r3,r2
 400ac0c:	10bfffc4 	addi	r2,r2,-1
 400ac10:	e0bff415 	stw	r2,-48(fp)
  if (j >= 0)
 400ac14:	e0bff417 	ldw	r2,-48(fp)
 400ac18:	10000416 	blt	r2,zero,400ac2c <_dtoa_r+0x4c0>
    {
      b2 = 0;
 400ac1c:	e03ffb15 	stw	zero,-20(fp)
      s2 = j;
 400ac20:	e0bff417 	ldw	r2,-48(fp)
 400ac24:	e0bfee15 	stw	r2,-72(fp)
 400ac28:	00000406 	br	400ac3c <_dtoa_r+0x4d0>
    }
  else
    {
      b2 = -j;
 400ac2c:	e0bff417 	ldw	r2,-48(fp)
 400ac30:	0085c83a 	sub	r2,zero,r2
 400ac34:	e0bffb15 	stw	r2,-20(fp)
      s2 = 0;
 400ac38:	e03fee15 	stw	zero,-72(fp)
    }
  if (k >= 0)
 400ac3c:	e0bff317 	ldw	r2,-52(fp)
 400ac40:	10000816 	blt	r2,zero,400ac64 <_dtoa_r+0x4f8>
    {
      b5 = 0;
 400ac44:	e03ffa15 	stw	zero,-24(fp)
      s5 = k;
 400ac48:	e0bff317 	ldw	r2,-52(fp)
 400ac4c:	e0bfed15 	stw	r2,-76(fp)
      s2 += k;
 400ac50:	e0ffee17 	ldw	r3,-72(fp)
 400ac54:	e0bff317 	ldw	r2,-52(fp)
 400ac58:	1885883a 	add	r2,r3,r2
 400ac5c:	e0bfee15 	stw	r2,-72(fp)
 400ac60:	00000806 	br	400ac84 <_dtoa_r+0x518>
    }
  else
    {
      b2 -= k;
 400ac64:	e0fffb17 	ldw	r3,-20(fp)
 400ac68:	e0bff317 	ldw	r2,-52(fp)
 400ac6c:	1885c83a 	sub	r2,r3,r2
 400ac70:	e0bffb15 	stw	r2,-20(fp)
      b5 = -k;
 400ac74:	e0bff317 	ldw	r2,-52(fp)
 400ac78:	0085c83a 	sub	r2,zero,r2
 400ac7c:	e0bffa15 	stw	r2,-24(fp)
      s5 = 0;
 400ac80:	e03fed15 	stw	zero,-76(fp)
    }
  if (mode < 0 || mode > 9)
 400ac84:	e0bfcd17 	ldw	r2,-204(fp)
 400ac88:	10000316 	blt	r2,zero,400ac98 <_dtoa_r+0x52c>
 400ac8c:	e0bfcd17 	ldw	r2,-204(fp)
 400ac90:	10800290 	cmplti	r2,r2,10
 400ac94:	1000011e 	bne	r2,zero,400ac9c <_dtoa_r+0x530>
    mode = 0;
 400ac98:	e03fcd15 	stw	zero,-204(fp)
  try_quick = 1;
 400ac9c:	00800044 	movi	r2,1
 400aca0:	e0bfeb15 	stw	r2,-84(fp)
  if (mode > 5)
 400aca4:	e0bfcd17 	ldw	r2,-204(fp)
 400aca8:	10800190 	cmplti	r2,r2,6
 400acac:	1000041e 	bne	r2,zero,400acc0 <_dtoa_r+0x554>
    {
      mode -= 4;
 400acb0:	e0bfcd17 	ldw	r2,-204(fp)
 400acb4:	10bfff04 	addi	r2,r2,-4
 400acb8:	e0bfcd15 	stw	r2,-204(fp)
      try_quick = 0;
 400acbc:	e03feb15 	stw	zero,-84(fp)
    }
  leftright = 1;
 400acc0:	00800044 	movi	r2,1
 400acc4:	e0bff115 	stw	r2,-60(fp)
  ilim = ilim1 = -1;
 400acc8:	00bfffc4 	movi	r2,-1
 400accc:	e0bff515 	stw	r2,-44(fp)
 400acd0:	e0bff517 	ldw	r2,-44(fp)
 400acd4:	e0bff615 	stw	r2,-40(fp)
 400acd8:	e0bfcd17 	ldw	r2,-204(fp)
 400acdc:	108001a8 	cmpgeui	r2,r2,6
 400ace0:	10002b1e 	bne	r2,zero,400ad90 <_dtoa_r+0x624>
 400ace4:	e0bfcd17 	ldw	r2,-204(fp)
 400ace8:	100690ba 	slli	r3,r2,2
 400acec:	00810074 	movhi	r2,1025
 400acf0:	1885883a 	add	r2,r3,r2
 400acf4:	10ab3f17 	ldw	r2,-21252(r2)
 400acf8:	1000683a 	jmp	r2
 400acfc:	0400ad14 	movui	r16,692
 400ad00:	0400ad14 	movui	r16,692
 400ad04:	0400ad24 	muli	r16,zero,692
 400ad08:	0400ad54 	movui	r16,693
 400ad0c:	0400ad28 	cmpgeui	r16,zero,692
 400ad10:	0400ad58 	cmpnei	r16,zero,693
  switch (mode)
    {
    case 0:
    case 1:
      i = 18;
 400ad14:	00800484 	movi	r2,18
 400ad18:	e0bff815 	stw	r2,-32(fp)
      ndigits = 0;
 400ad1c:	e0000215 	stw	zero,8(fp)
      break;
 400ad20:	00001b06 	br	400ad90 <_dtoa_r+0x624>
    case 2:
      leftright = 0;
 400ad24:	e03ff115 	stw	zero,-60(fp)
      /* no break */
    case 4:
      if (ndigits <= 0)
 400ad28:	e0800217 	ldw	r2,8(fp)
 400ad2c:	00800216 	blt	zero,r2,400ad38 <_dtoa_r+0x5cc>
	ndigits = 1;
 400ad30:	00800044 	movi	r2,1
 400ad34:	e0800215 	stw	r2,8(fp)
      ilim = ilim1 = i = ndigits;
 400ad38:	e0800217 	ldw	r2,8(fp)
 400ad3c:	e0bff815 	stw	r2,-32(fp)
 400ad40:	e0bff817 	ldw	r2,-32(fp)
 400ad44:	e0bff515 	stw	r2,-44(fp)
 400ad48:	e0bff517 	ldw	r2,-44(fp)
 400ad4c:	e0bff615 	stw	r2,-40(fp)
      break;
 400ad50:	00000f06 	br	400ad90 <_dtoa_r+0x624>
    case 3:
      leftright = 0;
 400ad54:	e03ff115 	stw	zero,-60(fp)
      /* no break */
    case 5:
      i = ndigits + k + 1;
 400ad58:	e0c00217 	ldw	r3,8(fp)
 400ad5c:	e0bff317 	ldw	r2,-52(fp)
 400ad60:	1885883a 	add	r2,r3,r2
 400ad64:	10800044 	addi	r2,r2,1
 400ad68:	e0bff815 	stw	r2,-32(fp)
      ilim = i;
 400ad6c:	e0bff817 	ldw	r2,-32(fp)
 400ad70:	e0bff615 	stw	r2,-40(fp)
      ilim1 = i - 1;
 400ad74:	e0bff817 	ldw	r2,-32(fp)
 400ad78:	10bfffc4 	addi	r2,r2,-1
 400ad7c:	e0bff515 	stw	r2,-44(fp)
      if (i <= 0)
 400ad80:	e0bff817 	ldw	r2,-32(fp)
 400ad84:	00800216 	blt	zero,r2,400ad90 <_dtoa_r+0x624>
	i = 1;
 400ad88:	00800044 	movi	r2,1
 400ad8c:	e0bff815 	stw	r2,-32(fp)
    }
  j = sizeof (__ULong);
 400ad90:	00800104 	movi	r2,4
 400ad94:	e0bff415 	stw	r2,-48(fp)
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
 400ad98:	e0bfd017 	ldw	r2,-192(fp)
 400ad9c:	10001115 	stw	zero,68(r2)
 400ada0:	00000806 	br	400adc4 <_dtoa_r+0x658>
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
 400ada4:	e0bfd017 	ldw	r2,-192(fp)
 400ada8:	10801117 	ldw	r2,68(r2)
 400adac:	10c00044 	addi	r3,r2,1
 400adb0:	e0bfd017 	ldw	r2,-192(fp)
 400adb4:	10c01115 	stw	r3,68(r2)
       j <<= 1)
 400adb8:	e0bff417 	ldw	r2,-48(fp)
 400adbc:	1085883a 	add	r2,r2,r2
 400adc0:	e0bff415 	stw	r2,-48(fp)
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
 400adc4:	e0bff417 	ldw	r2,-48(fp)
 400adc8:	10800504 	addi	r2,r2,20
 400adcc:	e0fff817 	ldw	r3,-32(fp)
 400add0:	18bff42e 	bgeu	r3,r2,400ada4 <_dtoa_r+0x638>
  _REENT_MP_RESULT(ptr) = eBalloc (ptr, _REENT_MP_RESULT_K(ptr));
 400add4:	e0bfd017 	ldw	r2,-192(fp)
 400add8:	10801117 	ldw	r2,68(r2)
 400addc:	100b883a 	mov	r5,r2
 400ade0:	e13fd017 	ldw	r4,-192(fp)
 400ade4:	400f5b40 	call	400f5b4 <_Balloc>
 400ade8:	e0bfe115 	stw	r2,-124(fp)
 400adec:	e0bfe117 	ldw	r2,-124(fp)
 400adf0:	1000071e 	bne	r2,zero,400ae10 <_dtoa_r+0x6a4>
 400adf4:	01c100b4 	movhi	r7,1026
 400adf8:	39eb2904 	addi	r7,r7,-21340
 400adfc:	000d883a 	mov	r6,zero
 400ae00:	01406a84 	movi	r5,426
 400ae04:	010100b4 	movhi	r4,1026
 400ae08:	212b2e04 	addi	r4,r4,-21320
 400ae0c:	40138480 	call	4013848 <__assert_func>
 400ae10:	e0ffe117 	ldw	r3,-124(fp)
 400ae14:	e0bfd017 	ldw	r2,-192(fp)
 400ae18:	10c01015 	stw	r3,64(r2)
  s = s0 = (char *) _REENT_MP_RESULT(ptr);
 400ae1c:	e0bfd017 	ldw	r2,-192(fp)
 400ae20:	10801017 	ldw	r2,64(r2)
 400ae24:	e0bfe015 	stw	r2,-128(fp)
 400ae28:	e0bfe017 	ldw	r2,-128(fp)
 400ae2c:	e0bfe315 	stw	r2,-116(fp)

  if (ilim >= 0 && ilim <= Quick_max && try_quick)
 400ae30:	e0bff617 	ldw	r2,-40(fp)
 400ae34:	10022016 	blt	r2,zero,400b6b8 <_dtoa_r+0xf4c>
 400ae38:	e0bff617 	ldw	r2,-40(fp)
 400ae3c:	108003c8 	cmpgei	r2,r2,15
 400ae40:	10021d1e 	bne	r2,zero,400b6b8 <_dtoa_r+0xf4c>
 400ae44:	e0bfeb17 	ldw	r2,-84(fp)
 400ae48:	10021b26 	beq	r2,zero,400b6b8 <_dtoa_r+0xf4c>
    {
      /* Try to get by with floating-point arithmetic. */

      i = 0;
 400ae4c:	e03ff815 	stw	zero,-32(fp)
      d2.d = d.d;
 400ae50:	e0bfd517 	ldw	r2,-172(fp)
 400ae54:	e0ffd617 	ldw	r3,-168(fp)
 400ae58:	e0bfd315 	stw	r2,-180(fp)
 400ae5c:	e0ffd415 	stw	r3,-176(fp)
      k0 = k;
 400ae60:	e0bff317 	ldw	r2,-52(fp)
 400ae64:	e0bfdf15 	stw	r2,-132(fp)
      ilim0 = ilim;
 400ae68:	e0bff617 	ldw	r2,-40(fp)
 400ae6c:	e0bfde15 	stw	r2,-136(fp)
      ieps = 2;			/* conservative */
 400ae70:	00800084 	movi	r2,2
 400ae74:	e0bff715 	stw	r2,-36(fp)
      if (k > 0)
 400ae78:	e0bff317 	ldw	r2,-52(fp)
 400ae7c:	0080560e 	bge	zero,r2,400afd8 <_dtoa_r+0x86c>
	{
	  ds = tens[k & 0xf];
 400ae80:	e0bff317 	ldw	r2,-52(fp)
 400ae84:	108003cc 	andi	r2,r2,15
 400ae88:	100690fa 	slli	r3,r2,3
 400ae8c:	008100b4 	movhi	r2,1026
 400ae90:	1885883a 	add	r2,r3,r2
 400ae94:	10ab6617 	ldw	r2,-21096(r2)
 400ae98:	e0bfe415 	stw	r2,-112(fp)
 400ae9c:	008100b4 	movhi	r2,1026
 400aea0:	1885883a 	add	r2,r3,r2
 400aea4:	10ab6717 	ldw	r2,-21092(r2)
 400aea8:	e0bfe515 	stw	r2,-108(fp)
	  j = k >> 4;
 400aeac:	e0bff317 	ldw	r2,-52(fp)
 400aeb0:	1005d13a 	srai	r2,r2,4
 400aeb4:	e0bff415 	stw	r2,-48(fp)
	  if (j & Bletch)
 400aeb8:	e0bff417 	ldw	r2,-48(fp)
 400aebc:	1080040c 	andi	r2,r2,16
 400aec0:	10003526 	beq	r2,zero,400af98 <_dtoa_r+0x82c>
	    {
	      /* prevent overflows */
	      j &= Bletch - 1;
 400aec4:	e0bff417 	ldw	r2,-48(fp)
 400aec8:	108003cc 	andi	r2,r2,15
 400aecc:	e0bff415 	stw	r2,-48(fp)
	      d.d /= bigtens[n_bigtens - 1];
 400aed0:	e0bfd517 	ldw	r2,-172(fp)
 400aed4:	e0ffd617 	ldw	r3,-168(fp)
 400aed8:	018100b4 	movhi	r6,1026
 400aedc:	312ba017 	ldw	r4,-20864(r6)
 400aee0:	018100b4 	movhi	r6,1026
 400aee4:	316ba117 	ldw	r5,-20860(r6)
 400aee8:	200d883a 	mov	r6,r4
 400aeec:	280f883a 	mov	r7,r5
 400aef0:	1009883a 	mov	r4,r2
 400aef4:	180b883a 	mov	r5,r3
 400aef8:	4015ed00 	call	4015ed0 <__divdf3>
 400aefc:	1009883a 	mov	r4,r2
 400af00:	180b883a 	mov	r5,r3
 400af04:	2005883a 	mov	r2,r4
 400af08:	2807883a 	mov	r3,r5
 400af0c:	e0bfd515 	stw	r2,-172(fp)
 400af10:	e0ffd615 	stw	r3,-168(fp)
	      ieps++;
 400af14:	e0bff717 	ldw	r2,-36(fp)
 400af18:	10800044 	addi	r2,r2,1
 400af1c:	e0bff715 	stw	r2,-36(fp)
	    }
	  for (; j; j >>= 1, i++)
 400af20:	00001d06 	br	400af98 <_dtoa_r+0x82c>
	    if (j & 1)
 400af24:	e0bff417 	ldw	r2,-48(fp)
 400af28:	1080004c 	andi	r2,r2,1
 400af2c:	10001426 	beq	r2,zero,400af80 <_dtoa_r+0x814>
	      {
		ieps++;
 400af30:	e0bff717 	ldw	r2,-36(fp)
 400af34:	10800044 	addi	r2,r2,1
 400af38:	e0bff715 	stw	r2,-36(fp)
		ds *= bigtens[i];
 400af3c:	e0bff817 	ldw	r2,-32(fp)
 400af40:	100a90fa 	slli	r5,r2,3
 400af44:	010100b4 	movhi	r4,1026
 400af48:	2909883a 	add	r4,r5,r4
 400af4c:	20ab9817 	ldw	r2,-20896(r4)
 400af50:	010100b4 	movhi	r4,1026
 400af54:	2909883a 	add	r4,r5,r4
 400af58:	20eb9917 	ldw	r3,-20892(r4)
 400af5c:	100d883a 	mov	r6,r2
 400af60:	180f883a 	mov	r7,r3
 400af64:	e13fe417 	ldw	r4,-112(fp)
 400af68:	e17fe517 	ldw	r5,-108(fp)
 400af6c:	4016a640 	call	4016a64 <__muldf3>
 400af70:	1009883a 	mov	r4,r2
 400af74:	180b883a 	mov	r5,r3
 400af78:	e13fe415 	stw	r4,-112(fp)
 400af7c:	e17fe515 	stw	r5,-108(fp)
	  for (; j; j >>= 1, i++)
 400af80:	e0bff417 	ldw	r2,-48(fp)
 400af84:	1005d07a 	srai	r2,r2,1
 400af88:	e0bff415 	stw	r2,-48(fp)
 400af8c:	e0bff817 	ldw	r2,-32(fp)
 400af90:	10800044 	addi	r2,r2,1
 400af94:	e0bff815 	stw	r2,-32(fp)
 400af98:	e0bff417 	ldw	r2,-48(fp)
 400af9c:	103fe11e 	bne	r2,zero,400af24 <_dtoa_r+0x7b8>
	      }
	  d.d /= ds;
 400afa0:	e0bfd517 	ldw	r2,-172(fp)
 400afa4:	e0ffd617 	ldw	r3,-168(fp)
 400afa8:	e1bfe417 	ldw	r6,-112(fp)
 400afac:	e1ffe517 	ldw	r7,-108(fp)
 400afb0:	1009883a 	mov	r4,r2
 400afb4:	180b883a 	mov	r5,r3
 400afb8:	4015ed00 	call	4015ed0 <__divdf3>
 400afbc:	1009883a 	mov	r4,r2
 400afc0:	180b883a 	mov	r5,r3
 400afc4:	2005883a 	mov	r2,r4
 400afc8:	2807883a 	mov	r3,r5
 400afcc:	e0bfd515 	stw	r2,-172(fp)
 400afd0:	e0ffd615 	stw	r3,-168(fp)
 400afd4:	00004206 	br	400b0e0 <_dtoa_r+0x974>
	}
      else if ((j1 = -k) != 0)
 400afd8:	e0bff317 	ldw	r2,-52(fp)
 400afdc:	0085c83a 	sub	r2,zero,r2
 400afe0:	e0bfdd15 	stw	r2,-140(fp)
 400afe4:	e0bfdd17 	ldw	r2,-140(fp)
 400afe8:	10003d26 	beq	r2,zero,400b0e0 <_dtoa_r+0x974>
	{
	  d.d *= tens[j1 & 0xf];
 400afec:	e0bfd517 	ldw	r2,-172(fp)
 400aff0:	e0ffd617 	ldw	r3,-168(fp)
 400aff4:	e13fdd17 	ldw	r4,-140(fp)
 400aff8:	210003cc 	andi	r4,r4,15
 400affc:	200e90fa 	slli	r7,r4,3
 400b000:	018100b4 	movhi	r6,1026
 400b004:	398d883a 	add	r6,r7,r6
 400b008:	312b6617 	ldw	r4,-21096(r6)
 400b00c:	018100b4 	movhi	r6,1026
 400b010:	398d883a 	add	r6,r7,r6
 400b014:	316b6717 	ldw	r5,-21092(r6)
 400b018:	200d883a 	mov	r6,r4
 400b01c:	280f883a 	mov	r7,r5
 400b020:	1009883a 	mov	r4,r2
 400b024:	180b883a 	mov	r5,r3
 400b028:	4016a640 	call	4016a64 <__muldf3>
 400b02c:	1009883a 	mov	r4,r2
 400b030:	180b883a 	mov	r5,r3
 400b034:	2005883a 	mov	r2,r4
 400b038:	2807883a 	mov	r3,r5
 400b03c:	e0bfd515 	stw	r2,-172(fp)
 400b040:	e0ffd615 	stw	r3,-168(fp)
	  for (j = j1 >> 4; j; j >>= 1, i++)
 400b044:	e0bfdd17 	ldw	r2,-140(fp)
 400b048:	1005d13a 	srai	r2,r2,4
 400b04c:	e0bff415 	stw	r2,-48(fp)
 400b050:	00002106 	br	400b0d8 <_dtoa_r+0x96c>
	    if (j & 1)
 400b054:	e0bff417 	ldw	r2,-48(fp)
 400b058:	1080004c 	andi	r2,r2,1
 400b05c:	10001826 	beq	r2,zero,400b0c0 <_dtoa_r+0x954>
	      {
		ieps++;
 400b060:	e0bff717 	ldw	r2,-36(fp)
 400b064:	10800044 	addi	r2,r2,1
 400b068:	e0bff715 	stw	r2,-36(fp)
		d.d *= bigtens[i];
 400b06c:	e0bfd517 	ldw	r2,-172(fp)
 400b070:	e0ffd617 	ldw	r3,-168(fp)
 400b074:	e13ff817 	ldw	r4,-32(fp)
 400b078:	200e90fa 	slli	r7,r4,3
 400b07c:	018100b4 	movhi	r6,1026
 400b080:	398d883a 	add	r6,r7,r6
 400b084:	312b9817 	ldw	r4,-20896(r6)
 400b088:	018100b4 	movhi	r6,1026
 400b08c:	398d883a 	add	r6,r7,r6
 400b090:	316b9917 	ldw	r5,-20892(r6)
 400b094:	200d883a 	mov	r6,r4
 400b098:	280f883a 	mov	r7,r5
 400b09c:	1009883a 	mov	r4,r2
 400b0a0:	180b883a 	mov	r5,r3
 400b0a4:	4016a640 	call	4016a64 <__muldf3>
 400b0a8:	1009883a 	mov	r4,r2
 400b0ac:	180b883a 	mov	r5,r3
 400b0b0:	2005883a 	mov	r2,r4
 400b0b4:	2807883a 	mov	r3,r5
 400b0b8:	e0bfd515 	stw	r2,-172(fp)
 400b0bc:	e0ffd615 	stw	r3,-168(fp)
	  for (j = j1 >> 4; j; j >>= 1, i++)
 400b0c0:	e0bff417 	ldw	r2,-48(fp)
 400b0c4:	1005d07a 	srai	r2,r2,1
 400b0c8:	e0bff415 	stw	r2,-48(fp)
 400b0cc:	e0bff817 	ldw	r2,-32(fp)
 400b0d0:	10800044 	addi	r2,r2,1
 400b0d4:	e0bff815 	stw	r2,-32(fp)
 400b0d8:	e0bff417 	ldw	r2,-48(fp)
 400b0dc:	103fdd1e 	bne	r2,zero,400b054 <_dtoa_r+0x8e8>
	      }
	}
      if (k_check && d.d < 1. && ilim > 0)
 400b0e0:	e0bff217 	ldw	r2,-56(fp)
 400b0e4:	10002126 	beq	r2,zero,400b16c <_dtoa_r+0xa00>
 400b0e8:	e0bfd517 	ldw	r2,-172(fp)
 400b0ec:	e0ffd617 	ldw	r3,-168(fp)
 400b0f0:	000d883a 	mov	r6,zero
 400b0f4:	01cffc34 	movhi	r7,16368
 400b0f8:	1009883a 	mov	r4,r2
 400b0fc:	180b883a 	mov	r5,r3
 400b100:	40169740 	call	4016974 <__ledf2>
 400b104:	1000190e 	bge	r2,zero,400b16c <_dtoa_r+0xa00>
 400b108:	e0bff617 	ldw	r2,-40(fp)
 400b10c:	0080170e 	bge	zero,r2,400b16c <_dtoa_r+0xa00>
	{
	  if (ilim1 <= 0)
 400b110:	e0bff517 	ldw	r2,-44(fp)
 400b114:	00815b0e 	bge	zero,r2,400b684 <_dtoa_r+0xf18>
	    goto fast_failed;
	  ilim = ilim1;
 400b118:	e0bff517 	ldw	r2,-44(fp)
 400b11c:	e0bff615 	stw	r2,-40(fp)
	  k--;
 400b120:	e0bff317 	ldw	r2,-52(fp)
 400b124:	10bfffc4 	addi	r2,r2,-1
 400b128:	e0bff315 	stw	r2,-52(fp)
	  d.d *= 10.;
 400b12c:	e0bfd517 	ldw	r2,-172(fp)
 400b130:	e0ffd617 	ldw	r3,-168(fp)
 400b134:	000d883a 	mov	r6,zero
 400b138:	01d00934 	movhi	r7,16420
 400b13c:	1009883a 	mov	r4,r2
 400b140:	180b883a 	mov	r5,r3
 400b144:	4016a640 	call	4016a64 <__muldf3>
 400b148:	1009883a 	mov	r4,r2
 400b14c:	180b883a 	mov	r5,r3
 400b150:	2005883a 	mov	r2,r4
 400b154:	2807883a 	mov	r3,r5
 400b158:	e0bfd515 	stw	r2,-172(fp)
 400b15c:	e0ffd615 	stw	r3,-168(fp)
	  ieps++;
 400b160:	e0bff717 	ldw	r2,-36(fp)
 400b164:	10800044 	addi	r2,r2,1
 400b168:	e0bff715 	stw	r2,-36(fp)
	}
      eps.d = ieps * d.d + 7.;
 400b16c:	e13ff717 	ldw	r4,-36(fp)
 400b170:	4017c140 	call	4017c14 <__floatsidf>
 400b174:	1011883a 	mov	r8,r2
 400b178:	1813883a 	mov	r9,r3
 400b17c:	e0bfd517 	ldw	r2,-172(fp)
 400b180:	e0ffd617 	ldw	r3,-168(fp)
 400b184:	100d883a 	mov	r6,r2
 400b188:	180f883a 	mov	r7,r3
 400b18c:	4009883a 	mov	r4,r8
 400b190:	480b883a 	mov	r5,r9
 400b194:	4016a640 	call	4016a64 <__muldf3>
 400b198:	1009883a 	mov	r4,r2
 400b19c:	180b883a 	mov	r5,r3
 400b1a0:	2005883a 	mov	r2,r4
 400b1a4:	2807883a 	mov	r3,r5
 400b1a8:	000d883a 	mov	r6,zero
 400b1ac:	01d00734 	movhi	r7,16412
 400b1b0:	1009883a 	mov	r4,r2
 400b1b4:	180b883a 	mov	r5,r3
 400b1b8:	40155580 	call	4015558 <__adddf3>
 400b1bc:	1009883a 	mov	r4,r2
 400b1c0:	180b883a 	mov	r5,r3
 400b1c4:	2005883a 	mov	r2,r4
 400b1c8:	2807883a 	mov	r3,r5
 400b1cc:	e0bfd115 	stw	r2,-188(fp)
 400b1d0:	e0ffd215 	stw	r3,-184(fp)
      word0 (eps) -= (P - 1) * Exp_msk1;
 400b1d4:	e0ffd217 	ldw	r3,-184(fp)
 400b1d8:	00bf3034 	movhi	r2,64704
 400b1dc:	1885883a 	add	r2,r3,r2
 400b1e0:	e0bfd215 	stw	r2,-184(fp)
      if (ilim == 0)
 400b1e4:	e0bff617 	ldw	r2,-40(fp)
 400b1e8:	1000271e 	bne	r2,zero,400b288 <_dtoa_r+0xb1c>
	{
	  S = mhi = 0;
 400b1ec:	e03fe715 	stw	zero,-100(fp)
 400b1f0:	e0bfe717 	ldw	r2,-100(fp)
 400b1f4:	e0bfe615 	stw	r2,-104(fp)
	  d.d -= 5.;
 400b1f8:	e0bfd517 	ldw	r2,-172(fp)
 400b1fc:	e0ffd617 	ldw	r3,-168(fp)
 400b200:	000d883a 	mov	r6,zero
 400b204:	01d00534 	movhi	r7,16404
 400b208:	1009883a 	mov	r4,r2
 400b20c:	180b883a 	mov	r5,r3
 400b210:	401720c0 	call	401720c <__subdf3>
 400b214:	1009883a 	mov	r4,r2
 400b218:	180b883a 	mov	r5,r3
 400b21c:	2005883a 	mov	r2,r4
 400b220:	2807883a 	mov	r3,r5
 400b224:	e0bfd515 	stw	r2,-172(fp)
 400b228:	e0ffd615 	stw	r3,-168(fp)
	  if (d.d > eps.d)
 400b22c:	e0bfd517 	ldw	r2,-172(fp)
 400b230:	e0ffd617 	ldw	r3,-168(fp)
 400b234:	e13fd117 	ldw	r4,-188(fp)
 400b238:	e17fd217 	ldw	r5,-184(fp)
 400b23c:	200d883a 	mov	r6,r4
 400b240:	280f883a 	mov	r7,r5
 400b244:	1009883a 	mov	r4,r2
 400b248:	180b883a 	mov	r5,r3
 400b24c:	40168840 	call	4016884 <__gedf2>
 400b250:	0082f916 	blt	zero,r2,400be38 <_dtoa_r+0x16cc>
	    goto one_digit;
	  if (d.d < -eps.d)
 400b254:	e23fd517 	ldw	r8,-172(fp)
 400b258:	e27fd617 	ldw	r9,-168(fp)
 400b25c:	e0bfd117 	ldw	r2,-188(fp)
 400b260:	e0ffd217 	ldw	r3,-184(fp)
 400b264:	1021883a 	mov	r16,r2
 400b268:	1c60003c 	xorhi	r17,r3,32768
 400b26c:	800d883a 	mov	r6,r16
 400b270:	880f883a 	mov	r7,r17
 400b274:	4009883a 	mov	r4,r8
 400b278:	480b883a 	mov	r5,r9
 400b27c:	40169740 	call	4016974 <__ledf2>
 400b280:	1002e416 	blt	r2,zero,400be14 <_dtoa_r+0x16a8>
	    goto no_digits;
	  goto fast_failed;
 400b284:	00010206 	br	400b690 <_dtoa_r+0xf24>
	}
#ifndef No_leftright
      if (leftright)
 400b288:	e0bff117 	ldw	r2,-60(fp)
 400b28c:	10007d26 	beq	r2,zero,400b484 <_dtoa_r+0xd18>
	{
	  /* Use Steele & White method of only
	   * generating digits needed.
	   */
	  eps.d = 0.5 / tens[ilim - 1] - eps.d;
 400b290:	e0bff617 	ldw	r2,-40(fp)
 400b294:	10bfffc4 	addi	r2,r2,-1
 400b298:	100a90fa 	slli	r5,r2,3
 400b29c:	010100b4 	movhi	r4,1026
 400b2a0:	2909883a 	add	r4,r5,r4
 400b2a4:	20ab6617 	ldw	r2,-21096(r4)
 400b2a8:	010100b4 	movhi	r4,1026
 400b2ac:	2909883a 	add	r4,r5,r4
 400b2b0:	20eb6717 	ldw	r3,-21092(r4)
 400b2b4:	100d883a 	mov	r6,r2
 400b2b8:	180f883a 	mov	r7,r3
 400b2bc:	0009883a 	mov	r4,zero
 400b2c0:	014ff834 	movhi	r5,16352
 400b2c4:	4015ed00 	call	4015ed0 <__divdf3>
 400b2c8:	1009883a 	mov	r4,r2
 400b2cc:	180b883a 	mov	r5,r3
 400b2d0:	2011883a 	mov	r8,r4
 400b2d4:	2813883a 	mov	r9,r5
 400b2d8:	e0bfd117 	ldw	r2,-188(fp)
 400b2dc:	e0ffd217 	ldw	r3,-184(fp)
 400b2e0:	100d883a 	mov	r6,r2
 400b2e4:	180f883a 	mov	r7,r3
 400b2e8:	4009883a 	mov	r4,r8
 400b2ec:	480b883a 	mov	r5,r9
 400b2f0:	401720c0 	call	401720c <__subdf3>
 400b2f4:	1009883a 	mov	r4,r2
 400b2f8:	180b883a 	mov	r5,r3
 400b2fc:	2005883a 	mov	r2,r4
 400b300:	2807883a 	mov	r3,r5
 400b304:	e0bfd115 	stw	r2,-188(fp)
 400b308:	e0ffd215 	stw	r3,-184(fp)
	  for (i = 0;;)
 400b30c:	e03ff815 	stw	zero,-32(fp)
	    {
	      L = d.d;
 400b310:	e0bfd517 	ldw	r2,-172(fp)
 400b314:	e0ffd617 	ldw	r3,-168(fp)
 400b318:	1009883a 	mov	r4,r2
 400b31c:	180b883a 	mov	r5,r3
 400b320:	4017b940 	call	4017b94 <__fixdfsi>
 400b324:	e0bfdc15 	stw	r2,-144(fp)
	      d.d -= L;
 400b328:	e43fd517 	ldw	r16,-172(fp)
 400b32c:	e47fd617 	ldw	r17,-168(fp)
 400b330:	e13fdc17 	ldw	r4,-144(fp)
 400b334:	4017c140 	call	4017c14 <__floatsidf>
 400b338:	1009883a 	mov	r4,r2
 400b33c:	180b883a 	mov	r5,r3
 400b340:	200d883a 	mov	r6,r4
 400b344:	280f883a 	mov	r7,r5
 400b348:	8009883a 	mov	r4,r16
 400b34c:	880b883a 	mov	r5,r17
 400b350:	401720c0 	call	401720c <__subdf3>
 400b354:	1009883a 	mov	r4,r2
 400b358:	180b883a 	mov	r5,r3
 400b35c:	2005883a 	mov	r2,r4
 400b360:	2807883a 	mov	r3,r5
 400b364:	e0bfd515 	stw	r2,-172(fp)
 400b368:	e0ffd615 	stw	r3,-168(fp)
	      *s++ = '0' + (int) L;
 400b36c:	e0bfdc17 	ldw	r2,-144(fp)
 400b370:	10800c04 	addi	r2,r2,48
 400b374:	1009883a 	mov	r4,r2
 400b378:	e0bfe317 	ldw	r2,-116(fp)
 400b37c:	10c00044 	addi	r3,r2,1
 400b380:	e0ffe315 	stw	r3,-116(fp)
 400b384:	2007883a 	mov	r3,r4
 400b388:	10c00005 	stb	r3,0(r2)
	      if (d.d < eps.d)
 400b38c:	e0bfd517 	ldw	r2,-172(fp)
 400b390:	e0ffd617 	ldw	r3,-168(fp)
 400b394:	e13fd117 	ldw	r4,-188(fp)
 400b398:	e17fd217 	ldw	r5,-184(fp)
 400b39c:	200d883a 	mov	r6,r4
 400b3a0:	280f883a 	mov	r7,r5
 400b3a4:	1009883a 	mov	r4,r2
 400b3a8:	180b883a 	mov	r5,r3
 400b3ac:	40169740 	call	4016974 <__ledf2>
 400b3b0:	1003de16 	blt	r2,zero,400c32c <_dtoa_r+0x1bc0>
		goto ret1;
	      if (1. - d.d < eps.d)
 400b3b4:	e0bfd517 	ldw	r2,-172(fp)
 400b3b8:	e0ffd617 	ldw	r3,-168(fp)
 400b3bc:	100d883a 	mov	r6,r2
 400b3c0:	180f883a 	mov	r7,r3
 400b3c4:	0009883a 	mov	r4,zero
 400b3c8:	014ffc34 	movhi	r5,16368
 400b3cc:	401720c0 	call	401720c <__subdf3>
 400b3d0:	1009883a 	mov	r4,r2
 400b3d4:	180b883a 	mov	r5,r3
 400b3d8:	2011883a 	mov	r8,r4
 400b3dc:	2813883a 	mov	r9,r5
 400b3e0:	e0bfd117 	ldw	r2,-188(fp)
 400b3e4:	e0ffd217 	ldw	r3,-184(fp)
 400b3e8:	100d883a 	mov	r6,r2
 400b3ec:	180f883a 	mov	r7,r3
 400b3f0:	4009883a 	mov	r4,r8
 400b3f4:	480b883a 	mov	r5,r9
 400b3f8:	40169740 	call	4016974 <__ledf2>
 400b3fc:	10012f16 	blt	r2,zero,400b8bc <_dtoa_r+0x1150>
		goto bump_up;
	      if (++i >= ilim)
 400b400:	e0bff817 	ldw	r2,-32(fp)
 400b404:	10800044 	addi	r2,r2,1
 400b408:	e0bff815 	stw	r2,-32(fp)
 400b40c:	e0fff817 	ldw	r3,-32(fp)
 400b410:	e0bff617 	ldw	r2,-40(fp)
 400b414:	18809d0e 	bge	r3,r2,400b68c <_dtoa_r+0xf20>
		break;
	      eps.d *= 10.;
 400b418:	e0bfd117 	ldw	r2,-188(fp)
 400b41c:	e0ffd217 	ldw	r3,-184(fp)
 400b420:	000d883a 	mov	r6,zero
 400b424:	01d00934 	movhi	r7,16420
 400b428:	1009883a 	mov	r4,r2
 400b42c:	180b883a 	mov	r5,r3
 400b430:	4016a640 	call	4016a64 <__muldf3>
 400b434:	1009883a 	mov	r4,r2
 400b438:	180b883a 	mov	r5,r3
 400b43c:	2005883a 	mov	r2,r4
 400b440:	2807883a 	mov	r3,r5
 400b444:	e0bfd115 	stw	r2,-188(fp)
 400b448:	e0ffd215 	stw	r3,-184(fp)
	      d.d *= 10.;
 400b44c:	e0bfd517 	ldw	r2,-172(fp)
 400b450:	e0ffd617 	ldw	r3,-168(fp)
 400b454:	000d883a 	mov	r6,zero
 400b458:	01d00934 	movhi	r7,16420
 400b45c:	1009883a 	mov	r4,r2
 400b460:	180b883a 	mov	r5,r3
 400b464:	4016a640 	call	4016a64 <__muldf3>
 400b468:	1009883a 	mov	r4,r2
 400b46c:	180b883a 	mov	r5,r3
 400b470:	2005883a 	mov	r2,r4
 400b474:	2807883a 	mov	r3,r5
 400b478:	e0bfd515 	stw	r2,-172(fp)
 400b47c:	e0ffd615 	stw	r3,-168(fp)
	      L = d.d;
 400b480:	003fa306 	br	400b310 <_dtoa_r+0xba4>
	}
      else
	{
#endif
	  /* Generate ilim digits, then fix them up. */
	  eps.d *= tens[ilim - 1];
 400b484:	e0bfd117 	ldw	r2,-188(fp)
 400b488:	e0ffd217 	ldw	r3,-184(fp)
 400b48c:	e13ff617 	ldw	r4,-40(fp)
 400b490:	213fffc4 	addi	r4,r4,-1
 400b494:	200e90fa 	slli	r7,r4,3
 400b498:	018100b4 	movhi	r6,1026
 400b49c:	398d883a 	add	r6,r7,r6
 400b4a0:	312b6617 	ldw	r4,-21096(r6)
 400b4a4:	018100b4 	movhi	r6,1026
 400b4a8:	398d883a 	add	r6,r7,r6
 400b4ac:	316b6717 	ldw	r5,-21092(r6)
 400b4b0:	200d883a 	mov	r6,r4
 400b4b4:	280f883a 	mov	r7,r5
 400b4b8:	1009883a 	mov	r4,r2
 400b4bc:	180b883a 	mov	r5,r3
 400b4c0:	4016a640 	call	4016a64 <__muldf3>
 400b4c4:	1009883a 	mov	r4,r2
 400b4c8:	180b883a 	mov	r5,r3
 400b4cc:	2005883a 	mov	r2,r4
 400b4d0:	2807883a 	mov	r3,r5
 400b4d4:	e0bfd115 	stw	r2,-188(fp)
 400b4d8:	e0ffd215 	stw	r3,-184(fp)
	  for (i = 1;; i++, d.d *= 10.)
 400b4dc:	00800044 	movi	r2,1
 400b4e0:	e0bff815 	stw	r2,-32(fp)
	    {
	      L = d.d;
 400b4e4:	e0bfd517 	ldw	r2,-172(fp)
 400b4e8:	e0ffd617 	ldw	r3,-168(fp)
 400b4ec:	1009883a 	mov	r4,r2
 400b4f0:	180b883a 	mov	r5,r3
 400b4f4:	4017b940 	call	4017b94 <__fixdfsi>
 400b4f8:	e0bfdc15 	stw	r2,-144(fp)
	      d.d -= L;
 400b4fc:	e43fd517 	ldw	r16,-172(fp)
 400b500:	e47fd617 	ldw	r17,-168(fp)
 400b504:	e13fdc17 	ldw	r4,-144(fp)
 400b508:	4017c140 	call	4017c14 <__floatsidf>
 400b50c:	1009883a 	mov	r4,r2
 400b510:	180b883a 	mov	r5,r3
 400b514:	200d883a 	mov	r6,r4
 400b518:	280f883a 	mov	r7,r5
 400b51c:	8009883a 	mov	r4,r16
 400b520:	880b883a 	mov	r5,r17
 400b524:	401720c0 	call	401720c <__subdf3>
 400b528:	1009883a 	mov	r4,r2
 400b52c:	180b883a 	mov	r5,r3
 400b530:	2005883a 	mov	r2,r4
 400b534:	2807883a 	mov	r3,r5
 400b538:	e0bfd515 	stw	r2,-172(fp)
 400b53c:	e0ffd615 	stw	r3,-168(fp)
	      *s++ = '0' + (int) L;
 400b540:	e0bfdc17 	ldw	r2,-144(fp)
 400b544:	10800c04 	addi	r2,r2,48
 400b548:	1009883a 	mov	r4,r2
 400b54c:	e0bfe317 	ldw	r2,-116(fp)
 400b550:	10c00044 	addi	r3,r2,1
 400b554:	e0ffe315 	stw	r3,-116(fp)
 400b558:	2007883a 	mov	r3,r4
 400b55c:	10c00005 	stb	r3,0(r2)
	      if (i == ilim)
 400b560:	e0fff817 	ldw	r3,-32(fp)
 400b564:	e0bff617 	ldw	r2,-40(fp)
 400b568:	1880351e 	bne	r3,r2,400b640 <_dtoa_r+0xed4>
		{
		  if (d.d > 0.5 + eps.d)
 400b56c:	e43fd517 	ldw	r16,-172(fp)
 400b570:	e47fd617 	ldw	r17,-168(fp)
 400b574:	e0bfd117 	ldw	r2,-188(fp)
 400b578:	e0ffd217 	ldw	r3,-184(fp)
 400b57c:	000d883a 	mov	r6,zero
 400b580:	01cff834 	movhi	r7,16352
 400b584:	1009883a 	mov	r4,r2
 400b588:	180b883a 	mov	r5,r3
 400b58c:	40155580 	call	4015558 <__adddf3>
 400b590:	1009883a 	mov	r4,r2
 400b594:	180b883a 	mov	r5,r3
 400b598:	2005883a 	mov	r2,r4
 400b59c:	2807883a 	mov	r3,r5
 400b5a0:	100d883a 	mov	r6,r2
 400b5a4:	180f883a 	mov	r7,r3
 400b5a8:	8009883a 	mov	r4,r16
 400b5ac:	880b883a 	mov	r5,r17
 400b5b0:	40168840 	call	4016884 <__gedf2>
 400b5b4:	0080c316 	blt	zero,r2,400b8c4 <_dtoa_r+0x1158>
		    goto bump_up;
		  else if (d.d < 0.5 - eps.d)
 400b5b8:	e43fd517 	ldw	r16,-172(fp)
 400b5bc:	e47fd617 	ldw	r17,-168(fp)
 400b5c0:	e0bfd117 	ldw	r2,-188(fp)
 400b5c4:	e0ffd217 	ldw	r3,-184(fp)
 400b5c8:	100d883a 	mov	r6,r2
 400b5cc:	180f883a 	mov	r7,r3
 400b5d0:	0009883a 	mov	r4,zero
 400b5d4:	014ff834 	movhi	r5,16352
 400b5d8:	401720c0 	call	401720c <__subdf3>
 400b5dc:	1009883a 	mov	r4,r2
 400b5e0:	180b883a 	mov	r5,r3
 400b5e4:	2005883a 	mov	r2,r4
 400b5e8:	2807883a 	mov	r3,r5
 400b5ec:	100d883a 	mov	r6,r2
 400b5f0:	180f883a 	mov	r7,r3
 400b5f4:	8009883a 	mov	r4,r16
 400b5f8:	880b883a 	mov	r5,r17
 400b5fc:	40169740 	call	4016974 <__ledf2>
 400b600:	10000116 	blt	r2,zero,400b608 <_dtoa_r+0xe9c>
		    {
		      while (*--s == '0');
		      s++;
		      goto ret1;
		    }
		  break;
 400b604:	00002206 	br	400b690 <_dtoa_r+0xf24>
		      while (*--s == '0');
 400b608:	e0bfe317 	ldw	r2,-116(fp)
 400b60c:	10bfffc4 	addi	r2,r2,-1
 400b610:	e0bfe315 	stw	r2,-116(fp)
 400b614:	e0bfe317 	ldw	r2,-116(fp)
 400b618:	10800003 	ldbu	r2,0(r2)
 400b61c:	10803fcc 	andi	r2,r2,255
 400b620:	1080201c 	xori	r2,r2,128
 400b624:	10bfe004 	addi	r2,r2,-128
 400b628:	10800c20 	cmpeqi	r2,r2,48
 400b62c:	103ff61e 	bne	r2,zero,400b608 <_dtoa_r+0xe9c>
		      s++;
 400b630:	e0bfe317 	ldw	r2,-116(fp)
 400b634:	10800044 	addi	r2,r2,1
 400b638:	e0bfe315 	stw	r2,-116(fp)
		      goto ret1;
 400b63c:	00033e06 	br	400c338 <_dtoa_r+0x1bcc>
	  for (i = 1;; i++, d.d *= 10.)
 400b640:	e0bff817 	ldw	r2,-32(fp)
 400b644:	10800044 	addi	r2,r2,1
 400b648:	e0bff815 	stw	r2,-32(fp)
 400b64c:	e0bfd517 	ldw	r2,-172(fp)
 400b650:	e0ffd617 	ldw	r3,-168(fp)
 400b654:	000d883a 	mov	r6,zero
 400b658:	01d00934 	movhi	r7,16420
 400b65c:	1009883a 	mov	r4,r2
 400b660:	180b883a 	mov	r5,r3
 400b664:	4016a640 	call	4016a64 <__muldf3>
 400b668:	1009883a 	mov	r4,r2
 400b66c:	180b883a 	mov	r5,r3
 400b670:	2005883a 	mov	r2,r4
 400b674:	2807883a 	mov	r3,r5
 400b678:	e0bfd515 	stw	r2,-172(fp)
 400b67c:	e0ffd615 	stw	r3,-168(fp)
	      L = d.d;
 400b680:	003f9806 	br	400b4e4 <_dtoa_r+0xd78>
	    goto fast_failed;
 400b684:	0001883a 	nop
 400b688:	00000106 	br	400b690 <_dtoa_r+0xf24>
		break;
 400b68c:	0001883a 	nop
	    }
#ifndef No_leftright
	}
#endif
    fast_failed:
      s = s0;
 400b690:	e0bfe017 	ldw	r2,-128(fp)
 400b694:	e0bfe315 	stw	r2,-116(fp)
      d.d = d2.d;
 400b698:	e0bfd317 	ldw	r2,-180(fp)
 400b69c:	e0ffd417 	ldw	r3,-176(fp)
 400b6a0:	e0bfd515 	stw	r2,-172(fp)
 400b6a4:	e0ffd615 	stw	r3,-168(fp)
      k = k0;
 400b6a8:	e0bfdf17 	ldw	r2,-132(fp)
 400b6ac:	e0bff315 	stw	r2,-52(fp)
      ilim = ilim0;
 400b6b0:	e0bfde17 	ldw	r2,-136(fp)
 400b6b4:	e0bff615 	stw	r2,-40(fp)
    }

  /* Do we have a "small" integer? */

  if (be >= 0 && k <= Int_max)
 400b6b8:	e0bfd717 	ldw	r2,-164(fp)
 400b6bc:	1000bd16 	blt	r2,zero,400b9b4 <_dtoa_r+0x1248>
 400b6c0:	e0bff317 	ldw	r2,-52(fp)
 400b6c4:	108003c8 	cmpgei	r2,r2,15
 400b6c8:	1000ba1e 	bne	r2,zero,400b9b4 <_dtoa_r+0x1248>
    {
      /* Yes. */
      ds = tens[k];
 400b6cc:	e0bff317 	ldw	r2,-52(fp)
 400b6d0:	100690fa 	slli	r3,r2,3
 400b6d4:	008100b4 	movhi	r2,1026
 400b6d8:	1885883a 	add	r2,r3,r2
 400b6dc:	10ab6617 	ldw	r2,-21096(r2)
 400b6e0:	e0bfe415 	stw	r2,-112(fp)
 400b6e4:	008100b4 	movhi	r2,1026
 400b6e8:	1885883a 	add	r2,r3,r2
 400b6ec:	10ab6717 	ldw	r2,-21092(r2)
 400b6f0:	e0bfe515 	stw	r2,-108(fp)
      if (ndigits < 0 && ilim <= 0)
 400b6f4:	e0800217 	ldw	r2,8(fp)
 400b6f8:	1000190e 	bge	r2,zero,400b760 <_dtoa_r+0xff4>
 400b6fc:	e0bff617 	ldw	r2,-40(fp)
 400b700:	00801716 	blt	zero,r2,400b760 <_dtoa_r+0xff4>
	{
	  S = mhi = 0;
 400b704:	e03fe715 	stw	zero,-100(fp)
 400b708:	e0bfe717 	ldw	r2,-100(fp)
 400b70c:	e0bfe615 	stw	r2,-104(fp)
	  if (ilim < 0 || d.d <= 5 * ds)
 400b710:	e0bff617 	ldw	r2,-40(fp)
 400b714:	1001c116 	blt	r2,zero,400be1c <_dtoa_r+0x16b0>
 400b718:	e43fd517 	ldw	r16,-172(fp)
 400b71c:	e47fd617 	ldw	r17,-168(fp)
 400b720:	000d883a 	mov	r6,zero
 400b724:	01d00534 	movhi	r7,16404
 400b728:	e13fe417 	ldw	r4,-112(fp)
 400b72c:	e17fe517 	ldw	r5,-108(fp)
 400b730:	4016a640 	call	4016a64 <__muldf3>
 400b734:	1009883a 	mov	r4,r2
 400b738:	180b883a 	mov	r5,r3
 400b73c:	2005883a 	mov	r2,r4
 400b740:	2807883a 	mov	r3,r5
 400b744:	100d883a 	mov	r6,r2
 400b748:	180f883a 	mov	r7,r3
 400b74c:	8009883a 	mov	r4,r16
 400b750:	880b883a 	mov	r5,r17
 400b754:	40169740 	call	4016974 <__ledf2>
 400b758:	0081b00e 	bge	zero,r2,400be1c <_dtoa_r+0x16b0>
	    goto no_digits;
	  goto one_digit;
 400b75c:	0001b906 	br	400be44 <_dtoa_r+0x16d8>
	}
      for (i = 1;; i++)
 400b760:	00800044 	movi	r2,1
 400b764:	e0bff815 	stw	r2,-32(fp)
	{
	  L = d.d / ds;
 400b768:	e0bfd517 	ldw	r2,-172(fp)
 400b76c:	e0ffd617 	ldw	r3,-168(fp)
 400b770:	e1bfe417 	ldw	r6,-112(fp)
 400b774:	e1ffe517 	ldw	r7,-108(fp)
 400b778:	1009883a 	mov	r4,r2
 400b77c:	180b883a 	mov	r5,r3
 400b780:	4015ed00 	call	4015ed0 <__divdf3>
 400b784:	1009883a 	mov	r4,r2
 400b788:	180b883a 	mov	r5,r3
 400b78c:	2005883a 	mov	r2,r4
 400b790:	2807883a 	mov	r3,r5
 400b794:	1009883a 	mov	r4,r2
 400b798:	180b883a 	mov	r5,r3
 400b79c:	4017b940 	call	4017b94 <__fixdfsi>
 400b7a0:	e0bfdc15 	stw	r2,-144(fp)
	  d.d -= L * ds;
 400b7a4:	e43fd517 	ldw	r16,-172(fp)
 400b7a8:	e47fd617 	ldw	r17,-168(fp)
 400b7ac:	e13fdc17 	ldw	r4,-144(fp)
 400b7b0:	4017c140 	call	4017c14 <__floatsidf>
 400b7b4:	1011883a 	mov	r8,r2
 400b7b8:	1813883a 	mov	r9,r3
 400b7bc:	e1bfe417 	ldw	r6,-112(fp)
 400b7c0:	e1ffe517 	ldw	r7,-108(fp)
 400b7c4:	4009883a 	mov	r4,r8
 400b7c8:	480b883a 	mov	r5,r9
 400b7cc:	4016a640 	call	4016a64 <__muldf3>
 400b7d0:	1009883a 	mov	r4,r2
 400b7d4:	180b883a 	mov	r5,r3
 400b7d8:	2005883a 	mov	r2,r4
 400b7dc:	2807883a 	mov	r3,r5
 400b7e0:	100d883a 	mov	r6,r2
 400b7e4:	180f883a 	mov	r7,r3
 400b7e8:	8009883a 	mov	r4,r16
 400b7ec:	880b883a 	mov	r5,r17
 400b7f0:	401720c0 	call	401720c <__subdf3>
 400b7f4:	1009883a 	mov	r4,r2
 400b7f8:	180b883a 	mov	r5,r3
 400b7fc:	2005883a 	mov	r2,r4
 400b800:	2807883a 	mov	r3,r5
 400b804:	e0bfd515 	stw	r2,-172(fp)
 400b808:	e0ffd615 	stw	r3,-168(fp)
	    {
	      L--;
	      d.d += ds;
	    }
#endif
	  *s++ = '0' + (int) L;
 400b80c:	e0bfdc17 	ldw	r2,-144(fp)
 400b810:	10800c04 	addi	r2,r2,48
 400b814:	1009883a 	mov	r4,r2
 400b818:	e0bfe317 	ldw	r2,-116(fp)
 400b81c:	10c00044 	addi	r3,r2,1
 400b820:	e0ffe315 	stw	r3,-116(fp)
 400b824:	2007883a 	mov	r3,r4
 400b828:	10c00005 	stb	r3,0(r2)
	  if (i == ilim)
 400b82c:	e0fff817 	ldw	r3,-32(fp)
 400b830:	e0bff617 	ldw	r2,-40(fp)
 400b834:	1880421e 	bne	r3,r2,400b940 <_dtoa_r+0x11d4>
	    {
	      d.d += d.d;
 400b838:	e0bfd517 	ldw	r2,-172(fp)
 400b83c:	e0ffd617 	ldw	r3,-168(fp)
 400b840:	100d883a 	mov	r6,r2
 400b844:	180f883a 	mov	r7,r3
 400b848:	1009883a 	mov	r4,r2
 400b84c:	180b883a 	mov	r5,r3
 400b850:	40155580 	call	4015558 <__adddf3>
 400b854:	1009883a 	mov	r4,r2
 400b858:	180b883a 	mov	r5,r3
 400b85c:	2005883a 	mov	r2,r4
 400b860:	2807883a 	mov	r3,r5
 400b864:	e0bfd515 	stw	r2,-172(fp)
 400b868:	e0ffd615 	stw	r3,-168(fp)
             if ((d.d > ds) || ((d.d == ds) && (L & 1)))
 400b86c:	e0bfd517 	ldw	r2,-172(fp)
 400b870:	e0ffd617 	ldw	r3,-168(fp)
 400b874:	100d883a 	mov	r6,r2
 400b878:	180f883a 	mov	r7,r3
 400b87c:	e13fe417 	ldw	r4,-112(fp)
 400b880:	e17fe517 	ldw	r5,-108(fp)
 400b884:	40169740 	call	4016974 <__ledf2>
 400b888:	10001016 	blt	r2,zero,400b8cc <_dtoa_r+0x1160>
 400b88c:	e0bfd517 	ldw	r2,-172(fp)
 400b890:	e0ffd617 	ldw	r3,-168(fp)
 400b894:	100d883a 	mov	r6,r2
 400b898:	180f883a 	mov	r7,r3
 400b89c:	e13fe417 	ldw	r4,-112(fp)
 400b8a0:	e17fe517 	ldw	r5,-108(fp)
 400b8a4:	40168040 	call	4016804 <__eqdf2>
 400b8a8:	10003e1e 	bne	r2,zero,400b9a4 <_dtoa_r+0x1238>
 400b8ac:	e0bfdc17 	ldw	r2,-144(fp)
 400b8b0:	1080004c 	andi	r2,r2,1
 400b8b4:	10003b26 	beq	r2,zero,400b9a4 <_dtoa_r+0x1238>
		{
		bump_up:
 400b8b8:	00000406 	br	400b8cc <_dtoa_r+0x1160>
		goto bump_up;
 400b8bc:	0001883a 	nop
 400b8c0:	00000e06 	br	400b8fc <_dtoa_r+0x1190>
		    goto bump_up;
 400b8c4:	0001883a 	nop
 400b8c8:	00000c06 	br	400b8fc <_dtoa_r+0x1190>
		bump_up:
 400b8cc:	0001883a 	nop
		  while (*--s == '9')
 400b8d0:	00000a06 	br	400b8fc <_dtoa_r+0x1190>
		    if (s == s0)
 400b8d4:	e0ffe317 	ldw	r3,-116(fp)
 400b8d8:	e0bfe017 	ldw	r2,-128(fp)
 400b8dc:	1880071e 	bne	r3,r2,400b8fc <_dtoa_r+0x1190>
		      {
			k++;
 400b8e0:	e0bff317 	ldw	r2,-52(fp)
 400b8e4:	10800044 	addi	r2,r2,1
 400b8e8:	e0bff315 	stw	r2,-52(fp)
			*s = '0';
 400b8ec:	e0bfe317 	ldw	r2,-116(fp)
 400b8f0:	00c00c04 	movi	r3,48
 400b8f4:	10c00005 	stb	r3,0(r2)
			break;
 400b8f8:	00000a06 	br	400b924 <_dtoa_r+0x11b8>
		  while (*--s == '9')
 400b8fc:	e0bfe317 	ldw	r2,-116(fp)
 400b900:	10bfffc4 	addi	r2,r2,-1
 400b904:	e0bfe315 	stw	r2,-116(fp)
 400b908:	e0bfe317 	ldw	r2,-116(fp)
 400b90c:	10800003 	ldbu	r2,0(r2)
 400b910:	10803fcc 	andi	r2,r2,255
 400b914:	1080201c 	xori	r2,r2,128
 400b918:	10bfe004 	addi	r2,r2,-128
 400b91c:	10800e60 	cmpeqi	r2,r2,57
 400b920:	103fec1e 	bne	r2,zero,400b8d4 <_dtoa_r+0x1168>
		      }
		  ++*s++;
 400b924:	e0bfe317 	ldw	r2,-116(fp)
 400b928:	10c00044 	addi	r3,r2,1
 400b92c:	e0ffe315 	stw	r3,-116(fp)
 400b930:	10c00003 	ldbu	r3,0(r2)
 400b934:	18c00044 	addi	r3,r3,1
 400b938:	10c00005 	stb	r3,0(r2)
		}
	      break;
 400b93c:	00001906 	br	400b9a4 <_dtoa_r+0x1238>
	    }
	  if (!(d.d *= 10.))
 400b940:	e0bfd517 	ldw	r2,-172(fp)
 400b944:	e0ffd617 	ldw	r3,-168(fp)
 400b948:	000d883a 	mov	r6,zero
 400b94c:	01d00934 	movhi	r7,16420
 400b950:	1009883a 	mov	r4,r2
 400b954:	180b883a 	mov	r5,r3
 400b958:	4016a640 	call	4016a64 <__muldf3>
 400b95c:	1009883a 	mov	r4,r2
 400b960:	180b883a 	mov	r5,r3
 400b964:	2005883a 	mov	r2,r4
 400b968:	2807883a 	mov	r3,r5
 400b96c:	e0bfd515 	stw	r2,-172(fp)
 400b970:	e0ffd615 	stw	r3,-168(fp)
 400b974:	e0bfd517 	ldw	r2,-172(fp)
 400b978:	e0ffd617 	ldw	r3,-168(fp)
 400b97c:	000d883a 	mov	r6,zero
 400b980:	000f883a 	mov	r7,zero
 400b984:	1009883a 	mov	r4,r2
 400b988:	180b883a 	mov	r5,r3
 400b98c:	40168040 	call	4016804 <__eqdf2>
 400b990:	10000626 	beq	r2,zero,400b9ac <_dtoa_r+0x1240>
      for (i = 1;; i++)
 400b994:	e0bff817 	ldw	r2,-32(fp)
 400b998:	10800044 	addi	r2,r2,1
 400b99c:	e0bff815 	stw	r2,-32(fp)
	  L = d.d / ds;
 400b9a0:	003f7106 	br	400b768 <_dtoa_r+0xffc>
	      break;
 400b9a4:	0001883a 	nop
 400b9a8:	00026306 	br	400c338 <_dtoa_r+0x1bcc>
	    break;
 400b9ac:	0001883a 	nop
	}
      goto ret1;
 400b9b0:	00026106 	br	400c338 <_dtoa_r+0x1bcc>
    }

  m2 = b2;
 400b9b4:	e0bffb17 	ldw	r2,-20(fp)
 400b9b8:	e0bff015 	stw	r2,-64(fp)
  m5 = b5;
 400b9bc:	e0bffa17 	ldw	r2,-24(fp)
 400b9c0:	e0bfef15 	stw	r2,-68(fp)
  mhi = mlo = 0;
 400b9c4:	e03fe815 	stw	zero,-96(fp)
 400b9c8:	e0bfe817 	ldw	r2,-96(fp)
 400b9cc:	e0bfe715 	stw	r2,-100(fp)
  if (leftright)
 400b9d0:	e0bff117 	ldw	r2,-60(fp)
 400b9d4:	10003a26 	beq	r2,zero,400bac0 <_dtoa_r+0x1354>
    {
      if (mode < 2)
 400b9d8:	e0bfcd17 	ldw	r2,-204(fp)
 400b9dc:	10800088 	cmpgei	r2,r2,2
 400b9e0:	10000a1e 	bne	r2,zero,400ba0c <_dtoa_r+0x12a0>
	{
	  i =
#ifndef Sudden_Underflow
	    denorm ? be + (Bias + (P - 1) - 1 + 1) :
 400b9e4:	e0bfea17 	ldw	r2,-88(fp)
 400b9e8:	10000326 	beq	r2,zero,400b9f8 <_dtoa_r+0x128c>
 400b9ec:	e0bfd717 	ldw	r2,-164(fp)
 400b9f0:	10810cc4 	addi	r2,r2,1075
 400b9f4:	00000306 	br	400ba04 <_dtoa_r+0x1298>
#endif
#ifdef IBM
	    1 + 4 * P - 3 - bbits + ((bbits + be - 1) & 3);
#else
	    1 + P - bbits;
 400b9f8:	e0bfd817 	ldw	r2,-160(fp)
	    denorm ? be + (Bias + (P - 1) - 1 + 1) :
 400b9fc:	00c00d84 	movi	r3,54
 400ba00:	1885c83a 	sub	r2,r3,r2
	  i =
 400ba04:	e0bff815 	stw	r2,-32(fp)
 400ba08:	00002106 	br	400ba90 <_dtoa_r+0x1324>
#endif
	}
      else
	{
	  j = ilim - 1;
 400ba0c:	e0bff617 	ldw	r2,-40(fp)
 400ba10:	10bfffc4 	addi	r2,r2,-1
 400ba14:	e0bff415 	stw	r2,-48(fp)
	  if (m5 >= j)
 400ba18:	e0ffef17 	ldw	r3,-68(fp)
 400ba1c:	e0bff417 	ldw	r2,-48(fp)
 400ba20:	18800516 	blt	r3,r2,400ba38 <_dtoa_r+0x12cc>
	    m5 -= j;
 400ba24:	e0ffef17 	ldw	r3,-68(fp)
 400ba28:	e0bff417 	ldw	r2,-48(fp)
 400ba2c:	1885c83a 	sub	r2,r3,r2
 400ba30:	e0bfef15 	stw	r2,-68(fp)
 400ba34:	00000d06 	br	400ba6c <_dtoa_r+0x1300>
	  else
	    {
	      s5 += j -= m5;
 400ba38:	e0fff417 	ldw	r3,-48(fp)
 400ba3c:	e0bfef17 	ldw	r2,-68(fp)
 400ba40:	1885c83a 	sub	r2,r3,r2
 400ba44:	e0bff415 	stw	r2,-48(fp)
 400ba48:	e0bff417 	ldw	r2,-48(fp)
 400ba4c:	e0ffed17 	ldw	r3,-76(fp)
 400ba50:	1885883a 	add	r2,r3,r2
 400ba54:	e0bfed15 	stw	r2,-76(fp)
	      b5 += j;
 400ba58:	e0fffa17 	ldw	r3,-24(fp)
 400ba5c:	e0bff417 	ldw	r2,-48(fp)
 400ba60:	1885883a 	add	r2,r3,r2
 400ba64:	e0bffa15 	stw	r2,-24(fp)
	      m5 = 0;
 400ba68:	e03fef15 	stw	zero,-68(fp)
	    }
	  if ((i = ilim) < 0)
 400ba6c:	e0bff617 	ldw	r2,-40(fp)
 400ba70:	e0bff815 	stw	r2,-32(fp)
 400ba74:	e0bff817 	ldw	r2,-32(fp)
 400ba78:	1000050e 	bge	r2,zero,400ba90 <_dtoa_r+0x1324>
	    {
	      m2 -= i;
 400ba7c:	e0fff017 	ldw	r3,-64(fp)
 400ba80:	e0bff817 	ldw	r2,-32(fp)
 400ba84:	1885c83a 	sub	r2,r3,r2
 400ba88:	e0bff015 	stw	r2,-64(fp)
	      i = 0;
 400ba8c:	e03ff815 	stw	zero,-32(fp)
	    }
	}
      b2 += i;
 400ba90:	e0fffb17 	ldw	r3,-20(fp)
 400ba94:	e0bff817 	ldw	r2,-32(fp)
 400ba98:	1885883a 	add	r2,r3,r2
 400ba9c:	e0bffb15 	stw	r2,-20(fp)
      s2 += i;
 400baa0:	e0ffee17 	ldw	r3,-72(fp)
 400baa4:	e0bff817 	ldw	r2,-32(fp)
 400baa8:	1885883a 	add	r2,r3,r2
 400baac:	e0bfee15 	stw	r2,-72(fp)
      mhi = i2b (ptr, 1);
 400bab0:	01400044 	movi	r5,1
 400bab4:	e13fd017 	ldw	r4,-192(fp)
 400bab8:	400fc4c0 	call	400fc4c <__i2b>
 400babc:	e0bfe715 	stw	r2,-100(fp)
    }
  if (m2 > 0 && s2 > 0)
 400bac0:	e0bff017 	ldw	r2,-64(fp)
 400bac4:	0080130e 	bge	zero,r2,400bb14 <_dtoa_r+0x13a8>
 400bac8:	e0bfee17 	ldw	r2,-72(fp)
 400bacc:	0080110e 	bge	zero,r2,400bb14 <_dtoa_r+0x13a8>
    {
      i = m2 < s2 ? m2 : s2;
 400bad0:	e0fff017 	ldw	r3,-64(fp)
 400bad4:	e0bfee17 	ldw	r2,-72(fp)
 400bad8:	1880010e 	bge	r3,r2,400bae0 <_dtoa_r+0x1374>
 400badc:	1805883a 	mov	r2,r3
 400bae0:	e0bff815 	stw	r2,-32(fp)
      b2 -= i;
 400bae4:	e0fffb17 	ldw	r3,-20(fp)
 400bae8:	e0bff817 	ldw	r2,-32(fp)
 400baec:	1885c83a 	sub	r2,r3,r2
 400baf0:	e0bffb15 	stw	r2,-20(fp)
      m2 -= i;
 400baf4:	e0fff017 	ldw	r3,-64(fp)
 400baf8:	e0bff817 	ldw	r2,-32(fp)
 400bafc:	1885c83a 	sub	r2,r3,r2
 400bb00:	e0bff015 	stw	r2,-64(fp)
      s2 -= i;
 400bb04:	e0ffee17 	ldw	r3,-72(fp)
 400bb08:	e0bff817 	ldw	r2,-32(fp)
 400bb0c:	1885c83a 	sub	r2,r3,r2
 400bb10:	e0bfee15 	stw	r2,-72(fp)
    }
  if (b5 > 0)
 400bb14:	e0bffa17 	ldw	r2,-24(fp)
 400bb18:	0080240e 	bge	zero,r2,400bbac <_dtoa_r+0x1440>
    {
      if (leftright)
 400bb1c:	e0bff117 	ldw	r2,-60(fp)
 400bb20:	10001d26 	beq	r2,zero,400bb98 <_dtoa_r+0x142c>
	{
	  if (m5 > 0)
 400bb24:	e0bfef17 	ldw	r2,-68(fp)
 400bb28:	00800f0e 	bge	zero,r2,400bb68 <_dtoa_r+0x13fc>
	    {
	      mhi = pow5mult (ptr, mhi, m5);
 400bb2c:	e1bfef17 	ldw	r6,-68(fp)
 400bb30:	e17fe717 	ldw	r5,-100(fp)
 400bb34:	e13fd017 	ldw	r4,-192(fp)
 400bb38:	40100cc0 	call	40100cc <__pow5mult>
 400bb3c:	e0bfe715 	stw	r2,-100(fp)
	      b1 = mult (ptr, mhi, b);
 400bb40:	e1bfe917 	ldw	r6,-92(fp)
 400bb44:	e17fe717 	ldw	r5,-100(fp)
 400bb48:	e13fd017 	ldw	r4,-192(fp)
 400bb4c:	400fcd00 	call	400fcd0 <__multiply>
 400bb50:	e0bfdb15 	stw	r2,-148(fp)
	      Bfree (ptr, b);
 400bb54:	e17fe917 	ldw	r5,-92(fp)
 400bb58:	e13fd017 	ldw	r4,-192(fp)
 400bb5c:	400f6d80 	call	400f6d8 <_Bfree>
	      b = b1;
 400bb60:	e0bfdb17 	ldw	r2,-148(fp)
 400bb64:	e0bfe915 	stw	r2,-92(fp)
	    }
         if ((j = b5 - m5) != 0)
 400bb68:	e0fffa17 	ldw	r3,-24(fp)
 400bb6c:	e0bfef17 	ldw	r2,-68(fp)
 400bb70:	1885c83a 	sub	r2,r3,r2
 400bb74:	e0bff415 	stw	r2,-48(fp)
 400bb78:	e0bff417 	ldw	r2,-48(fp)
 400bb7c:	10000b26 	beq	r2,zero,400bbac <_dtoa_r+0x1440>
	    b = pow5mult (ptr, b, j);
 400bb80:	e1bff417 	ldw	r6,-48(fp)
 400bb84:	e17fe917 	ldw	r5,-92(fp)
 400bb88:	e13fd017 	ldw	r4,-192(fp)
 400bb8c:	40100cc0 	call	40100cc <__pow5mult>
 400bb90:	e0bfe915 	stw	r2,-92(fp)
 400bb94:	00000506 	br	400bbac <_dtoa_r+0x1440>
	}
      else
	b = pow5mult (ptr, b, b5);
 400bb98:	e1bffa17 	ldw	r6,-24(fp)
 400bb9c:	e17fe917 	ldw	r5,-92(fp)
 400bba0:	e13fd017 	ldw	r4,-192(fp)
 400bba4:	40100cc0 	call	40100cc <__pow5mult>
 400bba8:	e0bfe915 	stw	r2,-92(fp)
    }
  S = i2b (ptr, 1);
 400bbac:	01400044 	movi	r5,1
 400bbb0:	e13fd017 	ldw	r4,-192(fp)
 400bbb4:	400fc4c0 	call	400fc4c <__i2b>
 400bbb8:	e0bfe615 	stw	r2,-104(fp)
  if (s5 > 0)
 400bbbc:	e0bfed17 	ldw	r2,-76(fp)
 400bbc0:	0080050e 	bge	zero,r2,400bbd8 <_dtoa_r+0x146c>
    S = pow5mult (ptr, S, s5);
 400bbc4:	e1bfed17 	ldw	r6,-76(fp)
 400bbc8:	e17fe617 	ldw	r5,-104(fp)
 400bbcc:	e13fd017 	ldw	r4,-192(fp)
 400bbd0:	40100cc0 	call	40100cc <__pow5mult>
 400bbd4:	e0bfe615 	stw	r2,-104(fp)

  /* Check for special case that d is a normalized power of 2. */

  spec_case = 0;
 400bbd8:	e03fec15 	stw	zero,-80(fp)
  if (mode < 2)
 400bbdc:	e0bfcd17 	ldw	r2,-204(fp)
 400bbe0:	10800088 	cmpgei	r2,r2,2
 400bbe4:	1000121e 	bne	r2,zero,400bc30 <_dtoa_r+0x14c4>
    {
      if (!word1 (d) && !(word0 (d) & Bndry_mask)
 400bbe8:	e0bfd517 	ldw	r2,-172(fp)
 400bbec:	1000101e 	bne	r2,zero,400bc30 <_dtoa_r+0x14c4>
 400bbf0:	e0ffd617 	ldw	r3,-168(fp)
 400bbf4:	00800434 	movhi	r2,16
 400bbf8:	10bfffc4 	addi	r2,r2,-1
 400bbfc:	1884703a 	and	r2,r3,r2
 400bc00:	10000b1e 	bne	r2,zero,400bc30 <_dtoa_r+0x14c4>
#ifndef Sudden_Underflow
	  && word0 (d) & Exp_mask
 400bc04:	e0bfd617 	ldw	r2,-168(fp)
 400bc08:	109ffc2c 	andhi	r2,r2,32752
 400bc0c:	10000826 	beq	r2,zero,400bc30 <_dtoa_r+0x14c4>
#endif
	)
	{
	  /* The special case */
	  b2 += Log2P;
 400bc10:	e0bffb17 	ldw	r2,-20(fp)
 400bc14:	10800044 	addi	r2,r2,1
 400bc18:	e0bffb15 	stw	r2,-20(fp)
	  s2 += Log2P;
 400bc1c:	e0bfee17 	ldw	r2,-72(fp)
 400bc20:	10800044 	addi	r2,r2,1
 400bc24:	e0bfee15 	stw	r2,-72(fp)
	  spec_case = 1;
 400bc28:	00800044 	movi	r2,1
 400bc2c:	e0bfec15 	stw	r2,-80(fp)
   * and for all and pass them and a shift to quorem, so it
   * can do shifts and ors to compute the numerator for q.
   */

#ifdef Pack_32
  if ((i = ((s5 ? 32 - hi0bits (S->_x[S->_wds - 1]) : 1) + s2) & 0x1f) != 0)
 400bc30:	e0bfed17 	ldw	r2,-76(fp)
 400bc34:	10000e26 	beq	r2,zero,400bc70 <_dtoa_r+0x1504>
 400bc38:	e0bfe617 	ldw	r2,-104(fp)
 400bc3c:	10800417 	ldw	r2,16(r2)
 400bc40:	10bfffc4 	addi	r2,r2,-1
 400bc44:	e0ffe617 	ldw	r3,-104(fp)
 400bc48:	10800144 	addi	r2,r2,5
 400bc4c:	100490ba 	slli	r2,r2,2
 400bc50:	1885883a 	add	r2,r3,r2
 400bc54:	10800017 	ldw	r2,0(r2)
 400bc58:	1009883a 	mov	r4,r2
 400bc5c:	400fad40 	call	400fad4 <__hi0bits>
 400bc60:	1007883a 	mov	r3,r2
 400bc64:	00800804 	movi	r2,32
 400bc68:	10c5c83a 	sub	r2,r2,r3
 400bc6c:	00000106 	br	400bc74 <_dtoa_r+0x1508>
 400bc70:	00800044 	movi	r2,1
 400bc74:	e0ffee17 	ldw	r3,-72(fp)
 400bc78:	10c5883a 	add	r2,r2,r3
 400bc7c:	108007cc 	andi	r2,r2,31
 400bc80:	e0bff815 	stw	r2,-32(fp)
 400bc84:	e0bff817 	ldw	r2,-32(fp)
 400bc88:	10000426 	beq	r2,zero,400bc9c <_dtoa_r+0x1530>
    i = 32 - i;
 400bc8c:	00c00804 	movi	r3,32
 400bc90:	e0bff817 	ldw	r2,-32(fp)
 400bc94:	1885c83a 	sub	r2,r3,r2
 400bc98:	e0bff815 	stw	r2,-32(fp)
#else
  if ((i = ((s5 ? 32 - hi0bits (S->_x[S->_wds - 1]) : 1) + s2) & 0xf) != 0)
    i = 16 - i;
#endif
  if (i > 4)
 400bc9c:	e0bff817 	ldw	r2,-32(fp)
 400bca0:	10800150 	cmplti	r2,r2,5
 400bca4:	1000101e 	bne	r2,zero,400bce8 <_dtoa_r+0x157c>
    {
      i -= 4;
 400bca8:	e0bff817 	ldw	r2,-32(fp)
 400bcac:	10bfff04 	addi	r2,r2,-4
 400bcb0:	e0bff815 	stw	r2,-32(fp)
      b2 += i;
 400bcb4:	e0fffb17 	ldw	r3,-20(fp)
 400bcb8:	e0bff817 	ldw	r2,-32(fp)
 400bcbc:	1885883a 	add	r2,r3,r2
 400bcc0:	e0bffb15 	stw	r2,-20(fp)
      m2 += i;
 400bcc4:	e0fff017 	ldw	r3,-64(fp)
 400bcc8:	e0bff817 	ldw	r2,-32(fp)
 400bccc:	1885883a 	add	r2,r3,r2
 400bcd0:	e0bff015 	stw	r2,-64(fp)
      s2 += i;
 400bcd4:	e0ffee17 	ldw	r3,-72(fp)
 400bcd8:	e0bff817 	ldw	r2,-32(fp)
 400bcdc:	1885883a 	add	r2,r3,r2
 400bce0:	e0bfee15 	stw	r2,-72(fp)
 400bce4:	00001206 	br	400bd30 <_dtoa_r+0x15c4>
    }
  else if (i < 4)
 400bce8:	e0bff817 	ldw	r2,-32(fp)
 400bcec:	10800108 	cmpgei	r2,r2,4
 400bcf0:	10000f1e 	bne	r2,zero,400bd30 <_dtoa_r+0x15c4>
    {
      i += 28;
 400bcf4:	e0bff817 	ldw	r2,-32(fp)
 400bcf8:	10800704 	addi	r2,r2,28
 400bcfc:	e0bff815 	stw	r2,-32(fp)
      b2 += i;
 400bd00:	e0fffb17 	ldw	r3,-20(fp)
 400bd04:	e0bff817 	ldw	r2,-32(fp)
 400bd08:	1885883a 	add	r2,r3,r2
 400bd0c:	e0bffb15 	stw	r2,-20(fp)
      m2 += i;
 400bd10:	e0fff017 	ldw	r3,-64(fp)
 400bd14:	e0bff817 	ldw	r2,-32(fp)
 400bd18:	1885883a 	add	r2,r3,r2
 400bd1c:	e0bff015 	stw	r2,-64(fp)
      s2 += i;
 400bd20:	e0ffee17 	ldw	r3,-72(fp)
 400bd24:	e0bff817 	ldw	r2,-32(fp)
 400bd28:	1885883a 	add	r2,r3,r2
 400bd2c:	e0bfee15 	stw	r2,-72(fp)
    }
  if (b2 > 0)
 400bd30:	e0bffb17 	ldw	r2,-20(fp)
 400bd34:	0080050e 	bge	zero,r2,400bd4c <_dtoa_r+0x15e0>
    b = lshift (ptr, b, b2);
 400bd38:	e1bffb17 	ldw	r6,-20(fp)
 400bd3c:	e17fe917 	ldw	r5,-92(fp)
 400bd40:	e13fd017 	ldw	r4,-192(fp)
 400bd44:	401023c0 	call	401023c <__lshift>
 400bd48:	e0bfe915 	stw	r2,-92(fp)
  if (s2 > 0)
 400bd4c:	e0bfee17 	ldw	r2,-72(fp)
 400bd50:	0080050e 	bge	zero,r2,400bd68 <_dtoa_r+0x15fc>
    S = lshift (ptr, S, s2);
 400bd54:	e1bfee17 	ldw	r6,-72(fp)
 400bd58:	e17fe617 	ldw	r5,-104(fp)
 400bd5c:	e13fd017 	ldw	r4,-192(fp)
 400bd60:	401023c0 	call	401023c <__lshift>
 400bd64:	e0bfe615 	stw	r2,-104(fp)
  if (k_check)
 400bd68:	e0bff217 	ldw	r2,-56(fp)
 400bd6c:	10001726 	beq	r2,zero,400bdcc <_dtoa_r+0x1660>
    {
      if (cmp (b, S) < 0)
 400bd70:	e17fe617 	ldw	r5,-104(fp)
 400bd74:	e13fe917 	ldw	r4,-92(fp)
 400bd78:	40104580 	call	4010458 <__mcmp>
 400bd7c:	1000130e 	bge	r2,zero,400bdcc <_dtoa_r+0x1660>
	{
	  k--;
 400bd80:	e0bff317 	ldw	r2,-52(fp)
 400bd84:	10bfffc4 	addi	r2,r2,-1
 400bd88:	e0bff315 	stw	r2,-52(fp)
	  b = multadd (ptr, b, 10, 0);	/* we botched the k estimate */
 400bd8c:	000f883a 	mov	r7,zero
 400bd90:	01800284 	movi	r6,10
 400bd94:	e17fe917 	ldw	r5,-92(fp)
 400bd98:	e13fd017 	ldw	r4,-192(fp)
 400bd9c:	400f74c0 	call	400f74c <__multadd>
 400bda0:	e0bfe915 	stw	r2,-92(fp)
	  if (leftright)
 400bda4:	e0bff117 	ldw	r2,-60(fp)
 400bda8:	10000626 	beq	r2,zero,400bdc4 <_dtoa_r+0x1658>
	    mhi = multadd (ptr, mhi, 10, 0);
 400bdac:	000f883a 	mov	r7,zero
 400bdb0:	01800284 	movi	r6,10
 400bdb4:	e17fe717 	ldw	r5,-100(fp)
 400bdb8:	e13fd017 	ldw	r4,-192(fp)
 400bdbc:	400f74c0 	call	400f74c <__multadd>
 400bdc0:	e0bfe715 	stw	r2,-100(fp)
	  ilim = ilim1;
 400bdc4:	e0bff517 	ldw	r2,-44(fp)
 400bdc8:	e0bff615 	stw	r2,-40(fp)
	}
    }
  if (ilim <= 0 && mode > 2)
 400bdcc:	e0bff617 	ldw	r2,-40(fp)
 400bdd0:	00802516 	blt	zero,r2,400be68 <_dtoa_r+0x16fc>
 400bdd4:	e0bfcd17 	ldw	r2,-204(fp)
 400bdd8:	108000d0 	cmplti	r2,r2,3
 400bddc:	1000221e 	bne	r2,zero,400be68 <_dtoa_r+0x16fc>
    {
      if (ilim < 0 || cmp (b, S = multadd (ptr, S, 5, 0)) <= 0)
 400bde0:	e0bff617 	ldw	r2,-40(fp)
 400bde4:	10000f16 	blt	r2,zero,400be24 <_dtoa_r+0x16b8>
 400bde8:	000f883a 	mov	r7,zero
 400bdec:	01800144 	movi	r6,5
 400bdf0:	e17fe617 	ldw	r5,-104(fp)
 400bdf4:	e13fd017 	ldw	r4,-192(fp)
 400bdf8:	400f74c0 	call	400f74c <__multadd>
 400bdfc:	e0bfe615 	stw	r2,-104(fp)
 400be00:	e17fe617 	ldw	r5,-104(fp)
 400be04:	e13fe917 	ldw	r4,-92(fp)
 400be08:	40104580 	call	4010458 <__mcmp>
 400be0c:	00800c16 	blt	zero,r2,400be40 <_dtoa_r+0x16d4>
	{
	  /* no digits, fcvt style */
	no_digits:
 400be10:	00000406 	br	400be24 <_dtoa_r+0x16b8>
	    goto no_digits;
 400be14:	0001883a 	nop
 400be18:	00000306 	br	400be28 <_dtoa_r+0x16bc>
	    goto no_digits;
 400be1c:	0001883a 	nop
 400be20:	00000106 	br	400be28 <_dtoa_r+0x16bc>
	no_digits:
 400be24:	0001883a 	nop
	  k = -1 - ndigits;
 400be28:	e0800217 	ldw	r2,8(fp)
 400be2c:	0084303a 	nor	r2,zero,r2
 400be30:	e0bff315 	stw	r2,-52(fp)
	  goto ret;
 400be34:	00012c06 	br	400c2e8 <_dtoa_r+0x1b7c>
	    goto one_digit;
 400be38:	0001883a 	nop
 400be3c:	00000106 	br	400be44 <_dtoa_r+0x16d8>
	}
    one_digit:
 400be40:	0001883a 	nop
      *s++ = '1';
 400be44:	e0bfe317 	ldw	r2,-116(fp)
 400be48:	10c00044 	addi	r3,r2,1
 400be4c:	e0ffe315 	stw	r3,-116(fp)
 400be50:	00c00c44 	movi	r3,49
 400be54:	10c00005 	stb	r3,0(r2)
      k++;
 400be58:	e0bff317 	ldw	r2,-52(fp)
 400be5c:	10800044 	addi	r2,r2,1
 400be60:	e0bff315 	stw	r2,-52(fp)
      goto ret;
 400be64:	00012006 	br	400c2e8 <_dtoa_r+0x1b7c>
    }
  if (leftright)
 400be68:	e0bff117 	ldw	r2,-60(fp)
 400be6c:	1000c626 	beq	r2,zero,400c188 <_dtoa_r+0x1a1c>
    {
      if (m2 > 0)
 400be70:	e0bff017 	ldw	r2,-64(fp)
 400be74:	0080050e 	bge	zero,r2,400be8c <_dtoa_r+0x1720>
	mhi = lshift (ptr, mhi, m2);
 400be78:	e1bff017 	ldw	r6,-64(fp)
 400be7c:	e17fe717 	ldw	r5,-100(fp)
 400be80:	e13fd017 	ldw	r4,-192(fp)
 400be84:	401023c0 	call	401023c <__lshift>
 400be88:	e0bfe715 	stw	r2,-100(fp)

      /* Compute mlo -- check for special case
       * that d is a normalized power of 2.
       */

      mlo = mhi;
 400be8c:	e0bfe717 	ldw	r2,-100(fp)
 400be90:	e0bfe815 	stw	r2,-96(fp)
      if (spec_case)
 400be94:	e0bfec17 	ldw	r2,-80(fp)
 400be98:	10002226 	beq	r2,zero,400bf24 <_dtoa_r+0x17b8>
	{
	  mhi = eBalloc (ptr, mhi->_k);
 400be9c:	e0bfe717 	ldw	r2,-100(fp)
 400bea0:	10800117 	ldw	r2,4(r2)
 400bea4:	100b883a 	mov	r5,r2
 400bea8:	e13fd017 	ldw	r4,-192(fp)
 400beac:	400f5b40 	call	400f5b4 <_Balloc>
 400beb0:	e0bfda15 	stw	r2,-152(fp)
 400beb4:	e0bfda17 	ldw	r2,-152(fp)
 400beb8:	1000071e 	bne	r2,zero,400bed8 <_dtoa_r+0x176c>
 400bebc:	01c100b4 	movhi	r7,1026
 400bec0:	39eb2904 	addi	r7,r7,-21340
 400bec4:	000d883a 	mov	r6,zero
 400bec8:	0140ba84 	movi	r5,746
 400becc:	010100b4 	movhi	r4,1026
 400bed0:	212b2e04 	addi	r4,r4,-21320
 400bed4:	40138480 	call	4013848 <__assert_func>
 400bed8:	e0bfda17 	ldw	r2,-152(fp)
 400bedc:	e0bfe715 	stw	r2,-100(fp)
	  Bcopy (mhi, mlo);
 400bee0:	e0bfe717 	ldw	r2,-100(fp)
 400bee4:	10c00304 	addi	r3,r2,12
 400bee8:	e0bfe817 	ldw	r2,-96(fp)
 400beec:	11000304 	addi	r4,r2,12
 400bef0:	e0bfe817 	ldw	r2,-96(fp)
 400bef4:	10800417 	ldw	r2,16(r2)
 400bef8:	10800084 	addi	r2,r2,2
 400befc:	100490ba 	slli	r2,r2,2
 400bf00:	100d883a 	mov	r6,r2
 400bf04:	200b883a 	mov	r5,r4
 400bf08:	1809883a 	mov	r4,r3
 400bf0c:	40075cc0 	call	40075cc <memcpy>
	  mhi = lshift (ptr, mhi, Log2P);
 400bf10:	01800044 	movi	r6,1
 400bf14:	e17fe717 	ldw	r5,-100(fp)
 400bf18:	e13fd017 	ldw	r4,-192(fp)
 400bf1c:	401023c0 	call	401023c <__lshift>
 400bf20:	e0bfe715 	stw	r2,-100(fp)
	}

      for (i = 1;; i++)
 400bf24:	00800044 	movi	r2,1
 400bf28:	e0bff815 	stw	r2,-32(fp)
	{
	  dig = quorem (b, S) + '0';
 400bf2c:	e17fe617 	ldw	r5,-104(fp)
 400bf30:	e13fe917 	ldw	r4,-92(fp)
 400bf34:	400a3b80 	call	400a3b8 <quorem>
 400bf38:	10800c04 	addi	r2,r2,48
 400bf3c:	e0bff915 	stw	r2,-28(fp)
	  /* Do we yet have the shortest decimal string
	   * that will round to d?
	   */
	  j = cmp (b, mlo);
 400bf40:	e17fe817 	ldw	r5,-96(fp)
 400bf44:	e13fe917 	ldw	r4,-92(fp)
 400bf48:	40104580 	call	4010458 <__mcmp>
 400bf4c:	e0bff415 	stw	r2,-48(fp)
	  delta = diff (ptr, S, mhi);
 400bf50:	e1bfe717 	ldw	r6,-100(fp)
 400bf54:	e17fe617 	ldw	r5,-104(fp)
 400bf58:	e13fd017 	ldw	r4,-192(fp)
 400bf5c:	401055c0 	call	401055c <__mdiff>
 400bf60:	e0bfd915 	stw	r2,-156(fp)
	  j1 = delta->_sign ? 1 : cmp (b, delta);
 400bf64:	e0bfd917 	ldw	r2,-156(fp)
 400bf68:	10800317 	ldw	r2,12(r2)
 400bf6c:	1000041e 	bne	r2,zero,400bf80 <_dtoa_r+0x1814>
 400bf70:	e17fd917 	ldw	r5,-156(fp)
 400bf74:	e13fe917 	ldw	r4,-92(fp)
 400bf78:	40104580 	call	4010458 <__mcmp>
 400bf7c:	00000106 	br	400bf84 <_dtoa_r+0x1818>
 400bf80:	00800044 	movi	r2,1
 400bf84:	e0bfdd15 	stw	r2,-140(fp)
	  Bfree (ptr, delta);
 400bf88:	e17fd917 	ldw	r5,-156(fp)
 400bf8c:	e13fd017 	ldw	r4,-192(fp)
 400bf90:	400f6d80 	call	400f6d8 <_Bfree>
#ifndef ROUND_BIASED
	  if (j1 == 0 && !mode && !(word1 (d) & 1))
 400bf94:	e0bfdd17 	ldw	r2,-140(fp)
 400bf98:	1000131e 	bne	r2,zero,400bfe8 <_dtoa_r+0x187c>
 400bf9c:	e0bfcd17 	ldw	r2,-204(fp)
 400bfa0:	1000111e 	bne	r2,zero,400bfe8 <_dtoa_r+0x187c>
 400bfa4:	e0bfd517 	ldw	r2,-172(fp)
 400bfa8:	1080004c 	andi	r2,r2,1
 400bfac:	10000e1e 	bne	r2,zero,400bfe8 <_dtoa_r+0x187c>
	    {
	      if (dig == '9')
 400bfb0:	e0bff917 	ldw	r2,-28(fp)
 400bfb4:	10800e58 	cmpnei	r2,r2,57
 400bfb8:	10003726 	beq	r2,zero,400c098 <_dtoa_r+0x192c>
		goto round_9_up;
	      if (j > 0)
 400bfbc:	e0bff417 	ldw	r2,-48(fp)
 400bfc0:	0080030e 	bge	zero,r2,400bfd0 <_dtoa_r+0x1864>
		dig++;
 400bfc4:	e0bff917 	ldw	r2,-28(fp)
 400bfc8:	10800044 	addi	r2,r2,1
 400bfcc:	e0bff915 	stw	r2,-28(fp)
	      *s++ = dig;
 400bfd0:	e0bfe317 	ldw	r2,-116(fp)
 400bfd4:	10c00044 	addi	r3,r2,1
 400bfd8:	e0ffe315 	stw	r3,-116(fp)
 400bfdc:	e0fff917 	ldw	r3,-28(fp)
 400bfe0:	10c00005 	stb	r3,0(r2)
	      goto ret;
 400bfe4:	0000c006 	br	400c2e8 <_dtoa_r+0x1b7c>
	    }
#endif
         if ((j < 0) || ((j == 0) && !mode
 400bfe8:	e0bff417 	ldw	r2,-48(fp)
 400bfec:	10000716 	blt	r2,zero,400c00c <_dtoa_r+0x18a0>
 400bff0:	e0bff417 	ldw	r2,-48(fp)
 400bff4:	1000221e 	bne	r2,zero,400c080 <_dtoa_r+0x1914>
 400bff8:	e0bfcd17 	ldw	r2,-204(fp)
 400bffc:	1000201e 	bne	r2,zero,400c080 <_dtoa_r+0x1914>
#ifndef ROUND_BIASED
	      && !(word1 (d) & 1)
 400c000:	e0bfd517 	ldw	r2,-172(fp)
 400c004:	1080004c 	andi	r2,r2,1
 400c008:	10001d1e 	bne	r2,zero,400c080 <_dtoa_r+0x1914>
#endif
           ))
	    {
	      if (j1 > 0)
 400c00c:	e0bfdd17 	ldw	r2,-140(fp)
 400c010:	0080150e 	bge	zero,r2,400c068 <_dtoa_r+0x18fc>
		{
		  b = lshift (ptr, b, 1);
 400c014:	01800044 	movi	r6,1
 400c018:	e17fe917 	ldw	r5,-92(fp)
 400c01c:	e13fd017 	ldw	r4,-192(fp)
 400c020:	401023c0 	call	401023c <__lshift>
 400c024:	e0bfe915 	stw	r2,-92(fp)
		  j1 = cmp (b, S);
 400c028:	e17fe617 	ldw	r5,-104(fp)
 400c02c:	e13fe917 	ldw	r4,-92(fp)
 400c030:	40104580 	call	4010458 <__mcmp>
 400c034:	e0bfdd15 	stw	r2,-140(fp)
                 if (((j1 > 0) || ((j1 == 0) && (dig & 1)))
 400c038:	e0bfdd17 	ldw	r2,-140(fp)
 400c03c:	00800516 	blt	zero,r2,400c054 <_dtoa_r+0x18e8>
 400c040:	e0bfdd17 	ldw	r2,-140(fp)
 400c044:	1000081e 	bne	r2,zero,400c068 <_dtoa_r+0x18fc>
 400c048:	e0bff917 	ldw	r2,-28(fp)
 400c04c:	1080004c 	andi	r2,r2,1
 400c050:	10000526 	beq	r2,zero,400c068 <_dtoa_r+0x18fc>
		      && dig++ == '9')
 400c054:	e0bff917 	ldw	r2,-28(fp)
 400c058:	10c00044 	addi	r3,r2,1
 400c05c:	e0fff915 	stw	r3,-28(fp)
 400c060:	10800e58 	cmpnei	r2,r2,57
 400c064:	10000e26 	beq	r2,zero,400c0a0 <_dtoa_r+0x1934>
		    goto round_9_up;
		}
	      *s++ = dig;
 400c068:	e0bfe317 	ldw	r2,-116(fp)
 400c06c:	10c00044 	addi	r3,r2,1
 400c070:	e0ffe315 	stw	r3,-116(fp)
 400c074:	e0fff917 	ldw	r3,-28(fp)
 400c078:	10c00005 	stb	r3,0(r2)
	      goto ret;
 400c07c:	00009a06 	br	400c2e8 <_dtoa_r+0x1b7c>
	    }
	  if (j1 > 0)
 400c080:	e0bfdd17 	ldw	r2,-140(fp)
 400c084:	0080160e 	bge	zero,r2,400c0e0 <_dtoa_r+0x1974>
	    {
	      if (dig == '9')
 400c088:	e0bff917 	ldw	r2,-28(fp)
 400c08c:	10800e58 	cmpnei	r2,r2,57
 400c090:	10000a1e 	bne	r2,zero,400c0bc <_dtoa_r+0x1950>
		{		/* possible if i == 1 */
		round_9_up:
 400c094:	00000306 	br	400c0a4 <_dtoa_r+0x1938>
		goto round_9_up;
 400c098:	0001883a 	nop
 400c09c:	00000106 	br	400c0a4 <_dtoa_r+0x1938>
		    goto round_9_up;
 400c0a0:	0001883a 	nop
		  *s++ = '9';
 400c0a4:	e0bfe317 	ldw	r2,-116(fp)
 400c0a8:	10c00044 	addi	r3,r2,1
 400c0ac:	e0ffe315 	stw	r3,-116(fp)
 400c0b0:	00c00e44 	movi	r3,57
 400c0b4:	10c00005 	stb	r3,0(r2)
		  goto roundoff;
 400c0b8:	00006006 	br	400c23c <_dtoa_r+0x1ad0>
		}
	      *s++ = dig + 1;
 400c0bc:	e0bff917 	ldw	r2,-28(fp)
 400c0c0:	10800044 	addi	r2,r2,1
 400c0c4:	1009883a 	mov	r4,r2
 400c0c8:	e0bfe317 	ldw	r2,-116(fp)
 400c0cc:	10c00044 	addi	r3,r2,1
 400c0d0:	e0ffe315 	stw	r3,-116(fp)
 400c0d4:	2007883a 	mov	r3,r4
 400c0d8:	10c00005 	stb	r3,0(r2)
	      goto ret;
 400c0dc:	00008206 	br	400c2e8 <_dtoa_r+0x1b7c>
	    }
	  *s++ = dig;
 400c0e0:	e0bfe317 	ldw	r2,-116(fp)
 400c0e4:	10c00044 	addi	r3,r2,1
 400c0e8:	e0ffe315 	stw	r3,-116(fp)
 400c0ec:	e0fff917 	ldw	r3,-28(fp)
 400c0f0:	10c00005 	stb	r3,0(r2)
	  if (i == ilim)
 400c0f4:	e0fff817 	ldw	r3,-32(fp)
 400c0f8:	e0bff617 	ldw	r2,-40(fp)
 400c0fc:	18803b26 	beq	r3,r2,400c1ec <_dtoa_r+0x1a80>
	    break;
	  b = multadd (ptr, b, 10, 0);
 400c100:	000f883a 	mov	r7,zero
 400c104:	01800284 	movi	r6,10
 400c108:	e17fe917 	ldw	r5,-92(fp)
 400c10c:	e13fd017 	ldw	r4,-192(fp)
 400c110:	400f74c0 	call	400f74c <__multadd>
 400c114:	e0bfe915 	stw	r2,-92(fp)
	  if (mlo == mhi)
 400c118:	e0ffe817 	ldw	r3,-96(fp)
 400c11c:	e0bfe717 	ldw	r2,-100(fp)
 400c120:	1880091e 	bne	r3,r2,400c148 <_dtoa_r+0x19dc>
	    mlo = mhi = multadd (ptr, mhi, 10, 0);
 400c124:	000f883a 	mov	r7,zero
 400c128:	01800284 	movi	r6,10
 400c12c:	e17fe717 	ldw	r5,-100(fp)
 400c130:	e13fd017 	ldw	r4,-192(fp)
 400c134:	400f74c0 	call	400f74c <__multadd>
 400c138:	e0bfe715 	stw	r2,-100(fp)
 400c13c:	e0bfe717 	ldw	r2,-100(fp)
 400c140:	e0bfe815 	stw	r2,-96(fp)
 400c144:	00000c06 	br	400c178 <_dtoa_r+0x1a0c>
	  else
	    {
	      mlo = multadd (ptr, mlo, 10, 0);
 400c148:	000f883a 	mov	r7,zero
 400c14c:	01800284 	movi	r6,10
 400c150:	e17fe817 	ldw	r5,-96(fp)
 400c154:	e13fd017 	ldw	r4,-192(fp)
 400c158:	400f74c0 	call	400f74c <__multadd>
 400c15c:	e0bfe815 	stw	r2,-96(fp)
	      mhi = multadd (ptr, mhi, 10, 0);
 400c160:	000f883a 	mov	r7,zero
 400c164:	01800284 	movi	r6,10
 400c168:	e17fe717 	ldw	r5,-100(fp)
 400c16c:	e13fd017 	ldw	r4,-192(fp)
 400c170:	400f74c0 	call	400f74c <__multadd>
 400c174:	e0bfe715 	stw	r2,-100(fp)
      for (i = 1;; i++)
 400c178:	e0bff817 	ldw	r2,-32(fp)
 400c17c:	10800044 	addi	r2,r2,1
 400c180:	e0bff815 	stw	r2,-32(fp)
	  dig = quorem (b, S) + '0';
 400c184:	003f6906 	br	400bf2c <_dtoa_r+0x17c0>
	    }
	}
    }
  else
    for (i = 1;; i++)
 400c188:	00800044 	movi	r2,1
 400c18c:	e0bff815 	stw	r2,-32(fp)
      {
	*s++ = dig = quorem (b, S) + '0';
 400c190:	e17fe617 	ldw	r5,-104(fp)
 400c194:	e13fe917 	ldw	r4,-92(fp)
 400c198:	400a3b80 	call	400a3b8 <quorem>
 400c19c:	10800c04 	addi	r2,r2,48
 400c1a0:	e0bff915 	stw	r2,-28(fp)
 400c1a4:	e0bfe317 	ldw	r2,-116(fp)
 400c1a8:	10c00044 	addi	r3,r2,1
 400c1ac:	e0ffe315 	stw	r3,-116(fp)
 400c1b0:	e0fff917 	ldw	r3,-28(fp)
 400c1b4:	10c00005 	stb	r3,0(r2)
	if (i >= ilim)
 400c1b8:	e0fff817 	ldw	r3,-32(fp)
 400c1bc:	e0bff617 	ldw	r2,-40(fp)
 400c1c0:	18800c0e 	bge	r3,r2,400c1f4 <_dtoa_r+0x1a88>
	  break;
	b = multadd (ptr, b, 10, 0);
 400c1c4:	000f883a 	mov	r7,zero
 400c1c8:	01800284 	movi	r6,10
 400c1cc:	e17fe917 	ldw	r5,-92(fp)
 400c1d0:	e13fd017 	ldw	r4,-192(fp)
 400c1d4:	400f74c0 	call	400f74c <__multadd>
 400c1d8:	e0bfe915 	stw	r2,-92(fp)
    for (i = 1;; i++)
 400c1dc:	e0bff817 	ldw	r2,-32(fp)
 400c1e0:	10800044 	addi	r2,r2,1
 400c1e4:	e0bff815 	stw	r2,-32(fp)
	*s++ = dig = quorem (b, S) + '0';
 400c1e8:	003fe906 	br	400c190 <_dtoa_r+0x1a24>
	    break;
 400c1ec:	0001883a 	nop
 400c1f0:	00000106 	br	400c1f8 <_dtoa_r+0x1a8c>
	  break;
 400c1f4:	0001883a 	nop
      }

  /* Round off last digit */

  b = lshift (ptr, b, 1);
 400c1f8:	01800044 	movi	r6,1
 400c1fc:	e17fe917 	ldw	r5,-92(fp)
 400c200:	e13fd017 	ldw	r4,-192(fp)
 400c204:	401023c0 	call	401023c <__lshift>
 400c208:	e0bfe915 	stw	r2,-92(fp)
  j = cmp (b, S);
 400c20c:	e17fe617 	ldw	r5,-104(fp)
 400c210:	e13fe917 	ldw	r4,-92(fp)
 400c214:	40104580 	call	4010458 <__mcmp>
 400c218:	e0bff415 	stw	r2,-48(fp)
  if ((j > 0) || ((j == 0) && (dig & 1)))
 400c21c:	e0bff417 	ldw	r2,-48(fp)
 400c220:	00800516 	blt	zero,r2,400c238 <_dtoa_r+0x1acc>
 400c224:	e0bff417 	ldw	r2,-48(fp)
 400c228:	1000221e 	bne	r2,zero,400c2b4 <_dtoa_r+0x1b48>
 400c22c:	e0bff917 	ldw	r2,-28(fp)
 400c230:	1080004c 	andi	r2,r2,1
 400c234:	10001f26 	beq	r2,zero,400c2b4 <_dtoa_r+0x1b48>
    {
    roundoff:
 400c238:	0001883a 	nop
      while (*--s == '9')
 400c23c:	00000c06 	br	400c270 <_dtoa_r+0x1b04>
	if (s == s0)
 400c240:	e0ffe317 	ldw	r3,-116(fp)
 400c244:	e0bfe017 	ldw	r2,-128(fp)
 400c248:	1880091e 	bne	r3,r2,400c270 <_dtoa_r+0x1b04>
	  {
	    k++;
 400c24c:	e0bff317 	ldw	r2,-52(fp)
 400c250:	10800044 	addi	r2,r2,1
 400c254:	e0bff315 	stw	r2,-52(fp)
	    *s++ = '1';
 400c258:	e0bfe317 	ldw	r2,-116(fp)
 400c25c:	10c00044 	addi	r3,r2,1
 400c260:	e0ffe315 	stw	r3,-116(fp)
 400c264:	00c00c44 	movi	r3,49
 400c268:	10c00005 	stb	r3,0(r2)
	    goto ret;
 400c26c:	00001e06 	br	400c2e8 <_dtoa_r+0x1b7c>
      while (*--s == '9')
 400c270:	e0bfe317 	ldw	r2,-116(fp)
 400c274:	10bfffc4 	addi	r2,r2,-1
 400c278:	e0bfe315 	stw	r2,-116(fp)
 400c27c:	e0bfe317 	ldw	r2,-116(fp)
 400c280:	10800003 	ldbu	r2,0(r2)
 400c284:	10803fcc 	andi	r2,r2,255
 400c288:	1080201c 	xori	r2,r2,128
 400c28c:	10bfe004 	addi	r2,r2,-128
 400c290:	10800e60 	cmpeqi	r2,r2,57
 400c294:	103fea1e 	bne	r2,zero,400c240 <_dtoa_r+0x1ad4>
	  }
      ++*s++;
 400c298:	e0bfe317 	ldw	r2,-116(fp)
 400c29c:	10c00044 	addi	r3,r2,1
 400c2a0:	e0ffe315 	stw	r3,-116(fp)
 400c2a4:	10c00003 	ldbu	r3,0(r2)
 400c2a8:	18c00044 	addi	r3,r3,1
 400c2ac:	10c00005 	stb	r3,0(r2)
 400c2b0:	00000d06 	br	400c2e8 <_dtoa_r+0x1b7c>
    }
  else
    {
      while (*--s == '0');
 400c2b4:	e0bfe317 	ldw	r2,-116(fp)
 400c2b8:	10bfffc4 	addi	r2,r2,-1
 400c2bc:	e0bfe315 	stw	r2,-116(fp)
 400c2c0:	e0bfe317 	ldw	r2,-116(fp)
 400c2c4:	10800003 	ldbu	r2,0(r2)
 400c2c8:	10803fcc 	andi	r2,r2,255
 400c2cc:	1080201c 	xori	r2,r2,128
 400c2d0:	10bfe004 	addi	r2,r2,-128
 400c2d4:	10800c20 	cmpeqi	r2,r2,48
 400c2d8:	103ff61e 	bne	r2,zero,400c2b4 <_dtoa_r+0x1b48>
      s++;
 400c2dc:	e0bfe317 	ldw	r2,-116(fp)
 400c2e0:	10800044 	addi	r2,r2,1
 400c2e4:	e0bfe315 	stw	r2,-116(fp)
    }
ret:
  Bfree (ptr, S);
 400c2e8:	e17fe617 	ldw	r5,-104(fp)
 400c2ec:	e13fd017 	ldw	r4,-192(fp)
 400c2f0:	400f6d80 	call	400f6d8 <_Bfree>
  if (mhi)
 400c2f4:	e0bfe717 	ldw	r2,-100(fp)
 400c2f8:	10000e26 	beq	r2,zero,400c334 <_dtoa_r+0x1bc8>
    {
      if (mlo && mlo != mhi)
 400c2fc:	e0bfe817 	ldw	r2,-96(fp)
 400c300:	10000626 	beq	r2,zero,400c31c <_dtoa_r+0x1bb0>
 400c304:	e0ffe817 	ldw	r3,-96(fp)
 400c308:	e0bfe717 	ldw	r2,-100(fp)
 400c30c:	18800326 	beq	r3,r2,400c31c <_dtoa_r+0x1bb0>
	Bfree (ptr, mlo);
 400c310:	e17fe817 	ldw	r5,-96(fp)
 400c314:	e13fd017 	ldw	r4,-192(fp)
 400c318:	400f6d80 	call	400f6d8 <_Bfree>
      Bfree (ptr, mhi);
 400c31c:	e17fe717 	ldw	r5,-100(fp)
 400c320:	e13fd017 	ldw	r4,-192(fp)
 400c324:	400f6d80 	call	400f6d8 <_Bfree>
 400c328:	00000306 	br	400c338 <_dtoa_r+0x1bcc>
		goto ret1;
 400c32c:	0001883a 	nop
 400c330:	00000106 	br	400c338 <_dtoa_r+0x1bcc>
    }
ret1:
 400c334:	0001883a 	nop
  Bfree (ptr, b);
 400c338:	e17fe917 	ldw	r5,-92(fp)
 400c33c:	e13fd017 	ldw	r4,-192(fp)
 400c340:	400f6d80 	call	400f6d8 <_Bfree>
  *s = 0;
 400c344:	e0bfe317 	ldw	r2,-116(fp)
 400c348:	10000005 	stb	zero,0(r2)
  *decpt = k + 1;
 400c34c:	e0bff317 	ldw	r2,-52(fp)
 400c350:	10c00044 	addi	r3,r2,1
 400c354:	e0800317 	ldw	r2,12(fp)
 400c358:	10c00015 	stw	r3,0(r2)
  if (rve)
 400c35c:	e0800517 	ldw	r2,20(fp)
 400c360:	10000326 	beq	r2,zero,400c370 <_dtoa_r+0x1c04>
    *rve = s;
 400c364:	e0800517 	ldw	r2,20(fp)
 400c368:	e0ffe317 	ldw	r3,-116(fp)
 400c36c:	10c00015 	stw	r3,0(r2)
  return s0;
 400c370:	e0bfe017 	ldw	r2,-128(fp)
}
 400c374:	e6fffc04 	addi	sp,fp,-16
 400c378:	dfc00517 	ldw	ra,20(sp)
 400c37c:	df000417 	ldw	fp,16(sp)
 400c380:	dcc00317 	ldw	r19,12(sp)
 400c384:	dc800217 	ldw	r18,8(sp)
 400c388:	dc400117 	ldw	r17,4(sp)
 400c38c:	dc000017 	ldw	r16,0(sp)
 400c390:	dec00604 	addi	sp,sp,24
 400c394:	f800283a 	ret

0400c398 <__sflush_r>:
/* Core function which does not lock file pointer.  This gets called
   directly from __srefill. */
int
__sflush_r (struct _reent *ptr,
       register FILE * fp)
{
 400c398:	defff504 	addi	sp,sp,-44
 400c39c:	dfc00a15 	stw	ra,40(sp)
 400c3a0:	df000915 	stw	fp,36(sp)
 400c3a4:	dcc00815 	stw	r19,32(sp)
 400c3a8:	dc800715 	stw	r18,28(sp)
 400c3ac:	dc400615 	stw	r17,24(sp)
 400c3b0:	dc000515 	stw	r16,20(sp)
 400c3b4:	df000904 	addi	fp,sp,36
 400c3b8:	e13ff715 	stw	r4,-36(fp)
 400c3bc:	2821883a 	mov	r16,r5
  register unsigned char *p;
  register _READ_WRITE_BUFSIZE_TYPE n;
  register _READ_WRITE_RETURN_TYPE t;
  short flags;

  flags = fp->_flags;
 400c3c0:	8080030b 	ldhu	r2,12(r16)
 400c3c4:	e0bff98d 	sth	r2,-26(fp)
  if ((flags & __SWR) == 0)
 400c3c8:	e0bff98b 	ldhu	r2,-26(fp)
 400c3cc:	10bfffcc 	andi	r2,r2,65535
 400c3d0:	1080020c 	andi	r2,r2,8
 400c3d4:	1000831e 	bne	r2,zero,400c5e4 <__sflush_r+0x24c>
    {
#ifdef _FSEEK_OPTIMIZATION
      /* For a read stream, an fflush causes the next seek to be
         unoptimized (i.e. forces a system-level seek).  This conforms
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;
 400c3d8:	8080030b 	ldhu	r2,12(r16)
 400c3dc:	10820014 	ori	r2,r2,2048
 400c3e0:	8080030d 	sth	r2,12(r16)
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && fp->_seek != NULL)
 400c3e4:	80800117 	ldw	r2,4(r16)
 400c3e8:	00800216 	blt	zero,r2,400c3f4 <__sflush_r+0x5c>
 400c3ec:	80800f17 	ldw	r2,60(r16)
 400c3f0:	00807a0e 	bge	zero,r2,400c5dc <__sflush_r+0x244>
 400c3f4:	80800a17 	ldw	r2,40(r16)
 400c3f8:	10007826 	beq	r2,zero,400c5dc <__sflush_r+0x244>
#endif

	  /* Save last errno and set errno to 0, so we can check if a device
	     returns with a valid position -1.  We restore the last errno if
	     no other error condition has been encountered. */
	  tmp_errno = ptr->_errno;
 400c3fc:	e0bff717 	ldw	r2,-36(fp)
 400c400:	10800017 	ldw	r2,0(r2)
 400c404:	e0bff815 	stw	r2,-32(fp)
	  ptr->_errno = 0;
 400c408:	e0bff717 	ldw	r2,-36(fp)
 400c40c:	10000015 	stw	zero,0(r2)
	  /* Get the physical position we are at in the file.  */
	  if (fp->_flags & __SOFF)
 400c410:	8080030b 	ldhu	r2,12(r16)
 400c414:	10bfffcc 	andi	r2,r2,65535
 400c418:	1084000c 	andi	r2,r2,4096
 400c41c:	10000326 	beq	r2,zero,400c42c <__sflush_r+0x94>
	    curoff = fp->_offset;
 400c420:	80801417 	ldw	r2,80(r16)
 400c424:	e0bffb15 	stw	r2,-20(fp)
 400c428:	00002206 	br	400c4b4 <__sflush_r+0x11c>
#ifdef __LARGE64_FILES
	      if (fp->_flags & __SL64)
		curoff = fp->_seek64 (ptr, fp->_cookie, 0, SEEK_CUR);
	      else
#endif
		curoff = fp->_seek (ptr, fp->_cookie, 0, SEEK_CUR);
 400c42c:	80800a17 	ldw	r2,40(r16)
 400c430:	80c00717 	ldw	r3,28(r16)
 400c434:	01c00044 	movi	r7,1
 400c438:	000d883a 	mov	r6,zero
 400c43c:	180b883a 	mov	r5,r3
 400c440:	e13ff717 	ldw	r4,-36(fp)
 400c444:	103ee83a 	callr	r2
 400c448:	e0bffb15 	stw	r2,-20(fp)
	      if (curoff == -1L && ptr->_errno != 0)
 400c44c:	e0bffb17 	ldw	r2,-20(fp)
 400c450:	10bfffd8 	cmpnei	r2,r2,-1
 400c454:	1000171e 	bne	r2,zero,400c4b4 <__sflush_r+0x11c>
 400c458:	e0bff717 	ldw	r2,-36(fp)
 400c45c:	10800017 	ldw	r2,0(r2)
 400c460:	10001426 	beq	r2,zero,400c4b4 <__sflush_r+0x11c>
		{
		  int result = EOF;
 400c464:	00bfffc4 	movi	r2,-1
 400c468:	e0bffa15 	stw	r2,-24(fp)
		  if (ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
 400c46c:	e0bff717 	ldw	r2,-36(fp)
 400c470:	10800017 	ldw	r2,0(r2)
 400c474:	10800760 	cmpeqi	r2,r2,29
 400c478:	1000041e 	bne	r2,zero,400c48c <__sflush_r+0xf4>
 400c47c:	e0bff717 	ldw	r2,-36(fp)
 400c480:	10800017 	ldw	r2,0(r2)
 400c484:	10800598 	cmpnei	r2,r2,22
 400c488:	1000051e 	bne	r2,zero,400c4a0 <__sflush_r+0x108>
		    {
		      result = 0;
 400c48c:	e03ffa15 	stw	zero,-24(fp)
		      ptr->_errno = tmp_errno;
 400c490:	e0bff717 	ldw	r2,-36(fp)
 400c494:	e0fff817 	ldw	r3,-32(fp)
 400c498:	10c00015 	stw	r3,0(r2)
 400c49c:	00000306 	br	400c4ac <__sflush_r+0x114>
		    }
		  else
		    fp->_flags |= __SERR;
 400c4a0:	8080030b 	ldhu	r2,12(r16)
 400c4a4:	10801014 	ori	r2,r2,64
 400c4a8:	8080030d 	sth	r2,12(r16)
		  return result;
 400c4ac:	e0bffa17 	ldw	r2,-24(fp)
 400c4b0:	00006f06 	br	400c670 <__sflush_r+0x2d8>
		}
            }
          if (fp->_flags & __SRD)
 400c4b4:	8080030b 	ldhu	r2,12(r16)
 400c4b8:	10bfffcc 	andi	r2,r2,65535
 400c4bc:	1080010c 	andi	r2,r2,4
 400c4c0:	10000a26 	beq	r2,zero,400c4ec <__sflush_r+0x154>
            {
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
              curoff -= fp->_r;
 400c4c4:	80800117 	ldw	r2,4(r16)
 400c4c8:	e0fffb17 	ldw	r3,-20(fp)
 400c4cc:	1885c83a 	sub	r2,r3,r2
 400c4d0:	e0bffb15 	stw	r2,-20(fp)
              if (HASUB (fp))
 400c4d4:	80800c17 	ldw	r2,48(r16)
 400c4d8:	10000426 	beq	r2,zero,400c4ec <__sflush_r+0x154>
                curoff -= fp->_ur;
 400c4dc:	80800f17 	ldw	r2,60(r16)
 400c4e0:	e0fffb17 	ldw	r3,-20(fp)
 400c4e4:	1885c83a 	sub	r2,r3,r2
 400c4e8:	e0bffb15 	stw	r2,-20(fp)
#ifdef __LARGE64_FILES
	  if (fp->_flags & __SL64)
	    curoff = fp->_seek64 (ptr, fp->_cookie, curoff, SEEK_SET);
	  else
#endif
	    curoff = fp->_seek (ptr, fp->_cookie, curoff, SEEK_SET);
 400c4ec:	80800a17 	ldw	r2,40(r16)
 400c4f0:	80c00717 	ldw	r3,28(r16)
 400c4f4:	000f883a 	mov	r7,zero
 400c4f8:	e1bffb17 	ldw	r6,-20(fp)
 400c4fc:	180b883a 	mov	r5,r3
 400c500:	e13ff717 	ldw	r4,-36(fp)
 400c504:	103ee83a 	callr	r2
 400c508:	e0bffb15 	stw	r2,-20(fp)
	  if (curoff != -1 || ptr->_errno == 0
 400c50c:	e0bffb17 	ldw	r2,-20(fp)
 400c510:	10bfffd8 	cmpnei	r2,r2,-1
 400c514:	10000b1e 	bne	r2,zero,400c544 <__sflush_r+0x1ac>
 400c518:	e0bff717 	ldw	r2,-36(fp)
 400c51c:	10800017 	ldw	r2,0(r2)
 400c520:	10000826 	beq	r2,zero,400c544 <__sflush_r+0x1ac>
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
 400c524:	e0bff717 	ldw	r2,-36(fp)
 400c528:	10800017 	ldw	r2,0(r2)
 400c52c:	10800760 	cmpeqi	r2,r2,29
 400c530:	1000041e 	bne	r2,zero,400c544 <__sflush_r+0x1ac>
 400c534:	e0bff717 	ldw	r2,-36(fp)
 400c538:	10800017 	ldw	r2,0(r2)
 400c53c:	10800598 	cmpnei	r2,r2,22
 400c540:	1000211e 	bne	r2,zero,400c5c8 <__sflush_r+0x230>
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
 400c544:	80c0030b 	ldhu	r3,12(r16)
 400c548:	00bdffc4 	movi	r2,-2049
 400c54c:	1884703a 	and	r2,r3,r2
 400c550:	8080030d 	sth	r2,12(r16)
#endif
	      fp->_r = 0;
 400c554:	80000115 	stw	zero,4(r16)
	      fp->_p = fp->_bf._base;
 400c558:	80800417 	ldw	r2,16(r16)
 400c55c:	80800015 	stw	r2,0(r16)
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
 400c560:	8080030b 	ldhu	r2,12(r16)
 400c564:	10bfffcc 	andi	r2,r2,65535
 400c568:	1084000c 	andi	r2,r2,4096
 400c56c:	10000826 	beq	r2,zero,400c590 <__sflush_r+0x1f8>
 400c570:	e0bffb17 	ldw	r2,-20(fp)
 400c574:	10bfffd8 	cmpnei	r2,r2,-1
 400c578:	1000031e 	bne	r2,zero,400c588 <__sflush_r+0x1f0>
 400c57c:	e0bff717 	ldw	r2,-36(fp)
 400c580:	10800017 	ldw	r2,0(r2)
 400c584:	1000021e 	bne	r2,zero,400c590 <__sflush_r+0x1f8>
		fp->_offset = curoff;
 400c588:	e0bffb17 	ldw	r2,-20(fp)
 400c58c:	80801415 	stw	r2,80(r16)
	      ptr->_errno = tmp_errno;
 400c590:	e0bff717 	ldw	r2,-36(fp)
 400c594:	e0fff817 	ldw	r3,-32(fp)
 400c598:	10c00015 	stw	r3,0(r2)
	      if (HASUB (fp))
 400c59c:	80800c17 	ldw	r2,48(r16)
 400c5a0:	10000e26 	beq	r2,zero,400c5dc <__sflush_r+0x244>
		FREEUB (ptr, fp);
 400c5a4:	80c00c17 	ldw	r3,48(r16)
 400c5a8:	80801004 	addi	r2,r16,64
 400c5ac:	18800426 	beq	r3,r2,400c5c0 <__sflush_r+0x228>
 400c5b0:	80800c17 	ldw	r2,48(r16)
 400c5b4:	100b883a 	mov	r5,r2
 400c5b8:	e13ff717 	ldw	r4,-36(fp)
 400c5bc:	400cdd80 	call	400cdd8 <_free_r>
 400c5c0:	80000c15 	stw	zero,48(r16)
	      if (HASUB (fp))
 400c5c4:	00000506 	br	400c5dc <__sflush_r+0x244>
	    }
	  else
	    {
	      fp->_flags |= __SERR;
 400c5c8:	8080030b 	ldhu	r2,12(r16)
 400c5cc:	10801014 	ori	r2,r2,64
 400c5d0:	8080030d 	sth	r2,12(r16)
	      return EOF;
 400c5d4:	00bfffc4 	movi	r2,-1
 400c5d8:	00002506 	br	400c670 <__sflush_r+0x2d8>
	    }
	}
      return 0;
 400c5dc:	0005883a 	mov	r2,zero
 400c5e0:	00002306 	br	400c670 <__sflush_r+0x2d8>
    }
  if ((p = fp->_bf._base) == NULL)
 400c5e4:	84400417 	ldw	r17,16(r16)
 400c5e8:	8800021e 	bne	r17,zero,400c5f4 <__sflush_r+0x25c>
    {
      /* Nothing to flush.  */
      return 0;
 400c5ec:	0005883a 	mov	r2,zero
 400c5f0:	00001f06 	br	400c670 <__sflush_r+0x2d8>
    }
  n = fp->_p - p;		/* write this much */
 400c5f4:	80800017 	ldw	r2,0(r16)
 400c5f8:	1465c83a 	sub	r18,r2,r17
  /*
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
   */
  fp->_p = p;
 400c5fc:	84400015 	stw	r17,0(r16)
  fp->_w = flags & (__SLBF | __SNBF) ? 0 : fp->_bf._size;
 400c600:	e0bff98b 	ldhu	r2,-26(fp)
 400c604:	10bfffcc 	andi	r2,r2,65535
 400c608:	108000cc 	andi	r2,r2,3
 400c60c:	1000021e 	bne	r2,zero,400c618 <__sflush_r+0x280>
 400c610:	80800517 	ldw	r2,20(r16)
 400c614:	00000106 	br	400c61c <__sflush_r+0x284>
 400c618:	0005883a 	mov	r2,zero
 400c61c:	80800215 	stw	r2,8(r16)

  while (n > 0)
 400c620:	00001106 	br	400c668 <__sflush_r+0x2d0>
    {
      t = fp->_write (ptr, fp->_cookie, (char *) p, n);
 400c624:	80800917 	ldw	r2,36(r16)
 400c628:	80c00717 	ldw	r3,28(r16)
 400c62c:	900f883a 	mov	r7,r18
 400c630:	880d883a 	mov	r6,r17
 400c634:	180b883a 	mov	r5,r3
 400c638:	e13ff717 	ldw	r4,-36(fp)
 400c63c:	103ee83a 	callr	r2
 400c640:	1027883a 	mov	r19,r2
      if (t <= 0)
 400c644:	04c00516 	blt	zero,r19,400c65c <__sflush_r+0x2c4>
	{
          fp->_flags |= __SERR;
 400c648:	8080030b 	ldhu	r2,12(r16)
 400c64c:	10801014 	ori	r2,r2,64
 400c650:	8080030d 	sth	r2,12(r16)
          return EOF;
 400c654:	00bfffc4 	movi	r2,-1
 400c658:	00000506 	br	400c670 <__sflush_r+0x2d8>
	}
      p += t;
 400c65c:	9805883a 	mov	r2,r19
 400c660:	88a3883a 	add	r17,r17,r2
      n -= t;
 400c664:	94e5c83a 	sub	r18,r18,r19
  while (n > 0)
 400c668:	04bfee16 	blt	zero,r18,400c624 <__sflush_r+0x28c>
    }
  return 0;
 400c66c:	0005883a 	mov	r2,zero
}
 400c670:	e6fffc04 	addi	sp,fp,-16
 400c674:	dfc00517 	ldw	ra,20(sp)
 400c678:	df000417 	ldw	fp,16(sp)
 400c67c:	dcc00317 	ldw	r19,12(sp)
 400c680:	dc800217 	ldw	r18,8(sp)
 400c684:	dc400117 	ldw	r17,4(sp)
 400c688:	dc000017 	ldw	r16,0(sp)
 400c68c:	dec00604 	addi	sp,sp,24
 400c690:	f800283a 	ret

0400c694 <_fflush_r>:
#endif /* __IMPL_UNLOCKED__ */

int
_fflush_r (struct _reent *ptr,
       register FILE * fp)
{
 400c694:	defffa04 	addi	sp,sp,-24
 400c698:	dfc00515 	stw	ra,20(sp)
 400c69c:	df000415 	stw	fp,16(sp)
 400c6a0:	dc000315 	stw	r16,12(sp)
 400c6a4:	df000404 	addi	fp,sp,16
 400c6a8:	e13ffc15 	stw	r4,-16(fp)
 400c6ac:	2821883a 	mov	r16,r5
     2 is implemented here due to its simplicity.  */
  if (fp->_bf._base == NULL)
    return 0;
#endif /* _REENT_SMALL  */

  CHECK_INIT (ptr, fp);
 400c6b0:	e0bffc17 	ldw	r2,-16(fp)
 400c6b4:	e0bffe15 	stw	r2,-8(fp)
 400c6b8:	e0bffe17 	ldw	r2,-8(fp)
 400c6bc:	10000526 	beq	r2,zero,400c6d4 <_fflush_r+0x40>
 400c6c0:	e0bffe17 	ldw	r2,-8(fp)
 400c6c4:	10800e17 	ldw	r2,56(r2)
 400c6c8:	1000021e 	bne	r2,zero,400c6d4 <_fflush_r+0x40>
 400c6cc:	e13ffe17 	ldw	r4,-8(fp)
 400c6d0:	400cbdc0 	call	400cbdc <__sinit>

  if (!fp->_flags)
 400c6d4:	8080030b 	ldhu	r2,12(r16)
 400c6d8:	10bfffcc 	andi	r2,r2,65535
 400c6dc:	10a0001c 	xori	r2,r2,32768
 400c6e0:	10a00004 	addi	r2,r2,-32768
 400c6e4:	1000021e 	bne	r2,zero,400c6f0 <_fflush_r+0x5c>
    return 0;
 400c6e8:	0005883a 	mov	r2,zero
 400c6ec:	00000506 	br	400c704 <_fflush_r+0x70>

  _newlib_flockfile_start (fp);
  ret = __sflush_r (ptr, fp);
 400c6f0:	800b883a 	mov	r5,r16
 400c6f4:	e13ffc17 	ldw	r4,-16(fp)
 400c6f8:	400c3980 	call	400c398 <__sflush_r>
 400c6fc:	e0bffd15 	stw	r2,-12(fp)
  _newlib_flockfile_end (fp);
  return ret;
 400c700:	e0bffd17 	ldw	r2,-12(fp)
}
 400c704:	e6ffff04 	addi	sp,fp,-4
 400c708:	dfc00217 	ldw	ra,8(sp)
 400c70c:	df000117 	ldw	fp,4(sp)
 400c710:	dc000017 	ldw	r16,0(sp)
 400c714:	dec00304 	addi	sp,sp,12
 400c718:	f800283a 	ret

0400c71c <fflush>:

#ifndef _REENT_ONLY

int
fflush (register FILE * fp)
{
 400c71c:	defffe04 	addi	sp,sp,-8
 400c720:	dfc00115 	stw	ra,4(sp)
 400c724:	df000015 	stw	fp,0(sp)
 400c728:	d839883a 	mov	fp,sp
 400c72c:	2005883a 	mov	r2,r4
  if (fp == NULL)
 400c730:	1000061e 	bne	r2,zero,400c74c <fflush+0x30>
    return _fwalk_reent (_GLOBAL_REENT, _fflush_r);
 400c734:	d0a00217 	ldw	r2,-32760(gp)
 400c738:	01410074 	movhi	r5,1025
 400c73c:	2971a504 	addi	r5,r5,-14700
 400c740:	1009883a 	mov	r4,r2
 400c744:	400dbb40 	call	400dbb4 <_fwalk_reent>
 400c748:	00000406 	br	400c75c <fflush+0x40>

  return _fflush_r (_REENT, fp);
 400c74c:	d0e00117 	ldw	r3,-32764(gp)
 400c750:	100b883a 	mov	r5,r2
 400c754:	1809883a 	mov	r4,r3
 400c758:	400c6940 	call	400c694 <_fflush_r>
}
 400c75c:	e037883a 	mov	sp,fp
 400c760:	dfc00117 	ldw	ra,4(sp)
 400c764:	df000017 	ldw	fp,0(sp)
 400c768:	dec00204 	addi	sp,sp,8
 400c76c:	f800283a 	ret

0400c770 <std>:
static void
#endif
std (FILE *ptr,
            int flags,
            int file)
{
 400c770:	defffb04 	addi	sp,sp,-20
 400c774:	dfc00415 	stw	ra,16(sp)
 400c778:	df000315 	stw	fp,12(sp)
 400c77c:	df000304 	addi	fp,sp,12
 400c780:	e13fff15 	stw	r4,-4(fp)
 400c784:	e17ffe15 	stw	r5,-8(fp)
 400c788:	e1bffd15 	stw	r6,-12(fp)
  ptr->_p = 0;
 400c78c:	e0bfff17 	ldw	r2,-4(fp)
 400c790:	10000015 	stw	zero,0(r2)
  ptr->_r = 0;
 400c794:	e0bfff17 	ldw	r2,-4(fp)
 400c798:	10000115 	stw	zero,4(r2)
  ptr->_w = 0;
 400c79c:	e0bfff17 	ldw	r2,-4(fp)
 400c7a0:	10000215 	stw	zero,8(r2)
  ptr->_flags = flags;
 400c7a4:	e0bffe17 	ldw	r2,-8(fp)
 400c7a8:	1007883a 	mov	r3,r2
 400c7ac:	e0bfff17 	ldw	r2,-4(fp)
 400c7b0:	10c0030d 	sth	r3,12(r2)
  ptr->_flags2 = 0;
 400c7b4:	e0bfff17 	ldw	r2,-4(fp)
 400c7b8:	10001915 	stw	zero,100(r2)
  ptr->_file = file;
 400c7bc:	e0bffd17 	ldw	r2,-12(fp)
 400c7c0:	1007883a 	mov	r3,r2
 400c7c4:	e0bfff17 	ldw	r2,-4(fp)
 400c7c8:	10c0038d 	sth	r3,14(r2)
  ptr->_bf._base = 0;
 400c7cc:	e0bfff17 	ldw	r2,-4(fp)
 400c7d0:	10000415 	stw	zero,16(r2)
  ptr->_bf._size = 0;
 400c7d4:	e0bfff17 	ldw	r2,-4(fp)
 400c7d8:	10000515 	stw	zero,20(r2)
  ptr->_lbfsize = 0;
 400c7dc:	e0bfff17 	ldw	r2,-4(fp)
 400c7e0:	10000615 	stw	zero,24(r2)
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
 400c7e4:	e0bfff17 	ldw	r2,-4(fp)
 400c7e8:	10801704 	addi	r2,r2,92
 400c7ec:	01800204 	movi	r6,8
 400c7f0:	000b883a 	mov	r5,zero
 400c7f4:	1009883a 	mov	r4,r2
 400c7f8:	40077540 	call	4007754 <memset>
  ptr->_cookie = ptr;
 400c7fc:	e0bfff17 	ldw	r2,-4(fp)
 400c800:	e0ffff17 	ldw	r3,-4(fp)
 400c804:	10c00715 	stw	r3,28(r2)
  ptr->_read = __sread;
 400c808:	e0ffff17 	ldw	r3,-4(fp)
 400c80c:	00810074 	movhi	r2,1025
 400c810:	10876004 	addi	r2,r2,7552
 400c814:	18800815 	stw	r2,32(r3)
#ifndef __LARGE64_FILES
  ptr->_write = __swrite;
 400c818:	e0ffff17 	ldw	r3,-4(fp)
 400c81c:	00810074 	movhi	r2,1025
 400c820:	10879304 	addi	r2,r2,7756
 400c824:	18800915 	stw	r2,36(r3)
#else /* __LARGE64_FILES */
  ptr->_write = __swrite64;
  ptr->_seek64 = __sseek64;
  ptr->_flags |= __SL64;
#endif /* __LARGE64_FILES */
  ptr->_seek = __sseek;
 400c828:	e0ffff17 	ldw	r3,-4(fp)
 400c82c:	00810074 	movhi	r2,1025
 400c830:	1087c004 	addi	r2,r2,7936
 400c834:	18800a15 	stw	r2,40(r3)
#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
  ptr->_close = __sclose;
 400c838:	e0ffff17 	ldw	r3,-4(fp)
 400c83c:	00810074 	movhi	r2,1025
 400c840:	1087e804 	addi	r2,r2,8096
 400c844:	18800b15 	stw	r2,44(r3)

#ifdef __SCLE
  if (__stextmode (ptr->_file))
    ptr->_flags |= __SCLE;
#endif
}
 400c848:	0001883a 	nop
 400c84c:	e037883a 	mov	sp,fp
 400c850:	dfc00117 	ldw	ra,4(sp)
 400c854:	df000017 	ldw	fp,0(sp)
 400c858:	dec00204 	addi	sp,sp,8
 400c85c:	f800283a 	ret

0400c860 <stdin_init>:

static inline void
stdin_init(FILE *ptr)
{
 400c860:	defffd04 	addi	sp,sp,-12
 400c864:	dfc00215 	stw	ra,8(sp)
 400c868:	df000115 	stw	fp,4(sp)
 400c86c:	df000104 	addi	fp,sp,4
 400c870:	e13fff15 	stw	r4,-4(fp)
  std (ptr,  __SRD, 0);
 400c874:	000d883a 	mov	r6,zero
 400c878:	01400104 	movi	r5,4
 400c87c:	e13fff17 	ldw	r4,-4(fp)
 400c880:	400c7700 	call	400c770 <std>
}
 400c884:	0001883a 	nop
 400c888:	e037883a 	mov	sp,fp
 400c88c:	dfc00117 	ldw	ra,4(sp)
 400c890:	df000017 	ldw	fp,0(sp)
 400c894:	dec00204 	addi	sp,sp,8
 400c898:	f800283a 	ret

0400c89c <stdout_init>:

static inline void
stdout_init(FILE *ptr)
{
 400c89c:	defffd04 	addi	sp,sp,-12
 400c8a0:	dfc00215 	stw	ra,8(sp)
 400c8a4:	df000115 	stw	fp,4(sp)
 400c8a8:	df000104 	addi	fp,sp,4
 400c8ac:	e13fff15 	stw	r4,-4(fp)
#ifdef HAVE_FCNTL
/*std (ptr, __SWR, 1); */
  std (ptr, __SWR | __SNBF, 1);	/* IntelSpecific: Change to have no buffering on stdout. */
#else
/*std (ptr, __SWR | __SLBF, 1); */
  std (ptr, __SWR | __SNBF, 1);	/* IntelSpecific: Change to have no buffering on stdout. */
 400c8b0:	01800044 	movi	r6,1
 400c8b4:	01400284 	movi	r5,10
 400c8b8:	e13fff17 	ldw	r4,-4(fp)
 400c8bc:	400c7700 	call	400c770 <std>
#endif
}
 400c8c0:	0001883a 	nop
 400c8c4:	e037883a 	mov	sp,fp
 400c8c8:	dfc00117 	ldw	ra,4(sp)
 400c8cc:	df000017 	ldw	fp,0(sp)
 400c8d0:	dec00204 	addi	sp,sp,8
 400c8d4:	f800283a 	ret

0400c8d8 <stderr_init>:

static inline void
stderr_init(FILE *ptr)
{
 400c8d8:	defffd04 	addi	sp,sp,-12
 400c8dc:	dfc00215 	stw	ra,8(sp)
 400c8e0:	df000115 	stw	fp,4(sp)
 400c8e4:	df000104 	addi	fp,sp,4
 400c8e8:	e13fff15 	stw	r4,-4(fp)
  /* POSIX requires stderr to be opened for reading and writing, even
     when the underlying fd 2 is write-only.  */
  std (ptr, __SRW | __SNBF, 2);
 400c8ec:	01800084 	movi	r6,2
 400c8f0:	01400484 	movi	r5,18
 400c8f4:	e13fff17 	ldw	r4,-4(fp)
 400c8f8:	400c7700 	call	400c770 <std>
}
 400c8fc:	0001883a 	nop
 400c900:	e037883a 	mov	sp,fp
 400c904:	dfc00117 	ldw	ra,4(sp)
 400c908:	df000017 	ldw	fp,0(sp)
 400c90c:	dec00204 	addi	sp,sp,8
 400c910:	f800283a 	ret

0400c914 <__sfmoreglue>:
};

struct _glue *
__sfmoreglue (struct _reent *d,
       register int n)
{
 400c914:	defffa04 	addi	sp,sp,-24
 400c918:	dfc00515 	stw	ra,20(sp)
 400c91c:	df000415 	stw	fp,16(sp)
 400c920:	dc400315 	stw	r17,12(sp)
 400c924:	dc000215 	stw	r16,8(sp)
 400c928:	df000404 	addi	fp,sp,16
 400c92c:	e13ffc15 	stw	r4,-16(fp)
 400c930:	2821883a 	mov	r16,r5
  struct glue_with_file *g;

  g = (struct glue_with_file *)
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
 400c934:	80bfffc4 	addi	r2,r16,-1
 400c938:	01401a04 	movi	r5,104
 400c93c:	1009883a 	mov	r4,r2
 400c940:	40075a40 	call	40075a4 <__mulsi3>
 400c944:	10801d04 	addi	r2,r2,116
 400c948:	100b883a 	mov	r5,r2
 400c94c:	e13ffc17 	ldw	r4,-16(fp)
 400c950:	400e5500 	call	400e550 <_malloc_r>
 400c954:	e0bffd15 	stw	r2,-12(fp)
  if (g == NULL)
 400c958:	e0bffd17 	ldw	r2,-12(fp)
 400c95c:	1000021e 	bne	r2,zero,400c968 <__sfmoreglue+0x54>
    return NULL;
 400c960:	0005883a 	mov	r2,zero
 400c964:	00001306 	br	400c9b4 <__sfmoreglue+0xa0>
  g->glue._next = NULL;
 400c968:	e0bffd17 	ldw	r2,-12(fp)
 400c96c:	10000015 	stw	zero,0(r2)
  g->glue._niobs = n;
 400c970:	e0bffd17 	ldw	r2,-12(fp)
 400c974:	14000115 	stw	r16,4(r2)
  g->glue._iobs = &g->file;
 400c978:	e0bffd17 	ldw	r2,-12(fp)
 400c97c:	10c00304 	addi	r3,r2,12
 400c980:	e0bffd17 	ldw	r2,-12(fp)
 400c984:	10c00215 	stw	r3,8(r2)
  memset (&g->file, 0, n * sizeof (FILE));
 400c988:	e0bffd17 	ldw	r2,-12(fp)
 400c98c:	14400304 	addi	r17,r2,12
 400c990:	8005883a 	mov	r2,r16
 400c994:	01401a04 	movi	r5,104
 400c998:	1009883a 	mov	r4,r2
 400c99c:	40075a40 	call	40075a4 <__mulsi3>
 400c9a0:	100d883a 	mov	r6,r2
 400c9a4:	000b883a 	mov	r5,zero
 400c9a8:	8809883a 	mov	r4,r17
 400c9ac:	40077540 	call	4007754 <memset>
  return &g->glue;
 400c9b0:	e0bffd17 	ldw	r2,-12(fp)
}
 400c9b4:	e6fffe04 	addi	sp,fp,-8
 400c9b8:	dfc00317 	ldw	ra,12(sp)
 400c9bc:	df000217 	ldw	fp,8(sp)
 400c9c0:	dc400117 	ldw	r17,4(sp)
 400c9c4:	dc000017 	ldw	r16,0(sp)
 400c9c8:	dec00404 	addi	sp,sp,16
 400c9cc:	f800283a 	ret

0400c9d0 <__sfp>:
 * Find a free FILE for fopen et al.
 */

FILE *
__sfp (struct _reent *d)
{
 400c9d0:	defffa04 	addi	sp,sp,-24
 400c9d4:	dfc00515 	stw	ra,20(sp)
 400c9d8:	df000415 	stw	fp,16(sp)
 400c9dc:	df000404 	addi	fp,sp,16
 400c9e0:	e13ffc15 	stw	r4,-16(fp)
  FILE *fp;
  int n;
  struct _glue *g;

  _newlib_sfp_lock_start ();
 400c9e4:	400cc900 	call	400cc90 <__sfp_lock_acquire>

  if (!_GLOBAL_REENT->__sdidinit)
 400c9e8:	d0a00217 	ldw	r2,-32760(gp)
 400c9ec:	10800e17 	ldw	r2,56(r2)
 400c9f0:	1000031e 	bne	r2,zero,400ca00 <__sfp+0x30>
    __sinit (_GLOBAL_REENT);
 400c9f4:	d0a00217 	ldw	r2,-32760(gp)
 400c9f8:	1009883a 	mov	r4,r2
 400c9fc:	400cbdc0 	call	400cbdc <__sinit>
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
 400ca00:	d0a00217 	ldw	r2,-32760(gp)
 400ca04:	1080b804 	addi	r2,r2,736
 400ca08:	e0bffd15 	stw	r2,-12(fp)
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
 400ca0c:	e0bffd17 	ldw	r2,-12(fp)
 400ca10:	10800217 	ldw	r2,8(r2)
 400ca14:	e0bfff15 	stw	r2,-4(fp)
 400ca18:	e0bffd17 	ldw	r2,-12(fp)
 400ca1c:	10800117 	ldw	r2,4(r2)
 400ca20:	e0bffe15 	stw	r2,-8(fp)
 400ca24:	00000906 	br	400ca4c <__sfp+0x7c>
	if (fp->_flags == 0)
 400ca28:	e0bfff17 	ldw	r2,-4(fp)
 400ca2c:	1080030b 	ldhu	r2,12(r2)
 400ca30:	10bfffcc 	andi	r2,r2,65535
 400ca34:	10a0001c 	xori	r2,r2,32768
 400ca38:	10a00004 	addi	r2,r2,-32768
 400ca3c:	10001f26 	beq	r2,zero,400cabc <__sfp+0xec>
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
 400ca40:	e0bfff17 	ldw	r2,-4(fp)
 400ca44:	10801a04 	addi	r2,r2,104
 400ca48:	e0bfff15 	stw	r2,-4(fp)
 400ca4c:	e0bffe17 	ldw	r2,-8(fp)
 400ca50:	10bfffc4 	addi	r2,r2,-1
 400ca54:	e0bffe15 	stw	r2,-8(fp)
 400ca58:	e0bffe17 	ldw	r2,-8(fp)
 400ca5c:	103ff20e 	bge	r2,zero,400ca28 <__sfp+0x58>
	  goto found;
      if (g->_next == NULL &&
 400ca60:	e0bffd17 	ldw	r2,-12(fp)
 400ca64:	10800017 	ldw	r2,0(r2)
 400ca68:	1000091e 	bne	r2,zero,400ca90 <__sfp+0xc0>
	  (g->_next = __sfmoreglue (d, NDYNAMIC)) == NULL)
 400ca6c:	01400104 	movi	r5,4
 400ca70:	e13ffc17 	ldw	r4,-16(fp)
 400ca74:	400c9140 	call	400c914 <__sfmoreglue>
 400ca78:	1007883a 	mov	r3,r2
 400ca7c:	e0bffd17 	ldw	r2,-12(fp)
 400ca80:	10c00015 	stw	r3,0(r2)
 400ca84:	e0bffd17 	ldw	r2,-12(fp)
 400ca88:	10800017 	ldw	r2,0(r2)
      if (g->_next == NULL &&
 400ca8c:	10000426 	beq	r2,zero,400caa0 <__sfp+0xd0>
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
 400ca90:	e0bffd17 	ldw	r2,-12(fp)
 400ca94:	10800017 	ldw	r2,0(r2)
 400ca98:	e0bffd15 	stw	r2,-12(fp)
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
 400ca9c:	003fdb06 	br	400ca0c <__sfp+0x3c>
	break;
 400caa0:	0001883a 	nop
    }
  _newlib_sfp_lock_exit ();
 400caa4:	400ccb00 	call	400ccb0 <__sfp_lock_release>
  d->_errno = ENOMEM;
 400caa8:	e0bffc17 	ldw	r2,-16(fp)
 400caac:	00c00304 	movi	r3,12
 400cab0:	10c00015 	stw	r3,0(r2)
  return NULL;
 400cab4:	0005883a 	mov	r2,zero
 400cab8:	00002506 	br	400cb50 <__sfp+0x180>
	  goto found;
 400cabc:	0001883a 	nop

found:
  fp->_file = -1;		/* no file */
 400cac0:	e0bfff17 	ldw	r2,-4(fp)
 400cac4:	00ffffc4 	movi	r3,-1
 400cac8:	10c0038d 	sth	r3,14(r2)
  fp->_flags = 1;		/* reserve this slot; caller sets real flags */
 400cacc:	e0bfff17 	ldw	r2,-4(fp)
 400cad0:	00c00044 	movi	r3,1
 400cad4:	10c0030d 	sth	r3,12(r2)
  fp->_flags2 = 0;
 400cad8:	e0bfff17 	ldw	r2,-4(fp)
 400cadc:	10001915 	stw	zero,100(r2)
#ifndef __SINGLE_THREAD__
  __lock_init_recursive (fp->_lock);
#endif
  _newlib_sfp_lock_end ();
 400cae0:	400ccb00 	call	400ccb0 <__sfp_lock_release>

  fp->_p = NULL;		/* no current pointer */
 400cae4:	e0bfff17 	ldw	r2,-4(fp)
 400cae8:	10000015 	stw	zero,0(r2)
  fp->_w = 0;			/* nothing to read or write */
 400caec:	e0bfff17 	ldw	r2,-4(fp)
 400caf0:	10000215 	stw	zero,8(r2)
  fp->_r = 0;
 400caf4:	e0bfff17 	ldw	r2,-4(fp)
 400caf8:	10000115 	stw	zero,4(r2)
  fp->_bf._base = NULL;		/* no buffer */
 400cafc:	e0bfff17 	ldw	r2,-4(fp)
 400cb00:	10000415 	stw	zero,16(r2)
  fp->_bf._size = 0;
 400cb04:	e0bfff17 	ldw	r2,-4(fp)
 400cb08:	10000515 	stw	zero,20(r2)
  fp->_lbfsize = 0;		/* not line buffered */
 400cb0c:	e0bfff17 	ldw	r2,-4(fp)
 400cb10:	10000615 	stw	zero,24(r2)
  memset (&fp->_mbstate, 0, sizeof (_mbstate_t));
 400cb14:	e0bfff17 	ldw	r2,-4(fp)
 400cb18:	10801704 	addi	r2,r2,92
 400cb1c:	01800204 	movi	r6,8
 400cb20:	000b883a 	mov	r5,zero
 400cb24:	1009883a 	mov	r4,r2
 400cb28:	40077540 	call	4007754 <memset>
  /* fp->_cookie = <any>; */	/* caller sets cookie, _read/_write etc */
  fp->_ub._base = NULL;		/* no ungetc buffer */
 400cb2c:	e0bfff17 	ldw	r2,-4(fp)
 400cb30:	10000c15 	stw	zero,48(r2)
  fp->_ub._size = 0;
 400cb34:	e0bfff17 	ldw	r2,-4(fp)
 400cb38:	10000d15 	stw	zero,52(r2)
  fp->_lb._base = NULL;		/* no line buffer */
 400cb3c:	e0bfff17 	ldw	r2,-4(fp)
 400cb40:	10001115 	stw	zero,68(r2)
  fp->_lb._size = 0;
 400cb44:	e0bfff17 	ldw	r2,-4(fp)
 400cb48:	10001215 	stw	zero,72(r2)

  return fp;
 400cb4c:	e0bfff17 	ldw	r2,-4(fp)
}
 400cb50:	e037883a 	mov	sp,fp
 400cb54:	dfc00117 	ldw	ra,4(sp)
 400cb58:	df000017 	ldw	fp,0(sp)
 400cb5c:	dec00204 	addi	sp,sp,8
 400cb60:	f800283a 	ret

0400cb64 <_cleanup_r>:
 * The name `_cleanup' is, alas, fairly well known outside stdio.
 */

void
_cleanup_r (struct _reent *ptr)
{
 400cb64:	defffc04 	addi	sp,sp,-16
 400cb68:	dfc00315 	stw	ra,12(sp)
 400cb6c:	df000215 	stw	fp,8(sp)
 400cb70:	df000204 	addi	fp,sp,8
 400cb74:	e13ffe15 	stw	r4,-8(fp)
  /* Otherwise close files and flush read streams, too.
     Note we call flush directly if "--enable-lite-exit" is in effect.  */
#ifdef _LITE_EXIT
  cleanup_func = _fflush_r;
#else
  cleanup_func = _fclose_r;
 400cb78:	00810074 	movhi	r2,1025
 400cb7c:	108e9804 	addi	r2,r2,14944
 400cb80:	e0bfff15 	stw	r2,-4(fp)
  if (ptr->_stdout != &__sf[1])
    (*cleanup_func) (ptr, ptr->_stdout);
  if (ptr->_stderr != &__sf[2])
    (*cleanup_func) (ptr, ptr->_stderr);
#endif
  (void) _fwalk_reent (ptr, cleanup_func);
 400cb84:	e17fff17 	ldw	r5,-4(fp)
 400cb88:	e13ffe17 	ldw	r4,-8(fp)
 400cb8c:	400dbb40 	call	400dbb4 <_fwalk_reent>
}
 400cb90:	0001883a 	nop
 400cb94:	e037883a 	mov	sp,fp
 400cb98:	dfc00117 	ldw	ra,4(sp)
 400cb9c:	df000017 	ldw	fp,0(sp)
 400cba0:	dec00204 	addi	sp,sp,8
 400cba4:	f800283a 	ret

0400cba8 <_cleanup>:

#ifndef _REENT_ONLY
void
_cleanup (void)
{
 400cba8:	defffe04 	addi	sp,sp,-8
 400cbac:	dfc00115 	stw	ra,4(sp)
 400cbb0:	df000015 	stw	fp,0(sp)
 400cbb4:	d839883a 	mov	fp,sp
  _cleanup_r (_GLOBAL_REENT);
 400cbb8:	d0a00217 	ldw	r2,-32760(gp)
 400cbbc:	1009883a 	mov	r4,r2
 400cbc0:	400cb640 	call	400cb64 <_cleanup_r>
}
 400cbc4:	0001883a 	nop
 400cbc8:	e037883a 	mov	sp,fp
 400cbcc:	dfc00117 	ldw	ra,4(sp)
 400cbd0:	df000017 	ldw	fp,0(sp)
 400cbd4:	dec00204 	addi	sp,sp,8
 400cbd8:	f800283a 	ret

0400cbdc <__sinit>:
 * __sinit() is called whenever stdio's internal variables must be set up.
 */

void
__sinit (struct _reent *s)
{
 400cbdc:	defffd04 	addi	sp,sp,-12
 400cbe0:	dfc00215 	stw	ra,8(sp)
 400cbe4:	df000115 	stw	fp,4(sp)
 400cbe8:	df000104 	addi	fp,sp,4
 400cbec:	e13fff15 	stw	r4,-4(fp)
  __sinit_lock_acquire ();
 400cbf0:	400ccd00 	call	400ccd0 <__sinit_lock_acquire>

  if (s->__sdidinit)
 400cbf4:	e0bfff17 	ldw	r2,-4(fp)
 400cbf8:	10800e17 	ldw	r2,56(r2)
 400cbfc:	10000226 	beq	r2,zero,400cc08 <__sinit+0x2c>
    {
      __sinit_lock_release ();
 400cc00:	400ccf00 	call	400ccf0 <__sinit_lock_release>
      return;
 400cc04:	00001d06 	br	400cc7c <__sinit+0xa0>
    }

  /* make sure we clean up on exit */
  s->__cleanup = _cleanup_r;	/* conservative */
 400cc08:	e0ffff17 	ldw	r3,-4(fp)
 400cc0c:	00810074 	movhi	r2,1025
 400cc10:	10b2d904 	addi	r2,r2,-13468
 400cc14:	18800f15 	stw	r2,60(r3)

  s->__sglue._next = NULL;
 400cc18:	e0bfff17 	ldw	r2,-4(fp)
 400cc1c:	1000b815 	stw	zero,736(r2)
#ifndef _REENT_SMALL
# ifndef _REENT_GLOBAL_STDIO_STREAMS
  s->__sglue._niobs = 3;
 400cc20:	e0bfff17 	ldw	r2,-4(fp)
 400cc24:	00c000c4 	movi	r3,3
 400cc28:	10c0b915 	stw	r3,740(r2)
  s->__sglue._iobs = &s->__sf[0];
 400cc2c:	e0bfff17 	ldw	r2,-4(fp)
 400cc30:	10c0bb04 	addi	r3,r2,748
 400cc34:	e0bfff17 	ldw	r2,-4(fp)
 400cc38:	10c0ba15 	stw	r3,744(r2)
    stdin_init (&__sf[0]);
    stdout_init (&__sf[1]);
    stderr_init (&__sf[2]);
  }
#else /* _REENT_GLOBAL_STDIO_STREAMS */
  stdin_init (s->_stdin);
 400cc3c:	e0bfff17 	ldw	r2,-4(fp)
 400cc40:	10800117 	ldw	r2,4(r2)
 400cc44:	1009883a 	mov	r4,r2
 400cc48:	400c8600 	call	400c860 <stdin_init>
  stdout_init (s->_stdout);
 400cc4c:	e0bfff17 	ldw	r2,-4(fp)
 400cc50:	10800217 	ldw	r2,8(r2)
 400cc54:	1009883a 	mov	r4,r2
 400cc58:	400c89c0 	call	400c89c <stdout_init>
  stderr_init (s->_stderr);
 400cc5c:	e0bfff17 	ldw	r2,-4(fp)
 400cc60:	10800317 	ldw	r2,12(r2)
 400cc64:	1009883a 	mov	r4,r2
 400cc68:	400c8d80 	call	400c8d8 <stderr_init>
#endif /* _REENT_GLOBAL_STDIO_STREAMS */

  s->__sdidinit = 1;
 400cc6c:	e0bfff17 	ldw	r2,-4(fp)
 400cc70:	00c00044 	movi	r3,1
 400cc74:	10c00e15 	stw	r3,56(r2)

  __sinit_lock_release ();
 400cc78:	400ccf00 	call	400ccf0 <__sinit_lock_release>
}
 400cc7c:	e037883a 	mov	sp,fp
 400cc80:	dfc00117 	ldw	ra,4(sp)
 400cc84:	df000017 	ldw	fp,0(sp)
 400cc88:	dec00204 	addi	sp,sp,8
 400cc8c:	f800283a 	ret

0400cc90 <__sfp_lock_acquire>:
__LOCK_INIT_RECURSIVE(static, __sfp_recursive_mutex);
__LOCK_INIT_RECURSIVE(static, __sinit_recursive_mutex);

void
__sfp_lock_acquire (void)
{
 400cc90:	deffff04 	addi	sp,sp,-4
 400cc94:	df000015 	stw	fp,0(sp)
 400cc98:	d839883a 	mov	fp,sp
  __lock_acquire_recursive (__sfp_recursive_mutex);
}
 400cc9c:	0001883a 	nop
 400cca0:	e037883a 	mov	sp,fp
 400cca4:	df000017 	ldw	fp,0(sp)
 400cca8:	dec00104 	addi	sp,sp,4
 400ccac:	f800283a 	ret

0400ccb0 <__sfp_lock_release>:

void
__sfp_lock_release (void)
{
 400ccb0:	deffff04 	addi	sp,sp,-4
 400ccb4:	df000015 	stw	fp,0(sp)
 400ccb8:	d839883a 	mov	fp,sp
  __lock_release_recursive (__sfp_recursive_mutex);
}
 400ccbc:	0001883a 	nop
 400ccc0:	e037883a 	mov	sp,fp
 400ccc4:	df000017 	ldw	fp,0(sp)
 400ccc8:	dec00104 	addi	sp,sp,4
 400cccc:	f800283a 	ret

0400ccd0 <__sinit_lock_acquire>:

void
__sinit_lock_acquire (void)
{
 400ccd0:	deffff04 	addi	sp,sp,-4
 400ccd4:	df000015 	stw	fp,0(sp)
 400ccd8:	d839883a 	mov	fp,sp
  __lock_acquire_recursive (__sinit_recursive_mutex);
}
 400ccdc:	0001883a 	nop
 400cce0:	e037883a 	mov	sp,fp
 400cce4:	df000017 	ldw	fp,0(sp)
 400cce8:	dec00104 	addi	sp,sp,4
 400ccec:	f800283a 	ret

0400ccf0 <__sinit_lock_release>:

void
__sinit_lock_release (void)
{
 400ccf0:	deffff04 	addi	sp,sp,-4
 400ccf4:	df000015 	stw	fp,0(sp)
 400ccf8:	d839883a 	mov	fp,sp
  __lock_release_recursive (__sinit_recursive_mutex);
}
 400ccfc:	0001883a 	nop
 400cd00:	e037883a 	mov	sp,fp
 400cd04:	df000017 	ldw	fp,0(sp)
 400cd08:	dec00104 	addi	sp,sp,4
 400cd0c:	f800283a 	ret

0400cd10 <__fp_lock>:

/* Walkable file locking routine.  */
static int
__fp_lock (FILE * ptr)
{
 400cd10:	defffe04 	addi	sp,sp,-8
 400cd14:	df000115 	stw	fp,4(sp)
 400cd18:	df000104 	addi	fp,sp,4
 400cd1c:	e13fff15 	stw	r4,-4(fp)
  if (!(ptr->_flags2 & __SNLK))
    _flockfile (ptr);

  return 0;
 400cd20:	0005883a 	mov	r2,zero
}
 400cd24:	e037883a 	mov	sp,fp
 400cd28:	df000017 	ldw	fp,0(sp)
 400cd2c:	dec00104 	addi	sp,sp,4
 400cd30:	f800283a 	ret

0400cd34 <__fp_unlock>:

/* Walkable file unlocking routine.  */
static int
__fp_unlock (FILE * ptr)
{
 400cd34:	defffe04 	addi	sp,sp,-8
 400cd38:	df000115 	stw	fp,4(sp)
 400cd3c:	df000104 	addi	fp,sp,4
 400cd40:	e13fff15 	stw	r4,-4(fp)
  if (!(ptr->_flags2 & __SNLK))
    _funlockfile (ptr);

  return 0;
 400cd44:	0005883a 	mov	r2,zero
}
 400cd48:	e037883a 	mov	sp,fp
 400cd4c:	df000017 	ldw	fp,0(sp)
 400cd50:	dec00104 	addi	sp,sp,4
 400cd54:	f800283a 	ret

0400cd58 <__fp_lock_all>:

void
__fp_lock_all (void)
{
 400cd58:	defffe04 	addi	sp,sp,-8
 400cd5c:	dfc00115 	stw	ra,4(sp)
 400cd60:	df000015 	stw	fp,0(sp)
 400cd64:	d839883a 	mov	fp,sp
  __sfp_lock_acquire ();
 400cd68:	400cc900 	call	400cc90 <__sfp_lock_acquire>

  (void) _fwalk (_REENT, __fp_lock);
 400cd6c:	d0a00117 	ldw	r2,-32764(gp)
 400cd70:	01410074 	movhi	r5,1025
 400cd74:	29734404 	addi	r5,r5,-13040
 400cd78:	1009883a 	mov	r4,r2
 400cd7c:	400dadc0 	call	400dadc <_fwalk>
}
 400cd80:	0001883a 	nop
 400cd84:	e037883a 	mov	sp,fp
 400cd88:	dfc00117 	ldw	ra,4(sp)
 400cd8c:	df000017 	ldw	fp,0(sp)
 400cd90:	dec00204 	addi	sp,sp,8
 400cd94:	f800283a 	ret

0400cd98 <__fp_unlock_all>:

void
__fp_unlock_all (void)
{
 400cd98:	defffe04 	addi	sp,sp,-8
 400cd9c:	dfc00115 	stw	ra,4(sp)
 400cda0:	df000015 	stw	fp,0(sp)
 400cda4:	d839883a 	mov	fp,sp
  (void) _fwalk (_REENT, __fp_unlock);
 400cda8:	d0a00117 	ldw	r2,-32764(gp)
 400cdac:	01410074 	movhi	r5,1025
 400cdb0:	29734d04 	addi	r5,r5,-13004
 400cdb4:	1009883a 	mov	r4,r2
 400cdb8:	400dadc0 	call	400dadc <_fwalk>

  __sfp_lock_release ();
 400cdbc:	400ccb00 	call	400ccb0 <__sfp_lock_release>
}
 400cdc0:	0001883a 	nop
 400cdc4:	e037883a 	mov	sp,fp
 400cdc8:	dfc00117 	ldw	ra,4(sp)
 400cdcc:	df000017 	ldw	fp,0(sp)
 400cdd0:	dec00204 	addi	sp,sp,8
 400cdd4:	f800283a 	ret

0400cdd8 <_free_r>:
#if __STD_C
void fREe(RARG Void_t* mem)
#else
void fREe(RARG mem) RDECL Void_t* mem;
#endif
{
 400cdd8:	defff204 	addi	sp,sp,-56
 400cddc:	dfc00d15 	stw	ra,52(sp)
 400cde0:	df000c15 	stw	fp,48(sp)
 400cde4:	df000c04 	addi	fp,sp,48
 400cde8:	e13ff515 	stw	r4,-44(fp)
 400cdec:	e17ff415 	stw	r5,-48(fp)
  INTERNAL_SIZE_T prevsz; /* size of previous contiguous chunk */
  mchunkptr bck;       /* misc temp for linking */
  mchunkptr fwd;       /* misc temp for linking */
  int       islr;      /* track whether merging with last_remainder */

  if (mem == 0)                              /* free(0) has no effect */
 400cdf0:	e0bff417 	ldw	r2,-48(fp)
 400cdf4:	10014826 	beq	r2,zero,400d318 <_free_r+0x540>
    return;

  MALLOC_LOCK;
 400cdf8:	e13ff517 	ldw	r4,-44(fp)
 400cdfc:	40187b80 	call	40187b8 <__malloc_lock>

  p = mem2chunk(mem);
 400ce00:	e0bff417 	ldw	r2,-48(fp)
 400ce04:	10bffe04 	addi	r2,r2,-8
 400ce08:	e0bfff15 	stw	r2,-4(fp)
  hd = p->size;
 400ce0c:	e0bfff17 	ldw	r2,-4(fp)
 400ce10:	10800117 	ldw	r2,4(r2)
 400ce14:	e0bffa15 	stw	r2,-24(fp)
  }
#endif
  
  check_inuse_chunk(p);
  
  sz = hd & ~PREV_INUSE;
 400ce18:	e0fffa17 	ldw	r3,-24(fp)
 400ce1c:	00bfff84 	movi	r2,-2
 400ce20:	1884703a 	and	r2,r3,r2
 400ce24:	e0bffe15 	stw	r2,-8(fp)
  next = chunk_at_offset(p, sz);
 400ce28:	e0ffff17 	ldw	r3,-4(fp)
 400ce2c:	e0bffe17 	ldw	r2,-8(fp)
 400ce30:	1885883a 	add	r2,r3,r2
 400ce34:	e0bff915 	stw	r2,-28(fp)
  nextsz = chunksize(next);
 400ce38:	e0bff917 	ldw	r2,-28(fp)
 400ce3c:	10c00117 	ldw	r3,4(r2)
 400ce40:	00bfff04 	movi	r2,-4
 400ce44:	1884703a 	and	r2,r3,r2
 400ce48:	e0bff815 	stw	r2,-32(fp)
  
  if (next == top)                            /* merge with top */
 400ce4c:	008100b4 	movhi	r2,1026
 400ce50:	10ae3304 	addi	r2,r2,-18228
 400ce54:	10800217 	ldw	r2,8(r2)
 400ce58:	e0fff917 	ldw	r3,-28(fp)
 400ce5c:	1880311e 	bne	r3,r2,400cf24 <_free_r+0x14c>
  {
    sz += nextsz;
 400ce60:	e0fffe17 	ldw	r3,-8(fp)
 400ce64:	e0bff817 	ldw	r2,-32(fp)
 400ce68:	1885883a 	add	r2,r3,r2
 400ce6c:	e0bffe15 	stw	r2,-8(fp)

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
 400ce70:	e0bffa17 	ldw	r2,-24(fp)
 400ce74:	1080004c 	andi	r2,r2,1
 400ce78:	1000181e 	bne	r2,zero,400cedc <_free_r+0x104>
    {
      prevsz = p->prev_size;
 400ce7c:	e0bfff17 	ldw	r2,-4(fp)
 400ce80:	10800017 	ldw	r2,0(r2)
 400ce84:	e0bff715 	stw	r2,-36(fp)
      p = chunk_at_offset(p, -prevsz);
 400ce88:	e0bff717 	ldw	r2,-36(fp)
 400ce8c:	0085c83a 	sub	r2,zero,r2
 400ce90:	e0ffff17 	ldw	r3,-4(fp)
 400ce94:	1885883a 	add	r2,r3,r2
 400ce98:	e0bfff15 	stw	r2,-4(fp)
      sz += prevsz;
 400ce9c:	e0fffe17 	ldw	r3,-8(fp)
 400cea0:	e0bff717 	ldw	r2,-36(fp)
 400cea4:	1885883a 	add	r2,r3,r2
 400cea8:	e0bffe15 	stw	r2,-8(fp)
      unlink(p, bck, fwd);
 400ceac:	e0bfff17 	ldw	r2,-4(fp)
 400ceb0:	10800317 	ldw	r2,12(r2)
 400ceb4:	e0bffd15 	stw	r2,-12(fp)
 400ceb8:	e0bfff17 	ldw	r2,-4(fp)
 400cebc:	10800217 	ldw	r2,8(r2)
 400cec0:	e0bffc15 	stw	r2,-16(fp)
 400cec4:	e0bffc17 	ldw	r2,-16(fp)
 400cec8:	e0fffd17 	ldw	r3,-12(fp)
 400cecc:	10c00315 	stw	r3,12(r2)
 400ced0:	e0bffd17 	ldw	r2,-12(fp)
 400ced4:	e0fffc17 	ldw	r3,-16(fp)
 400ced8:	10c00215 	stw	r3,8(r2)
    }

    set_head(p, sz | PREV_INUSE);
 400cedc:	e0bffe17 	ldw	r2,-8(fp)
 400cee0:	10c00054 	ori	r3,r2,1
 400cee4:	e0bfff17 	ldw	r2,-4(fp)
 400cee8:	10c00115 	stw	r3,4(r2)
    top = p;
 400ceec:	008100b4 	movhi	r2,1026
 400cef0:	10ae3304 	addi	r2,r2,-18228
 400cef4:	e0ffff17 	ldw	r3,-4(fp)
 400cef8:	10c00215 	stw	r3,8(r2)
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold) 
 400cefc:	d0a00317 	ldw	r2,-32756(gp)
 400cf00:	e0fffe17 	ldw	r3,-8(fp)
 400cf04:	18800436 	bltu	r3,r2,400cf18 <_free_r+0x140>
      malloc_trim(RCALL top_pad); 
 400cf08:	d0a72617 	ldw	r2,-25448(gp)
 400cf0c:	100b883a 	mov	r5,r2
 400cf10:	e13ff517 	ldw	r4,-44(fp)
 400cf14:	400d3300 	call	400d330 <_malloc_trim_r>
    MALLOC_UNLOCK;
 400cf18:	e13ff517 	ldw	r4,-44(fp)
 400cf1c:	40187dc0 	call	40187dc <__malloc_unlock>
    return;
 400cf20:	0000fe06 	br	400d31c <_free_r+0x544>
  }

  set_head(next, nextsz);                    /* clear inuse bit */
 400cf24:	e0bff917 	ldw	r2,-28(fp)
 400cf28:	e0fff817 	ldw	r3,-32(fp)
 400cf2c:	10c00115 	stw	r3,4(r2)

  islr = 0;
 400cf30:	e03ffb15 	stw	zero,-20(fp)

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
 400cf34:	e0bffa17 	ldw	r2,-24(fp)
 400cf38:	1080004c 	andi	r2,r2,1
 400cf3c:	1000201e 	bne	r2,zero,400cfc0 <_free_r+0x1e8>
  {
    prevsz = p->prev_size;
 400cf40:	e0bfff17 	ldw	r2,-4(fp)
 400cf44:	10800017 	ldw	r2,0(r2)
 400cf48:	e0bff715 	stw	r2,-36(fp)
    p = chunk_at_offset(p, -prevsz);
 400cf4c:	e0bff717 	ldw	r2,-36(fp)
 400cf50:	0085c83a 	sub	r2,zero,r2
 400cf54:	e0ffff17 	ldw	r3,-4(fp)
 400cf58:	1885883a 	add	r2,r3,r2
 400cf5c:	e0bfff15 	stw	r2,-4(fp)
    sz += prevsz;
 400cf60:	e0fffe17 	ldw	r3,-8(fp)
 400cf64:	e0bff717 	ldw	r2,-36(fp)
 400cf68:	1885883a 	add	r2,r3,r2
 400cf6c:	e0bffe15 	stw	r2,-8(fp)
    
    if (p->fd == last_remainder)             /* keep as last_remainder */
 400cf70:	e0bfff17 	ldw	r2,-4(fp)
 400cf74:	10c00217 	ldw	r3,8(r2)
 400cf78:	008100b4 	movhi	r2,1026
 400cf7c:	10ae3504 	addi	r2,r2,-18220
 400cf80:	1880031e 	bne	r3,r2,400cf90 <_free_r+0x1b8>
      islr = 1;
 400cf84:	00800044 	movi	r2,1
 400cf88:	e0bffb15 	stw	r2,-20(fp)
 400cf8c:	00000c06 	br	400cfc0 <_free_r+0x1e8>
    else
      unlink(p, bck, fwd);
 400cf90:	e0bfff17 	ldw	r2,-4(fp)
 400cf94:	10800317 	ldw	r2,12(r2)
 400cf98:	e0bffd15 	stw	r2,-12(fp)
 400cf9c:	e0bfff17 	ldw	r2,-4(fp)
 400cfa0:	10800217 	ldw	r2,8(r2)
 400cfa4:	e0bffc15 	stw	r2,-16(fp)
 400cfa8:	e0bffc17 	ldw	r2,-16(fp)
 400cfac:	e0fffd17 	ldw	r3,-12(fp)
 400cfb0:	10c00315 	stw	r3,12(r2)
 400cfb4:	e0bffd17 	ldw	r2,-12(fp)
 400cfb8:	e0fffc17 	ldw	r3,-16(fp)
 400cfbc:	10c00215 	stw	r3,8(r2)
  }
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
 400cfc0:	e0fff917 	ldw	r3,-28(fp)
 400cfc4:	e0bff817 	ldw	r2,-32(fp)
 400cfc8:	1885883a 	add	r2,r3,r2
 400cfcc:	10800117 	ldw	r2,4(r2)
 400cfd0:	1080004c 	andi	r2,r2,1
 400cfd4:	10002a1e 	bne	r2,zero,400d080 <_free_r+0x2a8>
  {
    sz += nextsz;
 400cfd8:	e0fffe17 	ldw	r3,-8(fp)
 400cfdc:	e0bff817 	ldw	r2,-32(fp)
 400cfe0:	1885883a 	add	r2,r3,r2
 400cfe4:	e0bffe15 	stw	r2,-8(fp)
    
    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
 400cfe8:	e0bffb17 	ldw	r2,-20(fp)
 400cfec:	1000181e 	bne	r2,zero,400d050 <_free_r+0x278>
 400cff0:	e0bff917 	ldw	r2,-28(fp)
 400cff4:	10c00217 	ldw	r3,8(r2)
 400cff8:	008100b4 	movhi	r2,1026
 400cffc:	10ae3504 	addi	r2,r2,-18220
 400d000:	1880131e 	bne	r3,r2,400d050 <_free_r+0x278>
    {
      islr = 1;
 400d004:	00800044 	movi	r2,1
 400d008:	e0bffb15 	stw	r2,-20(fp)
      link_last_remainder(p);   
 400d00c:	008100b4 	movhi	r2,1026
 400d010:	10ae3504 	addi	r2,r2,-18220
 400d014:	e0ffff17 	ldw	r3,-4(fp)
 400d018:	10c00315 	stw	r3,12(r2)
 400d01c:	00c100b4 	movhi	r3,1026
 400d020:	18ee3504 	addi	r3,r3,-18220
 400d024:	10800317 	ldw	r2,12(r2)
 400d028:	18800215 	stw	r2,8(r3)
 400d02c:	008100b4 	movhi	r2,1026
 400d030:	10ae3504 	addi	r2,r2,-18220
 400d034:	e0ffff17 	ldw	r3,-4(fp)
 400d038:	18800315 	stw	r2,12(r3)
 400d03c:	e0bfff17 	ldw	r2,-4(fp)
 400d040:	10c00317 	ldw	r3,12(r2)
 400d044:	e0bfff17 	ldw	r2,-4(fp)
 400d048:	10c00215 	stw	r3,8(r2)
 400d04c:	00000c06 	br	400d080 <_free_r+0x2a8>
    }
    else
      unlink(next, bck, fwd);
 400d050:	e0bff917 	ldw	r2,-28(fp)
 400d054:	10800317 	ldw	r2,12(r2)
 400d058:	e0bffd15 	stw	r2,-12(fp)
 400d05c:	e0bff917 	ldw	r2,-28(fp)
 400d060:	10800217 	ldw	r2,8(r2)
 400d064:	e0bffc15 	stw	r2,-16(fp)
 400d068:	e0bffc17 	ldw	r2,-16(fp)
 400d06c:	e0fffd17 	ldw	r3,-12(fp)
 400d070:	10c00315 	stw	r3,12(r2)
 400d074:	e0bffd17 	ldw	r2,-12(fp)
 400d078:	e0fffc17 	ldw	r3,-16(fp)
 400d07c:	10c00215 	stw	r3,8(r2)
  }


  set_head(p, sz | PREV_INUSE);
 400d080:	e0bffe17 	ldw	r2,-8(fp)
 400d084:	10c00054 	ori	r3,r2,1
 400d088:	e0bfff17 	ldw	r2,-4(fp)
 400d08c:	10c00115 	stw	r3,4(r2)
  set_foot(p, sz);
 400d090:	e0ffff17 	ldw	r3,-4(fp)
 400d094:	e0bffe17 	ldw	r2,-8(fp)
 400d098:	1885883a 	add	r2,r3,r2
 400d09c:	e0fffe17 	ldw	r3,-8(fp)
 400d0a0:	10c00015 	stw	r3,0(r2)
  if (!islr)
 400d0a4:	e0bffb17 	ldw	r2,-20(fp)
 400d0a8:	1000981e 	bne	r2,zero,400d30c <_free_r+0x534>
    frontlink(p, sz, idx, bck, fwd);  
 400d0ac:	e0bffe17 	ldw	r2,-8(fp)
 400d0b0:	10808028 	cmpgeui	r2,r2,512
 400d0b4:	10002b1e 	bne	r2,zero,400d164 <_free_r+0x38c>
 400d0b8:	e0bffe17 	ldw	r2,-8(fp)
 400d0bc:	1004d0fa 	srli	r2,r2,3
 400d0c0:	e0bff615 	stw	r2,-40(fp)
 400d0c4:	008100b4 	movhi	r2,1026
 400d0c8:	10ae3304 	addi	r2,r2,-18228
 400d0cc:	11000117 	ldw	r4,4(r2)
 400d0d0:	e0bff617 	ldw	r2,-40(fp)
 400d0d4:	1000010e 	bge	r2,zero,400d0dc <_free_r+0x304>
 400d0d8:	108000c4 	addi	r2,r2,3
 400d0dc:	1005d0ba 	srai	r2,r2,2
 400d0e0:	1007883a 	mov	r3,r2
 400d0e4:	00800044 	movi	r2,1
 400d0e8:	10c6983a 	sll	r3,r2,r3
 400d0ec:	008100b4 	movhi	r2,1026
 400d0f0:	10ae3304 	addi	r2,r2,-18228
 400d0f4:	20c6b03a 	or	r3,r4,r3
 400d0f8:	10c00115 	stw	r3,4(r2)
 400d0fc:	e0bff617 	ldw	r2,-40(fp)
 400d100:	10800044 	addi	r2,r2,1
 400d104:	1085883a 	add	r2,r2,r2
 400d108:	100690ba 	slli	r3,r2,2
 400d10c:	008100b4 	movhi	r2,1026
 400d110:	10ae3304 	addi	r2,r2,-18228
 400d114:	1885883a 	add	r2,r3,r2
 400d118:	10bffe04 	addi	r2,r2,-8
 400d11c:	e0bffd15 	stw	r2,-12(fp)
 400d120:	e0bffd17 	ldw	r2,-12(fp)
 400d124:	10800217 	ldw	r2,8(r2)
 400d128:	e0bffc15 	stw	r2,-16(fp)
 400d12c:	e0bfff17 	ldw	r2,-4(fp)
 400d130:	e0fffd17 	ldw	r3,-12(fp)
 400d134:	10c00315 	stw	r3,12(r2)
 400d138:	e0bfff17 	ldw	r2,-4(fp)
 400d13c:	e0fffc17 	ldw	r3,-16(fp)
 400d140:	10c00215 	stw	r3,8(r2)
 400d144:	e0bffd17 	ldw	r2,-12(fp)
 400d148:	e0ffff17 	ldw	r3,-4(fp)
 400d14c:	10c00215 	stw	r3,8(r2)
 400d150:	e0bffd17 	ldw	r2,-12(fp)
 400d154:	10c00217 	ldw	r3,8(r2)
 400d158:	e0bffc17 	ldw	r2,-16(fp)
 400d15c:	10c00315 	stw	r3,12(r2)
 400d160:	00006a06 	br	400d30c <_free_r+0x534>
 400d164:	e0bffe17 	ldw	r2,-8(fp)
 400d168:	1004d27a 	srli	r2,r2,9
 400d16c:	1000031e 	bne	r2,zero,400d17c <_free_r+0x3a4>
 400d170:	e0bffe17 	ldw	r2,-8(fp)
 400d174:	1004d0fa 	srli	r2,r2,3
 400d178:	00002906 	br	400d220 <_free_r+0x448>
 400d17c:	e0bffe17 	ldw	r2,-8(fp)
 400d180:	1004d27a 	srli	r2,r2,9
 400d184:	10800168 	cmpgeui	r2,r2,5
 400d188:	1000041e 	bne	r2,zero,400d19c <_free_r+0x3c4>
 400d18c:	e0bffe17 	ldw	r2,-8(fp)
 400d190:	1004d1ba 	srli	r2,r2,6
 400d194:	10800e04 	addi	r2,r2,56
 400d198:	00002106 	br	400d220 <_free_r+0x448>
 400d19c:	e0bffe17 	ldw	r2,-8(fp)
 400d1a0:	1004d27a 	srli	r2,r2,9
 400d1a4:	10800568 	cmpgeui	r2,r2,21
 400d1a8:	1000041e 	bne	r2,zero,400d1bc <_free_r+0x3e4>
 400d1ac:	e0bffe17 	ldw	r2,-8(fp)
 400d1b0:	1004d27a 	srli	r2,r2,9
 400d1b4:	108016c4 	addi	r2,r2,91
 400d1b8:	00001906 	br	400d220 <_free_r+0x448>
 400d1bc:	e0bffe17 	ldw	r2,-8(fp)
 400d1c0:	1004d27a 	srli	r2,r2,9
 400d1c4:	10801568 	cmpgeui	r2,r2,85
 400d1c8:	1000041e 	bne	r2,zero,400d1dc <_free_r+0x404>
 400d1cc:	e0bffe17 	ldw	r2,-8(fp)
 400d1d0:	1004d33a 	srli	r2,r2,12
 400d1d4:	10801b84 	addi	r2,r2,110
 400d1d8:	00001106 	br	400d220 <_free_r+0x448>
 400d1dc:	e0bffe17 	ldw	r2,-8(fp)
 400d1e0:	1004d27a 	srli	r2,r2,9
 400d1e4:	10805568 	cmpgeui	r2,r2,341
 400d1e8:	1000041e 	bne	r2,zero,400d1fc <_free_r+0x424>
 400d1ec:	e0bffe17 	ldw	r2,-8(fp)
 400d1f0:	1004d3fa 	srli	r2,r2,15
 400d1f4:	10801dc4 	addi	r2,r2,119
 400d1f8:	00000906 	br	400d220 <_free_r+0x448>
 400d1fc:	e0bffe17 	ldw	r2,-8(fp)
 400d200:	1004d27a 	srli	r2,r2,9
 400d204:	10815568 	cmpgeui	r2,r2,1365
 400d208:	1000041e 	bne	r2,zero,400d21c <_free_r+0x444>
 400d20c:	e0bffe17 	ldw	r2,-8(fp)
 400d210:	1004d4ba 	srli	r2,r2,18
 400d214:	10801f04 	addi	r2,r2,124
 400d218:	00000106 	br	400d220 <_free_r+0x448>
 400d21c:	00801f84 	movi	r2,126
 400d220:	e0bff615 	stw	r2,-40(fp)
 400d224:	e0bff617 	ldw	r2,-40(fp)
 400d228:	10800044 	addi	r2,r2,1
 400d22c:	1085883a 	add	r2,r2,r2
 400d230:	100690ba 	slli	r3,r2,2
 400d234:	008100b4 	movhi	r2,1026
 400d238:	10ae3304 	addi	r2,r2,-18228
 400d23c:	1885883a 	add	r2,r3,r2
 400d240:	10bffe04 	addi	r2,r2,-8
 400d244:	e0bffd15 	stw	r2,-12(fp)
 400d248:	e0bffd17 	ldw	r2,-12(fp)
 400d24c:	10800217 	ldw	r2,8(r2)
 400d250:	e0bffc15 	stw	r2,-16(fp)
 400d254:	e0fffc17 	ldw	r3,-16(fp)
 400d258:	e0bffd17 	ldw	r2,-12(fp)
 400d25c:	1880121e 	bne	r3,r2,400d2a8 <_free_r+0x4d0>
 400d260:	008100b4 	movhi	r2,1026
 400d264:	10ae3304 	addi	r2,r2,-18228
 400d268:	11000117 	ldw	r4,4(r2)
 400d26c:	e0bff617 	ldw	r2,-40(fp)
 400d270:	1000010e 	bge	r2,zero,400d278 <_free_r+0x4a0>
 400d274:	108000c4 	addi	r2,r2,3
 400d278:	1005d0ba 	srai	r2,r2,2
 400d27c:	1007883a 	mov	r3,r2
 400d280:	00800044 	movi	r2,1
 400d284:	10c6983a 	sll	r3,r2,r3
 400d288:	008100b4 	movhi	r2,1026
 400d28c:	10ae3304 	addi	r2,r2,-18228
 400d290:	20c6b03a 	or	r3,r4,r3
 400d294:	10c00115 	stw	r3,4(r2)
 400d298:	00000f06 	br	400d2d8 <_free_r+0x500>
 400d29c:	e0bffc17 	ldw	r2,-16(fp)
 400d2a0:	10800217 	ldw	r2,8(r2)
 400d2a4:	e0bffc15 	stw	r2,-16(fp)
 400d2a8:	e0fffc17 	ldw	r3,-16(fp)
 400d2ac:	e0bffd17 	ldw	r2,-12(fp)
 400d2b0:	18800626 	beq	r3,r2,400d2cc <_free_r+0x4f4>
 400d2b4:	e0bffc17 	ldw	r2,-16(fp)
 400d2b8:	10c00117 	ldw	r3,4(r2)
 400d2bc:	00bfff04 	movi	r2,-4
 400d2c0:	1884703a 	and	r2,r3,r2
 400d2c4:	e0fffe17 	ldw	r3,-8(fp)
 400d2c8:	18bff436 	bltu	r3,r2,400d29c <_free_r+0x4c4>
 400d2cc:	e0bffc17 	ldw	r2,-16(fp)
 400d2d0:	10800317 	ldw	r2,12(r2)
 400d2d4:	e0bffd15 	stw	r2,-12(fp)
 400d2d8:	e0bfff17 	ldw	r2,-4(fp)
 400d2dc:	e0fffd17 	ldw	r3,-12(fp)
 400d2e0:	10c00315 	stw	r3,12(r2)
 400d2e4:	e0bfff17 	ldw	r2,-4(fp)
 400d2e8:	e0fffc17 	ldw	r3,-16(fp)
 400d2ec:	10c00215 	stw	r3,8(r2)
 400d2f0:	e0bffd17 	ldw	r2,-12(fp)
 400d2f4:	e0ffff17 	ldw	r3,-4(fp)
 400d2f8:	10c00215 	stw	r3,8(r2)
 400d2fc:	e0bffd17 	ldw	r2,-12(fp)
 400d300:	10c00217 	ldw	r3,8(r2)
 400d304:	e0bffc17 	ldw	r2,-16(fp)
 400d308:	10c00315 	stw	r3,12(r2)

  MALLOC_UNLOCK;
 400d30c:	e13ff517 	ldw	r4,-44(fp)
 400d310:	40187dc0 	call	40187dc <__malloc_unlock>
 400d314:	00000106 	br	400d31c <_free_r+0x544>
    return;
 400d318:	0001883a 	nop

#endif /* MALLOC_PROVIDED */
}
 400d31c:	e037883a 	mov	sp,fp
 400d320:	dfc00117 	ldw	ra,4(sp)
 400d324:	df000017 	ldw	fp,0(sp)
 400d328:	dec00204 	addi	sp,sp,8
 400d32c:	f800283a 	ret

0400d330 <_malloc_trim_r>:
#if __STD_C
int malloc_trim(RARG size_t pad)
#else
int malloc_trim(RARG pad) RDECL size_t pad;
#endif
{
 400d330:	defff704 	addi	sp,sp,-36
 400d334:	dfc00815 	stw	ra,32(sp)
 400d338:	df000715 	stw	fp,28(sp)
 400d33c:	df000704 	addi	fp,sp,28
 400d340:	e13ffa15 	stw	r4,-24(fp)
 400d344:	e17ff915 	stw	r5,-28(fp)
  long  top_size;        /* Amount of top-most memory */
  long  extra;           /* Amount to release */
  char* current_brk;     /* address returned by pre-check sbrk call */
  char* new_brk;         /* address returned by negative sbrk call */

  unsigned long pagesz = malloc_getpagesize;
 400d348:	00840004 	movi	r2,4096
 400d34c:	e0bfff15 	stw	r2,-4(fp)

  MALLOC_LOCK;
 400d350:	e13ffa17 	ldw	r4,-24(fp)
 400d354:	40187b80 	call	40187b8 <__malloc_lock>

  top_size = chunksize(top);
 400d358:	008100b4 	movhi	r2,1026
 400d35c:	10ae3304 	addi	r2,r2,-18228
 400d360:	10800217 	ldw	r2,8(r2)
 400d364:	10800117 	ldw	r2,4(r2)
 400d368:	1007883a 	mov	r3,r2
 400d36c:	00bfff04 	movi	r2,-4
 400d370:	1884703a 	and	r2,r3,r2
 400d374:	e0bffe15 	stw	r2,-8(fp)
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;
 400d378:	e0fffe17 	ldw	r3,-8(fp)
 400d37c:	e0bff917 	ldw	r2,-28(fp)
 400d380:	1887c83a 	sub	r3,r3,r2
 400d384:	e0bfff17 	ldw	r2,-4(fp)
 400d388:	1885883a 	add	r2,r3,r2
 400d38c:	10bffbc4 	addi	r2,r2,-17
 400d390:	e17fff17 	ldw	r5,-4(fp)
 400d394:	1009883a 	mov	r4,r2
 400d398:	40074e40 	call	40074e4 <__udivsi3>
 400d39c:	10bfffc4 	addi	r2,r2,-1
 400d3a0:	e17fff17 	ldw	r5,-4(fp)
 400d3a4:	1009883a 	mov	r4,r2
 400d3a8:	40075a40 	call	40075a4 <__mulsi3>
 400d3ac:	e0bffd15 	stw	r2,-12(fp)

  if (extra < (long)pagesz)  /* Not enough memory to release */
 400d3b0:	e0bfff17 	ldw	r2,-4(fp)
 400d3b4:	e0fffd17 	ldw	r3,-12(fp)
 400d3b8:	1880040e 	bge	r3,r2,400d3cc <_malloc_trim_r+0x9c>
  {
    MALLOC_UNLOCK;
 400d3bc:	e13ffa17 	ldw	r4,-24(fp)
 400d3c0:	40187dc0 	call	40187dc <__malloc_unlock>
    return 0;
 400d3c4:	0005883a 	mov	r2,zero
 400d3c8:	00004506 	br	400d4e0 <_malloc_trim_r+0x1b0>
  }

  else
  {
    /* Test to make sure no one else called sbrk */
    current_brk = (char*)(MORECORE (0));
 400d3cc:	000b883a 	mov	r5,zero
 400d3d0:	e13ffa17 	ldw	r4,-24(fp)
 400d3d4:	4011d200 	call	4011d20 <_sbrk_r>
 400d3d8:	e0bffc15 	stw	r2,-16(fp)
    if (current_brk != (char*)(top) + top_size)
 400d3dc:	008100b4 	movhi	r2,1026
 400d3e0:	10ae3304 	addi	r2,r2,-18228
 400d3e4:	10c00217 	ldw	r3,8(r2)
 400d3e8:	e0bffe17 	ldw	r2,-8(fp)
 400d3ec:	1885883a 	add	r2,r3,r2
 400d3f0:	e0fffc17 	ldw	r3,-16(fp)
 400d3f4:	18800426 	beq	r3,r2,400d408 <_malloc_trim_r+0xd8>
    {
      MALLOC_UNLOCK;
 400d3f8:	e13ffa17 	ldw	r4,-24(fp)
 400d3fc:	40187dc0 	call	40187dc <__malloc_unlock>
      return 0;     /* Apparently we don't own memory; must fail */
 400d400:	0005883a 	mov	r2,zero
 400d404:	00003606 	br	400d4e0 <_malloc_trim_r+0x1b0>
    }

    else
    {
      new_brk = (char*)(MORECORE (-extra));
 400d408:	e0bffd17 	ldw	r2,-12(fp)
 400d40c:	0085c83a 	sub	r2,zero,r2
 400d410:	100b883a 	mov	r5,r2
 400d414:	e13ffa17 	ldw	r4,-24(fp)
 400d418:	4011d200 	call	4011d20 <_sbrk_r>
 400d41c:	e0bffb15 	stw	r2,-20(fp)
      
      if (new_brk == (char*)(MORECORE_FAILURE)) /* sbrk failed? */
 400d420:	e0bffb17 	ldw	r2,-20(fp)
 400d424:	10bfffd8 	cmpnei	r2,r2,-1
 400d428:	10001c1e 	bne	r2,zero,400d49c <_malloc_trim_r+0x16c>
      {
        /* Try to figure out what we have */
        current_brk = (char*)(MORECORE (0));
 400d42c:	000b883a 	mov	r5,zero
 400d430:	e13ffa17 	ldw	r4,-24(fp)
 400d434:	4011d200 	call	4011d20 <_sbrk_r>
 400d438:	e0bffc15 	stw	r2,-16(fp)
        top_size = current_brk - (char*)top;
 400d43c:	008100b4 	movhi	r2,1026
 400d440:	10ae3304 	addi	r2,r2,-18228
 400d444:	10800217 	ldw	r2,8(r2)
 400d448:	e0fffc17 	ldw	r3,-16(fp)
 400d44c:	1885c83a 	sub	r2,r3,r2
 400d450:	e0bffe15 	stw	r2,-8(fp)
        if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
 400d454:	e0bffe17 	ldw	r2,-8(fp)
 400d458:	10800410 	cmplti	r2,r2,16
 400d45c:	10000b1e 	bne	r2,zero,400d48c <_malloc_trim_r+0x15c>
        {
          sbrked_mem = current_brk - sbrk_base;
 400d460:	d0a00417 	ldw	r2,-32752(gp)
 400d464:	e0fffc17 	ldw	r3,-16(fp)
 400d468:	1887c83a 	sub	r3,r3,r2
 400d46c:	008120b4 	movhi	r2,1154
 400d470:	10fb2615 	stw	r3,-4968(r2)
          set_head(top, top_size | PREV_INUSE);
 400d474:	e0bffe17 	ldw	r2,-8(fp)
 400d478:	10c00054 	ori	r3,r2,1
 400d47c:	008100b4 	movhi	r2,1026
 400d480:	10ae3304 	addi	r2,r2,-18228
 400d484:	10800217 	ldw	r2,8(r2)
 400d488:	10c00115 	stw	r3,4(r2)
        }
        check_chunk(top);
	MALLOC_UNLOCK;
 400d48c:	e13ffa17 	ldw	r4,-24(fp)
 400d490:	40187dc0 	call	40187dc <__malloc_unlock>
        return 0; 
 400d494:	0005883a 	mov	r2,zero
 400d498:	00001106 	br	400d4e0 <_malloc_trim_r+0x1b0>
      }

      else
      {
        /* Success. Adjust top accordingly. */
        set_head(top, (top_size - extra) | PREV_INUSE);
 400d49c:	e0fffe17 	ldw	r3,-8(fp)
 400d4a0:	e0bffd17 	ldw	r2,-12(fp)
 400d4a4:	1885c83a 	sub	r2,r3,r2
 400d4a8:	10c00054 	ori	r3,r2,1
 400d4ac:	008100b4 	movhi	r2,1026
 400d4b0:	10ae3304 	addi	r2,r2,-18228
 400d4b4:	10800217 	ldw	r2,8(r2)
 400d4b8:	10c00115 	stw	r3,4(r2)
        sbrked_mem -= extra;
 400d4bc:	008120b4 	movhi	r2,1154
 400d4c0:	10fb2617 	ldw	r3,-4968(r2)
 400d4c4:	e0bffd17 	ldw	r2,-12(fp)
 400d4c8:	1887c83a 	sub	r3,r3,r2
 400d4cc:	008120b4 	movhi	r2,1154
 400d4d0:	10fb2615 	stw	r3,-4968(r2)
        check_chunk(top);
	MALLOC_UNLOCK;
 400d4d4:	e13ffa17 	ldw	r4,-24(fp)
 400d4d8:	40187dc0 	call	40187dc <__malloc_unlock>
        return 1;
 400d4dc:	00800044 	movi	r2,1
      }
    }
  }
}
 400d4e0:	e037883a 	mov	sp,fp
 400d4e4:	dfc00117 	ldw	ra,4(sp)
 400d4e8:	df000017 	ldw	fp,0(sp)
 400d4ec:	dec00204 	addi	sp,sp,8
 400d4f0:	f800283a 	ret

0400d4f4 <__sfvwrite_r>:

int
__sfvwrite_r (struct _reent *ptr,
       register FILE *fp,
       register struct __suio *uio)
{
 400d4f4:	defff004 	addi	sp,sp,-64
 400d4f8:	dfc00f15 	stw	ra,60(sp)
 400d4fc:	df000e15 	stw	fp,56(sp)
 400d500:	dd800d15 	stw	r22,52(sp)
 400d504:	dd400c15 	stw	r21,48(sp)
 400d508:	dd000b15 	stw	r20,44(sp)
 400d50c:	dcc00a15 	stw	r19,40(sp)
 400d510:	dc800915 	stw	r18,36(sp)
 400d514:	dc400815 	stw	r17,32(sp)
 400d518:	dc000715 	stw	r16,28(sp)
 400d51c:	df000e04 	addi	fp,sp,56
 400d520:	e13ff215 	stw	r4,-56(fp)
 400d524:	2821883a 	mov	r16,r5
 400d528:	302b883a 	mov	r21,r6
  register size_t len;
  register const char *p = NULL;
 400d52c:	0027883a 	mov	r19,zero
  register struct __siov *iov;
  register _READ_WRITE_RETURN_TYPE w, s;
  char *nl;
  int nlknown, nldist;

  if ((len = uio->uio_resid) == 0)
 400d530:	ac800217 	ldw	r18,8(r21)
 400d534:	9000021e 	bne	r18,zero,400d540 <__sfvwrite_r+0x4c>
    return 0;
 400d538:	0005883a 	mov	r2,zero
 400d53c:	00015b06 	br	400daac <__sfvwrite_r+0x5b8>

  /* make sure we can write */
  if (cantwrite (ptr, fp))
 400d540:	8080030b 	ldhu	r2,12(r16)
 400d544:	10bfffcc 	andi	r2,r2,65535
 400d548:	1080020c 	andi	r2,r2,8
 400d54c:	10000226 	beq	r2,zero,400d558 <__sfvwrite_r+0x64>
 400d550:	80800417 	ldw	r2,16(r16)
 400d554:	1000061e 	bne	r2,zero,400d570 <__sfvwrite_r+0x7c>
 400d558:	800b883a 	mov	r5,r16
 400d55c:	e13ff217 	ldw	r4,-56(fp)
 400d560:	400a2180 	call	400a218 <__swsetup_r>
 400d564:	10000226 	beq	r2,zero,400d570 <__sfvwrite_r+0x7c>
    return EOF;
 400d568:	00bfffc4 	movi	r2,-1
 400d56c:	00014f06 	br	400daac <__sfvwrite_r+0x5b8>

  iov = uio->uio_iov;
 400d570:	ad000017 	ldw	r20,0(r21)
  len = 0;
 400d574:	0025883a 	mov	r18,zero
      while (uio->uio_resid > 0);
      return 0;
    }
#endif

  if (fp->_flags & __SNBF)
 400d578:	8080030b 	ldhu	r2,12(r16)
 400d57c:	10bfffcc 	andi	r2,r2,65535
 400d580:	1080008c 	andi	r2,r2,2
 400d584:	10001f26 	beq	r2,zero,400d604 <__sfvwrite_r+0x110>
       * Unbuffered: Split buffer in the largest multiple of BUFSIZ < INT_MAX
       * as some legacy code may expect int instead of size_t.
       */
      do
	{
	  GETIOV (;);
 400d588:	00000306 	br	400d598 <__sfvwrite_r+0xa4>
 400d58c:	a4c00017 	ldw	r19,0(r20)
 400d590:	a4800117 	ldw	r18,4(r20)
 400d594:	a5000204 	addi	r20,r20,8
 400d598:	903ffc26 	beq	r18,zero,400d58c <__sfvwrite_r+0x98>
	  w = fp->_write (ptr, fp->_cookie, p,
 400d59c:	82000917 	ldw	r8,36(r16)
 400d5a0:	81000717 	ldw	r4,28(r16)
			  MIN (len, INT_MAX - INT_MAX % BUFSIZ));
 400d5a4:	9005883a 	mov	r2,r18
 400d5a8:	00e00034 	movhi	r3,32768
 400d5ac:	18ff0004 	addi	r3,r3,-1024
 400d5b0:	1880022e 	bgeu	r3,r2,400d5bc <__sfvwrite_r+0xc8>
 400d5b4:	00a00034 	movhi	r2,32768
 400d5b8:	10bf0004 	addi	r2,r2,-1024
	  w = fp->_write (ptr, fp->_cookie, p,
 400d5bc:	100f883a 	mov	r7,r2
 400d5c0:	980d883a 	mov	r6,r19
 400d5c4:	200b883a 	mov	r5,r4
 400d5c8:	e13ff217 	ldw	r4,-56(fp)
 400d5cc:	403ee83a 	callr	r8
 400d5d0:	1023883a 	mov	r17,r2
	  if (w <= 0)
 400d5d4:	04412c0e 	bge	zero,r17,400da88 <__sfvwrite_r+0x594>
	    goto err;
	  p += w;
 400d5d8:	8805883a 	mov	r2,r17
 400d5dc:	98a7883a 	add	r19,r19,r2
	  len -= w;
 400d5e0:	8805883a 	mov	r2,r17
 400d5e4:	90a5c83a 	sub	r18,r18,r2
	}
      while ((uio->uio_resid -= w) != 0);
 400d5e8:	a8800217 	ldw	r2,8(r21)
 400d5ec:	8807883a 	mov	r3,r17
 400d5f0:	10c5c83a 	sub	r2,r2,r3
 400d5f4:	a8800215 	stw	r2,8(r21)
 400d5f8:	a8800217 	ldw	r2,8(r21)
 400d5fc:	103fe61e 	bne	r2,zero,400d598 <__sfvwrite_r+0xa4>
 400d600:	00011f06 	br	400da80 <__sfvwrite_r+0x58c>
    }
  else if ((fp->_flags & __SLBF) == 0)
 400d604:	8080030b 	ldhu	r2,12(r16)
 400d608:	10bfffcc 	andi	r2,r2,65535
 400d60c:	1080004c 	andi	r2,r2,1
 400d610:	1000b91e 	bne	r2,zero,400d8f8 <__sfvwrite_r+0x404>
       * we are dealing with the asprintf routines, we will
       * dynamically increase the buffer size as needed.
       */
      do
	{
	  GETIOV (;);
 400d614:	00000306 	br	400d624 <__sfvwrite_r+0x130>
 400d618:	a4c00017 	ldw	r19,0(r20)
 400d61c:	a4800117 	ldw	r18,4(r20)
 400d620:	a5000204 	addi	r20,r20,8
 400d624:	903ffc26 	beq	r18,zero,400d618 <__sfvwrite_r+0x124>
	  w = fp->_w;
 400d628:	84400217 	ldw	r17,8(r16)
	  if (fp->_flags & __SSTR)
 400d62c:	8080030b 	ldhu	r2,12(r16)
 400d630:	10bfffcc 	andi	r2,r2,65535
 400d634:	1080800c 	andi	r2,r2,512
 400d638:	10006a26 	beq	r2,zero,400d7e4 <__sfvwrite_r+0x2f0>
	    {
	      if (len >= w && fp->_flags & (__SMBF | __SOPT))
 400d63c:	8805883a 	mov	r2,r17
 400d640:	90805636 	bltu	r18,r2,400d79c <__sfvwrite_r+0x2a8>
 400d644:	8080030b 	ldhu	r2,12(r16)
 400d648:	10bfffcc 	andi	r2,r2,65535
 400d64c:	1081200c 	andi	r2,r2,1152
 400d650:	10005226 	beq	r2,zero,400d79c <__sfvwrite_r+0x2a8>
		{ /* must be asprintf family */
		  unsigned char *str;
		  int curpos = (fp->_p - fp->_bf._base);
 400d654:	80c00017 	ldw	r3,0(r16)
 400d658:	80800417 	ldw	r2,16(r16)
 400d65c:	1885c83a 	sub	r2,r3,r2
 400d660:	e0bff315 	stw	r2,-52(fp)
		     than (1+sqrt(5))/2 to accomodate malloc
		     overhead. asprintf EXPECTS us to overallocate, so
		     that it can add a trailing \0 without
		     reallocating.  The new allocation should thus be
		     max(prev_size*1.5, curpos+len+1). */
		  int newsize = fp->_bf._size * 3 / 2;
 400d664:	80c00517 	ldw	r3,20(r16)
 400d668:	1805883a 	mov	r2,r3
 400d66c:	1085883a 	add	r2,r2,r2
 400d670:	10c5883a 	add	r2,r2,r3
 400d674:	1006d7fa 	srli	r3,r2,31
 400d678:	1885883a 	add	r2,r3,r2
 400d67c:	1005d07a 	srai	r2,r2,1
 400d680:	e0bff515 	stw	r2,-44(fp)
		  if (newsize < curpos + len + 1)
 400d684:	e0bff317 	ldw	r2,-52(fp)
 400d688:	9085883a 	add	r2,r18,r2
 400d68c:	10800044 	addi	r2,r2,1
 400d690:	e0fff517 	ldw	r3,-44(fp)
 400d694:	1880042e 	bgeu	r3,r2,400d6a8 <__sfvwrite_r+0x1b4>
		    newsize = curpos + len + 1;
 400d698:	e0bff317 	ldw	r2,-52(fp)
 400d69c:	9085883a 	add	r2,r18,r2
 400d6a0:	10800044 	addi	r2,r2,1
 400d6a4:	e0bff515 	stw	r2,-44(fp)
		  if (fp->_flags & __SOPT)
 400d6a8:	8080030b 	ldhu	r2,12(r16)
 400d6ac:	10bfffcc 	andi	r2,r2,65535
 400d6b0:	1081000c 	andi	r2,r2,1024
 400d6b4:	10001726 	beq	r2,zero,400d714 <__sfvwrite_r+0x220>
		    {
		      /* asnprintf leaves original buffer alone.  */
		      str = (unsigned char *)_malloc_r (ptr, newsize);
 400d6b8:	e0bff517 	ldw	r2,-44(fp)
 400d6bc:	100b883a 	mov	r5,r2
 400d6c0:	e13ff217 	ldw	r4,-56(fp)
 400d6c4:	400e5500 	call	400e550 <_malloc_r>
 400d6c8:	e0bff615 	stw	r2,-40(fp)
		      if (!str)
 400d6cc:	e0bff617 	ldw	r2,-40(fp)
 400d6d0:	1000041e 	bne	r2,zero,400d6e4 <__sfvwrite_r+0x1f0>
			{
			  ptr->_errno = ENOMEM;
 400d6d4:	e0bff217 	ldw	r2,-56(fp)
 400d6d8:	00c00304 	movi	r3,12
 400d6dc:	10c00015 	stw	r3,0(r2)
			  goto err;
 400d6e0:	0000ee06 	br	400da9c <__sfvwrite_r+0x5a8>
			}
		      memcpy (str, fp->_bf._base, curpos);
 400d6e4:	80800417 	ldw	r2,16(r16)
 400d6e8:	e0fff317 	ldw	r3,-52(fp)
 400d6ec:	180d883a 	mov	r6,r3
 400d6f0:	100b883a 	mov	r5,r2
 400d6f4:	e13ff617 	ldw	r4,-40(fp)
 400d6f8:	40075cc0 	call	40075cc <memcpy>
		      fp->_flags = (fp->_flags & ~__SOPT) | __SMBF;
 400d6fc:	80c0030b 	ldhu	r3,12(r16)
 400d700:	00bedfc4 	movi	r2,-1153
 400d704:	1884703a 	and	r2,r3,r2
 400d708:	10802014 	ori	r2,r2,128
 400d70c:	8080030d 	sth	r2,12(r16)
 400d710:	00001506 	br	400d768 <__sfvwrite_r+0x274>
		    }
		  else
		    {
		      str = (unsigned char *)_realloc_r (ptr, fp->_bf._base,
 400d714:	80800417 	ldw	r2,16(r16)
 400d718:	e0fff517 	ldw	r3,-44(fp)
 400d71c:	180d883a 	mov	r6,r3
 400d720:	100b883a 	mov	r5,r2
 400d724:	e13ff217 	ldw	r4,-56(fp)
 400d728:	401112c0 	call	401112c <_realloc_r>
 400d72c:	e0bff615 	stw	r2,-40(fp)
							 newsize);
		      if (!str)
 400d730:	e0bff617 	ldw	r2,-40(fp)
 400d734:	10000c1e 	bne	r2,zero,400d768 <__sfvwrite_r+0x274>
			{
			  /* Free buffer which is no longer used and clear
			     __SMBF flag to avoid double free in fclose.  */
			  _free_r (ptr, fp->_bf._base);
 400d738:	80800417 	ldw	r2,16(r16)
 400d73c:	100b883a 	mov	r5,r2
 400d740:	e13ff217 	ldw	r4,-56(fp)
 400d744:	400cdd80 	call	400cdd8 <_free_r>
			  fp->_flags &=  ~__SMBF;
 400d748:	80c0030b 	ldhu	r3,12(r16)
 400d74c:	00bfdfc4 	movi	r2,-129
 400d750:	1884703a 	and	r2,r3,r2
 400d754:	8080030d 	sth	r2,12(r16)
			  /* Ensure correct errno, even if free changed it.  */
			  ptr->_errno = ENOMEM;
 400d758:	e0bff217 	ldw	r2,-56(fp)
 400d75c:	00c00304 	movi	r3,12
 400d760:	10c00015 	stw	r3,0(r2)
			  goto err;
 400d764:	0000cd06 	br	400da9c <__sfvwrite_r+0x5a8>
			}
		    }
		  fp->_bf._base = str;
 400d768:	e0bff617 	ldw	r2,-40(fp)
 400d76c:	80800415 	stw	r2,16(r16)
		  fp->_p = str + curpos;
 400d770:	e0bff317 	ldw	r2,-52(fp)
 400d774:	e0fff617 	ldw	r3,-40(fp)
 400d778:	1885883a 	add	r2,r3,r2
 400d77c:	80800015 	stw	r2,0(r16)
		  fp->_bf._size = newsize;
 400d780:	e0bff517 	ldw	r2,-44(fp)
 400d784:	80800515 	stw	r2,20(r16)
		  w = len;
 400d788:	9023883a 	mov	r17,r18
		  fp->_w = newsize - curpos;
 400d78c:	e0fff517 	ldw	r3,-44(fp)
 400d790:	e0bff317 	ldw	r2,-52(fp)
 400d794:	1885c83a 	sub	r2,r3,r2
 400d798:	80800215 	stw	r2,8(r16)
		}
	      if (len < w)
 400d79c:	8805883a 	mov	r2,r17
 400d7a0:	9080012e 	bgeu	r18,r2,400d7a8 <__sfvwrite_r+0x2b4>
		w = len;
 400d7a4:	9023883a 	mov	r17,r18
	      COPY (w);		/* copy MIN(fp->_w,len), */
 400d7a8:	80800017 	ldw	r2,0(r16)
 400d7ac:	8807883a 	mov	r3,r17
 400d7b0:	180d883a 	mov	r6,r3
 400d7b4:	980b883a 	mov	r5,r19
 400d7b8:	1009883a 	mov	r4,r2
 400d7bc:	400f3ac0 	call	400f3ac <memmove>
	      fp->_w -= w;
 400d7c0:	80800217 	ldw	r2,8(r16)
 400d7c4:	1445c83a 	sub	r2,r2,r17
 400d7c8:	80800215 	stw	r2,8(r16)
	      fp->_p += w;
 400d7cc:	80800017 	ldw	r2,0(r16)
 400d7d0:	8807883a 	mov	r3,r17
 400d7d4:	10c5883a 	add	r2,r2,r3
 400d7d8:	80800015 	stw	r2,0(r16)
	      w = len;		/* but pretend copied all */
 400d7dc:	9023883a 	mov	r17,r18
 400d7e0:	00003a06 	br	400d8cc <__sfvwrite_r+0x3d8>
	    }
	  else if (fp->_p > fp->_bf._base || len < fp->_bf._size)
 400d7e4:	80800017 	ldw	r2,0(r16)
 400d7e8:	80c00417 	ldw	r3,16(r16)
 400d7ec:	18800236 	bltu	r3,r2,400d7f8 <__sfvwrite_r+0x304>
 400d7f0:	80800517 	ldw	r2,20(r16)
 400d7f4:	9080192e 	bgeu	r18,r2,400d85c <__sfvwrite_r+0x368>
	    {
	      /* pass through the buffer */
	      w = MIN (len, w);
 400d7f8:	8807883a 	mov	r3,r17
 400d7fc:	9005883a 	mov	r2,r18
 400d800:	1880012e 	bgeu	r3,r2,400d808 <__sfvwrite_r+0x314>
 400d804:	1805883a 	mov	r2,r3
 400d808:	1023883a 	mov	r17,r2
	      COPY (w);
 400d80c:	80800017 	ldw	r2,0(r16)
 400d810:	8807883a 	mov	r3,r17
 400d814:	180d883a 	mov	r6,r3
 400d818:	980b883a 	mov	r5,r19
 400d81c:	1009883a 	mov	r4,r2
 400d820:	400f3ac0 	call	400f3ac <memmove>
	      fp->_w -= w;
 400d824:	80800217 	ldw	r2,8(r16)
 400d828:	1445c83a 	sub	r2,r2,r17
 400d82c:	80800215 	stw	r2,8(r16)
	      fp->_p += w;
 400d830:	80800017 	ldw	r2,0(r16)
 400d834:	8807883a 	mov	r3,r17
 400d838:	10c5883a 	add	r2,r2,r3
 400d83c:	80800015 	stw	r2,0(r16)
	      if (fp->_w == 0 && _fflush_r (ptr, fp))
 400d840:	80800217 	ldw	r2,8(r16)
 400d844:	1000201e 	bne	r2,zero,400d8c8 <__sfvwrite_r+0x3d4>
 400d848:	800b883a 	mov	r5,r16
 400d84c:	e13ff217 	ldw	r4,-56(fp)
 400d850:	400c6940 	call	400c694 <_fflush_r>
 400d854:	10001c26 	beq	r2,zero,400d8c8 <__sfvwrite_r+0x3d4>
		goto err;
 400d858:	00009006 	br	400da9c <__sfvwrite_r+0x5a8>
	    }
	  else
	    {
	      /* write directly */
	      w = ((int)MIN (len, INT_MAX)) / fp->_bf._size * fp->_bf._size;
 400d85c:	00a00034 	movhi	r2,32768
 400d860:	10bfff84 	addi	r2,r2,-2
 400d864:	14800236 	bltu	r2,r18,400d870 <__sfvwrite_r+0x37c>
 400d868:	9005883a 	mov	r2,r18
 400d86c:	00000206 	br	400d878 <__sfvwrite_r+0x384>
 400d870:	00a00034 	movhi	r2,32768
 400d874:	10bfffc4 	addi	r2,r2,-1
 400d878:	80c00517 	ldw	r3,20(r16)
 400d87c:	180b883a 	mov	r5,r3
 400d880:	1009883a 	mov	r4,r2
 400d884:	40073f00 	call	40073f0 <__divsi3>
 400d888:	1007883a 	mov	r3,r2
 400d88c:	80800517 	ldw	r2,20(r16)
 400d890:	100b883a 	mov	r5,r2
 400d894:	1809883a 	mov	r4,r3
 400d898:	40075a40 	call	40075a4 <__mulsi3>
 400d89c:	1023883a 	mov	r17,r2
	      w = fp->_write (ptr, fp->_cookie, p, w);
 400d8a0:	80800917 	ldw	r2,36(r16)
 400d8a4:	80c00717 	ldw	r3,28(r16)
 400d8a8:	880f883a 	mov	r7,r17
 400d8ac:	980d883a 	mov	r6,r19
 400d8b0:	180b883a 	mov	r5,r3
 400d8b4:	e13ff217 	ldw	r4,-56(fp)
 400d8b8:	103ee83a 	callr	r2
 400d8bc:	1023883a 	mov	r17,r2
	      if (w <= 0)
 400d8c0:	0440730e 	bge	zero,r17,400da90 <__sfvwrite_r+0x59c>
 400d8c4:	00000106 	br	400d8cc <__sfvwrite_r+0x3d8>
	      if (fp->_w == 0 && _fflush_r (ptr, fp))
 400d8c8:	0001883a 	nop
		goto err;
	    }
	  p += w;
 400d8cc:	8805883a 	mov	r2,r17
 400d8d0:	98a7883a 	add	r19,r19,r2
	  len -= w;
 400d8d4:	8805883a 	mov	r2,r17
 400d8d8:	90a5c83a 	sub	r18,r18,r2
	}
      while ((uio->uio_resid -= w) != 0);
 400d8dc:	a8800217 	ldw	r2,8(r21)
 400d8e0:	8807883a 	mov	r3,r17
 400d8e4:	10c5c83a 	sub	r2,r2,r3
 400d8e8:	a8800215 	stw	r2,8(r21)
 400d8ec:	a8800217 	ldw	r2,8(r21)
 400d8f0:	103f4c1e 	bne	r2,zero,400d624 <__sfvwrite_r+0x130>
 400d8f4:	00006206 	br	400da80 <__sfvwrite_r+0x58c>
       * must check for newlines.  Compute the distance
       * to the first newline (including the newline),
       * or `infinity' if there is none, then pretend
       * that the amount to write is MIN(len,nldist).
       */
      nlknown = 0;
 400d8f8:	e03ff815 	stw	zero,-32(fp)
      nldist = 0;
 400d8fc:	e03ff715 	stw	zero,-36(fp)
      do
	{
	  GETIOV (nlknown = 0);
 400d900:	00000406 	br	400d914 <__sfvwrite_r+0x420>
 400d904:	e03ff815 	stw	zero,-32(fp)
 400d908:	a4c00017 	ldw	r19,0(r20)
 400d90c:	a4800117 	ldw	r18,4(r20)
 400d910:	a5000204 	addi	r20,r20,8
 400d914:	903ffb26 	beq	r18,zero,400d904 <__sfvwrite_r+0x410>
	  if (!nlknown)
 400d918:	e0bff817 	ldw	r2,-32(fp)
 400d91c:	10000f1e 	bne	r2,zero,400d95c <__sfvwrite_r+0x468>
	    {
	      nl = memchr ((void *) p, '\n', len);
 400d920:	900d883a 	mov	r6,r18
 400d924:	01400284 	movi	r5,10
 400d928:	9809883a 	mov	r4,r19
 400d92c:	400f1f00 	call	400f1f0 <memchr>
 400d930:	e0bff415 	stw	r2,-48(fp)
	      nldist = nl ? nl + 1 - p : len + 1;
 400d934:	e0bff417 	ldw	r2,-48(fp)
 400d938:	10000426 	beq	r2,zero,400d94c <__sfvwrite_r+0x458>
 400d93c:	e0bff417 	ldw	r2,-48(fp)
 400d940:	10800044 	addi	r2,r2,1
 400d944:	14c5c83a 	sub	r2,r2,r19
 400d948:	00000106 	br	400d950 <__sfvwrite_r+0x45c>
 400d94c:	90800044 	addi	r2,r18,1
 400d950:	e0bff715 	stw	r2,-36(fp)
	      nlknown = 1;
 400d954:	00800044 	movi	r2,1
 400d958:	e0bff815 	stw	r2,-32(fp)
	    }
	  s = MIN (len, nldist);
 400d95c:	e0fff717 	ldw	r3,-36(fp)
 400d960:	9005883a 	mov	r2,r18
 400d964:	1880012e 	bgeu	r3,r2,400d96c <__sfvwrite_r+0x478>
 400d968:	1805883a 	mov	r2,r3
 400d96c:	102d883a 	mov	r22,r2
	  w = fp->_w + fp->_bf._size;
 400d970:	80c00217 	ldw	r3,8(r16)
 400d974:	80800517 	ldw	r2,20(r16)
 400d978:	18a3883a 	add	r17,r3,r2
	  if (fp->_p > fp->_bf._base && s > w)
 400d97c:	80800017 	ldw	r2,0(r16)
 400d980:	80c00417 	ldw	r3,16(r16)
 400d984:	1880102e 	bgeu	r3,r2,400d9c8 <__sfvwrite_r+0x4d4>
 400d988:	8d800f0e 	bge	r17,r22,400d9c8 <__sfvwrite_r+0x4d4>
	    {
	      COPY (w);
 400d98c:	80800017 	ldw	r2,0(r16)
 400d990:	8807883a 	mov	r3,r17
 400d994:	180d883a 	mov	r6,r3
 400d998:	980b883a 	mov	r5,r19
 400d99c:	1009883a 	mov	r4,r2
 400d9a0:	400f3ac0 	call	400f3ac <memmove>
	      /* fp->_w -= w; */
	      fp->_p += w;
 400d9a4:	80800017 	ldw	r2,0(r16)
 400d9a8:	8807883a 	mov	r3,r17
 400d9ac:	10c5883a 	add	r2,r2,r3
 400d9b0:	80800015 	stw	r2,0(r16)
	      if (_fflush_r (ptr, fp))
 400d9b4:	800b883a 	mov	r5,r16
 400d9b8:	e13ff217 	ldw	r4,-56(fp)
 400d9bc:	400c6940 	call	400c694 <_fflush_r>
 400d9c0:	10001b26 	beq	r2,zero,400da30 <__sfvwrite_r+0x53c>
		goto err;
 400d9c4:	00003506 	br	400da9c <__sfvwrite_r+0x5a8>
	    }
	  else if (s >= (w = fp->_bf._size))
 400d9c8:	84400517 	ldw	r17,20(r16)
 400d9cc:	b4400a16 	blt	r22,r17,400d9f8 <__sfvwrite_r+0x504>
	    {
	      w = fp->_write (ptr, fp->_cookie, p, w);
 400d9d0:	80800917 	ldw	r2,36(r16)
 400d9d4:	80c00717 	ldw	r3,28(r16)
 400d9d8:	880f883a 	mov	r7,r17
 400d9dc:	980d883a 	mov	r6,r19
 400d9e0:	180b883a 	mov	r5,r3
 400d9e4:	e13ff217 	ldw	r4,-56(fp)
 400d9e8:	103ee83a 	callr	r2
 400d9ec:	1023883a 	mov	r17,r2
	      if (w <= 0)
 400d9f0:	04400f16 	blt	zero,r17,400da30 <__sfvwrite_r+0x53c>
		goto err;
 400d9f4:	00002906 	br	400da9c <__sfvwrite_r+0x5a8>
	    }
	  else
	    {
	      w = s;
 400d9f8:	b023883a 	mov	r17,r22
	      COPY (w);
 400d9fc:	80800017 	ldw	r2,0(r16)
 400da00:	8807883a 	mov	r3,r17
 400da04:	180d883a 	mov	r6,r3
 400da08:	980b883a 	mov	r5,r19
 400da0c:	1009883a 	mov	r4,r2
 400da10:	400f3ac0 	call	400f3ac <memmove>
	      fp->_w -= w;
 400da14:	80800217 	ldw	r2,8(r16)
 400da18:	1445c83a 	sub	r2,r2,r17
 400da1c:	80800215 	stw	r2,8(r16)
	      fp->_p += w;
 400da20:	80800017 	ldw	r2,0(r16)
 400da24:	8807883a 	mov	r3,r17
 400da28:	10c5883a 	add	r2,r2,r3
 400da2c:	80800015 	stw	r2,0(r16)
	    }
	  if ((nldist -= w) == 0)
 400da30:	e0bff717 	ldw	r2,-36(fp)
 400da34:	1445c83a 	sub	r2,r2,r17
 400da38:	e0bff715 	stw	r2,-36(fp)
 400da3c:	e0bff717 	ldw	r2,-36(fp)
 400da40:	1000051e 	bne	r2,zero,400da58 <__sfvwrite_r+0x564>
	    {
	      /* copied the newline: flush and forget */
	      if (_fflush_r (ptr, fp))
 400da44:	800b883a 	mov	r5,r16
 400da48:	e13ff217 	ldw	r4,-56(fp)
 400da4c:	400c6940 	call	400c694 <_fflush_r>
 400da50:	1000111e 	bne	r2,zero,400da98 <__sfvwrite_r+0x5a4>
		goto err;
	      nlknown = 0;
 400da54:	e03ff815 	stw	zero,-32(fp)
	    }
	  p += w;
 400da58:	8805883a 	mov	r2,r17
 400da5c:	98a7883a 	add	r19,r19,r2
	  len -= w;
 400da60:	8805883a 	mov	r2,r17
 400da64:	90a5c83a 	sub	r18,r18,r2
	}
      while ((uio->uio_resid -= w) != 0);
 400da68:	a8800217 	ldw	r2,8(r21)
 400da6c:	8807883a 	mov	r3,r17
 400da70:	10c5c83a 	sub	r2,r2,r3
 400da74:	a8800215 	stw	r2,8(r21)
 400da78:	a8800217 	ldw	r2,8(r21)
 400da7c:	103fa51e 	bne	r2,zero,400d914 <__sfvwrite_r+0x420>
    }
  return 0;
 400da80:	0005883a 	mov	r2,zero
 400da84:	00000906 	br	400daac <__sfvwrite_r+0x5b8>
	    goto err;
 400da88:	0001883a 	nop
 400da8c:	00000306 	br	400da9c <__sfvwrite_r+0x5a8>
		goto err;
 400da90:	0001883a 	nop
 400da94:	00000106 	br	400da9c <__sfvwrite_r+0x5a8>
		goto err;
 400da98:	0001883a 	nop

err:
  fp->_flags |= __SERR;
 400da9c:	8080030b 	ldhu	r2,12(r16)
 400daa0:	10801014 	ori	r2,r2,64
 400daa4:	8080030d 	sth	r2,12(r16)
  return EOF;
 400daa8:	00bfffc4 	movi	r2,-1
}
 400daac:	e6fff904 	addi	sp,fp,-28
 400dab0:	dfc00817 	ldw	ra,32(sp)
 400dab4:	df000717 	ldw	fp,28(sp)
 400dab8:	dd800617 	ldw	r22,24(sp)
 400dabc:	dd400517 	ldw	r21,20(sp)
 400dac0:	dd000417 	ldw	r20,16(sp)
 400dac4:	dcc00317 	ldw	r19,12(sp)
 400dac8:	dc800217 	ldw	r18,8(sp)
 400dacc:	dc400117 	ldw	r17,4(sp)
 400dad0:	dc000017 	ldw	r16,0(sp)
 400dad4:	dec00904 	addi	sp,sp,36
 400dad8:	f800283a 	ret

0400dadc <_fwalk>:
#include "local.h"

int
_fwalk (struct _reent *ptr,
       register int (*function) (FILE *))
{
 400dadc:	defff804 	addi	sp,sp,-32
 400dae0:	dfc00715 	stw	ra,28(sp)
 400dae4:	df000615 	stw	fp,24(sp)
 400dae8:	dd000515 	stw	r20,20(sp)
 400daec:	dcc00415 	stw	r19,16(sp)
 400daf0:	dc800315 	stw	r18,12(sp)
 400daf4:	dc400215 	stw	r17,8(sp)
 400daf8:	dc000115 	stw	r16,4(sp)
 400dafc:	df000604 	addi	fp,sp,24
 400db00:	e13ffa15 	stw	r4,-24(fp)
 400db04:	2829883a 	mov	r20,r5
  register FILE *fp;
  register int n, ret = 0;
 400db08:	0027883a 	mov	r19,zero
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
 400db0c:	e0bffa17 	ldw	r2,-24(fp)
 400db10:	1440b804 	addi	r17,r2,736
 400db14:	00001b06 	br	400db84 <_fwalk+0xa8>
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
 400db18:	8c000217 	ldw	r16,8(r17)
 400db1c:	8c800117 	ldw	r18,4(r17)
 400db20:	00001506 	br	400db78 <_fwalk+0x9c>
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
 400db24:	8080030b 	ldhu	r2,12(r16)
 400db28:	10bfffcc 	andi	r2,r2,65535
 400db2c:	10a0001c 	xori	r2,r2,32768
 400db30:	10a00004 	addi	r2,r2,-32768
 400db34:	10000f26 	beq	r2,zero,400db74 <_fwalk+0x98>
 400db38:	8080030b 	ldhu	r2,12(r16)
 400db3c:	10bfffcc 	andi	r2,r2,65535
 400db40:	10a0001c 	xori	r2,r2,32768
 400db44:	10a00004 	addi	r2,r2,-32768
 400db48:	10800060 	cmpeqi	r2,r2,1
 400db4c:	1000091e 	bne	r2,zero,400db74 <_fwalk+0x98>
 400db50:	8080038b 	ldhu	r2,14(r16)
 400db54:	10bfffcc 	andi	r2,r2,65535
 400db58:	10a0001c 	xori	r2,r2,32768
 400db5c:	10a00004 	addi	r2,r2,-32768
 400db60:	10bfffe0 	cmpeqi	r2,r2,-1
 400db64:	1000031e 	bne	r2,zero,400db74 <_fwalk+0x98>
	ret |= (*function) (fp);
 400db68:	8009883a 	mov	r4,r16
 400db6c:	a03ee83a 	callr	r20
 400db70:	98a6b03a 	or	r19,r19,r2
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
 400db74:	84001a04 	addi	r16,r16,104
 400db78:	94bfffc4 	addi	r18,r18,-1
 400db7c:	903fe90e 	bge	r18,zero,400db24 <_fwalk+0x48>
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
 400db80:	8c400017 	ldw	r17,0(r17)
 400db84:	883fe41e 	bne	r17,zero,400db18 <_fwalk+0x3c>

  return ret;
 400db88:	9805883a 	mov	r2,r19
}
 400db8c:	e6fffb04 	addi	sp,fp,-20
 400db90:	dfc00617 	ldw	ra,24(sp)
 400db94:	df000517 	ldw	fp,20(sp)
 400db98:	dd000417 	ldw	r20,16(sp)
 400db9c:	dcc00317 	ldw	r19,12(sp)
 400dba0:	dc800217 	ldw	r18,8(sp)
 400dba4:	dc400117 	ldw	r17,4(sp)
 400dba8:	dc000017 	ldw	r16,0(sp)
 400dbac:	dec00704 	addi	sp,sp,28
 400dbb0:	f800283a 	ret

0400dbb4 <_fwalk_reent>:
/* Special version of __fwalk where the function pointer is a reentrant
   I/O function (e.g. _fclose_r).  */
int
_fwalk_reent (struct _reent *ptr,
       register int (*reent_function) (struct _reent *, FILE *))
{
 400dbb4:	defff804 	addi	sp,sp,-32
 400dbb8:	dfc00715 	stw	ra,28(sp)
 400dbbc:	df000615 	stw	fp,24(sp)
 400dbc0:	dd000515 	stw	r20,20(sp)
 400dbc4:	dcc00415 	stw	r19,16(sp)
 400dbc8:	dc800315 	stw	r18,12(sp)
 400dbcc:	dc400215 	stw	r17,8(sp)
 400dbd0:	dc000115 	stw	r16,4(sp)
 400dbd4:	df000604 	addi	fp,sp,24
 400dbd8:	e13ffa15 	stw	r4,-24(fp)
 400dbdc:	2829883a 	mov	r20,r5
  register FILE *fp;
  register int n, ret = 0;
 400dbe0:	0027883a 	mov	r19,zero
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
 400dbe4:	e0bffa17 	ldw	r2,-24(fp)
 400dbe8:	1440b804 	addi	r17,r2,736
 400dbec:	00001c06 	br	400dc60 <_fwalk_reent+0xac>
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
 400dbf0:	8c000217 	ldw	r16,8(r17)
 400dbf4:	8c800117 	ldw	r18,4(r17)
 400dbf8:	00001606 	br	400dc54 <_fwalk_reent+0xa0>
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
 400dbfc:	8080030b 	ldhu	r2,12(r16)
 400dc00:	10bfffcc 	andi	r2,r2,65535
 400dc04:	10a0001c 	xori	r2,r2,32768
 400dc08:	10a00004 	addi	r2,r2,-32768
 400dc0c:	10001026 	beq	r2,zero,400dc50 <_fwalk_reent+0x9c>
 400dc10:	8080030b 	ldhu	r2,12(r16)
 400dc14:	10bfffcc 	andi	r2,r2,65535
 400dc18:	10a0001c 	xori	r2,r2,32768
 400dc1c:	10a00004 	addi	r2,r2,-32768
 400dc20:	10800060 	cmpeqi	r2,r2,1
 400dc24:	10000a1e 	bne	r2,zero,400dc50 <_fwalk_reent+0x9c>
 400dc28:	8080038b 	ldhu	r2,14(r16)
 400dc2c:	10bfffcc 	andi	r2,r2,65535
 400dc30:	10a0001c 	xori	r2,r2,32768
 400dc34:	10a00004 	addi	r2,r2,-32768
 400dc38:	10bfffe0 	cmpeqi	r2,r2,-1
 400dc3c:	1000041e 	bne	r2,zero,400dc50 <_fwalk_reent+0x9c>
	ret |= (*reent_function) (ptr, fp);
 400dc40:	800b883a 	mov	r5,r16
 400dc44:	e13ffa17 	ldw	r4,-24(fp)
 400dc48:	a03ee83a 	callr	r20
 400dc4c:	98a6b03a 	or	r19,r19,r2
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
 400dc50:	84001a04 	addi	r16,r16,104
 400dc54:	94bfffc4 	addi	r18,r18,-1
 400dc58:	903fe80e 	bge	r18,zero,400dbfc <_fwalk_reent+0x48>
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
 400dc5c:	8c400017 	ldw	r17,0(r17)
 400dc60:	883fe31e 	bne	r17,zero,400dbf0 <_fwalk_reent+0x3c>

  return ret;
 400dc64:	9805883a 	mov	r2,r19
}
 400dc68:	e6fffb04 	addi	sp,fp,-20
 400dc6c:	dfc00617 	ldw	ra,24(sp)
 400dc70:	df000517 	ldw	fp,20(sp)
 400dc74:	dd000417 	ldw	r20,16(sp)
 400dc78:	dcc00317 	ldw	r19,12(sp)
 400dc7c:	dc800217 	ldw	r18,8(sp)
 400dc80:	dc400117 	ldw	r17,4(sp)
 400dc84:	dc000017 	ldw	r16,0(sp)
 400dc88:	dec00704 	addi	sp,sp,28
 400dc8c:	f800283a 	ret

0400dc90 <__get_global_locale>:

/* In POSIX terms the global locale is the process-wide locale.  Use this
   function to always refer to the global locale. */
_ELIDABLE_INLINE struct __locale_t *
__get_global_locale ()
{
 400dc90:	deffff04 	addi	sp,sp,-4
 400dc94:	df000015 	stw	fp,0(sp)
 400dc98:	d839883a 	mov	fp,sp
  extern struct __locale_t __global_locale;
  return &__global_locale;
 400dc9c:	008100b4 	movhi	r2,1026
 400dca0:	10add804 	addi	r2,r2,-18592
}
 400dca4:	e037883a 	mov	sp,fp
 400dca8:	df000017 	ldw	fp,0(sp)
 400dcac:	dec00104 	addi	sp,sp,4
 400dcb0:	f800283a 	ret

0400dcb4 <__get_current_locale>:
   using locale info without providing a locale as parameter (*_l functions).
   The current locale is either the locale of the current thread, if the
   thread called uselocale, or the global locale if not. */
_ELIDABLE_INLINE struct __locale_t *
__get_current_locale (void)
{
 400dcb4:	defffe04 	addi	sp,sp,-8
 400dcb8:	dfc00115 	stw	ra,4(sp)
 400dcbc:	df000015 	stw	fp,0(sp)
 400dcc0:	d839883a 	mov	fp,sp
#ifdef __HAVE_LOCALE_INFO__
  return _REENT->_locale ?: __get_global_locale ();
#else
  return __get_global_locale();
 400dcc4:	400dc900 	call	400dc90 <__get_global_locale>
#endif
}
 400dcc8:	e037883a 	mov	sp,fp
 400dccc:	dfc00117 	ldw	ra,4(sp)
 400dcd0:	df000017 	ldw	fp,0(sp)
 400dcd4:	dec00204 	addi	sp,sp,8
 400dcd8:	f800283a 	ret

0400dcdc <__get_C_locale>:

/* Only access fixed "C" locale using this function.  Fake for !_MB_CAPABLE
   targets by returning ptr to globale locale. */
_ELIDABLE_INLINE struct __locale_t *
__get_C_locale (void)
{
 400dcdc:	defffe04 	addi	sp,sp,-8
 400dce0:	dfc00115 	stw	ra,4(sp)
 400dce4:	df000015 	stw	fp,0(sp)
 400dce8:	d839883a 	mov	fp,sp
#ifndef _MB_CAPABLE
  return __get_global_locale ();
 400dcec:	400dc900 	call	400dc90 <__get_global_locale>
#else
  extern const struct __locale_t __C_locale;
  return (struct __locale_t *) &__C_locale;
#endif
}
 400dcf0:	e037883a 	mov	sp,fp
 400dcf4:	dfc00117 	ldw	ra,4(sp)
 400dcf8:	df000017 	ldw	fp,0(sp)
 400dcfc:	dec00204 	addi	sp,sp,8
 400dd00:	f800283a 	ret

0400dd04 <__localeconv_l>:
#include <reent.h>
#include "setlocale.h"

struct lconv *
__localeconv_l (struct __locale_t *locale)
{
 400dd04:	defffc04 	addi	sp,sp,-16
 400dd08:	dfc00315 	stw	ra,12(sp)
 400dd0c:	df000215 	stw	fp,8(sp)
 400dd10:	df000204 	addi	fp,sp,8
 400dd14:	e13ffe15 	stw	r4,-8(fp)
  struct lconv *lconv = &locale->lconv;
 400dd18:	e0bffe17 	ldw	r2,-8(fp)
 400dd1c:	10803c04 	addi	r2,r2,240
 400dd20:	e0bfff15 	stw	r2,-4(fp)
  if (locale == __get_C_locale ())
 400dd24:	400dcdc0 	call	400dcdc <__get_C_locale>
 400dd28:	1007883a 	mov	r3,r2
 400dd2c:	e0bffe17 	ldw	r2,-8(fp)
 400dd30:	10c0021e 	bne	r2,r3,400dd3c <__localeconv_l+0x38>
    return lconv;
 400dd34:	e0bfff17 	ldw	r2,-4(fp)
 400dd38:	00000106 	br	400dd40 <__localeconv_l+0x3c>
  lconv->int_n_sep_by_space = m->n_sep_by_space[0];
  lconv->int_n_sign_posn = m->n_sign_posn[0];
  lconv->int_p_sign_posn = m->p_sign_posn[0];
#endif /* !__HAVE_LOCALE_INFO_EXTENDED__ */
#endif /* __HAVE_LOCALE_INFO__ */
  return lconv;
 400dd3c:	e0bfff17 	ldw	r2,-4(fp)
}
 400dd40:	e037883a 	mov	sp,fp
 400dd44:	dfc00117 	ldw	ra,4(sp)
 400dd48:	df000017 	ldw	fp,0(sp)
 400dd4c:	dec00204 	addi	sp,sp,8
 400dd50:	f800283a 	ret

0400dd54 <_localeconv_r>:

struct lconv *
_localeconv_r (struct _reent *data)
{
 400dd54:	defffd04 	addi	sp,sp,-12
 400dd58:	dfc00215 	stw	ra,8(sp)
 400dd5c:	df000115 	stw	fp,4(sp)
 400dd60:	df000104 	addi	fp,sp,4
 400dd64:	e13fff15 	stw	r4,-4(fp)
  /* Note that we always fall back to the global locale, even in case
     of specifying a reent.  Otherwise a call to _localeconv_r would just
     crash if the reent locale pointer is NULL. */
  return __localeconv_l (__get_current_locale ());
 400dd68:	400dcb40 	call	400dcb4 <__get_current_locale>
 400dd6c:	1009883a 	mov	r4,r2
 400dd70:	400dd040 	call	400dd04 <__localeconv_l>
}
 400dd74:	e037883a 	mov	sp,fp
 400dd78:	dfc00117 	ldw	ra,4(sp)
 400dd7c:	df000017 	ldw	fp,0(sp)
 400dd80:	dec00204 	addi	sp,sp,8
 400dd84:	f800283a 	ret

0400dd88 <localeconv>:

#ifndef _REENT_ONLY
struct lconv *
localeconv (void)
{
 400dd88:	defffe04 	addi	sp,sp,-8
 400dd8c:	dfc00115 	stw	ra,4(sp)
 400dd90:	df000015 	stw	fp,0(sp)
 400dd94:	d839883a 	mov	fp,sp
  return __localeconv_l (__get_current_locale ());
 400dd98:	400dcb40 	call	400dcb4 <__get_current_locale>
 400dd9c:	1009883a 	mov	r4,r2
 400dda0:	400dd040 	call	400dd04 <__localeconv_l>
}
 400dda4:	e037883a 	mov	sp,fp
 400dda8:	dfc00117 	ldw	ra,4(sp)
 400ddac:	df000017 	ldw	fp,0(sp)
 400ddb0:	dec00204 	addi	sp,sp,8
 400ddb4:	f800283a 	ret

0400ddb8 <__get_global_locale>:
{
 400ddb8:	deffff04 	addi	sp,sp,-4
 400ddbc:	df000015 	stw	fp,0(sp)
 400ddc0:	d839883a 	mov	fp,sp
  return &__global_locale;
 400ddc4:	008100b4 	movhi	r2,1026
 400ddc8:	10add804 	addi	r2,r2,-18592
}
 400ddcc:	e037883a 	mov	sp,fp
 400ddd0:	df000017 	ldw	fp,0(sp)
 400ddd4:	dec00104 	addi	sp,sp,4
 400ddd8:	f800283a 	ret

0400dddc <__get_current_locale>:
{
 400dddc:	defffe04 	addi	sp,sp,-8
 400dde0:	dfc00115 	stw	ra,4(sp)
 400dde4:	df000015 	stw	fp,0(sp)
 400dde8:	d839883a 	mov	fp,sp
  return __get_global_locale();
 400ddec:	400ddb80 	call	400ddb8 <__get_global_locale>
}
 400ddf0:	e037883a 	mov	sp,fp
 400ddf4:	dfc00117 	ldw	ra,4(sp)
 400ddf8:	df000017 	ldw	fp,0(sp)
 400ddfc:	dec00204 	addi	sp,sp,8
 400de00:	f800283a 	ret

0400de04 <_setlocale_r>:

char *
_setlocale_r (struct _reent *p,
       int category,
       const char *locale)
{
 400de04:	defffb04 	addi	sp,sp,-20
 400de08:	dfc00415 	stw	ra,16(sp)
 400de0c:	df000315 	stw	fp,12(sp)
 400de10:	df000304 	addi	fp,sp,12
 400de14:	e13fff15 	stw	r4,-4(fp)
 400de18:	e17ffe15 	stw	r5,-8(fp)
 400de1c:	e1bffd15 	stw	r6,-12(fp)
#ifndef _MB_CAPABLE
  if (locale)
 400de20:	e0bffd17 	ldw	r2,-12(fp)
 400de24:	10001026 	beq	r2,zero,400de68 <_setlocale_r+0x64>
    { 
      if (strcmp (locale, "POSIX") && strcmp (locale, "C")
 400de28:	014100b4 	movhi	r5,1026
 400de2c:	296b4704 	addi	r5,r5,-21220
 400de30:	e13ffd17 	ldw	r4,-12(fp)
 400de34:	4011ff40 	call	4011ff4 <strcmp>
 400de38:	10000b26 	beq	r2,zero,400de68 <_setlocale_r+0x64>
 400de3c:	014100b4 	movhi	r5,1026
 400de40:	296b4904 	addi	r5,r5,-21212
 400de44:	e13ffd17 	ldw	r4,-12(fp)
 400de48:	4011ff40 	call	4011ff4 <strcmp>
 400de4c:	10000626 	beq	r2,zero,400de68 <_setlocale_r+0x64>
	  && strcmp (locale, ""))
 400de50:	e0bffd17 	ldw	r2,-12(fp)
 400de54:	10800003 	ldbu	r2,0(r2)
 400de58:	10803fcc 	andi	r2,r2,255
 400de5c:	10000226 	beq	r2,zero,400de68 <_setlocale_r+0x64>
        return NULL;
 400de60:	0005883a 	mov	r2,zero
 400de64:	00000206 	br	400de70 <_setlocale_r+0x6c>
    }
  return "C";
 400de68:	008100b4 	movhi	r2,1026
 400de6c:	10ab4904 	addi	r2,r2,-21212
	  return NULL;
	}
    }
  return currentlocale ();
#endif /* _MB_CAPABLE */
}
 400de70:	e037883a 	mov	sp,fp
 400de74:	dfc00117 	ldw	ra,4(sp)
 400de78:	df000017 	ldw	fp,0(sp)
 400de7c:	dec00204 	addi	sp,sp,8
 400de80:	f800283a 	ret

0400de84 <__locale_mb_cur_max>:
}
#endif /* _MB_CAPABLE */

int
__locale_mb_cur_max (void)
{
 400de84:	defffe04 	addi	sp,sp,-8
 400de88:	dfc00115 	stw	ra,4(sp)
 400de8c:	df000015 	stw	fp,0(sp)
 400de90:	d839883a 	mov	fp,sp
#ifdef __HAVE_LOCALE_INFO__
  return __get_current_ctype_locale ()->mb_cur_max[0];
#else
  return __get_current_locale ()->mb_cur_max[0];
 400de94:	400dddc0 	call	400dddc <__get_current_locale>
 400de98:	10804a03 	ldbu	r2,296(r2)
 400de9c:	10803fcc 	andi	r2,r2,255
 400dea0:	1080201c 	xori	r2,r2,128
 400dea4:	10bfe004 	addi	r2,r2,-128
#endif
}
 400dea8:	e037883a 	mov	sp,fp
 400deac:	dfc00117 	ldw	ra,4(sp)
 400deb0:	df000017 	ldw	fp,0(sp)
 400deb4:	dec00204 	addi	sp,sp,8
 400deb8:	f800283a 	ret

0400debc <setlocale>:
#ifndef _REENT_ONLY

char *
setlocale (int category,
	const char *locale)
{
 400debc:	defffc04 	addi	sp,sp,-16
 400dec0:	dfc00315 	stw	ra,12(sp)
 400dec4:	df000215 	stw	fp,8(sp)
 400dec8:	df000204 	addi	fp,sp,8
 400decc:	e13fff15 	stw	r4,-4(fp)
 400ded0:	e17ffe15 	stw	r5,-8(fp)
  return _setlocale_r (_REENT, category, locale);
 400ded4:	d0a00117 	ldw	r2,-32764(gp)
 400ded8:	e1bffe17 	ldw	r6,-8(fp)
 400dedc:	e17fff17 	ldw	r5,-4(fp)
 400dee0:	1009883a 	mov	r4,r2
 400dee4:	400de040 	call	400de04 <_setlocale_r>
}
 400dee8:	e037883a 	mov	sp,fp
 400deec:	dfc00117 	ldw	ra,4(sp)
 400def0:	df000017 	ldw	fp,0(sp)
 400def4:	dec00204 	addi	sp,sp,8
 400def8:	f800283a 	ret

0400defc <__smakebuf_r>:
 */

void
__smakebuf_r (struct _reent *ptr,
       register FILE *fp)
{
 400defc:	defff804 	addi	sp,sp,-32
 400df00:	dfc00715 	stw	ra,28(sp)
 400df04:	df000615 	stw	fp,24(sp)
 400df08:	dc400515 	stw	r17,20(sp)
 400df0c:	dc000415 	stw	r16,16(sp)
 400df10:	df000604 	addi	fp,sp,24
 400df14:	e13ffa15 	stw	r4,-24(fp)
 400df18:	2821883a 	mov	r16,r5
  register void *p;
  int flags;
  size_t size;
  int couldbetty;

  if (fp->_flags & __SNBF)
 400df1c:	8080030b 	ldhu	r2,12(r16)
 400df20:	10bfffcc 	andi	r2,r2,65535
 400df24:	1080008c 	andi	r2,r2,2
 400df28:	10000726 	beq	r2,zero,400df48 <__smakebuf_r+0x4c>
    {
      fp->_bf._base = fp->_p = fp->_nbuf;
 400df2c:	808010c4 	addi	r2,r16,67
 400df30:	80800015 	stw	r2,0(r16)
 400df34:	80800017 	ldw	r2,0(r16)
 400df38:	80800415 	stw	r2,16(r16)
      fp->_bf._size = 1;
 400df3c:	00800044 	movi	r2,1
 400df40:	80800515 	stw	r2,20(r16)
 400df44:	00005006 	br	400e088 <__smakebuf_r+0x18c>
      return;
    }
  flags = __swhatbuf_r (ptr, fp, &size, &couldbetty);
 400df48:	e0fffb04 	addi	r3,fp,-20
 400df4c:	e0bffc04 	addi	r2,fp,-16
 400df50:	180f883a 	mov	r7,r3
 400df54:	100d883a 	mov	r6,r2
 400df58:	800b883a 	mov	r5,r16
 400df5c:	e13ffa17 	ldw	r4,-24(fp)
 400df60:	400e0a40 	call	400e0a4 <__swhatbuf_r>
 400df64:	e0bffd15 	stw	r2,-12(fp)
  /* Make unbuffered by default: */                /* IntelSpecific */
  if (couldbetty && _isatty_r (ptr, fp->_file))    /* IntelSpecific */
 400df68:	e0bffb17 	ldw	r2,-20(fp)
 400df6c:	10001126 	beq	r2,zero,400dfb4 <__smakebuf_r+0xb8>
 400df70:	8080038b 	ldhu	r2,14(r16)
 400df74:	10bfffcc 	andi	r2,r2,65535
 400df78:	10a0001c 	xori	r2,r2,32768
 400df7c:	10a00004 	addi	r2,r2,-32768
 400df80:	100b883a 	mov	r5,r2
 400df84:	e13ffa17 	ldw	r4,-24(fp)
 400df88:	4013fb00 	call	4013fb0 <_isatty_r>
 400df8c:	10000926 	beq	r2,zero,400dfb4 <__smakebuf_r+0xb8>
  {                                                /* IntelSpecific */
    fp->_flags |= __SLBF;                          /* IntelSpecific __SLBF == "line buffered */
 400df90:	8080030b 	ldhu	r2,12(r16)
 400df94:	10800054 	ori	r2,r2,1
 400df98:	8080030d 	sth	r2,12(r16)
    fp->_bf._base = fp->_p = fp->_nbuf;            /* IntelSpecific (see newlib/libc/include/stdio.h) */
 400df9c:	808010c4 	addi	r2,r16,67
 400dfa0:	80800015 	stw	r2,0(r16)
 400dfa4:	80800017 	ldw	r2,0(r16)
 400dfa8:	80800415 	stw	r2,16(r16)
    fp->_bf._size = 1;                             /* IntelSpecific */
 400dfac:	00800044 	movi	r2,1
 400dfb0:	80800515 	stw	r2,20(r16)
  }                                                /* IntelSpecific */
  if ((p = _malloc_r (ptr, size)) == NULL)
 400dfb4:	e0bffc17 	ldw	r2,-16(fp)
 400dfb8:	100b883a 	mov	r5,r2
 400dfbc:	e13ffa17 	ldw	r4,-24(fp)
 400dfc0:	400e5500 	call	400e550 <_malloc_r>
 400dfc4:	1023883a 	mov	r17,r2
 400dfc8:	8800101e 	bne	r17,zero,400e00c <__smakebuf_r+0x110>
    {
      if (!(fp->_flags & __SSTR))
 400dfcc:	8080030b 	ldhu	r2,12(r16)
 400dfd0:	10bfffcc 	andi	r2,r2,65535
 400dfd4:	1080800c 	andi	r2,r2,512
 400dfd8:	10002b1e 	bne	r2,zero,400e088 <__smakebuf_r+0x18c>
	{
	  fp->_flags = (fp->_flags & ~__SLBF) | __SNBF;
 400dfdc:	80c0030b 	ldhu	r3,12(r16)
 400dfe0:	00bfff04 	movi	r2,-4
 400dfe4:	1884703a 	and	r2,r3,r2
 400dfe8:	10800094 	ori	r2,r2,2
 400dfec:	8080030d 	sth	r2,12(r16)
	  fp->_bf._base = fp->_p = fp->_nbuf;
 400dff0:	808010c4 	addi	r2,r16,67
 400dff4:	80800015 	stw	r2,0(r16)
 400dff8:	80800017 	ldw	r2,0(r16)
 400dffc:	80800415 	stw	r2,16(r16)
	  fp->_bf._size = 1;
 400e000:	00800044 	movi	r2,1
 400e004:	80800515 	stw	r2,20(r16)
 400e008:	00001f06 	br	400e088 <__smakebuf_r+0x18c>
	}
    }
  else
    {
      ptr->__cleanup = _cleanup_r;
 400e00c:	e0fffa17 	ldw	r3,-24(fp)
 400e010:	00810074 	movhi	r2,1025
 400e014:	10b2d904 	addi	r2,r2,-13468
 400e018:	18800f15 	stw	r2,60(r3)
      fp->_flags |= __SMBF;
 400e01c:	8080030b 	ldhu	r2,12(r16)
 400e020:	10802014 	ori	r2,r2,128
 400e024:	8080030d 	sth	r2,12(r16)
      fp->_bf._base = fp->_p = (unsigned char *) p;
 400e028:	84400015 	stw	r17,0(r16)
 400e02c:	80800017 	ldw	r2,0(r16)
 400e030:	80800415 	stw	r2,16(r16)
      fp->_bf._size = size;
 400e034:	e0bffc17 	ldw	r2,-16(fp)
 400e038:	80800515 	stw	r2,20(r16)
      if (couldbetty && _isatty_r (ptr, fp->_file))
 400e03c:	e0bffb17 	ldw	r2,-20(fp)
 400e040:	10000d26 	beq	r2,zero,400e078 <__smakebuf_r+0x17c>
 400e044:	8080038b 	ldhu	r2,14(r16)
 400e048:	10bfffcc 	andi	r2,r2,65535
 400e04c:	10a0001c 	xori	r2,r2,32768
 400e050:	10a00004 	addi	r2,r2,-32768
 400e054:	100b883a 	mov	r5,r2
 400e058:	e13ffa17 	ldw	r4,-24(fp)
 400e05c:	4013fb00 	call	4013fb0 <_isatty_r>
 400e060:	10000526 	beq	r2,zero,400e078 <__smakebuf_r+0x17c>
	fp->_flags = (fp->_flags & ~__SNBF) | __SLBF;
 400e064:	80c0030b 	ldhu	r3,12(r16)
 400e068:	00bfff04 	movi	r2,-4
 400e06c:	1884703a 	and	r2,r3,r2
 400e070:	10800054 	ori	r2,r2,1
 400e074:	8080030d 	sth	r2,12(r16)
      fp->_flags |= flags;
 400e078:	8080030b 	ldhu	r2,12(r16)
 400e07c:	e0fffd17 	ldw	r3,-12(fp)
 400e080:	10c4b03a 	or	r2,r2,r3
 400e084:	8080030d 	sth	r2,12(r16)
    }
}
 400e088:	e6fffe04 	addi	sp,fp,-8
 400e08c:	dfc00317 	ldw	ra,12(sp)
 400e090:	df000217 	ldw	fp,8(sp)
 400e094:	dc400117 	ldw	r17,4(sp)
 400e098:	dc000017 	ldw	r16,0(sp)
 400e09c:	dec00404 	addi	sp,sp,16
 400e0a0:	f800283a 	ret

0400e0a4 <__swhatbuf_r>:
int
__swhatbuf_r (struct _reent *ptr,
	FILE *fp,
	size_t *bufsize,
	int *couldbetty)
{
 400e0a4:	deffe704 	addi	sp,sp,-100
 400e0a8:	dfc01815 	stw	ra,96(sp)
 400e0ac:	df001715 	stw	fp,92(sp)
 400e0b0:	df001704 	addi	fp,sp,92
 400e0b4:	e13fec15 	stw	r4,-80(fp)
 400e0b8:	e17feb15 	stw	r5,-84(fp)
 400e0bc:	e1bfea15 	stw	r6,-88(fp)
 400e0c0:	e1ffe915 	stw	r7,-92(fp)
#ifdef _FSEEK_OPTIMIZATION
  const int snpt = __SNPT;
 400e0c4:	00820004 	movi	r2,2048
 400e0c8:	e0bfff15 	stw	r2,-4(fp)

  if (fp->_file < 0 || _fstat64_r (ptr, fp->_file, &st) < 0)
#else
  struct stat st;

  if (fp->_file < 0 || _fstat_r (ptr, fp->_file, &st) < 0)
 400e0cc:	e0bfeb17 	ldw	r2,-84(fp)
 400e0d0:	1080038b 	ldhu	r2,14(r2)
 400e0d4:	10bfffcc 	andi	r2,r2,65535
 400e0d8:	10a0001c 	xori	r2,r2,32768
 400e0dc:	10a00004 	addi	r2,r2,-32768
 400e0e0:	10000b16 	blt	r2,zero,400e110 <__swhatbuf_r+0x6c>
 400e0e4:	e0bfeb17 	ldw	r2,-84(fp)
 400e0e8:	1080038b 	ldhu	r2,14(r2)
 400e0ec:	10bfffcc 	andi	r2,r2,65535
 400e0f0:	10a0001c 	xori	r2,r2,32768
 400e0f4:	10a00004 	addi	r2,r2,-32768
 400e0f8:	e0ffed04 	addi	r3,fp,-76
 400e0fc:	180d883a 	mov	r6,r3
 400e100:	100b883a 	mov	r5,r2
 400e104:	e13fec17 	ldw	r4,-80(fp)
 400e108:	4013f480 	call	4013f48 <_fstat_r>
 400e10c:	1000100e 	bge	r2,zero,400e150 <__swhatbuf_r+0xac>
#endif
    {
      *couldbetty = 0;
 400e110:	e0bfe917 	ldw	r2,-92(fp)
 400e114:	10000015 	stw	zero,0(r2)
      /* Check if we are be called by asprintf family for initial buffer.  */
      if (fp->_flags & __SMBF)
 400e118:	e0bfeb17 	ldw	r2,-84(fp)
 400e11c:	1080030b 	ldhu	r2,12(r2)
 400e120:	10bfffcc 	andi	r2,r2,65535
 400e124:	1080200c 	andi	r2,r2,128
 400e128:	10000426 	beq	r2,zero,400e13c <__swhatbuf_r+0x98>
        *bufsize = _DEFAULT_ASPRINTF_BUFSIZE;
 400e12c:	e0bfea17 	ldw	r2,-88(fp)
 400e130:	00c01004 	movi	r3,64
 400e134:	10c00015 	stw	r3,0(r2)
 400e138:	00000306 	br	400e148 <__swhatbuf_r+0xa4>
      else
        *bufsize = BUFSIZ;
 400e13c:	e0bfea17 	ldw	r2,-88(fp)
 400e140:	00c10004 	movi	r3,1024
 400e144:	10c00015 	stw	r3,0(r2)
      return (0);
 400e148:	0005883a 	mov	r2,zero
 400e14c:	00000a06 	br	400e178 <__swhatbuf_r+0xd4>
    }

  /* could be a tty iff it is a character device */
  *couldbetty = S_ISCHR(st.st_mode);
 400e150:	e0bfee17 	ldw	r2,-72(fp)
 400e154:	10bc000c 	andi	r2,r2,61440
 400e158:	10880020 	cmpeqi	r2,r2,8192
 400e15c:	10c03fcc 	andi	r3,r2,255
 400e160:	e0bfe917 	ldw	r2,-92(fp)
 400e164:	10c00015 	stw	r3,0(r2)
      *bufsize = st.st_blksize;
      fp->_blksize = st.st_blksize;
      return ((st.st_mode & S_IFMT) == S_IFREG ?  __SOPT : snpt);
    }
#endif
  *bufsize = BUFSIZ;
 400e168:	e0bfea17 	ldw	r2,-88(fp)
 400e16c:	00c10004 	movi	r3,1024
 400e170:	10c00015 	stw	r3,0(r2)
  return (snpt);
 400e174:	e0bfff17 	ldw	r2,-4(fp)
}
 400e178:	e037883a 	mov	sp,fp
 400e17c:	dfc00117 	ldw	ra,4(sp)
 400e180:	df000017 	ldw	fp,0(sp)
 400e184:	dec00204 	addi	sp,sp,8
 400e188:	f800283a 	ret

0400e18c <malloc_extend_top>:
{
 400e18c:	defff104 	addi	sp,sp,-60
 400e190:	dfc00e15 	stw	ra,56(sp)
 400e194:	df000d15 	stw	fp,52(sp)
 400e198:	df000d04 	addi	fp,sp,52
 400e19c:	e13ff415 	stw	r4,-48(fp)
 400e1a0:	e17ff315 	stw	r5,-52(fp)
  int correction_failed = 0;      /* whether we should relax the assertion */
 400e1a4:	e03ffb15 	stw	zero,-20(fp)
  mchunkptr old_top     = top;  /* Record state of old top */
 400e1a8:	008100b4 	movhi	r2,1026
 400e1ac:	10ae3304 	addi	r2,r2,-18228
 400e1b0:	10800217 	ldw	r2,8(r2)
 400e1b4:	e0bffa15 	stw	r2,-24(fp)
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
 400e1b8:	e0bffa17 	ldw	r2,-24(fp)
 400e1bc:	10c00117 	ldw	r3,4(r2)
 400e1c0:	00bfff04 	movi	r2,-4
 400e1c4:	1884703a 	and	r2,r3,r2
 400e1c8:	e0bff915 	stw	r2,-28(fp)
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));
 400e1cc:	e0fffa17 	ldw	r3,-24(fp)
 400e1d0:	e0bff917 	ldw	r2,-28(fp)
 400e1d4:	1885883a 	add	r2,r3,r2
 400e1d8:	e0bff815 	stw	r2,-32(fp)
  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
 400e1dc:	d0e72617 	ldw	r3,-25448(gp)
 400e1e0:	e0bff317 	ldw	r2,-52(fp)
 400e1e4:	1885883a 	add	r2,r3,r2
 400e1e8:	10800404 	addi	r2,r2,16
 400e1ec:	e0bffc15 	stw	r2,-16(fp)
  unsigned long pagesz    = malloc_getpagesize;
 400e1f0:	00840004 	movi	r2,4096
 400e1f4:	e0bff715 	stw	r2,-36(fp)
  if (sbrk_base != (char*)(-1))
 400e1f8:	d0a00417 	ldw	r2,-32752(gp)
 400e1fc:	10bfffe0 	cmpeqi	r2,r2,-1
 400e200:	1000081e 	bne	r2,zero,400e224 <malloc_extend_top+0x98>
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);
 400e204:	e0fff717 	ldw	r3,-36(fp)
 400e208:	e0bffc17 	ldw	r2,-16(fp)
 400e20c:	1885883a 	add	r2,r3,r2
 400e210:	10ffffc4 	addi	r3,r2,-1
 400e214:	e0bff717 	ldw	r2,-36(fp)
 400e218:	0085c83a 	sub	r2,zero,r2
 400e21c:	1884703a 	and	r2,r3,r2
 400e220:	e0bffc15 	stw	r2,-16(fp)
  brk = (char*)(MORECORE (sbrk_size));
 400e224:	e0bffc17 	ldw	r2,-16(fp)
 400e228:	100b883a 	mov	r5,r2
 400e22c:	e13ff417 	ldw	r4,-48(fp)
 400e230:	4011d200 	call	4011d20 <_sbrk_r>
 400e234:	e0bfff15 	stw	r2,-4(fp)
  if (brk == (char*)(MORECORE_FAILURE) || 
 400e238:	e0bfff17 	ldw	r2,-4(fp)
 400e23c:	10bfffe0 	cmpeqi	r2,r2,-1
 400e240:	1000bd1e 	bne	r2,zero,400e538 <malloc_extend_top+0x3ac>
 400e244:	e0ffff17 	ldw	r3,-4(fp)
 400e248:	e0bff817 	ldw	r2,-32(fp)
 400e24c:	1880042e 	bgeu	r3,r2,400e260 <malloc_extend_top+0xd4>
      (brk < old_end && old_top != initial_top))
 400e250:	008100b4 	movhi	r2,1026
 400e254:	10ae3304 	addi	r2,r2,-18228
 400e258:	e0fffa17 	ldw	r3,-24(fp)
 400e25c:	1880b61e 	bne	r3,r2,400e538 <malloc_extend_top+0x3ac>
  sbrked_mem += sbrk_size;
 400e260:	008120b4 	movhi	r2,1154
 400e264:	10bb2617 	ldw	r2,-4968(r2)
 400e268:	1007883a 	mov	r3,r2
 400e26c:	e0bffc17 	ldw	r2,-16(fp)
 400e270:	1885883a 	add	r2,r3,r2
 400e274:	1007883a 	mov	r3,r2
 400e278:	008120b4 	movhi	r2,1154
 400e27c:	10fb2615 	stw	r3,-4968(r2)
  if (brk == old_end /* can just add bytes to current top, unless
 400e280:	e0ffff17 	ldw	r3,-4(fp)
 400e284:	e0bff817 	ldw	r2,-32(fp)
 400e288:	1880101e 	bne	r3,r2,400e2cc <malloc_extend_top+0x140>
      && ((POINTER_UINT)old_end & (pagesz - 1)) == 0)
 400e28c:	e0bff717 	ldw	r2,-36(fp)
 400e290:	10ffffc4 	addi	r3,r2,-1
 400e294:	e0bff817 	ldw	r2,-32(fp)
 400e298:	1884703a 	and	r2,r3,r2
 400e29c:	10000b1e 	bne	r2,zero,400e2cc <malloc_extend_top+0x140>
    top_size = sbrk_size + old_top_size;
 400e2a0:	e0fffc17 	ldw	r3,-16(fp)
 400e2a4:	e0bff917 	ldw	r2,-28(fp)
 400e2a8:	1885883a 	add	r2,r3,r2
 400e2ac:	e0bff615 	stw	r2,-40(fp)
    set_head(top, top_size | PREV_INUSE);
 400e2b0:	008100b4 	movhi	r2,1026
 400e2b4:	10ae3304 	addi	r2,r2,-18228
 400e2b8:	10800217 	ldw	r2,8(r2)
 400e2bc:	e0fff617 	ldw	r3,-40(fp)
 400e2c0:	18c00054 	ori	r3,r3,1
 400e2c4:	10c00115 	stw	r3,4(r2)
 400e2c8:	00008a06 	br	400e4f4 <malloc_extend_top+0x368>
    if (sbrk_base == (char*)(-1))  /* First time through. Record base */
 400e2cc:	d0a00417 	ldw	r2,-32752(gp)
 400e2d0:	10bfffd8 	cmpnei	r2,r2,-1
 400e2d4:	1000031e 	bne	r2,zero,400e2e4 <malloc_extend_top+0x158>
      sbrk_base = brk;
 400e2d8:	e0bfff17 	ldw	r2,-4(fp)
 400e2dc:	d0a00415 	stw	r2,-32752(gp)
 400e2e0:	00000806 	br	400e304 <malloc_extend_top+0x178>
      sbrked_mem += brk - (char*)old_end;
 400e2e4:	008120b4 	movhi	r2,1154
 400e2e8:	10fb2617 	ldw	r3,-4968(r2)
 400e2ec:	e13fff17 	ldw	r4,-4(fp)
 400e2f0:	e0bff817 	ldw	r2,-32(fp)
 400e2f4:	2085c83a 	sub	r2,r4,r2
 400e2f8:	1887883a 	add	r3,r3,r2
 400e2fc:	008120b4 	movhi	r2,1154
 400e300:	10fb2615 	stw	r3,-4968(r2)
    front_misalign = (POINTER_UINT)chunk2mem(brk) & MALLOC_ALIGN_MASK;
 400e304:	e0bfff17 	ldw	r2,-4(fp)
 400e308:	10800204 	addi	r2,r2,8
 400e30c:	108001cc 	andi	r2,r2,7
 400e310:	e0bff515 	stw	r2,-44(fp)
    if (front_misalign > 0) 
 400e314:	e0bff517 	ldw	r2,-44(fp)
 400e318:	10000926 	beq	r2,zero,400e340 <malloc_extend_top+0x1b4>
      correction = (MALLOC_ALIGNMENT) - front_misalign;
 400e31c:	00c00204 	movi	r3,8
 400e320:	e0bff517 	ldw	r2,-44(fp)
 400e324:	1885c83a 	sub	r2,r3,r2
 400e328:	e0bffe15 	stw	r2,-8(fp)
      brk += correction;
 400e32c:	e0ffff17 	ldw	r3,-4(fp)
 400e330:	e0bffe17 	ldw	r2,-8(fp)
 400e334:	1885883a 	add	r2,r3,r2
 400e338:	e0bfff15 	stw	r2,-4(fp)
 400e33c:	00000106 	br	400e344 <malloc_extend_top+0x1b8>
      correction = 0;
 400e340:	e03ffe15 	stw	zero,-8(fp)
    correction += pagesz - ((POINTER_UINT)(brk + sbrk_size) & (pagesz - 1));
 400e344:	e0ffff17 	ldw	r3,-4(fp)
 400e348:	e0bffc17 	ldw	r2,-16(fp)
 400e34c:	1885883a 	add	r2,r3,r2
 400e350:	1007883a 	mov	r3,r2
 400e354:	e0bff717 	ldw	r2,-36(fp)
 400e358:	10bfffc4 	addi	r2,r2,-1
 400e35c:	1884703a 	and	r2,r3,r2
 400e360:	e0fff717 	ldw	r3,-36(fp)
 400e364:	1885c83a 	sub	r2,r3,r2
 400e368:	e0fffe17 	ldw	r3,-8(fp)
 400e36c:	1885883a 	add	r2,r3,r2
 400e370:	e0bffe15 	stw	r2,-8(fp)
    correction &= (pagesz - 1);
 400e374:	e0bff717 	ldw	r2,-36(fp)
 400e378:	10bfffc4 	addi	r2,r2,-1
 400e37c:	e0fffe17 	ldw	r3,-8(fp)
 400e380:	1884703a 	and	r2,r3,r2
 400e384:	e0bffe15 	stw	r2,-8(fp)
    new_brk = (char*)(MORECORE (correction));
 400e388:	e0bffe17 	ldw	r2,-8(fp)
 400e38c:	100b883a 	mov	r5,r2
 400e390:	e13ff417 	ldw	r4,-48(fp)
 400e394:	4011d200 	call	4011d20 <_sbrk_r>
 400e398:	e0bffd15 	stw	r2,-12(fp)
    if (new_brk == (char*)(MORECORE_FAILURE))
 400e39c:	e0bffd17 	ldw	r2,-12(fp)
 400e3a0:	10bfffd8 	cmpnei	r2,r2,-1
 400e3a4:	10000e1e 	bne	r2,zero,400e3e0 <malloc_extend_top+0x254>
	correction = 0;
 400e3a8:	e03ffe15 	stw	zero,-8(fp)
	correction_failed = 1;
 400e3ac:	00800044 	movi	r2,1
 400e3b0:	e0bffb15 	stw	r2,-20(fp)
	new_brk = brk + sbrk_size;
 400e3b4:	e0ffff17 	ldw	r3,-4(fp)
 400e3b8:	e0bffc17 	ldw	r2,-16(fp)
 400e3bc:	1885883a 	add	r2,r3,r2
 400e3c0:	e0bffd15 	stw	r2,-12(fp)
	if (front_misalign > 0)
 400e3c4:	e0bff517 	ldw	r2,-44(fp)
 400e3c8:	10000526 	beq	r2,zero,400e3e0 <malloc_extend_top+0x254>
	  new_brk -= (MALLOC_ALIGNMENT) - front_misalign;
 400e3cc:	e0bff517 	ldw	r2,-44(fp)
 400e3d0:	10bffe04 	addi	r2,r2,-8
 400e3d4:	e0fffd17 	ldw	r3,-12(fp)
 400e3d8:	1885883a 	add	r2,r3,r2
 400e3dc:	e0bffd15 	stw	r2,-12(fp)
    sbrked_mem += correction;
 400e3e0:	008120b4 	movhi	r2,1154
 400e3e4:	10bb2617 	ldw	r2,-4968(r2)
 400e3e8:	1007883a 	mov	r3,r2
 400e3ec:	e0bffe17 	ldw	r2,-8(fp)
 400e3f0:	1885883a 	add	r2,r3,r2
 400e3f4:	1007883a 	mov	r3,r2
 400e3f8:	008120b4 	movhi	r2,1154
 400e3fc:	10fb2615 	stw	r3,-4968(r2)
    top = (mchunkptr)brk;
 400e400:	008100b4 	movhi	r2,1026
 400e404:	10ae3304 	addi	r2,r2,-18228
 400e408:	e0ffff17 	ldw	r3,-4(fp)
 400e40c:	10c00215 	stw	r3,8(r2)
    top_size = new_brk - brk + correction;
 400e410:	e0fffd17 	ldw	r3,-12(fp)
 400e414:	e0bfff17 	ldw	r2,-4(fp)
 400e418:	1885c83a 	sub	r2,r3,r2
 400e41c:	1007883a 	mov	r3,r2
 400e420:	e0bffe17 	ldw	r2,-8(fp)
 400e424:	10c5883a 	add	r2,r2,r3
 400e428:	e0bff615 	stw	r2,-40(fp)
    set_head(top, top_size | PREV_INUSE);
 400e42c:	008100b4 	movhi	r2,1026
 400e430:	10ae3304 	addi	r2,r2,-18228
 400e434:	10800217 	ldw	r2,8(r2)
 400e438:	e0fff617 	ldw	r3,-40(fp)
 400e43c:	18c00054 	ori	r3,r3,1
 400e440:	10c00115 	stw	r3,4(r2)
    if (old_top != initial_top)
 400e444:	008100b4 	movhi	r2,1026
 400e448:	10ae3304 	addi	r2,r2,-18228
 400e44c:	e0fffa17 	ldw	r3,-24(fp)
 400e450:	18802826 	beq	r3,r2,400e4f4 <malloc_extend_top+0x368>
      if (old_top_size < MINSIZE) 
 400e454:	e0bff917 	ldw	r2,-28(fp)
 400e458:	10800428 	cmpgeui	r2,r2,16
 400e45c:	1000061e 	bne	r2,zero,400e478 <malloc_extend_top+0x2ec>
        set_head(top, PREV_INUSE); /* will force null return from malloc */
 400e460:	008100b4 	movhi	r2,1026
 400e464:	10ae3304 	addi	r2,r2,-18228
 400e468:	10800217 	ldw	r2,8(r2)
 400e46c:	00c00044 	movi	r3,1
 400e470:	10c00115 	stw	r3,4(r2)
        return;
 400e474:	00003106 	br	400e53c <malloc_extend_top+0x3b0>
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
 400e478:	e0bff917 	ldw	r2,-28(fp)
 400e47c:	10fffd04 	addi	r3,r2,-12
 400e480:	00bffe04 	movi	r2,-8
 400e484:	1884703a 	and	r2,r3,r2
 400e488:	e0bff915 	stw	r2,-28(fp)
      set_head_size(old_top, old_top_size);
 400e48c:	e0bffa17 	ldw	r2,-24(fp)
 400e490:	10800117 	ldw	r2,4(r2)
 400e494:	10c0004c 	andi	r3,r2,1
 400e498:	e0bff917 	ldw	r2,-28(fp)
 400e49c:	1886b03a 	or	r3,r3,r2
 400e4a0:	e0bffa17 	ldw	r2,-24(fp)
 400e4a4:	10c00115 	stw	r3,4(r2)
      chunk_at_offset(old_top, old_top_size          )->size =
 400e4a8:	e0fffa17 	ldw	r3,-24(fp)
 400e4ac:	e0bff917 	ldw	r2,-28(fp)
 400e4b0:	1885883a 	add	r2,r3,r2
 400e4b4:	00c00144 	movi	r3,5
 400e4b8:	10c00115 	stw	r3,4(r2)
      chunk_at_offset(old_top, old_top_size + SIZE_SZ)->size =
 400e4bc:	e0bff917 	ldw	r2,-28(fp)
 400e4c0:	10800104 	addi	r2,r2,4
 400e4c4:	e0fffa17 	ldw	r3,-24(fp)
 400e4c8:	1885883a 	add	r2,r3,r2
 400e4cc:	00c00144 	movi	r3,5
 400e4d0:	10c00115 	stw	r3,4(r2)
      if (old_top_size >= MINSIZE) 
 400e4d4:	e0bff917 	ldw	r2,-28(fp)
 400e4d8:	10800430 	cmpltui	r2,r2,16
 400e4dc:	1000051e 	bne	r2,zero,400e4f4 <malloc_extend_top+0x368>
        fREe(RCALL chunk2mem(old_top));
 400e4e0:	e0bffa17 	ldw	r2,-24(fp)
 400e4e4:	10800204 	addi	r2,r2,8
 400e4e8:	100b883a 	mov	r5,r2
 400e4ec:	e13ff417 	ldw	r4,-48(fp)
 400e4f0:	400cdd80 	call	400cdd8 <_free_r>
  if ((unsigned long)sbrked_mem > (unsigned long)max_sbrked_mem) 
 400e4f4:	008120b4 	movhi	r2,1154
 400e4f8:	10bb2617 	ldw	r2,-4968(r2)
 400e4fc:	1007883a 	mov	r3,r2
 400e500:	d0a72717 	ldw	r2,-25444(gp)
 400e504:	10c0032e 	bgeu	r2,r3,400e514 <malloc_extend_top+0x388>
    max_sbrked_mem = sbrked_mem;
 400e508:	008120b4 	movhi	r2,1154
 400e50c:	10bb2617 	ldw	r2,-4968(r2)
 400e510:	d0a72715 	stw	r2,-25444(gp)
  if ((unsigned long)(sbrked_mem) > (unsigned long)max_total_mem) 
 400e514:	008120b4 	movhi	r2,1154
 400e518:	10bb2617 	ldw	r2,-4968(r2)
 400e51c:	1007883a 	mov	r3,r2
 400e520:	d0a72817 	ldw	r2,-25440(gp)
 400e524:	10c0052e 	bgeu	r2,r3,400e53c <malloc_extend_top+0x3b0>
    max_total_mem = sbrked_mem;
 400e528:	008120b4 	movhi	r2,1154
 400e52c:	10bb2617 	ldw	r2,-4968(r2)
 400e530:	d0a72815 	stw	r2,-25440(gp)
 400e534:	00000106 	br	400e53c <malloc_extend_top+0x3b0>
    return;
 400e538:	0001883a 	nop
}
 400e53c:	e037883a 	mov	sp,fp
 400e540:	dfc00117 	ldw	ra,4(sp)
 400e544:	df000017 	ldw	fp,0(sp)
 400e548:	dec00204 	addi	sp,sp,8
 400e54c:	f800283a 	ret

0400e550 <_malloc_r>:
{
 400e550:	deffef04 	addi	sp,sp,-68
 400e554:	dfc01015 	stw	ra,64(sp)
 400e558:	df000f15 	stw	fp,60(sp)
 400e55c:	df000f04 	addi	fp,sp,60
 400e560:	e13ff215 	stw	r4,-56(fp)
 400e564:	e17ff115 	stw	r5,-60(fp)
  INTERNAL_SIZE_T nb  = request2size(bytes);  /* padded request size; */
 400e568:	e0bff117 	ldw	r2,-60(fp)
 400e56c:	108002c4 	addi	r2,r2,11
 400e570:	108005f0 	cmpltui	r2,r2,23
 400e574:	1000051e 	bne	r2,zero,400e58c <_malloc_r+0x3c>
 400e578:	e0bff117 	ldw	r2,-60(fp)
 400e57c:	10c002c4 	addi	r3,r2,11
 400e580:	00bffe04 	movi	r2,-8
 400e584:	1884703a 	and	r2,r3,r2
 400e588:	00000106 	br	400e590 <_malloc_r+0x40>
 400e58c:	00800404 	movi	r2,16
 400e590:	e0bff615 	stw	r2,-40(fp)
  if (nb > INT_MAX || nb < bytes)
 400e594:	e0bff617 	ldw	r2,-40(fp)
 400e598:	10000316 	blt	r2,zero,400e5a8 <_malloc_r+0x58>
 400e59c:	e0fff617 	ldw	r3,-40(fp)
 400e5a0:	e0bff117 	ldw	r2,-60(fp)
 400e5a4:	1880052e 	bgeu	r3,r2,400e5bc <_malloc_r+0x6c>
    RERRNO = ENOMEM;
 400e5a8:	e0bff217 	ldw	r2,-56(fp)
 400e5ac:	00c00304 	movi	r3,12
 400e5b0:	10c00015 	stw	r3,0(r2)
    return 0;
 400e5b4:	0005883a 	mov	r2,zero
 400e5b8:	0002ba06 	br	400f0a4 <_malloc_r+0xb54>
  MALLOC_LOCK;
 400e5bc:	e13ff217 	ldw	r4,-56(fp)
 400e5c0:	40187b80 	call	40187b8 <__malloc_lock>
  if (is_small_request(nb))  /* Faster version for small requests */
 400e5c4:	e0bff617 	ldw	r2,-40(fp)
 400e5c8:	10807e28 	cmpgeui	r2,r2,504
 400e5cc:	10003e1e 	bne	r2,zero,400e6c8 <_malloc_r+0x178>
    idx = smallbin_index(nb); 
 400e5d0:	e0bff617 	ldw	r2,-40(fp)
 400e5d4:	1004d0fa 	srli	r2,r2,3
 400e5d8:	e0bffe15 	stw	r2,-8(fp)
    q = bin_at(idx);
 400e5dc:	e0bffe17 	ldw	r2,-8(fp)
 400e5e0:	10800044 	addi	r2,r2,1
 400e5e4:	1085883a 	add	r2,r2,r2
 400e5e8:	100690ba 	slli	r3,r2,2
 400e5ec:	008100b4 	movhi	r2,1026
 400e5f0:	10ae3304 	addi	r2,r2,-18228
 400e5f4:	1885883a 	add	r2,r3,r2
 400e5f8:	10bffe04 	addi	r2,r2,-8
 400e5fc:	e0bff715 	stw	r2,-36(fp)
    victim = last(q);
 400e600:	e0bff717 	ldw	r2,-36(fp)
 400e604:	10800317 	ldw	r2,12(r2)
 400e608:	e0bfff15 	stw	r2,-4(fp)
    if (victim == q)
 400e60c:	e0ffff17 	ldw	r3,-4(fp)
 400e610:	e0bff717 	ldw	r2,-36(fp)
 400e614:	1880061e 	bne	r3,r2,400e630 <_malloc_r+0xe0>
      q = next_bin(q);
 400e618:	e0bff717 	ldw	r2,-36(fp)
 400e61c:	10800204 	addi	r2,r2,8
 400e620:	e0bff715 	stw	r2,-36(fp)
      victim = last(q);
 400e624:	e0bff717 	ldw	r2,-36(fp)
 400e628:	10800317 	ldw	r2,12(r2)
 400e62c:	e0bfff15 	stw	r2,-4(fp)
    if (victim != q)
 400e630:	e0ffff17 	ldw	r3,-4(fp)
 400e634:	e0bff717 	ldw	r2,-36(fp)
 400e638:	18801f26 	beq	r3,r2,400e6b8 <_malloc_r+0x168>
      victim_size = chunksize(victim);
 400e63c:	e0bfff17 	ldw	r2,-4(fp)
 400e640:	10c00117 	ldw	r3,4(r2)
 400e644:	00bfff04 	movi	r2,-4
 400e648:	1884703a 	and	r2,r3,r2
 400e64c:	e0bff515 	stw	r2,-44(fp)
      unlink(victim, bck, fwd);
 400e650:	e0bfff17 	ldw	r2,-4(fp)
 400e654:	10800317 	ldw	r2,12(r2)
 400e658:	e0bff815 	stw	r2,-32(fp)
 400e65c:	e0bfff17 	ldw	r2,-4(fp)
 400e660:	10800217 	ldw	r2,8(r2)
 400e664:	e0bff915 	stw	r2,-28(fp)
 400e668:	e0bff917 	ldw	r2,-28(fp)
 400e66c:	e0fff817 	ldw	r3,-32(fp)
 400e670:	10c00315 	stw	r3,12(r2)
 400e674:	e0bff817 	ldw	r2,-32(fp)
 400e678:	e0fff917 	ldw	r3,-28(fp)
 400e67c:	10c00215 	stw	r3,8(r2)
      set_inuse_bit_at_offset(victim, victim_size);
 400e680:	e0ffff17 	ldw	r3,-4(fp)
 400e684:	e0bff517 	ldw	r2,-44(fp)
 400e688:	1885883a 	add	r2,r3,r2
 400e68c:	10c00117 	ldw	r3,4(r2)
 400e690:	e13fff17 	ldw	r4,-4(fp)
 400e694:	e0bff517 	ldw	r2,-44(fp)
 400e698:	2085883a 	add	r2,r4,r2
 400e69c:	18c00054 	ori	r3,r3,1
 400e6a0:	10c00115 	stw	r3,4(r2)
      MALLOC_UNLOCK;
 400e6a4:	e13ff217 	ldw	r4,-56(fp)
 400e6a8:	40187dc0 	call	40187dc <__malloc_unlock>
      return chunk2mem(victim);
 400e6ac:	e0bfff17 	ldw	r2,-4(fp)
 400e6b0:	10800204 	addi	r2,r2,8
 400e6b4:	00027b06 	br	400f0a4 <_malloc_r+0xb54>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */
 400e6b8:	e0bffe17 	ldw	r2,-8(fp)
 400e6bc:	10800084 	addi	r2,r2,2
 400e6c0:	e0bffe15 	stw	r2,-8(fp)
 400e6c4:	00007206 	br	400e890 <_malloc_r+0x340>
    idx = bin_index(nb);
 400e6c8:	e0bff617 	ldw	r2,-40(fp)
 400e6cc:	1004d27a 	srli	r2,r2,9
 400e6d0:	1000031e 	bne	r2,zero,400e6e0 <_malloc_r+0x190>
 400e6d4:	e0bff617 	ldw	r2,-40(fp)
 400e6d8:	1004d0fa 	srli	r2,r2,3
 400e6dc:	00002906 	br	400e784 <_malloc_r+0x234>
 400e6e0:	e0bff617 	ldw	r2,-40(fp)
 400e6e4:	1004d27a 	srli	r2,r2,9
 400e6e8:	10800168 	cmpgeui	r2,r2,5
 400e6ec:	1000041e 	bne	r2,zero,400e700 <_malloc_r+0x1b0>
 400e6f0:	e0bff617 	ldw	r2,-40(fp)
 400e6f4:	1004d1ba 	srli	r2,r2,6
 400e6f8:	10800e04 	addi	r2,r2,56
 400e6fc:	00002106 	br	400e784 <_malloc_r+0x234>
 400e700:	e0bff617 	ldw	r2,-40(fp)
 400e704:	1004d27a 	srli	r2,r2,9
 400e708:	10800568 	cmpgeui	r2,r2,21
 400e70c:	1000041e 	bne	r2,zero,400e720 <_malloc_r+0x1d0>
 400e710:	e0bff617 	ldw	r2,-40(fp)
 400e714:	1004d27a 	srli	r2,r2,9
 400e718:	108016c4 	addi	r2,r2,91
 400e71c:	00001906 	br	400e784 <_malloc_r+0x234>
 400e720:	e0bff617 	ldw	r2,-40(fp)
 400e724:	1004d27a 	srli	r2,r2,9
 400e728:	10801568 	cmpgeui	r2,r2,85
 400e72c:	1000041e 	bne	r2,zero,400e740 <_malloc_r+0x1f0>
 400e730:	e0bff617 	ldw	r2,-40(fp)
 400e734:	1004d33a 	srli	r2,r2,12
 400e738:	10801b84 	addi	r2,r2,110
 400e73c:	00001106 	br	400e784 <_malloc_r+0x234>
 400e740:	e0bff617 	ldw	r2,-40(fp)
 400e744:	1004d27a 	srli	r2,r2,9
 400e748:	10805568 	cmpgeui	r2,r2,341
 400e74c:	1000041e 	bne	r2,zero,400e760 <_malloc_r+0x210>
 400e750:	e0bff617 	ldw	r2,-40(fp)
 400e754:	1004d3fa 	srli	r2,r2,15
 400e758:	10801dc4 	addi	r2,r2,119
 400e75c:	00000906 	br	400e784 <_malloc_r+0x234>
 400e760:	e0bff617 	ldw	r2,-40(fp)
 400e764:	1004d27a 	srli	r2,r2,9
 400e768:	10815568 	cmpgeui	r2,r2,1365
 400e76c:	1000041e 	bne	r2,zero,400e780 <_malloc_r+0x230>
 400e770:	e0bff617 	ldw	r2,-40(fp)
 400e774:	1004d4ba 	srli	r2,r2,18
 400e778:	10801f04 	addi	r2,r2,124
 400e77c:	00000106 	br	400e784 <_malloc_r+0x234>
 400e780:	00801f84 	movi	r2,126
 400e784:	e0bffe15 	stw	r2,-8(fp)
    bin = bin_at(idx);
 400e788:	e0bffe17 	ldw	r2,-8(fp)
 400e78c:	10800044 	addi	r2,r2,1
 400e790:	1085883a 	add	r2,r2,r2
 400e794:	100690ba 	slli	r3,r2,2
 400e798:	008100b4 	movhi	r2,1026
 400e79c:	10ae3304 	addi	r2,r2,-18228
 400e7a0:	1885883a 	add	r2,r3,r2
 400e7a4:	10bffe04 	addi	r2,r2,-8
 400e7a8:	e0bffd15 	stw	r2,-12(fp)
    for (victim = last(bin); victim != bin; victim = victim->bk)
 400e7ac:	e0bffd17 	ldw	r2,-12(fp)
 400e7b0:	10800317 	ldw	r2,12(r2)
 400e7b4:	e0bfff15 	stw	r2,-4(fp)
 400e7b8:	00002f06 	br	400e878 <_malloc_r+0x328>
      victim_size = chunksize(victim);
 400e7bc:	e0bfff17 	ldw	r2,-4(fp)
 400e7c0:	10c00117 	ldw	r3,4(r2)
 400e7c4:	00bfff04 	movi	r2,-4
 400e7c8:	1884703a 	and	r2,r3,r2
 400e7cc:	e0bff515 	stw	r2,-44(fp)
      remainder_size = long_sub_size_t(victim_size, nb);
 400e7d0:	e0fff517 	ldw	r3,-44(fp)
 400e7d4:	e0bff617 	ldw	r2,-40(fp)
 400e7d8:	1885c83a 	sub	r2,r3,r2
 400e7dc:	e0bffc15 	stw	r2,-16(fp)
      if (remainder_size >= (long)MINSIZE) /* too big */
 400e7e0:	e0bffc17 	ldw	r2,-16(fp)
 400e7e4:	10800410 	cmplti	r2,r2,16
 400e7e8:	1000041e 	bne	r2,zero,400e7fc <_malloc_r+0x2ac>
        --idx; /* adjust to rescan below after checking last remainder */
 400e7ec:	e0bffe17 	ldw	r2,-8(fp)
 400e7f0:	10bfffc4 	addi	r2,r2,-1
 400e7f4:	e0bffe15 	stw	r2,-8(fp)
        break;   
 400e7f8:	00002206 	br	400e884 <_malloc_r+0x334>
      else if (remainder_size >= 0) /* exact fit */
 400e7fc:	e0bffc17 	ldw	r2,-16(fp)
 400e800:	10001a16 	blt	r2,zero,400e86c <_malloc_r+0x31c>
        unlink(victim, bck, fwd);
 400e804:	e0bfff17 	ldw	r2,-4(fp)
 400e808:	10800317 	ldw	r2,12(r2)
 400e80c:	e0bff815 	stw	r2,-32(fp)
 400e810:	e0bfff17 	ldw	r2,-4(fp)
 400e814:	10800217 	ldw	r2,8(r2)
 400e818:	e0bff915 	stw	r2,-28(fp)
 400e81c:	e0bff917 	ldw	r2,-28(fp)
 400e820:	e0fff817 	ldw	r3,-32(fp)
 400e824:	10c00315 	stw	r3,12(r2)
 400e828:	e0bff817 	ldw	r2,-32(fp)
 400e82c:	e0fff917 	ldw	r3,-28(fp)
 400e830:	10c00215 	stw	r3,8(r2)
        set_inuse_bit_at_offset(victim, victim_size);
 400e834:	e0ffff17 	ldw	r3,-4(fp)
 400e838:	e0bff517 	ldw	r2,-44(fp)
 400e83c:	1885883a 	add	r2,r3,r2
 400e840:	10c00117 	ldw	r3,4(r2)
 400e844:	e13fff17 	ldw	r4,-4(fp)
 400e848:	e0bff517 	ldw	r2,-44(fp)
 400e84c:	2085883a 	add	r2,r4,r2
 400e850:	18c00054 	ori	r3,r3,1
 400e854:	10c00115 	stw	r3,4(r2)
	MALLOC_UNLOCK;
 400e858:	e13ff217 	ldw	r4,-56(fp)
 400e85c:	40187dc0 	call	40187dc <__malloc_unlock>
        return chunk2mem(victim);
 400e860:	e0bfff17 	ldw	r2,-4(fp)
 400e864:	10800204 	addi	r2,r2,8
 400e868:	00020e06 	br	400f0a4 <_malloc_r+0xb54>
    for (victim = last(bin); victim != bin; victim = victim->bk)
 400e86c:	e0bfff17 	ldw	r2,-4(fp)
 400e870:	10800317 	ldw	r2,12(r2)
 400e874:	e0bfff15 	stw	r2,-4(fp)
 400e878:	e0ffff17 	ldw	r3,-4(fp)
 400e87c:	e0bffd17 	ldw	r2,-12(fp)
 400e880:	18bfce1e 	bne	r3,r2,400e7bc <_malloc_r+0x26c>
    ++idx; 
 400e884:	e0bffe17 	ldw	r2,-8(fp)
 400e888:	10800044 	addi	r2,r2,1
 400e88c:	e0bffe15 	stw	r2,-8(fp)
  if ( (victim = last_remainder->fd) != last_remainder)
 400e890:	008100b4 	movhi	r2,1026
 400e894:	10ae3504 	addi	r2,r2,-18220
 400e898:	10800217 	ldw	r2,8(r2)
 400e89c:	e0bfff15 	stw	r2,-4(fp)
 400e8a0:	008100b4 	movhi	r2,1026
 400e8a4:	10ae3504 	addi	r2,r2,-18220
 400e8a8:	e0ffff17 	ldw	r3,-4(fp)
 400e8ac:	1880e426 	beq	r3,r2,400ec40 <_malloc_r+0x6f0>
    victim_size = chunksize(victim);
 400e8b0:	e0bfff17 	ldw	r2,-4(fp)
 400e8b4:	10c00117 	ldw	r3,4(r2)
 400e8b8:	00bfff04 	movi	r2,-4
 400e8bc:	1884703a 	and	r2,r3,r2
 400e8c0:	e0bff515 	stw	r2,-44(fp)
    remainder_size = long_sub_size_t(victim_size, nb);
 400e8c4:	e0fff517 	ldw	r3,-44(fp)
 400e8c8:	e0bff617 	ldw	r2,-40(fp)
 400e8cc:	1885c83a 	sub	r2,r3,r2
 400e8d0:	e0bffc15 	stw	r2,-16(fp)
    if (remainder_size >= (long)MINSIZE) /* re-split */
 400e8d4:	e0bffc17 	ldw	r2,-16(fp)
 400e8d8:	10800410 	cmplti	r2,r2,16
 400e8dc:	1000271e 	bne	r2,zero,400e97c <_malloc_r+0x42c>
      remainder = chunk_at_offset(victim, nb);
 400e8e0:	e0ffff17 	ldw	r3,-4(fp)
 400e8e4:	e0bff617 	ldw	r2,-40(fp)
 400e8e8:	1885883a 	add	r2,r3,r2
 400e8ec:	e0bff315 	stw	r2,-52(fp)
      set_head(victim, nb | PREV_INUSE);
 400e8f0:	e0bff617 	ldw	r2,-40(fp)
 400e8f4:	10c00054 	ori	r3,r2,1
 400e8f8:	e0bfff17 	ldw	r2,-4(fp)
 400e8fc:	10c00115 	stw	r3,4(r2)
      link_last_remainder(remainder);
 400e900:	008100b4 	movhi	r2,1026
 400e904:	10ae3504 	addi	r2,r2,-18220
 400e908:	e0fff317 	ldw	r3,-52(fp)
 400e90c:	10c00315 	stw	r3,12(r2)
 400e910:	00c100b4 	movhi	r3,1026
 400e914:	18ee3504 	addi	r3,r3,-18220
 400e918:	10800317 	ldw	r2,12(r2)
 400e91c:	18800215 	stw	r2,8(r3)
 400e920:	008100b4 	movhi	r2,1026
 400e924:	10ae3504 	addi	r2,r2,-18220
 400e928:	e0fff317 	ldw	r3,-52(fp)
 400e92c:	18800315 	stw	r2,12(r3)
 400e930:	e0bff317 	ldw	r2,-52(fp)
 400e934:	10c00317 	ldw	r3,12(r2)
 400e938:	e0bff317 	ldw	r2,-52(fp)
 400e93c:	10c00215 	stw	r3,8(r2)
      set_head(remainder, remainder_size | PREV_INUSE);
 400e940:	e0bffc17 	ldw	r2,-16(fp)
 400e944:	10800054 	ori	r2,r2,1
 400e948:	1007883a 	mov	r3,r2
 400e94c:	e0bff317 	ldw	r2,-52(fp)
 400e950:	10c00115 	stw	r3,4(r2)
      set_foot(remainder, remainder_size);
 400e954:	e0bffc17 	ldw	r2,-16(fp)
 400e958:	e0fff317 	ldw	r3,-52(fp)
 400e95c:	1885883a 	add	r2,r3,r2
 400e960:	e0fffc17 	ldw	r3,-16(fp)
 400e964:	10c00015 	stw	r3,0(r2)
      MALLOC_UNLOCK;
 400e968:	e13ff217 	ldw	r4,-56(fp)
 400e96c:	40187dc0 	call	40187dc <__malloc_unlock>
      return chunk2mem(victim);
 400e970:	e0bfff17 	ldw	r2,-4(fp)
 400e974:	10800204 	addi	r2,r2,8
 400e978:	0001ca06 	br	400f0a4 <_malloc_r+0xb54>
    clear_last_remainder;
 400e97c:	008100b4 	movhi	r2,1026
 400e980:	10ae3504 	addi	r2,r2,-18220
 400e984:	00c100b4 	movhi	r3,1026
 400e988:	18ee3504 	addi	r3,r3,-18220
 400e98c:	10c00315 	stw	r3,12(r2)
 400e990:	00c100b4 	movhi	r3,1026
 400e994:	18ee3504 	addi	r3,r3,-18220
 400e998:	10800317 	ldw	r2,12(r2)
 400e99c:	18800215 	stw	r2,8(r3)
    if (remainder_size >= 0)  /* exhaust */
 400e9a0:	e0bffc17 	ldw	r2,-16(fp)
 400e9a4:	10000e16 	blt	r2,zero,400e9e0 <_malloc_r+0x490>
      set_inuse_bit_at_offset(victim, victim_size);
 400e9a8:	e0ffff17 	ldw	r3,-4(fp)
 400e9ac:	e0bff517 	ldw	r2,-44(fp)
 400e9b0:	1885883a 	add	r2,r3,r2
 400e9b4:	10c00117 	ldw	r3,4(r2)
 400e9b8:	e13fff17 	ldw	r4,-4(fp)
 400e9bc:	e0bff517 	ldw	r2,-44(fp)
 400e9c0:	2085883a 	add	r2,r4,r2
 400e9c4:	18c00054 	ori	r3,r3,1
 400e9c8:	10c00115 	stw	r3,4(r2)
      MALLOC_UNLOCK;
 400e9cc:	e13ff217 	ldw	r4,-56(fp)
 400e9d0:	40187dc0 	call	40187dc <__malloc_unlock>
      return chunk2mem(victim);
 400e9d4:	e0bfff17 	ldw	r2,-4(fp)
 400e9d8:	10800204 	addi	r2,r2,8
 400e9dc:	0001b106 	br	400f0a4 <_malloc_r+0xb54>
    frontlink(victim, victim_size, remainder_index, bck, fwd);
 400e9e0:	e0bff517 	ldw	r2,-44(fp)
 400e9e4:	10808028 	cmpgeui	r2,r2,512
 400e9e8:	10002b1e 	bne	r2,zero,400ea98 <_malloc_r+0x548>
 400e9ec:	e0bff517 	ldw	r2,-44(fp)
 400e9f0:	1004d0fa 	srli	r2,r2,3
 400e9f4:	e0bff415 	stw	r2,-48(fp)
 400e9f8:	008100b4 	movhi	r2,1026
 400e9fc:	10ae3304 	addi	r2,r2,-18228
 400ea00:	11000117 	ldw	r4,4(r2)
 400ea04:	e0bff417 	ldw	r2,-48(fp)
 400ea08:	1000010e 	bge	r2,zero,400ea10 <_malloc_r+0x4c0>
 400ea0c:	108000c4 	addi	r2,r2,3
 400ea10:	1005d0ba 	srai	r2,r2,2
 400ea14:	1007883a 	mov	r3,r2
 400ea18:	00800044 	movi	r2,1
 400ea1c:	10c6983a 	sll	r3,r2,r3
 400ea20:	008100b4 	movhi	r2,1026
 400ea24:	10ae3304 	addi	r2,r2,-18228
 400ea28:	20c6b03a 	or	r3,r4,r3
 400ea2c:	10c00115 	stw	r3,4(r2)
 400ea30:	e0bff417 	ldw	r2,-48(fp)
 400ea34:	10800044 	addi	r2,r2,1
 400ea38:	1085883a 	add	r2,r2,r2
 400ea3c:	100690ba 	slli	r3,r2,2
 400ea40:	008100b4 	movhi	r2,1026
 400ea44:	10ae3304 	addi	r2,r2,-18228
 400ea48:	1885883a 	add	r2,r3,r2
 400ea4c:	10bffe04 	addi	r2,r2,-8
 400ea50:	e0bff815 	stw	r2,-32(fp)
 400ea54:	e0bff817 	ldw	r2,-32(fp)
 400ea58:	10800217 	ldw	r2,8(r2)
 400ea5c:	e0bff915 	stw	r2,-28(fp)
 400ea60:	e0bfff17 	ldw	r2,-4(fp)
 400ea64:	e0fff817 	ldw	r3,-32(fp)
 400ea68:	10c00315 	stw	r3,12(r2)
 400ea6c:	e0bfff17 	ldw	r2,-4(fp)
 400ea70:	e0fff917 	ldw	r3,-28(fp)
 400ea74:	10c00215 	stw	r3,8(r2)
 400ea78:	e0bff817 	ldw	r2,-32(fp)
 400ea7c:	e0ffff17 	ldw	r3,-4(fp)
 400ea80:	10c00215 	stw	r3,8(r2)
 400ea84:	e0bff817 	ldw	r2,-32(fp)
 400ea88:	10c00217 	ldw	r3,8(r2)
 400ea8c:	e0bff917 	ldw	r2,-28(fp)
 400ea90:	10c00315 	stw	r3,12(r2)
 400ea94:	00006a06 	br	400ec40 <_malloc_r+0x6f0>
 400ea98:	e0bff517 	ldw	r2,-44(fp)
 400ea9c:	1004d27a 	srli	r2,r2,9
 400eaa0:	1000031e 	bne	r2,zero,400eab0 <_malloc_r+0x560>
 400eaa4:	e0bff517 	ldw	r2,-44(fp)
 400eaa8:	1004d0fa 	srli	r2,r2,3
 400eaac:	00002906 	br	400eb54 <_malloc_r+0x604>
 400eab0:	e0bff517 	ldw	r2,-44(fp)
 400eab4:	1004d27a 	srli	r2,r2,9
 400eab8:	10800168 	cmpgeui	r2,r2,5
 400eabc:	1000041e 	bne	r2,zero,400ead0 <_malloc_r+0x580>
 400eac0:	e0bff517 	ldw	r2,-44(fp)
 400eac4:	1004d1ba 	srli	r2,r2,6
 400eac8:	10800e04 	addi	r2,r2,56
 400eacc:	00002106 	br	400eb54 <_malloc_r+0x604>
 400ead0:	e0bff517 	ldw	r2,-44(fp)
 400ead4:	1004d27a 	srli	r2,r2,9
 400ead8:	10800568 	cmpgeui	r2,r2,21
 400eadc:	1000041e 	bne	r2,zero,400eaf0 <_malloc_r+0x5a0>
 400eae0:	e0bff517 	ldw	r2,-44(fp)
 400eae4:	1004d27a 	srli	r2,r2,9
 400eae8:	108016c4 	addi	r2,r2,91
 400eaec:	00001906 	br	400eb54 <_malloc_r+0x604>
 400eaf0:	e0bff517 	ldw	r2,-44(fp)
 400eaf4:	1004d27a 	srli	r2,r2,9
 400eaf8:	10801568 	cmpgeui	r2,r2,85
 400eafc:	1000041e 	bne	r2,zero,400eb10 <_malloc_r+0x5c0>
 400eb00:	e0bff517 	ldw	r2,-44(fp)
 400eb04:	1004d33a 	srli	r2,r2,12
 400eb08:	10801b84 	addi	r2,r2,110
 400eb0c:	00001106 	br	400eb54 <_malloc_r+0x604>
 400eb10:	e0bff517 	ldw	r2,-44(fp)
 400eb14:	1004d27a 	srli	r2,r2,9
 400eb18:	10805568 	cmpgeui	r2,r2,341
 400eb1c:	1000041e 	bne	r2,zero,400eb30 <_malloc_r+0x5e0>
 400eb20:	e0bff517 	ldw	r2,-44(fp)
 400eb24:	1004d3fa 	srli	r2,r2,15
 400eb28:	10801dc4 	addi	r2,r2,119
 400eb2c:	00000906 	br	400eb54 <_malloc_r+0x604>
 400eb30:	e0bff517 	ldw	r2,-44(fp)
 400eb34:	1004d27a 	srli	r2,r2,9
 400eb38:	10815568 	cmpgeui	r2,r2,1365
 400eb3c:	1000041e 	bne	r2,zero,400eb50 <_malloc_r+0x600>
 400eb40:	e0bff517 	ldw	r2,-44(fp)
 400eb44:	1004d4ba 	srli	r2,r2,18
 400eb48:	10801f04 	addi	r2,r2,124
 400eb4c:	00000106 	br	400eb54 <_malloc_r+0x604>
 400eb50:	00801f84 	movi	r2,126
 400eb54:	e0bff415 	stw	r2,-48(fp)
 400eb58:	e0bff417 	ldw	r2,-48(fp)
 400eb5c:	10800044 	addi	r2,r2,1
 400eb60:	1085883a 	add	r2,r2,r2
 400eb64:	100690ba 	slli	r3,r2,2
 400eb68:	008100b4 	movhi	r2,1026
 400eb6c:	10ae3304 	addi	r2,r2,-18228
 400eb70:	1885883a 	add	r2,r3,r2
 400eb74:	10bffe04 	addi	r2,r2,-8
 400eb78:	e0bff815 	stw	r2,-32(fp)
 400eb7c:	e0bff817 	ldw	r2,-32(fp)
 400eb80:	10800217 	ldw	r2,8(r2)
 400eb84:	e0bff915 	stw	r2,-28(fp)
 400eb88:	e0fff917 	ldw	r3,-28(fp)
 400eb8c:	e0bff817 	ldw	r2,-32(fp)
 400eb90:	1880121e 	bne	r3,r2,400ebdc <_malloc_r+0x68c>
 400eb94:	008100b4 	movhi	r2,1026
 400eb98:	10ae3304 	addi	r2,r2,-18228
 400eb9c:	11000117 	ldw	r4,4(r2)
 400eba0:	e0bff417 	ldw	r2,-48(fp)
 400eba4:	1000010e 	bge	r2,zero,400ebac <_malloc_r+0x65c>
 400eba8:	108000c4 	addi	r2,r2,3
 400ebac:	1005d0ba 	srai	r2,r2,2
 400ebb0:	1007883a 	mov	r3,r2
 400ebb4:	00800044 	movi	r2,1
 400ebb8:	10c6983a 	sll	r3,r2,r3
 400ebbc:	008100b4 	movhi	r2,1026
 400ebc0:	10ae3304 	addi	r2,r2,-18228
 400ebc4:	20c6b03a 	or	r3,r4,r3
 400ebc8:	10c00115 	stw	r3,4(r2)
 400ebcc:	00000f06 	br	400ec0c <_malloc_r+0x6bc>
 400ebd0:	e0bff917 	ldw	r2,-28(fp)
 400ebd4:	10800217 	ldw	r2,8(r2)
 400ebd8:	e0bff915 	stw	r2,-28(fp)
 400ebdc:	e0fff917 	ldw	r3,-28(fp)
 400ebe0:	e0bff817 	ldw	r2,-32(fp)
 400ebe4:	18800626 	beq	r3,r2,400ec00 <_malloc_r+0x6b0>
 400ebe8:	e0bff917 	ldw	r2,-28(fp)
 400ebec:	10c00117 	ldw	r3,4(r2)
 400ebf0:	00bfff04 	movi	r2,-4
 400ebf4:	1884703a 	and	r2,r3,r2
 400ebf8:	e0fff517 	ldw	r3,-44(fp)
 400ebfc:	18bff436 	bltu	r3,r2,400ebd0 <_malloc_r+0x680>
 400ec00:	e0bff917 	ldw	r2,-28(fp)
 400ec04:	10800317 	ldw	r2,12(r2)
 400ec08:	e0bff815 	stw	r2,-32(fp)
 400ec0c:	e0bfff17 	ldw	r2,-4(fp)
 400ec10:	e0fff817 	ldw	r3,-32(fp)
 400ec14:	10c00315 	stw	r3,12(r2)
 400ec18:	e0bfff17 	ldw	r2,-4(fp)
 400ec1c:	e0fff917 	ldw	r3,-28(fp)
 400ec20:	10c00215 	stw	r3,8(r2)
 400ec24:	e0bff817 	ldw	r2,-32(fp)
 400ec28:	e0ffff17 	ldw	r3,-4(fp)
 400ec2c:	10c00215 	stw	r3,8(r2)
 400ec30:	e0bff817 	ldw	r2,-32(fp)
 400ec34:	10c00217 	ldw	r3,8(r2)
 400ec38:	e0bff917 	ldw	r2,-28(fp)
 400ec3c:	10c00315 	stw	r3,12(r2)
  if ( (block = idx2binblock(idx)) <= binblocks)  
 400ec40:	e0bffe17 	ldw	r2,-8(fp)
 400ec44:	1000010e 	bge	r2,zero,400ec4c <_malloc_r+0x6fc>
 400ec48:	108000c4 	addi	r2,r2,3
 400ec4c:	1005d0ba 	srai	r2,r2,2
 400ec50:	1007883a 	mov	r3,r2
 400ec54:	00800044 	movi	r2,1
 400ec58:	10c4983a 	sll	r2,r2,r3
 400ec5c:	e0bffb15 	stw	r2,-20(fp)
 400ec60:	008100b4 	movhi	r2,1026
 400ec64:	10ae3304 	addi	r2,r2,-18228
 400ec68:	10c00117 	ldw	r3,4(r2)
 400ec6c:	e0bffb17 	ldw	r2,-20(fp)
 400ec70:	1880c536 	bltu	r3,r2,400ef88 <_malloc_r+0xa38>
    if ( (block & binblocks) == 0) 
 400ec74:	008100b4 	movhi	r2,1026
 400ec78:	10ae3304 	addi	r2,r2,-18228
 400ec7c:	10c00117 	ldw	r3,4(r2)
 400ec80:	e0bffb17 	ldw	r2,-20(fp)
 400ec84:	1884703a 	and	r2,r3,r2
 400ec88:	1000151e 	bne	r2,zero,400ece0 <_malloc_r+0x790>
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
 400ec8c:	e0fffe17 	ldw	r3,-8(fp)
 400ec90:	00bfff04 	movi	r2,-4
 400ec94:	1884703a 	and	r2,r3,r2
 400ec98:	10800104 	addi	r2,r2,4
 400ec9c:	e0bffe15 	stw	r2,-8(fp)
      block <<= 1;
 400eca0:	e0bffb17 	ldw	r2,-20(fp)
 400eca4:	1085883a 	add	r2,r2,r2
 400eca8:	e0bffb15 	stw	r2,-20(fp)
      while ((block & binblocks) == 0)
 400ecac:	00000606 	br	400ecc8 <_malloc_r+0x778>
        idx += BINBLOCKWIDTH;
 400ecb0:	e0bffe17 	ldw	r2,-8(fp)
 400ecb4:	10800104 	addi	r2,r2,4
 400ecb8:	e0bffe15 	stw	r2,-8(fp)
        block <<= 1;
 400ecbc:	e0bffb17 	ldw	r2,-20(fp)
 400ecc0:	1085883a 	add	r2,r2,r2
 400ecc4:	e0bffb15 	stw	r2,-20(fp)
      while ((block & binblocks) == 0)
 400ecc8:	008100b4 	movhi	r2,1026
 400eccc:	10ae3304 	addi	r2,r2,-18228
 400ecd0:	10c00117 	ldw	r3,4(r2)
 400ecd4:	e0bffb17 	ldw	r2,-20(fp)
 400ecd8:	1884703a 	and	r2,r3,r2
 400ecdc:	103ff426 	beq	r2,zero,400ecb0 <_malloc_r+0x760>
      startidx = idx;          /* (track incomplete blocks) */
 400ece0:	e0bffe17 	ldw	r2,-8(fp)
 400ece4:	e0bffa15 	stw	r2,-24(fp)
      q = bin = bin_at(idx);
 400ece8:	e0bffe17 	ldw	r2,-8(fp)
 400ecec:	10800044 	addi	r2,r2,1
 400ecf0:	1085883a 	add	r2,r2,r2
 400ecf4:	100690ba 	slli	r3,r2,2
 400ecf8:	008100b4 	movhi	r2,1026
 400ecfc:	10ae3304 	addi	r2,r2,-18228
 400ed00:	1885883a 	add	r2,r3,r2
 400ed04:	10bffe04 	addi	r2,r2,-8
 400ed08:	e0bffd15 	stw	r2,-12(fp)
 400ed0c:	e0bffd17 	ldw	r2,-12(fp)
 400ed10:	e0bff715 	stw	r2,-36(fp)
        for (victim = last(bin); victim != bin; victim = victim->bk)
 400ed14:	e0bffd17 	ldw	r2,-12(fp)
 400ed18:	10800317 	ldw	r2,12(r2)
 400ed1c:	e0bfff15 	stw	r2,-4(fp)
 400ed20:	00005e06 	br	400ee9c <_malloc_r+0x94c>
          victim_size = chunksize(victim);
 400ed24:	e0bfff17 	ldw	r2,-4(fp)
 400ed28:	10c00117 	ldw	r3,4(r2)
 400ed2c:	00bfff04 	movi	r2,-4
 400ed30:	1884703a 	and	r2,r3,r2
 400ed34:	e0bff515 	stw	r2,-44(fp)
          remainder_size = long_sub_size_t(victim_size, nb);
 400ed38:	e0fff517 	ldw	r3,-44(fp)
 400ed3c:	e0bff617 	ldw	r2,-40(fp)
 400ed40:	1885c83a 	sub	r2,r3,r2
 400ed44:	e0bffc15 	stw	r2,-16(fp)
          if (remainder_size >= (long)MINSIZE) /* split */
 400ed48:	e0bffc17 	ldw	r2,-16(fp)
 400ed4c:	10800410 	cmplti	r2,r2,16
 400ed50:	1000331e 	bne	r2,zero,400ee20 <_malloc_r+0x8d0>
            remainder = chunk_at_offset(victim, nb);
 400ed54:	e0ffff17 	ldw	r3,-4(fp)
 400ed58:	e0bff617 	ldw	r2,-40(fp)
 400ed5c:	1885883a 	add	r2,r3,r2
 400ed60:	e0bff315 	stw	r2,-52(fp)
            set_head(victim, nb | PREV_INUSE);
 400ed64:	e0bff617 	ldw	r2,-40(fp)
 400ed68:	10c00054 	ori	r3,r2,1
 400ed6c:	e0bfff17 	ldw	r2,-4(fp)
 400ed70:	10c00115 	stw	r3,4(r2)
            unlink(victim, bck, fwd);
 400ed74:	e0bfff17 	ldw	r2,-4(fp)
 400ed78:	10800317 	ldw	r2,12(r2)
 400ed7c:	e0bff815 	stw	r2,-32(fp)
 400ed80:	e0bfff17 	ldw	r2,-4(fp)
 400ed84:	10800217 	ldw	r2,8(r2)
 400ed88:	e0bff915 	stw	r2,-28(fp)
 400ed8c:	e0bff917 	ldw	r2,-28(fp)
 400ed90:	e0fff817 	ldw	r3,-32(fp)
 400ed94:	10c00315 	stw	r3,12(r2)
 400ed98:	e0bff817 	ldw	r2,-32(fp)
 400ed9c:	e0fff917 	ldw	r3,-28(fp)
 400eda0:	10c00215 	stw	r3,8(r2)
            link_last_remainder(remainder);
 400eda4:	008100b4 	movhi	r2,1026
 400eda8:	10ae3504 	addi	r2,r2,-18220
 400edac:	e0fff317 	ldw	r3,-52(fp)
 400edb0:	10c00315 	stw	r3,12(r2)
 400edb4:	00c100b4 	movhi	r3,1026
 400edb8:	18ee3504 	addi	r3,r3,-18220
 400edbc:	10800317 	ldw	r2,12(r2)
 400edc0:	18800215 	stw	r2,8(r3)
 400edc4:	008100b4 	movhi	r2,1026
 400edc8:	10ae3504 	addi	r2,r2,-18220
 400edcc:	e0fff317 	ldw	r3,-52(fp)
 400edd0:	18800315 	stw	r2,12(r3)
 400edd4:	e0bff317 	ldw	r2,-52(fp)
 400edd8:	10c00317 	ldw	r3,12(r2)
 400eddc:	e0bff317 	ldw	r2,-52(fp)
 400ede0:	10c00215 	stw	r3,8(r2)
            set_head(remainder, remainder_size | PREV_INUSE);
 400ede4:	e0bffc17 	ldw	r2,-16(fp)
 400ede8:	10800054 	ori	r2,r2,1
 400edec:	1007883a 	mov	r3,r2
 400edf0:	e0bff317 	ldw	r2,-52(fp)
 400edf4:	10c00115 	stw	r3,4(r2)
            set_foot(remainder, remainder_size);
 400edf8:	e0bffc17 	ldw	r2,-16(fp)
 400edfc:	e0fff317 	ldw	r3,-52(fp)
 400ee00:	1885883a 	add	r2,r3,r2
 400ee04:	e0fffc17 	ldw	r3,-16(fp)
 400ee08:	10c00015 	stw	r3,0(r2)
	    MALLOC_UNLOCK;
 400ee0c:	e13ff217 	ldw	r4,-56(fp)
 400ee10:	40187dc0 	call	40187dc <__malloc_unlock>
            return chunk2mem(victim);
 400ee14:	e0bfff17 	ldw	r2,-4(fp)
 400ee18:	10800204 	addi	r2,r2,8
 400ee1c:	0000a106 	br	400f0a4 <_malloc_r+0xb54>
          else if (remainder_size >= 0)  /* take */
 400ee20:	e0bffc17 	ldw	r2,-16(fp)
 400ee24:	10001a16 	blt	r2,zero,400ee90 <_malloc_r+0x940>
            set_inuse_bit_at_offset(victim, victim_size);
 400ee28:	e0ffff17 	ldw	r3,-4(fp)
 400ee2c:	e0bff517 	ldw	r2,-44(fp)
 400ee30:	1885883a 	add	r2,r3,r2
 400ee34:	10c00117 	ldw	r3,4(r2)
 400ee38:	e13fff17 	ldw	r4,-4(fp)
 400ee3c:	e0bff517 	ldw	r2,-44(fp)
 400ee40:	2085883a 	add	r2,r4,r2
 400ee44:	18c00054 	ori	r3,r3,1
 400ee48:	10c00115 	stw	r3,4(r2)
            unlink(victim, bck, fwd);
 400ee4c:	e0bfff17 	ldw	r2,-4(fp)
 400ee50:	10800317 	ldw	r2,12(r2)
 400ee54:	e0bff815 	stw	r2,-32(fp)
 400ee58:	e0bfff17 	ldw	r2,-4(fp)
 400ee5c:	10800217 	ldw	r2,8(r2)
 400ee60:	e0bff915 	stw	r2,-28(fp)
 400ee64:	e0bff917 	ldw	r2,-28(fp)
 400ee68:	e0fff817 	ldw	r3,-32(fp)
 400ee6c:	10c00315 	stw	r3,12(r2)
 400ee70:	e0bff817 	ldw	r2,-32(fp)
 400ee74:	e0fff917 	ldw	r3,-28(fp)
 400ee78:	10c00215 	stw	r3,8(r2)
	    MALLOC_UNLOCK;
 400ee7c:	e13ff217 	ldw	r4,-56(fp)
 400ee80:	40187dc0 	call	40187dc <__malloc_unlock>
            return chunk2mem(victim);
 400ee84:	e0bfff17 	ldw	r2,-4(fp)
 400ee88:	10800204 	addi	r2,r2,8
 400ee8c:	00008506 	br	400f0a4 <_malloc_r+0xb54>
        for (victim = last(bin); victim != bin; victim = victim->bk)
 400ee90:	e0bfff17 	ldw	r2,-4(fp)
 400ee94:	10800317 	ldw	r2,12(r2)
 400ee98:	e0bfff15 	stw	r2,-4(fp)
 400ee9c:	e0ffff17 	ldw	r3,-4(fp)
 400eea0:	e0bffd17 	ldw	r2,-12(fp)
 400eea4:	18bf9f1e 	bne	r3,r2,400ed24 <_malloc_r+0x7d4>
       bin = next_bin(bin);
 400eea8:	e0bffd17 	ldw	r2,-12(fp)
 400eeac:	10800204 	addi	r2,r2,8
 400eeb0:	e0bffd15 	stw	r2,-12(fp)
      } while ((++idx & (BINBLOCKWIDTH - 1)) != 0);
 400eeb4:	e0bffe17 	ldw	r2,-8(fp)
 400eeb8:	10800044 	addi	r2,r2,1
 400eebc:	e0bffe15 	stw	r2,-8(fp)
 400eec0:	e0bffe17 	ldw	r2,-8(fp)
 400eec4:	108000cc 	andi	r2,r2,3
 400eec8:	103f921e 	bne	r2,zero,400ed14 <_malloc_r+0x7c4>
        if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
 400eecc:	e0bffa17 	ldw	r2,-24(fp)
 400eed0:	108000cc 	andi	r2,r2,3
 400eed4:	10000a1e 	bne	r2,zero,400ef00 <_malloc_r+0x9b0>
          binblocks &= ~block;
 400eed8:	008100b4 	movhi	r2,1026
 400eedc:	10ae3304 	addi	r2,r2,-18228
 400eee0:	11000117 	ldw	r4,4(r2)
 400eee4:	e0bffb17 	ldw	r2,-20(fp)
 400eee8:	0086303a 	nor	r3,zero,r2
 400eeec:	008100b4 	movhi	r2,1026
 400eef0:	10ae3304 	addi	r2,r2,-18228
 400eef4:	20c6703a 	and	r3,r4,r3
 400eef8:	10c00115 	stw	r3,4(r2)
          break;
 400eefc:	00000a06 	br	400ef28 <_malloc_r+0x9d8>
        --startidx;
 400ef00:	e0bffa17 	ldw	r2,-24(fp)
 400ef04:	10bfffc4 	addi	r2,r2,-1
 400ef08:	e0bffa15 	stw	r2,-24(fp)
       q = prev_bin(q);
 400ef0c:	e0bff717 	ldw	r2,-36(fp)
 400ef10:	10bffe04 	addi	r2,r2,-8
 400ef14:	e0bff715 	stw	r2,-36(fp)
      } while (first(q) == q);
 400ef18:	e0bff717 	ldw	r2,-36(fp)
 400ef1c:	10800217 	ldw	r2,8(r2)
 400ef20:	e0fff717 	ldw	r3,-36(fp)
 400ef24:	18bfe926 	beq	r3,r2,400eecc <_malloc_r+0x97c>
      if ( (block <<= 1) <= binblocks && (block != 0) ) 
 400ef28:	e0bffb17 	ldw	r2,-20(fp)
 400ef2c:	1085883a 	add	r2,r2,r2
 400ef30:	e0bffb15 	stw	r2,-20(fp)
 400ef34:	008100b4 	movhi	r2,1026
 400ef38:	10ae3304 	addi	r2,r2,-18228
 400ef3c:	10c00117 	ldw	r3,4(r2)
 400ef40:	e0bffb17 	ldw	r2,-20(fp)
 400ef44:	18801036 	bltu	r3,r2,400ef88 <_malloc_r+0xa38>
 400ef48:	e0bffb17 	ldw	r2,-20(fp)
 400ef4c:	10000e26 	beq	r2,zero,400ef88 <_malloc_r+0xa38>
        while ((block & binblocks) == 0)
 400ef50:	00000606 	br	400ef6c <_malloc_r+0xa1c>
          idx += BINBLOCKWIDTH;
 400ef54:	e0bffe17 	ldw	r2,-8(fp)
 400ef58:	10800104 	addi	r2,r2,4
 400ef5c:	e0bffe15 	stw	r2,-8(fp)
          block <<= 1;
 400ef60:	e0bffb17 	ldw	r2,-20(fp)
 400ef64:	1085883a 	add	r2,r2,r2
 400ef68:	e0bffb15 	stw	r2,-20(fp)
        while ((block & binblocks) == 0)
 400ef6c:	008100b4 	movhi	r2,1026
 400ef70:	10ae3304 	addi	r2,r2,-18228
 400ef74:	10c00117 	ldw	r3,4(r2)
 400ef78:	e0bffb17 	ldw	r2,-20(fp)
 400ef7c:	1884703a 	and	r2,r3,r2
 400ef80:	103ff426 	beq	r2,zero,400ef54 <_malloc_r+0xa04>
      startidx = idx;          /* (track incomplete blocks) */
 400ef84:	003f5606 	br	400ece0 <_malloc_r+0x790>
  remainder_size = long_sub_size_t(chunksize(top), nb);
 400ef88:	008100b4 	movhi	r2,1026
 400ef8c:	10ae3304 	addi	r2,r2,-18228
 400ef90:	10800217 	ldw	r2,8(r2)
 400ef94:	10c00117 	ldw	r3,4(r2)
 400ef98:	00bfff04 	movi	r2,-4
 400ef9c:	1886703a 	and	r3,r3,r2
 400efa0:	e0bff617 	ldw	r2,-40(fp)
 400efa4:	1885c83a 	sub	r2,r3,r2
 400efa8:	e0bffc15 	stw	r2,-16(fp)
  if (chunksize(top) < nb || remainder_size < (long)MINSIZE)
 400efac:	008100b4 	movhi	r2,1026
 400efb0:	10ae3304 	addi	r2,r2,-18228
 400efb4:	10800217 	ldw	r2,8(r2)
 400efb8:	10c00117 	ldw	r3,4(r2)
 400efbc:	00bfff04 	movi	r2,-4
 400efc0:	1886703a 	and	r3,r3,r2
 400efc4:	e0bff617 	ldw	r2,-40(fp)
 400efc8:	18800336 	bltu	r3,r2,400efd8 <_malloc_r+0xa88>
 400efcc:	e0bffc17 	ldw	r2,-16(fp)
 400efd0:	10800408 	cmpgei	r2,r2,16
 400efd4:	10001b1e 	bne	r2,zero,400f044 <_malloc_r+0xaf4>
    malloc_extend_top(RCALL nb);
 400efd8:	e17ff617 	ldw	r5,-40(fp)
 400efdc:	e13ff217 	ldw	r4,-56(fp)
 400efe0:	400e18c0 	call	400e18c <malloc_extend_top>
    remainder_size = long_sub_size_t(chunksize(top), nb);
 400efe4:	008100b4 	movhi	r2,1026
 400efe8:	10ae3304 	addi	r2,r2,-18228
 400efec:	10800217 	ldw	r2,8(r2)
 400eff0:	10c00117 	ldw	r3,4(r2)
 400eff4:	00bfff04 	movi	r2,-4
 400eff8:	1886703a 	and	r3,r3,r2
 400effc:	e0bff617 	ldw	r2,-40(fp)
 400f000:	1885c83a 	sub	r2,r3,r2
 400f004:	e0bffc15 	stw	r2,-16(fp)
    if (chunksize(top) < nb || remainder_size < (long)MINSIZE)
 400f008:	008100b4 	movhi	r2,1026
 400f00c:	10ae3304 	addi	r2,r2,-18228
 400f010:	10800217 	ldw	r2,8(r2)
 400f014:	10c00117 	ldw	r3,4(r2)
 400f018:	00bfff04 	movi	r2,-4
 400f01c:	1886703a 	and	r3,r3,r2
 400f020:	e0bff617 	ldw	r2,-40(fp)
 400f024:	18800336 	bltu	r3,r2,400f034 <_malloc_r+0xae4>
 400f028:	e0bffc17 	ldw	r2,-16(fp)
 400f02c:	10800408 	cmpgei	r2,r2,16
 400f030:	1000041e 	bne	r2,zero,400f044 <_malloc_r+0xaf4>
      MALLOC_UNLOCK;
 400f034:	e13ff217 	ldw	r4,-56(fp)
 400f038:	40187dc0 	call	40187dc <__malloc_unlock>
      return 0; /* propagate failure */
 400f03c:	0005883a 	mov	r2,zero
 400f040:	00001806 	br	400f0a4 <_malloc_r+0xb54>
  victim = top;
 400f044:	008100b4 	movhi	r2,1026
 400f048:	10ae3304 	addi	r2,r2,-18228
 400f04c:	10800217 	ldw	r2,8(r2)
 400f050:	e0bfff15 	stw	r2,-4(fp)
  set_head(victim, nb | PREV_INUSE);
 400f054:	e0bff617 	ldw	r2,-40(fp)
 400f058:	10c00054 	ori	r3,r2,1
 400f05c:	e0bfff17 	ldw	r2,-4(fp)
 400f060:	10c00115 	stw	r3,4(r2)
  top = chunk_at_offset(victim, nb);
 400f064:	008100b4 	movhi	r2,1026
 400f068:	10ae3304 	addi	r2,r2,-18228
 400f06c:	e13fff17 	ldw	r4,-4(fp)
 400f070:	e0fff617 	ldw	r3,-40(fp)
 400f074:	20c7883a 	add	r3,r4,r3
 400f078:	10c00215 	stw	r3,8(r2)
  set_head(top, remainder_size | PREV_INUSE);
 400f07c:	e0bffc17 	ldw	r2,-16(fp)
 400f080:	10c00054 	ori	r3,r2,1
 400f084:	008100b4 	movhi	r2,1026
 400f088:	10ae3304 	addi	r2,r2,-18228
 400f08c:	10800217 	ldw	r2,8(r2)
 400f090:	10c00115 	stw	r3,4(r2)
  MALLOC_UNLOCK;
 400f094:	e13ff217 	ldw	r4,-56(fp)
 400f098:	40187dc0 	call	40187dc <__malloc_unlock>
  return chunk2mem(victim);
 400f09c:	e0bfff17 	ldw	r2,-4(fp)
 400f0a0:	10800204 	addi	r2,r2,8
}
 400f0a4:	e037883a 	mov	sp,fp
 400f0a8:	dfc00117 	ldw	ra,4(sp)
 400f0ac:	df000017 	ldw	fp,0(sp)
 400f0b0:	dec00204 	addi	sp,sp,8
 400f0b4:	f800283a 	ret

0400f0b8 <__get_global_locale>:

/* In POSIX terms the global locale is the process-wide locale.  Use this
   function to always refer to the global locale. */
_ELIDABLE_INLINE struct __locale_t *
__get_global_locale ()
{
 400f0b8:	deffff04 	addi	sp,sp,-4
 400f0bc:	df000015 	stw	fp,0(sp)
 400f0c0:	d839883a 	mov	fp,sp
  extern struct __locale_t __global_locale;
  return &__global_locale;
 400f0c4:	008100b4 	movhi	r2,1026
 400f0c8:	10add804 	addi	r2,r2,-18592
}
 400f0cc:	e037883a 	mov	sp,fp
 400f0d0:	df000017 	ldw	fp,0(sp)
 400f0d4:	dec00104 	addi	sp,sp,4
 400f0d8:	f800283a 	ret

0400f0dc <__get_current_locale>:
   using locale info without providing a locale as parameter (*_l functions).
   The current locale is either the locale of the current thread, if the
   thread called uselocale, or the global locale if not. */
_ELIDABLE_INLINE struct __locale_t *
__get_current_locale (void)
{
 400f0dc:	defffe04 	addi	sp,sp,-8
 400f0e0:	dfc00115 	stw	ra,4(sp)
 400f0e4:	df000015 	stw	fp,0(sp)
 400f0e8:	d839883a 	mov	fp,sp
#ifdef __HAVE_LOCALE_INFO__
  return _REENT->_locale ?: __get_global_locale ();
#else
  return __get_global_locale();
 400f0ec:	400f0b80 	call	400f0b8 <__get_global_locale>
#endif
}
 400f0f0:	e037883a 	mov	sp,fp
 400f0f4:	dfc00117 	ldw	ra,4(sp)
 400f0f8:	df000017 	ldw	fp,0(sp)
 400f0fc:	dec00204 	addi	sp,sp,8
 400f100:	f800283a 	ret

0400f104 <_mbtowc_r>:
_mbtowc_r (struct _reent *r,
        wchar_t       *__restrict pwc,
        const char    *__restrict s,
        size_t         n,
        mbstate_t      *state)
{
 400f104:	defff904 	addi	sp,sp,-28
 400f108:	dfc00615 	stw	ra,24(sp)
 400f10c:	df000515 	stw	fp,20(sp)
 400f110:	df000504 	addi	fp,sp,20
 400f114:	e13fff15 	stw	r4,-4(fp)
 400f118:	e17ffe15 	stw	r5,-8(fp)
 400f11c:	e1bffd15 	stw	r6,-12(fp)
 400f120:	e1fffc15 	stw	r7,-16(fp)
  return __MBTOWC (r, pwc, s, n, state);
 400f124:	400f0dc0 	call	400f0dc <__get_current_locale>
 400f128:	10803917 	ldw	r2,228(r2)
 400f12c:	e0c00217 	ldw	r3,8(fp)
 400f130:	d8c00015 	stw	r3,0(sp)
 400f134:	e1fffc17 	ldw	r7,-16(fp)
 400f138:	e1bffd17 	ldw	r6,-12(fp)
 400f13c:	e17ffe17 	ldw	r5,-8(fp)
 400f140:	e13fff17 	ldw	r4,-4(fp)
 400f144:	103ee83a 	callr	r2
}
 400f148:	e037883a 	mov	sp,fp
 400f14c:	dfc00117 	ldw	ra,4(sp)
 400f150:	df000017 	ldw	fp,0(sp)
 400f154:	dec00204 	addi	sp,sp,8
 400f158:	f800283a 	ret

0400f15c <__ascii_mbtowc>:
__ascii_mbtowc (struct _reent *r,
        wchar_t       *pwc,
        const char    *s,
        size_t         n,
        mbstate_t      *state)
{
 400f15c:	defff904 	addi	sp,sp,-28
 400f160:	df000615 	stw	fp,24(sp)
 400f164:	df000604 	addi	fp,sp,24
 400f168:	e13ffd15 	stw	r4,-12(fp)
 400f16c:	e17ffc15 	stw	r5,-16(fp)
 400f170:	e1bffb15 	stw	r6,-20(fp)
 400f174:	e1fffa15 	stw	r7,-24(fp)
  wchar_t dummy;
  unsigned char *t = (unsigned char *)s;
 400f178:	e0bffb17 	ldw	r2,-20(fp)
 400f17c:	e0bfff15 	stw	r2,-4(fp)

  if (pwc == NULL)
 400f180:	e0bffc17 	ldw	r2,-16(fp)
 400f184:	1000021e 	bne	r2,zero,400f190 <__ascii_mbtowc+0x34>
    pwc = &dummy;
 400f188:	e0bffe04 	addi	r2,fp,-8
 400f18c:	e0bffc15 	stw	r2,-16(fp)

  if (s == NULL)
 400f190:	e0bffb17 	ldw	r2,-20(fp)
 400f194:	1000021e 	bne	r2,zero,400f1a0 <__ascii_mbtowc+0x44>
    return 0;
 400f198:	0005883a 	mov	r2,zero
 400f19c:	00001006 	br	400f1e0 <__ascii_mbtowc+0x84>

  if (n == 0)
 400f1a0:	e0bffa17 	ldw	r2,-24(fp)
 400f1a4:	1000021e 	bne	r2,zero,400f1b0 <__ascii_mbtowc+0x54>
    return -2;
 400f1a8:	00bfff84 	movi	r2,-2
 400f1ac:	00000c06 	br	400f1e0 <__ascii_mbtowc+0x84>
      r->_errno = EILSEQ;
      return -1;
    }
#endif

  *pwc = (wchar_t)*t;
 400f1b0:	e0bfff17 	ldw	r2,-4(fp)
 400f1b4:	10800003 	ldbu	r2,0(r2)
 400f1b8:	10c03fcc 	andi	r3,r2,255
 400f1bc:	e0bffc17 	ldw	r2,-16(fp)
 400f1c0:	10c00015 	stw	r3,0(r2)
  
  if (*t == '\0')
 400f1c4:	e0bfff17 	ldw	r2,-4(fp)
 400f1c8:	10800003 	ldbu	r2,0(r2)
 400f1cc:	10803fcc 	andi	r2,r2,255
 400f1d0:	1000021e 	bne	r2,zero,400f1dc <__ascii_mbtowc+0x80>
    return 0;
 400f1d4:	0005883a 	mov	r2,zero
 400f1d8:	00000106 	br	400f1e0 <__ascii_mbtowc+0x84>

  return 1;
 400f1dc:	00800044 	movi	r2,1
}
 400f1e0:	e037883a 	mov	sp,fp
 400f1e4:	df000017 	ldw	fp,0(sp)
 400f1e8:	dec00104 	addi	sp,sp,4
 400f1ec:	f800283a 	ret

0400f1f0 <memchr>:

void *
memchr (const void *src_void,
	int c,
	size_t length)
{
 400f1f0:	defff704 	addi	sp,sp,-36
 400f1f4:	df000815 	stw	fp,32(sp)
 400f1f8:	df000804 	addi	fp,sp,32
 400f1fc:	e13ffa15 	stw	r4,-24(fp)
 400f200:	e17ff915 	stw	r5,-28(fp)
 400f204:	e1bff815 	stw	r6,-32(fp)
  const unsigned char *src = (const unsigned char *) src_void;
 400f208:	e0bffa17 	ldw	r2,-24(fp)
 400f20c:	e0bfff15 	stw	r2,-4(fp)
  unsigned char d = c;
 400f210:	e0bff917 	ldw	r2,-28(fp)
 400f214:	e0bffbc5 	stb	r2,-17(fp)
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *asrc;
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
 400f218:	00001006 	br	400f25c <memchr+0x6c>
    {
      if (!length--)
 400f21c:	e0bff817 	ldw	r2,-32(fp)
 400f220:	10ffffc4 	addi	r3,r2,-1
 400f224:	e0fff815 	stw	r3,-32(fp)
 400f228:	1000021e 	bne	r2,zero,400f234 <memchr+0x44>
        return NULL;
 400f22c:	0005883a 	mov	r2,zero
 400f230:	00005a06 	br	400f39c <memchr+0x1ac>
      if (*src == d)
 400f234:	e0bfff17 	ldw	r2,-4(fp)
 400f238:	10800003 	ldbu	r2,0(r2)
 400f23c:	e0fffbc3 	ldbu	r3,-17(fp)
 400f240:	10803fcc 	andi	r2,r2,255
 400f244:	1880021e 	bne	r3,r2,400f250 <memchr+0x60>
        return (void *) src;
 400f248:	e0bfff17 	ldw	r2,-4(fp)
 400f24c:	00005306 	br	400f39c <memchr+0x1ac>
      src++;
 400f250:	e0bfff17 	ldw	r2,-4(fp)
 400f254:	10800044 	addi	r2,r2,1
 400f258:	e0bfff15 	stw	r2,-4(fp)
  while (UNALIGNED (src))
 400f25c:	e0bfff17 	ldw	r2,-4(fp)
 400f260:	108000cc 	andi	r2,r2,3
 400f264:	103fed1e 	bne	r2,zero,400f21c <memchr+0x2c>
    }

  if (!TOO_SMALL (length))
 400f268:	e0bff817 	ldw	r2,-32(fp)
 400f26c:	10800130 	cmpltui	r2,r2,4
 400f270:	1000451e 	bne	r2,zero,400f388 <memchr+0x198>
         performs the bytewise search on word-sized segments if they
         contain the search character, which is detected by XORing
         the word-sized segment with a word-sized block of the search
         character and then detecting for the presence of NUL in the
         result.  */
      asrc = (unsigned long *) src;
 400f274:	e0bfff17 	ldw	r2,-4(fp)
 400f278:	e0bffe15 	stw	r2,-8(fp)
      mask = d << 8 | d;
 400f27c:	e0bffbc3 	ldbu	r2,-17(fp)
 400f280:	1006923a 	slli	r3,r2,8
 400f284:	e0bffbc3 	ldbu	r2,-17(fp)
 400f288:	1884b03a 	or	r2,r3,r2
 400f28c:	e0bffd15 	stw	r2,-12(fp)
      mask = mask << 16 | mask;
 400f290:	e0bffd17 	ldw	r2,-12(fp)
 400f294:	1004943a 	slli	r2,r2,16
 400f298:	e0fffd17 	ldw	r3,-12(fp)
 400f29c:	1884b03a 	or	r2,r3,r2
 400f2a0:	e0bffd15 	stw	r2,-12(fp)
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
 400f2a4:	00800804 	movi	r2,32
 400f2a8:	e0bffc15 	stw	r2,-16(fp)
 400f2ac:	00000906 	br	400f2d4 <memchr+0xe4>
        mask = (mask << i) | mask;
 400f2b0:	e0fffd17 	ldw	r3,-12(fp)
 400f2b4:	e0bffc17 	ldw	r2,-16(fp)
 400f2b8:	1884983a 	sll	r2,r3,r2
 400f2bc:	e0fffd17 	ldw	r3,-12(fp)
 400f2c0:	1884b03a 	or	r2,r3,r2
 400f2c4:	e0bffd15 	stw	r2,-12(fp)
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
 400f2c8:	e0bffc17 	ldw	r2,-16(fp)
 400f2cc:	1085883a 	add	r2,r2,r2
 400f2d0:	e0bffc15 	stw	r2,-16(fp)
 400f2d4:	e0bffc17 	ldw	r2,-16(fp)
 400f2d8:	10800830 	cmpltui	r2,r2,32
 400f2dc:	103ff41e 	bne	r2,zero,400f2b0 <memchr+0xc0>

      while (length >= LBLOCKSIZE)
 400f2e0:	00001706 	br	400f340 <memchr+0x150>
        {
          if (DETECTCHAR (*asrc, mask))
 400f2e4:	e0bffe17 	ldw	r2,-8(fp)
 400f2e8:	10c00017 	ldw	r3,0(r2)
 400f2ec:	e0bffd17 	ldw	r2,-12(fp)
 400f2f0:	1886f03a 	xor	r3,r3,r2
 400f2f4:	00bfbff4 	movhi	r2,65279
 400f2f8:	10bfbfc4 	addi	r2,r2,-257
 400f2fc:	1887883a 	add	r3,r3,r2
 400f300:	e0bffe17 	ldw	r2,-8(fp)
 400f304:	11000017 	ldw	r4,0(r2)
 400f308:	e0bffd17 	ldw	r2,-12(fp)
 400f30c:	2084f03a 	xor	r2,r4,r2
 400f310:	0084303a 	nor	r2,zero,r2
 400f314:	1886703a 	and	r3,r3,r2
 400f318:	00a02074 	movhi	r2,32897
 400f31c:	10a02004 	addi	r2,r2,-32640
 400f320:	1884703a 	and	r2,r3,r2
 400f324:	10000a1e 	bne	r2,zero,400f350 <memchr+0x160>
            break;
          length -= LBLOCKSIZE;
 400f328:	e0bff817 	ldw	r2,-32(fp)
 400f32c:	10bfff04 	addi	r2,r2,-4
 400f330:	e0bff815 	stw	r2,-32(fp)
          asrc++;
 400f334:	e0bffe17 	ldw	r2,-8(fp)
 400f338:	10800104 	addi	r2,r2,4
 400f33c:	e0bffe15 	stw	r2,-8(fp)
      while (length >= LBLOCKSIZE)
 400f340:	e0bff817 	ldw	r2,-32(fp)
 400f344:	10800128 	cmpgeui	r2,r2,4
 400f348:	103fe61e 	bne	r2,zero,400f2e4 <memchr+0xf4>
 400f34c:	00000106 	br	400f354 <memchr+0x164>
            break;
 400f350:	0001883a 	nop
        }

      /* If there are fewer than LBLOCKSIZE characters left,
         then we resort to the bytewise loop.  */

      src = (unsigned char *) asrc;
 400f354:	e0bffe17 	ldw	r2,-8(fp)
 400f358:	e0bfff15 	stw	r2,-4(fp)
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (length--)
 400f35c:	00000a06 	br	400f388 <memchr+0x198>
    {
      if (*src == d)
 400f360:	e0bfff17 	ldw	r2,-4(fp)
 400f364:	10800003 	ldbu	r2,0(r2)
 400f368:	e0fffbc3 	ldbu	r3,-17(fp)
 400f36c:	10803fcc 	andi	r2,r2,255
 400f370:	1880021e 	bne	r3,r2,400f37c <memchr+0x18c>
        return (void *) src;
 400f374:	e0bfff17 	ldw	r2,-4(fp)
 400f378:	00000806 	br	400f39c <memchr+0x1ac>
      src++;
 400f37c:	e0bfff17 	ldw	r2,-4(fp)
 400f380:	10800044 	addi	r2,r2,1
 400f384:	e0bfff15 	stw	r2,-4(fp)
  while (length--)
 400f388:	e0bff817 	ldw	r2,-32(fp)
 400f38c:	10ffffc4 	addi	r3,r2,-1
 400f390:	e0fff815 	stw	r3,-32(fp)
 400f394:	103ff21e 	bne	r2,zero,400f360 <memchr+0x170>
    }

  return NULL;
 400f398:	0005883a 	mov	r2,zero
}
 400f39c:	e037883a 	mov	sp,fp
 400f3a0:	df000017 	ldw	fp,0(sp)
 400f3a4:	dec00104 	addi	sp,sp,4
 400f3a8:	f800283a 	ret

0400f3ac <memmove>:
void *
__inhibit_loop_to_libcall
memmove (void *dst_void,
	const void *src_void,
	size_t length)
{
 400f3ac:	defff804 	addi	sp,sp,-32
 400f3b0:	df000715 	stw	fp,28(sp)
 400f3b4:	df000704 	addi	fp,sp,28
 400f3b8:	e13ffb15 	stw	r4,-20(fp)
 400f3bc:	e17ffa15 	stw	r5,-24(fp)
 400f3c0:	e1bff915 	stw	r6,-28(fp)
	}
    }

  return dst_void;
#else
  char *dst = dst_void;
 400f3c4:	e0bffb17 	ldw	r2,-20(fp)
 400f3c8:	e0bfff15 	stw	r2,-4(fp)
  const char *src = src_void;
 400f3cc:	e0bffa17 	ldw	r2,-24(fp)
 400f3d0:	e0bffe15 	stw	r2,-8(fp)
  long *aligned_dst;
  const long *aligned_src;

  if (src < dst && dst < src + length)
 400f3d4:	e0fffe17 	ldw	r3,-8(fp)
 400f3d8:	e0bfff17 	ldw	r2,-4(fp)
 400f3dc:	18801d2e 	bgeu	r3,r2,400f454 <memmove+0xa8>
 400f3e0:	e0fffe17 	ldw	r3,-8(fp)
 400f3e4:	e0bff917 	ldw	r2,-28(fp)
 400f3e8:	1885883a 	add	r2,r3,r2
 400f3ec:	e0ffff17 	ldw	r3,-4(fp)
 400f3f0:	1880182e 	bgeu	r3,r2,400f454 <memmove+0xa8>
    {
      /* Destructive overlap...have to copy backwards */
      src += length;
 400f3f4:	e0fffe17 	ldw	r3,-8(fp)
 400f3f8:	e0bff917 	ldw	r2,-28(fp)
 400f3fc:	1885883a 	add	r2,r3,r2
 400f400:	e0bffe15 	stw	r2,-8(fp)
      dst += length;
 400f404:	e0ffff17 	ldw	r3,-4(fp)
 400f408:	e0bff917 	ldw	r2,-28(fp)
 400f40c:	1885883a 	add	r2,r3,r2
 400f410:	e0bfff15 	stw	r2,-4(fp)
      while (length--)
 400f414:	00000a06 	br	400f440 <memmove+0x94>
	{
	  *--dst = *--src;
 400f418:	e0bffe17 	ldw	r2,-8(fp)
 400f41c:	10bfffc4 	addi	r2,r2,-1
 400f420:	e0bffe15 	stw	r2,-8(fp)
 400f424:	e0bfff17 	ldw	r2,-4(fp)
 400f428:	10bfffc4 	addi	r2,r2,-1
 400f42c:	e0bfff15 	stw	r2,-4(fp)
 400f430:	e0bffe17 	ldw	r2,-8(fp)
 400f434:	10c00003 	ldbu	r3,0(r2)
 400f438:	e0bfff17 	ldw	r2,-4(fp)
 400f43c:	10c00005 	stb	r3,0(r2)
      while (length--)
 400f440:	e0bff917 	ldw	r2,-28(fp)
 400f444:	10ffffc4 	addi	r3,r2,-1
 400f448:	e0fff915 	stw	r3,-28(fp)
 400f44c:	103ff21e 	bne	r2,zero,400f418 <memmove+0x6c>
  if (src < dst && dst < src + length)
 400f450:	00005306 	br	400f5a0 <memmove+0x1f4>
  else
    {
      /* Use optimizing algorithm for a non-destructive copy to closely 
         match memcpy. If the size is small or either SRC or DST is unaligned,
         then punt into the byte copy loop.  This should be rare.  */
      if (!TOO_SMALL(length) && !UNALIGNED (src, dst))
 400f454:	e0bff917 	ldw	r2,-28(fp)
 400f458:	10800430 	cmpltui	r2,r2,16
 400f45c:	10004c1e 	bne	r2,zero,400f590 <memmove+0x1e4>
 400f460:	e0fffe17 	ldw	r3,-8(fp)
 400f464:	e0bfff17 	ldw	r2,-4(fp)
 400f468:	1884b03a 	or	r2,r3,r2
 400f46c:	108000cc 	andi	r2,r2,3
 400f470:	1000471e 	bne	r2,zero,400f590 <memmove+0x1e4>
        {
          aligned_dst = (long*)dst;
 400f474:	e0bfff17 	ldw	r2,-4(fp)
 400f478:	e0bffd15 	stw	r2,-12(fp)
          aligned_src = (long*)src;
 400f47c:	e0bffe17 	ldw	r2,-8(fp)
 400f480:	e0bffc15 	stw	r2,-16(fp)

          /* Copy 4X long words at a time if possible.  */
          while (length >= BIGBLOCKSIZE)
 400f484:	00002306 	br	400f514 <memmove+0x168>
            {
              *aligned_dst++ = *aligned_src++;
 400f488:	e0fffc17 	ldw	r3,-16(fp)
 400f48c:	18800104 	addi	r2,r3,4
 400f490:	e0bffc15 	stw	r2,-16(fp)
 400f494:	e0bffd17 	ldw	r2,-12(fp)
 400f498:	11000104 	addi	r4,r2,4
 400f49c:	e13ffd15 	stw	r4,-12(fp)
 400f4a0:	18c00017 	ldw	r3,0(r3)
 400f4a4:	10c00015 	stw	r3,0(r2)
              *aligned_dst++ = *aligned_src++;
 400f4a8:	e0fffc17 	ldw	r3,-16(fp)
 400f4ac:	18800104 	addi	r2,r3,4
 400f4b0:	e0bffc15 	stw	r2,-16(fp)
 400f4b4:	e0bffd17 	ldw	r2,-12(fp)
 400f4b8:	11000104 	addi	r4,r2,4
 400f4bc:	e13ffd15 	stw	r4,-12(fp)
 400f4c0:	18c00017 	ldw	r3,0(r3)
 400f4c4:	10c00015 	stw	r3,0(r2)
              *aligned_dst++ = *aligned_src++;
 400f4c8:	e0fffc17 	ldw	r3,-16(fp)
 400f4cc:	18800104 	addi	r2,r3,4
 400f4d0:	e0bffc15 	stw	r2,-16(fp)
 400f4d4:	e0bffd17 	ldw	r2,-12(fp)
 400f4d8:	11000104 	addi	r4,r2,4
 400f4dc:	e13ffd15 	stw	r4,-12(fp)
 400f4e0:	18c00017 	ldw	r3,0(r3)
 400f4e4:	10c00015 	stw	r3,0(r2)
              *aligned_dst++ = *aligned_src++;
 400f4e8:	e0fffc17 	ldw	r3,-16(fp)
 400f4ec:	18800104 	addi	r2,r3,4
 400f4f0:	e0bffc15 	stw	r2,-16(fp)
 400f4f4:	e0bffd17 	ldw	r2,-12(fp)
 400f4f8:	11000104 	addi	r4,r2,4
 400f4fc:	e13ffd15 	stw	r4,-12(fp)
 400f500:	18c00017 	ldw	r3,0(r3)
 400f504:	10c00015 	stw	r3,0(r2)
              length -= BIGBLOCKSIZE;
 400f508:	e0bff917 	ldw	r2,-28(fp)
 400f50c:	10bffc04 	addi	r2,r2,-16
 400f510:	e0bff915 	stw	r2,-28(fp)
          while (length >= BIGBLOCKSIZE)
 400f514:	e0bff917 	ldw	r2,-28(fp)
 400f518:	10800428 	cmpgeui	r2,r2,16
 400f51c:	103fda1e 	bne	r2,zero,400f488 <memmove+0xdc>
            }

          /* Copy one long word at a time if possible.  */
          while (length >= LITTLEBLOCKSIZE)
 400f520:	00000b06 	br	400f550 <memmove+0x1a4>
            {
              *aligned_dst++ = *aligned_src++;
 400f524:	e0fffc17 	ldw	r3,-16(fp)
 400f528:	18800104 	addi	r2,r3,4
 400f52c:	e0bffc15 	stw	r2,-16(fp)
 400f530:	e0bffd17 	ldw	r2,-12(fp)
 400f534:	11000104 	addi	r4,r2,4
 400f538:	e13ffd15 	stw	r4,-12(fp)
 400f53c:	18c00017 	ldw	r3,0(r3)
 400f540:	10c00015 	stw	r3,0(r2)
              length -= LITTLEBLOCKSIZE;
 400f544:	e0bff917 	ldw	r2,-28(fp)
 400f548:	10bfff04 	addi	r2,r2,-4
 400f54c:	e0bff915 	stw	r2,-28(fp)
          while (length >= LITTLEBLOCKSIZE)
 400f550:	e0bff917 	ldw	r2,-28(fp)
 400f554:	10800128 	cmpgeui	r2,r2,4
 400f558:	103ff21e 	bne	r2,zero,400f524 <memmove+0x178>
            }

          /* Pick up any residual with a byte copier.  */
          dst = (char*)aligned_dst;
 400f55c:	e0bffd17 	ldw	r2,-12(fp)
 400f560:	e0bfff15 	stw	r2,-4(fp)
          src = (char*)aligned_src;
 400f564:	e0bffc17 	ldw	r2,-16(fp)
 400f568:	e0bffe15 	stw	r2,-8(fp)
        }

      while (length--)
 400f56c:	00000806 	br	400f590 <memmove+0x1e4>
        {
          *dst++ = *src++;
 400f570:	e0fffe17 	ldw	r3,-8(fp)
 400f574:	18800044 	addi	r2,r3,1
 400f578:	e0bffe15 	stw	r2,-8(fp)
 400f57c:	e0bfff17 	ldw	r2,-4(fp)
 400f580:	11000044 	addi	r4,r2,1
 400f584:	e13fff15 	stw	r4,-4(fp)
 400f588:	18c00003 	ldbu	r3,0(r3)
 400f58c:	10c00005 	stb	r3,0(r2)
      while (length--)
 400f590:	e0bff917 	ldw	r2,-28(fp)
 400f594:	10ffffc4 	addi	r3,r2,-1
 400f598:	e0fff915 	stw	r3,-28(fp)
 400f59c:	103ff41e 	bne	r2,zero,400f570 <memmove+0x1c4>
        }
    }

  return dst_void;
 400f5a0:	e0bffb17 	ldw	r2,-20(fp)
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 400f5a4:	e037883a 	mov	sp,fp
 400f5a8:	df000017 	ldw	fp,0(sp)
 400f5ac:	dec00104 	addi	sp,sp,4
 400f5b0:	f800283a 	ret

0400f5b4 <_Balloc>:
#define _Kmax 15
*/

_Bigint *
Balloc (struct _reent *ptr, int k)
{
 400f5b4:	defffa04 	addi	sp,sp,-24
 400f5b8:	dfc00515 	stw	ra,20(sp)
 400f5bc:	df000415 	stw	fp,16(sp)
 400f5c0:	df000404 	addi	fp,sp,16
 400f5c4:	e13ffd15 	stw	r4,-12(fp)
 400f5c8:	e17ffc15 	stw	r5,-16(fp)
  int x;
  _Bigint *rv ;

  _REENT_CHECK_MP(ptr);
  if (_REENT_MP_FREELIST(ptr) == NULL)
 400f5cc:	e0bffd17 	ldw	r2,-12(fp)
 400f5d0:	10801317 	ldw	r2,76(r2)
 400f5d4:	10000c1e 	bne	r2,zero,400f608 <_Balloc+0x54>
    {
      /* Allocate a list of pointers to the mprec objects */
      _REENT_MP_FREELIST(ptr) = (struct _Bigint **) _calloc_r (ptr, 
 400f5d8:	01800844 	movi	r6,33
 400f5dc:	01400104 	movi	r5,4
 400f5e0:	e13ffd17 	ldw	r4,-12(fp)
 400f5e4:	40138fc0 	call	40138fc <_calloc_r>
 400f5e8:	1007883a 	mov	r3,r2
 400f5ec:	e0bffd17 	ldw	r2,-12(fp)
 400f5f0:	10c01315 	stw	r3,76(r2)
						      sizeof (struct _Bigint *),
						      _Kmax + 1);
      if (_REENT_MP_FREELIST(ptr) == NULL)
 400f5f4:	e0bffd17 	ldw	r2,-12(fp)
 400f5f8:	10801317 	ldw	r2,76(r2)
 400f5fc:	1000021e 	bne	r2,zero,400f608 <_Balloc+0x54>
	{
	  return NULL;
 400f600:	0005883a 	mov	r2,zero
 400f604:	00002f06 	br	400f6c4 <_Balloc+0x110>
	}
    }

  if ((rv = _REENT_MP_FREELIST(ptr)[k]) != 0)
 400f608:	e0bffd17 	ldw	r2,-12(fp)
 400f60c:	10c01317 	ldw	r3,76(r2)
 400f610:	e0bffc17 	ldw	r2,-16(fp)
 400f614:	100490ba 	slli	r2,r2,2
 400f618:	1885883a 	add	r2,r3,r2
 400f61c:	10800017 	ldw	r2,0(r2)
 400f620:	e0bfff15 	stw	r2,-4(fp)
 400f624:	e0bfff17 	ldw	r2,-4(fp)
 400f628:	10000926 	beq	r2,zero,400f650 <_Balloc+0x9c>
    {
      _REENT_MP_FREELIST(ptr)[k] = rv->_next;
 400f62c:	e0bffd17 	ldw	r2,-12(fp)
 400f630:	10c01317 	ldw	r3,76(r2)
 400f634:	e0bffc17 	ldw	r2,-16(fp)
 400f638:	100490ba 	slli	r2,r2,2
 400f63c:	1885883a 	add	r2,r3,r2
 400f640:	e0ffff17 	ldw	r3,-4(fp)
 400f644:	18c00017 	ldw	r3,0(r3)
 400f648:	10c00015 	stw	r3,0(r2)
 400f64c:	00001606 	br	400f6a8 <_Balloc+0xf4>
    }
  else
    {
      x = 1 << k;
 400f650:	00c00044 	movi	r3,1
 400f654:	e0bffc17 	ldw	r2,-16(fp)
 400f658:	1884983a 	sll	r2,r3,r2
 400f65c:	e0bffe15 	stw	r2,-8(fp)
      /* Allocate an mprec Bigint and stick in in the freelist */
      rv = (_Bigint *) _calloc_r (ptr,
				  1,
				  sizeof (_Bigint) +
 400f660:	e0bffe17 	ldw	r2,-8(fp)
 400f664:	10800144 	addi	r2,r2,5
      rv = (_Bigint *) _calloc_r (ptr,
 400f668:	100490ba 	slli	r2,r2,2
 400f66c:	100d883a 	mov	r6,r2
 400f670:	01400044 	movi	r5,1
 400f674:	e13ffd17 	ldw	r4,-12(fp)
 400f678:	40138fc0 	call	40138fc <_calloc_r>
 400f67c:	e0bfff15 	stw	r2,-4(fp)
				  (x-1) * sizeof(rv->_x));
      if (rv == NULL) return NULL;
 400f680:	e0bfff17 	ldw	r2,-4(fp)
 400f684:	1000021e 	bne	r2,zero,400f690 <_Balloc+0xdc>
 400f688:	0005883a 	mov	r2,zero
 400f68c:	00000d06 	br	400f6c4 <_Balloc+0x110>
      rv->_k = k;
 400f690:	e0bfff17 	ldw	r2,-4(fp)
 400f694:	e0fffc17 	ldw	r3,-16(fp)
 400f698:	10c00115 	stw	r3,4(r2)
      rv->_maxwds = x;
 400f69c:	e0bfff17 	ldw	r2,-4(fp)
 400f6a0:	e0fffe17 	ldw	r3,-8(fp)
 400f6a4:	10c00215 	stw	r3,8(r2)
    }
  rv->_sign = rv->_wds = 0;
 400f6a8:	e0bfff17 	ldw	r2,-4(fp)
 400f6ac:	10000415 	stw	zero,16(r2)
 400f6b0:	e0bfff17 	ldw	r2,-4(fp)
 400f6b4:	10c00417 	ldw	r3,16(r2)
 400f6b8:	e0bfff17 	ldw	r2,-4(fp)
 400f6bc:	10c00315 	stw	r3,12(r2)
  return rv;
 400f6c0:	e0bfff17 	ldw	r2,-4(fp)
}
 400f6c4:	e037883a 	mov	sp,fp
 400f6c8:	dfc00117 	ldw	ra,4(sp)
 400f6cc:	df000017 	ldw	fp,0(sp)
 400f6d0:	dec00204 	addi	sp,sp,8
 400f6d4:	f800283a 	ret

0400f6d8 <_Bfree>:

void
Bfree (struct _reent *ptr, _Bigint * v)
{
 400f6d8:	defffd04 	addi	sp,sp,-12
 400f6dc:	df000215 	stw	fp,8(sp)
 400f6e0:	df000204 	addi	fp,sp,8
 400f6e4:	e13fff15 	stw	r4,-4(fp)
 400f6e8:	e17ffe15 	stw	r5,-8(fp)
  _REENT_CHECK_MP(ptr);
  if (v)
 400f6ec:	e0bffe17 	ldw	r2,-8(fp)
 400f6f0:	10001126 	beq	r2,zero,400f738 <_Bfree+0x60>
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
 400f6f4:	e0bfff17 	ldw	r2,-4(fp)
 400f6f8:	10c01317 	ldw	r3,76(r2)
 400f6fc:	e0bffe17 	ldw	r2,-8(fp)
 400f700:	10800117 	ldw	r2,4(r2)
 400f704:	100490ba 	slli	r2,r2,2
 400f708:	1885883a 	add	r2,r3,r2
 400f70c:	10c00017 	ldw	r3,0(r2)
 400f710:	e0bffe17 	ldw	r2,-8(fp)
 400f714:	10c00015 	stw	r3,0(r2)
      _REENT_MP_FREELIST(ptr)[v->_k] = v;
 400f718:	e0bfff17 	ldw	r2,-4(fp)
 400f71c:	10c01317 	ldw	r3,76(r2)
 400f720:	e0bffe17 	ldw	r2,-8(fp)
 400f724:	10800117 	ldw	r2,4(r2)
 400f728:	100490ba 	slli	r2,r2,2
 400f72c:	1885883a 	add	r2,r3,r2
 400f730:	e0fffe17 	ldw	r3,-8(fp)
 400f734:	10c00015 	stw	r3,0(r2)
    }
}
 400f738:	0001883a 	nop
 400f73c:	e037883a 	mov	sp,fp
 400f740:	df000017 	ldw	fp,0(sp)
 400f744:	dec00104 	addi	sp,sp,4
 400f748:	f800283a 	ret

0400f74c <__multadd>:
_Bigint *
multadd (struct _reent *ptr,
	_Bigint * b,
	int m,
	int a)
{
 400f74c:	defff204 	addi	sp,sp,-56
 400f750:	dfc00d15 	stw	ra,52(sp)
 400f754:	df000c15 	stw	fp,48(sp)
 400f758:	df000c04 	addi	fp,sp,48
 400f75c:	e13ff715 	stw	r4,-36(fp)
 400f760:	e17ff615 	stw	r5,-40(fp)
 400f764:	e1bff515 	stw	r6,-44(fp)
 400f768:	e1fff415 	stw	r7,-48(fp)
#ifdef Pack_32
  __ULong xi, z;
#endif
  _Bigint *b1;

  wds = b->_wds;
 400f76c:	e0bff617 	ldw	r2,-40(fp)
 400f770:	10800417 	ldw	r2,16(r2)
 400f774:	e0bffd15 	stw	r2,-12(fp)
  x = b->_x;
 400f778:	e0bff617 	ldw	r2,-40(fp)
 400f77c:	10800504 	addi	r2,r2,20
 400f780:	e0bffe15 	stw	r2,-8(fp)
  i = 0;
 400f784:	e03fff15 	stw	zero,-4(fp)
  do
    {
#ifdef Pack_32
      xi = *x;
 400f788:	e0bffe17 	ldw	r2,-8(fp)
 400f78c:	10800017 	ldw	r2,0(r2)
 400f790:	e0bffc15 	stw	r2,-16(fp)
      y = (xi & 0xffff) * m + a;
 400f794:	e0bffc17 	ldw	r2,-16(fp)
 400f798:	10bfffcc 	andi	r2,r2,65535
 400f79c:	e0fff517 	ldw	r3,-44(fp)
 400f7a0:	180b883a 	mov	r5,r3
 400f7a4:	1009883a 	mov	r4,r2
 400f7a8:	40075a40 	call	40075a4 <__mulsi3>
 400f7ac:	1007883a 	mov	r3,r2
 400f7b0:	e0bff417 	ldw	r2,-48(fp)
 400f7b4:	1885883a 	add	r2,r3,r2
 400f7b8:	e0bffb15 	stw	r2,-20(fp)
      z = (xi >> 16) * m + (y >> 16);
 400f7bc:	e0bffc17 	ldw	r2,-16(fp)
 400f7c0:	1004d43a 	srli	r2,r2,16
 400f7c4:	e0fff517 	ldw	r3,-44(fp)
 400f7c8:	180b883a 	mov	r5,r3
 400f7cc:	1009883a 	mov	r4,r2
 400f7d0:	40075a40 	call	40075a4 <__mulsi3>
 400f7d4:	1007883a 	mov	r3,r2
 400f7d8:	e0bffb17 	ldw	r2,-20(fp)
 400f7dc:	1004d43a 	srli	r2,r2,16
 400f7e0:	1885883a 	add	r2,r3,r2
 400f7e4:	e0bffa15 	stw	r2,-24(fp)
      a = (int) (z >> 16);
 400f7e8:	e0bffa17 	ldw	r2,-24(fp)
 400f7ec:	1004d43a 	srli	r2,r2,16
 400f7f0:	e0bff415 	stw	r2,-48(fp)
      *x++ = (z << 16) + (y & 0xffff);
 400f7f4:	e0bffa17 	ldw	r2,-24(fp)
 400f7f8:	1008943a 	slli	r4,r2,16
 400f7fc:	e0bffb17 	ldw	r2,-20(fp)
 400f800:	10ffffcc 	andi	r3,r2,65535
 400f804:	e0bffe17 	ldw	r2,-8(fp)
 400f808:	11400104 	addi	r5,r2,4
 400f80c:	e17ffe15 	stw	r5,-8(fp)
 400f810:	20c7883a 	add	r3,r4,r3
 400f814:	10c00015 	stw	r3,0(r2)
      y = *x * m + a;
      a = (int) (y >> 16);
      *x++ = y & 0xffff;
#endif
    }
  while (++i < wds);
 400f818:	e0bfff17 	ldw	r2,-4(fp)
 400f81c:	10800044 	addi	r2,r2,1
 400f820:	e0bfff15 	stw	r2,-4(fp)
 400f824:	e0ffff17 	ldw	r3,-4(fp)
 400f828:	e0bffd17 	ldw	r2,-12(fp)
 400f82c:	18bfd616 	blt	r3,r2,400f788 <__multadd+0x3c>
  if (a)
 400f830:	e0bff417 	ldw	r2,-48(fp)
 400f834:	10003326 	beq	r2,zero,400f904 <__multadd+0x1b8>
    {
      if (wds >= b->_maxwds)
 400f838:	e0bff617 	ldw	r2,-40(fp)
 400f83c:	10800217 	ldw	r2,8(r2)
 400f840:	e0fffd17 	ldw	r3,-12(fp)
 400f844:	18802316 	blt	r3,r2,400f8d4 <__multadd+0x188>
	{
	  b1 = eBalloc (ptr, b->_k + 1);
 400f848:	e0bff617 	ldw	r2,-40(fp)
 400f84c:	10800117 	ldw	r2,4(r2)
 400f850:	10800044 	addi	r2,r2,1
 400f854:	100b883a 	mov	r5,r2
 400f858:	e13ff717 	ldw	r4,-36(fp)
 400f85c:	400f5b40 	call	400f5b4 <_Balloc>
 400f860:	e0bff915 	stw	r2,-28(fp)
 400f864:	e0bff917 	ldw	r2,-28(fp)
 400f868:	1000071e 	bne	r2,zero,400f888 <__multadd+0x13c>
 400f86c:	01c100b4 	movhi	r7,1026
 400f870:	39eb4a04 	addi	r7,r7,-21208
 400f874:	000d883a 	mov	r6,zero
 400f878:	01402d44 	movi	r5,181
 400f87c:	010100b4 	movhi	r4,1026
 400f880:	212b4f04 	addi	r4,r4,-21188
 400f884:	40138480 	call	4013848 <__assert_func>
 400f888:	e0bff917 	ldw	r2,-28(fp)
 400f88c:	e0bff815 	stw	r2,-32(fp)
	  Bcopy (b1, b);
 400f890:	e0bff817 	ldw	r2,-32(fp)
 400f894:	10c00304 	addi	r3,r2,12
 400f898:	e0bff617 	ldw	r2,-40(fp)
 400f89c:	11000304 	addi	r4,r2,12
 400f8a0:	e0bff617 	ldw	r2,-40(fp)
 400f8a4:	10800417 	ldw	r2,16(r2)
 400f8a8:	10800084 	addi	r2,r2,2
 400f8ac:	100490ba 	slli	r2,r2,2
 400f8b0:	100d883a 	mov	r6,r2
 400f8b4:	200b883a 	mov	r5,r4
 400f8b8:	1809883a 	mov	r4,r3
 400f8bc:	40075cc0 	call	40075cc <memcpy>
	  Bfree (ptr, b);
 400f8c0:	e17ff617 	ldw	r5,-40(fp)
 400f8c4:	e13ff717 	ldw	r4,-36(fp)
 400f8c8:	400f6d80 	call	400f6d8 <_Bfree>
	  b = b1;
 400f8cc:	e0bff817 	ldw	r2,-32(fp)
 400f8d0:	e0bff615 	stw	r2,-40(fp)
	}
      b->_x[wds++] = a;
 400f8d4:	e0bffd17 	ldw	r2,-12(fp)
 400f8d8:	10c00044 	addi	r3,r2,1
 400f8dc:	e0fffd15 	stw	r3,-12(fp)
 400f8e0:	e0fff417 	ldw	r3,-48(fp)
 400f8e4:	e13ff617 	ldw	r4,-40(fp)
 400f8e8:	10800144 	addi	r2,r2,5
 400f8ec:	100490ba 	slli	r2,r2,2
 400f8f0:	2085883a 	add	r2,r4,r2
 400f8f4:	10c00015 	stw	r3,0(r2)
      b->_wds = wds;
 400f8f8:	e0bff617 	ldw	r2,-40(fp)
 400f8fc:	e0fffd17 	ldw	r3,-12(fp)
 400f900:	10c00415 	stw	r3,16(r2)
    }
  return b;
 400f904:	e0bff617 	ldw	r2,-40(fp)
}
 400f908:	e037883a 	mov	sp,fp
 400f90c:	dfc00117 	ldw	ra,4(sp)
 400f910:	df000017 	ldw	fp,0(sp)
 400f914:	dec00204 	addi	sp,sp,8
 400f918:	f800283a 	ret

0400f91c <__s2b>:
s2b (struct _reent * ptr,
	const char *s,
	int nd0,
	int nd,
	__ULong y9)
{
 400f91c:	defff404 	addi	sp,sp,-48
 400f920:	dfc00b15 	stw	ra,44(sp)
 400f924:	df000a15 	stw	fp,40(sp)
 400f928:	df000a04 	addi	fp,sp,40
 400f92c:	e13ff915 	stw	r4,-28(fp)
 400f930:	e17ff815 	stw	r5,-32(fp)
 400f934:	e1bff715 	stw	r6,-36(fp)
 400f938:	e1fff615 	stw	r7,-40(fp)
  _Bigint *b;
  int i, k;
  __Long x, y;

  x = (nd + 8) / 9;
 400f93c:	e0bff617 	ldw	r2,-40(fp)
 400f940:	10800204 	addi	r2,r2,8
 400f944:	01400244 	movi	r5,9
 400f948:	1009883a 	mov	r4,r2
 400f94c:	40073f00 	call	40073f0 <__divsi3>
 400f950:	e0bffb15 	stw	r2,-20(fp)
  for (k = 0, y = 1; x > y; y <<= 1, k++);
 400f954:	e03ffd15 	stw	zero,-12(fp)
 400f958:	00800044 	movi	r2,1
 400f95c:	e0bffc15 	stw	r2,-16(fp)
 400f960:	00000606 	br	400f97c <__s2b+0x60>
 400f964:	e0bffc17 	ldw	r2,-16(fp)
 400f968:	1085883a 	add	r2,r2,r2
 400f96c:	e0bffc15 	stw	r2,-16(fp)
 400f970:	e0bffd17 	ldw	r2,-12(fp)
 400f974:	10800044 	addi	r2,r2,1
 400f978:	e0bffd15 	stw	r2,-12(fp)
 400f97c:	e0bffb17 	ldw	r2,-20(fp)
 400f980:	e0fffc17 	ldw	r3,-16(fp)
 400f984:	18bff716 	blt	r3,r2,400f964 <__s2b+0x48>
#ifdef Pack_32
  b = eBalloc (ptr, k);
 400f988:	e17ffd17 	ldw	r5,-12(fp)
 400f98c:	e13ff917 	ldw	r4,-28(fp)
 400f990:	400f5b40 	call	400f5b4 <_Balloc>
 400f994:	e0bffa15 	stw	r2,-24(fp)
 400f998:	e0bffa17 	ldw	r2,-24(fp)
 400f99c:	1000071e 	bne	r2,zero,400f9bc <__s2b+0xa0>
 400f9a0:	01c100b4 	movhi	r7,1026
 400f9a4:	39eb4a04 	addi	r7,r7,-21208
 400f9a8:	000d883a 	mov	r6,zero
 400f9ac:	01403384 	movi	r5,206
 400f9b0:	010100b4 	movhi	r4,1026
 400f9b4:	212b4f04 	addi	r4,r4,-21188
 400f9b8:	40138480 	call	4013848 <__assert_func>
 400f9bc:	e0bffa17 	ldw	r2,-24(fp)
 400f9c0:	e0bfff15 	stw	r2,-4(fp)
  b->_x[0] = y9;
 400f9c4:	e0bfff17 	ldw	r2,-4(fp)
 400f9c8:	e0c00217 	ldw	r3,8(fp)
 400f9cc:	10c00515 	stw	r3,20(r2)
  b->_wds = 1;
 400f9d0:	e0bfff17 	ldw	r2,-4(fp)
 400f9d4:	00c00044 	movi	r3,1
 400f9d8:	10c00415 	stw	r3,16(r2)
  b = eBalloc (ptr, k + 1);
  b->_x[0] = y9 & 0xffff;
  b->_wds = (b->_x[1] = y9 >> 16) ? 2 : 1;
#endif

  i = 9;
 400f9dc:	00800244 	movi	r2,9
 400f9e0:	e0bffe15 	stw	r2,-8(fp)
  if (9 < nd0)
 400f9e4:	e0bff717 	ldw	r2,-36(fp)
 400f9e8:	10800290 	cmplti	r2,r2,10
 400f9ec:	10001b1e 	bne	r2,zero,400fa5c <__s2b+0x140>
    {
      s += 9;
 400f9f0:	e0bff817 	ldw	r2,-32(fp)
 400f9f4:	10800244 	addi	r2,r2,9
 400f9f8:	e0bff815 	stw	r2,-32(fp)
      do
	b = multadd (ptr, b, 10, *s++ - '0');
 400f9fc:	e0bff817 	ldw	r2,-32(fp)
 400fa00:	10c00044 	addi	r3,r2,1
 400fa04:	e0fff815 	stw	r3,-32(fp)
 400fa08:	10800003 	ldbu	r2,0(r2)
 400fa0c:	10803fcc 	andi	r2,r2,255
 400fa10:	1080201c 	xori	r2,r2,128
 400fa14:	10bfe004 	addi	r2,r2,-128
 400fa18:	10bff404 	addi	r2,r2,-48
 400fa1c:	100f883a 	mov	r7,r2
 400fa20:	01800284 	movi	r6,10
 400fa24:	e17fff17 	ldw	r5,-4(fp)
 400fa28:	e13ff917 	ldw	r4,-28(fp)
 400fa2c:	400f74c0 	call	400f74c <__multadd>
 400fa30:	e0bfff15 	stw	r2,-4(fp)
      while (++i < nd0);
 400fa34:	e0bffe17 	ldw	r2,-8(fp)
 400fa38:	10800044 	addi	r2,r2,1
 400fa3c:	e0bffe15 	stw	r2,-8(fp)
 400fa40:	e0fffe17 	ldw	r3,-8(fp)
 400fa44:	e0bff717 	ldw	r2,-36(fp)
 400fa48:	18bfec16 	blt	r3,r2,400f9fc <__s2b+0xe0>
      s++;
 400fa4c:	e0bff817 	ldw	r2,-32(fp)
 400fa50:	10800044 	addi	r2,r2,1
 400fa54:	e0bff815 	stw	r2,-32(fp)
 400fa58:	00001506 	br	400fab0 <__s2b+0x194>
    }
  else
    s += 10;
 400fa5c:	e0bff817 	ldw	r2,-32(fp)
 400fa60:	10800284 	addi	r2,r2,10
 400fa64:	e0bff815 	stw	r2,-32(fp)
  for (; i < nd; i++)
 400fa68:	00001106 	br	400fab0 <__s2b+0x194>
    b = multadd (ptr, b, 10, *s++ - '0');
 400fa6c:	e0bff817 	ldw	r2,-32(fp)
 400fa70:	10c00044 	addi	r3,r2,1
 400fa74:	e0fff815 	stw	r3,-32(fp)
 400fa78:	10800003 	ldbu	r2,0(r2)
 400fa7c:	10803fcc 	andi	r2,r2,255
 400fa80:	1080201c 	xori	r2,r2,128
 400fa84:	10bfe004 	addi	r2,r2,-128
 400fa88:	10bff404 	addi	r2,r2,-48
 400fa8c:	100f883a 	mov	r7,r2
 400fa90:	01800284 	movi	r6,10
 400fa94:	e17fff17 	ldw	r5,-4(fp)
 400fa98:	e13ff917 	ldw	r4,-28(fp)
 400fa9c:	400f74c0 	call	400f74c <__multadd>
 400faa0:	e0bfff15 	stw	r2,-4(fp)
  for (; i < nd; i++)
 400faa4:	e0bffe17 	ldw	r2,-8(fp)
 400faa8:	10800044 	addi	r2,r2,1
 400faac:	e0bffe15 	stw	r2,-8(fp)
 400fab0:	e0fffe17 	ldw	r3,-8(fp)
 400fab4:	e0bff617 	ldw	r2,-40(fp)
 400fab8:	18bfec16 	blt	r3,r2,400fa6c <__s2b+0x150>
  return b;
 400fabc:	e0bfff17 	ldw	r2,-4(fp)
}
 400fac0:	e037883a 	mov	sp,fp
 400fac4:	dfc00117 	ldw	ra,4(sp)
 400fac8:	df000017 	ldw	fp,0(sp)
 400facc:	dec00204 	addi	sp,sp,8
 400fad0:	f800283a 	ret

0400fad4 <__hi0bits>:

int
hi0bits (register __ULong x)
{
 400fad4:	defffe04 	addi	sp,sp,-8
 400fad8:	df000115 	stw	fp,4(sp)
 400fadc:	dc000015 	stw	r16,0(sp)
 400fae0:	df000104 	addi	fp,sp,4
 400fae4:	2005883a 	mov	r2,r4
  register int k = 0;
 400fae8:	0021883a 	mov	r16,zero

  if (!(x & 0xffff0000))
 400faec:	10ffffec 	andhi	r3,r2,65535
 400faf0:	1800021e 	bne	r3,zero,400fafc <__hi0bits+0x28>
    {
      k = 16;
 400faf4:	04000404 	movi	r16,16
      x <<= 16;
 400faf8:	1004943a 	slli	r2,r2,16
    }
  if (!(x & 0xff000000))
 400fafc:	10ffc02c 	andhi	r3,r2,65280
 400fb00:	1800021e 	bne	r3,zero,400fb0c <__hi0bits+0x38>
    {
      k += 8;
 400fb04:	84000204 	addi	r16,r16,8
      x <<= 8;
 400fb08:	1004923a 	slli	r2,r2,8
    }
  if (!(x & 0xf0000000))
 400fb0c:	10fc002c 	andhi	r3,r2,61440
 400fb10:	1800021e 	bne	r3,zero,400fb1c <__hi0bits+0x48>
    {
      k += 4;
 400fb14:	84000104 	addi	r16,r16,4
      x <<= 4;
 400fb18:	1004913a 	slli	r2,r2,4
    }
  if (!(x & 0xc0000000))
 400fb1c:	10f0002c 	andhi	r3,r2,49152
 400fb20:	1800021e 	bne	r3,zero,400fb2c <__hi0bits+0x58>
    {
      k += 2;
 400fb24:	84000084 	addi	r16,r16,2
      x <<= 2;
 400fb28:	100490ba 	slli	r2,r2,2
    }
  if (!(x & 0x80000000))
 400fb2c:	1007883a 	mov	r3,r2
 400fb30:	18000516 	blt	r3,zero,400fb48 <__hi0bits+0x74>
    {
      k++;
 400fb34:	84000044 	addi	r16,r16,1
      if (!(x & 0x40000000))
 400fb38:	1090002c 	andhi	r2,r2,16384
 400fb3c:	1000021e 	bne	r2,zero,400fb48 <__hi0bits+0x74>
	return 32;
 400fb40:	00800804 	movi	r2,32
 400fb44:	00000106 	br	400fb4c <__hi0bits+0x78>
    }
  return k;
 400fb48:	8005883a 	mov	r2,r16
}
 400fb4c:	e6ffff04 	addi	sp,fp,-4
 400fb50:	df000117 	ldw	fp,4(sp)
 400fb54:	dc000017 	ldw	r16,0(sp)
 400fb58:	dec00204 	addi	sp,sp,8
 400fb5c:	f800283a 	ret

0400fb60 <__lo0bits>:

int
lo0bits (__ULong *y)
{
 400fb60:	defffc04 	addi	sp,sp,-16
 400fb64:	df000315 	stw	fp,12(sp)
 400fb68:	dc400215 	stw	r17,8(sp)
 400fb6c:	dc000115 	stw	r16,4(sp)
 400fb70:	df000304 	addi	fp,sp,12
 400fb74:	e13ffd15 	stw	r4,-12(fp)
  register int k;
  register __ULong x = *y;
 400fb78:	e0bffd17 	ldw	r2,-12(fp)
 400fb7c:	14000017 	ldw	r16,0(r2)

  if (x & 7)
 400fb80:	808001cc 	andi	r2,r16,7
 400fb84:	10001026 	beq	r2,zero,400fbc8 <__lo0bits+0x68>
    {
      if (x & 1)
 400fb88:	8080004c 	andi	r2,r16,1
 400fb8c:	10000226 	beq	r2,zero,400fb98 <__lo0bits+0x38>
	return 0;
 400fb90:	0005883a 	mov	r2,zero
 400fb94:	00002706 	br	400fc34 <__lo0bits+0xd4>
      if (x & 2)
 400fb98:	8080008c 	andi	r2,r16,2
 400fb9c:	10000526 	beq	r2,zero,400fbb4 <__lo0bits+0x54>
	{
	  *y = x >> 1;
 400fba0:	8006d07a 	srli	r3,r16,1
 400fba4:	e0bffd17 	ldw	r2,-12(fp)
 400fba8:	10c00015 	stw	r3,0(r2)
	  return 1;
 400fbac:	00800044 	movi	r2,1
 400fbb0:	00002006 	br	400fc34 <__lo0bits+0xd4>
	}
      *y = x >> 2;
 400fbb4:	8006d0ba 	srli	r3,r16,2
 400fbb8:	e0bffd17 	ldw	r2,-12(fp)
 400fbbc:	10c00015 	stw	r3,0(r2)
      return 2;
 400fbc0:	00800084 	movi	r2,2
 400fbc4:	00001b06 	br	400fc34 <__lo0bits+0xd4>
    }
  k = 0;
 400fbc8:	0023883a 	mov	r17,zero
  if (!(x & 0xffff))
 400fbcc:	80bfffcc 	andi	r2,r16,65535
 400fbd0:	1000021e 	bne	r2,zero,400fbdc <__lo0bits+0x7c>
    {
      k = 16;
 400fbd4:	04400404 	movi	r17,16
      x >>= 16;
 400fbd8:	8020d43a 	srli	r16,r16,16
    }
  if (!(x & 0xff))
 400fbdc:	80803fcc 	andi	r2,r16,255
 400fbe0:	1000021e 	bne	r2,zero,400fbec <__lo0bits+0x8c>
    {
      k += 8;
 400fbe4:	8c400204 	addi	r17,r17,8
      x >>= 8;
 400fbe8:	8020d23a 	srli	r16,r16,8
    }
  if (!(x & 0xf))
 400fbec:	808003cc 	andi	r2,r16,15
 400fbf0:	1000021e 	bne	r2,zero,400fbfc <__lo0bits+0x9c>
    {
      k += 4;
 400fbf4:	8c400104 	addi	r17,r17,4
      x >>= 4;
 400fbf8:	8020d13a 	srli	r16,r16,4
    }
  if (!(x & 0x3))
 400fbfc:	808000cc 	andi	r2,r16,3
 400fc00:	1000021e 	bne	r2,zero,400fc0c <__lo0bits+0xac>
    {
      k += 2;
 400fc04:	8c400084 	addi	r17,r17,2
      x >>= 2;
 400fc08:	8020d0ba 	srli	r16,r16,2
    }
  if (!(x & 1))
 400fc0c:	8080004c 	andi	r2,r16,1
 400fc10:	1000051e 	bne	r2,zero,400fc28 <__lo0bits+0xc8>
    {
      k++;
 400fc14:	8c400044 	addi	r17,r17,1
      x >>= 1;
 400fc18:	8020d07a 	srli	r16,r16,1
      if (!x & 1)
 400fc1c:	8000021e 	bne	r16,zero,400fc28 <__lo0bits+0xc8>
	return 32;
 400fc20:	00800804 	movi	r2,32
 400fc24:	00000306 	br	400fc34 <__lo0bits+0xd4>
    }
  *y = x;
 400fc28:	e0bffd17 	ldw	r2,-12(fp)
 400fc2c:	14000015 	stw	r16,0(r2)
  return k;
 400fc30:	8805883a 	mov	r2,r17
}
 400fc34:	e6fffe04 	addi	sp,fp,-8
 400fc38:	df000217 	ldw	fp,8(sp)
 400fc3c:	dc400117 	ldw	r17,4(sp)
 400fc40:	dc000017 	ldw	r16,0(sp)
 400fc44:	dec00304 	addi	sp,sp,12
 400fc48:	f800283a 	ret

0400fc4c <__i2b>:

_Bigint *
i2b (struct _reent * ptr, int i)
{
 400fc4c:	defffa04 	addi	sp,sp,-24
 400fc50:	dfc00515 	stw	ra,20(sp)
 400fc54:	df000415 	stw	fp,16(sp)
 400fc58:	df000404 	addi	fp,sp,16
 400fc5c:	e13ffd15 	stw	r4,-12(fp)
 400fc60:	e17ffc15 	stw	r5,-16(fp)
  _Bigint *b;

  b = eBalloc (ptr, 1);
 400fc64:	01400044 	movi	r5,1
 400fc68:	e13ffd17 	ldw	r4,-12(fp)
 400fc6c:	400f5b40 	call	400f5b4 <_Balloc>
 400fc70:	e0bfff15 	stw	r2,-4(fp)
 400fc74:	e0bfff17 	ldw	r2,-4(fp)
 400fc78:	1000071e 	bne	r2,zero,400fc98 <__i2b+0x4c>
 400fc7c:	01c100b4 	movhi	r7,1026
 400fc80:	39eb4a04 	addi	r7,r7,-21208
 400fc84:	000d883a 	mov	r6,zero
 400fc88:	01405004 	movi	r5,320
 400fc8c:	010100b4 	movhi	r4,1026
 400fc90:	212b4f04 	addi	r4,r4,-21188
 400fc94:	40138480 	call	4013848 <__assert_func>
 400fc98:	e0bfff17 	ldw	r2,-4(fp)
 400fc9c:	e0bffe15 	stw	r2,-8(fp)
  b->_x[0] = i;
 400fca0:	e0fffc17 	ldw	r3,-16(fp)
 400fca4:	e0bffe17 	ldw	r2,-8(fp)
 400fca8:	10c00515 	stw	r3,20(r2)
  b->_wds = 1;
 400fcac:	e0bffe17 	ldw	r2,-8(fp)
 400fcb0:	00c00044 	movi	r3,1
 400fcb4:	10c00415 	stw	r3,16(r2)
  return b;
 400fcb8:	e0bffe17 	ldw	r2,-8(fp)
}
 400fcbc:	e037883a 	mov	sp,fp
 400fcc0:	dfc00117 	ldw	ra,4(sp)
 400fcc4:	df000017 	ldw	fp,0(sp)
 400fcc8:	dec00204 	addi	sp,sp,8
 400fccc:	f800283a 	ret

0400fcd0 <__multiply>:

_Bigint *
mult (struct _reent * ptr, _Bigint * a, _Bigint * b)
{
 400fcd0:	deffea04 	addi	sp,sp,-88
 400fcd4:	dfc01515 	stw	ra,84(sp)
 400fcd8:	df001415 	stw	fp,80(sp)
 400fcdc:	df001404 	addi	fp,sp,80
 400fce0:	e13fee15 	stw	r4,-72(fp)
 400fce4:	e17fed15 	stw	r5,-76(fp)
 400fce8:	e1bfec15 	stw	r6,-80(fp)
  __ULong *x, *xa, *xae, *xb, *xbe, *xc, *xc0;
#ifdef Pack_32
  __ULong z2;
#endif

  if (a->_wds < b->_wds)
 400fcec:	e0bfed17 	ldw	r2,-76(fp)
 400fcf0:	10c00417 	ldw	r3,16(r2)
 400fcf4:	e0bfec17 	ldw	r2,-80(fp)
 400fcf8:	10800417 	ldw	r2,16(r2)
 400fcfc:	1880060e 	bge	r3,r2,400fd18 <__multiply+0x48>
    {
      c = a;
 400fd00:	e0bfed17 	ldw	r2,-76(fp)
 400fd04:	e0bff715 	stw	r2,-36(fp)
      a = b;
 400fd08:	e0bfec17 	ldw	r2,-80(fp)
 400fd0c:	e0bfed15 	stw	r2,-76(fp)
      b = c;
 400fd10:	e0bff717 	ldw	r2,-36(fp)
 400fd14:	e0bfec15 	stw	r2,-80(fp)
    }
  k = a->_k;
 400fd18:	e0bfed17 	ldw	r2,-76(fp)
 400fd1c:	10800117 	ldw	r2,4(r2)
 400fd20:	e0bfff15 	stw	r2,-4(fp)
  wa = a->_wds;
 400fd24:	e0bfed17 	ldw	r2,-76(fp)
 400fd28:	10800417 	ldw	r2,16(r2)
 400fd2c:	e0bff615 	stw	r2,-40(fp)
  wb = b->_wds;
 400fd30:	e0bfec17 	ldw	r2,-80(fp)
 400fd34:	10800417 	ldw	r2,16(r2)
 400fd38:	e0bff515 	stw	r2,-44(fp)
  wc = wa + wb;
 400fd3c:	e0fff617 	ldw	r3,-40(fp)
 400fd40:	e0bff517 	ldw	r2,-44(fp)
 400fd44:	1885883a 	add	r2,r3,r2
 400fd48:	e0bffe15 	stw	r2,-8(fp)
  if (wc > a->_maxwds)
 400fd4c:	e0bfed17 	ldw	r2,-76(fp)
 400fd50:	10c00217 	ldw	r3,8(r2)
 400fd54:	e0bffe17 	ldw	r2,-8(fp)
 400fd58:	1880030e 	bge	r3,r2,400fd68 <__multiply+0x98>
    k++;
 400fd5c:	e0bfff17 	ldw	r2,-4(fp)
 400fd60:	10800044 	addi	r2,r2,1
 400fd64:	e0bfff15 	stw	r2,-4(fp)
  c = eBalloc (ptr, k);
 400fd68:	e17fff17 	ldw	r5,-4(fp)
 400fd6c:	e13fee17 	ldw	r4,-72(fp)
 400fd70:	400f5b40 	call	400f5b4 <_Balloc>
 400fd74:	e0bff415 	stw	r2,-48(fp)
 400fd78:	e0bff417 	ldw	r2,-48(fp)
 400fd7c:	1000071e 	bne	r2,zero,400fd9c <__multiply+0xcc>
 400fd80:	01c100b4 	movhi	r7,1026
 400fd84:	39eb4a04 	addi	r7,r7,-21208
 400fd88:	000d883a 	mov	r6,zero
 400fd8c:	01405744 	movi	r5,349
 400fd90:	010100b4 	movhi	r4,1026
 400fd94:	212b4f04 	addi	r4,r4,-21188
 400fd98:	40138480 	call	4013848 <__assert_func>
 400fd9c:	e0bff417 	ldw	r2,-48(fp)
 400fda0:	e0bff715 	stw	r2,-36(fp)
  for (x = c->_x, xa = x + wc; x < xa; x++)
 400fda4:	e0bff717 	ldw	r2,-36(fp)
 400fda8:	10800504 	addi	r2,r2,20
 400fdac:	e0bffc15 	stw	r2,-16(fp)
 400fdb0:	e0bffe17 	ldw	r2,-8(fp)
 400fdb4:	100490ba 	slli	r2,r2,2
 400fdb8:	e0fffc17 	ldw	r3,-16(fp)
 400fdbc:	1885883a 	add	r2,r3,r2
 400fdc0:	e0bff315 	stw	r2,-52(fp)
 400fdc4:	00000506 	br	400fddc <__multiply+0x10c>
    *x = 0;
 400fdc8:	e0bffc17 	ldw	r2,-16(fp)
 400fdcc:	10000015 	stw	zero,0(r2)
  for (x = c->_x, xa = x + wc; x < xa; x++)
 400fdd0:	e0bffc17 	ldw	r2,-16(fp)
 400fdd4:	10800104 	addi	r2,r2,4
 400fdd8:	e0bffc15 	stw	r2,-16(fp)
 400fddc:	e0fffc17 	ldw	r3,-16(fp)
 400fde0:	e0bff317 	ldw	r2,-52(fp)
 400fde4:	18bff836 	bltu	r3,r2,400fdc8 <__multiply+0xf8>
  xa = a->_x;
 400fde8:	e0bfed17 	ldw	r2,-76(fp)
 400fdec:	10800504 	addi	r2,r2,20
 400fdf0:	e0bff315 	stw	r2,-52(fp)
  xae = xa + wa;
 400fdf4:	e0bff617 	ldw	r2,-40(fp)
 400fdf8:	100490ba 	slli	r2,r2,2
 400fdfc:	e0fff317 	ldw	r3,-52(fp)
 400fe00:	1885883a 	add	r2,r3,r2
 400fe04:	e0bff215 	stw	r2,-56(fp)
  xb = b->_x;
 400fe08:	e0bfec17 	ldw	r2,-80(fp)
 400fe0c:	10800504 	addi	r2,r2,20
 400fe10:	e0bffb15 	stw	r2,-20(fp)
  xbe = xb + wb;
 400fe14:	e0bff517 	ldw	r2,-44(fp)
 400fe18:	100490ba 	slli	r2,r2,2
 400fe1c:	e0fffb17 	ldw	r3,-20(fp)
 400fe20:	1885883a 	add	r2,r3,r2
 400fe24:	e0bff115 	stw	r2,-60(fp)
  xc0 = c->_x;
 400fe28:	e0bff717 	ldw	r2,-36(fp)
 400fe2c:	10800504 	addi	r2,r2,20
 400fe30:	e0bff915 	stw	r2,-28(fp)
#ifdef Pack_32
  for (; xb < xbe; xb++, xc0++)
 400fe34:	00008506 	br	401004c <__multiply+0x37c>
    {
      if ((y = *xb & 0xffff) != 0)
 400fe38:	e0bffb17 	ldw	r2,-20(fp)
 400fe3c:	10800017 	ldw	r2,0(r2)
 400fe40:	10bfffcc 	andi	r2,r2,65535
 400fe44:	e0bff015 	stw	r2,-64(fp)
 400fe48:	e0bff017 	ldw	r2,-64(fp)
 400fe4c:	10003826 	beq	r2,zero,400ff30 <__multiply+0x260>
	{
	  x = xa;
 400fe50:	e0bff317 	ldw	r2,-52(fp)
 400fe54:	e0bffc15 	stw	r2,-16(fp)
	  xc = xc0;
 400fe58:	e0bff917 	ldw	r2,-28(fp)
 400fe5c:	e0bffa15 	stw	r2,-24(fp)
	  carry = 0;
 400fe60:	e03ffd15 	stw	zero,-12(fp)
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
 400fe64:	e0bffc17 	ldw	r2,-16(fp)
 400fe68:	10800017 	ldw	r2,0(r2)
 400fe6c:	10bfffcc 	andi	r2,r2,65535
 400fe70:	e17ff017 	ldw	r5,-64(fp)
 400fe74:	1009883a 	mov	r4,r2
 400fe78:	40075a40 	call	40075a4 <__mulsi3>
 400fe7c:	1007883a 	mov	r3,r2
 400fe80:	e0bffa17 	ldw	r2,-24(fp)
 400fe84:	10800017 	ldw	r2,0(r2)
 400fe88:	10bfffcc 	andi	r2,r2,65535
 400fe8c:	1885883a 	add	r2,r3,r2
 400fe90:	e0fffd17 	ldw	r3,-12(fp)
 400fe94:	1885883a 	add	r2,r3,r2
 400fe98:	e0bfef15 	stw	r2,-68(fp)
	      carry = z >> 16;
 400fe9c:	e0bfef17 	ldw	r2,-68(fp)
 400fea0:	1004d43a 	srli	r2,r2,16
 400fea4:	e0bffd15 	stw	r2,-12(fp)
	      z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;
 400fea8:	e0bffc17 	ldw	r2,-16(fp)
 400feac:	10c00104 	addi	r3,r2,4
 400feb0:	e0fffc15 	stw	r3,-16(fp)
 400feb4:	10800017 	ldw	r2,0(r2)
 400feb8:	1004d43a 	srli	r2,r2,16
 400febc:	e17ff017 	ldw	r5,-64(fp)
 400fec0:	1009883a 	mov	r4,r2
 400fec4:	40075a40 	call	40075a4 <__mulsi3>
 400fec8:	1007883a 	mov	r3,r2
 400fecc:	e0bffa17 	ldw	r2,-24(fp)
 400fed0:	10800017 	ldw	r2,0(r2)
 400fed4:	1004d43a 	srli	r2,r2,16
 400fed8:	1885883a 	add	r2,r3,r2
 400fedc:	e0fffd17 	ldw	r3,-12(fp)
 400fee0:	1885883a 	add	r2,r3,r2
 400fee4:	e0bff815 	stw	r2,-32(fp)
	      carry = z2 >> 16;
 400fee8:	e0bff817 	ldw	r2,-32(fp)
 400feec:	1004d43a 	srli	r2,r2,16
 400fef0:	e0bffd15 	stw	r2,-12(fp)
	      Storeinc (xc, z2, z);
 400fef4:	e0bff817 	ldw	r2,-32(fp)
 400fef8:	1008943a 	slli	r4,r2,16
 400fefc:	e0bfef17 	ldw	r2,-68(fp)
 400ff00:	10ffffcc 	andi	r3,r2,65535
 400ff04:	e0bffa17 	ldw	r2,-24(fp)
 400ff08:	11400104 	addi	r5,r2,4
 400ff0c:	e17ffa15 	stw	r5,-24(fp)
 400ff10:	20c6b03a 	or	r3,r4,r3
 400ff14:	10c00015 	stw	r3,0(r2)
	    }
	  while (x < xae);
 400ff18:	e0fffc17 	ldw	r3,-16(fp)
 400ff1c:	e0bff217 	ldw	r2,-56(fp)
 400ff20:	18bfd036 	bltu	r3,r2,400fe64 <__multiply+0x194>
	  *xc = carry;
 400ff24:	e0bffa17 	ldw	r2,-24(fp)
 400ff28:	e0fffd17 	ldw	r3,-12(fp)
 400ff2c:	10c00015 	stw	r3,0(r2)
	}
      if ((y = *xb >> 16) != 0)
 400ff30:	e0bffb17 	ldw	r2,-20(fp)
 400ff34:	10800017 	ldw	r2,0(r2)
 400ff38:	1004d43a 	srli	r2,r2,16
 400ff3c:	e0bff015 	stw	r2,-64(fp)
 400ff40:	e0bff017 	ldw	r2,-64(fp)
 400ff44:	10003b26 	beq	r2,zero,4010034 <__multiply+0x364>
	{
	  x = xa;
 400ff48:	e0bff317 	ldw	r2,-52(fp)
 400ff4c:	e0bffc15 	stw	r2,-16(fp)
	  xc = xc0;
 400ff50:	e0bff917 	ldw	r2,-28(fp)
 400ff54:	e0bffa15 	stw	r2,-24(fp)
	  carry = 0;
 400ff58:	e03ffd15 	stw	zero,-12(fp)
	  z2 = *xc;
 400ff5c:	e0bffa17 	ldw	r2,-24(fp)
 400ff60:	10800017 	ldw	r2,0(r2)
 400ff64:	e0bff815 	stw	r2,-32(fp)
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc >> 16) + carry;
 400ff68:	e0bffc17 	ldw	r2,-16(fp)
 400ff6c:	10800017 	ldw	r2,0(r2)
 400ff70:	10bfffcc 	andi	r2,r2,65535
 400ff74:	e17ff017 	ldw	r5,-64(fp)
 400ff78:	1009883a 	mov	r4,r2
 400ff7c:	40075a40 	call	40075a4 <__mulsi3>
 400ff80:	1007883a 	mov	r3,r2
 400ff84:	e0bffa17 	ldw	r2,-24(fp)
 400ff88:	10800017 	ldw	r2,0(r2)
 400ff8c:	1004d43a 	srli	r2,r2,16
 400ff90:	1885883a 	add	r2,r3,r2
 400ff94:	e0fffd17 	ldw	r3,-12(fp)
 400ff98:	1885883a 	add	r2,r3,r2
 400ff9c:	e0bfef15 	stw	r2,-68(fp)
	      carry = z >> 16;
 400ffa0:	e0bfef17 	ldw	r2,-68(fp)
 400ffa4:	1004d43a 	srli	r2,r2,16
 400ffa8:	e0bffd15 	stw	r2,-12(fp)
	      Storeinc (xc, z, z2);
 400ffac:	e0bfef17 	ldw	r2,-68(fp)
 400ffb0:	1008943a 	slli	r4,r2,16
 400ffb4:	e0bff817 	ldw	r2,-32(fp)
 400ffb8:	10ffffcc 	andi	r3,r2,65535
 400ffbc:	e0bffa17 	ldw	r2,-24(fp)
 400ffc0:	11400104 	addi	r5,r2,4
 400ffc4:	e17ffa15 	stw	r5,-24(fp)
 400ffc8:	20c6b03a 	or	r3,r4,r3
 400ffcc:	10c00015 	stw	r3,0(r2)
	      z2 = (*x++ >> 16) * y + (*xc & 0xffff) + carry;
 400ffd0:	e0bffc17 	ldw	r2,-16(fp)
 400ffd4:	10c00104 	addi	r3,r2,4
 400ffd8:	e0fffc15 	stw	r3,-16(fp)
 400ffdc:	10800017 	ldw	r2,0(r2)
 400ffe0:	1004d43a 	srli	r2,r2,16
 400ffe4:	e17ff017 	ldw	r5,-64(fp)
 400ffe8:	1009883a 	mov	r4,r2
 400ffec:	40075a40 	call	40075a4 <__mulsi3>
 400fff0:	1007883a 	mov	r3,r2
 400fff4:	e0bffa17 	ldw	r2,-24(fp)
 400fff8:	10800017 	ldw	r2,0(r2)
 400fffc:	10bfffcc 	andi	r2,r2,65535
 4010000:	1885883a 	add	r2,r3,r2
 4010004:	e0fffd17 	ldw	r3,-12(fp)
 4010008:	1885883a 	add	r2,r3,r2
 401000c:	e0bff815 	stw	r2,-32(fp)
	      carry = z2 >> 16;
 4010010:	e0bff817 	ldw	r2,-32(fp)
 4010014:	1004d43a 	srli	r2,r2,16
 4010018:	e0bffd15 	stw	r2,-12(fp)
	    }
	  while (x < xae);
 401001c:	e0fffc17 	ldw	r3,-16(fp)
 4010020:	e0bff217 	ldw	r2,-56(fp)
 4010024:	18bfd036 	bltu	r3,r2,400ff68 <__multiply+0x298>
	  *xc = z2;
 4010028:	e0bffa17 	ldw	r2,-24(fp)
 401002c:	e0fff817 	ldw	r3,-32(fp)
 4010030:	10c00015 	stw	r3,0(r2)
  for (; xb < xbe; xb++, xc0++)
 4010034:	e0bffb17 	ldw	r2,-20(fp)
 4010038:	10800104 	addi	r2,r2,4
 401003c:	e0bffb15 	stw	r2,-20(fp)
 4010040:	e0bff917 	ldw	r2,-28(fp)
 4010044:	10800104 	addi	r2,r2,4
 4010048:	e0bff915 	stw	r2,-28(fp)
 401004c:	e0fffb17 	ldw	r3,-20(fp)
 4010050:	e0bff117 	ldw	r2,-60(fp)
 4010054:	18bf7836 	bltu	r3,r2,400fe38 <__multiply+0x168>
	  while (x < xae);
	  *xc = carry;
	}
    }
#endif
  for (xc0 = c->_x, xc = xc0 + wc; wc > 0 && !*--xc; --wc);
 4010058:	e0bff717 	ldw	r2,-36(fp)
 401005c:	10800504 	addi	r2,r2,20
 4010060:	e0bff915 	stw	r2,-28(fp)
 4010064:	e0bffe17 	ldw	r2,-8(fp)
 4010068:	100490ba 	slli	r2,r2,2
 401006c:	e0fff917 	ldw	r3,-28(fp)
 4010070:	1885883a 	add	r2,r3,r2
 4010074:	e0bffa15 	stw	r2,-24(fp)
 4010078:	00000306 	br	4010088 <__multiply+0x3b8>
 401007c:	e0bffe17 	ldw	r2,-8(fp)
 4010080:	10bfffc4 	addi	r2,r2,-1
 4010084:	e0bffe15 	stw	r2,-8(fp)
 4010088:	e0bffe17 	ldw	r2,-8(fp)
 401008c:	0080060e 	bge	zero,r2,40100a8 <__multiply+0x3d8>
 4010090:	e0bffa17 	ldw	r2,-24(fp)
 4010094:	10bfff04 	addi	r2,r2,-4
 4010098:	e0bffa15 	stw	r2,-24(fp)
 401009c:	e0bffa17 	ldw	r2,-24(fp)
 40100a0:	10800017 	ldw	r2,0(r2)
 40100a4:	103ff526 	beq	r2,zero,401007c <__multiply+0x3ac>
  c->_wds = wc;
 40100a8:	e0bff717 	ldw	r2,-36(fp)
 40100ac:	e0fffe17 	ldw	r3,-8(fp)
 40100b0:	10c00415 	stw	r3,16(r2)
  return c;
 40100b4:	e0bff717 	ldw	r2,-36(fp)
}
 40100b8:	e037883a 	mov	sp,fp
 40100bc:	dfc00117 	ldw	ra,4(sp)
 40100c0:	df000017 	ldw	fp,0(sp)
 40100c4:	dec00204 	addi	sp,sp,8
 40100c8:	f800283a 	ret

040100cc <__pow5mult>:

_Bigint *
pow5mult (struct _reent * ptr, _Bigint * b, int k)
{
 40100cc:	defff704 	addi	sp,sp,-36
 40100d0:	dfc00815 	stw	ra,32(sp)
 40100d4:	df000715 	stw	fp,28(sp)
 40100d8:	df000704 	addi	fp,sp,28
 40100dc:	e13ffb15 	stw	r4,-20(fp)
 40100e0:	e17ffa15 	stw	r5,-24(fp)
 40100e4:	e1bff915 	stw	r6,-28(fp)
  _Bigint *b1, *p5, *p51;
  int i;
  static const int p05[3] = {5, 25, 125};

  if ((i = k & 3) != 0)
 40100e8:	e0bff917 	ldw	r2,-28(fp)
 40100ec:	108000cc 	andi	r2,r2,3
 40100f0:	e0bffd15 	stw	r2,-12(fp)
 40100f4:	e0bffd17 	ldw	r2,-12(fp)
 40100f8:	10000c26 	beq	r2,zero,401012c <__pow5mult+0x60>
    b = multadd (ptr, b, p05[i - 1], 0);
 40100fc:	e0bffd17 	ldw	r2,-12(fp)
 4010100:	10bfffc4 	addi	r2,r2,-1
 4010104:	100690ba 	slli	r3,r2,2
 4010108:	008100b4 	movhi	r2,1026
 401010c:	1885883a 	add	r2,r3,r2
 4010110:	10abac17 	ldw	r2,-20816(r2)
 4010114:	000f883a 	mov	r7,zero
 4010118:	100d883a 	mov	r6,r2
 401011c:	e17ffa17 	ldw	r5,-24(fp)
 4010120:	e13ffb17 	ldw	r4,-20(fp)
 4010124:	400f74c0 	call	400f74c <__multadd>
 4010128:	e0bffa15 	stw	r2,-24(fp)

  if (!(k >>= 2))
 401012c:	e0bff917 	ldw	r2,-28(fp)
 4010130:	1005d0ba 	srai	r2,r2,2
 4010134:	e0bff915 	stw	r2,-28(fp)
 4010138:	e0bff917 	ldw	r2,-28(fp)
 401013c:	1000021e 	bne	r2,zero,4010148 <__pow5mult+0x7c>
    return b;
 4010140:	e0bffa17 	ldw	r2,-24(fp)
 4010144:	00003806 	br	4010228 <__pow5mult+0x15c>
  _REENT_CHECK_MP(ptr);
  if (!(p5 = _REENT_MP_P5S(ptr)))
 4010148:	e0bffb17 	ldw	r2,-20(fp)
 401014c:	10801217 	ldw	r2,72(r2)
 4010150:	e0bfff15 	stw	r2,-4(fp)
 4010154:	e0bfff17 	ldw	r2,-4(fp)
 4010158:	10000b1e 	bne	r2,zero,4010188 <__pow5mult+0xbc>
    {
      /* first time */
      p5 = _REENT_MP_P5S(ptr) = i2b (ptr, 625);
 401015c:	01409c44 	movi	r5,625
 4010160:	e13ffb17 	ldw	r4,-20(fp)
 4010164:	400fc4c0 	call	400fc4c <__i2b>
 4010168:	1007883a 	mov	r3,r2
 401016c:	e0bffb17 	ldw	r2,-20(fp)
 4010170:	10c01215 	stw	r3,72(r2)
 4010174:	e0bffb17 	ldw	r2,-20(fp)
 4010178:	10801217 	ldw	r2,72(r2)
 401017c:	e0bfff15 	stw	r2,-4(fp)
      p5->_next = 0;
 4010180:	e0bfff17 	ldw	r2,-4(fp)
 4010184:	10000015 	stw	zero,0(r2)
    }
  for (;;)
    {
      if (k & 1)
 4010188:	e0bff917 	ldw	r2,-28(fp)
 401018c:	1080004c 	andi	r2,r2,1
 4010190:	10000a26 	beq	r2,zero,40101bc <__pow5mult+0xf0>
	{
	  b1 = mult (ptr, b, p5);
 4010194:	e1bfff17 	ldw	r6,-4(fp)
 4010198:	e17ffa17 	ldw	r5,-24(fp)
 401019c:	e13ffb17 	ldw	r4,-20(fp)
 40101a0:	400fcd00 	call	400fcd0 <__multiply>
 40101a4:	e0bffc15 	stw	r2,-16(fp)
	  Bfree (ptr, b);
 40101a8:	e17ffa17 	ldw	r5,-24(fp)
 40101ac:	e13ffb17 	ldw	r4,-20(fp)
 40101b0:	400f6d80 	call	400f6d8 <_Bfree>
	  b = b1;
 40101b4:	e0bffc17 	ldw	r2,-16(fp)
 40101b8:	e0bffa15 	stw	r2,-24(fp)
	}
      if (!(k >>= 1))
 40101bc:	e0bff917 	ldw	r2,-28(fp)
 40101c0:	1005d07a 	srai	r2,r2,1
 40101c4:	e0bff915 	stw	r2,-28(fp)
 40101c8:	e0bff917 	ldw	r2,-28(fp)
 40101cc:	10001426 	beq	r2,zero,4010220 <__pow5mult+0x154>
	break;
      if (!(p51 = p5->_next))
 40101d0:	e0bfff17 	ldw	r2,-4(fp)
 40101d4:	10800017 	ldw	r2,0(r2)
 40101d8:	e0bffe15 	stw	r2,-8(fp)
 40101dc:	e0bffe17 	ldw	r2,-8(fp)
 40101e0:	10000c1e 	bne	r2,zero,4010214 <__pow5mult+0x148>
	{
	  p51 = p5->_next = mult (ptr, p5, p5);
 40101e4:	e1bfff17 	ldw	r6,-4(fp)
 40101e8:	e17fff17 	ldw	r5,-4(fp)
 40101ec:	e13ffb17 	ldw	r4,-20(fp)
 40101f0:	400fcd00 	call	400fcd0 <__multiply>
 40101f4:	1007883a 	mov	r3,r2
 40101f8:	e0bfff17 	ldw	r2,-4(fp)
 40101fc:	10c00015 	stw	r3,0(r2)
 4010200:	e0bfff17 	ldw	r2,-4(fp)
 4010204:	10800017 	ldw	r2,0(r2)
 4010208:	e0bffe15 	stw	r2,-8(fp)
	  p51->_next = 0;
 401020c:	e0bffe17 	ldw	r2,-8(fp)
 4010210:	10000015 	stw	zero,0(r2)
	}
      p5 = p51;
 4010214:	e0bffe17 	ldw	r2,-8(fp)
 4010218:	e0bfff15 	stw	r2,-4(fp)
      if (k & 1)
 401021c:	003fda06 	br	4010188 <__pow5mult+0xbc>
	break;
 4010220:	0001883a 	nop
    }
  return b;
 4010224:	e0bffa17 	ldw	r2,-24(fp)
}
 4010228:	e037883a 	mov	sp,fp
 401022c:	dfc00117 	ldw	ra,4(sp)
 4010230:	df000017 	ldw	fp,0(sp)
 4010234:	dec00204 	addi	sp,sp,8
 4010238:	f800283a 	ret

0401023c <__lshift>:

_Bigint *
lshift (struct _reent * ptr, _Bigint * b, int k)
{
 401023c:	defff104 	addi	sp,sp,-60
 4010240:	dfc00e15 	stw	ra,56(sp)
 4010244:	df000d15 	stw	fp,52(sp)
 4010248:	df000d04 	addi	fp,sp,52
 401024c:	e13ff515 	stw	r4,-44(fp)
 4010250:	e17ff415 	stw	r5,-48(fp)
 4010254:	e1bff315 	stw	r6,-52(fp)
  int i, k1, n, n1;
  _Bigint *b1;
  __ULong *x, *x1, *xe, z;

#ifdef Pack_32
  n = k >> 5;
 4010258:	e0bff317 	ldw	r2,-52(fp)
 401025c:	1005d17a 	srai	r2,r2,5
 4010260:	e0bff915 	stw	r2,-28(fp)
#else
  n = k >> 4;
#endif
  k1 = b->_k;
 4010264:	e0bff417 	ldw	r2,-48(fp)
 4010268:	10800117 	ldw	r2,4(r2)
 401026c:	e0bffe15 	stw	r2,-8(fp)
  n1 = n + b->_wds + 1;
 4010270:	e0bff417 	ldw	r2,-48(fp)
 4010274:	10c00417 	ldw	r3,16(r2)
 4010278:	e0bff917 	ldw	r2,-28(fp)
 401027c:	1885883a 	add	r2,r3,r2
 4010280:	10800044 	addi	r2,r2,1
 4010284:	e0bffd15 	stw	r2,-12(fp)
  for (i = b->_maxwds; n1 > i; i <<= 1)
 4010288:	e0bff417 	ldw	r2,-48(fp)
 401028c:	10800217 	ldw	r2,8(r2)
 4010290:	e0bfff15 	stw	r2,-4(fp)
 4010294:	00000606 	br	40102b0 <__lshift+0x74>
    k1++;
 4010298:	e0bffe17 	ldw	r2,-8(fp)
 401029c:	10800044 	addi	r2,r2,1
 40102a0:	e0bffe15 	stw	r2,-8(fp)
  for (i = b->_maxwds; n1 > i; i <<= 1)
 40102a4:	e0bfff17 	ldw	r2,-4(fp)
 40102a8:	1085883a 	add	r2,r2,r2
 40102ac:	e0bfff15 	stw	r2,-4(fp)
 40102b0:	e0bffd17 	ldw	r2,-12(fp)
 40102b4:	e0ffff17 	ldw	r3,-4(fp)
 40102b8:	18bff716 	blt	r3,r2,4010298 <__lshift+0x5c>
  b1 = eBalloc (ptr, k1);
 40102bc:	e17ffe17 	ldw	r5,-8(fp)
 40102c0:	e13ff517 	ldw	r4,-44(fp)
 40102c4:	400f5b40 	call	400f5b4 <_Balloc>
 40102c8:	e0bff815 	stw	r2,-32(fp)
 40102cc:	e0bff817 	ldw	r2,-32(fp)
 40102d0:	1000071e 	bne	r2,zero,40102f0 <__lshift+0xb4>
 40102d4:	01c100b4 	movhi	r7,1026
 40102d8:	39eb4a04 	addi	r7,r7,-21208
 40102dc:	000d883a 	mov	r6,zero
 40102e0:	01407644 	movi	r5,473
 40102e4:	010100b4 	movhi	r4,1026
 40102e8:	212b4f04 	addi	r4,r4,-21188
 40102ec:	40138480 	call	4013848 <__assert_func>
 40102f0:	e0bff817 	ldw	r2,-32(fp)
 40102f4:	e0bff715 	stw	r2,-36(fp)
  x1 = b1->_x;
 40102f8:	e0bff717 	ldw	r2,-36(fp)
 40102fc:	10800504 	addi	r2,r2,20
 4010300:	e0bffb15 	stw	r2,-20(fp)
  for (i = 0; i < n; i++)
 4010304:	e03fff15 	stw	zero,-4(fp)
 4010308:	00000706 	br	4010328 <__lshift+0xec>
    *x1++ = 0;
 401030c:	e0bffb17 	ldw	r2,-20(fp)
 4010310:	10c00104 	addi	r3,r2,4
 4010314:	e0fffb15 	stw	r3,-20(fp)
 4010318:	10000015 	stw	zero,0(r2)
  for (i = 0; i < n; i++)
 401031c:	e0bfff17 	ldw	r2,-4(fp)
 4010320:	10800044 	addi	r2,r2,1
 4010324:	e0bfff15 	stw	r2,-4(fp)
 4010328:	e0ffff17 	ldw	r3,-4(fp)
 401032c:	e0bff917 	ldw	r2,-28(fp)
 4010330:	18bff616 	blt	r3,r2,401030c <__lshift+0xd0>
  x = b->_x;
 4010334:	e0bff417 	ldw	r2,-48(fp)
 4010338:	10800504 	addi	r2,r2,20
 401033c:	e0bffc15 	stw	r2,-16(fp)
  xe = x + b->_wds;
 4010340:	e0bff417 	ldw	r2,-48(fp)
 4010344:	10800417 	ldw	r2,16(r2)
 4010348:	100490ba 	slli	r2,r2,2
 401034c:	e0fffc17 	ldw	r3,-16(fp)
 4010350:	1885883a 	add	r2,r3,r2
 4010354:	e0bff615 	stw	r2,-40(fp)
#ifdef Pack_32
  if (k &= 0x1f)
 4010358:	e0bff317 	ldw	r2,-52(fp)
 401035c:	108007cc 	andi	r2,r2,31
 4010360:	e0bff315 	stw	r2,-52(fp)
 4010364:	e0bff317 	ldw	r2,-52(fp)
 4010368:	10002326 	beq	r2,zero,40103f8 <__lshift+0x1bc>
    {
      k1 = 32 - k;
 401036c:	00c00804 	movi	r3,32
 4010370:	e0bff317 	ldw	r2,-52(fp)
 4010374:	1885c83a 	sub	r2,r3,r2
 4010378:	e0bffe15 	stw	r2,-8(fp)
      z = 0;
 401037c:	e03ffa15 	stw	zero,-24(fp)
      do
	{
	  *x1++ = *x << k | z;
 4010380:	e0bffc17 	ldw	r2,-16(fp)
 4010384:	10c00017 	ldw	r3,0(r2)
 4010388:	e0bff317 	ldw	r2,-52(fp)
 401038c:	1888983a 	sll	r4,r3,r2
 4010390:	e0bffb17 	ldw	r2,-20(fp)
 4010394:	10c00104 	addi	r3,r2,4
 4010398:	e0fffb15 	stw	r3,-20(fp)
 401039c:	e0fffa17 	ldw	r3,-24(fp)
 40103a0:	20c6b03a 	or	r3,r4,r3
 40103a4:	10c00015 	stw	r3,0(r2)
	  z = *x++ >> k1;
 40103a8:	e0bffc17 	ldw	r2,-16(fp)
 40103ac:	10c00104 	addi	r3,r2,4
 40103b0:	e0fffc15 	stw	r3,-16(fp)
 40103b4:	10c00017 	ldw	r3,0(r2)
 40103b8:	e0bffe17 	ldw	r2,-8(fp)
 40103bc:	1884d83a 	srl	r2,r3,r2
 40103c0:	e0bffa15 	stw	r2,-24(fp)
	}
      while (x < xe);
 40103c4:	e0fffc17 	ldw	r3,-16(fp)
 40103c8:	e0bff617 	ldw	r2,-40(fp)
 40103cc:	18bfec36 	bltu	r3,r2,4010380 <__lshift+0x144>
      if ((*x1 = z) != 0)
 40103d0:	e0bffb17 	ldw	r2,-20(fp)
 40103d4:	e0fffa17 	ldw	r3,-24(fp)
 40103d8:	10c00015 	stw	r3,0(r2)
 40103dc:	e0bffb17 	ldw	r2,-20(fp)
 40103e0:	10800017 	ldw	r2,0(r2)
 40103e4:	10000f26 	beq	r2,zero,4010424 <__lshift+0x1e8>
	++n1;
 40103e8:	e0bffd17 	ldw	r2,-12(fp)
 40103ec:	10800044 	addi	r2,r2,1
 40103f0:	e0bffd15 	stw	r2,-12(fp)
 40103f4:	00000b06 	br	4010424 <__lshift+0x1e8>
	++n1;
    }
#endif
  else
    do
      *x1++ = *x++;
 40103f8:	e0fffc17 	ldw	r3,-16(fp)
 40103fc:	18800104 	addi	r2,r3,4
 4010400:	e0bffc15 	stw	r2,-16(fp)
 4010404:	e0bffb17 	ldw	r2,-20(fp)
 4010408:	11000104 	addi	r4,r2,4
 401040c:	e13ffb15 	stw	r4,-20(fp)
 4010410:	18c00017 	ldw	r3,0(r3)
 4010414:	10c00015 	stw	r3,0(r2)
    while (x < xe);
 4010418:	e0fffc17 	ldw	r3,-16(fp)
 401041c:	e0bff617 	ldw	r2,-40(fp)
 4010420:	18bff536 	bltu	r3,r2,40103f8 <__lshift+0x1bc>
  b1->_wds = n1 - 1;
 4010424:	e0bffd17 	ldw	r2,-12(fp)
 4010428:	10ffffc4 	addi	r3,r2,-1
 401042c:	e0bff717 	ldw	r2,-36(fp)
 4010430:	10c00415 	stw	r3,16(r2)
  Bfree (ptr, b);
 4010434:	e17ff417 	ldw	r5,-48(fp)
 4010438:	e13ff517 	ldw	r4,-44(fp)
 401043c:	400f6d80 	call	400f6d8 <_Bfree>
  return b1;
 4010440:	e0bff717 	ldw	r2,-36(fp)
}
 4010444:	e037883a 	mov	sp,fp
 4010448:	dfc00117 	ldw	ra,4(sp)
 401044c:	df000017 	ldw	fp,0(sp)
 4010450:	dec00204 	addi	sp,sp,8
 4010454:	f800283a 	ret

04010458 <__mcmp>:

int
cmp (_Bigint * a, _Bigint * b)
{
 4010458:	defff704 	addi	sp,sp,-36
 401045c:	df000815 	stw	fp,32(sp)
 4010460:	df000804 	addi	fp,sp,32
 4010464:	e13ff915 	stw	r4,-28(fp)
 4010468:	e17ff815 	stw	r5,-32(fp)
  __ULong *xa, *xa0, *xb, *xb0;
  int i, j;

  i = a->_wds;
 401046c:	e0bff917 	ldw	r2,-28(fp)
 4010470:	10800417 	ldw	r2,16(r2)
 4010474:	e0bffd15 	stw	r2,-12(fp)
  j = b->_wds;
 4010478:	e0bff817 	ldw	r2,-32(fp)
 401047c:	10800417 	ldw	r2,16(r2)
 4010480:	e0bffc15 	stw	r2,-16(fp)
  if (i > 1 && !a->_x[i - 1])
    Bug ("cmp called with a->_x[a->_wds-1] == 0");
  if (j > 1 && !b->_x[j - 1])
    Bug ("cmp called with b->_x[b->_wds-1] == 0");
#endif
  if (i -= j)
 4010484:	e0fffd17 	ldw	r3,-12(fp)
 4010488:	e0bffc17 	ldw	r2,-16(fp)
 401048c:	1885c83a 	sub	r2,r3,r2
 4010490:	e0bffd15 	stw	r2,-12(fp)
 4010494:	e0bffd17 	ldw	r2,-12(fp)
 4010498:	10000226 	beq	r2,zero,40104a4 <__mcmp+0x4c>
    return i;
 401049c:	e0bffd17 	ldw	r2,-12(fp)
 40104a0:	00002a06 	br	401054c <__mcmp+0xf4>
  xa0 = a->_x;
 40104a4:	e0bff917 	ldw	r2,-28(fp)
 40104a8:	10800504 	addi	r2,r2,20
 40104ac:	e0bffb15 	stw	r2,-20(fp)
  xa = xa0 + j;
 40104b0:	e0bffc17 	ldw	r2,-16(fp)
 40104b4:	100490ba 	slli	r2,r2,2
 40104b8:	e0fffb17 	ldw	r3,-20(fp)
 40104bc:	1885883a 	add	r2,r3,r2
 40104c0:	e0bfff15 	stw	r2,-4(fp)
  xb0 = b->_x;
 40104c4:	e0bff817 	ldw	r2,-32(fp)
 40104c8:	10800504 	addi	r2,r2,20
 40104cc:	e0bffa15 	stw	r2,-24(fp)
  xb = xb0 + j;
 40104d0:	e0bffc17 	ldw	r2,-16(fp)
 40104d4:	100490ba 	slli	r2,r2,2
 40104d8:	e0fffa17 	ldw	r3,-24(fp)
 40104dc:	1885883a 	add	r2,r3,r2
 40104e0:	e0bffe15 	stw	r2,-8(fp)
  for (;;)
    {
      if (*--xa != *--xb)
 40104e4:	e0bfff17 	ldw	r2,-4(fp)
 40104e8:	10bfff04 	addi	r2,r2,-4
 40104ec:	e0bfff15 	stw	r2,-4(fp)
 40104f0:	e0bfff17 	ldw	r2,-4(fp)
 40104f4:	10c00017 	ldw	r3,0(r2)
 40104f8:	e0bffe17 	ldw	r2,-8(fp)
 40104fc:	10bfff04 	addi	r2,r2,-4
 4010500:	e0bffe15 	stw	r2,-8(fp)
 4010504:	e0bffe17 	ldw	r2,-8(fp)
 4010508:	10800017 	ldw	r2,0(r2)
 401050c:	18800926 	beq	r3,r2,4010534 <__mcmp+0xdc>
	return *xa < *xb ? -1 : 1;
 4010510:	e0bfff17 	ldw	r2,-4(fp)
 4010514:	10c00017 	ldw	r3,0(r2)
 4010518:	e0bffe17 	ldw	r2,-8(fp)
 401051c:	10800017 	ldw	r2,0(r2)
 4010520:	1880022e 	bgeu	r3,r2,401052c <__mcmp+0xd4>
 4010524:	00bfffc4 	movi	r2,-1
 4010528:	00000806 	br	401054c <__mcmp+0xf4>
 401052c:	00800044 	movi	r2,1
 4010530:	00000606 	br	401054c <__mcmp+0xf4>
      if (xa <= xa0)
 4010534:	e0bfff17 	ldw	r2,-4(fp)
 4010538:	e0fffb17 	ldw	r3,-20(fp)
 401053c:	1880012e 	bgeu	r3,r2,4010544 <__mcmp+0xec>
      if (*--xa != *--xb)
 4010540:	003fe806 	br	40104e4 <__mcmp+0x8c>
	break;
 4010544:	0001883a 	nop
    }
  return 0;
 4010548:	0005883a 	mov	r2,zero
}
 401054c:	e037883a 	mov	sp,fp
 4010550:	df000017 	ldw	fp,0(sp)
 4010554:	dec00104 	addi	sp,sp,4
 4010558:	f800283a 	ret

0401055c <__mdiff>:

_Bigint *
diff (struct _reent * ptr,
	_Bigint * a, _Bigint * b)
{
 401055c:	deffed04 	addi	sp,sp,-76
 4010560:	dfc01215 	stw	ra,72(sp)
 4010564:	df001115 	stw	fp,68(sp)
 4010568:	df001104 	addi	fp,sp,68
 401056c:	e13ff115 	stw	r4,-60(fp)
 4010570:	e17ff015 	stw	r5,-64(fp)
 4010574:	e1bfef15 	stw	r6,-68(fp)
  __ULong *xa, *xae, *xb, *xbe, *xc;
#ifdef Pack_32
  __Long z;
#endif

  i = cmp (a, b);
 4010578:	e17fef17 	ldw	r5,-68(fp)
 401057c:	e13ff017 	ldw	r4,-64(fp)
 4010580:	40104580 	call	4010458 <__mcmp>
 4010584:	e0bfff15 	stw	r2,-4(fp)
  if (!i)
 4010588:	e0bfff17 	ldw	r2,-4(fp)
 401058c:	1000161e 	bne	r2,zero,40105e8 <__mdiff+0x8c>
    {
      c = eBalloc (ptr, 0);
 4010590:	000b883a 	mov	r5,zero
 4010594:	e13ff117 	ldw	r4,-60(fp)
 4010598:	400f5b40 	call	400f5b4 <_Balloc>
 401059c:	e0bff215 	stw	r2,-56(fp)
 40105a0:	e0bff217 	ldw	r2,-56(fp)
 40105a4:	1000071e 	bne	r2,zero,40105c4 <__mdiff+0x68>
 40105a8:	01c100b4 	movhi	r7,1026
 40105ac:	39eb4a04 	addi	r7,r7,-21208
 40105b0:	000d883a 	mov	r6,zero
 40105b4:	01408c84 	movi	r5,562
 40105b8:	010100b4 	movhi	r4,1026
 40105bc:	212b4f04 	addi	r4,r4,-21188
 40105c0:	40138480 	call	4013848 <__assert_func>
 40105c4:	e0bff217 	ldw	r2,-56(fp)
 40105c8:	e0bff915 	stw	r2,-28(fp)
      c->_wds = 1;
 40105cc:	e0bff917 	ldw	r2,-28(fp)
 40105d0:	00c00044 	movi	r3,1
 40105d4:	10c00415 	stw	r3,16(r2)
      c->_x[0] = 0;
 40105d8:	e0bff917 	ldw	r2,-28(fp)
 40105dc:	10000515 	stw	zero,20(r2)
      return c;
 40105e0:	e0bff917 	ldw	r2,-28(fp)
 40105e4:	00009506 	br	401083c <__mdiff+0x2e0>
    }
  if (i < 0)
 40105e8:	e0bfff17 	ldw	r2,-4(fp)
 40105ec:	1000090e 	bge	r2,zero,4010614 <__mdiff+0xb8>
    {
      c = a;
 40105f0:	e0bff017 	ldw	r2,-64(fp)
 40105f4:	e0bff915 	stw	r2,-28(fp)
      a = b;
 40105f8:	e0bfef17 	ldw	r2,-68(fp)
 40105fc:	e0bff015 	stw	r2,-64(fp)
      b = c;
 4010600:	e0bff917 	ldw	r2,-28(fp)
 4010604:	e0bfef15 	stw	r2,-68(fp)
      i = 1;
 4010608:	00800044 	movi	r2,1
 401060c:	e0bfff15 	stw	r2,-4(fp)
 4010610:	00000106 	br	4010618 <__mdiff+0xbc>
    }
  else
    i = 0;
 4010614:	e03fff15 	stw	zero,-4(fp)
  c = eBalloc (ptr, a->_k);
 4010618:	e0bff017 	ldw	r2,-64(fp)
 401061c:	10800117 	ldw	r2,4(r2)
 4010620:	100b883a 	mov	r5,r2
 4010624:	e13ff117 	ldw	r4,-60(fp)
 4010628:	400f5b40 	call	400f5b4 <_Balloc>
 401062c:	e0bff815 	stw	r2,-32(fp)
 4010630:	e0bff817 	ldw	r2,-32(fp)
 4010634:	1000071e 	bne	r2,zero,4010654 <__mdiff+0xf8>
 4010638:	01c100b4 	movhi	r7,1026
 401063c:	39eb4a04 	addi	r7,r7,-21208
 4010640:	000d883a 	mov	r6,zero
 4010644:	01409004 	movi	r5,576
 4010648:	010100b4 	movhi	r4,1026
 401064c:	212b4f04 	addi	r4,r4,-21188
 4010650:	40138480 	call	4013848 <__assert_func>
 4010654:	e0bff817 	ldw	r2,-32(fp)
 4010658:	e0bff915 	stw	r2,-28(fp)
  c->_sign = i;
 401065c:	e0bff917 	ldw	r2,-28(fp)
 4010660:	e0ffff17 	ldw	r3,-4(fp)
 4010664:	10c00315 	stw	r3,12(r2)
  wa = a->_wds;
 4010668:	e0bff017 	ldw	r2,-64(fp)
 401066c:	10800417 	ldw	r2,16(r2)
 4010670:	e0bffe15 	stw	r2,-8(fp)
  xa = a->_x;
 4010674:	e0bff017 	ldw	r2,-64(fp)
 4010678:	10800504 	addi	r2,r2,20
 401067c:	e0bffc15 	stw	r2,-16(fp)
  xae = xa + wa;
 4010680:	e0bffe17 	ldw	r2,-8(fp)
 4010684:	100490ba 	slli	r2,r2,2
 4010688:	e0fffc17 	ldw	r3,-16(fp)
 401068c:	1885883a 	add	r2,r3,r2
 4010690:	e0bff715 	stw	r2,-36(fp)
  wb = b->_wds;
 4010694:	e0bfef17 	ldw	r2,-68(fp)
 4010698:	10800417 	ldw	r2,16(r2)
 401069c:	e0bff615 	stw	r2,-40(fp)
  xb = b->_x;
 40106a0:	e0bfef17 	ldw	r2,-68(fp)
 40106a4:	10800504 	addi	r2,r2,20
 40106a8:	e0bffb15 	stw	r2,-20(fp)
  xbe = xb + wb;
 40106ac:	e0bff617 	ldw	r2,-40(fp)
 40106b0:	100490ba 	slli	r2,r2,2
 40106b4:	e0fffb17 	ldw	r3,-20(fp)
 40106b8:	1885883a 	add	r2,r3,r2
 40106bc:	e0bff515 	stw	r2,-44(fp)
  xc = c->_x;
 40106c0:	e0bff917 	ldw	r2,-28(fp)
 40106c4:	10800504 	addi	r2,r2,20
 40106c8:	e0bffa15 	stw	r2,-24(fp)
  borrow = 0;
 40106cc:	e03ffd15 	stw	zero,-12(fp)
#ifdef Pack_32
  do
    {
      y = (*xa & 0xffff) - (*xb & 0xffff) + borrow;
 40106d0:	e0bffc17 	ldw	r2,-16(fp)
 40106d4:	10800017 	ldw	r2,0(r2)
 40106d8:	10ffffcc 	andi	r3,r2,65535
 40106dc:	e0bffb17 	ldw	r2,-20(fp)
 40106e0:	10800017 	ldw	r2,0(r2)
 40106e4:	10bfffcc 	andi	r2,r2,65535
 40106e8:	1887c83a 	sub	r3,r3,r2
 40106ec:	e0bffd17 	ldw	r2,-12(fp)
 40106f0:	1885883a 	add	r2,r3,r2
 40106f4:	e0bff415 	stw	r2,-48(fp)
      borrow = y >> 16;
 40106f8:	e0bff417 	ldw	r2,-48(fp)
 40106fc:	1005d43a 	srai	r2,r2,16
 4010700:	e0bffd15 	stw	r2,-12(fp)
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) - (*xb++ >> 16) + borrow;
 4010704:	e0bffc17 	ldw	r2,-16(fp)
 4010708:	10c00104 	addi	r3,r2,4
 401070c:	e0fffc15 	stw	r3,-16(fp)
 4010710:	10800017 	ldw	r2,0(r2)
 4010714:	1006d43a 	srli	r3,r2,16
 4010718:	e0bffb17 	ldw	r2,-20(fp)
 401071c:	11000104 	addi	r4,r2,4
 4010720:	e13ffb15 	stw	r4,-20(fp)
 4010724:	10800017 	ldw	r2,0(r2)
 4010728:	1004d43a 	srli	r2,r2,16
 401072c:	1887c83a 	sub	r3,r3,r2
 4010730:	e0bffd17 	ldw	r2,-12(fp)
 4010734:	1885883a 	add	r2,r3,r2
 4010738:	e0bff315 	stw	r2,-52(fp)
      borrow = z >> 16;
 401073c:	e0bff317 	ldw	r2,-52(fp)
 4010740:	1005d43a 	srai	r2,r2,16
 4010744:	e0bffd15 	stw	r2,-12(fp)
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
 4010748:	e0bff317 	ldw	r2,-52(fp)
 401074c:	1006943a 	slli	r3,r2,16
 4010750:	e0bff417 	ldw	r2,-48(fp)
 4010754:	10bfffcc 	andi	r2,r2,65535
 4010758:	1888b03a 	or	r4,r3,r2
 401075c:	e0bffa17 	ldw	r2,-24(fp)
 4010760:	10c00104 	addi	r3,r2,4
 4010764:	e0fffa15 	stw	r3,-24(fp)
 4010768:	2007883a 	mov	r3,r4
 401076c:	10c00015 	stw	r3,0(r2)
    }
  while (xb < xbe);
 4010770:	e0fffb17 	ldw	r3,-20(fp)
 4010774:	e0bff517 	ldw	r2,-44(fp)
 4010778:	18bfd536 	bltu	r3,r2,40106d0 <__mdiff+0x174>
  while (xa < xae)
 401077c:	00001e06 	br	40107f8 <__mdiff+0x29c>
    {
      y = (*xa & 0xffff) + borrow;
 4010780:	e0bffc17 	ldw	r2,-16(fp)
 4010784:	10800017 	ldw	r2,0(r2)
 4010788:	10ffffcc 	andi	r3,r2,65535
 401078c:	e0bffd17 	ldw	r2,-12(fp)
 4010790:	1885883a 	add	r2,r3,r2
 4010794:	e0bff415 	stw	r2,-48(fp)
      borrow = y >> 16;
 4010798:	e0bff417 	ldw	r2,-48(fp)
 401079c:	1005d43a 	srai	r2,r2,16
 40107a0:	e0bffd15 	stw	r2,-12(fp)
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) + borrow;
 40107a4:	e0bffc17 	ldw	r2,-16(fp)
 40107a8:	10c00104 	addi	r3,r2,4
 40107ac:	e0fffc15 	stw	r3,-16(fp)
 40107b0:	10800017 	ldw	r2,0(r2)
 40107b4:	1006d43a 	srli	r3,r2,16
 40107b8:	e0bffd17 	ldw	r2,-12(fp)
 40107bc:	1885883a 	add	r2,r3,r2
 40107c0:	e0bff315 	stw	r2,-52(fp)
      borrow = z >> 16;
 40107c4:	e0bff317 	ldw	r2,-52(fp)
 40107c8:	1005d43a 	srai	r2,r2,16
 40107cc:	e0bffd15 	stw	r2,-12(fp)
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
 40107d0:	e0bff317 	ldw	r2,-52(fp)
 40107d4:	1006943a 	slli	r3,r2,16
 40107d8:	e0bff417 	ldw	r2,-48(fp)
 40107dc:	10bfffcc 	andi	r2,r2,65535
 40107e0:	1888b03a 	or	r4,r3,r2
 40107e4:	e0bffa17 	ldw	r2,-24(fp)
 40107e8:	10c00104 	addi	r3,r2,4
 40107ec:	e0fffa15 	stw	r3,-24(fp)
 40107f0:	2007883a 	mov	r3,r4
 40107f4:	10c00015 	stw	r3,0(r2)
  while (xa < xae)
 40107f8:	e0fffc17 	ldw	r3,-16(fp)
 40107fc:	e0bff717 	ldw	r2,-36(fp)
 4010800:	18bfdf36 	bltu	r3,r2,4010780 <__mdiff+0x224>
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      *xc++ = y & 0xffff;
    }
#endif
  while (!*--xc)
 4010804:	00000306 	br	4010814 <__mdiff+0x2b8>
    wa--;
 4010808:	e0bffe17 	ldw	r2,-8(fp)
 401080c:	10bfffc4 	addi	r2,r2,-1
 4010810:	e0bffe15 	stw	r2,-8(fp)
  while (!*--xc)
 4010814:	e0bffa17 	ldw	r2,-24(fp)
 4010818:	10bfff04 	addi	r2,r2,-4
 401081c:	e0bffa15 	stw	r2,-24(fp)
 4010820:	e0bffa17 	ldw	r2,-24(fp)
 4010824:	10800017 	ldw	r2,0(r2)
 4010828:	103ff726 	beq	r2,zero,4010808 <__mdiff+0x2ac>
  c->_wds = wa;
 401082c:	e0bff917 	ldw	r2,-28(fp)
 4010830:	e0fffe17 	ldw	r3,-8(fp)
 4010834:	10c00415 	stw	r3,16(r2)
  return c;
 4010838:	e0bff917 	ldw	r2,-28(fp)
}
 401083c:	e037883a 	mov	sp,fp
 4010840:	dfc00117 	ldw	ra,4(sp)
 4010844:	df000017 	ldw	fp,0(sp)
 4010848:	dec00204 	addi	sp,sp,8
 401084c:	f800283a 	ret

04010850 <__ulp>:

double
ulp (double _x)
{
 4010850:	defff804 	addi	sp,sp,-32
 4010854:	df000715 	stw	fp,28(sp)
 4010858:	dc000615 	stw	r16,24(sp)
 401085c:	df000704 	addi	fp,sp,28
 4010860:	e13ff915 	stw	r4,-28(fp)
 4010864:	e17ffa15 	stw	r5,-24(fp)
  union double_union x, a;
  register __Long L;

  x.d = _x;
 4010868:	e0bff917 	ldw	r2,-28(fp)
 401086c:	e0bffd15 	stw	r2,-12(fp)
 4010870:	e0bffa17 	ldw	r2,-24(fp)
 4010874:	e0bffe15 	stw	r2,-8(fp)

  L = (word0 (x) & Exp_mask) - (P - 1) * Exp_msk1;
 4010878:	e0bffe17 	ldw	r2,-8(fp)
 401087c:	10dffc2c 	andhi	r3,r2,32752
 4010880:	00bf3034 	movhi	r2,64704
 4010884:	1885883a 	add	r2,r3,r2
 4010888:	1021883a 	mov	r16,r2
#ifndef Sudden_Underflow
  if (L > 0)
 401088c:	0400040e 	bge	zero,r16,40108a0 <__ulp+0x50>
    {
#endif
#ifdef IBM
      L |= Exp_msk1 >> 4;
#endif
      word0 (a) = L;
 4010890:	8005883a 	mov	r2,r16
 4010894:	e0bffc15 	stw	r2,-16(fp)
#ifndef _DOUBLE_IS_32BITS
      word1 (a) = 0;
 4010898:	e03ffb15 	stw	zero,-20(fp)
 401089c:	00001206 	br	40108e8 <__ulp+0x98>

#ifndef Sudden_Underflow
    }
  else
    {
      L = -L >> Exp_shift;
 40108a0:	0405c83a 	sub	r2,zero,r16
 40108a4:	1021d53a 	srai	r16,r2,20
      if (L < Exp_shift)
 40108a8:	80800508 	cmpgei	r2,r16,20
 40108ac:	1000051e 	bne	r2,zero,40108c4 <__ulp+0x74>
	{
	  word0 (a) = 0x80000 >> L;
 40108b0:	00800234 	movhi	r2,8
 40108b4:	1405d83a 	sra	r2,r2,r16
 40108b8:	e0bffc15 	stw	r2,-16(fp)
#ifndef _DOUBLE_IS_32BITS
	  word1 (a) = 0;
 40108bc:	e03ffb15 	stw	zero,-20(fp)
 40108c0:	00000906 	br	40108e8 <__ulp+0x98>
#endif
	}
      else
	{
	  word0 (a) = 0;
 40108c4:	e03ffc15 	stw	zero,-16(fp)
	  L -= Exp_shift;
 40108c8:	843ffb04 	addi	r16,r16,-20
#ifndef _DOUBLE_IS_32BITS
         word1 (a) = L >= 31 ? 1 : 1 << (31 - L);
 40108cc:	808007c8 	cmpgei	r2,r16,31
 40108d0:	1000031e 	bne	r2,zero,40108e0 <__ulp+0x90>
 40108d4:	00a00034 	movhi	r2,32768
 40108d8:	1404d83a 	srl	r2,r2,r16
 40108dc:	00000106 	br	40108e4 <__ulp+0x94>
 40108e0:	00800044 	movi	r2,1
 40108e4:	e0bffb15 	stw	r2,-20(fp)
#endif
	}
    }
#endif
  return a.d;
 40108e8:	e0bffb17 	ldw	r2,-20(fp)
 40108ec:	e0fffc17 	ldw	r3,-16(fp)
 40108f0:	1009883a 	mov	r4,r2
 40108f4:	180b883a 	mov	r5,r3
}
 40108f8:	2005883a 	mov	r2,r4
 40108fc:	2807883a 	mov	r3,r5
 4010900:	e6ffff04 	addi	sp,fp,-4
 4010904:	df000117 	ldw	fp,4(sp)
 4010908:	dc000017 	ldw	r16,0(sp)
 401090c:	dec00204 	addi	sp,sp,8
 4010910:	f800283a 	ret

04010914 <__b2d>:

double
b2d (_Bigint * a, int *e)
{
 4010914:	defff404 	addi	sp,sp,-48
 4010918:	dfc00b15 	stw	ra,44(sp)
 401091c:	df000a15 	stw	fp,40(sp)
 4010920:	df000a04 	addi	fp,sp,40
 4010924:	e13ff715 	stw	r4,-36(fp)
 4010928:	e17ff615 	stw	r5,-40(fp)
#else
#define d0 word0(d)
#define d1 word1(d)
#endif

  xa0 = a->_x;
 401092c:	e0bff717 	ldw	r2,-36(fp)
 4010930:	10800504 	addi	r2,r2,20
 4010934:	e0bffe15 	stw	r2,-8(fp)
  xa = xa0 + a->_wds;
 4010938:	e0bff717 	ldw	r2,-36(fp)
 401093c:	10800417 	ldw	r2,16(r2)
 4010940:	100490ba 	slli	r2,r2,2
 4010944:	e0fffe17 	ldw	r3,-8(fp)
 4010948:	1885883a 	add	r2,r3,r2
 401094c:	e0bfff15 	stw	r2,-4(fp)
  y = *--xa;
 4010950:	e0bfff17 	ldw	r2,-4(fp)
 4010954:	10bfff04 	addi	r2,r2,-4
 4010958:	e0bfff15 	stw	r2,-4(fp)
 401095c:	e0bfff17 	ldw	r2,-4(fp)
 4010960:	10800017 	ldw	r2,0(r2)
 4010964:	e0bffd15 	stw	r2,-12(fp)
#ifdef DEBUG
  if (!y)
    Bug ("zero y in b2d");
#endif
  k = hi0bits (y);
 4010968:	e13ffd17 	ldw	r4,-12(fp)
 401096c:	400fad40 	call	400fad4 <__hi0bits>
 4010970:	e0bffc15 	stw	r2,-16(fp)
  *e = 32 - k;
 4010974:	00c00804 	movi	r3,32
 4010978:	e0bffc17 	ldw	r2,-16(fp)
 401097c:	1887c83a 	sub	r3,r3,r2
 4010980:	e0bff617 	ldw	r2,-40(fp)
 4010984:	10c00015 	stw	r3,0(r2)
#ifdef Pack_32
  if (k < Ebits)
 4010988:	e0bffc17 	ldw	r2,-16(fp)
 401098c:	108002c8 	cmpgei	r2,r2,11
 4010990:	10001e1e 	bne	r2,zero,4010a0c <__b2d+0xf8>
    {
      d0 = Exp_1 | y >> (Ebits - k);
 4010994:	00c002c4 	movi	r3,11
 4010998:	e0bffc17 	ldw	r2,-16(fp)
 401099c:	1885c83a 	sub	r2,r3,r2
 40109a0:	e0fffd17 	ldw	r3,-12(fp)
 40109a4:	1884d83a 	srl	r2,r3,r2
 40109a8:	108ffc34 	orhi	r2,r2,16368
 40109ac:	e0bff915 	stw	r2,-28(fp)
      w = xa > xa0 ? *--xa : 0;
 40109b0:	e0bfff17 	ldw	r2,-4(fp)
 40109b4:	e0fffe17 	ldw	r3,-8(fp)
 40109b8:	1880062e 	bgeu	r3,r2,40109d4 <__b2d+0xc0>
 40109bc:	e0bfff17 	ldw	r2,-4(fp)
 40109c0:	10bfff04 	addi	r2,r2,-4
 40109c4:	e0bfff15 	stw	r2,-4(fp)
 40109c8:	e0bfff17 	ldw	r2,-4(fp)
 40109cc:	10800017 	ldw	r2,0(r2)
 40109d0:	00000106 	br	40109d8 <__b2d+0xc4>
 40109d4:	0005883a 	mov	r2,zero
 40109d8:	e0bffa15 	stw	r2,-24(fp)
#ifndef _DOUBLE_IS_32BITS
      d1 = y << ((32 - Ebits) + k) | w >> (Ebits - k);
 40109dc:	e0bffc17 	ldw	r2,-16(fp)
 40109e0:	10800544 	addi	r2,r2,21
 40109e4:	e0fffd17 	ldw	r3,-12(fp)
 40109e8:	1886983a 	sll	r3,r3,r2
 40109ec:	010002c4 	movi	r4,11
 40109f0:	e0bffc17 	ldw	r2,-16(fp)
 40109f4:	2085c83a 	sub	r2,r4,r2
 40109f8:	e13ffa17 	ldw	r4,-24(fp)
 40109fc:	2084d83a 	srl	r2,r4,r2
 4010a00:	1884b03a 	or	r2,r3,r2
 4010a04:	e0bff815 	stw	r2,-32(fp)
#endif
      goto ret_d;
 4010a08:	00003606 	br	4010ae4 <__b2d+0x1d0>
    }
  z = xa > xa0 ? *--xa : 0;
 4010a0c:	e0bfff17 	ldw	r2,-4(fp)
 4010a10:	e0fffe17 	ldw	r3,-8(fp)
 4010a14:	1880062e 	bgeu	r3,r2,4010a30 <__b2d+0x11c>
 4010a18:	e0bfff17 	ldw	r2,-4(fp)
 4010a1c:	10bfff04 	addi	r2,r2,-4
 4010a20:	e0bfff15 	stw	r2,-4(fp)
 4010a24:	e0bfff17 	ldw	r2,-4(fp)
 4010a28:	10800017 	ldw	r2,0(r2)
 4010a2c:	00000106 	br	4010a34 <__b2d+0x120>
 4010a30:	0005883a 	mov	r2,zero
 4010a34:	e0bffb15 	stw	r2,-20(fp)
  if (k -= Ebits)
 4010a38:	e0bffc17 	ldw	r2,-16(fp)
 4010a3c:	10bffd44 	addi	r2,r2,-11
 4010a40:	e0bffc15 	stw	r2,-16(fp)
 4010a44:	e0bffc17 	ldw	r2,-16(fp)
 4010a48:	10002126 	beq	r2,zero,4010ad0 <__b2d+0x1bc>
    {
      d0 = Exp_1 | y << k | z >> (32 - k);
 4010a4c:	e0fffd17 	ldw	r3,-12(fp)
 4010a50:	e0bffc17 	ldw	r2,-16(fp)
 4010a54:	1886983a 	sll	r3,r3,r2
 4010a58:	01000804 	movi	r4,32
 4010a5c:	e0bffc17 	ldw	r2,-16(fp)
 4010a60:	2085c83a 	sub	r2,r4,r2
 4010a64:	e13ffb17 	ldw	r4,-20(fp)
 4010a68:	2084d83a 	srl	r2,r4,r2
 4010a6c:	1884b03a 	or	r2,r3,r2
 4010a70:	108ffc34 	orhi	r2,r2,16368
 4010a74:	e0bff915 	stw	r2,-28(fp)
      y = xa > xa0 ? *--xa : 0;
 4010a78:	e0bfff17 	ldw	r2,-4(fp)
 4010a7c:	e0fffe17 	ldw	r3,-8(fp)
 4010a80:	1880062e 	bgeu	r3,r2,4010a9c <__b2d+0x188>
 4010a84:	e0bfff17 	ldw	r2,-4(fp)
 4010a88:	10bfff04 	addi	r2,r2,-4
 4010a8c:	e0bfff15 	stw	r2,-4(fp)
 4010a90:	e0bfff17 	ldw	r2,-4(fp)
 4010a94:	10800017 	ldw	r2,0(r2)
 4010a98:	00000106 	br	4010aa0 <__b2d+0x18c>
 4010a9c:	0005883a 	mov	r2,zero
 4010aa0:	e0bffd15 	stw	r2,-12(fp)
#ifndef _DOUBLE_IS_32BITS
      d1 = z << k | y >> (32 - k);
 4010aa4:	e0fffb17 	ldw	r3,-20(fp)
 4010aa8:	e0bffc17 	ldw	r2,-16(fp)
 4010aac:	1886983a 	sll	r3,r3,r2
 4010ab0:	01000804 	movi	r4,32
 4010ab4:	e0bffc17 	ldw	r2,-16(fp)
 4010ab8:	2085c83a 	sub	r2,r4,r2
 4010abc:	e13ffd17 	ldw	r4,-12(fp)
 4010ac0:	2084d83a 	srl	r2,r4,r2
 4010ac4:	1884b03a 	or	r2,r3,r2
 4010ac8:	e0bff815 	stw	r2,-32(fp)
 4010acc:	00000506 	br	4010ae4 <__b2d+0x1d0>
#endif
    }
  else
    {
      d0 = Exp_1 | y;
 4010ad0:	e0bffd17 	ldw	r2,-12(fp)
 4010ad4:	108ffc34 	orhi	r2,r2,16368
 4010ad8:	e0bff915 	stw	r2,-28(fp)
#ifndef _DOUBLE_IS_32BITS
      d1 = z;
 4010adc:	e0bffb17 	ldw	r2,-20(fp)
 4010ae0:	e0bff815 	stw	r2,-32(fp)
  word1 (d) = d1 >> 16 | d1 << 16;
#else
#undef d0
#undef d1
#endif
  return d.d;
 4010ae4:	e0bff817 	ldw	r2,-32(fp)
 4010ae8:	e0fff917 	ldw	r3,-28(fp)
 4010aec:	1009883a 	mov	r4,r2
 4010af0:	180b883a 	mov	r5,r3
}
 4010af4:	2005883a 	mov	r2,r4
 4010af8:	2807883a 	mov	r3,r5
 4010afc:	e037883a 	mov	sp,fp
 4010b00:	dfc00117 	ldw	ra,4(sp)
 4010b04:	df000017 	ldw	fp,0(sp)
 4010b08:	dec00204 	addi	sp,sp,8
 4010b0c:	f800283a 	ret

04010b10 <__d2b>:
d2b (struct _reent * ptr,
	double _d,
	int *e,
	int *bits)

{
 4010b10:	deffef04 	addi	sp,sp,-68
 4010b14:	dfc01015 	stw	ra,64(sp)
 4010b18:	df000f15 	stw	fp,60(sp)
 4010b1c:	dc000e15 	stw	r16,56(sp)
 4010b20:	df000f04 	addi	fp,sp,60
 4010b24:	e13ff415 	stw	r4,-48(fp)
 4010b28:	e17ff215 	stw	r5,-56(fp)
 4010b2c:	e1bff315 	stw	r6,-52(fp)
 4010b30:	e1fff115 	stw	r7,-60(fp)
  int de, i, k;
  __ULong *x, y, z;
#ifdef VAX
  __ULong d0, d1;
#endif
  d.d = _d;
 4010b34:	e0bff217 	ldw	r2,-56(fp)
 4010b38:	e0bff715 	stw	r2,-36(fp)
 4010b3c:	e0bff317 	ldw	r2,-52(fp)
 4010b40:	e0bff815 	stw	r2,-32(fp)
  d0 = word0 (d) >> 16 | word0 (d) << 16;
  d1 = word1 (d) >> 16 | word1 (d) << 16;
#else
#define d0 word0(d)
#define d1 word1(d)
  d.d = _d;
 4010b44:	e0bff217 	ldw	r2,-56(fp)
 4010b48:	e0bff715 	stw	r2,-36(fp)
 4010b4c:	e0bff317 	ldw	r2,-52(fp)
 4010b50:	e0bff815 	stw	r2,-32(fp)
#endif

#ifdef Pack_32
  b = eBalloc (ptr, 1);
 4010b54:	01400044 	movi	r5,1
 4010b58:	e13ff417 	ldw	r4,-48(fp)
 4010b5c:	400f5b40 	call	400f5b4 <_Balloc>
 4010b60:	e0bffc15 	stw	r2,-16(fp)
 4010b64:	e0bffc17 	ldw	r2,-16(fp)
 4010b68:	1000071e 	bne	r2,zero,4010b88 <__d2b+0x78>
 4010b6c:	01c100b4 	movhi	r7,1026
 4010b70:	39eb4a04 	addi	r7,r7,-21208
 4010b74:	000d883a 	mov	r6,zero
 4010b78:	0140c284 	movi	r5,778
 4010b7c:	010100b4 	movhi	r4,1026
 4010b80:	212b4f04 	addi	r4,r4,-21188
 4010b84:	40138480 	call	4013848 <__assert_func>
 4010b88:	e0bffc17 	ldw	r2,-16(fp)
 4010b8c:	e0bffb15 	stw	r2,-20(fp)
#else
  b = eBalloc (ptr, 2);
#endif
  x = b->_x;
 4010b90:	e0bffb17 	ldw	r2,-20(fp)
 4010b94:	10800504 	addi	r2,r2,20
 4010b98:	e0bffa15 	stw	r2,-24(fp)

  z = d0 & Frac_mask;
 4010b9c:	e0fff817 	ldw	r3,-32(fp)
 4010ba0:	00800434 	movhi	r2,16
 4010ba4:	10bfffc4 	addi	r2,r2,-1
 4010ba8:	1884703a 	and	r2,r3,r2
 4010bac:	e0bff515 	stw	r2,-44(fp)
  d0 &= 0x7fffffff;		/* clear sign bit, which we ignore */
 4010bb0:	e0fff817 	ldw	r3,-32(fp)
 4010bb4:	00a00034 	movhi	r2,32768
 4010bb8:	10bfffc4 	addi	r2,r2,-1
 4010bbc:	1884703a 	and	r2,r3,r2
 4010bc0:	e0bff815 	stw	r2,-32(fp)
  de = (int) (d0 >> Exp_shift);
#ifndef IBM
  z |= Exp_msk11;
#endif
#else
  if ((de = (int) (d0 >> Exp_shift)) != 0)
 4010bc4:	e0bff817 	ldw	r2,-32(fp)
 4010bc8:	1004d53a 	srli	r2,r2,20
 4010bcc:	e0bff915 	stw	r2,-28(fp)
 4010bd0:	e0bff917 	ldw	r2,-28(fp)
 4010bd4:	10000326 	beq	r2,zero,4010be4 <__d2b+0xd4>
    z |= Exp_msk1;
 4010bd8:	e0bff517 	ldw	r2,-44(fp)
 4010bdc:	10800434 	orhi	r2,r2,16
 4010be0:	e0bff515 	stw	r2,-44(fp)
#endif
#ifdef Pack_32
#ifndef _DOUBLE_IS_32BITS
  if (d1)
 4010be4:	e0bff717 	ldw	r2,-36(fp)
 4010be8:	10002826 	beq	r2,zero,4010c8c <__d2b+0x17c>
    {
      y = d1;
 4010bec:	e0bff717 	ldw	r2,-36(fp)
 4010bf0:	e0bff615 	stw	r2,-40(fp)
      k = lo0bits (&y);
 4010bf4:	e0bff604 	addi	r2,fp,-40
 4010bf8:	1009883a 	mov	r4,r2
 4010bfc:	400fb600 	call	400fb60 <__lo0bits>
 4010c00:	e0bffd15 	stw	r2,-12(fp)
      if (k)
 4010c04:	e0bffd17 	ldw	r2,-12(fp)
 4010c08:	10000e26 	beq	r2,zero,4010c44 <__d2b+0x134>
	{
         x[0] = y | z << (32 - k);
 4010c0c:	e0fff517 	ldw	r3,-44(fp)
 4010c10:	01000804 	movi	r4,32
 4010c14:	e0bffd17 	ldw	r2,-12(fp)
 4010c18:	2085c83a 	sub	r2,r4,r2
 4010c1c:	1886983a 	sll	r3,r3,r2
 4010c20:	e0bff617 	ldw	r2,-40(fp)
 4010c24:	1886b03a 	or	r3,r3,r2
 4010c28:	e0bffa17 	ldw	r2,-24(fp)
 4010c2c:	10c00015 	stw	r3,0(r2)
	  z >>= k;
 4010c30:	e0fff517 	ldw	r3,-44(fp)
 4010c34:	e0bffd17 	ldw	r2,-12(fp)
 4010c38:	1884d83a 	srl	r2,r3,r2
 4010c3c:	e0bff515 	stw	r2,-44(fp)
 4010c40:	00000306 	br	4010c50 <__d2b+0x140>
	}
      else
	x[0] = y;
 4010c44:	e0fff617 	ldw	r3,-40(fp)
 4010c48:	e0bffa17 	ldw	r2,-24(fp)
 4010c4c:	10c00015 	stw	r3,0(r2)
      i = b->_wds = (x[1] = z) ? 2 : 1;
 4010c50:	e0bffa17 	ldw	r2,-24(fp)
 4010c54:	10800104 	addi	r2,r2,4
 4010c58:	e0fff517 	ldw	r3,-44(fp)
 4010c5c:	10c00015 	stw	r3,0(r2)
 4010c60:	10800017 	ldw	r2,0(r2)
 4010c64:	10000226 	beq	r2,zero,4010c70 <__d2b+0x160>
 4010c68:	00800084 	movi	r2,2
 4010c6c:	00000106 	br	4010c74 <__d2b+0x164>
 4010c70:	00800044 	movi	r2,1
 4010c74:	e0fffb17 	ldw	r3,-20(fp)
 4010c78:	18800415 	stw	r2,16(r3)
 4010c7c:	e0bffb17 	ldw	r2,-20(fp)
 4010c80:	10800417 	ldw	r2,16(r2)
 4010c84:	e0bffe15 	stw	r2,-8(fp)
 4010c88:	00001006 	br	4010ccc <__d2b+0x1bc>
    {
#ifdef DEBUG
      if (!z)
	Bug ("Zero passed to d2b");
#endif
      k = lo0bits (&z);
 4010c8c:	e0bff504 	addi	r2,fp,-44
 4010c90:	1009883a 	mov	r4,r2
 4010c94:	400fb600 	call	400fb60 <__lo0bits>
 4010c98:	e0bffd15 	stw	r2,-12(fp)
      x[0] = z;
 4010c9c:	e0fff517 	ldw	r3,-44(fp)
 4010ca0:	e0bffa17 	ldw	r2,-24(fp)
 4010ca4:	10c00015 	stw	r3,0(r2)
      i = b->_wds = 1;
 4010ca8:	e0bffb17 	ldw	r2,-20(fp)
 4010cac:	00c00044 	movi	r3,1
 4010cb0:	10c00415 	stw	r3,16(r2)
 4010cb4:	e0bffb17 	ldw	r2,-20(fp)
 4010cb8:	10800417 	ldw	r2,16(r2)
 4010cbc:	e0bffe15 	stw	r2,-8(fp)
#ifndef _DOUBLE_IS_32BITS
      k += 32;
 4010cc0:	e0bffd17 	ldw	r2,-12(fp)
 4010cc4:	10800804 	addi	r2,r2,32
 4010cc8:	e0bffd15 	stw	r2,-12(fp)
  while (!x[i])
    --i;
  b->_wds = i + 1;
#endif
#ifndef Sudden_Underflow
  if (de)
 4010ccc:	e0bff917 	ldw	r2,-28(fp)
 4010cd0:	10000c26 	beq	r2,zero,4010d04 <__d2b+0x1f4>
#endif
#ifdef IBM
      *e = (de - Bias - (P - 1) << 2) + k;
      *bits = 4 * P + 8 - k - hi0bits (word0 (d) & Frac_mask);
#else
      *e = de - Bias - (P - 1) + k;
 4010cd4:	e0bff917 	ldw	r2,-28(fp)
 4010cd8:	10fef344 	addi	r3,r2,-1075
 4010cdc:	e0bffd17 	ldw	r2,-12(fp)
 4010ce0:	1887883a 	add	r3,r3,r2
 4010ce4:	e0bff117 	ldw	r2,-60(fp)
 4010ce8:	10c00015 	stw	r3,0(r2)
      *bits = P - k;
 4010cec:	00c00d44 	movi	r3,53
 4010cf0:	e0bffd17 	ldw	r2,-12(fp)
 4010cf4:	1887c83a 	sub	r3,r3,r2
 4010cf8:	e0800217 	ldw	r2,8(fp)
 4010cfc:	10c00015 	stw	r3,0(r2)
 4010d00:	00001506 	br	4010d58 <__d2b+0x248>
#endif
#ifndef Sudden_Underflow
    }
  else
    {
      *e = de - Bias - (P - 1) + 1 + k;
 4010d04:	e0bff917 	ldw	r2,-28(fp)
 4010d08:	10fef384 	addi	r3,r2,-1074
 4010d0c:	e0bffd17 	ldw	r2,-12(fp)
 4010d10:	1887883a 	add	r3,r3,r2
 4010d14:	e0bff117 	ldw	r2,-60(fp)
 4010d18:	10c00015 	stw	r3,0(r2)
#ifdef Pack_32
      *bits = 32 * i - hi0bits (x[i - 1]);
 4010d1c:	e0bffe17 	ldw	r2,-8(fp)
 4010d20:	1020917a 	slli	r16,r2,5
 4010d24:	e0fffe17 	ldw	r3,-8(fp)
 4010d28:	00900034 	movhi	r2,16384
 4010d2c:	10bfffc4 	addi	r2,r2,-1
 4010d30:	1885883a 	add	r2,r3,r2
 4010d34:	100490ba 	slli	r2,r2,2
 4010d38:	e0fffa17 	ldw	r3,-24(fp)
 4010d3c:	1885883a 	add	r2,r3,r2
 4010d40:	10800017 	ldw	r2,0(r2)
 4010d44:	1009883a 	mov	r4,r2
 4010d48:	400fad40 	call	400fad4 <__hi0bits>
 4010d4c:	8087c83a 	sub	r3,r16,r2
 4010d50:	e0800217 	ldw	r2,8(fp)
 4010d54:	10c00015 	stw	r3,0(r2)
#else
      *bits = (i + 2) * 16 - hi0bits (x[i]);
#endif
    }
#endif
  return b;
 4010d58:	e0bffb17 	ldw	r2,-20(fp)
}
 4010d5c:	e6ffff04 	addi	sp,fp,-4
 4010d60:	dfc00217 	ldw	ra,8(sp)
 4010d64:	df000117 	ldw	fp,4(sp)
 4010d68:	dc000017 	ldw	r16,0(sp)
 4010d6c:	dec00304 	addi	sp,sp,12
 4010d70:	f800283a 	ret

04010d74 <__ratio>:
#undef d1

double
ratio (_Bigint * a, _Bigint * b)

{
 4010d74:	defff504 	addi	sp,sp,-44
 4010d78:	dfc00a15 	stw	ra,40(sp)
 4010d7c:	df000915 	stw	fp,36(sp)
 4010d80:	df000904 	addi	fp,sp,36
 4010d84:	e13ff815 	stw	r4,-32(fp)
 4010d88:	e17ff715 	stw	r5,-36(fp)
  union double_union da, db;
  int k, ka, kb;

  da.d = b2d (a, &ka);
 4010d8c:	e0bffa04 	addi	r2,fp,-24
 4010d90:	100b883a 	mov	r5,r2
 4010d94:	e13ff817 	ldw	r4,-32(fp)
 4010d98:	40109140 	call	4010914 <__b2d>
 4010d9c:	1009883a 	mov	r4,r2
 4010da0:	180b883a 	mov	r5,r3
 4010da4:	e13ffd15 	stw	r4,-12(fp)
 4010da8:	e17ffe15 	stw	r5,-8(fp)
  db.d = b2d (b, &kb);
 4010dac:	e0bff904 	addi	r2,fp,-28
 4010db0:	100b883a 	mov	r5,r2
 4010db4:	e13ff717 	ldw	r4,-36(fp)
 4010db8:	40109140 	call	4010914 <__b2d>
 4010dbc:	1009883a 	mov	r4,r2
 4010dc0:	180b883a 	mov	r5,r3
 4010dc4:	e13ffb15 	stw	r4,-20(fp)
 4010dc8:	e17ffc15 	stw	r5,-16(fp)
#ifdef Pack_32
  k = ka - kb + 32 * (a->_wds - b->_wds);
 4010dcc:	e0fffa17 	ldw	r3,-24(fp)
 4010dd0:	e0bff917 	ldw	r2,-28(fp)
 4010dd4:	1887c83a 	sub	r3,r3,r2
 4010dd8:	e0bff817 	ldw	r2,-32(fp)
 4010ddc:	11000417 	ldw	r4,16(r2)
 4010de0:	e0bff717 	ldw	r2,-36(fp)
 4010de4:	10800417 	ldw	r2,16(r2)
 4010de8:	2085c83a 	sub	r2,r4,r2
 4010dec:	1004917a 	slli	r2,r2,5
 4010df0:	1885883a 	add	r2,r3,r2
 4010df4:	e0bfff15 	stw	r2,-4(fp)
      word0 (db) += (k >> 2) * Exp_msk1;
      if (k &= 3)
	db.d *= 1 << k;
    }
#else
  if (k > 0)
 4010df8:	e0bfff17 	ldw	r2,-4(fp)
 4010dfc:	0080060e 	bge	zero,r2,4010e18 <__ratio+0xa4>
    word0 (da) += k * Exp_msk1;
 4010e00:	e0fffe17 	ldw	r3,-8(fp)
 4010e04:	e0bfff17 	ldw	r2,-4(fp)
 4010e08:	1004953a 	slli	r2,r2,20
 4010e0c:	1885883a 	add	r2,r3,r2
 4010e10:	e0bffe15 	stw	r2,-8(fp)
 4010e14:	00000806 	br	4010e38 <__ratio+0xc4>
  else
    {
      k = -k;
 4010e18:	e0bfff17 	ldw	r2,-4(fp)
 4010e1c:	0085c83a 	sub	r2,zero,r2
 4010e20:	e0bfff15 	stw	r2,-4(fp)
      word0 (db) += k * Exp_msk1;
 4010e24:	e0fffc17 	ldw	r3,-16(fp)
 4010e28:	e0bfff17 	ldw	r2,-4(fp)
 4010e2c:	1004953a 	slli	r2,r2,20
 4010e30:	1885883a 	add	r2,r3,r2
 4010e34:	e0bffc15 	stw	r2,-16(fp)
    }
#endif
  return da.d / db.d;
 4010e38:	e0bffd17 	ldw	r2,-12(fp)
 4010e3c:	e0fffe17 	ldw	r3,-8(fp)
 4010e40:	e13ffb17 	ldw	r4,-20(fp)
 4010e44:	e17ffc17 	ldw	r5,-16(fp)
 4010e48:	200d883a 	mov	r6,r4
 4010e4c:	280f883a 	mov	r7,r5
 4010e50:	1009883a 	mov	r4,r2
 4010e54:	180b883a 	mov	r5,r3
 4010e58:	4015ed00 	call	4015ed0 <__divdf3>
 4010e5c:	1009883a 	mov	r4,r2
 4010e60:	180b883a 	mov	r5,r3
 4010e64:	2005883a 	mov	r2,r4
 4010e68:	2807883a 	mov	r3,r5
 4010e6c:	1009883a 	mov	r4,r2
 4010e70:	180b883a 	mov	r5,r3
}
 4010e74:	2005883a 	mov	r2,r4
 4010e78:	2807883a 	mov	r3,r5
 4010e7c:	e037883a 	mov	sp,fp
 4010e80:	dfc00117 	ldw	ra,4(sp)
 4010e84:	df000017 	ldw	fp,0(sp)
 4010e88:	dec00204 	addi	sp,sp,8
 4010e8c:	f800283a 	ret

04010e90 <_mprec_log10>:
#endif


double
_mprec_log10 (int dig)
{
 4010e90:	defffb04 	addi	sp,sp,-20
 4010e94:	dfc00415 	stw	ra,16(sp)
 4010e98:	df000315 	stw	fp,12(sp)
 4010e9c:	df000304 	addi	fp,sp,12
 4010ea0:	e13ffd15 	stw	r4,-12(fp)
  double v = 1.0;
 4010ea4:	e03ffe15 	stw	zero,-8(fp)
 4010ea8:	008ffc34 	movhi	r2,16368
 4010eac:	e0bfff15 	stw	r2,-4(fp)
  if (dig < 24)
 4010eb0:	e0bffd17 	ldw	r2,-12(fp)
 4010eb4:	10800608 	cmpgei	r2,r2,24
 4010eb8:	1000151e 	bne	r2,zero,4010f10 <_mprec_log10+0x80>
    return tens[dig];
 4010ebc:	e0bffd17 	ldw	r2,-12(fp)
 4010ec0:	100a90fa 	slli	r5,r2,3
 4010ec4:	010100b4 	movhi	r4,1026
 4010ec8:	2909883a 	add	r4,r5,r4
 4010ecc:	20ab6617 	ldw	r2,-21096(r4)
 4010ed0:	010100b4 	movhi	r4,1026
 4010ed4:	2909883a 	add	r4,r5,r4
 4010ed8:	20eb6717 	ldw	r3,-21092(r4)
 4010edc:	00001006 	br	4010f20 <_mprec_log10+0x90>
  while (dig > 0)
    {
      v *= 10;
 4010ee0:	000d883a 	mov	r6,zero
 4010ee4:	01d00934 	movhi	r7,16420
 4010ee8:	e13ffe17 	ldw	r4,-8(fp)
 4010eec:	e17fff17 	ldw	r5,-4(fp)
 4010ef0:	4016a640 	call	4016a64 <__muldf3>
 4010ef4:	1009883a 	mov	r4,r2
 4010ef8:	180b883a 	mov	r5,r3
 4010efc:	e13ffe15 	stw	r4,-8(fp)
 4010f00:	e17fff15 	stw	r5,-4(fp)
      dig--;
 4010f04:	e0bffd17 	ldw	r2,-12(fp)
 4010f08:	10bfffc4 	addi	r2,r2,-1
 4010f0c:	e0bffd15 	stw	r2,-12(fp)
  while (dig > 0)
 4010f10:	e0bffd17 	ldw	r2,-12(fp)
 4010f14:	00bff216 	blt	zero,r2,4010ee0 <_mprec_log10+0x50>
    }
  return v;
 4010f18:	e0bffe17 	ldw	r2,-8(fp)
 4010f1c:	e0ffff17 	ldw	r3,-4(fp)
 4010f20:	1009883a 	mov	r4,r2
 4010f24:	180b883a 	mov	r5,r3
}
 4010f28:	2005883a 	mov	r2,r4
 4010f2c:	2807883a 	mov	r3,r5
 4010f30:	e037883a 	mov	sp,fp
 4010f34:	dfc00117 	ldw	ra,4(sp)
 4010f38:	df000017 	ldw	fp,0(sp)
 4010f3c:	dec00204 	addi	sp,sp,8
 4010f40:	f800283a 	ret

04010f44 <__copybits>:

void
copybits (__ULong *c,
	int n,
	_Bigint *b)
{
 4010f44:	defff904 	addi	sp,sp,-28
 4010f48:	df000615 	stw	fp,24(sp)
 4010f4c:	df000604 	addi	fp,sp,24
 4010f50:	e13ffc15 	stw	r4,-16(fp)
 4010f54:	e17ffb15 	stw	r5,-20(fp)
 4010f58:	e1bffa15 	stw	r6,-24(fp)
	__ULong *ce, *x, *xe;
#ifdef Pack_16
	int nw, nw1;
#endif

	ce = c + ((n-1) >> kshift) + 1;
 4010f5c:	e0bffb17 	ldw	r2,-20(fp)
 4010f60:	10bfffc4 	addi	r2,r2,-1
 4010f64:	1005d17a 	srai	r2,r2,5
 4010f68:	10800044 	addi	r2,r2,1
 4010f6c:	100490ba 	slli	r2,r2,2
 4010f70:	e0fffc17 	ldw	r3,-16(fp)
 4010f74:	1885883a 	add	r2,r3,r2
 4010f78:	e0bffe15 	stw	r2,-8(fp)
	x = b->_x;
 4010f7c:	e0bffa17 	ldw	r2,-24(fp)
 4010f80:	10800504 	addi	r2,r2,20
 4010f84:	e0bfff15 	stw	r2,-4(fp)
#ifdef Pack_32
	xe = x + b->_wds;
 4010f88:	e0bffa17 	ldw	r2,-24(fp)
 4010f8c:	10800417 	ldw	r2,16(r2)
 4010f90:	100490ba 	slli	r2,r2,2
 4010f94:	e0ffff17 	ldw	r3,-4(fp)
 4010f98:	1885883a 	add	r2,r3,r2
 4010f9c:	e0bffd15 	stw	r2,-12(fp)
	while(x < xe)
 4010fa0:	00000806 	br	4010fc4 <__copybits+0x80>
		*c++ = *x++;
 4010fa4:	e0ffff17 	ldw	r3,-4(fp)
 4010fa8:	18800104 	addi	r2,r3,4
 4010fac:	e0bfff15 	stw	r2,-4(fp)
 4010fb0:	e0bffc17 	ldw	r2,-16(fp)
 4010fb4:	11000104 	addi	r4,r2,4
 4010fb8:	e13ffc15 	stw	r4,-16(fp)
 4010fbc:	18c00017 	ldw	r3,0(r3)
 4010fc0:	10c00015 	stw	r3,0(r2)
	while(x < xe)
 4010fc4:	e0ffff17 	ldw	r3,-4(fp)
 4010fc8:	e0bffd17 	ldw	r2,-12(fp)
 4010fcc:	18bff536 	bltu	r3,r2,4010fa4 <__copybits+0x60>
	for(xe = x + (nw - nw1); x < xe; x += 2)
		Storeinc(c, x[1], x[0]);
	if (nw1)
		*c++ = *x;
#endif
	while(c < ce)
 4010fd0:	00000406 	br	4010fe4 <__copybits+0xa0>
		*c++ = 0;
 4010fd4:	e0bffc17 	ldw	r2,-16(fp)
 4010fd8:	10c00104 	addi	r3,r2,4
 4010fdc:	e0fffc15 	stw	r3,-16(fp)
 4010fe0:	10000015 	stw	zero,0(r2)
	while(c < ce)
 4010fe4:	e0fffc17 	ldw	r3,-16(fp)
 4010fe8:	e0bffe17 	ldw	r2,-8(fp)
 4010fec:	18bff936 	bltu	r3,r2,4010fd4 <__copybits+0x90>
}
 4010ff0:	0001883a 	nop
 4010ff4:	0001883a 	nop
 4010ff8:	e037883a 	mov	sp,fp
 4010ffc:	df000017 	ldw	fp,0(sp)
 4011000:	dec00104 	addi	sp,sp,4
 4011004:	f800283a 	ret

04011008 <__any_on>:

__ULong
any_on (_Bigint *b,
	int k)
{
 4011008:	defff704 	addi	sp,sp,-36
 401100c:	df000815 	stw	fp,32(sp)
 4011010:	df000804 	addi	fp,sp,32
 4011014:	e13ff915 	stw	r4,-28(fp)
 4011018:	e17ff815 	stw	r5,-32(fp)
	int n, nwds;
	__ULong *x, *x0, x1, x2;

	x = b->_x;
 401101c:	e0bff917 	ldw	r2,-28(fp)
 4011020:	10800504 	addi	r2,r2,20
 4011024:	e0bffe15 	stw	r2,-8(fp)
	nwds = b->_wds;
 4011028:	e0bff917 	ldw	r2,-28(fp)
 401102c:	10800417 	ldw	r2,16(r2)
 4011030:	e0bffd15 	stw	r2,-12(fp)
	n = k >> kshift;
 4011034:	e0bff817 	ldw	r2,-32(fp)
 4011038:	1005d17a 	srai	r2,r2,5
 401103c:	e0bfff15 	stw	r2,-4(fp)
	if (n > nwds)
 4011040:	e0bfff17 	ldw	r2,-4(fp)
 4011044:	e0fffd17 	ldw	r3,-12(fp)
 4011048:	1880030e 	bge	r3,r2,4011058 <__any_on+0x50>
		n = nwds;
 401104c:	e0bffd17 	ldw	r2,-12(fp)
 4011050:	e0bfff15 	stw	r2,-4(fp)
 4011054:	00001d06 	br	40110cc <__any_on+0xc4>
	else if (n < nwds && (k &= kmask)) {
 4011058:	e0ffff17 	ldw	r3,-4(fp)
 401105c:	e0bffd17 	ldw	r2,-12(fp)
 4011060:	18801a0e 	bge	r3,r2,40110cc <__any_on+0xc4>
 4011064:	e0bff817 	ldw	r2,-32(fp)
 4011068:	108007cc 	andi	r2,r2,31
 401106c:	e0bff815 	stw	r2,-32(fp)
 4011070:	e0bff817 	ldw	r2,-32(fp)
 4011074:	10001526 	beq	r2,zero,40110cc <__any_on+0xc4>
		x1 = x2 = x[n];
 4011078:	e0bfff17 	ldw	r2,-4(fp)
 401107c:	100490ba 	slli	r2,r2,2
 4011080:	e0fffe17 	ldw	r3,-8(fp)
 4011084:	1885883a 	add	r2,r3,r2
 4011088:	10800017 	ldw	r2,0(r2)
 401108c:	e0bffc15 	stw	r2,-16(fp)
 4011090:	e0bffc17 	ldw	r2,-16(fp)
 4011094:	e0bffb15 	stw	r2,-20(fp)
		x1 >>= k;
 4011098:	e0fffb17 	ldw	r3,-20(fp)
 401109c:	e0bff817 	ldw	r2,-32(fp)
 40110a0:	1884d83a 	srl	r2,r3,r2
 40110a4:	e0bffb15 	stw	r2,-20(fp)
		x1 <<= k;
 40110a8:	e0fffb17 	ldw	r3,-20(fp)
 40110ac:	e0bff817 	ldw	r2,-32(fp)
 40110b0:	1884983a 	sll	r2,r3,r2
 40110b4:	e0bffb15 	stw	r2,-20(fp)
		if (x1 != x2)
 40110b8:	e0fffb17 	ldw	r3,-20(fp)
 40110bc:	e0bffc17 	ldw	r2,-16(fp)
 40110c0:	18800226 	beq	r3,r2,40110cc <__any_on+0xc4>
			return 1;
 40110c4:	00800044 	movi	r2,1
 40110c8:	00001406 	br	401111c <__any_on+0x114>
		}
	x0 = x;
 40110cc:	e0bffe17 	ldw	r2,-8(fp)
 40110d0:	e0bffa15 	stw	r2,-24(fp)
	x += n;
 40110d4:	e0bfff17 	ldw	r2,-4(fp)
 40110d8:	100490ba 	slli	r2,r2,2
 40110dc:	e0fffe17 	ldw	r3,-8(fp)
 40110e0:	1885883a 	add	r2,r3,r2
 40110e4:	e0bffe15 	stw	r2,-8(fp)
	while(x > x0)
 40110e8:	00000806 	br	401110c <__any_on+0x104>
		if (*--x)
 40110ec:	e0bffe17 	ldw	r2,-8(fp)
 40110f0:	10bfff04 	addi	r2,r2,-4
 40110f4:	e0bffe15 	stw	r2,-8(fp)
 40110f8:	e0bffe17 	ldw	r2,-8(fp)
 40110fc:	10800017 	ldw	r2,0(r2)
 4011100:	10000226 	beq	r2,zero,401110c <__any_on+0x104>
			return 1;
 4011104:	00800044 	movi	r2,1
 4011108:	00000406 	br	401111c <__any_on+0x114>
	while(x > x0)
 401110c:	e0bffe17 	ldw	r2,-8(fp)
 4011110:	e0fffa17 	ldw	r3,-24(fp)
 4011114:	18bff536 	bltu	r3,r2,40110ec <__any_on+0xe4>
	return 0;
 4011118:	0005883a 	mov	r2,zero
}
 401111c:	e037883a 	mov	sp,fp
 4011120:	df000017 	ldw	fp,0(sp)
 4011124:	dec00104 	addi	sp,sp,4
 4011128:	f800283a 	ret

0401112c <_realloc_r>:
{
 401112c:	deffe104 	addi	sp,sp,-124
 4011130:	dfc01e15 	stw	ra,120(sp)
 4011134:	df001d15 	stw	fp,116(sp)
 4011138:	df001d04 	addi	fp,sp,116
 401113c:	e13fe515 	stw	r4,-108(fp)
 4011140:	e17fe415 	stw	r5,-112(fp)
 4011144:	e1bfe315 	stw	r6,-116(fp)
  if (oldmem == 0) return mALLOc(RCALL bytes);
 4011148:	e0bfe417 	ldw	r2,-112(fp)
 401114c:	1000041e 	bne	r2,zero,4011160 <_realloc_r+0x34>
 4011150:	e17fe317 	ldw	r5,-116(fp)
 4011154:	e13fe517 	ldw	r4,-108(fp)
 4011158:	400e5500 	call	400e550 <_malloc_r>
 401115c:	0002eb06 	br	4011d0c <_realloc_r+0xbe0>
  MALLOC_LOCK;
 4011160:	e13fe517 	ldw	r4,-108(fp)
 4011164:	40187b80 	call	40187b8 <__malloc_lock>
  newp    = oldp    = mem2chunk(oldmem);
 4011168:	e0bfe417 	ldw	r2,-112(fp)
 401116c:	10bffe04 	addi	r2,r2,-8
 4011170:	e0bff315 	stw	r2,-52(fp)
 4011174:	e0bff317 	ldw	r2,-52(fp)
 4011178:	e0bfff15 	stw	r2,-4(fp)
  newsize = oldsize = chunksize(oldp);
 401117c:	e0bff317 	ldw	r2,-52(fp)
 4011180:	10c00117 	ldw	r3,4(r2)
 4011184:	00bfff04 	movi	r2,-4
 4011188:	1884703a 	and	r2,r3,r2
 401118c:	e0bff215 	stw	r2,-56(fp)
 4011190:	e0bff217 	ldw	r2,-56(fp)
 4011194:	e0bffe15 	stw	r2,-8(fp)
  nb = request2size(bytes);
 4011198:	e0bfe317 	ldw	r2,-116(fp)
 401119c:	108002c4 	addi	r2,r2,11
 40111a0:	108005f0 	cmpltui	r2,r2,23
 40111a4:	1000051e 	bne	r2,zero,40111bc <_realloc_r+0x90>
 40111a8:	e0bfe317 	ldw	r2,-116(fp)
 40111ac:	10c002c4 	addi	r3,r2,11
 40111b0:	00bffe04 	movi	r2,-8
 40111b4:	1884703a 	and	r2,r3,r2
 40111b8:	00000106 	br	40111c0 <_realloc_r+0x94>
 40111bc:	00800404 	movi	r2,16
 40111c0:	e0bff115 	stw	r2,-60(fp)
  if (nb > INT_MAX || nb < bytes)
 40111c4:	e0bff117 	ldw	r2,-60(fp)
 40111c8:	10000316 	blt	r2,zero,40111d8 <_realloc_r+0xac>
 40111cc:	e0fff117 	ldw	r3,-60(fp)
 40111d0:	e0bfe317 	ldw	r2,-116(fp)
 40111d4:	1880052e 	bgeu	r3,r2,40111ec <_realloc_r+0xc0>
    RERRNO = ENOMEM;
 40111d8:	e0bfe517 	ldw	r2,-108(fp)
 40111dc:	00c00304 	movi	r3,12
 40111e0:	10c00015 	stw	r3,0(r2)
    return 0;
 40111e4:	0005883a 	mov	r2,zero
 40111e8:	0002c806 	br	4011d0c <_realloc_r+0xbe0>
  if ((long)(oldsize) < (long)(nb))  
 40111ec:	e0fff217 	ldw	r3,-56(fp)
 40111f0:	e0bff117 	ldw	r2,-60(fp)
 40111f4:	18828b0e 	bge	r3,r2,4011c24 <_realloc_r+0xaf8>
    next = chunk_at_offset(oldp, oldsize);
 40111f8:	e0fff317 	ldw	r3,-52(fp)
 40111fc:	e0bff217 	ldw	r2,-56(fp)
 4011200:	1885883a 	add	r2,r3,r2
 4011204:	e0bffd15 	stw	r2,-12(fp)
    if (next == top || !inuse(next)) 
 4011208:	008100b4 	movhi	r2,1026
 401120c:	10ae3304 	addi	r2,r2,-18228
 4011210:	10800217 	ldw	r2,8(r2)
 4011214:	e0fffd17 	ldw	r3,-12(fp)
 4011218:	18800926 	beq	r3,r2,4011240 <_realloc_r+0x114>
 401121c:	e0bffd17 	ldw	r2,-12(fp)
 4011220:	10c00117 	ldw	r3,4(r2)
 4011224:	00bfff84 	movi	r2,-2
 4011228:	1884703a 	and	r2,r3,r2
 401122c:	e0fffd17 	ldw	r3,-12(fp)
 4011230:	1885883a 	add	r2,r3,r2
 4011234:	10800117 	ldw	r2,4(r2)
 4011238:	1080004c 	andi	r2,r2,1
 401123c:	1000461e 	bne	r2,zero,4011358 <_realloc_r+0x22c>
      nextsize = chunksize(next);
 4011240:	e0bffd17 	ldw	r2,-12(fp)
 4011244:	10c00117 	ldw	r3,4(r2)
 4011248:	00bfff04 	movi	r2,-4
 401124c:	1884703a 	and	r2,r3,r2
 4011250:	e0bffc15 	stw	r2,-16(fp)
      if (next == top)
 4011254:	008100b4 	movhi	r2,1026
 4011258:	10ae3304 	addi	r2,r2,-18228
 401125c:	10800217 	ldw	r2,8(r2)
 4011260:	e0fffd17 	ldw	r3,-12(fp)
 4011264:	1880251e 	bne	r3,r2,40112fc <_realloc_r+0x1d0>
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
 4011268:	e0fffc17 	ldw	r3,-16(fp)
 401126c:	e0bffe17 	ldw	r2,-8(fp)
 4011270:	1885883a 	add	r2,r3,r2
 4011274:	1007883a 	mov	r3,r2
 4011278:	e0bff117 	ldw	r2,-60(fp)
 401127c:	10800404 	addi	r2,r2,16
 4011280:	18803816 	blt	r3,r2,4011364 <_realloc_r+0x238>
          newsize += nextsize;
 4011284:	e0fffe17 	ldw	r3,-8(fp)
 4011288:	e0bffc17 	ldw	r2,-16(fp)
 401128c:	1885883a 	add	r2,r3,r2
 4011290:	e0bffe15 	stw	r2,-8(fp)
          top = chunk_at_offset(oldp, nb);
 4011294:	008100b4 	movhi	r2,1026
 4011298:	10ae3304 	addi	r2,r2,-18228
 401129c:	e13ff317 	ldw	r4,-52(fp)
 40112a0:	e0fff117 	ldw	r3,-60(fp)
 40112a4:	20c7883a 	add	r3,r4,r3
 40112a8:	10c00215 	stw	r3,8(r2)
          set_head(top, (newsize - nb) | PREV_INUSE);
 40112ac:	e0fffe17 	ldw	r3,-8(fp)
 40112b0:	e0bff117 	ldw	r2,-60(fp)
 40112b4:	1887c83a 	sub	r3,r3,r2
 40112b8:	008100b4 	movhi	r2,1026
 40112bc:	10ae3304 	addi	r2,r2,-18228
 40112c0:	10800217 	ldw	r2,8(r2)
 40112c4:	18c00054 	ori	r3,r3,1
 40112c8:	10c00115 	stw	r3,4(r2)
          set_head_size(oldp, nb);
 40112cc:	e0bff317 	ldw	r2,-52(fp)
 40112d0:	10800117 	ldw	r2,4(r2)
 40112d4:	10c0004c 	andi	r3,r2,1
 40112d8:	e0bff117 	ldw	r2,-60(fp)
 40112dc:	1886b03a 	or	r3,r3,r2
 40112e0:	e0bff317 	ldw	r2,-52(fp)
 40112e4:	10c00115 	stw	r3,4(r2)
	  MALLOC_UNLOCK;
 40112e8:	e13fe517 	ldw	r4,-108(fp)
 40112ec:	40187dc0 	call	40187dc <__malloc_unlock>
          return chunk2mem(oldp);
 40112f0:	e0bff317 	ldw	r2,-52(fp)
 40112f4:	10800204 	addi	r2,r2,8
 40112f8:	00028406 	br	4011d0c <_realloc_r+0xbe0>
      else if (((long)(nextsize + newsize) >= (long)(nb)))
 40112fc:	e0fffc17 	ldw	r3,-16(fp)
 4011300:	e0bffe17 	ldw	r2,-8(fp)
 4011304:	1885883a 	add	r2,r3,r2
 4011308:	1007883a 	mov	r3,r2
 401130c:	e0bff117 	ldw	r2,-60(fp)
 4011310:	18801416 	blt	r3,r2,4011364 <_realloc_r+0x238>
        unlink(next, bck, fwd);
 4011314:	e0bffd17 	ldw	r2,-12(fp)
 4011318:	10800317 	ldw	r2,12(r2)
 401131c:	e0bff015 	stw	r2,-64(fp)
 4011320:	e0bffd17 	ldw	r2,-12(fp)
 4011324:	10800217 	ldw	r2,8(r2)
 4011328:	e0bfef15 	stw	r2,-68(fp)
 401132c:	e0bfef17 	ldw	r2,-68(fp)
 4011330:	e0fff017 	ldw	r3,-64(fp)
 4011334:	10c00315 	stw	r3,12(r2)
 4011338:	e0bff017 	ldw	r2,-64(fp)
 401133c:	e0ffef17 	ldw	r3,-68(fp)
 4011340:	10c00215 	stw	r3,8(r2)
        newsize  += nextsize;
 4011344:	e0fffe17 	ldw	r3,-8(fp)
 4011348:	e0bffc17 	ldw	r2,-16(fp)
 401134c:	1885883a 	add	r2,r3,r2
 4011350:	e0bffe15 	stw	r2,-8(fp)
        goto split;
 4011354:	00023406 	br	4011c28 <_realloc_r+0xafc>
      next = 0;
 4011358:	e03ffd15 	stw	zero,-12(fp)
      nextsize = 0;
 401135c:	e03ffc15 	stw	zero,-16(fp)
 4011360:	00000106 	br	4011368 <_realloc_r+0x23c>
      if (next == top)
 4011364:	0001883a 	nop
    if (!prev_inuse(oldp))
 4011368:	e0bff317 	ldw	r2,-52(fp)
 401136c:	10800117 	ldw	r2,4(r2)
 4011370:	1080004c 	andi	r2,r2,1
 4011374:	1001a91e 	bne	r2,zero,4011a1c <_realloc_r+0x8f0>
      prev = prev_chunk(oldp);
 4011378:	e0bff317 	ldw	r2,-52(fp)
 401137c:	10800017 	ldw	r2,0(r2)
 4011380:	0085c83a 	sub	r2,zero,r2
 4011384:	e0fff317 	ldw	r3,-52(fp)
 4011388:	1885883a 	add	r2,r3,r2
 401138c:	e0bfee15 	stw	r2,-72(fp)
      prevsize = chunksize(prev);
 4011390:	e0bfee17 	ldw	r2,-72(fp)
 4011394:	10c00117 	ldw	r3,4(r2)
 4011398:	00bfff04 	movi	r2,-4
 401139c:	1884703a 	and	r2,r3,r2
 40113a0:	e0bfed15 	stw	r2,-76(fp)
      if (next != 0)
 40113a4:	e0bffd17 	ldw	r2,-12(fp)
 40113a8:	10012226 	beq	r2,zero,4011834 <_realloc_r+0x708>
        if (next == top)
 40113ac:	008100b4 	movhi	r2,1026
 40113b0:	10ae3304 	addi	r2,r2,-18228
 40113b4:	10800217 	ldw	r2,8(r2)
 40113b8:	e0fffd17 	ldw	r3,-12(fp)
 40113bc:	1880951e 	bne	r3,r2,4011614 <_realloc_r+0x4e8>
          if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
 40113c0:	e0fffc17 	ldw	r3,-16(fp)
 40113c4:	e0bfed17 	ldw	r2,-76(fp)
 40113c8:	1887883a 	add	r3,r3,r2
 40113cc:	e0bffe17 	ldw	r2,-8(fp)
 40113d0:	1885883a 	add	r2,r3,r2
 40113d4:	1007883a 	mov	r3,r2
 40113d8:	e0bff117 	ldw	r2,-60(fp)
 40113dc:	10800404 	addi	r2,r2,16
 40113e0:	18811416 	blt	r3,r2,4011834 <_realloc_r+0x708>
            unlink(prev, bck, fwd);
 40113e4:	e0bfee17 	ldw	r2,-72(fp)
 40113e8:	10800317 	ldw	r2,12(r2)
 40113ec:	e0bff015 	stw	r2,-64(fp)
 40113f0:	e0bfee17 	ldw	r2,-72(fp)
 40113f4:	10800217 	ldw	r2,8(r2)
 40113f8:	e0bfef15 	stw	r2,-68(fp)
 40113fc:	e0bfef17 	ldw	r2,-68(fp)
 4011400:	e0fff017 	ldw	r3,-64(fp)
 4011404:	10c00315 	stw	r3,12(r2)
 4011408:	e0bff017 	ldw	r2,-64(fp)
 401140c:	e0ffef17 	ldw	r3,-68(fp)
 4011410:	10c00215 	stw	r3,8(r2)
            newp = prev;
 4011414:	e0bfee17 	ldw	r2,-72(fp)
 4011418:	e0bfff15 	stw	r2,-4(fp)
            newsize += prevsize + nextsize;
 401141c:	e0ffed17 	ldw	r3,-76(fp)
 4011420:	e0bffc17 	ldw	r2,-16(fp)
 4011424:	1885883a 	add	r2,r3,r2
 4011428:	e0fffe17 	ldw	r3,-8(fp)
 401142c:	1885883a 	add	r2,r3,r2
 4011430:	e0bffe15 	stw	r2,-8(fp)
            newmem = chunk2mem(newp);
 4011434:	e0bfff17 	ldw	r2,-4(fp)
 4011438:	10800204 	addi	r2,r2,8
 401143c:	e0bfec15 	stw	r2,-80(fp)
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
 4011440:	e0bff217 	ldw	r2,-56(fp)
 4011444:	10bfff04 	addi	r2,r2,-4
 4011448:	e0bfea15 	stw	r2,-88(fp)
 401144c:	e0bfea17 	ldw	r2,-88(fp)
 4011450:	10800968 	cmpgeui	r2,r2,37
 4011454:	1000521e 	bne	r2,zero,40115a0 <_realloc_r+0x474>
 4011458:	e0bfe417 	ldw	r2,-112(fp)
 401145c:	e0bffb15 	stw	r2,-20(fp)
 4011460:	e0bfec17 	ldw	r2,-80(fp)
 4011464:	e0bffa15 	stw	r2,-24(fp)
 4011468:	e0bfea17 	ldw	r2,-88(fp)
 401146c:	10800530 	cmpltui	r2,r2,20
 4011470:	1000361e 	bne	r2,zero,401154c <_realloc_r+0x420>
 4011474:	e0fffb17 	ldw	r3,-20(fp)
 4011478:	18800104 	addi	r2,r3,4
 401147c:	e0bffb15 	stw	r2,-20(fp)
 4011480:	e0bffa17 	ldw	r2,-24(fp)
 4011484:	11000104 	addi	r4,r2,4
 4011488:	e13ffa15 	stw	r4,-24(fp)
 401148c:	18c00017 	ldw	r3,0(r3)
 4011490:	10c00015 	stw	r3,0(r2)
 4011494:	e0fffb17 	ldw	r3,-20(fp)
 4011498:	18800104 	addi	r2,r3,4
 401149c:	e0bffb15 	stw	r2,-20(fp)
 40114a0:	e0bffa17 	ldw	r2,-24(fp)
 40114a4:	11000104 	addi	r4,r2,4
 40114a8:	e13ffa15 	stw	r4,-24(fp)
 40114ac:	18c00017 	ldw	r3,0(r3)
 40114b0:	10c00015 	stw	r3,0(r2)
 40114b4:	e0bfea17 	ldw	r2,-88(fp)
 40114b8:	10800730 	cmpltui	r2,r2,28
 40114bc:	1000231e 	bne	r2,zero,401154c <_realloc_r+0x420>
 40114c0:	e0fffb17 	ldw	r3,-20(fp)
 40114c4:	18800104 	addi	r2,r3,4
 40114c8:	e0bffb15 	stw	r2,-20(fp)
 40114cc:	e0bffa17 	ldw	r2,-24(fp)
 40114d0:	11000104 	addi	r4,r2,4
 40114d4:	e13ffa15 	stw	r4,-24(fp)
 40114d8:	18c00017 	ldw	r3,0(r3)
 40114dc:	10c00015 	stw	r3,0(r2)
 40114e0:	e0fffb17 	ldw	r3,-20(fp)
 40114e4:	18800104 	addi	r2,r3,4
 40114e8:	e0bffb15 	stw	r2,-20(fp)
 40114ec:	e0bffa17 	ldw	r2,-24(fp)
 40114f0:	11000104 	addi	r4,r2,4
 40114f4:	e13ffa15 	stw	r4,-24(fp)
 40114f8:	18c00017 	ldw	r3,0(r3)
 40114fc:	10c00015 	stw	r3,0(r2)
 4011500:	e0bfea17 	ldw	r2,-88(fp)
 4011504:	10800930 	cmpltui	r2,r2,36
 4011508:	1000101e 	bne	r2,zero,401154c <_realloc_r+0x420>
 401150c:	e0fffb17 	ldw	r3,-20(fp)
 4011510:	18800104 	addi	r2,r3,4
 4011514:	e0bffb15 	stw	r2,-20(fp)
 4011518:	e0bffa17 	ldw	r2,-24(fp)
 401151c:	11000104 	addi	r4,r2,4
 4011520:	e13ffa15 	stw	r4,-24(fp)
 4011524:	18c00017 	ldw	r3,0(r3)
 4011528:	10c00015 	stw	r3,0(r2)
 401152c:	e0fffb17 	ldw	r3,-20(fp)
 4011530:	18800104 	addi	r2,r3,4
 4011534:	e0bffb15 	stw	r2,-20(fp)
 4011538:	e0bffa17 	ldw	r2,-24(fp)
 401153c:	11000104 	addi	r4,r2,4
 4011540:	e13ffa15 	stw	r4,-24(fp)
 4011544:	18c00017 	ldw	r3,0(r3)
 4011548:	10c00015 	stw	r3,0(r2)
 401154c:	e0fffb17 	ldw	r3,-20(fp)
 4011550:	18800104 	addi	r2,r3,4
 4011554:	e0bffb15 	stw	r2,-20(fp)
 4011558:	e0bffa17 	ldw	r2,-24(fp)
 401155c:	11000104 	addi	r4,r2,4
 4011560:	e13ffa15 	stw	r4,-24(fp)
 4011564:	18c00017 	ldw	r3,0(r3)
 4011568:	10c00015 	stw	r3,0(r2)
 401156c:	e0fffb17 	ldw	r3,-20(fp)
 4011570:	18800104 	addi	r2,r3,4
 4011574:	e0bffb15 	stw	r2,-20(fp)
 4011578:	e0bffa17 	ldw	r2,-24(fp)
 401157c:	11000104 	addi	r4,r2,4
 4011580:	e13ffa15 	stw	r4,-24(fp)
 4011584:	18c00017 	ldw	r3,0(r3)
 4011588:	10c00015 	stw	r3,0(r2)
 401158c:	e0bffb17 	ldw	r2,-20(fp)
 4011590:	10c00017 	ldw	r3,0(r2)
 4011594:	e0bffa17 	ldw	r2,-24(fp)
 4011598:	10c00015 	stw	r3,0(r2)
 401159c:	00000406 	br	40115b0 <_realloc_r+0x484>
 40115a0:	e1bfea17 	ldw	r6,-88(fp)
 40115a4:	e17fe417 	ldw	r5,-112(fp)
 40115a8:	e13fec17 	ldw	r4,-80(fp)
 40115ac:	400f3ac0 	call	400f3ac <memmove>
            top = chunk_at_offset(newp, nb);
 40115b0:	008100b4 	movhi	r2,1026
 40115b4:	10ae3304 	addi	r2,r2,-18228
 40115b8:	e13fff17 	ldw	r4,-4(fp)
 40115bc:	e0fff117 	ldw	r3,-60(fp)
 40115c0:	20c7883a 	add	r3,r4,r3
 40115c4:	10c00215 	stw	r3,8(r2)
            set_head(top, (newsize - nb) | PREV_INUSE);
 40115c8:	e0fffe17 	ldw	r3,-8(fp)
 40115cc:	e0bff117 	ldw	r2,-60(fp)
 40115d0:	1887c83a 	sub	r3,r3,r2
 40115d4:	008100b4 	movhi	r2,1026
 40115d8:	10ae3304 	addi	r2,r2,-18228
 40115dc:	10800217 	ldw	r2,8(r2)
 40115e0:	18c00054 	ori	r3,r3,1
 40115e4:	10c00115 	stw	r3,4(r2)
            set_head_size(newp, nb);
 40115e8:	e0bfff17 	ldw	r2,-4(fp)
 40115ec:	10800117 	ldw	r2,4(r2)
 40115f0:	10c0004c 	andi	r3,r2,1
 40115f4:	e0bff117 	ldw	r2,-60(fp)
 40115f8:	1886b03a 	or	r3,r3,r2
 40115fc:	e0bfff17 	ldw	r2,-4(fp)
 4011600:	10c00115 	stw	r3,4(r2)
	    MALLOC_UNLOCK;
 4011604:	e13fe517 	ldw	r4,-108(fp)
 4011608:	40187dc0 	call	40187dc <__malloc_unlock>
            return newmem;
 401160c:	e0bfec17 	ldw	r2,-80(fp)
 4011610:	0001be06 	br	4011d0c <_realloc_r+0xbe0>
        else if (((long)(nextsize + prevsize + newsize) >= (long)(nb)))
 4011614:	e0fffc17 	ldw	r3,-16(fp)
 4011618:	e0bfed17 	ldw	r2,-76(fp)
 401161c:	1887883a 	add	r3,r3,r2
 4011620:	e0bffe17 	ldw	r2,-8(fp)
 4011624:	1885883a 	add	r2,r3,r2
 4011628:	1007883a 	mov	r3,r2
 401162c:	e0bff117 	ldw	r2,-60(fp)
 4011630:	18808016 	blt	r3,r2,4011834 <_realloc_r+0x708>
          unlink(next, bck, fwd);
 4011634:	e0bffd17 	ldw	r2,-12(fp)
 4011638:	10800317 	ldw	r2,12(r2)
 401163c:	e0bff015 	stw	r2,-64(fp)
 4011640:	e0bffd17 	ldw	r2,-12(fp)
 4011644:	10800217 	ldw	r2,8(r2)
 4011648:	e0bfef15 	stw	r2,-68(fp)
 401164c:	e0bfef17 	ldw	r2,-68(fp)
 4011650:	e0fff017 	ldw	r3,-64(fp)
 4011654:	10c00315 	stw	r3,12(r2)
 4011658:	e0bff017 	ldw	r2,-64(fp)
 401165c:	e0ffef17 	ldw	r3,-68(fp)
 4011660:	10c00215 	stw	r3,8(r2)
          unlink(prev, bck, fwd);
 4011664:	e0bfee17 	ldw	r2,-72(fp)
 4011668:	10800317 	ldw	r2,12(r2)
 401166c:	e0bff015 	stw	r2,-64(fp)
 4011670:	e0bfee17 	ldw	r2,-72(fp)
 4011674:	10800217 	ldw	r2,8(r2)
 4011678:	e0bfef15 	stw	r2,-68(fp)
 401167c:	e0bfef17 	ldw	r2,-68(fp)
 4011680:	e0fff017 	ldw	r3,-64(fp)
 4011684:	10c00315 	stw	r3,12(r2)
 4011688:	e0bff017 	ldw	r2,-64(fp)
 401168c:	e0ffef17 	ldw	r3,-68(fp)
 4011690:	10c00215 	stw	r3,8(r2)
          newp = prev;
 4011694:	e0bfee17 	ldw	r2,-72(fp)
 4011698:	e0bfff15 	stw	r2,-4(fp)
          newsize += nextsize + prevsize;
 401169c:	e0fffc17 	ldw	r3,-16(fp)
 40116a0:	e0bfed17 	ldw	r2,-76(fp)
 40116a4:	1885883a 	add	r2,r3,r2
 40116a8:	e0fffe17 	ldw	r3,-8(fp)
 40116ac:	1885883a 	add	r2,r3,r2
 40116b0:	e0bffe15 	stw	r2,-8(fp)
          newmem = chunk2mem(newp);
 40116b4:	e0bfff17 	ldw	r2,-4(fp)
 40116b8:	10800204 	addi	r2,r2,8
 40116bc:	e0bfec15 	stw	r2,-80(fp)
          MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
 40116c0:	e0bff217 	ldw	r2,-56(fp)
 40116c4:	10bfff04 	addi	r2,r2,-4
 40116c8:	e0bfeb15 	stw	r2,-84(fp)
 40116cc:	e0bfeb17 	ldw	r2,-84(fp)
 40116d0:	10800968 	cmpgeui	r2,r2,37
 40116d4:	1000521e 	bne	r2,zero,4011820 <_realloc_r+0x6f4>
 40116d8:	e0bfe417 	ldw	r2,-112(fp)
 40116dc:	e0bff915 	stw	r2,-28(fp)
 40116e0:	e0bfec17 	ldw	r2,-80(fp)
 40116e4:	e0bff815 	stw	r2,-32(fp)
 40116e8:	e0bfeb17 	ldw	r2,-84(fp)
 40116ec:	10800530 	cmpltui	r2,r2,20
 40116f0:	1000361e 	bne	r2,zero,40117cc <_realloc_r+0x6a0>
 40116f4:	e0fff917 	ldw	r3,-28(fp)
 40116f8:	18800104 	addi	r2,r3,4
 40116fc:	e0bff915 	stw	r2,-28(fp)
 4011700:	e0bff817 	ldw	r2,-32(fp)
 4011704:	11000104 	addi	r4,r2,4
 4011708:	e13ff815 	stw	r4,-32(fp)
 401170c:	18c00017 	ldw	r3,0(r3)
 4011710:	10c00015 	stw	r3,0(r2)
 4011714:	e0fff917 	ldw	r3,-28(fp)
 4011718:	18800104 	addi	r2,r3,4
 401171c:	e0bff915 	stw	r2,-28(fp)
 4011720:	e0bff817 	ldw	r2,-32(fp)
 4011724:	11000104 	addi	r4,r2,4
 4011728:	e13ff815 	stw	r4,-32(fp)
 401172c:	18c00017 	ldw	r3,0(r3)
 4011730:	10c00015 	stw	r3,0(r2)
 4011734:	e0bfeb17 	ldw	r2,-84(fp)
 4011738:	10800730 	cmpltui	r2,r2,28
 401173c:	1000231e 	bne	r2,zero,40117cc <_realloc_r+0x6a0>
 4011740:	e0fff917 	ldw	r3,-28(fp)
 4011744:	18800104 	addi	r2,r3,4
 4011748:	e0bff915 	stw	r2,-28(fp)
 401174c:	e0bff817 	ldw	r2,-32(fp)
 4011750:	11000104 	addi	r4,r2,4
 4011754:	e13ff815 	stw	r4,-32(fp)
 4011758:	18c00017 	ldw	r3,0(r3)
 401175c:	10c00015 	stw	r3,0(r2)
 4011760:	e0fff917 	ldw	r3,-28(fp)
 4011764:	18800104 	addi	r2,r3,4
 4011768:	e0bff915 	stw	r2,-28(fp)
 401176c:	e0bff817 	ldw	r2,-32(fp)
 4011770:	11000104 	addi	r4,r2,4
 4011774:	e13ff815 	stw	r4,-32(fp)
 4011778:	18c00017 	ldw	r3,0(r3)
 401177c:	10c00015 	stw	r3,0(r2)
 4011780:	e0bfeb17 	ldw	r2,-84(fp)
 4011784:	10800930 	cmpltui	r2,r2,36
 4011788:	1000101e 	bne	r2,zero,40117cc <_realloc_r+0x6a0>
 401178c:	e0fff917 	ldw	r3,-28(fp)
 4011790:	18800104 	addi	r2,r3,4
 4011794:	e0bff915 	stw	r2,-28(fp)
 4011798:	e0bff817 	ldw	r2,-32(fp)
 401179c:	11000104 	addi	r4,r2,4
 40117a0:	e13ff815 	stw	r4,-32(fp)
 40117a4:	18c00017 	ldw	r3,0(r3)
 40117a8:	10c00015 	stw	r3,0(r2)
 40117ac:	e0fff917 	ldw	r3,-28(fp)
 40117b0:	18800104 	addi	r2,r3,4
 40117b4:	e0bff915 	stw	r2,-28(fp)
 40117b8:	e0bff817 	ldw	r2,-32(fp)
 40117bc:	11000104 	addi	r4,r2,4
 40117c0:	e13ff815 	stw	r4,-32(fp)
 40117c4:	18c00017 	ldw	r3,0(r3)
 40117c8:	10c00015 	stw	r3,0(r2)
 40117cc:	e0fff917 	ldw	r3,-28(fp)
 40117d0:	18800104 	addi	r2,r3,4
 40117d4:	e0bff915 	stw	r2,-28(fp)
 40117d8:	e0bff817 	ldw	r2,-32(fp)
 40117dc:	11000104 	addi	r4,r2,4
 40117e0:	e13ff815 	stw	r4,-32(fp)
 40117e4:	18c00017 	ldw	r3,0(r3)
 40117e8:	10c00015 	stw	r3,0(r2)
 40117ec:	e0fff917 	ldw	r3,-28(fp)
 40117f0:	18800104 	addi	r2,r3,4
 40117f4:	e0bff915 	stw	r2,-28(fp)
 40117f8:	e0bff817 	ldw	r2,-32(fp)
 40117fc:	11000104 	addi	r4,r2,4
 4011800:	e13ff815 	stw	r4,-32(fp)
 4011804:	18c00017 	ldw	r3,0(r3)
 4011808:	10c00015 	stw	r3,0(r2)
 401180c:	e0bff917 	ldw	r2,-28(fp)
 4011810:	10c00017 	ldw	r3,0(r2)
 4011814:	e0bff817 	ldw	r2,-32(fp)
 4011818:	10c00015 	stw	r3,0(r2)
          goto split;
 401181c:	00010206 	br	4011c28 <_realloc_r+0xafc>
          MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
 4011820:	e1bfeb17 	ldw	r6,-84(fp)
 4011824:	e17fe417 	ldw	r5,-112(fp)
 4011828:	e13fec17 	ldw	r4,-80(fp)
 401182c:	400f3ac0 	call	400f3ac <memmove>
          goto split;
 4011830:	0000fd06 	br	4011c28 <_realloc_r+0xafc>
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
 4011834:	e0bfee17 	ldw	r2,-72(fp)
 4011838:	10007826 	beq	r2,zero,4011a1c <_realloc_r+0x8f0>
 401183c:	e0ffed17 	ldw	r3,-76(fp)
 4011840:	e0bffe17 	ldw	r2,-8(fp)
 4011844:	1885883a 	add	r2,r3,r2
 4011848:	1007883a 	mov	r3,r2
 401184c:	e0bff117 	ldw	r2,-60(fp)
 4011850:	18807216 	blt	r3,r2,4011a1c <_realloc_r+0x8f0>
        unlink(prev, bck, fwd);
 4011854:	e0bfee17 	ldw	r2,-72(fp)
 4011858:	10800317 	ldw	r2,12(r2)
 401185c:	e0bff015 	stw	r2,-64(fp)
 4011860:	e0bfee17 	ldw	r2,-72(fp)
 4011864:	10800217 	ldw	r2,8(r2)
 4011868:	e0bfef15 	stw	r2,-68(fp)
 401186c:	e0bfef17 	ldw	r2,-68(fp)
 4011870:	e0fff017 	ldw	r3,-64(fp)
 4011874:	10c00315 	stw	r3,12(r2)
 4011878:	e0bff017 	ldw	r2,-64(fp)
 401187c:	e0ffef17 	ldw	r3,-68(fp)
 4011880:	10c00215 	stw	r3,8(r2)
        newp = prev;
 4011884:	e0bfee17 	ldw	r2,-72(fp)
 4011888:	e0bfff15 	stw	r2,-4(fp)
        newsize += prevsize;
 401188c:	e0fffe17 	ldw	r3,-8(fp)
 4011890:	e0bfed17 	ldw	r2,-76(fp)
 4011894:	1885883a 	add	r2,r3,r2
 4011898:	e0bffe15 	stw	r2,-8(fp)
        newmem = chunk2mem(newp);
 401189c:	e0bfff17 	ldw	r2,-4(fp)
 40118a0:	10800204 	addi	r2,r2,8
 40118a4:	e0bfec15 	stw	r2,-80(fp)
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
 40118a8:	e0bff217 	ldw	r2,-56(fp)
 40118ac:	10bfff04 	addi	r2,r2,-4
 40118b0:	e0bfe915 	stw	r2,-92(fp)
 40118b4:	e0bfe917 	ldw	r2,-92(fp)
 40118b8:	10800968 	cmpgeui	r2,r2,37
 40118bc:	1000521e 	bne	r2,zero,4011a08 <_realloc_r+0x8dc>
 40118c0:	e0bfe417 	ldw	r2,-112(fp)
 40118c4:	e0bff715 	stw	r2,-36(fp)
 40118c8:	e0bfec17 	ldw	r2,-80(fp)
 40118cc:	e0bff615 	stw	r2,-40(fp)
 40118d0:	e0bfe917 	ldw	r2,-92(fp)
 40118d4:	10800530 	cmpltui	r2,r2,20
 40118d8:	1000361e 	bne	r2,zero,40119b4 <_realloc_r+0x888>
 40118dc:	e0fff717 	ldw	r3,-36(fp)
 40118e0:	18800104 	addi	r2,r3,4
 40118e4:	e0bff715 	stw	r2,-36(fp)
 40118e8:	e0bff617 	ldw	r2,-40(fp)
 40118ec:	11000104 	addi	r4,r2,4
 40118f0:	e13ff615 	stw	r4,-40(fp)
 40118f4:	18c00017 	ldw	r3,0(r3)
 40118f8:	10c00015 	stw	r3,0(r2)
 40118fc:	e0fff717 	ldw	r3,-36(fp)
 4011900:	18800104 	addi	r2,r3,4
 4011904:	e0bff715 	stw	r2,-36(fp)
 4011908:	e0bff617 	ldw	r2,-40(fp)
 401190c:	11000104 	addi	r4,r2,4
 4011910:	e13ff615 	stw	r4,-40(fp)
 4011914:	18c00017 	ldw	r3,0(r3)
 4011918:	10c00015 	stw	r3,0(r2)
 401191c:	e0bfe917 	ldw	r2,-92(fp)
 4011920:	10800730 	cmpltui	r2,r2,28
 4011924:	1000231e 	bne	r2,zero,40119b4 <_realloc_r+0x888>
 4011928:	e0fff717 	ldw	r3,-36(fp)
 401192c:	18800104 	addi	r2,r3,4
 4011930:	e0bff715 	stw	r2,-36(fp)
 4011934:	e0bff617 	ldw	r2,-40(fp)
 4011938:	11000104 	addi	r4,r2,4
 401193c:	e13ff615 	stw	r4,-40(fp)
 4011940:	18c00017 	ldw	r3,0(r3)
 4011944:	10c00015 	stw	r3,0(r2)
 4011948:	e0fff717 	ldw	r3,-36(fp)
 401194c:	18800104 	addi	r2,r3,4
 4011950:	e0bff715 	stw	r2,-36(fp)
 4011954:	e0bff617 	ldw	r2,-40(fp)
 4011958:	11000104 	addi	r4,r2,4
 401195c:	e13ff615 	stw	r4,-40(fp)
 4011960:	18c00017 	ldw	r3,0(r3)
 4011964:	10c00015 	stw	r3,0(r2)
 4011968:	e0bfe917 	ldw	r2,-92(fp)
 401196c:	10800930 	cmpltui	r2,r2,36
 4011970:	1000101e 	bne	r2,zero,40119b4 <_realloc_r+0x888>
 4011974:	e0fff717 	ldw	r3,-36(fp)
 4011978:	18800104 	addi	r2,r3,4
 401197c:	e0bff715 	stw	r2,-36(fp)
 4011980:	e0bff617 	ldw	r2,-40(fp)
 4011984:	11000104 	addi	r4,r2,4
 4011988:	e13ff615 	stw	r4,-40(fp)
 401198c:	18c00017 	ldw	r3,0(r3)
 4011990:	10c00015 	stw	r3,0(r2)
 4011994:	e0fff717 	ldw	r3,-36(fp)
 4011998:	18800104 	addi	r2,r3,4
 401199c:	e0bff715 	stw	r2,-36(fp)
 40119a0:	e0bff617 	ldw	r2,-40(fp)
 40119a4:	11000104 	addi	r4,r2,4
 40119a8:	e13ff615 	stw	r4,-40(fp)
 40119ac:	18c00017 	ldw	r3,0(r3)
 40119b0:	10c00015 	stw	r3,0(r2)
 40119b4:	e0fff717 	ldw	r3,-36(fp)
 40119b8:	18800104 	addi	r2,r3,4
 40119bc:	e0bff715 	stw	r2,-36(fp)
 40119c0:	e0bff617 	ldw	r2,-40(fp)
 40119c4:	11000104 	addi	r4,r2,4
 40119c8:	e13ff615 	stw	r4,-40(fp)
 40119cc:	18c00017 	ldw	r3,0(r3)
 40119d0:	10c00015 	stw	r3,0(r2)
 40119d4:	e0fff717 	ldw	r3,-36(fp)
 40119d8:	18800104 	addi	r2,r3,4
 40119dc:	e0bff715 	stw	r2,-36(fp)
 40119e0:	e0bff617 	ldw	r2,-40(fp)
 40119e4:	11000104 	addi	r4,r2,4
 40119e8:	e13ff615 	stw	r4,-40(fp)
 40119ec:	18c00017 	ldw	r3,0(r3)
 40119f0:	10c00015 	stw	r3,0(r2)
 40119f4:	e0bff717 	ldw	r2,-36(fp)
 40119f8:	10c00017 	ldw	r3,0(r2)
 40119fc:	e0bff617 	ldw	r2,-40(fp)
 4011a00:	10c00015 	stw	r3,0(r2)
        goto split;
 4011a04:	00008806 	br	4011c28 <_realloc_r+0xafc>
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
 4011a08:	e1bfe917 	ldw	r6,-92(fp)
 4011a0c:	e17fe417 	ldw	r5,-112(fp)
 4011a10:	e13fec17 	ldw	r4,-80(fp)
 4011a14:	400f3ac0 	call	400f3ac <memmove>
        goto split;
 4011a18:	00008306 	br	4011c28 <_realloc_r+0xafc>
    newmem = mALLOc (RCALL bytes);
 4011a1c:	e17fe317 	ldw	r5,-116(fp)
 4011a20:	e13fe517 	ldw	r4,-108(fp)
 4011a24:	400e5500 	call	400e550 <_malloc_r>
 4011a28:	e0bfec15 	stw	r2,-80(fp)
    if (newmem == 0)  /* propagate failure */
 4011a2c:	e0bfec17 	ldw	r2,-80(fp)
 4011a30:	1000041e 	bne	r2,zero,4011a44 <_realloc_r+0x918>
      MALLOC_UNLOCK;
 4011a34:	e13fe517 	ldw	r4,-108(fp)
 4011a38:	40187dc0 	call	40187dc <__malloc_unlock>
      return 0;
 4011a3c:	0005883a 	mov	r2,zero
 4011a40:	0000b206 	br	4011d0c <_realloc_r+0xbe0>
    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp)) 
 4011a44:	e0bfec17 	ldw	r2,-80(fp)
 4011a48:	10bffe04 	addi	r2,r2,-8
 4011a4c:	e0bfff15 	stw	r2,-4(fp)
 4011a50:	e0bff317 	ldw	r2,-52(fp)
 4011a54:	10c00117 	ldw	r3,4(r2)
 4011a58:	00bfff84 	movi	r2,-2
 4011a5c:	1884703a 	and	r2,r3,r2
 4011a60:	e0fff317 	ldw	r3,-52(fp)
 4011a64:	1885883a 	add	r2,r3,r2
 4011a68:	e0ffff17 	ldw	r3,-4(fp)
 4011a6c:	18800a1e 	bne	r3,r2,4011a98 <_realloc_r+0x96c>
      newsize += chunksize(newp);
 4011a70:	e0bfff17 	ldw	r2,-4(fp)
 4011a74:	10c00117 	ldw	r3,4(r2)
 4011a78:	00bfff04 	movi	r2,-4
 4011a7c:	1884703a 	and	r2,r3,r2
 4011a80:	e0fffe17 	ldw	r3,-8(fp)
 4011a84:	1885883a 	add	r2,r3,r2
 4011a88:	e0bffe15 	stw	r2,-8(fp)
      newp = oldp;
 4011a8c:	e0bff317 	ldw	r2,-52(fp)
 4011a90:	e0bfff15 	stw	r2,-4(fp)
      goto split;
 4011a94:	00006406 	br	4011c28 <_realloc_r+0xafc>
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
 4011a98:	e0bff217 	ldw	r2,-56(fp)
 4011a9c:	10bfff04 	addi	r2,r2,-4
 4011aa0:	e0bfe815 	stw	r2,-96(fp)
 4011aa4:	e0bfe817 	ldw	r2,-96(fp)
 4011aa8:	10800968 	cmpgeui	r2,r2,37
 4011aac:	1000521e 	bne	r2,zero,4011bf8 <_realloc_r+0xacc>
 4011ab0:	e0bfe417 	ldw	r2,-112(fp)
 4011ab4:	e0bff515 	stw	r2,-44(fp)
 4011ab8:	e0bfec17 	ldw	r2,-80(fp)
 4011abc:	e0bff415 	stw	r2,-48(fp)
 4011ac0:	e0bfe817 	ldw	r2,-96(fp)
 4011ac4:	10800530 	cmpltui	r2,r2,20
 4011ac8:	1000361e 	bne	r2,zero,4011ba4 <_realloc_r+0xa78>
 4011acc:	e0fff517 	ldw	r3,-44(fp)
 4011ad0:	18800104 	addi	r2,r3,4
 4011ad4:	e0bff515 	stw	r2,-44(fp)
 4011ad8:	e0bff417 	ldw	r2,-48(fp)
 4011adc:	11000104 	addi	r4,r2,4
 4011ae0:	e13ff415 	stw	r4,-48(fp)
 4011ae4:	18c00017 	ldw	r3,0(r3)
 4011ae8:	10c00015 	stw	r3,0(r2)
 4011aec:	e0fff517 	ldw	r3,-44(fp)
 4011af0:	18800104 	addi	r2,r3,4
 4011af4:	e0bff515 	stw	r2,-44(fp)
 4011af8:	e0bff417 	ldw	r2,-48(fp)
 4011afc:	11000104 	addi	r4,r2,4
 4011b00:	e13ff415 	stw	r4,-48(fp)
 4011b04:	18c00017 	ldw	r3,0(r3)
 4011b08:	10c00015 	stw	r3,0(r2)
 4011b0c:	e0bfe817 	ldw	r2,-96(fp)
 4011b10:	10800730 	cmpltui	r2,r2,28
 4011b14:	1000231e 	bne	r2,zero,4011ba4 <_realloc_r+0xa78>
 4011b18:	e0fff517 	ldw	r3,-44(fp)
 4011b1c:	18800104 	addi	r2,r3,4
 4011b20:	e0bff515 	stw	r2,-44(fp)
 4011b24:	e0bff417 	ldw	r2,-48(fp)
 4011b28:	11000104 	addi	r4,r2,4
 4011b2c:	e13ff415 	stw	r4,-48(fp)
 4011b30:	18c00017 	ldw	r3,0(r3)
 4011b34:	10c00015 	stw	r3,0(r2)
 4011b38:	e0fff517 	ldw	r3,-44(fp)
 4011b3c:	18800104 	addi	r2,r3,4
 4011b40:	e0bff515 	stw	r2,-44(fp)
 4011b44:	e0bff417 	ldw	r2,-48(fp)
 4011b48:	11000104 	addi	r4,r2,4
 4011b4c:	e13ff415 	stw	r4,-48(fp)
 4011b50:	18c00017 	ldw	r3,0(r3)
 4011b54:	10c00015 	stw	r3,0(r2)
 4011b58:	e0bfe817 	ldw	r2,-96(fp)
 4011b5c:	10800930 	cmpltui	r2,r2,36
 4011b60:	1000101e 	bne	r2,zero,4011ba4 <_realloc_r+0xa78>
 4011b64:	e0fff517 	ldw	r3,-44(fp)
 4011b68:	18800104 	addi	r2,r3,4
 4011b6c:	e0bff515 	stw	r2,-44(fp)
 4011b70:	e0bff417 	ldw	r2,-48(fp)
 4011b74:	11000104 	addi	r4,r2,4
 4011b78:	e13ff415 	stw	r4,-48(fp)
 4011b7c:	18c00017 	ldw	r3,0(r3)
 4011b80:	10c00015 	stw	r3,0(r2)
 4011b84:	e0fff517 	ldw	r3,-44(fp)
 4011b88:	18800104 	addi	r2,r3,4
 4011b8c:	e0bff515 	stw	r2,-44(fp)
 4011b90:	e0bff417 	ldw	r2,-48(fp)
 4011b94:	11000104 	addi	r4,r2,4
 4011b98:	e13ff415 	stw	r4,-48(fp)
 4011b9c:	18c00017 	ldw	r3,0(r3)
 4011ba0:	10c00015 	stw	r3,0(r2)
 4011ba4:	e0fff517 	ldw	r3,-44(fp)
 4011ba8:	18800104 	addi	r2,r3,4
 4011bac:	e0bff515 	stw	r2,-44(fp)
 4011bb0:	e0bff417 	ldw	r2,-48(fp)
 4011bb4:	11000104 	addi	r4,r2,4
 4011bb8:	e13ff415 	stw	r4,-48(fp)
 4011bbc:	18c00017 	ldw	r3,0(r3)
 4011bc0:	10c00015 	stw	r3,0(r2)
 4011bc4:	e0fff517 	ldw	r3,-44(fp)
 4011bc8:	18800104 	addi	r2,r3,4
 4011bcc:	e0bff515 	stw	r2,-44(fp)
 4011bd0:	e0bff417 	ldw	r2,-48(fp)
 4011bd4:	11000104 	addi	r4,r2,4
 4011bd8:	e13ff415 	stw	r4,-48(fp)
 4011bdc:	18c00017 	ldw	r3,0(r3)
 4011be0:	10c00015 	stw	r3,0(r2)
 4011be4:	e0bff517 	ldw	r2,-44(fp)
 4011be8:	10c00017 	ldw	r3,0(r2)
 4011bec:	e0bff417 	ldw	r2,-48(fp)
 4011bf0:	10c00015 	stw	r3,0(r2)
 4011bf4:	00000406 	br	4011c08 <_realloc_r+0xadc>
 4011bf8:	e1bfe817 	ldw	r6,-96(fp)
 4011bfc:	e17fe417 	ldw	r5,-112(fp)
 4011c00:	e13fec17 	ldw	r4,-80(fp)
 4011c04:	400f3ac0 	call	400f3ac <memmove>
    fREe(RCALL oldmem);
 4011c08:	e17fe417 	ldw	r5,-112(fp)
 4011c0c:	e13fe517 	ldw	r4,-108(fp)
 4011c10:	400cdd80 	call	400cdd8 <_free_r>
    MALLOC_UNLOCK;
 4011c14:	e13fe517 	ldw	r4,-108(fp)
 4011c18:	40187dc0 	call	40187dc <__malloc_unlock>
    return newmem;
 4011c1c:	e0bfec17 	ldw	r2,-80(fp)
 4011c20:	00003a06 	br	4011d0c <_realloc_r+0xbe0>
 split:  /* split off extra room in old or expanded chunk */
 4011c24:	0001883a 	nop
  remainder_size = long_sub_size_t(newsize, nb);
 4011c28:	e0fffe17 	ldw	r3,-8(fp)
 4011c2c:	e0bff117 	ldw	r2,-60(fp)
 4011c30:	1885c83a 	sub	r2,r3,r2
 4011c34:	e0bfe715 	stw	r2,-100(fp)
  if (remainder_size >= (long)MINSIZE) /* split off remainder */
 4011c38:	e0bfe717 	ldw	r2,-100(fp)
 4011c3c:	10800430 	cmpltui	r2,r2,16
 4011c40:	10001e1e 	bne	r2,zero,4011cbc <_realloc_r+0xb90>
    remainder = chunk_at_offset(newp, nb);
 4011c44:	e0ffff17 	ldw	r3,-4(fp)
 4011c48:	e0bff117 	ldw	r2,-60(fp)
 4011c4c:	1885883a 	add	r2,r3,r2
 4011c50:	e0bfe615 	stw	r2,-104(fp)
    set_head_size(newp, nb);
 4011c54:	e0bfff17 	ldw	r2,-4(fp)
 4011c58:	10800117 	ldw	r2,4(r2)
 4011c5c:	10c0004c 	andi	r3,r2,1
 4011c60:	e0bff117 	ldw	r2,-60(fp)
 4011c64:	1886b03a 	or	r3,r3,r2
 4011c68:	e0bfff17 	ldw	r2,-4(fp)
 4011c6c:	10c00115 	stw	r3,4(r2)
    set_head(remainder, remainder_size | PREV_INUSE);
 4011c70:	e0bfe717 	ldw	r2,-100(fp)
 4011c74:	10c00054 	ori	r3,r2,1
 4011c78:	e0bfe617 	ldw	r2,-104(fp)
 4011c7c:	10c00115 	stw	r3,4(r2)
    set_inuse_bit_at_offset(remainder, remainder_size);
 4011c80:	e0ffe617 	ldw	r3,-104(fp)
 4011c84:	e0bfe717 	ldw	r2,-100(fp)
 4011c88:	1885883a 	add	r2,r3,r2
 4011c8c:	10c00117 	ldw	r3,4(r2)
 4011c90:	e13fe617 	ldw	r4,-104(fp)
 4011c94:	e0bfe717 	ldw	r2,-100(fp)
 4011c98:	2085883a 	add	r2,r4,r2
 4011c9c:	18c00054 	ori	r3,r3,1
 4011ca0:	10c00115 	stw	r3,4(r2)
    fREe(RCALL chunk2mem(remainder)); /* let free() deal with it */
 4011ca4:	e0bfe617 	ldw	r2,-104(fp)
 4011ca8:	10800204 	addi	r2,r2,8
 4011cac:	100b883a 	mov	r5,r2
 4011cb0:	e13fe517 	ldw	r4,-108(fp)
 4011cb4:	400cdd80 	call	400cdd8 <_free_r>
 4011cb8:	00001006 	br	4011cfc <_realloc_r+0xbd0>
    set_head_size(newp, newsize);
 4011cbc:	e0bfff17 	ldw	r2,-4(fp)
 4011cc0:	10800117 	ldw	r2,4(r2)
 4011cc4:	10c0004c 	andi	r3,r2,1
 4011cc8:	e0bffe17 	ldw	r2,-8(fp)
 4011ccc:	1886b03a 	or	r3,r3,r2
 4011cd0:	e0bfff17 	ldw	r2,-4(fp)
 4011cd4:	10c00115 	stw	r3,4(r2)
    set_inuse_bit_at_offset(newp, newsize);
 4011cd8:	e0ffff17 	ldw	r3,-4(fp)
 4011cdc:	e0bffe17 	ldw	r2,-8(fp)
 4011ce0:	1885883a 	add	r2,r3,r2
 4011ce4:	10c00117 	ldw	r3,4(r2)
 4011ce8:	e13fff17 	ldw	r4,-4(fp)
 4011cec:	e0bffe17 	ldw	r2,-8(fp)
 4011cf0:	2085883a 	add	r2,r4,r2
 4011cf4:	18c00054 	ori	r3,r3,1
 4011cf8:	10c00115 	stw	r3,4(r2)
  MALLOC_UNLOCK;
 4011cfc:	e13fe517 	ldw	r4,-108(fp)
 4011d00:	40187dc0 	call	40187dc <__malloc_unlock>
  return chunk2mem(newp);
 4011d04:	e0bfff17 	ldw	r2,-4(fp)
 4011d08:	10800204 	addi	r2,r2,8
}
 4011d0c:	e037883a 	mov	sp,fp
 4011d10:	dfc00117 	ldw	ra,4(sp)
 4011d14:	df000017 	ldw	fp,0(sp)
 4011d18:	dec00204 	addi	sp,sp,8
 4011d1c:	f800283a 	ret

04011d20 <_sbrk_r>:
*/

void *
_sbrk_r (struct _reent *ptr,
     ptrdiff_t incr)
{
 4011d20:	defffb04 	addi	sp,sp,-20
 4011d24:	dfc00415 	stw	ra,16(sp)
 4011d28:	df000315 	stw	fp,12(sp)
 4011d2c:	df000304 	addi	fp,sp,12
 4011d30:	e13ffe15 	stw	r4,-8(fp)
 4011d34:	e17ffd15 	stw	r5,-12(fp)
  char *ret;
  void *_sbrk(ptrdiff_t);

  errno = 0;
 4011d38:	d0272915 	stw	zero,-25436(gp)
  if ((ret = (char *)(_sbrk (incr))) == (void *) -1 && errno != 0)
 4011d3c:	e13ffd17 	ldw	r4,-12(fp)
 4011d40:	40189b40 	call	40189b4 <sbrk>
 4011d44:	e0bfff15 	stw	r2,-4(fp)
 4011d48:	e0bfff17 	ldw	r2,-4(fp)
 4011d4c:	10bfffd8 	cmpnei	r2,r2,-1
 4011d50:	1000051e 	bne	r2,zero,4011d68 <_sbrk_r+0x48>
 4011d54:	d0a72917 	ldw	r2,-25436(gp)
 4011d58:	10000326 	beq	r2,zero,4011d68 <_sbrk_r+0x48>
    ptr->_errno = errno;
 4011d5c:	d0e72917 	ldw	r3,-25436(gp)
 4011d60:	e0bffe17 	ldw	r2,-8(fp)
 4011d64:	10c00015 	stw	r3,0(r2)
  return ret;
 4011d68:	e0bfff17 	ldw	r2,-4(fp)
}
 4011d6c:	e037883a 	mov	sp,fp
 4011d70:	dfc00117 	ldw	ra,4(sp)
 4011d74:	df000017 	ldw	fp,0(sp)
 4011d78:	dec00204 	addi	sp,sp,8
 4011d7c:	f800283a 	ret

04011d80 <__sread>:
_READ_WRITE_RETURN_TYPE
__sread (struct _reent *ptr,
       void *cookie,
       char *buf,
       _READ_WRITE_BUFSIZE_TYPE n)
{
 4011d80:	defff804 	addi	sp,sp,-32
 4011d84:	dfc00715 	stw	ra,28(sp)
 4011d88:	df000615 	stw	fp,24(sp)
 4011d8c:	dc400515 	stw	r17,20(sp)
 4011d90:	dc000415 	stw	r16,16(sp)
 4011d94:	df000604 	addi	fp,sp,24
 4011d98:	e13ffd15 	stw	r4,-12(fp)
 4011d9c:	e17ffc15 	stw	r5,-16(fp)
 4011da0:	e1bffb15 	stw	r6,-20(fp)
 4011da4:	e1fffa15 	stw	r7,-24(fp)
  register FILE *fp = (FILE *) cookie;
 4011da8:	e43ffc17 	ldw	r16,-16(fp)
  int oldmode = 0;
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  ret = _read_r (ptr, fp->_file, buf, n);
 4011dac:	8080038b 	ldhu	r2,14(r16)
 4011db0:	10bfffcc 	andi	r2,r2,65535
 4011db4:	10a0001c 	xori	r2,r2,32768
 4011db8:	10a00004 	addi	r2,r2,-32768
 4011dbc:	e0fffa17 	ldw	r3,-24(fp)
 4011dc0:	180f883a 	mov	r7,r3
 4011dc4:	e1bffb17 	ldw	r6,-20(fp)
 4011dc8:	100b883a 	mov	r5,r2
 4011dcc:	e13ffd17 	ldw	r4,-12(fp)
 4011dd0:	40140800 	call	4014080 <_read_r>
 4011dd4:	1023883a 	mov	r17,r2
    setmode (fp->_file, oldmode);
#endif

  /* If the read succeeded, update the current offset.  */

  if (ret >= 0)
 4011dd8:	88000416 	blt	r17,zero,4011dec <__sread+0x6c>
    fp->_offset += ret;
 4011ddc:	80801417 	ldw	r2,80(r16)
 4011de0:	8885883a 	add	r2,r17,r2
 4011de4:	80801415 	stw	r2,80(r16)
 4011de8:	00000406 	br	4011dfc <__sread+0x7c>
  else
    fp->_flags &= ~__SOFF;	/* paranoia */
 4011dec:	80c0030b 	ldhu	r3,12(r16)
 4011df0:	00bbffc4 	movi	r2,-4097
 4011df4:	1884703a 	and	r2,r3,r2
 4011df8:	8080030d 	sth	r2,12(r16)
  return ret;
 4011dfc:	8805883a 	mov	r2,r17
}
 4011e00:	e6fffe04 	addi	sp,fp,-8
 4011e04:	dfc00317 	ldw	ra,12(sp)
 4011e08:	df000217 	ldw	fp,8(sp)
 4011e0c:	dc400117 	ldw	r17,4(sp)
 4011e10:	dc000017 	ldw	r16,0(sp)
 4011e14:	dec00404 	addi	sp,sp,16
 4011e18:	f800283a 	ret

04011e1c <__seofread>:
_READ_WRITE_RETURN_TYPE
__seofread (struct _reent *_ptr,
       void *cookie,
       char *buf,
       _READ_WRITE_BUFSIZE_TYPE len)
{
 4011e1c:	defffb04 	addi	sp,sp,-20
 4011e20:	df000415 	stw	fp,16(sp)
 4011e24:	df000404 	addi	fp,sp,16
 4011e28:	e13fff15 	stw	r4,-4(fp)
 4011e2c:	e17ffe15 	stw	r5,-8(fp)
 4011e30:	e1bffd15 	stw	r6,-12(fp)
 4011e34:	e1fffc15 	stw	r7,-16(fp)
  return 0;
 4011e38:	0005883a 	mov	r2,zero
}
 4011e3c:	e037883a 	mov	sp,fp
 4011e40:	df000017 	ldw	fp,0(sp)
 4011e44:	dec00104 	addi	sp,sp,4
 4011e48:	f800283a 	ret

04011e4c <__swrite>:
_READ_WRITE_RETURN_TYPE
__swrite (struct _reent *ptr,
       void *cookie,
       char const *buf,
       _READ_WRITE_BUFSIZE_TYPE n)
{
 4011e4c:	defff804 	addi	sp,sp,-32
 4011e50:	dfc00715 	stw	ra,28(sp)
 4011e54:	df000615 	stw	fp,24(sp)
 4011e58:	dc000515 	stw	r16,20(sp)
 4011e5c:	df000604 	addi	fp,sp,24
 4011e60:	e13ffd15 	stw	r4,-12(fp)
 4011e64:	e17ffc15 	stw	r5,-16(fp)
 4011e68:	e1bffb15 	stw	r6,-20(fp)
 4011e6c:	e1fffa15 	stw	r7,-24(fp)
  register FILE *fp = (FILE *) cookie;
 4011e70:	e43ffc17 	ldw	r16,-16(fp)
  ssize_t w;
#ifdef __SCLE
  int oldmode=0;
#endif

  if (fp->_flags & __SAPP)
 4011e74:	8080030b 	ldhu	r2,12(r16)
 4011e78:	10bfffcc 	andi	r2,r2,65535
 4011e7c:	1080400c 	andi	r2,r2,256
 4011e80:	10000926 	beq	r2,zero,4011ea8 <__swrite+0x5c>
    _lseek_r (ptr, fp->_file, (_off_t) 0, SEEK_END);
 4011e84:	8080038b 	ldhu	r2,14(r16)
 4011e88:	10bfffcc 	andi	r2,r2,65535
 4011e8c:	10a0001c 	xori	r2,r2,32768
 4011e90:	10a00004 	addi	r2,r2,-32768
 4011e94:	01c00084 	movi	r7,2
 4011e98:	000d883a 	mov	r6,zero
 4011e9c:	100b883a 	mov	r5,r2
 4011ea0:	e13ffd17 	ldw	r4,-12(fp)
 4011ea4:	40140100 	call	4014010 <_lseek_r>
  fp->_flags &= ~__SOFF;	/* in case O_APPEND mode is set */
 4011ea8:	80c0030b 	ldhu	r3,12(r16)
 4011eac:	00bbffc4 	movi	r2,-4097
 4011eb0:	1884703a 	and	r2,r3,r2
 4011eb4:	8080030d 	sth	r2,12(r16)
#ifdef __SCLE
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  w = _write_r (ptr, fp->_file, buf, n);
 4011eb8:	8080038b 	ldhu	r2,14(r16)
 4011ebc:	10bfffcc 	andi	r2,r2,65535
 4011ec0:	10a0001c 	xori	r2,r2,32768
 4011ec4:	10a00004 	addi	r2,r2,-32768
 4011ec8:	e0fffa17 	ldw	r3,-24(fp)
 4011ecc:	180f883a 	mov	r7,r3
 4011ed0:	e1bffb17 	ldw	r6,-20(fp)
 4011ed4:	100b883a 	mov	r5,r2
 4011ed8:	e13ffd17 	ldw	r4,-12(fp)
 4011edc:	40137780 	call	4013778 <_write_r>
 4011ee0:	e0bffe15 	stw	r2,-8(fp)
#ifdef __SCLE
  if (oldmode)
    setmode (fp->_file, oldmode);
#endif

  return w;
 4011ee4:	e0bffe17 	ldw	r2,-8(fp)
}
 4011ee8:	e6ffff04 	addi	sp,fp,-4
 4011eec:	dfc00217 	ldw	ra,8(sp)
 4011ef0:	df000117 	ldw	fp,4(sp)
 4011ef4:	dc000017 	ldw	r16,0(sp)
 4011ef8:	dec00304 	addi	sp,sp,12
 4011efc:	f800283a 	ret

04011f00 <__sseek>:
_fpos_t
__sseek (struct _reent *ptr,
       void *cookie,
       _fpos_t offset,
       int whence)
{
 4011f00:	defff804 	addi	sp,sp,-32
 4011f04:	dfc00715 	stw	ra,28(sp)
 4011f08:	df000615 	stw	fp,24(sp)
 4011f0c:	dc400515 	stw	r17,20(sp)
 4011f10:	dc000415 	stw	r16,16(sp)
 4011f14:	df000604 	addi	fp,sp,24
 4011f18:	e13ffd15 	stw	r4,-12(fp)
 4011f1c:	e17ffc15 	stw	r5,-16(fp)
 4011f20:	e1bffb15 	stw	r6,-20(fp)
 4011f24:	e1fffa15 	stw	r7,-24(fp)
  register FILE *fp = (FILE *) cookie;
 4011f28:	e43ffc17 	ldw	r16,-16(fp)
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
 4011f2c:	8080038b 	ldhu	r2,14(r16)
 4011f30:	10bfffcc 	andi	r2,r2,65535
 4011f34:	10a0001c 	xori	r2,r2,32768
 4011f38:	10a00004 	addi	r2,r2,-32768
 4011f3c:	e1fffa17 	ldw	r7,-24(fp)
 4011f40:	e1bffb17 	ldw	r6,-20(fp)
 4011f44:	100b883a 	mov	r5,r2
 4011f48:	e13ffd17 	ldw	r4,-12(fp)
 4011f4c:	40140100 	call	4014010 <_lseek_r>
 4011f50:	1023883a 	mov	r17,r2
  if (ret == -1L)
 4011f54:	88bfffd8 	cmpnei	r2,r17,-1
 4011f58:	1000051e 	bne	r2,zero,4011f70 <__sseek+0x70>
    fp->_flags &= ~__SOFF;
 4011f5c:	80c0030b 	ldhu	r3,12(r16)
 4011f60:	00bbffc4 	movi	r2,-4097
 4011f64:	1884703a 	and	r2,r3,r2
 4011f68:	8080030d 	sth	r2,12(r16)
 4011f6c:	00000406 	br	4011f80 <__sseek+0x80>
  else
    {
      fp->_flags |= __SOFF;
 4011f70:	8080030b 	ldhu	r2,12(r16)
 4011f74:	10840014 	ori	r2,r2,4096
 4011f78:	8080030d 	sth	r2,12(r16)
      fp->_offset = ret;
 4011f7c:	84401415 	stw	r17,80(r16)
    }
  return ret;
 4011f80:	8805883a 	mov	r2,r17
}
 4011f84:	e6fffe04 	addi	sp,fp,-8
 4011f88:	dfc00317 	ldw	ra,12(sp)
 4011f8c:	df000217 	ldw	fp,8(sp)
 4011f90:	dc400117 	ldw	r17,4(sp)
 4011f94:	dc000017 	ldw	r16,0(sp)
 4011f98:	dec00404 	addi	sp,sp,16
 4011f9c:	f800283a 	ret

04011fa0 <__sclose>:

int
__sclose (struct _reent *ptr,
       void *cookie)
{
 4011fa0:	defffb04 	addi	sp,sp,-20
 4011fa4:	dfc00415 	stw	ra,16(sp)
 4011fa8:	df000315 	stw	fp,12(sp)
 4011fac:	df000304 	addi	fp,sp,12
 4011fb0:	e13ffe15 	stw	r4,-8(fp)
 4011fb4:	e17ffd15 	stw	r5,-12(fp)
  FILE *fp = (FILE *) cookie;
 4011fb8:	e0bffd17 	ldw	r2,-12(fp)
 4011fbc:	e0bfff15 	stw	r2,-4(fp)

  return _close_r (ptr, fp->_file);
 4011fc0:	e0bfff17 	ldw	r2,-4(fp)
 4011fc4:	1080038b 	ldhu	r2,14(r2)
 4011fc8:	10bfffcc 	andi	r2,r2,65535
 4011fcc:	10a0001c 	xori	r2,r2,32768
 4011fd0:	10a00004 	addi	r2,r2,-32768
 4011fd4:	100b883a 	mov	r5,r2
 4011fd8:	e13ffe17 	ldw	r4,-8(fp)
 4011fdc:	40137e80 	call	40137e8 <_close_r>
}
 4011fe0:	e037883a 	mov	sp,fp
 4011fe4:	dfc00117 	ldw	ra,4(sp)
 4011fe8:	df000017 	ldw	fp,0(sp)
 4011fec:	dec00204 	addi	sp,sp,8
 4011ff0:	f800283a 	ret

04011ff4 <strcmp>:
#endif

int
strcmp (const char *s1,
	const char *s2)
{ 
 4011ff4:	defffb04 	addi	sp,sp,-20
 4011ff8:	df000415 	stw	fp,16(sp)
 4011ffc:	df000404 	addi	fp,sp,16
 4012000:	e13ffd15 	stw	r4,-12(fp)
 4012004:	e17ffc15 	stw	r5,-16(fp)
#else
  unsigned long *a1;
  unsigned long *a2;

  /* If s1 or s2 are unaligned, then compare bytes. */
  if (!UNALIGNED (s1, s2))
 4012008:	e0fffd17 	ldw	r3,-12(fp)
 401200c:	e0bffc17 	ldw	r2,-16(fp)
 4012010:	1884b03a 	or	r2,r3,r2
 4012014:	108000cc 	andi	r2,r2,3
 4012018:	10002a1e 	bne	r2,zero,40120c4 <strcmp+0xd0>
    {  
      /* If s1 and s2 are word-aligned, compare them a word at a time. */
      a1 = (unsigned long*)s1;
 401201c:	e0bffd17 	ldw	r2,-12(fp)
 4012020:	e0bfff15 	stw	r2,-4(fp)
      a2 = (unsigned long*)s2;
 4012024:	e0bffc17 	ldw	r2,-16(fp)
 4012028:	e0bffe15 	stw	r2,-8(fp)
      while (*a1 == *a2)
 401202c:	00001506 	br	4012084 <strcmp+0x90>
        {
          /* To get here, *a1 == *a2, thus if we find a null in *a1,
	     then the strings must be equal, so return zero.  */
          if (DETECTNULL (*a1))
 4012030:	e0bfff17 	ldw	r2,-4(fp)
 4012034:	10c00017 	ldw	r3,0(r2)
 4012038:	00bfbff4 	movhi	r2,65279
 401203c:	10bfbfc4 	addi	r2,r2,-257
 4012040:	1887883a 	add	r3,r3,r2
 4012044:	e0bfff17 	ldw	r2,-4(fp)
 4012048:	10800017 	ldw	r2,0(r2)
 401204c:	0084303a 	nor	r2,zero,r2
 4012050:	1886703a 	and	r3,r3,r2
 4012054:	00a02074 	movhi	r2,32897
 4012058:	10a02004 	addi	r2,r2,-32640
 401205c:	1884703a 	and	r2,r3,r2
 4012060:	10000226 	beq	r2,zero,401206c <strcmp+0x78>
	    return 0;
 4012064:	0005883a 	mov	r2,zero
 4012068:	00002e06 	br	4012124 <strcmp+0x130>

          a1++;
 401206c:	e0bfff17 	ldw	r2,-4(fp)
 4012070:	10800104 	addi	r2,r2,4
 4012074:	e0bfff15 	stw	r2,-4(fp)
          a2++;
 4012078:	e0bffe17 	ldw	r2,-8(fp)
 401207c:	10800104 	addi	r2,r2,4
 4012080:	e0bffe15 	stw	r2,-8(fp)
      while (*a1 == *a2)
 4012084:	e0bfff17 	ldw	r2,-4(fp)
 4012088:	10c00017 	ldw	r3,0(r2)
 401208c:	e0bffe17 	ldw	r2,-8(fp)
 4012090:	10800017 	ldw	r2,0(r2)
 4012094:	18bfe626 	beq	r3,r2,4012030 <strcmp+0x3c>
        }

      /* A difference was detected in last few bytes of s1, so search bytewise */
      s1 = (char*)a1;
 4012098:	e0bfff17 	ldw	r2,-4(fp)
 401209c:	e0bffd15 	stw	r2,-12(fp)
      s2 = (char*)a2;
 40120a0:	e0bffe17 	ldw	r2,-8(fp)
 40120a4:	e0bffc15 	stw	r2,-16(fp)
    }

  while (*s1 != '\0' && *s1 == *s2)
 40120a8:	00000606 	br	40120c4 <strcmp+0xd0>
    {
      s1++;
 40120ac:	e0bffd17 	ldw	r2,-12(fp)
 40120b0:	10800044 	addi	r2,r2,1
 40120b4:	e0bffd15 	stw	r2,-12(fp)
      s2++;
 40120b8:	e0bffc17 	ldw	r2,-16(fp)
 40120bc:	10800044 	addi	r2,r2,1
 40120c0:	e0bffc15 	stw	r2,-16(fp)
  while (*s1 != '\0' && *s1 == *s2)
 40120c4:	e0bffd17 	ldw	r2,-12(fp)
 40120c8:	10800003 	ldbu	r2,0(r2)
 40120cc:	10803fcc 	andi	r2,r2,255
 40120d0:	1080201c 	xori	r2,r2,128
 40120d4:	10bfe004 	addi	r2,r2,-128
 40120d8:	10000b26 	beq	r2,zero,4012108 <strcmp+0x114>
 40120dc:	e0bffd17 	ldw	r2,-12(fp)
 40120e0:	10c00003 	ldbu	r3,0(r2)
 40120e4:	e0bffc17 	ldw	r2,-16(fp)
 40120e8:	10800003 	ldbu	r2,0(r2)
 40120ec:	18c03fcc 	andi	r3,r3,255
 40120f0:	18c0201c 	xori	r3,r3,128
 40120f4:	18ffe004 	addi	r3,r3,-128
 40120f8:	10803fcc 	andi	r2,r2,255
 40120fc:	1080201c 	xori	r2,r2,128
 4012100:	10bfe004 	addi	r2,r2,-128
 4012104:	18bfe926 	beq	r3,r2,40120ac <strcmp+0xb8>
    }
  return (*(unsigned char *) s1) - (*(unsigned char *) s2);
 4012108:	e0bffd17 	ldw	r2,-12(fp)
 401210c:	10800003 	ldbu	r2,0(r2)
 4012110:	10c03fcc 	andi	r3,r2,255
 4012114:	e0bffc17 	ldw	r2,-16(fp)
 4012118:	10800003 	ldbu	r2,0(r2)
 401211c:	10803fcc 	andi	r2,r2,255
 4012120:	1885c83a 	sub	r2,r3,r2
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 4012124:	e037883a 	mov	sp,fp
 4012128:	df000017 	ldw	fp,0(sp)
 401212c:	dec00104 	addi	sp,sp,4
 4012130:	f800283a 	ret

04012134 <__sprint_r>:
{
 4012134:	defff604 	addi	sp,sp,-40
 4012138:	dfc00915 	stw	ra,36(sp)
 401213c:	df000815 	stw	fp,32(sp)
 4012140:	dc400715 	stw	r17,28(sp)
 4012144:	dc000615 	stw	r16,24(sp)
 4012148:	df000804 	addi	fp,sp,32
 401214c:	e13ff915 	stw	r4,-28(fp)
 4012150:	e17ff815 	stw	r5,-32(fp)
 4012154:	3021883a 	mov	r16,r6
	register int err = 0;
 4012158:	0023883a 	mov	r17,zero
	if (uio->uio_resid == 0) {
 401215c:	80800217 	ldw	r2,8(r16)
 4012160:	1000031e 	bne	r2,zero,4012170 <__sprint_r+0x3c>
		uio->uio_iovcnt = 0;
 4012164:	80000115 	stw	zero,4(r16)
		return (0);
 4012168:	0005883a 	mov	r2,zero
 401216c:	00003606 	br	4012248 <__sprint_r+0x114>
	if (fp->_flags2 & __SWID) {
 4012170:	e0bff817 	ldw	r2,-32(fp)
 4012174:	10801917 	ldw	r2,100(r2)
 4012178:	1088000c 	andi	r2,r2,8192
 401217c:	10002a26 	beq	r2,zero,4012228 <__sprint_r+0xf4>
		iov = uio->uio_iov;
 4012180:	80800017 	ldw	r2,0(r16)
 4012184:	e0bffd15 	stw	r2,-12(fp)
		for (; uio->uio_resid != 0;
 4012188:	00002406 	br	401221c <__sprint_r+0xe8>
			p = (wchar_t *) iov->iov_base;
 401218c:	e0bffd17 	ldw	r2,-12(fp)
 4012190:	10800017 	ldw	r2,0(r2)
 4012194:	e0bffb15 	stw	r2,-20(fp)
			len = iov->iov_len / sizeof (wchar_t);
 4012198:	e0bffd17 	ldw	r2,-12(fp)
 401219c:	10800117 	ldw	r2,4(r2)
 40121a0:	1004d0ba 	srli	r2,r2,2
 40121a4:	e0bffa15 	stw	r2,-24(fp)
			for (i = 0; i < len; i++) {
 40121a8:	e03ffc15 	stw	zero,-16(fp)
 40121ac:	00001006 	br	40121f0 <__sprint_r+0xbc>
				if (_fputwc_r (ptr, p[i], fp) == WEOF) {
 40121b0:	e0bffc17 	ldw	r2,-16(fp)
 40121b4:	100490ba 	slli	r2,r2,2
 40121b8:	e0fffb17 	ldw	r3,-20(fp)
 40121bc:	1885883a 	add	r2,r3,r2
 40121c0:	10800017 	ldw	r2,0(r2)
 40121c4:	e1bff817 	ldw	r6,-32(fp)
 40121c8:	100b883a 	mov	r5,r2
 40121cc:	e13ff917 	ldw	r4,-28(fp)
 40121d0:	4013e580 	call	4013e58 <_fputwc_r>
 40121d4:	10bfffd8 	cmpnei	r2,r2,-1
 40121d8:	1000021e 	bne	r2,zero,40121e4 <__sprint_r+0xb0>
					err = -1;
 40121dc:	047fffc4 	movi	r17,-1
					goto out;
 40121e0:	00001606 	br	401223c <__sprint_r+0x108>
			for (i = 0; i < len; i++) {
 40121e4:	e0bffc17 	ldw	r2,-16(fp)
 40121e8:	10800044 	addi	r2,r2,1
 40121ec:	e0bffc15 	stw	r2,-16(fp)
 40121f0:	e0fffc17 	ldw	r3,-16(fp)
 40121f4:	e0bffa17 	ldw	r2,-24(fp)
 40121f8:	18bfed16 	blt	r3,r2,40121b0 <__sprint_r+0x7c>
		     uio->uio_resid -= len * sizeof (wchar_t), iov++) {
 40121fc:	80c00217 	ldw	r3,8(r16)
 4012200:	e0bffa17 	ldw	r2,-24(fp)
 4012204:	100490ba 	slli	r2,r2,2
 4012208:	1885c83a 	sub	r2,r3,r2
 401220c:	80800215 	stw	r2,8(r16)
 4012210:	e0bffd17 	ldw	r2,-12(fp)
 4012214:	10800204 	addi	r2,r2,8
 4012218:	e0bffd15 	stw	r2,-12(fp)
		for (; uio->uio_resid != 0;
 401221c:	80800217 	ldw	r2,8(r16)
 4012220:	103fda1e 	bne	r2,zero,401218c <__sprint_r+0x58>
 4012224:	00000506 	br	401223c <__sprint_r+0x108>
		err = __sfvwrite_r(ptr, fp, uio);
 4012228:	800d883a 	mov	r6,r16
 401222c:	e17ff817 	ldw	r5,-32(fp)
 4012230:	e13ff917 	ldw	r4,-28(fp)
 4012234:	400d4f40 	call	400d4f4 <__sfvwrite_r>
 4012238:	1023883a 	mov	r17,r2
	uio->uio_resid = 0;
 401223c:	80000215 	stw	zero,8(r16)
	uio->uio_iovcnt = 0;
 4012240:	80000115 	stw	zero,4(r16)
	return (err);
 4012244:	8805883a 	mov	r2,r17
}
 4012248:	e6fffe04 	addi	sp,fp,-8
 401224c:	dfc00317 	ldw	ra,12(sp)
 4012250:	df000217 	ldw	fp,8(sp)
 4012254:	dc400117 	ldw	r17,4(sp)
 4012258:	dc000017 	ldw	r16,0(sp)
 401225c:	dec00404 	addi	sp,sp,16
 4012260:	f800283a 	ret

04012264 <__sbprintf>:
{
 4012264:	defedf04 	addi	sp,sp,-1156
 4012268:	dfc12015 	stw	ra,1152(sp)
 401226c:	df011f15 	stw	fp,1148(sp)
 4012270:	dc011e15 	stw	r16,1144(sp)
 4012274:	df011f04 	addi	fp,sp,1148
 4012278:	e13ee315 	stw	r4,-1140(fp)
 401227c:	2821883a 	mov	r16,r5
 4012280:	e1bee215 	stw	r6,-1144(fp)
 4012284:	e1fee115 	stw	r7,-1148(fp)
	fake._flags = fp->_flags & ~__SNBF;
 4012288:	80c0030b 	ldhu	r3,12(r16)
 401228c:	00bfff44 	movi	r2,-3
 4012290:	1884703a 	and	r2,r3,r2
 4012294:	e0bfe70d 	sth	r2,-100(fp)
	fake._flags2 = fp->_flags2;
 4012298:	80801917 	ldw	r2,100(r16)
 401229c:	e0bffd15 	stw	r2,-12(fp)
	fake._file = fp->_file;
 40122a0:	8080038b 	ldhu	r2,14(r16)
 40122a4:	e0bfe78d 	sth	r2,-98(fp)
	fake._cookie = fp->_cookie;
 40122a8:	80800717 	ldw	r2,28(r16)
 40122ac:	e0bfeb15 	stw	r2,-84(fp)
	fake._write = fp->_write;
 40122b0:	80800917 	ldw	r2,36(r16)
 40122b4:	e0bfed15 	stw	r2,-76(fp)
	fake._bf._base = fake._p = buf;
 40122b8:	e0bee404 	addi	r2,fp,-1136
 40122bc:	e0bfe415 	stw	r2,-112(fp)
 40122c0:	e0bfe417 	ldw	r2,-112(fp)
 40122c4:	e0bfe815 	stw	r2,-96(fp)
	fake._bf._size = fake._w = sizeof (buf);
 40122c8:	00810004 	movi	r2,1024
 40122cc:	e0bfe615 	stw	r2,-104(fp)
 40122d0:	e0bfe617 	ldw	r2,-104(fp)
 40122d4:	e0bfe915 	stw	r2,-92(fp)
	fake._lbfsize = 0;	/* not actually used, but Just In Case */
 40122d8:	e03fea15 	stw	zero,-88(fp)
	ret = _VFPRINTF_R (rptr, &fake, fmt, ap);
 40122dc:	e0bfe404 	addi	r2,fp,-112
 40122e0:	e1fee117 	ldw	r7,-1148(fp)
 40122e4:	e1bee217 	ldw	r6,-1144(fp)
 40122e8:	100b883a 	mov	r5,r2
 40122ec:	e13ee317 	ldw	r4,-1140(fp)
 40122f0:	40123a40 	call	40123a4 <___vfiprintf_internal_r>
 40122f4:	e0bffe15 	stw	r2,-8(fp)
	if (ret >= 0 && _fflush_r (rptr, &fake))
 40122f8:	e0bffe17 	ldw	r2,-8(fp)
 40122fc:	10000716 	blt	r2,zero,401231c <__sbprintf+0xb8>
 4012300:	e0bfe404 	addi	r2,fp,-112
 4012304:	100b883a 	mov	r5,r2
 4012308:	e13ee317 	ldw	r4,-1140(fp)
 401230c:	400c6940 	call	400c694 <_fflush_r>
 4012310:	10000226 	beq	r2,zero,401231c <__sbprintf+0xb8>
		ret = EOF;
 4012314:	00bfffc4 	movi	r2,-1
 4012318:	e0bffe15 	stw	r2,-8(fp)
	if (fake._flags & __SERR)
 401231c:	e0bfe70b 	ldhu	r2,-100(fp)
 4012320:	10bfffcc 	andi	r2,r2,65535
 4012324:	1080100c 	andi	r2,r2,64
 4012328:	10000326 	beq	r2,zero,4012338 <__sbprintf+0xd4>
		fp->_flags |= __SERR;
 401232c:	8080030b 	ldhu	r2,12(r16)
 4012330:	10801014 	ori	r2,r2,64
 4012334:	8080030d 	sth	r2,12(r16)
	return (ret);
 4012338:	e0bffe17 	ldw	r2,-8(fp)
}
 401233c:	e6ffff04 	addi	sp,fp,-4
 4012340:	dfc00217 	ldw	ra,8(sp)
 4012344:	df000117 	ldw	fp,4(sp)
 4012348:	dc000017 	ldw	r16,0(sp)
 401234c:	dec00304 	addi	sp,sp,12
 4012350:	f800283a 	ret

04012354 <__vfiprintf_internal>:
{
 4012354:	defffa04 	addi	sp,sp,-24
 4012358:	dfc00515 	stw	ra,20(sp)
 401235c:	df000415 	stw	fp,16(sp)
 4012360:	df000404 	addi	fp,sp,16
 4012364:	e13ffe15 	stw	r4,-8(fp)
 4012368:	e17ffd15 	stw	r5,-12(fp)
 401236c:	e1bffc15 	stw	r6,-16(fp)
  result = _VFPRINTF_R (_REENT, fp, fmt0, ap);
 4012370:	d0a00117 	ldw	r2,-32764(gp)
 4012374:	e1fffc17 	ldw	r7,-16(fp)
 4012378:	e1bffd17 	ldw	r6,-12(fp)
 401237c:	e17ffe17 	ldw	r5,-8(fp)
 4012380:	1009883a 	mov	r4,r2
 4012384:	40123a40 	call	40123a4 <___vfiprintf_internal_r>
 4012388:	e0bfff15 	stw	r2,-4(fp)
  return result;
 401238c:	e0bfff17 	ldw	r2,-4(fp)
}
 4012390:	e037883a 	mov	sp,fp
 4012394:	dfc00117 	ldw	ra,4(sp)
 4012398:	df000017 	ldw	fp,0(sp)
 401239c:	dec00204 	addi	sp,sp,8
 40123a0:	f800283a 	ret

040123a4 <___vfiprintf_internal_r>:
{
 40123a4:	deffbd04 	addi	sp,sp,-268
 40123a8:	dfc04215 	stw	ra,264(sp)
 40123ac:	df004115 	stw	fp,260(sp)
 40123b0:	ddc04015 	stw	r23,256(sp)
 40123b4:	dd803f15 	stw	r22,252(sp)
 40123b8:	dd403e15 	stw	r21,248(sp)
 40123bc:	dd003d15 	stw	r20,244(sp)
 40123c0:	dcc03c15 	stw	r19,240(sp)
 40123c4:	dc803b15 	stw	r18,236(sp)
 40123c8:	dc403a15 	stw	r17,232(sp)
 40123cc:	dc003915 	stw	r16,228(sp)
 40123d0:	df004104 	addi	fp,sp,260
 40123d4:	e13fca15 	stw	r4,-216(fp)
 40123d8:	e17fc915 	stw	r5,-220(fp)
 40123dc:	e1bfc815 	stw	r6,-224(fp)
 40123e0:	e1ffc715 	stw	r7,-228(fp)
	char *xdigs = NULL;	/* digits for [xX] conversion */
 40123e4:	e03fee15 	stw	zero,-72(fp)
	char *malloc_buf = NULL;/* handy pointer for malloced buffers */
 40123e8:	e03fed15 	stw	zero,-76(fp)
	CHECK_INIT (data, fp);
 40123ec:	e0bfca17 	ldw	r2,-216(fp)
 40123f0:	e0bfec15 	stw	r2,-80(fp)
 40123f4:	e0bfec17 	ldw	r2,-80(fp)
 40123f8:	10000526 	beq	r2,zero,4012410 <___vfiprintf_internal_r+0x6c>
 40123fc:	e0bfec17 	ldw	r2,-80(fp)
 4012400:	10800e17 	ldw	r2,56(r2)
 4012404:	1000021e 	bne	r2,zero,4012410 <___vfiprintf_internal_r+0x6c>
 4012408:	e13fec17 	ldw	r4,-80(fp)
 401240c:	400cbdc0 	call	400cbdc <__sinit>
	ORIENT(fp, -1);
 4012410:	e0bfc917 	ldw	r2,-220(fp)
 4012414:	1080030b 	ldhu	r2,12(r2)
 4012418:	10bfffcc 	andi	r2,r2,65535
 401241c:	1088000c 	andi	r2,r2,8192
 4012420:	10000c1e 	bne	r2,zero,4012454 <___vfiprintf_internal_r+0xb0>
 4012424:	e0bfc917 	ldw	r2,-220(fp)
 4012428:	1080030b 	ldhu	r2,12(r2)
 401242c:	10880014 	ori	r2,r2,8192
 4012430:	1007883a 	mov	r3,r2
 4012434:	e0bfc917 	ldw	r2,-220(fp)
 4012438:	10c0030d 	sth	r3,12(r2)
 401243c:	e0bfc917 	ldw	r2,-220(fp)
 4012440:	10c01917 	ldw	r3,100(r2)
 4012444:	00b7ffc4 	movi	r2,-8193
 4012448:	1886703a 	and	r3,r3,r2
 401244c:	e0bfc917 	ldw	r2,-220(fp)
 4012450:	10c01915 	stw	r3,100(r2)
	if (cantwrite (data, fp)) {
 4012454:	e0bfc917 	ldw	r2,-220(fp)
 4012458:	1080030b 	ldhu	r2,12(r2)
 401245c:	10bfffcc 	andi	r2,r2,65535
 4012460:	1080020c 	andi	r2,r2,8
 4012464:	10000326 	beq	r2,zero,4012474 <___vfiprintf_internal_r+0xd0>
 4012468:	e0bfc917 	ldw	r2,-220(fp)
 401246c:	10800417 	ldw	r2,16(r2)
 4012470:	1000061e 	bne	r2,zero,401248c <___vfiprintf_internal_r+0xe8>
 4012474:	e17fc917 	ldw	r5,-220(fp)
 4012478:	e13fca17 	ldw	r4,-216(fp)
 401247c:	400a2180 	call	400a218 <__swsetup_r>
 4012480:	10000226 	beq	r2,zero,401248c <___vfiprintf_internal_r+0xe8>
		return (EOF);
 4012484:	00bfffc4 	movi	r2,-1
 4012488:	00046906 	br	4013630 <___vfiprintf_internal_r+0x128c>
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
 401248c:	e0bfc917 	ldw	r2,-220(fp)
 4012490:	1080030b 	ldhu	r2,12(r2)
 4012494:	10bfffcc 	andi	r2,r2,65535
 4012498:	1080068c 	andi	r2,r2,26
 401249c:	10800298 	cmpnei	r2,r2,10
 40124a0:	10000d1e 	bne	r2,zero,40124d8 <___vfiprintf_internal_r+0x134>
	    fp->_file >= 0) {
 40124a4:	e0bfc917 	ldw	r2,-220(fp)
 40124a8:	1080038b 	ldhu	r2,14(r2)
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
 40124ac:	10bfffcc 	andi	r2,r2,65535
 40124b0:	10a0001c 	xori	r2,r2,32768
 40124b4:	10a00004 	addi	r2,r2,-32768
 40124b8:	10000716 	blt	r2,zero,40124d8 <___vfiprintf_internal_r+0x134>
		return (__sbprintf (data, fp, fmt0, ap));
 40124bc:	e0bfc717 	ldw	r2,-228(fp)
 40124c0:	100f883a 	mov	r7,r2
 40124c4:	e1bfc817 	ldw	r6,-224(fp)
 40124c8:	e17fc917 	ldw	r5,-220(fp)
 40124cc:	e13fca17 	ldw	r4,-216(fp)
 40124d0:	40122640 	call	4012264 <__sbprintf>
 40124d4:	00045606 	br	4013630 <___vfiprintf_internal_r+0x128c>
	fmt = (char *)fmt0;
 40124d8:	e53fc817 	ldw	r20,-224(fp)
	uio.uio_iov = iovp = iov;
 40124dc:	e43fd604 	addi	r16,fp,-168
 40124e0:	e43fe615 	stw	r16,-104(fp)
	uio.uio_resid = 0;
 40124e4:	e03fe815 	stw	zero,-96(fp)
	uio.uio_iovcnt = 0;
 40124e8:	e03fe715 	stw	zero,-100(fp)
	ret = 0;
 40124ec:	e03ff715 	stw	zero,-36(fp)
	        cp = fmt;
 40124f0:	a025883a 	mov	r18,r20
                while (*fmt != '\0' && *fmt != '%')
 40124f4:	00000106 	br	40124fc <___vfiprintf_internal_r+0x158>
                    fmt += 1;
 40124f8:	a5000044 	addi	r20,r20,1
                while (*fmt != '\0' && *fmt != '%')
 40124fc:	a0800003 	ldbu	r2,0(r20)
 4012500:	10803fcc 	andi	r2,r2,255
 4012504:	1080201c 	xori	r2,r2,128
 4012508:	10bfe004 	addi	r2,r2,-128
 401250c:	10000626 	beq	r2,zero,4012528 <___vfiprintf_internal_r+0x184>
 4012510:	a0800003 	ldbu	r2,0(r20)
 4012514:	10803fcc 	andi	r2,r2,255
 4012518:	1080201c 	xori	r2,r2,128
 401251c:	10bfe004 	addi	r2,r2,-128
 4012520:	10800958 	cmpnei	r2,r2,37
 4012524:	103ff41e 	bne	r2,zero,40124f8 <___vfiprintf_internal_r+0x154>
		if ((m = fmt - cp) != 0) {
 4012528:	a4a3c83a 	sub	r17,r20,r18
 401252c:	88001826 	beq	r17,zero,4012590 <___vfiprintf_internal_r+0x1ec>
			PRINT (cp, m);
 4012530:	84800015 	stw	r18,0(r16)
 4012534:	8805883a 	mov	r2,r17
 4012538:	80800115 	stw	r2,4(r16)
 401253c:	e0bfe817 	ldw	r2,-96(fp)
 4012540:	8807883a 	mov	r3,r17
 4012544:	10c5883a 	add	r2,r2,r3
 4012548:	e0bfe815 	stw	r2,-96(fp)
 401254c:	84000204 	addi	r16,r16,8
 4012550:	e0bfe717 	ldw	r2,-100(fp)
 4012554:	10800044 	addi	r2,r2,1
 4012558:	e0bfe715 	stw	r2,-100(fp)
 401255c:	e0bfe717 	ldw	r2,-100(fp)
 4012560:	10800210 	cmplti	r2,r2,8
 4012564:	1000071e 	bne	r2,zero,4012584 <___vfiprintf_internal_r+0x1e0>
 4012568:	e0bfe604 	addi	r2,fp,-104
 401256c:	100d883a 	mov	r6,r2
 4012570:	e17fc917 	ldw	r5,-220(fp)
 4012574:	e13fca17 	ldw	r4,-216(fp)
 4012578:	40121340 	call	4012134 <__sprint_r>
 401257c:	1004041e 	bne	r2,zero,4013590 <___vfiprintf_internal_r+0x11ec>
 4012580:	e43fd604 	addi	r16,fp,-168
			ret += m;
 4012584:	e0bff717 	ldw	r2,-36(fp)
 4012588:	1445883a 	add	r2,r2,r17
 401258c:	e0bff715 	stw	r2,-36(fp)
                if (*fmt == '\0')
 4012590:	a0800003 	ldbu	r2,0(r20)
 4012594:	10803fcc 	andi	r2,r2,255
 4012598:	1080201c 	xori	r2,r2,128
 401259c:	10bfe004 	addi	r2,r2,-128
 40125a0:	1003ed26 	beq	r2,zero,4013558 <___vfiprintf_internal_r+0x11b4>
		fmt_anchor = fmt;
 40125a4:	e53feb15 	stw	r20,-84(fp)
		fmt++;		/* skip over '%' */
 40125a8:	a5000044 	addi	r20,r20,1
		flags = 0;
 40125ac:	0023883a 	mov	r17,zero
		dprec = 0;
 40125b0:	e03ff115 	stw	zero,-60(fp)
		width = 0;
 40125b4:	e03ff615 	stw	zero,-40(fp)
		prec = -1;
 40125b8:	00bfffc4 	movi	r2,-1
 40125bc:	e0bff515 	stw	r2,-44(fp)
		sign = '\0';
 40125c0:	e03fe9c5 	stb	zero,-89(fp)
rflag:		ch = *fmt++;
 40125c4:	a005883a 	mov	r2,r20
 40125c8:	15000044 	addi	r20,r2,1
 40125cc:	10800003 	ldbu	r2,0(r2)
 40125d0:	15403fcc 	andi	r21,r2,255
 40125d4:	ad40201c 	xori	r21,r21,128
 40125d8:	ad7fe004 	addi	r21,r21,-128
 40125dc:	a8bff804 	addi	r2,r21,-32
 40125e0:	10c01668 	cmpgeui	r3,r2,89
 40125e4:	1802891e 	bne	r3,zero,401300c <___vfiprintf_internal_r+0xc68>
 40125e8:	100690ba 	slli	r3,r2,2
 40125ec:	00810074 	movhi	r2,1025
 40125f0:	1885883a 	add	r2,r3,r2
 40125f4:	10897f17 	ldw	r2,9724(r2)
 40125f8:	1000683a 	jmp	r2
 40125fc:	04012760 	cmpeqi	r16,zero,1181
 4012600:	0401300c 	andi	r16,zero,1216
 4012604:	0401300c 	andi	r16,zero,1216
 4012608:	04012780 	call	401278 <__alt_mem_dram-0x3bfed88>
 401260c:	0401300c 	andi	r16,zero,1216
 4012610:	0401300c 	andi	r16,zero,1216
 4012614:	0401300c 	andi	r16,zero,1216
 4012618:	0401300c 	andi	r16,zero,1216
 401261c:	0401300c 	andi	r16,zero,1216
 4012620:	0401300c 	andi	r16,zero,1216
 4012624:	04012788 	cmpgei	r16,zero,1182
 4012628:	040127bc 	xorhi	r16,zero,1182
 401262c:	0401300c 	andi	r16,zero,1216
 4012630:	040127b4 	movhi	r16,1182
 4012634:	040127c8 	cmpgei	r16,zero,1183
 4012638:	0401300c 	andi	r16,zero,1216
 401263c:	0401286c 	andhi	r16,zero,1185
 4012640:	04012874 	movhi	r16,1185
 4012644:	04012874 	movhi	r16,1185
 4012648:	04012874 	movhi	r16,1185
 401264c:	04012874 	movhi	r16,1185
 4012650:	04012874 	movhi	r16,1185
 4012654:	04012874 	movhi	r16,1185
 4012658:	04012874 	movhi	r16,1185
 401265c:	04012874 	movhi	r16,1185
 4012660:	04012874 	movhi	r16,1185
 4012664:	0401300c 	andi	r16,zero,1216
 4012668:	0401300c 	andi	r16,zero,1216
 401266c:	0401300c 	andi	r16,zero,1216
 4012670:	0401300c 	andi	r16,zero,1216
 4012674:	0401300c 	andi	r16,zero,1216
 4012678:	0401300c 	andi	r16,zero,1216
 401267c:	0401300c 	andi	r16,zero,1216
 4012680:	0401300c 	andi	r16,zero,1216
 4012684:	0401300c 	andi	r16,zero,1216
 4012688:	0401300c 	andi	r16,zero,1216
 401268c:	04012924 	muli	r16,zero,1188
 4012690:	0401300c 	andi	r16,zero,1216
 4012694:	0401300c 	andi	r16,zero,1216
 4012698:	0401300c 	andi	r16,zero,1216
 401269c:	0401300c 	andi	r16,zero,1216
 40126a0:	0401300c 	andi	r16,zero,1216
 40126a4:	0401300c 	andi	r16,zero,1216
 40126a8:	0401300c 	andi	r16,zero,1216
 40126ac:	0401300c 	andi	r16,zero,1216
 40126b0:	0401300c 	andi	r16,zero,1216
 40126b4:	0401300c 	andi	r16,zero,1216
 40126b8:	04012ac4 	movi	r16,1195
 40126bc:	0401300c 	andi	r16,zero,1216
 40126c0:	0401300c 	andi	r16,zero,1216
 40126c4:	0401300c 	andi	r16,zero,1216
 40126c8:	0401300c 	andi	r16,zero,1216
 40126cc:	0401300c 	andi	r16,zero,1216
 40126d0:	04012c30 	cmpltui	r16,zero,1200
 40126d4:	0401300c 	andi	r16,zero,1216
 40126d8:	0401300c 	andi	r16,zero,1216
 40126dc:	04012cdc 	xori	r16,zero,1203
 40126e0:	0401300c 	andi	r16,zero,1216
 40126e4:	0401300c 	andi	r16,zero,1216
 40126e8:	0401300c 	andi	r16,zero,1216
 40126ec:	0401300c 	andi	r16,zero,1216
 40126f0:	0401300c 	andi	r16,zero,1216
 40126f4:	0401300c 	andi	r16,zero,1216
 40126f8:	0401300c 	andi	r16,zero,1216
 40126fc:	0401300c 	andi	r16,zero,1216
 4012700:	0401300c 	andi	r16,zero,1216
 4012704:	0401300c 	andi	r16,zero,1216
 4012708:	040128fc 	xorhi	r16,zero,1187
 401270c:	04012928 	cmpgeui	r16,zero,1188
 4012710:	0401300c 	andi	r16,zero,1216
 4012714:	0401300c 	andi	r16,zero,1216
 4012718:	0401300c 	andi	r16,zero,1216
 401271c:	040128c0 	call	40128c <__alt_mem_dram-0x3bfed74>
 4012720:	04012928 	cmpgeui	r16,zero,1188
 4012724:	0401300c 	andi	r16,zero,1216
 4012728:	0401300c 	andi	r16,zero,1216
 401272c:	040128c8 	cmpgei	r16,zero,1187
 4012730:	0401300c 	andi	r16,zero,1216
 4012734:	04012a24 	muli	r16,zero,1192
 4012738:	04012ac8 	cmpgei	r16,zero,1195
 401273c:	04012b5c 	xori	r16,zero,1197
 4012740:	040128f4 	movhi	r16,1187
 4012744:	0401300c 	andi	r16,zero,1216
 4012748:	04012ba4 	muli	r16,zero,1198
 401274c:	0401300c 	andi	r16,zero,1216
 4012750:	04012c34 	movhi	r16,1200
 4012754:	0401300c 	andi	r16,zero,1216
 4012758:	0401300c 	andi	r16,zero,1216
 401275c:	04012cec 	andhi	r16,zero,1203
			if (!sign)
 4012760:	e0bfe9c3 	ldbu	r2,-89(fp)
 4012764:	10803fcc 	andi	r2,r2,255
 4012768:	1080201c 	xori	r2,r2,128
 401276c:	10bfe004 	addi	r2,r2,-128
 4012770:	103f941e 	bne	r2,zero,40125c4 <___vfiprintf_internal_r+0x220>
				sign = ' ';
 4012774:	00800804 	movi	r2,32
 4012778:	e0bfe9c5 	stb	r2,-89(fp)
			goto rflag;
 401277c:	003f9106 	br	40125c4 <___vfiprintf_internal_r+0x220>
			flags |= ALT;
 4012780:	8c400054 	ori	r17,r17,1
			goto rflag;
 4012784:	003f8f06 	br	40125c4 <___vfiprintf_internal_r+0x220>
			width = GET_ARG (n, ap, int);
 4012788:	e0bfc717 	ldw	r2,-228(fp)
 401278c:	10c00104 	addi	r3,r2,4
 4012790:	e0ffc715 	stw	r3,-228(fp)
 4012794:	10800017 	ldw	r2,0(r2)
 4012798:	e0bff615 	stw	r2,-40(fp)
			if (width >= 0)
 401279c:	e0bff617 	ldw	r2,-40(fp)
 40127a0:	10000116 	blt	r2,zero,40127a8 <___vfiprintf_internal_r+0x404>
				goto rflag;
 40127a4:	003f8706 	br	40125c4 <___vfiprintf_internal_r+0x220>
			width = -width;
 40127a8:	e0bff617 	ldw	r2,-40(fp)
 40127ac:	0085c83a 	sub	r2,zero,r2
 40127b0:	e0bff615 	stw	r2,-40(fp)
			flags |= LADJUST;
 40127b4:	8c400114 	ori	r17,r17,4
			goto rflag;
 40127b8:	003f8206 	br	40125c4 <___vfiprintf_internal_r+0x220>
			sign = '+';
 40127bc:	00800ac4 	movi	r2,43
 40127c0:	e0bfe9c5 	stb	r2,-89(fp)
			goto rflag;
 40127c4:	003f7f06 	br	40125c4 <___vfiprintf_internal_r+0x220>
			if ((ch = *fmt++) == '*') {
 40127c8:	a005883a 	mov	r2,r20
 40127cc:	15000044 	addi	r20,r2,1
 40127d0:	10800003 	ldbu	r2,0(r2)
 40127d4:	15403fcc 	andi	r21,r2,255
 40127d8:	ad40201c 	xori	r21,r21,128
 40127dc:	ad7fe004 	addi	r21,r21,-128
 40127e0:	a8800a98 	cmpnei	r2,r21,42
 40127e4:	10000a1e 	bne	r2,zero,4012810 <___vfiprintf_internal_r+0x46c>
				prec = GET_ARG (n, ap, int);
 40127e8:	e0bfc717 	ldw	r2,-228(fp)
 40127ec:	10c00104 	addi	r3,r2,4
 40127f0:	e0ffc715 	stw	r3,-228(fp)
 40127f4:	10800017 	ldw	r2,0(r2)
 40127f8:	e0bff515 	stw	r2,-44(fp)
				if (prec < 0)
 40127fc:	e0bff517 	ldw	r2,-44(fp)
 4012800:	103f700e 	bge	r2,zero,40125c4 <___vfiprintf_internal_r+0x220>
					prec = -1;
 4012804:	00bfffc4 	movi	r2,-1
 4012808:	e0bff515 	stw	r2,-44(fp)
				goto rflag;
 401280c:	003f6d06 	br	40125c4 <___vfiprintf_internal_r+0x220>
			n = 0;
 4012810:	0027883a 	mov	r19,zero
			while (is_digit (ch)) {
 4012814:	00000d06 	br	401284c <___vfiprintf_internal_r+0x4a8>
				n = 10 * n + to_digit (ch);
 4012818:	9805883a 	mov	r2,r19
 401281c:	100490ba 	slli	r2,r2,2
 4012820:	14c5883a 	add	r2,r2,r19
 4012824:	1085883a 	add	r2,r2,r2
 4012828:	1007883a 	mov	r3,r2
 401282c:	a8bff404 	addi	r2,r21,-48
 4012830:	18a7883a 	add	r19,r3,r2
				ch = *fmt++;
 4012834:	a005883a 	mov	r2,r20
 4012838:	15000044 	addi	r20,r2,1
 401283c:	10800003 	ldbu	r2,0(r2)
 4012840:	15403fcc 	andi	r21,r2,255
 4012844:	ad40201c 	xori	r21,r21,128
 4012848:	ad7fe004 	addi	r21,r21,-128
			while (is_digit (ch)) {
 401284c:	a8bff404 	addi	r2,r21,-48
 4012850:	108002b0 	cmpltui	r2,r2,10
 4012854:	103ff01e 	bne	r2,zero,4012818 <___vfiprintf_internal_r+0x474>
			prec = n < 0 ? -1 : n;
 4012858:	9805883a 	mov	r2,r19
 401285c:	1000010e 	bge	r2,zero,4012864 <___vfiprintf_internal_r+0x4c0>
 4012860:	00bfffc4 	movi	r2,-1
 4012864:	e0bff515 	stw	r2,-44(fp)
			goto reswitch;
 4012868:	003f5c06 	br	40125dc <___vfiprintf_internal_r+0x238>
			flags |= ZEROPAD;
 401286c:	8c402014 	ori	r17,r17,128
			goto rflag;
 4012870:	003f5406 	br	40125c4 <___vfiprintf_internal_r+0x220>
			n = 0;
 4012874:	0027883a 	mov	r19,zero
				n = 10 * n + to_digit (ch);
 4012878:	9805883a 	mov	r2,r19
 401287c:	100490ba 	slli	r2,r2,2
 4012880:	14c5883a 	add	r2,r2,r19
 4012884:	1085883a 	add	r2,r2,r2
 4012888:	1007883a 	mov	r3,r2
 401288c:	a8bff404 	addi	r2,r21,-48
 4012890:	18a7883a 	add	r19,r3,r2
				ch = *fmt++;
 4012894:	a005883a 	mov	r2,r20
 4012898:	15000044 	addi	r20,r2,1
 401289c:	10800003 	ldbu	r2,0(r2)
 40128a0:	15403fcc 	andi	r21,r2,255
 40128a4:	ad40201c 	xori	r21,r21,128
 40128a8:	ad7fe004 	addi	r21,r21,-128
			} while (is_digit (ch));
 40128ac:	a8bff404 	addi	r2,r21,-48
 40128b0:	108002b0 	cmpltui	r2,r2,10
 40128b4:	103ff01e 	bne	r2,zero,4012878 <___vfiprintf_internal_r+0x4d4>
			width = n;
 40128b8:	e4fff615 	stw	r19,-40(fp)
			goto reswitch;
 40128bc:	003f4706 	br	40125dc <___vfiprintf_internal_r+0x238>
				flags |= SHORTINT;
 40128c0:	8c401014 	ori	r17,r17,64
			goto rflag;
 40128c4:	003f3f06 	br	40125c4 <___vfiprintf_internal_r+0x220>
			if (*fmt == 'l') {
 40128c8:	a0800003 	ldbu	r2,0(r20)
 40128cc:	10803fcc 	andi	r2,r2,255
 40128d0:	1080201c 	xori	r2,r2,128
 40128d4:	10bfe004 	addi	r2,r2,-128
 40128d8:	10801b18 	cmpnei	r2,r2,108
 40128dc:	1000031e 	bne	r2,zero,40128ec <___vfiprintf_internal_r+0x548>
				fmt++;
 40128e0:	a5000044 	addi	r20,r20,1
				flags |= QUADINT;
 40128e4:	8c400814 	ori	r17,r17,32
 40128e8:	003f3606 	br	40125c4 <___vfiprintf_internal_r+0x220>
				flags |= LONGINT;
 40128ec:	8c400414 	ori	r17,r17,16
			goto rflag;
 40128f0:	003f3406 	br	40125c4 <___vfiprintf_internal_r+0x220>
			flags |= QUADINT;
 40128f4:	8c400814 	ori	r17,r17,32
			goto rflag;
 40128f8:	003f3206 	br	40125c4 <___vfiprintf_internal_r+0x220>
			cp = buf;
 40128fc:	e4bfcc04 	addi	r18,fp,-208
				*cp = GET_ARG (N, ap, int);
 4012900:	e0bfc717 	ldw	r2,-228(fp)
 4012904:	10c00104 	addi	r3,r2,4
 4012908:	e0ffc715 	stw	r3,-228(fp)
 401290c:	10800017 	ldw	r2,0(r2)
 4012910:	90800005 	stb	r2,0(r18)
				size = 1;
 4012914:	00800044 	movi	r2,1
 4012918:	e0bfef15 	stw	r2,-68(fp)
			sign = '\0';
 401291c:	e03fe9c5 	stb	zero,-89(fp)
			break;
 4012920:	0001c206 	br	401302c <___vfiprintf_internal_r+0xc88>
			flags |= LONGINT;
 4012924:	8c400414 	ori	r17,r17,16
			_uquad = SARG ();
 4012928:	8880080c 	andi	r2,r17,32
 401292c:	10000826 	beq	r2,zero,4012950 <___vfiprintf_internal_r+0x5ac>
 4012930:	e13fc717 	ldw	r4,-228(fp)
 4012934:	20800204 	addi	r2,r4,8
 4012938:	e0bfc715 	stw	r2,-228(fp)
 401293c:	20800017 	ldw	r2,0(r4)
 4012940:	20c00117 	ldw	r3,4(r4)
 4012944:	e0bfc515 	stw	r2,-236(fp)
 4012948:	e0ffc615 	stw	r3,-232(fp)
 401294c:	00001e06 	br	40129c8 <___vfiprintf_internal_r+0x624>
 4012950:	8880040c 	andi	r2,r17,16
 4012954:	10000826 	beq	r2,zero,4012978 <___vfiprintf_internal_r+0x5d4>
 4012958:	e0bfc717 	ldw	r2,-228(fp)
 401295c:	10c00104 	addi	r3,r2,4
 4012960:	e0ffc715 	stw	r3,-228(fp)
 4012964:	10800017 	ldw	r2,0(r2)
 4012968:	e0bfc515 	stw	r2,-236(fp)
 401296c:	1005d7fa 	srai	r2,r2,31
 4012970:	e0bfc615 	stw	r2,-232(fp)
 4012974:	00001406 	br	40129c8 <___vfiprintf_internal_r+0x624>
 4012978:	8880100c 	andi	r2,r17,64
 401297c:	10000b26 	beq	r2,zero,40129ac <___vfiprintf_internal_r+0x608>
 4012980:	e0bfc717 	ldw	r2,-228(fp)
 4012984:	10c00104 	addi	r3,r2,4
 4012988:	e0ffc715 	stw	r3,-228(fp)
 401298c:	10800017 	ldw	r2,0(r2)
 4012990:	10bfffcc 	andi	r2,r2,65535
 4012994:	10a0001c 	xori	r2,r2,32768
 4012998:	10a00004 	addi	r2,r2,-32768
 401299c:	e0bfc515 	stw	r2,-236(fp)
 40129a0:	1005d7fa 	srai	r2,r2,31
 40129a4:	e0bfc615 	stw	r2,-232(fp)
 40129a8:	00000706 	br	40129c8 <___vfiprintf_internal_r+0x624>
 40129ac:	e0bfc717 	ldw	r2,-228(fp)
 40129b0:	10c00104 	addi	r3,r2,4
 40129b4:	e0ffc715 	stw	r3,-228(fp)
 40129b8:	10800017 	ldw	r2,0(r2)
 40129bc:	e0bfc515 	stw	r2,-236(fp)
 40129c0:	1005d7fa 	srai	r2,r2,31
 40129c4:	e0bfc615 	stw	r2,-232(fp)
 40129c8:	e0bfc517 	ldw	r2,-236(fp)
 40129cc:	e0bff315 	stw	r2,-52(fp)
 40129d0:	e0bfc617 	ldw	r2,-232(fp)
 40129d4:	e0bff415 	stw	r2,-48(fp)
			if ((quad_t)_uquad < 0)
 40129d8:	e0bff317 	ldw	r2,-52(fp)
 40129dc:	e0fff417 	ldw	r3,-48(fp)
 40129e0:	18000d0e 	bge	r3,zero,4012a18 <___vfiprintf_internal_r+0x674>
				_uquad = -_uquad;
 40129e4:	000d883a 	mov	r6,zero
 40129e8:	000f883a 	mov	r7,zero
 40129ec:	e13ff317 	ldw	r4,-52(fp)
 40129f0:	e17ff417 	ldw	r5,-48(fp)
 40129f4:	3105c83a 	sub	r2,r6,r4
 40129f8:	3091803a 	cmpltu	r8,r6,r2
 40129fc:	3947c83a 	sub	r3,r7,r5
 4012a00:	1a09c83a 	sub	r4,r3,r8
 4012a04:	2007883a 	mov	r3,r4
 4012a08:	e0bff315 	stw	r2,-52(fp)
 4012a0c:	e0fff415 	stw	r3,-48(fp)
				sign = '-';
 4012a10:	00800b44 	movi	r2,45
 4012a14:	e0bfe9c5 	stb	r2,-89(fp)
			base = DEC;
 4012a18:	00800044 	movi	r2,1
 4012a1c:	e0bff215 	stw	r2,-56(fp)
			goto number;
 4012a20:	0000ec06 	br	4012dd4 <___vfiprintf_internal_r+0xa30>
			if (flags & QUADINT)
 4012a24:	8880080c 	andi	r2,r17,32
 4012a28:	10000d26 	beq	r2,zero,4012a60 <___vfiprintf_internal_r+0x6bc>
				*GET_ARG (N, ap, quad_ptr_t) = ret;
 4012a2c:	e0bfc717 	ldw	r2,-228(fp)
 4012a30:	10c00104 	addi	r3,r2,4
 4012a34:	e0ffc715 	stw	r3,-228(fp)
 4012a38:	10800017 	ldw	r2,0(r2)
 4012a3c:	e0fff717 	ldw	r3,-36(fp)
 4012a40:	e0ffbf15 	stw	r3,-260(fp)
 4012a44:	1807d7fa 	srai	r3,r3,31
 4012a48:	e0ffc015 	stw	r3,-256(fp)
 4012a4c:	e0ffbf17 	ldw	r3,-260(fp)
 4012a50:	10c00015 	stw	r3,0(r2)
 4012a54:	e0ffc017 	ldw	r3,-256(fp)
 4012a58:	10c00115 	stw	r3,4(r2)
			continue;	/* no output */
 4012a5c:	0002bd06 	br	4013554 <___vfiprintf_internal_r+0x11b0>
			if (flags & LONGINT)
 4012a60:	8880040c 	andi	r2,r17,16
 4012a64:	10000726 	beq	r2,zero,4012a84 <___vfiprintf_internal_r+0x6e0>
				*GET_ARG (N, ap, long_ptr_t) = ret;
 4012a68:	e0bfc717 	ldw	r2,-228(fp)
 4012a6c:	10c00104 	addi	r3,r2,4
 4012a70:	e0ffc715 	stw	r3,-228(fp)
 4012a74:	10800017 	ldw	r2,0(r2)
 4012a78:	e0fff717 	ldw	r3,-36(fp)
 4012a7c:	10c00015 	stw	r3,0(r2)
			continue;	/* no output */
 4012a80:	0002b406 	br	4013554 <___vfiprintf_internal_r+0x11b0>
			else if (flags & SHORTINT)
 4012a84:	8880100c 	andi	r2,r17,64
 4012a88:	10000726 	beq	r2,zero,4012aa8 <___vfiprintf_internal_r+0x704>
				*GET_ARG (N, ap, short_ptr_t) = ret;
 4012a8c:	e0bfc717 	ldw	r2,-228(fp)
 4012a90:	10c00104 	addi	r3,r2,4
 4012a94:	e0ffc715 	stw	r3,-228(fp)
 4012a98:	10800017 	ldw	r2,0(r2)
 4012a9c:	e0fff717 	ldw	r3,-36(fp)
 4012aa0:	10c0000d 	sth	r3,0(r2)
			continue;	/* no output */
 4012aa4:	0002ab06 	br	4013554 <___vfiprintf_internal_r+0x11b0>
				*GET_ARG (N, ap, int_ptr_t) = ret;
 4012aa8:	e0bfc717 	ldw	r2,-228(fp)
 4012aac:	10c00104 	addi	r3,r2,4
 4012ab0:	e0ffc715 	stw	r3,-228(fp)
 4012ab4:	10800017 	ldw	r2,0(r2)
 4012ab8:	e0fff717 	ldw	r3,-36(fp)
 4012abc:	10c00015 	stw	r3,0(r2)
			continue;	/* no output */
 4012ac0:	0002a406 	br	4013554 <___vfiprintf_internal_r+0x11b0>
			flags |= LONGINT;
 4012ac4:	8c400414 	ori	r17,r17,16
			_uquad = UARG ();
 4012ac8:	8880080c 	andi	r2,r17,32
 4012acc:	10000626 	beq	r2,zero,4012ae8 <___vfiprintf_internal_r+0x744>
 4012ad0:	e0bfc717 	ldw	r2,-228(fp)
 4012ad4:	10c00204 	addi	r3,r2,8
 4012ad8:	e0ffc715 	stw	r3,-228(fp)
 4012adc:	15800017 	ldw	r22,0(r2)
 4012ae0:	15c00117 	ldw	r23,4(r2)
 4012ae4:	00001906 	br	4012b4c <___vfiprintf_internal_r+0x7a8>
 4012ae8:	8880040c 	andi	r2,r17,16
 4012aec:	10000726 	beq	r2,zero,4012b0c <___vfiprintf_internal_r+0x768>
 4012af0:	e0bfc717 	ldw	r2,-228(fp)
 4012af4:	10c00104 	addi	r3,r2,4
 4012af8:	e0ffc715 	stw	r3,-228(fp)
 4012afc:	10800017 	ldw	r2,0(r2)
 4012b00:	102d883a 	mov	r22,r2
 4012b04:	002f883a 	mov	r23,zero
 4012b08:	00001006 	br	4012b4c <___vfiprintf_internal_r+0x7a8>
 4012b0c:	8880100c 	andi	r2,r17,64
 4012b10:	10000826 	beq	r2,zero,4012b34 <___vfiprintf_internal_r+0x790>
 4012b14:	e0bfc717 	ldw	r2,-228(fp)
 4012b18:	10c00104 	addi	r3,r2,4
 4012b1c:	e0ffc715 	stw	r3,-228(fp)
 4012b20:	10800017 	ldw	r2,0(r2)
 4012b24:	10bfffcc 	andi	r2,r2,65535
 4012b28:	102d883a 	mov	r22,r2
 4012b2c:	002f883a 	mov	r23,zero
 4012b30:	00000606 	br	4012b4c <___vfiprintf_internal_r+0x7a8>
 4012b34:	e0bfc717 	ldw	r2,-228(fp)
 4012b38:	10c00104 	addi	r3,r2,4
 4012b3c:	e0ffc715 	stw	r3,-228(fp)
 4012b40:	10800017 	ldw	r2,0(r2)
 4012b44:	102d883a 	mov	r22,r2
 4012b48:	002f883a 	mov	r23,zero
 4012b4c:	e5bff315 	stw	r22,-52(fp)
 4012b50:	e5fff415 	stw	r23,-48(fp)
			base = OCT;
 4012b54:	e03ff215 	stw	zero,-56(fp)
			goto nosign;
 4012b58:	00009d06 	br	4012dd0 <___vfiprintf_internal_r+0xa2c>
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
 4012b5c:	e0bfc717 	ldw	r2,-228(fp)
 4012b60:	10c00104 	addi	r3,r2,4
 4012b64:	e0ffc715 	stw	r3,-228(fp)
 4012b68:	10800017 	ldw	r2,0(r2)
 4012b6c:	e0bff315 	stw	r2,-52(fp)
 4012b70:	e03ff415 	stw	zero,-48(fp)
			base = HEX;
 4012b74:	00800084 	movi	r2,2
 4012b78:	e0bff215 	stw	r2,-56(fp)
			xdigs = "0123456789abcdef";
 4012b7c:	008100b4 	movhi	r2,1026
 4012b80:	10abaf04 	addi	r2,r2,-20804
 4012b84:	e0bfee15 	stw	r2,-72(fp)
			flags |= HEXPREFIX;
 4012b88:	8c400094 	ori	r17,r17,2
			ox[0] = '0';
 4012b8c:	00800c04 	movi	r2,48
 4012b90:	e0bfcb85 	stb	r2,-210(fp)
			ox[1] = ch = 'x';
 4012b94:	05401e04 	movi	r21,120
 4012b98:	00801e04 	movi	r2,120
 4012b9c:	e0bfcbc5 	stb	r2,-209(fp)
			goto nosign;
 4012ba0:	00008b06 	br	4012dd0 <___vfiprintf_internal_r+0xa2c>
			cp = GET_ARG (N, ap, char_ptr_t);
 4012ba4:	e0bfc717 	ldw	r2,-228(fp)
 4012ba8:	10c00104 	addi	r3,r2,4
 4012bac:	e0ffc715 	stw	r3,-228(fp)
 4012bb0:	14800017 	ldw	r18,0(r2)
			sign = '\0';
 4012bb4:	e03fe9c5 	stb	zero,-89(fp)
			if (cp == NULL) {
 4012bb8:	9000081e 	bne	r18,zero,4012bdc <___vfiprintf_internal_r+0x838>
				cp = "(null)";
 4012bbc:	048100b4 	movhi	r18,1026
 4012bc0:	94abb404 	addi	r18,r18,-20784
				size = ((unsigned) prec > 6U) ? 6 : prec;
 4012bc4:	e0bff517 	ldw	r2,-44(fp)
 4012bc8:	10c001f0 	cmpltui	r3,r2,7
 4012bcc:	1800011e 	bne	r3,zero,4012bd4 <___vfiprintf_internal_r+0x830>
 4012bd0:	00800184 	movi	r2,6
 4012bd4:	e0bfef15 	stw	r2,-68(fp)
			break;
 4012bd8:	00011406 	br	401302c <___vfiprintf_internal_r+0xc88>
			if (prec >= 0) {
 4012bdc:	e0bff517 	ldw	r2,-44(fp)
 4012be0:	10000f16 	blt	r2,zero,4012c20 <___vfiprintf_internal_r+0x87c>
				char *p = memchr (cp, 0, prec);
 4012be4:	e0bff517 	ldw	r2,-44(fp)
 4012be8:	100d883a 	mov	r6,r2
 4012bec:	000b883a 	mov	r5,zero
 4012bf0:	9009883a 	mov	r4,r18
 4012bf4:	400f1f00 	call	400f1f0 <memchr>
 4012bf8:	e0bfea15 	stw	r2,-88(fp)
				if (p != NULL)
 4012bfc:	e0bfea17 	ldw	r2,-88(fp)
 4012c00:	10000426 	beq	r2,zero,4012c14 <___vfiprintf_internal_r+0x870>
					size = p - cp;
 4012c04:	e0bfea17 	ldw	r2,-88(fp)
 4012c08:	1485c83a 	sub	r2,r2,r18
 4012c0c:	e0bfef15 	stw	r2,-68(fp)
			break;
 4012c10:	00010606 	br	401302c <___vfiprintf_internal_r+0xc88>
					size = prec;
 4012c14:	e0bff517 	ldw	r2,-44(fp)
 4012c18:	e0bfef15 	stw	r2,-68(fp)
			break;
 4012c1c:	00010306 	br	401302c <___vfiprintf_internal_r+0xc88>
				size = strlen (cp);
 4012c20:	9009883a 	mov	r4,r18
 4012c24:	4007b340 	call	4007b34 <strlen>
 4012c28:	e0bfef15 	stw	r2,-68(fp)
			break;
 4012c2c:	0000ff06 	br	401302c <___vfiprintf_internal_r+0xc88>
			flags |= LONGINT;
 4012c30:	8c400414 	ori	r17,r17,16
			_uquad = UARG ();
 4012c34:	8880080c 	andi	r2,r17,32
 4012c38:	10000826 	beq	r2,zero,4012c5c <___vfiprintf_internal_r+0x8b8>
 4012c3c:	e0bfc717 	ldw	r2,-228(fp)
 4012c40:	10c00204 	addi	r3,r2,8
 4012c44:	e0ffc715 	stw	r3,-228(fp)
 4012c48:	10c00017 	ldw	r3,0(r2)
 4012c4c:	e0ffc315 	stw	r3,-244(fp)
 4012c50:	10800117 	ldw	r2,4(r2)
 4012c54:	e0bfc415 	stw	r2,-240(fp)
 4012c58:	00001906 	br	4012cc0 <___vfiprintf_internal_r+0x91c>
 4012c5c:	8880040c 	andi	r2,r17,16
 4012c60:	10000726 	beq	r2,zero,4012c80 <___vfiprintf_internal_r+0x8dc>
 4012c64:	e0bfc717 	ldw	r2,-228(fp)
 4012c68:	10c00104 	addi	r3,r2,4
 4012c6c:	e0ffc715 	stw	r3,-228(fp)
 4012c70:	10800017 	ldw	r2,0(r2)
 4012c74:	e0bfc315 	stw	r2,-244(fp)
 4012c78:	e03fc415 	stw	zero,-240(fp)
 4012c7c:	00001006 	br	4012cc0 <___vfiprintf_internal_r+0x91c>
 4012c80:	8880100c 	andi	r2,r17,64
 4012c84:	10000826 	beq	r2,zero,4012ca8 <___vfiprintf_internal_r+0x904>
 4012c88:	e0bfc717 	ldw	r2,-228(fp)
 4012c8c:	10c00104 	addi	r3,r2,4
 4012c90:	e0ffc715 	stw	r3,-228(fp)
 4012c94:	10800017 	ldw	r2,0(r2)
 4012c98:	10bfffcc 	andi	r2,r2,65535
 4012c9c:	e0bfc315 	stw	r2,-244(fp)
 4012ca0:	e03fc415 	stw	zero,-240(fp)
 4012ca4:	00000606 	br	4012cc0 <___vfiprintf_internal_r+0x91c>
 4012ca8:	e0bfc717 	ldw	r2,-228(fp)
 4012cac:	10c00104 	addi	r3,r2,4
 4012cb0:	e0ffc715 	stw	r3,-228(fp)
 4012cb4:	10800017 	ldw	r2,0(r2)
 4012cb8:	e0bfc315 	stw	r2,-244(fp)
 4012cbc:	e03fc415 	stw	zero,-240(fp)
 4012cc0:	e0bfc317 	ldw	r2,-244(fp)
 4012cc4:	e0bff315 	stw	r2,-52(fp)
 4012cc8:	e0bfc417 	ldw	r2,-240(fp)
 4012ccc:	e0bff415 	stw	r2,-48(fp)
			base = DEC;
 4012cd0:	00800044 	movi	r2,1
 4012cd4:	e0bff215 	stw	r2,-56(fp)
			goto nosign;
 4012cd8:	00003d06 	br	4012dd0 <___vfiprintf_internal_r+0xa2c>
			xdigs = "0123456789ABCDEF";
 4012cdc:	008100b4 	movhi	r2,1026
 4012ce0:	10abb604 	addi	r2,r2,-20776
 4012ce4:	e0bfee15 	stw	r2,-72(fp)
			goto hex;
 4012ce8:	00000306 	br	4012cf8 <___vfiprintf_internal_r+0x954>
			xdigs = "0123456789abcdef";
 4012cec:	008100b4 	movhi	r2,1026
 4012cf0:	10abaf04 	addi	r2,r2,-20804
 4012cf4:	e0bfee15 	stw	r2,-72(fp)
hex:			_uquad = UARG ();
 4012cf8:	8880080c 	andi	r2,r17,32
 4012cfc:	10000826 	beq	r2,zero,4012d20 <___vfiprintf_internal_r+0x97c>
 4012d00:	e0bfc717 	ldw	r2,-228(fp)
 4012d04:	10c00204 	addi	r3,r2,8
 4012d08:	e0ffc715 	stw	r3,-228(fp)
 4012d0c:	10c00017 	ldw	r3,0(r2)
 4012d10:	e0ffc115 	stw	r3,-252(fp)
 4012d14:	10800117 	ldw	r2,4(r2)
 4012d18:	e0bfc215 	stw	r2,-248(fp)
 4012d1c:	00001906 	br	4012d84 <___vfiprintf_internal_r+0x9e0>
 4012d20:	8880040c 	andi	r2,r17,16
 4012d24:	10000726 	beq	r2,zero,4012d44 <___vfiprintf_internal_r+0x9a0>
 4012d28:	e0bfc717 	ldw	r2,-228(fp)
 4012d2c:	10c00104 	addi	r3,r2,4
 4012d30:	e0ffc715 	stw	r3,-228(fp)
 4012d34:	10800017 	ldw	r2,0(r2)
 4012d38:	e0bfc115 	stw	r2,-252(fp)
 4012d3c:	e03fc215 	stw	zero,-248(fp)
 4012d40:	00001006 	br	4012d84 <___vfiprintf_internal_r+0x9e0>
 4012d44:	8880100c 	andi	r2,r17,64
 4012d48:	10000826 	beq	r2,zero,4012d6c <___vfiprintf_internal_r+0x9c8>
 4012d4c:	e0bfc717 	ldw	r2,-228(fp)
 4012d50:	10c00104 	addi	r3,r2,4
 4012d54:	e0ffc715 	stw	r3,-228(fp)
 4012d58:	10800017 	ldw	r2,0(r2)
 4012d5c:	10bfffcc 	andi	r2,r2,65535
 4012d60:	e0bfc115 	stw	r2,-252(fp)
 4012d64:	e03fc215 	stw	zero,-248(fp)
 4012d68:	00000606 	br	4012d84 <___vfiprintf_internal_r+0x9e0>
 4012d6c:	e0bfc717 	ldw	r2,-228(fp)
 4012d70:	10c00104 	addi	r3,r2,4
 4012d74:	e0ffc715 	stw	r3,-228(fp)
 4012d78:	10800017 	ldw	r2,0(r2)
 4012d7c:	e0bfc115 	stw	r2,-252(fp)
 4012d80:	e03fc215 	stw	zero,-248(fp)
 4012d84:	e0bfc117 	ldw	r2,-252(fp)
 4012d88:	e0bff315 	stw	r2,-52(fp)
 4012d8c:	e0bfc217 	ldw	r2,-248(fp)
 4012d90:	e0bff415 	stw	r2,-48(fp)
			base = HEX;
 4012d94:	00800084 	movi	r2,2
 4012d98:	e0bff215 	stw	r2,-56(fp)
			if (flags & ALT && _uquad != 0) {
 4012d9c:	8880004c 	andi	r2,r17,1
 4012da0:	10000a26 	beq	r2,zero,4012dcc <___vfiprintf_internal_r+0xa28>
 4012da4:	e0bff317 	ldw	r2,-52(fp)
 4012da8:	e0fff417 	ldw	r3,-48(fp)
 4012dac:	10c4b03a 	or	r2,r2,r3
 4012db0:	10000726 	beq	r2,zero,4012dd0 <___vfiprintf_internal_r+0xa2c>
				ox[0] = '0';
 4012db4:	00800c04 	movi	r2,48
 4012db8:	e0bfcb85 	stb	r2,-210(fp)
				ox[1] = ch;
 4012dbc:	a805883a 	mov	r2,r21
 4012dc0:	e0bfcbc5 	stb	r2,-209(fp)
				flags |= HEXPREFIX;
 4012dc4:	8c400094 	ori	r17,r17,2
 4012dc8:	00000106 	br	4012dd0 <___vfiprintf_internal_r+0xa2c>
nosign:			sign = '\0';
 4012dcc:	0001883a 	nop
 4012dd0:	e03fe9c5 	stb	zero,-89(fp)
number:			if ((dprec = prec) >= 0)
 4012dd4:	e0bff517 	ldw	r2,-44(fp)
 4012dd8:	e0bff115 	stw	r2,-60(fp)
 4012ddc:	e0bff117 	ldw	r2,-60(fp)
 4012de0:	10000216 	blt	r2,zero,4012dec <___vfiprintf_internal_r+0xa48>
				flags &= ~ZEROPAD;
 4012de4:	00bfdfc4 	movi	r2,-129
 4012de8:	88a2703a 	and	r17,r17,r2
			cp = buf + BUF;
 4012dec:	e4bfcc04 	addi	r18,fp,-208
 4012df0:	94800a04 	addi	r18,r18,40
			if (_uquad != 0 || prec != 0) {
 4012df4:	e0bff317 	ldw	r2,-52(fp)
 4012df8:	e0fff417 	ldw	r3,-48(fp)
 4012dfc:	10c4b03a 	or	r2,r2,r3
 4012e00:	1000021e 	bne	r2,zero,4012e0c <___vfiprintf_internal_r+0xa68>
 4012e04:	e0bff517 	ldw	r2,-44(fp)
 4012e08:	10007426 	beq	r2,zero,4012fdc <___vfiprintf_internal_r+0xc38>
 4012e0c:	e0bff217 	ldw	r2,-56(fp)
 4012e10:	108000a0 	cmpeqi	r2,r2,2
 4012e14:	1000531e 	bne	r2,zero,4012f64 <___vfiprintf_internal_r+0xbc0>
 4012e18:	e0bff217 	ldw	r2,-56(fp)
 4012e1c:	108000e8 	cmpgeui	r2,r2,3
 4012e20:	1000651e 	bne	r2,zero,4012fb8 <___vfiprintf_internal_r+0xc14>
 4012e24:	e0bff217 	ldw	r2,-56(fp)
 4012e28:	10000526 	beq	r2,zero,4012e40 <___vfiprintf_internal_r+0xa9c>
 4012e2c:	e0bff217 	ldw	r2,-56(fp)
 4012e30:	10800060 	cmpeqi	r2,r2,1
 4012e34:	1000201e 	bne	r2,zero,4012eb8 <___vfiprintf_internal_r+0xb14>
 4012e38:	00005f06 	br	4012fb8 <___vfiprintf_internal_r+0xc14>
				case OCT:
 4012e3c:	0001883a 	nop
						*--cp = to_char (_uquad & 7);
 4012e40:	e0bff317 	ldw	r2,-52(fp)
 4012e44:	108001cc 	andi	r2,r2,7
 4012e48:	10800c04 	addi	r2,r2,48
 4012e4c:	94bfffc4 	addi	r18,r18,-1
 4012e50:	90800005 	stb	r2,0(r18)
						_uquad >>= 3;
 4012e54:	e0bff417 	ldw	r2,-48(fp)
 4012e58:	1004977a 	slli	r2,r2,29
 4012e5c:	e0fff317 	ldw	r3,-52(fp)
 4012e60:	1806d0fa 	srli	r3,r3,3
 4012e64:	1884b03a 	or	r2,r3,r2
 4012e68:	e0bff315 	stw	r2,-52(fp)
 4012e6c:	e0bff417 	ldw	r2,-48(fp)
 4012e70:	1004d0fa 	srli	r2,r2,3
 4012e74:	e0bff415 	stw	r2,-48(fp)
					} while (_uquad);
 4012e78:	e0bff317 	ldw	r2,-52(fp)
 4012e7c:	e0fff417 	ldw	r3,-48(fp)
 4012e80:	10c4b03a 	or	r2,r2,r3
 4012e84:	103fed1e 	bne	r2,zero,4012e3c <___vfiprintf_internal_r+0xa98>
					if (flags & ALT && *cp != '0')
 4012e88:	8880004c 	andi	r2,r17,1
 4012e8c:	10005126 	beq	r2,zero,4012fd4 <___vfiprintf_internal_r+0xc30>
 4012e90:	90800003 	ldbu	r2,0(r18)
 4012e94:	10803fcc 	andi	r2,r2,255
 4012e98:	1080201c 	xori	r2,r2,128
 4012e9c:	10bfe004 	addi	r2,r2,-128
 4012ea0:	10800c20 	cmpeqi	r2,r2,48
 4012ea4:	10004b1e 	bne	r2,zero,4012fd4 <___vfiprintf_internal_r+0xc30>
						*--cp = '0';
 4012ea8:	94bfffc4 	addi	r18,r18,-1
 4012eac:	00800c04 	movi	r2,48
 4012eb0:	90800005 	stb	r2,0(r18)
					break;
 4012eb4:	00004706 	br	4012fd4 <___vfiprintf_internal_r+0xc30>
					if (_uquad < 10) {
 4012eb8:	e0bff417 	ldw	r2,-48(fp)
 4012ebc:	10000a1e 	bne	r2,zero,4012ee8 <___vfiprintf_internal_r+0xb44>
 4012ec0:	e0bff417 	ldw	r2,-48(fp)
 4012ec4:	1000031e 	bne	r2,zero,4012ed4 <___vfiprintf_internal_r+0xb30>
 4012ec8:	e0bff317 	ldw	r2,-52(fp)
 4012ecc:	108002a8 	cmpgeui	r2,r2,10
 4012ed0:	1000051e 	bne	r2,zero,4012ee8 <___vfiprintf_internal_r+0xb44>
						*--cp = to_char(_uquad);
 4012ed4:	e0bff317 	ldw	r2,-52(fp)
 4012ed8:	10800c04 	addi	r2,r2,48
 4012edc:	94bfffc4 	addi	r18,r18,-1
 4012ee0:	90800005 	stb	r2,0(r18)
						break;
 4012ee4:	00003c06 	br	4012fd8 <___vfiprintf_internal_r+0xc34>
					  *--cp = to_char (_uquad % 10);
 4012ee8:	e0bff317 	ldw	r2,-52(fp)
 4012eec:	e0fff417 	ldw	r3,-48(fp)
 4012ef0:	01800284 	movi	r6,10
 4012ef4:	000f883a 	mov	r7,zero
 4012ef8:	1009883a 	mov	r4,r2
 4012efc:	180b883a 	mov	r5,r3
 4012f00:	4014f940 	call	4014f94 <__umoddi3>
 4012f04:	1009883a 	mov	r4,r2
 4012f08:	180b883a 	mov	r5,r3
 4012f0c:	2005883a 	mov	r2,r4
 4012f10:	2807883a 	mov	r3,r5
 4012f14:	10800c04 	addi	r2,r2,48
 4012f18:	94bfffc4 	addi	r18,r18,-1
 4012f1c:	90800005 	stb	r2,0(r18)
					  _uquad /= 10;
 4012f20:	e0bff317 	ldw	r2,-52(fp)
 4012f24:	e0fff417 	ldw	r3,-48(fp)
 4012f28:	01800284 	movi	r6,10
 4012f2c:	000f883a 	mov	r7,zero
 4012f30:	1009883a 	mov	r4,r2
 4012f34:	180b883a 	mov	r5,r3
 4012f38:	40149780 	call	4014978 <__udivdi3>
 4012f3c:	1009883a 	mov	r4,r2
 4012f40:	180b883a 	mov	r5,r3
 4012f44:	e13ff315 	stw	r4,-52(fp)
 4012f48:	e17ff415 	stw	r5,-48(fp)
					} while (_uquad != 0);
 4012f4c:	e0bff317 	ldw	r2,-52(fp)
 4012f50:	e0fff417 	ldw	r3,-48(fp)
 4012f54:	10c4b03a 	or	r2,r2,r3
 4012f58:	103fe31e 	bne	r2,zero,4012ee8 <___vfiprintf_internal_r+0xb44>
					break;
 4012f5c:	00001e06 	br	4012fd8 <___vfiprintf_internal_r+0xc34>
				case HEX:
 4012f60:	0001883a 	nop
						*--cp = xdigs[_uquad & 15];
 4012f64:	e0bff317 	ldw	r2,-52(fp)
 4012f68:	108003cc 	andi	r2,r2,15
 4012f6c:	e0ffee17 	ldw	r3,-72(fp)
 4012f70:	1885883a 	add	r2,r3,r2
 4012f74:	94bfffc4 	addi	r18,r18,-1
 4012f78:	10800003 	ldbu	r2,0(r2)
 4012f7c:	90800005 	stb	r2,0(r18)
						_uquad >>= 4;
 4012f80:	e0bff417 	ldw	r2,-48(fp)
 4012f84:	1004973a 	slli	r2,r2,28
 4012f88:	e0fff317 	ldw	r3,-52(fp)
 4012f8c:	1806d13a 	srli	r3,r3,4
 4012f90:	1884b03a 	or	r2,r3,r2
 4012f94:	e0bff315 	stw	r2,-52(fp)
 4012f98:	e0bff417 	ldw	r2,-48(fp)
 4012f9c:	1004d13a 	srli	r2,r2,4
 4012fa0:	e0bff415 	stw	r2,-48(fp)
					} while (_uquad);
 4012fa4:	e0bff317 	ldw	r2,-52(fp)
 4012fa8:	e0fff417 	ldw	r3,-48(fp)
 4012fac:	10c4b03a 	or	r2,r2,r3
 4012fb0:	103feb1e 	bne	r2,zero,4012f60 <___vfiprintf_internal_r+0xbbc>
					break;
 4012fb4:	00000806 	br	4012fd8 <___vfiprintf_internal_r+0xc34>
					cp = "bug in vfprintf: bad base";
 4012fb8:	048100b4 	movhi	r18,1026
 4012fbc:	94abbb04 	addi	r18,r18,-20756
					size = strlen (cp);
 4012fc0:	9009883a 	mov	r4,r18
 4012fc4:	4007b340 	call	4007b34 <strlen>
 4012fc8:	e0bfef15 	stw	r2,-68(fp)
					goto skipsize;
 4012fcc:	0001883a 	nop
			break;
 4012fd0:	00001606 	br	401302c <___vfiprintf_internal_r+0xc88>
					break;
 4012fd4:	0001883a 	nop
				switch (base) {
 4012fd8:	00000706 	br	4012ff8 <___vfiprintf_internal_r+0xc54>
                       else if (base == OCT && (flags & ALT))
 4012fdc:	e0bff217 	ldw	r2,-56(fp)
 4012fe0:	1000051e 	bne	r2,zero,4012ff8 <___vfiprintf_internal_r+0xc54>
 4012fe4:	8880004c 	andi	r2,r17,1
 4012fe8:	10000326 	beq	r2,zero,4012ff8 <___vfiprintf_internal_r+0xc54>
                         *--cp = '0';
 4012fec:	94bfffc4 	addi	r18,r18,-1
 4012ff0:	00800c04 	movi	r2,48
 4012ff4:	90800005 	stb	r2,0(r18)
			size = buf + BUF - cp;
 4012ff8:	e0bfcc04 	addi	r2,fp,-208
 4012ffc:	10800a04 	addi	r2,r2,40
 4013000:	1485c83a 	sub	r2,r2,r18
 4013004:	e0bfef15 	stw	r2,-68(fp)
			break;
 4013008:	00000806 	br	401302c <___vfiprintf_internal_r+0xc88>
			if (ch == '\0')
 401300c:	a8015426 	beq	r21,zero,4013560 <___vfiprintf_internal_r+0x11bc>
			cp = buf;
 4013010:	e4bfcc04 	addi	r18,fp,-208
			*cp = ch;
 4013014:	a805883a 	mov	r2,r21
 4013018:	90800005 	stb	r2,0(r18)
			size = 1;
 401301c:	00800044 	movi	r2,1
 4013020:	e0bfef15 	stw	r2,-68(fp)
			sign = '\0';
 4013024:	e03fe9c5 	stb	zero,-89(fp)
			break;
 4013028:	0001883a 	nop
		realsz = dprec > size ? dprec : size;
 401302c:	e0fff117 	ldw	r3,-60(fp)
 4013030:	e0bfef17 	ldw	r2,-68(fp)
 4013034:	10c0010e 	bge	r2,r3,401303c <___vfiprintf_internal_r+0xc98>
 4013038:	1805883a 	mov	r2,r3
 401303c:	e0bff015 	stw	r2,-64(fp)
		if (sign)
 4013040:	e0bfe9c3 	ldbu	r2,-89(fp)
 4013044:	10803fcc 	andi	r2,r2,255
 4013048:	1080201c 	xori	r2,r2,128
 401304c:	10bfe004 	addi	r2,r2,-128
 4013050:	10000326 	beq	r2,zero,4013060 <___vfiprintf_internal_r+0xcbc>
			realsz++;
 4013054:	e0bff017 	ldw	r2,-64(fp)
 4013058:	10800044 	addi	r2,r2,1
 401305c:	e0bff015 	stw	r2,-64(fp)
		if (flags & HEXPREFIX)
 4013060:	8880008c 	andi	r2,r17,2
 4013064:	10000326 	beq	r2,zero,4013074 <___vfiprintf_internal_r+0xcd0>
			realsz+= 2;
 4013068:	e0bff017 	ldw	r2,-64(fp)
 401306c:	10800084 	addi	r2,r2,2
 4013070:	e0bff015 	stw	r2,-64(fp)
		if ((flags & (LADJUST|ZEROPAD)) == 0)
 4013074:	8880210c 	andi	r2,r17,132
 4013078:	1000351e 	bne	r2,zero,4013150 <___vfiprintf_internal_r+0xdac>
			PAD (width - realsz, blanks);
 401307c:	e0fff617 	ldw	r3,-40(fp)
 4013080:	e0bff017 	ldw	r2,-64(fp)
 4013084:	18a7c83a 	sub	r19,r3,r2
 4013088:	04c0310e 	bge	zero,r19,4013150 <___vfiprintf_internal_r+0xdac>
 401308c:	00001706 	br	40130ec <___vfiprintf_internal_r+0xd48>
 4013090:	008100b4 	movhi	r2,1026
 4013094:	10abc204 	addi	r2,r2,-20728
 4013098:	80800015 	stw	r2,0(r16)
 401309c:	00800404 	movi	r2,16
 40130a0:	80800115 	stw	r2,4(r16)
 40130a4:	e0bfe817 	ldw	r2,-96(fp)
 40130a8:	10800404 	addi	r2,r2,16
 40130ac:	e0bfe815 	stw	r2,-96(fp)
 40130b0:	84000204 	addi	r16,r16,8
 40130b4:	e0bfe717 	ldw	r2,-100(fp)
 40130b8:	10800044 	addi	r2,r2,1
 40130bc:	e0bfe715 	stw	r2,-100(fp)
 40130c0:	e0bfe717 	ldw	r2,-100(fp)
 40130c4:	10800210 	cmplti	r2,r2,8
 40130c8:	1000071e 	bne	r2,zero,40130e8 <___vfiprintf_internal_r+0xd44>
 40130cc:	e0bfe604 	addi	r2,fp,-104
 40130d0:	100d883a 	mov	r6,r2
 40130d4:	e17fc917 	ldw	r5,-220(fp)
 40130d8:	e13fca17 	ldw	r4,-216(fp)
 40130dc:	40121340 	call	4012134 <__sprint_r>
 40130e0:	10012d1e 	bne	r2,zero,4013598 <___vfiprintf_internal_r+0x11f4>
 40130e4:	e43fd604 	addi	r16,fp,-168
 40130e8:	9cfffc04 	addi	r19,r19,-16
 40130ec:	98800448 	cmpgei	r2,r19,17
 40130f0:	103fe71e 	bne	r2,zero,4013090 <___vfiprintf_internal_r+0xcec>
 40130f4:	008100b4 	movhi	r2,1026
 40130f8:	10abc204 	addi	r2,r2,-20728
 40130fc:	80800015 	stw	r2,0(r16)
 4013100:	9805883a 	mov	r2,r19
 4013104:	80800115 	stw	r2,4(r16)
 4013108:	e0bfe817 	ldw	r2,-96(fp)
 401310c:	9807883a 	mov	r3,r19
 4013110:	10c5883a 	add	r2,r2,r3
 4013114:	e0bfe815 	stw	r2,-96(fp)
 4013118:	84000204 	addi	r16,r16,8
 401311c:	e0bfe717 	ldw	r2,-100(fp)
 4013120:	10800044 	addi	r2,r2,1
 4013124:	e0bfe715 	stw	r2,-100(fp)
 4013128:	e0bfe717 	ldw	r2,-100(fp)
 401312c:	10800210 	cmplti	r2,r2,8
 4013130:	1000071e 	bne	r2,zero,4013150 <___vfiprintf_internal_r+0xdac>
 4013134:	e0bfe604 	addi	r2,fp,-104
 4013138:	100d883a 	mov	r6,r2
 401313c:	e17fc917 	ldw	r5,-220(fp)
 4013140:	e13fca17 	ldw	r4,-216(fp)
 4013144:	40121340 	call	4012134 <__sprint_r>
 4013148:	1001151e 	bne	r2,zero,40135a0 <___vfiprintf_internal_r+0x11fc>
 401314c:	e43fd604 	addi	r16,fp,-168
		if (sign)
 4013150:	e0bfe9c3 	ldbu	r2,-89(fp)
 4013154:	10803fcc 	andi	r2,r2,255
 4013158:	1080201c 	xori	r2,r2,128
 401315c:	10bfe004 	addi	r2,r2,-128
 4013160:	10001526 	beq	r2,zero,40131b8 <___vfiprintf_internal_r+0xe14>
			PRINT (&sign, 1);
 4013164:	e0bfe9c4 	addi	r2,fp,-89
 4013168:	80800015 	stw	r2,0(r16)
 401316c:	00800044 	movi	r2,1
 4013170:	80800115 	stw	r2,4(r16)
 4013174:	e0bfe817 	ldw	r2,-96(fp)
 4013178:	10800044 	addi	r2,r2,1
 401317c:	e0bfe815 	stw	r2,-96(fp)
 4013180:	84000204 	addi	r16,r16,8
 4013184:	e0bfe717 	ldw	r2,-100(fp)
 4013188:	10800044 	addi	r2,r2,1
 401318c:	e0bfe715 	stw	r2,-100(fp)
 4013190:	e0bfe717 	ldw	r2,-100(fp)
 4013194:	10800210 	cmplti	r2,r2,8
 4013198:	1000071e 	bne	r2,zero,40131b8 <___vfiprintf_internal_r+0xe14>
 401319c:	e0bfe604 	addi	r2,fp,-104
 40131a0:	100d883a 	mov	r6,r2
 40131a4:	e17fc917 	ldw	r5,-220(fp)
 40131a8:	e13fca17 	ldw	r4,-216(fp)
 40131ac:	40121340 	call	4012134 <__sprint_r>
 40131b0:	1000fd1e 	bne	r2,zero,40135a8 <___vfiprintf_internal_r+0x1204>
 40131b4:	e43fd604 	addi	r16,fp,-168
		if (flags & HEXPREFIX)
 40131b8:	8880008c 	andi	r2,r17,2
 40131bc:	10001526 	beq	r2,zero,4013214 <___vfiprintf_internal_r+0xe70>
			PRINT (ox, 2);
 40131c0:	e0bfcb84 	addi	r2,fp,-210
 40131c4:	80800015 	stw	r2,0(r16)
 40131c8:	00800084 	movi	r2,2
 40131cc:	80800115 	stw	r2,4(r16)
 40131d0:	e0bfe817 	ldw	r2,-96(fp)
 40131d4:	10800084 	addi	r2,r2,2
 40131d8:	e0bfe815 	stw	r2,-96(fp)
 40131dc:	84000204 	addi	r16,r16,8
 40131e0:	e0bfe717 	ldw	r2,-100(fp)
 40131e4:	10800044 	addi	r2,r2,1
 40131e8:	e0bfe715 	stw	r2,-100(fp)
 40131ec:	e0bfe717 	ldw	r2,-100(fp)
 40131f0:	10800210 	cmplti	r2,r2,8
 40131f4:	1000071e 	bne	r2,zero,4013214 <___vfiprintf_internal_r+0xe70>
 40131f8:	e0bfe604 	addi	r2,fp,-104
 40131fc:	100d883a 	mov	r6,r2
 4013200:	e17fc917 	ldw	r5,-220(fp)
 4013204:	e13fca17 	ldw	r4,-216(fp)
 4013208:	40121340 	call	4012134 <__sprint_r>
 401320c:	1000e81e 	bne	r2,zero,40135b0 <___vfiprintf_internal_r+0x120c>
 4013210:	e43fd604 	addi	r16,fp,-168
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
 4013214:	8880210c 	andi	r2,r17,132
 4013218:	10802018 	cmpnei	r2,r2,128
 401321c:	1000351e 	bne	r2,zero,40132f4 <___vfiprintf_internal_r+0xf50>
			PAD (width - realsz, zeroes);
 4013220:	e0fff617 	ldw	r3,-40(fp)
 4013224:	e0bff017 	ldw	r2,-64(fp)
 4013228:	18a7c83a 	sub	r19,r3,r2
 401322c:	04c0310e 	bge	zero,r19,40132f4 <___vfiprintf_internal_r+0xf50>
 4013230:	00001706 	br	4013290 <___vfiprintf_internal_r+0xeec>
 4013234:	008100b4 	movhi	r2,1026
 4013238:	10abc604 	addi	r2,r2,-20712
 401323c:	80800015 	stw	r2,0(r16)
 4013240:	00800404 	movi	r2,16
 4013244:	80800115 	stw	r2,4(r16)
 4013248:	e0bfe817 	ldw	r2,-96(fp)
 401324c:	10800404 	addi	r2,r2,16
 4013250:	e0bfe815 	stw	r2,-96(fp)
 4013254:	84000204 	addi	r16,r16,8
 4013258:	e0bfe717 	ldw	r2,-100(fp)
 401325c:	10800044 	addi	r2,r2,1
 4013260:	e0bfe715 	stw	r2,-100(fp)
 4013264:	e0bfe717 	ldw	r2,-100(fp)
 4013268:	10800210 	cmplti	r2,r2,8
 401326c:	1000071e 	bne	r2,zero,401328c <___vfiprintf_internal_r+0xee8>
 4013270:	e0bfe604 	addi	r2,fp,-104
 4013274:	100d883a 	mov	r6,r2
 4013278:	e17fc917 	ldw	r5,-220(fp)
 401327c:	e13fca17 	ldw	r4,-216(fp)
 4013280:	40121340 	call	4012134 <__sprint_r>
 4013284:	1000cc1e 	bne	r2,zero,40135b8 <___vfiprintf_internal_r+0x1214>
 4013288:	e43fd604 	addi	r16,fp,-168
 401328c:	9cfffc04 	addi	r19,r19,-16
 4013290:	98800448 	cmpgei	r2,r19,17
 4013294:	103fe71e 	bne	r2,zero,4013234 <___vfiprintf_internal_r+0xe90>
 4013298:	008100b4 	movhi	r2,1026
 401329c:	10abc604 	addi	r2,r2,-20712
 40132a0:	80800015 	stw	r2,0(r16)
 40132a4:	9805883a 	mov	r2,r19
 40132a8:	80800115 	stw	r2,4(r16)
 40132ac:	e0bfe817 	ldw	r2,-96(fp)
 40132b0:	9807883a 	mov	r3,r19
 40132b4:	10c5883a 	add	r2,r2,r3
 40132b8:	e0bfe815 	stw	r2,-96(fp)
 40132bc:	84000204 	addi	r16,r16,8
 40132c0:	e0bfe717 	ldw	r2,-100(fp)
 40132c4:	10800044 	addi	r2,r2,1
 40132c8:	e0bfe715 	stw	r2,-100(fp)
 40132cc:	e0bfe717 	ldw	r2,-100(fp)
 40132d0:	10800210 	cmplti	r2,r2,8
 40132d4:	1000071e 	bne	r2,zero,40132f4 <___vfiprintf_internal_r+0xf50>
 40132d8:	e0bfe604 	addi	r2,fp,-104
 40132dc:	100d883a 	mov	r6,r2
 40132e0:	e17fc917 	ldw	r5,-220(fp)
 40132e4:	e13fca17 	ldw	r4,-216(fp)
 40132e8:	40121340 	call	4012134 <__sprint_r>
 40132ec:	1000b41e 	bne	r2,zero,40135c0 <___vfiprintf_internal_r+0x121c>
 40132f0:	e43fd604 	addi	r16,fp,-168
		PAD (dprec - size, zeroes);
 40132f4:	e0fff117 	ldw	r3,-60(fp)
 40132f8:	e0bfef17 	ldw	r2,-68(fp)
 40132fc:	18a7c83a 	sub	r19,r3,r2
 4013300:	04c0310e 	bge	zero,r19,40133c8 <___vfiprintf_internal_r+0x1024>
 4013304:	00001706 	br	4013364 <___vfiprintf_internal_r+0xfc0>
 4013308:	008100b4 	movhi	r2,1026
 401330c:	10abc604 	addi	r2,r2,-20712
 4013310:	80800015 	stw	r2,0(r16)
 4013314:	00800404 	movi	r2,16
 4013318:	80800115 	stw	r2,4(r16)
 401331c:	e0bfe817 	ldw	r2,-96(fp)
 4013320:	10800404 	addi	r2,r2,16
 4013324:	e0bfe815 	stw	r2,-96(fp)
 4013328:	84000204 	addi	r16,r16,8
 401332c:	e0bfe717 	ldw	r2,-100(fp)
 4013330:	10800044 	addi	r2,r2,1
 4013334:	e0bfe715 	stw	r2,-100(fp)
 4013338:	e0bfe717 	ldw	r2,-100(fp)
 401333c:	10800210 	cmplti	r2,r2,8
 4013340:	1000071e 	bne	r2,zero,4013360 <___vfiprintf_internal_r+0xfbc>
 4013344:	e0bfe604 	addi	r2,fp,-104
 4013348:	100d883a 	mov	r6,r2
 401334c:	e17fc917 	ldw	r5,-220(fp)
 4013350:	e13fca17 	ldw	r4,-216(fp)
 4013354:	40121340 	call	4012134 <__sprint_r>
 4013358:	10009b1e 	bne	r2,zero,40135c8 <___vfiprintf_internal_r+0x1224>
 401335c:	e43fd604 	addi	r16,fp,-168
 4013360:	9cfffc04 	addi	r19,r19,-16
 4013364:	98800448 	cmpgei	r2,r19,17
 4013368:	103fe71e 	bne	r2,zero,4013308 <___vfiprintf_internal_r+0xf64>
 401336c:	008100b4 	movhi	r2,1026
 4013370:	10abc604 	addi	r2,r2,-20712
 4013374:	80800015 	stw	r2,0(r16)
 4013378:	9805883a 	mov	r2,r19
 401337c:	80800115 	stw	r2,4(r16)
 4013380:	e0bfe817 	ldw	r2,-96(fp)
 4013384:	9807883a 	mov	r3,r19
 4013388:	10c5883a 	add	r2,r2,r3
 401338c:	e0bfe815 	stw	r2,-96(fp)
 4013390:	84000204 	addi	r16,r16,8
 4013394:	e0bfe717 	ldw	r2,-100(fp)
 4013398:	10800044 	addi	r2,r2,1
 401339c:	e0bfe715 	stw	r2,-100(fp)
 40133a0:	e0bfe717 	ldw	r2,-100(fp)
 40133a4:	10800210 	cmplti	r2,r2,8
 40133a8:	1000071e 	bne	r2,zero,40133c8 <___vfiprintf_internal_r+0x1024>
 40133ac:	e0bfe604 	addi	r2,fp,-104
 40133b0:	100d883a 	mov	r6,r2
 40133b4:	e17fc917 	ldw	r5,-220(fp)
 40133b8:	e13fca17 	ldw	r4,-216(fp)
 40133bc:	40121340 	call	4012134 <__sprint_r>
 40133c0:	1000831e 	bne	r2,zero,40135d0 <___vfiprintf_internal_r+0x122c>
 40133c4:	e43fd604 	addi	r16,fp,-168
		PRINT (cp, size);
 40133c8:	84800015 	stw	r18,0(r16)
 40133cc:	e0bfef17 	ldw	r2,-68(fp)
 40133d0:	80800115 	stw	r2,4(r16)
 40133d4:	e0ffe817 	ldw	r3,-96(fp)
 40133d8:	e0bfef17 	ldw	r2,-68(fp)
 40133dc:	1885883a 	add	r2,r3,r2
 40133e0:	e0bfe815 	stw	r2,-96(fp)
 40133e4:	84000204 	addi	r16,r16,8
 40133e8:	e0bfe717 	ldw	r2,-100(fp)
 40133ec:	10800044 	addi	r2,r2,1
 40133f0:	e0bfe715 	stw	r2,-100(fp)
 40133f4:	e0bfe717 	ldw	r2,-100(fp)
 40133f8:	10800210 	cmplti	r2,r2,8
 40133fc:	1000071e 	bne	r2,zero,401341c <___vfiprintf_internal_r+0x1078>
 4013400:	e0bfe604 	addi	r2,fp,-104
 4013404:	100d883a 	mov	r6,r2
 4013408:	e17fc917 	ldw	r5,-220(fp)
 401340c:	e13fca17 	ldw	r4,-216(fp)
 4013410:	40121340 	call	4012134 <__sprint_r>
 4013414:	1000701e 	bne	r2,zero,40135d8 <___vfiprintf_internal_r+0x1234>
 4013418:	e43fd604 	addi	r16,fp,-168
		if (flags & LADJUST)
 401341c:	8880010c 	andi	r2,r17,4
 4013420:	10003526 	beq	r2,zero,40134f8 <___vfiprintf_internal_r+0x1154>
			PAD (width - realsz, blanks);
 4013424:	e0fff617 	ldw	r3,-40(fp)
 4013428:	e0bff017 	ldw	r2,-64(fp)
 401342c:	18a7c83a 	sub	r19,r3,r2
 4013430:	04c0310e 	bge	zero,r19,40134f8 <___vfiprintf_internal_r+0x1154>
 4013434:	00001706 	br	4013494 <___vfiprintf_internal_r+0x10f0>
 4013438:	008100b4 	movhi	r2,1026
 401343c:	10abc204 	addi	r2,r2,-20728
 4013440:	80800015 	stw	r2,0(r16)
 4013444:	00800404 	movi	r2,16
 4013448:	80800115 	stw	r2,4(r16)
 401344c:	e0bfe817 	ldw	r2,-96(fp)
 4013450:	10800404 	addi	r2,r2,16
 4013454:	e0bfe815 	stw	r2,-96(fp)
 4013458:	84000204 	addi	r16,r16,8
 401345c:	e0bfe717 	ldw	r2,-100(fp)
 4013460:	10800044 	addi	r2,r2,1
 4013464:	e0bfe715 	stw	r2,-100(fp)
 4013468:	e0bfe717 	ldw	r2,-100(fp)
 401346c:	10800210 	cmplti	r2,r2,8
 4013470:	1000071e 	bne	r2,zero,4013490 <___vfiprintf_internal_r+0x10ec>
 4013474:	e0bfe604 	addi	r2,fp,-104
 4013478:	100d883a 	mov	r6,r2
 401347c:	e17fc917 	ldw	r5,-220(fp)
 4013480:	e13fca17 	ldw	r4,-216(fp)
 4013484:	40121340 	call	4012134 <__sprint_r>
 4013488:	1000551e 	bne	r2,zero,40135e0 <___vfiprintf_internal_r+0x123c>
 401348c:	e43fd604 	addi	r16,fp,-168
 4013490:	9cfffc04 	addi	r19,r19,-16
 4013494:	98800448 	cmpgei	r2,r19,17
 4013498:	103fe71e 	bne	r2,zero,4013438 <___vfiprintf_internal_r+0x1094>
 401349c:	008100b4 	movhi	r2,1026
 40134a0:	10abc204 	addi	r2,r2,-20728
 40134a4:	80800015 	stw	r2,0(r16)
 40134a8:	9805883a 	mov	r2,r19
 40134ac:	80800115 	stw	r2,4(r16)
 40134b0:	e0bfe817 	ldw	r2,-96(fp)
 40134b4:	9807883a 	mov	r3,r19
 40134b8:	10c5883a 	add	r2,r2,r3
 40134bc:	e0bfe815 	stw	r2,-96(fp)
 40134c0:	84000204 	addi	r16,r16,8
 40134c4:	e0bfe717 	ldw	r2,-100(fp)
 40134c8:	10800044 	addi	r2,r2,1
 40134cc:	e0bfe715 	stw	r2,-100(fp)
 40134d0:	e0bfe717 	ldw	r2,-100(fp)
 40134d4:	10800210 	cmplti	r2,r2,8
 40134d8:	1000071e 	bne	r2,zero,40134f8 <___vfiprintf_internal_r+0x1154>
 40134dc:	e0bfe604 	addi	r2,fp,-104
 40134e0:	100d883a 	mov	r6,r2
 40134e4:	e17fc917 	ldw	r5,-220(fp)
 40134e8:	e13fca17 	ldw	r4,-216(fp)
 40134ec:	40121340 	call	4012134 <__sprint_r>
 40134f0:	10003d1e 	bne	r2,zero,40135e8 <___vfiprintf_internal_r+0x1244>
 40134f4:	e43fd604 	addi	r16,fp,-168
		ret += width > realsz ? width : realsz;
 40134f8:	e0fff617 	ldw	r3,-40(fp)
 40134fc:	e0bff017 	ldw	r2,-64(fp)
 4013500:	10c0010e 	bge	r2,r3,4013508 <___vfiprintf_internal_r+0x1164>
 4013504:	1805883a 	mov	r2,r3
 4013508:	e0fff717 	ldw	r3,-36(fp)
 401350c:	1885883a 	add	r2,r3,r2
 4013510:	e0bff715 	stw	r2,-36(fp)
		FLUSH ();	/* copy out the I/O vectors */
 4013514:	e0bfe817 	ldw	r2,-96(fp)
 4013518:	10000626 	beq	r2,zero,4013534 <___vfiprintf_internal_r+0x1190>
 401351c:	e0bfe604 	addi	r2,fp,-104
 4013520:	100d883a 	mov	r6,r2
 4013524:	e17fc917 	ldw	r5,-220(fp)
 4013528:	e13fca17 	ldw	r4,-216(fp)
 401352c:	40121340 	call	4012134 <__sprint_r>
 4013530:	10002f1e 	bne	r2,zero,40135f0 <___vfiprintf_internal_r+0x124c>
 4013534:	e03fe715 	stw	zero,-100(fp)
 4013538:	e43fd604 	addi	r16,fp,-168
                if (malloc_buf != NULL) {
 401353c:	e0bfed17 	ldw	r2,-76(fp)
 4013540:	103beb26 	beq	r2,zero,40124f0 <___vfiprintf_internal_r+0x14c>
			_free_r (data, malloc_buf);
 4013544:	e17fed17 	ldw	r5,-76(fp)
 4013548:	e13fca17 	ldw	r4,-216(fp)
 401354c:	400cdd80 	call	400cdd8 <_free_r>
			malloc_buf = NULL;
 4013550:	e03fed15 	stw	zero,-76(fp)
	        cp = fmt;
 4013554:	003be606 	br	40124f0 <___vfiprintf_internal_r+0x14c>
                    goto done;
 4013558:	0001883a 	nop
 401355c:	00000106 	br	4013564 <___vfiprintf_internal_r+0x11c0>
				goto done;
 4013560:	0001883a 	nop
	FLUSH ();
 4013564:	e0bfe817 	ldw	r2,-96(fp)
 4013568:	10000626 	beq	r2,zero,4013584 <___vfiprintf_internal_r+0x11e0>
 401356c:	e0bfe604 	addi	r2,fp,-104
 4013570:	100d883a 	mov	r6,r2
 4013574:	e17fc917 	ldw	r5,-220(fp)
 4013578:	e13fca17 	ldw	r4,-216(fp)
 401357c:	40121340 	call	4012134 <__sprint_r>
 4013580:	10001d1e 	bne	r2,zero,40135f8 <___vfiprintf_internal_r+0x1254>
 4013584:	e03fe715 	stw	zero,-100(fp)
 4013588:	e43fd604 	addi	r16,fp,-168
 401358c:	00001b06 	br	40135fc <___vfiprintf_internal_r+0x1258>
			PRINT (cp, m);
 4013590:	0001883a 	nop
 4013594:	00001906 	br	40135fc <___vfiprintf_internal_r+0x1258>
			PAD (width - realsz, blanks);
 4013598:	0001883a 	nop
 401359c:	00001706 	br	40135fc <___vfiprintf_internal_r+0x1258>
 40135a0:	0001883a 	nop
 40135a4:	00001506 	br	40135fc <___vfiprintf_internal_r+0x1258>
			PRINT (&sign, 1);
 40135a8:	0001883a 	nop
 40135ac:	00001306 	br	40135fc <___vfiprintf_internal_r+0x1258>
			PRINT (ox, 2);
 40135b0:	0001883a 	nop
 40135b4:	00001106 	br	40135fc <___vfiprintf_internal_r+0x1258>
			PAD (width - realsz, zeroes);
 40135b8:	0001883a 	nop
 40135bc:	00000f06 	br	40135fc <___vfiprintf_internal_r+0x1258>
 40135c0:	0001883a 	nop
 40135c4:	00000d06 	br	40135fc <___vfiprintf_internal_r+0x1258>
		PAD (dprec - size, zeroes);
 40135c8:	0001883a 	nop
 40135cc:	00000b06 	br	40135fc <___vfiprintf_internal_r+0x1258>
 40135d0:	0001883a 	nop
 40135d4:	00000906 	br	40135fc <___vfiprintf_internal_r+0x1258>
		PRINT (cp, size);
 40135d8:	0001883a 	nop
 40135dc:	00000706 	br	40135fc <___vfiprintf_internal_r+0x1258>
			PAD (width - realsz, blanks);
 40135e0:	0001883a 	nop
 40135e4:	00000506 	br	40135fc <___vfiprintf_internal_r+0x1258>
 40135e8:	0001883a 	nop
 40135ec:	00000306 	br	40135fc <___vfiprintf_internal_r+0x1258>
		FLUSH ();	/* copy out the I/O vectors */
 40135f0:	0001883a 	nop
 40135f4:	00000106 	br	40135fc <___vfiprintf_internal_r+0x1258>
	FLUSH ();
 40135f8:	0001883a 	nop
	if (malloc_buf != NULL)
 40135fc:	e0bfed17 	ldw	r2,-76(fp)
 4013600:	10000326 	beq	r2,zero,4013610 <___vfiprintf_internal_r+0x126c>
		_free_r (data, malloc_buf);
 4013604:	e17fed17 	ldw	r5,-76(fp)
 4013608:	e13fca17 	ldw	r4,-216(fp)
 401360c:	400cdd80 	call	400cdd8 <_free_r>
	return (__sferror (fp) ? EOF : ret);
 4013610:	e0bfc917 	ldw	r2,-220(fp)
 4013614:	1080030b 	ldhu	r2,12(r2)
 4013618:	10bfffcc 	andi	r2,r2,65535
 401361c:	1080100c 	andi	r2,r2,64
 4013620:	1000021e 	bne	r2,zero,401362c <___vfiprintf_internal_r+0x1288>
 4013624:	e0bff717 	ldw	r2,-36(fp)
 4013628:	00000106 	br	4013630 <___vfiprintf_internal_r+0x128c>
 401362c:	00bfffc4 	movi	r2,-1
}
 4013630:	e6fff804 	addi	sp,fp,-32
 4013634:	dfc00917 	ldw	ra,36(sp)
 4013638:	df000817 	ldw	fp,32(sp)
 401363c:	ddc00717 	ldw	r23,28(sp)
 4013640:	dd800617 	ldw	r22,24(sp)
 4013644:	dd400517 	ldw	r21,20(sp)
 4013648:	dd000417 	ldw	r20,16(sp)
 401364c:	dcc00317 	ldw	r19,12(sp)
 4013650:	dc800217 	ldw	r18,8(sp)
 4013654:	dc400117 	ldw	r17,4(sp)
 4013658:	dc000017 	ldw	r16,0(sp)
 401365c:	dec00a04 	addi	sp,sp,40
 4013660:	f800283a 	ret

04013664 <__get_global_locale>:
{
 4013664:	deffff04 	addi	sp,sp,-4
 4013668:	df000015 	stw	fp,0(sp)
 401366c:	d839883a 	mov	fp,sp
  return &__global_locale;
 4013670:	008100b4 	movhi	r2,1026
 4013674:	10add804 	addi	r2,r2,-18592
}
 4013678:	e037883a 	mov	sp,fp
 401367c:	df000017 	ldw	fp,0(sp)
 4013680:	dec00104 	addi	sp,sp,4
 4013684:	f800283a 	ret

04013688 <__get_current_locale>:
{
 4013688:	defffe04 	addi	sp,sp,-8
 401368c:	dfc00115 	stw	ra,4(sp)
 4013690:	df000015 	stw	fp,0(sp)
 4013694:	d839883a 	mov	fp,sp
  return __get_global_locale();
 4013698:	40136640 	call	4013664 <__get_global_locale>
}
 401369c:	e037883a 	mov	sp,fp
 40136a0:	dfc00117 	ldw	ra,4(sp)
 40136a4:	df000017 	ldw	fp,0(sp)
 40136a8:	dec00204 	addi	sp,sp,8
 40136ac:	f800283a 	ret

040136b0 <_wctomb_r>:
int
_wctomb_r (struct _reent *r,
        char          *s,
        wchar_t        _wchar,
        mbstate_t     *state)
{
 40136b0:	defffa04 	addi	sp,sp,-24
 40136b4:	dfc00515 	stw	ra,20(sp)
 40136b8:	df000415 	stw	fp,16(sp)
 40136bc:	df000404 	addi	fp,sp,16
 40136c0:	e13fff15 	stw	r4,-4(fp)
 40136c4:	e17ffe15 	stw	r5,-8(fp)
 40136c8:	e1bffd15 	stw	r6,-12(fp)
 40136cc:	e1fffc15 	stw	r7,-16(fp)
  return __WCTOMB (r, s, _wchar, state);
 40136d0:	40136880 	call	4013688 <__get_current_locale>
 40136d4:	10803817 	ldw	r2,224(r2)
 40136d8:	e1fffc17 	ldw	r7,-16(fp)
 40136dc:	e1bffd17 	ldw	r6,-12(fp)
 40136e0:	e17ffe17 	ldw	r5,-8(fp)
 40136e4:	e13fff17 	ldw	r4,-4(fp)
 40136e8:	103ee83a 	callr	r2
}
 40136ec:	e037883a 	mov	sp,fp
 40136f0:	dfc00117 	ldw	ra,4(sp)
 40136f4:	df000017 	ldw	fp,0(sp)
 40136f8:	dec00204 	addi	sp,sp,8
 40136fc:	f800283a 	ret

04013700 <__ascii_wctomb>:
int
__ascii_wctomb (struct _reent *r,
        char          *s,
        wchar_t        _wchar,
        mbstate_t     *state)
{
 4013700:	defffa04 	addi	sp,sp,-24
 4013704:	df000515 	stw	fp,20(sp)
 4013708:	df000504 	addi	fp,sp,20
 401370c:	e13ffe15 	stw	r4,-8(fp)
 4013710:	e17ffd15 	stw	r5,-12(fp)
 4013714:	e1bffc15 	stw	r6,-16(fp)
 4013718:	e1fffb15 	stw	r7,-20(fp)
  /* Avoids compiler warnings about comparisons that are always false
     due to limited range when sizeof(wchar_t) is 2 but sizeof(wint_t)
     is 4, as is the case on cygwin.  */
  wint_t wchar = _wchar;
 401371c:	e0bffc17 	ldw	r2,-16(fp)
 4013720:	e0bfff15 	stw	r2,-4(fp)

  if (s == NULL)
 4013724:	e0bffd17 	ldw	r2,-12(fp)
 4013728:	1000021e 	bne	r2,zero,4013734 <__ascii_wctomb+0x34>
    return 0;
 401372c:	0005883a 	mov	r2,zero
 4013730:	00000d06 	br	4013768 <__ascii_wctomb+0x68>
 
#ifdef __CYGWIN__
  if ((size_t)wchar >= 0x80)
#else
  if ((size_t)wchar >= 0x100)
 4013734:	e0bfff17 	ldw	r2,-4(fp)
 4013738:	10804030 	cmpltui	r2,r2,256
 401373c:	1000051e 	bne	r2,zero,4013754 <__ascii_wctomb+0x54>
#endif
    {
      r->_errno = EILSEQ;
 4013740:	e0bffe17 	ldw	r2,-8(fp)
 4013744:	00c02284 	movi	r3,138
 4013748:	10c00015 	stw	r3,0(r2)
      return -1;
 401374c:	00bfffc4 	movi	r2,-1
 4013750:	00000506 	br	4013768 <__ascii_wctomb+0x68>
    }

  *s = (char) wchar;
 4013754:	e0bfff17 	ldw	r2,-4(fp)
 4013758:	1007883a 	mov	r3,r2
 401375c:	e0bffd17 	ldw	r2,-12(fp)
 4013760:	10c00005 	stb	r3,0(r2)
  return 1;
 4013764:	00800044 	movi	r2,1
}
 4013768:	e037883a 	mov	sp,fp
 401376c:	df000017 	ldw	fp,0(sp)
 4013770:	dec00104 	addi	sp,sp,4
 4013774:	f800283a 	ret

04013778 <_write_r>:
_ssize_t
_write_r (struct _reent *ptr,
     int fd,
     const void *buf,
     size_t cnt)
{
 4013778:	defff904 	addi	sp,sp,-28
 401377c:	dfc00615 	stw	ra,24(sp)
 4013780:	df000515 	stw	fp,20(sp)
 4013784:	df000504 	addi	fp,sp,20
 4013788:	e13ffe15 	stw	r4,-8(fp)
 401378c:	e17ffd15 	stw	r5,-12(fp)
 4013790:	e1bffc15 	stw	r6,-16(fp)
 4013794:	e1fffb15 	stw	r7,-20(fp)
  _ssize_t ret;

  errno = 0;
 4013798:	d0272915 	stw	zero,-25436(gp)
  if ((ret = (_ssize_t)_write (fd, buf, cnt)) == -1 && errno != 0)
 401379c:	e1bffb17 	ldw	r6,-20(fp)
 40137a0:	e17ffc17 	ldw	r5,-16(fp)
 40137a4:	e13ffd17 	ldw	r4,-12(fp)
 40137a8:	4018aa80 	call	4018aa8 <write>
 40137ac:	e0bfff15 	stw	r2,-4(fp)
 40137b0:	e0bfff17 	ldw	r2,-4(fp)
 40137b4:	10bfffd8 	cmpnei	r2,r2,-1
 40137b8:	1000051e 	bne	r2,zero,40137d0 <_write_r+0x58>
 40137bc:	d0a72917 	ldw	r2,-25436(gp)
 40137c0:	10000326 	beq	r2,zero,40137d0 <_write_r+0x58>
    ptr->_errno = errno;
 40137c4:	d0e72917 	ldw	r3,-25436(gp)
 40137c8:	e0bffe17 	ldw	r2,-8(fp)
 40137cc:	10c00015 	stw	r3,0(r2)
  return ret;
 40137d0:	e0bfff17 	ldw	r2,-4(fp)
}
 40137d4:	e037883a 	mov	sp,fp
 40137d8:	dfc00117 	ldw	ra,4(sp)
 40137dc:	df000017 	ldw	fp,0(sp)
 40137e0:	dec00204 	addi	sp,sp,8
 40137e4:	f800283a 	ret

040137e8 <_close_r>:

int
_close_r (ptr, fd)
     struct _reent *ptr;
     int fd;
{
 40137e8:	defffb04 	addi	sp,sp,-20
 40137ec:	dfc00415 	stw	ra,16(sp)
 40137f0:	df000315 	stw	fp,12(sp)
 40137f4:	df000304 	addi	fp,sp,12
 40137f8:	e13ffe15 	stw	r4,-8(fp)
 40137fc:	e17ffd15 	stw	r5,-12(fp)
  int ret;

  errno = 0;
 4013800:	d0272915 	stw	zero,-25436(gp)
  if ((ret = _close (fd)) == -1 && errno != 0)
 4013804:	e13ffd17 	ldw	r4,-12(fp)
 4013808:	4017df00 	call	4017df0 <close>
 401380c:	e0bfff15 	stw	r2,-4(fp)
 4013810:	e0bfff17 	ldw	r2,-4(fp)
 4013814:	10bfffd8 	cmpnei	r2,r2,-1
 4013818:	1000051e 	bne	r2,zero,4013830 <_close_r+0x48>
 401381c:	d0a72917 	ldw	r2,-25436(gp)
 4013820:	10000326 	beq	r2,zero,4013830 <_close_r+0x48>
    ptr->_errno = errno;
 4013824:	d0e72917 	ldw	r3,-25436(gp)
 4013828:	e0bffe17 	ldw	r2,-8(fp)
 401382c:	10c00015 	stw	r3,0(r2)
  return ret;
 4013830:	e0bfff17 	ldw	r2,-4(fp)
}
 4013834:	e037883a 	mov	sp,fp
 4013838:	dfc00117 	ldw	ra,4(sp)
 401383c:	df000017 	ldw	fp,0(sp)
 4013840:	dec00204 	addi	sp,sp,8
 4013844:	f800283a 	ret

04013848 <__assert_func>:
void
__assert_func (const char *file,
	int line,
	const char *func,
	const char *failedexpr)
{
 4013848:	defff704 	addi	sp,sp,-36
 401384c:	dfc00815 	stw	ra,32(sp)
 4013850:	df000715 	stw	fp,28(sp)
 4013854:	df000704 	addi	fp,sp,28
 4013858:	e13fff15 	stw	r4,-4(fp)
 401385c:	e17ffe15 	stw	r5,-8(fp)
 4013860:	e1bffd15 	stw	r6,-12(fp)
 4013864:	e1fffc15 	stw	r7,-16(fp)
  fiprintf(stderr,
 4013868:	d0a00117 	ldw	r2,-32764(gp)
 401386c:	11000317 	ldw	r4,12(r2)
 4013870:	e0bffd17 	ldw	r2,-12(fp)
 4013874:	10000326 	beq	r2,zero,4013884 <__assert_func+0x3c>
 4013878:	008100b4 	movhi	r2,1026
 401387c:	10abca04 	addi	r2,r2,-20696
 4013880:	00000206 	br	401388c <__assert_func+0x44>
 4013884:	008100b4 	movhi	r2,1026
 4013888:	10abce04 	addi	r2,r2,-20680
 401388c:	e0fffd17 	ldw	r3,-12(fp)
 4013890:	18000226 	beq	r3,zero,401389c <__assert_func+0x54>
 4013894:	e0fffd17 	ldw	r3,-12(fp)
 4013898:	00000206 	br	40138a4 <__assert_func+0x5c>
 401389c:	00c100b4 	movhi	r3,1026
 40138a0:	18ebce04 	addi	r3,r3,-20680
 40138a4:	d8c00215 	stw	r3,8(sp)
 40138a8:	d8800115 	stw	r2,4(sp)
 40138ac:	e0bffe17 	ldw	r2,-8(fp)
 40138b0:	d8800015 	stw	r2,0(sp)
 40138b4:	e1ffff17 	ldw	r7,-4(fp)
 40138b8:	e1bffc17 	ldw	r6,-16(fp)
 40138bc:	014100b4 	movhi	r5,1026
 40138c0:	296bcf04 	addi	r5,r5,-20676
 40138c4:	4013c200 	call	4013c20 <fiprintf>
	   "assertion \"%s\" failed: file \"%s\", line %d%s%s\n",
	   failedexpr, file, line,
	   func ? ", function: " : "", func ? func : "");
  abort();
 40138c8:	40144a40 	call	40144a4 <abort>

040138cc <__assert>:

void
__assert (const char *file,
	int line,
	const char *failedexpr)
{
 40138cc:	defffb04 	addi	sp,sp,-20
 40138d0:	dfc00415 	stw	ra,16(sp)
 40138d4:	df000315 	stw	fp,12(sp)
 40138d8:	df000304 	addi	fp,sp,12
 40138dc:	e13fff15 	stw	r4,-4(fp)
 40138e0:	e17ffe15 	stw	r5,-8(fp)
 40138e4:	e1bffd15 	stw	r6,-12(fp)
   __assert_func (file, line, NULL, failedexpr);
 40138e8:	e1fffd17 	ldw	r7,-12(fp)
 40138ec:	000d883a 	mov	r6,zero
 40138f0:	e17ffe17 	ldw	r5,-8(fp)
 40138f4:	e13fff17 	ldw	r4,-4(fp)
 40138f8:	40138480 	call	4013848 <__assert_func>

040138fc <_calloc_r>:
{
 40138fc:	defff504 	addi	sp,sp,-44
 4013900:	dfc00a15 	stw	ra,40(sp)
 4013904:	df000915 	stw	fp,36(sp)
 4013908:	df000904 	addi	fp,sp,36
 401390c:	e13ff915 	stw	r4,-28(fp)
 4013910:	e17ff815 	stw	r5,-32(fp)
 4013914:	e1bff715 	stw	r6,-36(fp)
  INTERNAL_SIZE_T sz = n * elem_size;
 4013918:	e17ff717 	ldw	r5,-36(fp)
 401391c:	e13ff817 	ldw	r4,-32(fp)
 4013920:	40075a40 	call	40075a4 <__mulsi3>
 4013924:	e0bffe15 	stw	r2,-8(fp)
  mem = mALLOc (RCALL sz);
 4013928:	e17ffe17 	ldw	r5,-8(fp)
 401392c:	e13ff917 	ldw	r4,-28(fp)
 4013930:	400e5500 	call	400e550 <_malloc_r>
 4013934:	e0bffd15 	stw	r2,-12(fp)
  if (mem == 0) 
 4013938:	e0bffd17 	ldw	r2,-12(fp)
 401393c:	1000021e 	bne	r2,zero,4013948 <_calloc_r+0x4c>
    return 0;
 4013940:	0005883a 	mov	r2,zero
 4013944:	00004106 	br	4013a4c <_calloc_r+0x150>
    p = mem2chunk(mem);
 4013948:	e0bffd17 	ldw	r2,-12(fp)
 401394c:	10bffe04 	addi	r2,r2,-8
 4013950:	e0bffc15 	stw	r2,-16(fp)
    csz = chunksize(p);
 4013954:	e0bffc17 	ldw	r2,-16(fp)
 4013958:	10c00117 	ldw	r3,4(r2)
 401395c:	00bfff04 	movi	r2,-4
 4013960:	1884703a 	and	r2,r3,r2
 4013964:	e0bffb15 	stw	r2,-20(fp)
    MALLOC_ZERO(mem, csz - SIZE_SZ);
 4013968:	e0bffb17 	ldw	r2,-20(fp)
 401396c:	10bfff04 	addi	r2,r2,-4
 4013970:	e0bffa15 	stw	r2,-24(fp)
 4013974:	e0bffa17 	ldw	r2,-24(fp)
 4013978:	10800968 	cmpgeui	r2,r2,37
 401397c:	10002e1e 	bne	r2,zero,4013a38 <_calloc_r+0x13c>
 4013980:	e0bffd17 	ldw	r2,-12(fp)
 4013984:	e0bfff15 	stw	r2,-4(fp)
 4013988:	e0bffa17 	ldw	r2,-24(fp)
 401398c:	10800530 	cmpltui	r2,r2,20
 4013990:	10001e1e 	bne	r2,zero,4013a0c <_calloc_r+0x110>
 4013994:	e0bfff17 	ldw	r2,-4(fp)
 4013998:	10c00104 	addi	r3,r2,4
 401399c:	e0ffff15 	stw	r3,-4(fp)
 40139a0:	10000015 	stw	zero,0(r2)
 40139a4:	e0bfff17 	ldw	r2,-4(fp)
 40139a8:	10c00104 	addi	r3,r2,4
 40139ac:	e0ffff15 	stw	r3,-4(fp)
 40139b0:	10000015 	stw	zero,0(r2)
 40139b4:	e0bffa17 	ldw	r2,-24(fp)
 40139b8:	10800730 	cmpltui	r2,r2,28
 40139bc:	1000131e 	bne	r2,zero,4013a0c <_calloc_r+0x110>
 40139c0:	e0bfff17 	ldw	r2,-4(fp)
 40139c4:	10c00104 	addi	r3,r2,4
 40139c8:	e0ffff15 	stw	r3,-4(fp)
 40139cc:	10000015 	stw	zero,0(r2)
 40139d0:	e0bfff17 	ldw	r2,-4(fp)
 40139d4:	10c00104 	addi	r3,r2,4
 40139d8:	e0ffff15 	stw	r3,-4(fp)
 40139dc:	10000015 	stw	zero,0(r2)
 40139e0:	e0bffa17 	ldw	r2,-24(fp)
 40139e4:	10800930 	cmpltui	r2,r2,36
 40139e8:	1000081e 	bne	r2,zero,4013a0c <_calloc_r+0x110>
 40139ec:	e0bfff17 	ldw	r2,-4(fp)
 40139f0:	10c00104 	addi	r3,r2,4
 40139f4:	e0ffff15 	stw	r3,-4(fp)
 40139f8:	10000015 	stw	zero,0(r2)
 40139fc:	e0bfff17 	ldw	r2,-4(fp)
 4013a00:	10c00104 	addi	r3,r2,4
 4013a04:	e0ffff15 	stw	r3,-4(fp)
 4013a08:	10000015 	stw	zero,0(r2)
 4013a0c:	e0bfff17 	ldw	r2,-4(fp)
 4013a10:	10c00104 	addi	r3,r2,4
 4013a14:	e0ffff15 	stw	r3,-4(fp)
 4013a18:	10000015 	stw	zero,0(r2)
 4013a1c:	e0bfff17 	ldw	r2,-4(fp)
 4013a20:	10c00104 	addi	r3,r2,4
 4013a24:	e0ffff15 	stw	r3,-4(fp)
 4013a28:	10000015 	stw	zero,0(r2)
 4013a2c:	e0bfff17 	ldw	r2,-4(fp)
 4013a30:	10000015 	stw	zero,0(r2)
 4013a34:	00000406 	br	4013a48 <_calloc_r+0x14c>
 4013a38:	e1bffa17 	ldw	r6,-24(fp)
 4013a3c:	000b883a 	mov	r5,zero
 4013a40:	e13ffd17 	ldw	r4,-12(fp)
 4013a44:	40077540 	call	4007754 <memset>
    return mem;
 4013a48:	e0bffd17 	ldw	r2,-12(fp)
}
 4013a4c:	e037883a 	mov	sp,fp
 4013a50:	dfc00117 	ldw	ra,4(sp)
 4013a54:	df000017 	ldw	fp,0(sp)
 4013a58:	dec00204 	addi	sp,sp,8
 4013a5c:	f800283a 	ret

04013a60 <_fclose_r>:
#include "local.h"

int
_fclose_r (struct _reent *rptr,
      register FILE * fp)
{
 4013a60:	defffa04 	addi	sp,sp,-24
 4013a64:	dfc00515 	stw	ra,20(sp)
 4013a68:	df000415 	stw	fp,16(sp)
 4013a6c:	dc000315 	stw	r16,12(sp)
 4013a70:	df000404 	addi	fp,sp,16
 4013a74:	e13ffc15 	stw	r4,-16(fp)
 4013a78:	2821883a 	mov	r16,r5
  int r;

  if (fp == NULL)
 4013a7c:	8000021e 	bne	r16,zero,4013a88 <_fclose_r+0x28>
    return (0);			/* on NULL */
 4013a80:	0005883a 	mov	r2,zero
 4013a84:	00003b06 	br	4013b74 <_fclose_r+0x114>

  CHECK_INIT (rptr, fp);
 4013a88:	e0bffc17 	ldw	r2,-16(fp)
 4013a8c:	e0bffd15 	stw	r2,-12(fp)
 4013a90:	e0bffd17 	ldw	r2,-12(fp)
 4013a94:	10000526 	beq	r2,zero,4013aac <_fclose_r+0x4c>
 4013a98:	e0bffd17 	ldw	r2,-12(fp)
 4013a9c:	10800e17 	ldw	r2,56(r2)
 4013aa0:	1000021e 	bne	r2,zero,4013aac <_fclose_r+0x4c>
 4013aa4:	e13ffd17 	ldw	r4,-12(fp)
 4013aa8:	400cbdc0 	call	400cbdc <__sinit>
  pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, &__oldcancel);
#endif
  if (!(fp->_flags2 & __SNLK))
    _flockfile (fp);

  if (fp->_flags == 0)		/* not open! */
 4013aac:	8080030b 	ldhu	r2,12(r16)
 4013ab0:	10bfffcc 	andi	r2,r2,65535
 4013ab4:	10a0001c 	xori	r2,r2,32768
 4013ab8:	10a00004 	addi	r2,r2,-32768
 4013abc:	1000021e 	bne	r2,zero,4013ac8 <_fclose_r+0x68>
      if (!(fp->_flags2 & __SNLK))
	_funlockfile (fp);
#ifdef _STDIO_WITH_THREAD_CANCELLATION_SUPPORT
      pthread_setcancelstate (__oldcancel, &__oldcancel);
#endif
      return (0);
 4013ac0:	0005883a 	mov	r2,zero
 4013ac4:	00002b06 	br	4013b74 <_fclose_r+0x114>
  r = (fp->_flags & __SWR) ? __sflush_r (rptr, fp) : 0;
#else
  /* Follow POSIX semantics exactly.  Unconditionally flush to allow
     special handling for seekable read files to reposition file to last
     byte processed as opposed to last byte read ahead into the buffer. */
  r = __sflush_r (rptr, fp);
 4013ac8:	800b883a 	mov	r5,r16
 4013acc:	e13ffc17 	ldw	r4,-16(fp)
 4013ad0:	400c3980 	call	400c398 <__sflush_r>
 4013ad4:	e0bffe15 	stw	r2,-8(fp)
#endif
  if (fp->_close != NULL && fp->_close (rptr, fp->_cookie) < 0)
 4013ad8:	80800b17 	ldw	r2,44(r16)
 4013adc:	10000826 	beq	r2,zero,4013b00 <_fclose_r+0xa0>
 4013ae0:	80800b17 	ldw	r2,44(r16)
 4013ae4:	80c00717 	ldw	r3,28(r16)
 4013ae8:	180b883a 	mov	r5,r3
 4013aec:	e13ffc17 	ldw	r4,-16(fp)
 4013af0:	103ee83a 	callr	r2
 4013af4:	1000020e 	bge	r2,zero,4013b00 <_fclose_r+0xa0>
    r = EOF;
 4013af8:	00bfffc4 	movi	r2,-1
 4013afc:	e0bffe15 	stw	r2,-8(fp)
  if (fp->_flags & __SMBF)
 4013b00:	8080030b 	ldhu	r2,12(r16)
 4013b04:	10bfffcc 	andi	r2,r2,65535
 4013b08:	1080200c 	andi	r2,r2,128
 4013b0c:	10000426 	beq	r2,zero,4013b20 <_fclose_r+0xc0>
    _free_r (rptr, (char *) fp->_bf._base);
 4013b10:	80800417 	ldw	r2,16(r16)
 4013b14:	100b883a 	mov	r5,r2
 4013b18:	e13ffc17 	ldw	r4,-16(fp)
 4013b1c:	400cdd80 	call	400cdd8 <_free_r>
  if (HASUB (fp))
 4013b20:	80800c17 	ldw	r2,48(r16)
 4013b24:	10000826 	beq	r2,zero,4013b48 <_fclose_r+0xe8>
    FREEUB (rptr, fp);
 4013b28:	80c00c17 	ldw	r3,48(r16)
 4013b2c:	80801004 	addi	r2,r16,64
 4013b30:	18800426 	beq	r3,r2,4013b44 <_fclose_r+0xe4>
 4013b34:	80800c17 	ldw	r2,48(r16)
 4013b38:	100b883a 	mov	r5,r2
 4013b3c:	e13ffc17 	ldw	r4,-16(fp)
 4013b40:	400cdd80 	call	400cdd8 <_free_r>
 4013b44:	80000c15 	stw	zero,48(r16)
  if (HASLB (fp))
 4013b48:	80801117 	ldw	r2,68(r16)
 4013b4c:	10000526 	beq	r2,zero,4013b64 <_fclose_r+0x104>
    FREELB (rptr, fp);
 4013b50:	80801117 	ldw	r2,68(r16)
 4013b54:	100b883a 	mov	r5,r2
 4013b58:	e13ffc17 	ldw	r4,-16(fp)
 4013b5c:	400cdd80 	call	400cdd8 <_free_r>
 4013b60:	80001115 	stw	zero,68(r16)
  __sfp_lock_acquire ();
 4013b64:	400cc900 	call	400cc90 <__sfp_lock_acquire>
  fp->_flags = 0;		/* release this FILE for reuse */
 4013b68:	8000030d 	sth	zero,12(r16)
    _funlockfile (fp);
#ifndef __SINGLE_THREAD__
  __lock_close_recursive (fp->_lock);
#endif

  __sfp_lock_release ();
 4013b6c:	400ccb00 	call	400ccb0 <__sfp_lock_release>
#ifdef _STDIO_WITH_THREAD_CANCELLATION_SUPPORT
  pthread_setcancelstate (__oldcancel, &__oldcancel);
#endif

  return (r);
 4013b70:	e0bffe17 	ldw	r2,-8(fp)
}
 4013b74:	e6ffff04 	addi	sp,fp,-4
 4013b78:	dfc00217 	ldw	ra,8(sp)
 4013b7c:	df000117 	ldw	fp,4(sp)
 4013b80:	dc000017 	ldw	r16,0(sp)
 4013b84:	dec00304 	addi	sp,sp,12
 4013b88:	f800283a 	ret

04013b8c <fclose>:

#ifndef _REENT_ONLY

int
fclose (register FILE * fp)
{
 4013b8c:	defffe04 	addi	sp,sp,-8
 4013b90:	dfc00115 	stw	ra,4(sp)
 4013b94:	df000015 	stw	fp,0(sp)
 4013b98:	d839883a 	mov	fp,sp
 4013b9c:	2007883a 	mov	r3,r4
  return _fclose_r(_REENT, fp);
 4013ba0:	d0a00117 	ldw	r2,-32764(gp)
 4013ba4:	180b883a 	mov	r5,r3
 4013ba8:	1009883a 	mov	r4,r2
 4013bac:	4013a600 	call	4013a60 <_fclose_r>
}
 4013bb0:	e037883a 	mov	sp,fp
 4013bb4:	dfc00117 	ldw	ra,4(sp)
 4013bb8:	df000017 	ldw	fp,0(sp)
 4013bbc:	dec00204 	addi	sp,sp,8
 4013bc0:	f800283a 	ret

04013bc4 <_fiprintf_r>:

int
_fiprintf_r (struct _reent *ptr,
       FILE * fp,
       const char *fmt, ...)
{
 4013bc4:	defff804 	addi	sp,sp,-32
 4013bc8:	dfc00615 	stw	ra,24(sp)
 4013bcc:	df000515 	stw	fp,20(sp)
 4013bd0:	df000504 	addi	fp,sp,20
 4013bd4:	e13ffd15 	stw	r4,-12(fp)
 4013bd8:	e17ffc15 	stw	r5,-16(fp)
 4013bdc:	e1bffb15 	stw	r6,-20(fp)
 4013be0:	e1c00215 	stw	r7,8(fp)
  int ret;
  va_list ap;

  va_start (ap, fmt);
 4013be4:	e0800204 	addi	r2,fp,8
 4013be8:	e0bffe15 	stw	r2,-8(fp)
  ret = _vfiprintf_r (ptr, fp, fmt, ap);
 4013bec:	e0bffe17 	ldw	r2,-8(fp)
 4013bf0:	100f883a 	mov	r7,r2
 4013bf4:	e1bffb17 	ldw	r6,-20(fp)
 4013bf8:	e17ffc17 	ldw	r5,-16(fp)
 4013bfc:	e13ffd17 	ldw	r4,-12(fp)
 4013c00:	40140f00 	call	40140f0 <_vfiprintf_r>
 4013c04:	e0bfff15 	stw	r2,-4(fp)
  va_end (ap);
  return ret;
 4013c08:	e0bfff17 	ldw	r2,-4(fp)
}
 4013c0c:	e037883a 	mov	sp,fp
 4013c10:	dfc00117 	ldw	ra,4(sp)
 4013c14:	df000017 	ldw	fp,0(sp)
 4013c18:	dec00304 	addi	sp,sp,12
 4013c1c:	f800283a 	ret

04013c20 <fiprintf>:
#ifndef _REENT_ONLY

int
fiprintf (FILE * fp,
       const char *fmt, ...)
{
 4013c20:	defff804 	addi	sp,sp,-32
 4013c24:	dfc00515 	stw	ra,20(sp)
 4013c28:	df000415 	stw	fp,16(sp)
 4013c2c:	df000404 	addi	fp,sp,16
 4013c30:	e13ffd15 	stw	r4,-12(fp)
 4013c34:	e17ffc15 	stw	r5,-16(fp)
 4013c38:	e1800215 	stw	r6,8(fp)
 4013c3c:	e1c00315 	stw	r7,12(fp)
  int ret;
  va_list ap;

  va_start (ap, fmt);
 4013c40:	e0800204 	addi	r2,fp,8
 4013c44:	e0bffe15 	stw	r2,-8(fp)
  ret = _vfiprintf_r (_REENT, fp, fmt, ap);
 4013c48:	d0a00117 	ldw	r2,-32764(gp)
 4013c4c:	e0fffe17 	ldw	r3,-8(fp)
 4013c50:	180f883a 	mov	r7,r3
 4013c54:	e1bffc17 	ldw	r6,-16(fp)
 4013c58:	e17ffd17 	ldw	r5,-12(fp)
 4013c5c:	1009883a 	mov	r4,r2
 4013c60:	40140f00 	call	40140f0 <_vfiprintf_r>
 4013c64:	e0bfff15 	stw	r2,-4(fp)
  va_end (ap);
  return ret;
 4013c68:	e0bfff17 	ldw	r2,-4(fp)
}
 4013c6c:	e037883a 	mov	sp,fp
 4013c70:	dfc00117 	ldw	ra,4(sp)
 4013c74:	df000017 	ldw	fp,0(sp)
 4013c78:	dec00404 	addi	sp,sp,16
 4013c7c:	f800283a 	ret

04013c80 <__fputwc>:

wint_t
__fputwc (struct _reent *ptr,
	wchar_t wc,
	FILE *fp)
{
 4013c80:	defff804 	addi	sp,sp,-32
 4013c84:	dfc00715 	stw	ra,28(sp)
 4013c88:	df000615 	stw	fp,24(sp)
 4013c8c:	df000604 	addi	fp,sp,24
 4013c90:	e13ffc15 	stw	r4,-16(fp)
 4013c94:	e17ffb15 	stw	r5,-20(fp)
 4013c98:	e1bffa15 	stw	r6,-24(fp)
  char buf[MB_LEN_MAX];
  size_t i, len;

  if (MB_CUR_MAX == 1 && wc > 0 && wc <= UCHAR_MAX)
 4013c9c:	400de840 	call	400de84 <__locale_mb_cur_max>
 4013ca0:	10800058 	cmpnei	r2,r2,1
 4013ca4:	10000a1e 	bne	r2,zero,4013cd0 <__fputwc+0x50>
 4013ca8:	e0bffb17 	ldw	r2,-20(fp)
 4013cac:	0080080e 	bge	zero,r2,4013cd0 <__fputwc+0x50>
 4013cb0:	e0bffb17 	ldw	r2,-20(fp)
 4013cb4:	10804008 	cmpgei	r2,r2,256
 4013cb8:	1000051e 	bne	r2,zero,4013cd0 <__fputwc+0x50>
      /*
       * Assume single-byte locale with no special encoding.
       * A more careful test would be to check
       * _CurrentRuneLocale->encoding.
       */
      *buf = (unsigned char)wc;
 4013cbc:	e0bffb17 	ldw	r2,-20(fp)
 4013cc0:	e0bffdc5 	stb	r2,-9(fp)
      len = 1;
 4013cc4:	00800044 	movi	r2,1
 4013cc8:	e0bffe15 	stw	r2,-8(fp)
 4013ccc:	00001406 	br	4013d20 <__fputwc+0xa0>
    }
  else
    {
      if ((len = _wcrtomb_r (ptr, buf, wc, &fp->_mbstate)) == (size_t) -1)
 4013cd0:	e0bffa17 	ldw	r2,-24(fp)
 4013cd4:	10c01704 	addi	r3,r2,92
 4013cd8:	e0bffdc4 	addi	r2,fp,-9
 4013cdc:	180f883a 	mov	r7,r3
 4013ce0:	e1bffb17 	ldw	r6,-20(fp)
 4013ce4:	100b883a 	mov	r5,r2
 4013ce8:	e13ffc17 	ldw	r4,-16(fp)
 4013cec:	40143380 	call	4014338 <_wcrtomb_r>
 4013cf0:	e0bffe15 	stw	r2,-8(fp)
 4013cf4:	e0bffe17 	ldw	r2,-8(fp)
 4013cf8:	10bfffd8 	cmpnei	r2,r2,-1
 4013cfc:	1000081e 	bne	r2,zero,4013d20 <__fputwc+0xa0>
	{
	  fp->_flags |= __SERR;
 4013d00:	e0bffa17 	ldw	r2,-24(fp)
 4013d04:	1080030b 	ldhu	r2,12(r2)
 4013d08:	10801014 	ori	r2,r2,64
 4013d0c:	1007883a 	mov	r3,r2
 4013d10:	e0bffa17 	ldw	r2,-24(fp)
 4013d14:	10c0030d 	sth	r3,12(r2)
	  return WEOF;
 4013d18:	00bfffc4 	movi	r2,-1
 4013d1c:	00004906 	br	4013e44 <__fputwc+0x1c4>
	}
    }

  for (i = 0; i < len; i++)
 4013d20:	e03fff15 	stw	zero,-4(fp)
 4013d24:	00004306 	br	4013e34 <__fputwc+0x1b4>
    if (__sputc_r (ptr, (unsigned char) buf[i], fp) == EOF)
 4013d28:	e0bffa17 	ldw	r2,-24(fp)
 4013d2c:	10800217 	ldw	r2,8(r2)
 4013d30:	10ffffc4 	addi	r3,r2,-1
 4013d34:	e0bffa17 	ldw	r2,-24(fp)
 4013d38:	10c00215 	stw	r3,8(r2)
 4013d3c:	e0bffa17 	ldw	r2,-24(fp)
 4013d40:	10800217 	ldw	r2,8(r2)
 4013d44:	1000280e 	bge	r2,zero,4013de8 <__fputwc+0x168>
 4013d48:	e0bffa17 	ldw	r2,-24(fp)
 4013d4c:	10c00217 	ldw	r3,8(r2)
 4013d50:	e0bffa17 	ldw	r2,-24(fp)
 4013d54:	10800617 	ldw	r2,24(r2)
 4013d58:	18801916 	blt	r3,r2,4013dc0 <__fputwc+0x140>
 4013d5c:	e0bfff17 	ldw	r2,-4(fp)
 4013d60:	e085883a 	add	r2,fp,r2
 4013d64:	10fffdc3 	ldbu	r3,-9(r2)
 4013d68:	e0bffa17 	ldw	r2,-24(fp)
 4013d6c:	10800017 	ldw	r2,0(r2)
 4013d70:	10c00005 	stb	r3,0(r2)
 4013d74:	e0bffa17 	ldw	r2,-24(fp)
 4013d78:	10800017 	ldw	r2,0(r2)
 4013d7c:	10800003 	ldbu	r2,0(r2)
 4013d80:	10803fcc 	andi	r2,r2,255
 4013d84:	108002a0 	cmpeqi	r2,r2,10
 4013d88:	1000071e 	bne	r2,zero,4013da8 <__fputwc+0x128>
 4013d8c:	e0bffa17 	ldw	r2,-24(fp)
 4013d90:	10800017 	ldw	r2,0(r2)
 4013d94:	10c00044 	addi	r3,r2,1
 4013d98:	e0bffa17 	ldw	r2,-24(fp)
 4013d9c:	10c00015 	stw	r3,0(r2)
 4013da0:	0005883a 	mov	r2,zero
 4013da4:	00001c06 	br	4013e18 <__fputwc+0x198>
 4013da8:	e1bffa17 	ldw	r6,-24(fp)
 4013dac:	01400284 	movi	r5,10
 4013db0:	e13ffc17 	ldw	r4,-16(fp)
 4013db4:	40141440 	call	4014144 <__swbuf_r>
 4013db8:	10bfffe0 	cmpeqi	r2,r2,-1
 4013dbc:	00001606 	br	4013e18 <__fputwc+0x198>
 4013dc0:	e0bfff17 	ldw	r2,-4(fp)
 4013dc4:	e085883a 	add	r2,fp,r2
 4013dc8:	10bffdc3 	ldbu	r2,-9(r2)
 4013dcc:	10803fcc 	andi	r2,r2,255
 4013dd0:	e1bffa17 	ldw	r6,-24(fp)
 4013dd4:	100b883a 	mov	r5,r2
 4013dd8:	e13ffc17 	ldw	r4,-16(fp)
 4013ddc:	40141440 	call	4014144 <__swbuf_r>
 4013de0:	10bfffe0 	cmpeqi	r2,r2,-1
 4013de4:	00000c06 	br	4013e18 <__fputwc+0x198>
 4013de8:	e0bfff17 	ldw	r2,-4(fp)
 4013dec:	e085883a 	add	r2,fp,r2
 4013df0:	10fffdc3 	ldbu	r3,-9(r2)
 4013df4:	e0bffa17 	ldw	r2,-24(fp)
 4013df8:	10800017 	ldw	r2,0(r2)
 4013dfc:	10c00005 	stb	r3,0(r2)
 4013e00:	e0bffa17 	ldw	r2,-24(fp)
 4013e04:	10800017 	ldw	r2,0(r2)
 4013e08:	10c00044 	addi	r3,r2,1
 4013e0c:	e0bffa17 	ldw	r2,-24(fp)
 4013e10:	10c00015 	stw	r3,0(r2)
 4013e14:	0005883a 	mov	r2,zero
 4013e18:	10803fcc 	andi	r2,r2,255
 4013e1c:	10000226 	beq	r2,zero,4013e28 <__fputwc+0x1a8>
      return WEOF;
 4013e20:	00bfffc4 	movi	r2,-1
 4013e24:	00000706 	br	4013e44 <__fputwc+0x1c4>
  for (i = 0; i < len; i++)
 4013e28:	e0bfff17 	ldw	r2,-4(fp)
 4013e2c:	10800044 	addi	r2,r2,1
 4013e30:	e0bfff15 	stw	r2,-4(fp)
 4013e34:	e0ffff17 	ldw	r3,-4(fp)
 4013e38:	e0bffe17 	ldw	r2,-8(fp)
 4013e3c:	18bfba36 	bltu	r3,r2,4013d28 <__fputwc+0xa8>

  return (wint_t) wc;
 4013e40:	e0bffb17 	ldw	r2,-20(fp)
}
 4013e44:	e037883a 	mov	sp,fp
 4013e48:	dfc00117 	ldw	ra,4(sp)
 4013e4c:	df000017 	ldw	fp,0(sp)
 4013e50:	dec00204 	addi	sp,sp,8
 4013e54:	f800283a 	ret

04013e58 <_fputwc_r>:

wint_t
_fputwc_r (struct _reent *ptr,
	wchar_t wc,
	FILE *fp)
{
 4013e58:	defffa04 	addi	sp,sp,-24
 4013e5c:	dfc00515 	stw	ra,20(sp)
 4013e60:	df000415 	stw	fp,16(sp)
 4013e64:	df000404 	addi	fp,sp,16
 4013e68:	e13ffe15 	stw	r4,-8(fp)
 4013e6c:	e17ffd15 	stw	r5,-12(fp)
 4013e70:	e1bffc15 	stw	r6,-16(fp)
  wint_t r;

  _newlib_flockfile_start (fp);
  ORIENT(fp, 1);
 4013e74:	e0bffc17 	ldw	r2,-16(fp)
 4013e78:	1080030b 	ldhu	r2,12(r2)
 4013e7c:	10bfffcc 	andi	r2,r2,65535
 4013e80:	1088000c 	andi	r2,r2,8192
 4013e84:	10000b1e 	bne	r2,zero,4013eb4 <_fputwc_r+0x5c>
 4013e88:	e0bffc17 	ldw	r2,-16(fp)
 4013e8c:	1080030b 	ldhu	r2,12(r2)
 4013e90:	10880014 	ori	r2,r2,8192
 4013e94:	1007883a 	mov	r3,r2
 4013e98:	e0bffc17 	ldw	r2,-16(fp)
 4013e9c:	10c0030d 	sth	r3,12(r2)
 4013ea0:	e0bffc17 	ldw	r2,-16(fp)
 4013ea4:	10801917 	ldw	r2,100(r2)
 4013ea8:	10c80014 	ori	r3,r2,8192
 4013eac:	e0bffc17 	ldw	r2,-16(fp)
 4013eb0:	10c01915 	stw	r3,100(r2)
  r = __fputwc(ptr, wc, fp);
 4013eb4:	e1bffc17 	ldw	r6,-16(fp)
 4013eb8:	e17ffd17 	ldw	r5,-12(fp)
 4013ebc:	e13ffe17 	ldw	r4,-8(fp)
 4013ec0:	4013c800 	call	4013c80 <__fputwc>
 4013ec4:	e0bfff15 	stw	r2,-4(fp)
  _newlib_flockfile_end (fp);
  return r;
 4013ec8:	e0bfff17 	ldw	r2,-4(fp)
}
 4013ecc:	e037883a 	mov	sp,fp
 4013ed0:	dfc00117 	ldw	ra,4(sp)
 4013ed4:	df000017 	ldw	fp,0(sp)
 4013ed8:	dec00204 	addi	sp,sp,8
 4013edc:	f800283a 	ret

04013ee0 <fputwc>:

wint_t
fputwc (wchar_t wc,
	FILE *fp)
{
 4013ee0:	defffa04 	addi	sp,sp,-24
 4013ee4:	dfc00515 	stw	ra,20(sp)
 4013ee8:	df000415 	stw	fp,16(sp)
 4013eec:	df000404 	addi	fp,sp,16
 4013ef0:	e13ffd15 	stw	r4,-12(fp)
 4013ef4:	e17ffc15 	stw	r5,-16(fp)
  struct _reent *reent = _REENT;
 4013ef8:	d0a00117 	ldw	r2,-32764(gp)
 4013efc:	e0bfff15 	stw	r2,-4(fp)

  CHECK_INIT(reent, fp);
 4013f00:	e0bfff17 	ldw	r2,-4(fp)
 4013f04:	e0bffe15 	stw	r2,-8(fp)
 4013f08:	e0bffe17 	ldw	r2,-8(fp)
 4013f0c:	10000526 	beq	r2,zero,4013f24 <fputwc+0x44>
 4013f10:	e0bffe17 	ldw	r2,-8(fp)
 4013f14:	10800e17 	ldw	r2,56(r2)
 4013f18:	1000021e 	bne	r2,zero,4013f24 <fputwc+0x44>
 4013f1c:	e13ffe17 	ldw	r4,-8(fp)
 4013f20:	400cbdc0 	call	400cbdc <__sinit>
  return _fputwc_r (reent, wc, fp);
 4013f24:	e1bffc17 	ldw	r6,-16(fp)
 4013f28:	e17ffd17 	ldw	r5,-12(fp)
 4013f2c:	e13fff17 	ldw	r4,-4(fp)
 4013f30:	4013e580 	call	4013e58 <_fputwc_r>
}
 4013f34:	e037883a 	mov	sp,fp
 4013f38:	dfc00117 	ldw	ra,4(sp)
 4013f3c:	df000017 	ldw	fp,0(sp)
 4013f40:	dec00204 	addi	sp,sp,8
 4013f44:	f800283a 	ret

04013f48 <_fstat_r>:
int
_fstat_r (ptr, fd, pstat)
     struct _reent *ptr;
     int fd;
     struct stat *pstat;
{
 4013f48:	defffa04 	addi	sp,sp,-24
 4013f4c:	dfc00515 	stw	ra,20(sp)
 4013f50:	df000415 	stw	fp,16(sp)
 4013f54:	df000404 	addi	fp,sp,16
 4013f58:	e13ffe15 	stw	r4,-8(fp)
 4013f5c:	e17ffd15 	stw	r5,-12(fp)
 4013f60:	e1bffc15 	stw	r6,-16(fp)
  int ret;

  errno = 0;
 4013f64:	d0272915 	stw	zero,-25436(gp)
  if ((ret = _fstat (fd, pstat)) == -1 && errno != 0)
 4013f68:	e17ffc17 	ldw	r5,-16(fp)
 4013f6c:	e13ffd17 	ldw	r4,-12(fp)
 4013f70:	4017f6c0 	call	4017f6c <fstat>
 4013f74:	e0bfff15 	stw	r2,-4(fp)
 4013f78:	e0bfff17 	ldw	r2,-4(fp)
 4013f7c:	10bfffd8 	cmpnei	r2,r2,-1
 4013f80:	1000051e 	bne	r2,zero,4013f98 <_fstat_r+0x50>
 4013f84:	d0a72917 	ldw	r2,-25436(gp)
 4013f88:	10000326 	beq	r2,zero,4013f98 <_fstat_r+0x50>
    ptr->_errno = errno;
 4013f8c:	d0e72917 	ldw	r3,-25436(gp)
 4013f90:	e0bffe17 	ldw	r2,-8(fp)
 4013f94:	10c00015 	stw	r3,0(r2)
  return ret;
 4013f98:	e0bfff17 	ldw	r2,-4(fp)
}
 4013f9c:	e037883a 	mov	sp,fp
 4013fa0:	dfc00117 	ldw	ra,4(sp)
 4013fa4:	df000017 	ldw	fp,0(sp)
 4013fa8:	dec00204 	addi	sp,sp,8
 4013fac:	f800283a 	ret

04013fb0 <_isatty_r>:

int
_isatty_r (ptr, fd)
     struct _reent *ptr;
     int fd;
{
 4013fb0:	defffb04 	addi	sp,sp,-20
 4013fb4:	dfc00415 	stw	ra,16(sp)
 4013fb8:	df000315 	stw	fp,12(sp)
 4013fbc:	df000304 	addi	fp,sp,12
 4013fc0:	e13ffe15 	stw	r4,-8(fp)
 4013fc4:	e17ffd15 	stw	r5,-12(fp)
  int ret;

  errno = 0;
 4013fc8:	d0272915 	stw	zero,-25436(gp)
  if ((ret = _isatty (fd)) == -1 && errno != 0)
 4013fcc:	e13ffd17 	ldw	r4,-12(fp)
 4013fd0:	401831c0 	call	401831c <isatty>
 4013fd4:	e0bfff15 	stw	r2,-4(fp)
 4013fd8:	e0bfff17 	ldw	r2,-4(fp)
 4013fdc:	10bfffd8 	cmpnei	r2,r2,-1
 4013fe0:	1000051e 	bne	r2,zero,4013ff8 <_isatty_r+0x48>
 4013fe4:	d0a72917 	ldw	r2,-25436(gp)
 4013fe8:	10000326 	beq	r2,zero,4013ff8 <_isatty_r+0x48>
    ptr->_errno = errno;
 4013fec:	d0e72917 	ldw	r3,-25436(gp)
 4013ff0:	e0bffe17 	ldw	r2,-8(fp)
 4013ff4:	10c00015 	stw	r3,0(r2)
  return ret;
 4013ff8:	e0bfff17 	ldw	r2,-4(fp)
}
 4013ffc:	e037883a 	mov	sp,fp
 4014000:	dfc00117 	ldw	ra,4(sp)
 4014004:	df000017 	ldw	fp,0(sp)
 4014008:	dec00204 	addi	sp,sp,8
 401400c:	f800283a 	ret

04014010 <_lseek_r>:
_off_t
_lseek_r (struct _reent *ptr,
     int fd,
     _off_t pos,
     int whence)
{
 4014010:	defff904 	addi	sp,sp,-28
 4014014:	dfc00615 	stw	ra,24(sp)
 4014018:	df000515 	stw	fp,20(sp)
 401401c:	df000504 	addi	fp,sp,20
 4014020:	e13ffe15 	stw	r4,-8(fp)
 4014024:	e17ffd15 	stw	r5,-12(fp)
 4014028:	e1bffc15 	stw	r6,-16(fp)
 401402c:	e1fffb15 	stw	r7,-20(fp)
  _off_t ret;

  errno = 0;
 4014030:	d0272915 	stw	zero,-25436(gp)
  if ((ret = _lseek (fd, pos, whence)) == (_off_t) -1 && errno != 0)
 4014034:	e1bffb17 	ldw	r6,-20(fp)
 4014038:	e17ffc17 	ldw	r5,-16(fp)
 401403c:	e13ffd17 	ldw	r4,-12(fp)
 4014040:	401865c0 	call	401865c <lseek>
 4014044:	e0bfff15 	stw	r2,-4(fp)
 4014048:	e0bfff17 	ldw	r2,-4(fp)
 401404c:	10bfffd8 	cmpnei	r2,r2,-1
 4014050:	1000051e 	bne	r2,zero,4014068 <_lseek_r+0x58>
 4014054:	d0a72917 	ldw	r2,-25436(gp)
 4014058:	10000326 	beq	r2,zero,4014068 <_lseek_r+0x58>
    ptr->_errno = errno;
 401405c:	d0e72917 	ldw	r3,-25436(gp)
 4014060:	e0bffe17 	ldw	r2,-8(fp)
 4014064:	10c00015 	stw	r3,0(r2)
  return ret;
 4014068:	e0bfff17 	ldw	r2,-4(fp)
}
 401406c:	e037883a 	mov	sp,fp
 4014070:	dfc00117 	ldw	ra,4(sp)
 4014074:	df000017 	ldw	fp,0(sp)
 4014078:	dec00204 	addi	sp,sp,8
 401407c:	f800283a 	ret

04014080 <_read_r>:
_ssize_t
_read_r (struct _reent *ptr,
     int fd,
     void *buf,
     size_t cnt)
{
 4014080:	defff904 	addi	sp,sp,-28
 4014084:	dfc00615 	stw	ra,24(sp)
 4014088:	df000515 	stw	fp,20(sp)
 401408c:	df000504 	addi	fp,sp,20
 4014090:	e13ffe15 	stw	r4,-8(fp)
 4014094:	e17ffd15 	stw	r5,-12(fp)
 4014098:	e1bffc15 	stw	r6,-16(fp)
 401409c:	e1fffb15 	stw	r7,-20(fp)
  _ssize_t ret;

  errno = 0;
 40140a0:	d0272915 	stw	zero,-25436(gp)
  if ((ret = (_ssize_t)_read (fd, buf, cnt)) == -1 && errno != 0)
 40140a4:	e1bffb17 	ldw	r6,-20(fp)
 40140a8:	e17ffc17 	ldw	r5,-16(fp)
 40140ac:	e13ffd17 	ldw	r4,-12(fp)
 40140b0:	401883c0 	call	401883c <read>
 40140b4:	e0bfff15 	stw	r2,-4(fp)
 40140b8:	e0bfff17 	ldw	r2,-4(fp)
 40140bc:	10bfffd8 	cmpnei	r2,r2,-1
 40140c0:	1000051e 	bne	r2,zero,40140d8 <_read_r+0x58>
 40140c4:	d0a72917 	ldw	r2,-25436(gp)
 40140c8:	10000326 	beq	r2,zero,40140d8 <_read_r+0x58>
    ptr->_errno = errno;
 40140cc:	d0e72917 	ldw	r3,-25436(gp)
 40140d0:	e0bffe17 	ldw	r2,-8(fp)
 40140d4:	10c00015 	stw	r3,0(r2)
  return ret;
 40140d8:	e0bfff17 	ldw	r2,-4(fp)
}
 40140dc:	e037883a 	mov	sp,fp
 40140e0:	dfc00117 	ldw	ra,4(sp)
 40140e4:	df000017 	ldw	fp,0(sp)
 40140e8:	dec00204 	addi	sp,sp,8
 40140ec:	f800283a 	ret

040140f0 <_vfiprintf_r>:
_DEFUN (_vfiprintf_r, (data, fp, fmt, ap),
	struct _reent *data _AND
	FILE * fp _AND
	_CONST char *fmt _AND
	va_list ap)
{
 40140f0:	defff904 	addi	sp,sp,-28
 40140f4:	dfc00615 	stw	ra,24(sp)
 40140f8:	df000515 	stw	fp,20(sp)
 40140fc:	df000504 	addi	fp,sp,20
 4014100:	e13ffe15 	stw	r4,-8(fp)
 4014104:	e17ffd15 	stw	r5,-12(fp)
 4014108:	e1bffc15 	stw	r6,-16(fp)
 401410c:	e1fffb15 	stw	r7,-20(fp)
  int ret;

  _REENT_SMALL_CHECK_INIT(fp);
  _FILE_INIT_DEV_WRITE (fp);
  ret = ___vfiprintf_internal_r (data, fp, fmt, ap);
 4014110:	e0bffb17 	ldw	r2,-20(fp)
 4014114:	100f883a 	mov	r7,r2
 4014118:	e1bffc17 	ldw	r6,-16(fp)
 401411c:	e17ffd17 	ldw	r5,-12(fp)
 4014120:	e13ffe17 	ldw	r4,-8(fp)
 4014124:	40123a40 	call	40123a4 <___vfiprintf_internal_r>
 4014128:	e0bfff15 	stw	r2,-4(fp)
  va_end (ap);
  return ret;
 401412c:	e0bfff17 	ldw	r2,-4(fp)
}
 4014130:	e037883a 	mov	sp,fp
 4014134:	dfc00117 	ldw	ra,4(sp)
 4014138:	df000017 	ldw	fp,0(sp)
 401413c:	dec00204 	addi	sp,sp,8
 4014140:	f800283a 	ret

04014144 <__swbuf_r>:

int
__swbuf_r (struct _reent *ptr,
       register int c,
       register FILE *fp)
{
 4014144:	defff904 	addi	sp,sp,-28
 4014148:	dfc00615 	stw	ra,24(sp)
 401414c:	df000515 	stw	fp,20(sp)
 4014150:	dc800415 	stw	r18,16(sp)
 4014154:	dc400315 	stw	r17,12(sp)
 4014158:	dc000215 	stw	r16,8(sp)
 401415c:	df000504 	addi	fp,sp,20
 4014160:	e13ffb15 	stw	r4,-20(fp)
 4014164:	2825883a 	mov	r18,r5
 4014168:	3021883a 	mov	r16,r6
  register int n;

  /* Ensure stdio has been initialized.  */

  CHECK_INIT (ptr, fp);
 401416c:	e0bffb17 	ldw	r2,-20(fp)
 4014170:	e0bffc15 	stw	r2,-16(fp)
 4014174:	e0bffc17 	ldw	r2,-16(fp)
 4014178:	10000526 	beq	r2,zero,4014190 <__swbuf_r+0x4c>
 401417c:	e0bffc17 	ldw	r2,-16(fp)
 4014180:	10800e17 	ldw	r2,56(r2)
 4014184:	1000021e 	bne	r2,zero,4014190 <__swbuf_r+0x4c>
 4014188:	e13ffc17 	ldw	r4,-16(fp)
 401418c:	400cbdc0 	call	400cbdc <__sinit>
   * (if line buffered) so that we will get called again.
   * If we did not do this, a sufficient number of putc()
   * calls might wrap _w from negative to positive.
   */

  fp->_w = fp->_lbfsize;
 4014190:	80800617 	ldw	r2,24(r16)
 4014194:	80800215 	stw	r2,8(r16)
  if (cantwrite (ptr, fp))
 4014198:	8080030b 	ldhu	r2,12(r16)
 401419c:	10bfffcc 	andi	r2,r2,65535
 40141a0:	1080020c 	andi	r2,r2,8
 40141a4:	10000226 	beq	r2,zero,40141b0 <__swbuf_r+0x6c>
 40141a8:	80800417 	ldw	r2,16(r16)
 40141ac:	1000061e 	bne	r2,zero,40141c8 <__swbuf_r+0x84>
 40141b0:	800b883a 	mov	r5,r16
 40141b4:	e13ffb17 	ldw	r4,-20(fp)
 40141b8:	400a2180 	call	400a218 <__swsetup_r>
 40141bc:	10000226 	beq	r2,zero,40141c8 <__swbuf_r+0x84>
    return EOF;
 40141c0:	00bfffc4 	movi	r2,-1
 40141c4:	00003106 	br	401428c <__swbuf_r+0x148>
  c = (unsigned char) c;
 40141c8:	9005883a 	mov	r2,r18
 40141cc:	14803fcc 	andi	r18,r2,255

  ORIENT (fp, -1);
 40141d0:	8080030b 	ldhu	r2,12(r16)
 40141d4:	10bfffcc 	andi	r2,r2,65535
 40141d8:	1088000c 	andi	r2,r2,8192
 40141dc:	1000071e 	bne	r2,zero,40141fc <__swbuf_r+0xb8>
 40141e0:	8080030b 	ldhu	r2,12(r16)
 40141e4:	10880014 	ori	r2,r2,8192
 40141e8:	8080030d 	sth	r2,12(r16)
 40141ec:	80c01917 	ldw	r3,100(r16)
 40141f0:	00b7ffc4 	movi	r2,-8193
 40141f4:	1884703a 	and	r2,r3,r2
 40141f8:	80801915 	stw	r2,100(r16)
   * happen on unbuffered streams, where _bf._size==1; fflush()
   * guarantees that putc() will always call wbuf() by setting _w
   * to 0, so we need not do anything else.
   */

  n = fp->_p - fp->_bf._base;
 40141fc:	80c00017 	ldw	r3,0(r16)
 4014200:	80800417 	ldw	r2,16(r16)
 4014204:	18a3c83a 	sub	r17,r3,r2
  if (n >= fp->_bf._size)
 4014208:	80800517 	ldw	r2,20(r16)
 401420c:	88800716 	blt	r17,r2,401422c <__swbuf_r+0xe8>
    {
      if (_fflush_r (ptr, fp))
 4014210:	800b883a 	mov	r5,r16
 4014214:	e13ffb17 	ldw	r4,-20(fp)
 4014218:	400c6940 	call	400c694 <_fflush_r>
 401421c:	10000226 	beq	r2,zero,4014228 <__swbuf_r+0xe4>
	return EOF;
 4014220:	00bfffc4 	movi	r2,-1
 4014224:	00001906 	br	401428c <__swbuf_r+0x148>
      n = 0;
 4014228:	0023883a 	mov	r17,zero
    }
  fp->_w--;
 401422c:	80800217 	ldw	r2,8(r16)
 4014230:	10bfffc4 	addi	r2,r2,-1
 4014234:	80800215 	stw	r2,8(r16)
  *fp->_p++ = c;
 4014238:	80800017 	ldw	r2,0(r16)
 401423c:	10c00044 	addi	r3,r2,1
 4014240:	80c00015 	stw	r3,0(r16)
 4014244:	9007883a 	mov	r3,r18
 4014248:	10c00005 	stb	r3,0(r2)
  if (++n == fp->_bf._size || (fp->_flags & __SLBF && c == '\n'))
 401424c:	8c400044 	addi	r17,r17,1
 4014250:	80800517 	ldw	r2,20(r16)
 4014254:	88800626 	beq	r17,r2,4014270 <__swbuf_r+0x12c>
 4014258:	8080030b 	ldhu	r2,12(r16)
 401425c:	10bfffcc 	andi	r2,r2,65535
 4014260:	1080004c 	andi	r2,r2,1
 4014264:	10000826 	beq	r2,zero,4014288 <__swbuf_r+0x144>
 4014268:	90800298 	cmpnei	r2,r18,10
 401426c:	1000061e 	bne	r2,zero,4014288 <__swbuf_r+0x144>
    if (_fflush_r (ptr, fp))
 4014270:	800b883a 	mov	r5,r16
 4014274:	e13ffb17 	ldw	r4,-20(fp)
 4014278:	400c6940 	call	400c694 <_fflush_r>
 401427c:	10000226 	beq	r2,zero,4014288 <__swbuf_r+0x144>
      return EOF;
 4014280:	00bfffc4 	movi	r2,-1
 4014284:	00000106 	br	401428c <__swbuf_r+0x148>
  return c;
 4014288:	9005883a 	mov	r2,r18
}
 401428c:	e6fffd04 	addi	sp,fp,-12
 4014290:	dfc00417 	ldw	ra,16(sp)
 4014294:	df000317 	ldw	fp,12(sp)
 4014298:	dc800217 	ldw	r18,8(sp)
 401429c:	dc400117 	ldw	r17,4(sp)
 40142a0:	dc000017 	ldw	r16,0(sp)
 40142a4:	dec00504 	addi	sp,sp,20
 40142a8:	f800283a 	ret

040142ac <__swbuf>:
   required for backward compatibility with applications built against
   earlier dynamically built newlib libraries. */
int
__swbuf (register int c,
       register FILE *fp)
{
 40142ac:	defffe04 	addi	sp,sp,-8
 40142b0:	dfc00115 	stw	ra,4(sp)
 40142b4:	df000015 	stw	fp,0(sp)
 40142b8:	d839883a 	mov	fp,sp
 40142bc:	2007883a 	mov	r3,r4
 40142c0:	2809883a 	mov	r4,r5
  return __swbuf_r (_REENT, c, fp);
 40142c4:	d0a00117 	ldw	r2,-32764(gp)
 40142c8:	200d883a 	mov	r6,r4
 40142cc:	180b883a 	mov	r5,r3
 40142d0:	1009883a 	mov	r4,r2
 40142d4:	40141440 	call	4014144 <__swbuf_r>
}
 40142d8:	e037883a 	mov	sp,fp
 40142dc:	dfc00117 	ldw	ra,4(sp)
 40142e0:	df000017 	ldw	fp,0(sp)
 40142e4:	dec00204 	addi	sp,sp,8
 40142e8:	f800283a 	ret

040142ec <__get_global_locale>:
{
 40142ec:	deffff04 	addi	sp,sp,-4
 40142f0:	df000015 	stw	fp,0(sp)
 40142f4:	d839883a 	mov	fp,sp
  return &__global_locale;
 40142f8:	008100b4 	movhi	r2,1026
 40142fc:	10add804 	addi	r2,r2,-18592
}
 4014300:	e037883a 	mov	sp,fp
 4014304:	df000017 	ldw	fp,0(sp)
 4014308:	dec00104 	addi	sp,sp,4
 401430c:	f800283a 	ret

04014310 <__get_current_locale>:
{
 4014310:	defffe04 	addi	sp,sp,-8
 4014314:	dfc00115 	stw	ra,4(sp)
 4014318:	df000015 	stw	fp,0(sp)
 401431c:	d839883a 	mov	fp,sp
  return __get_global_locale();
 4014320:	40142ec0 	call	40142ec <__get_global_locale>
}
 4014324:	e037883a 	mov	sp,fp
 4014328:	dfc00117 	ldw	ra,4(sp)
 401432c:	df000017 	ldw	fp,0(sp)
 4014330:	dec00204 	addi	sp,sp,8
 4014334:	f800283a 	ret

04014338 <_wcrtomb_r>:
size_t
_wcrtomb_r (struct _reent *ptr,
	char *s,
	wchar_t wc,
	mbstate_t *ps)
{
 4014338:	defff604 	addi	sp,sp,-40
 401433c:	dfc00915 	stw	ra,36(sp)
 4014340:	df000815 	stw	fp,32(sp)
 4014344:	df000804 	addi	fp,sp,32
 4014348:	e13ffb15 	stw	r4,-20(fp)
 401434c:	e17ffa15 	stw	r5,-24(fp)
 4014350:	e1bff915 	stw	r6,-28(fp)
 4014354:	e1fff815 	stw	r7,-32(fp)
  int retval = 0;
 4014358:	e03fff15 	stw	zero,-4(fp)
      _REENT_CHECK_MISC(ptr);
      ps = &(_REENT_WCRTOMB_STATE(ptr));
    }
#endif

  if (s == NULL)
 401435c:	e0bffa17 	ldw	r2,-24(fp)
 4014360:	10000a1e 	bne	r2,zero,401438c <_wcrtomb_r+0x54>
    retval = __WCTOMB (ptr, buf, L'\0', ps);
 4014364:	40143100 	call	4014310 <__get_current_locale>
 4014368:	10803817 	ldw	r2,224(r2)
 401436c:	e0fffc84 	addi	r3,fp,-14
 4014370:	e1fff817 	ldw	r7,-32(fp)
 4014374:	000d883a 	mov	r6,zero
 4014378:	180b883a 	mov	r5,r3
 401437c:	e13ffb17 	ldw	r4,-20(fp)
 4014380:	103ee83a 	callr	r2
 4014384:	e0bfff15 	stw	r2,-4(fp)
 4014388:	00000806 	br	40143ac <_wcrtomb_r+0x74>
  else
    retval = __WCTOMB (ptr, s, wc, ps);
 401438c:	40143100 	call	4014310 <__get_current_locale>
 4014390:	10803817 	ldw	r2,224(r2)
 4014394:	e1fff817 	ldw	r7,-32(fp)
 4014398:	e1bff917 	ldw	r6,-28(fp)
 401439c:	e17ffa17 	ldw	r5,-24(fp)
 40143a0:	e13ffb17 	ldw	r4,-20(fp)
 40143a4:	103ee83a 	callr	r2
 40143a8:	e0bfff15 	stw	r2,-4(fp)

  if (retval == -1)
 40143ac:	e0bfff17 	ldw	r2,-4(fp)
 40143b0:	10bfffd8 	cmpnei	r2,r2,-1
 40143b4:	1000071e 	bne	r2,zero,40143d4 <_wcrtomb_r+0x9c>
    {
      ps->__count = 0;
 40143b8:	e0bff817 	ldw	r2,-32(fp)
 40143bc:	10000015 	stw	zero,0(r2)
      ptr->_errno = EILSEQ;
 40143c0:	e0bffb17 	ldw	r2,-20(fp)
 40143c4:	00c02284 	movi	r3,138
 40143c8:	10c00015 	stw	r3,0(r2)
      return (size_t)(-1);
 40143cc:	00bfffc4 	movi	r2,-1
 40143d0:	00000106 	br	40143d8 <_wcrtomb_r+0xa0>
    }
  else
    return (size_t)retval;
 40143d4:	e0bfff17 	ldw	r2,-4(fp)
}
 40143d8:	e037883a 	mov	sp,fp
 40143dc:	dfc00117 	ldw	ra,4(sp)
 40143e0:	df000017 	ldw	fp,0(sp)
 40143e4:	dec00204 	addi	sp,sp,8
 40143e8:	f800283a 	ret

040143ec <wcrtomb>:
#ifndef _REENT_ONLY
size_t
wcrtomb (char *__restrict s,
	wchar_t wc,
	mbstate_t *__restrict ps)
{
 40143ec:	defff604 	addi	sp,sp,-40
 40143f0:	dfc00915 	stw	ra,36(sp)
 40143f4:	df000815 	stw	fp,32(sp)
 40143f8:	df000804 	addi	fp,sp,32
 40143fc:	e13ffa15 	stw	r4,-24(fp)
 4014400:	e17ff915 	stw	r5,-28(fp)
 4014404:	e1bff815 	stw	r6,-32(fp)
#if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
  return _wcrtomb_r (_REENT, s, wc, ps);
#else
  int retval = 0;
 4014408:	e03fff15 	stw	zero,-4(fp)
  struct _reent *reent = _REENT;
 401440c:	d0a00117 	ldw	r2,-32764(gp)
 4014410:	e0bffe15 	stw	r2,-8(fp)
      _REENT_CHECK_MISC(reent);
      ps = &(_REENT_WCRTOMB_STATE(reent));
    }
#endif

  if (s == NULL)
 4014414:	e0bffa17 	ldw	r2,-24(fp)
 4014418:	10000a1e 	bne	r2,zero,4014444 <wcrtomb+0x58>
    retval = __WCTOMB (reent, buf, L'\0', ps);
 401441c:	40143100 	call	4014310 <__get_current_locale>
 4014420:	10803817 	ldw	r2,224(r2)
 4014424:	e0fffb84 	addi	r3,fp,-18
 4014428:	e1fff817 	ldw	r7,-32(fp)
 401442c:	000d883a 	mov	r6,zero
 4014430:	180b883a 	mov	r5,r3
 4014434:	e13ffe17 	ldw	r4,-8(fp)
 4014438:	103ee83a 	callr	r2
 401443c:	e0bfff15 	stw	r2,-4(fp)
 4014440:	00000806 	br	4014464 <wcrtomb+0x78>
  else
    retval = __WCTOMB (reent, s, wc, ps);
 4014444:	40143100 	call	4014310 <__get_current_locale>
 4014448:	10803817 	ldw	r2,224(r2)
 401444c:	e1fff817 	ldw	r7,-32(fp)
 4014450:	e1bff917 	ldw	r6,-28(fp)
 4014454:	e17ffa17 	ldw	r5,-24(fp)
 4014458:	e13ffe17 	ldw	r4,-8(fp)
 401445c:	103ee83a 	callr	r2
 4014460:	e0bfff15 	stw	r2,-4(fp)

  if (retval == -1)
 4014464:	e0bfff17 	ldw	r2,-4(fp)
 4014468:	10bfffd8 	cmpnei	r2,r2,-1
 401446c:	1000071e 	bne	r2,zero,401448c <wcrtomb+0xa0>
    {
      ps->__count = 0;
 4014470:	e0bff817 	ldw	r2,-32(fp)
 4014474:	10000015 	stw	zero,0(r2)
      reent->_errno = EILSEQ;
 4014478:	e0bffe17 	ldw	r2,-8(fp)
 401447c:	00c02284 	movi	r3,138
 4014480:	10c00015 	stw	r3,0(r2)
      return (size_t)(-1);
 4014484:	00bfffc4 	movi	r2,-1
 4014488:	00000106 	br	4014490 <wcrtomb+0xa4>
    }
  else
    return (size_t)retval;
 401448c:	e0bfff17 	ldw	r2,-4(fp)
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 4014490:	e037883a 	mov	sp,fp
 4014494:	dfc00117 	ldw	ra,4(sp)
 4014498:	df000017 	ldw	fp,0(sp)
 401449c:	dec00204 	addi	sp,sp,8
 40144a0:	f800283a 	ret

040144a4 <abort>:
#include <unistd.h>
#include <signal.h>

void
abort (void)
{
 40144a4:	defffe04 	addi	sp,sp,-8
 40144a8:	dfc00115 	stw	ra,4(sp)
 40144ac:	df000015 	stw	fp,0(sp)
 40144b0:	d839883a 	mov	fp,sp
  write (2, "Abort called\n", sizeof ("Abort called\n")-1);
#endif

  while (1)
    {
      raise (SIGABRT);
 40144b4:	01000184 	movi	r4,6
 40144b8:	40147fc0 	call	40147fc <raise>
      _exit (1);
 40144bc:	01000044 	movi	r4,1
 40144c0:	4017ef80 	call	4017ef8 <_exit>

040144c4 <_init_signal_r>:
#include <reent.h>
#include <_syslist.h>

int
_init_signal_r (struct _reent *ptr)
{
 40144c4:	defffc04 	addi	sp,sp,-16
 40144c8:	dfc00315 	stw	ra,12(sp)
 40144cc:	df000215 	stw	fp,8(sp)
 40144d0:	df000204 	addi	fp,sp,8
 40144d4:	e13ffe15 	stw	r4,-8(fp)
  int i;

  if (ptr->_sig_func == NULL)
 40144d8:	e0bffe17 	ldw	r2,-8(fp)
 40144dc:	1080b717 	ldw	r2,732(r2)
 40144e0:	1000191e 	bne	r2,zero,4014548 <_init_signal_r+0x84>
    {
      ptr->_sig_func = (_sig_func_ptr *)_malloc_r (ptr, sizeof (_sig_func_ptr) * NSIG);
 40144e4:	01402004 	movi	r5,128
 40144e8:	e13ffe17 	ldw	r4,-8(fp)
 40144ec:	400e5500 	call	400e550 <_malloc_r>
 40144f0:	1007883a 	mov	r3,r2
 40144f4:	e0bffe17 	ldw	r2,-8(fp)
 40144f8:	10c0b715 	stw	r3,732(r2)
      if (ptr->_sig_func == NULL)
 40144fc:	e0bffe17 	ldw	r2,-8(fp)
 4014500:	1080b717 	ldw	r2,732(r2)
 4014504:	1000021e 	bne	r2,zero,4014510 <_init_signal_r+0x4c>
	return -1;
 4014508:	00bfffc4 	movi	r2,-1
 401450c:	00000f06 	br	401454c <_init_signal_r+0x88>

      for (i = 0; i < NSIG; i++)
 4014510:	e03fff15 	stw	zero,-4(fp)
 4014514:	00000906 	br	401453c <_init_signal_r+0x78>
	ptr->_sig_func[i] = SIG_DFL;
 4014518:	e0bffe17 	ldw	r2,-8(fp)
 401451c:	10c0b717 	ldw	r3,732(r2)
 4014520:	e0bfff17 	ldw	r2,-4(fp)
 4014524:	100490ba 	slli	r2,r2,2
 4014528:	1885883a 	add	r2,r3,r2
 401452c:	10000015 	stw	zero,0(r2)
      for (i = 0; i < NSIG; i++)
 4014530:	e0bfff17 	ldw	r2,-4(fp)
 4014534:	10800044 	addi	r2,r2,1
 4014538:	e0bfff15 	stw	r2,-4(fp)
 401453c:	e0bfff17 	ldw	r2,-4(fp)
 4014540:	10800810 	cmplti	r2,r2,32
 4014544:	103ff41e 	bne	r2,zero,4014518 <_init_signal_r+0x54>
    }

  return 0;
 4014548:	0005883a 	mov	r2,zero
}
 401454c:	e037883a 	mov	sp,fp
 4014550:	dfc00117 	ldw	ra,4(sp)
 4014554:	df000017 	ldw	fp,0(sp)
 4014558:	dec00204 	addi	sp,sp,8
 401455c:	f800283a 	ret

04014560 <_signal_r>:

_sig_func_ptr
_signal_r (struct _reent *ptr,
	int sig,
	_sig_func_ptr func)
{
 4014560:	defffa04 	addi	sp,sp,-24
 4014564:	dfc00515 	stw	ra,20(sp)
 4014568:	df000415 	stw	fp,16(sp)
 401456c:	df000404 	addi	fp,sp,16
 4014570:	e13ffe15 	stw	r4,-8(fp)
 4014574:	e17ffd15 	stw	r5,-12(fp)
 4014578:	e1bffc15 	stw	r6,-16(fp)
  _sig_func_ptr old_func;

  if (sig < 0 || sig >= NSIG)
 401457c:	e0bffd17 	ldw	r2,-12(fp)
 4014580:	10000316 	blt	r2,zero,4014590 <_signal_r+0x30>
 4014584:	e0bffd17 	ldw	r2,-12(fp)
 4014588:	10800810 	cmplti	r2,r2,32
 401458c:	1000051e 	bne	r2,zero,40145a4 <_signal_r+0x44>
    {
      ptr->_errno = EINVAL;
 4014590:	e0bffe17 	ldw	r2,-8(fp)
 4014594:	00c00584 	movi	r3,22
 4014598:	10c00015 	stw	r3,0(r2)
      return SIG_ERR;
 401459c:	00bfffc4 	movi	r2,-1
 40145a0:	00001706 	br	4014600 <_signal_r+0xa0>
    }

  if (ptr->_sig_func == NULL && _init_signal_r (ptr) != 0)
 40145a4:	e0bffe17 	ldw	r2,-8(fp)
 40145a8:	1080b717 	ldw	r2,732(r2)
 40145ac:	1000051e 	bne	r2,zero,40145c4 <_signal_r+0x64>
 40145b0:	e13ffe17 	ldw	r4,-8(fp)
 40145b4:	40144c40 	call	40144c4 <_init_signal_r>
 40145b8:	10000226 	beq	r2,zero,40145c4 <_signal_r+0x64>
    return SIG_ERR;
 40145bc:	00bfffc4 	movi	r2,-1
 40145c0:	00000f06 	br	4014600 <_signal_r+0xa0>
  
  old_func = ptr->_sig_func[sig];
 40145c4:	e0bffe17 	ldw	r2,-8(fp)
 40145c8:	10c0b717 	ldw	r3,732(r2)
 40145cc:	e0bffd17 	ldw	r2,-12(fp)
 40145d0:	100490ba 	slli	r2,r2,2
 40145d4:	1885883a 	add	r2,r3,r2
 40145d8:	10800017 	ldw	r2,0(r2)
 40145dc:	e0bfff15 	stw	r2,-4(fp)
  ptr->_sig_func[sig] = func;
 40145e0:	e0bffe17 	ldw	r2,-8(fp)
 40145e4:	10c0b717 	ldw	r3,732(r2)
 40145e8:	e0bffd17 	ldw	r2,-12(fp)
 40145ec:	100490ba 	slli	r2,r2,2
 40145f0:	1885883a 	add	r2,r3,r2
 40145f4:	e0fffc17 	ldw	r3,-16(fp)
 40145f8:	10c00015 	stw	r3,0(r2)

  return old_func;
 40145fc:	e0bfff17 	ldw	r2,-4(fp)
}
 4014600:	e037883a 	mov	sp,fp
 4014604:	dfc00117 	ldw	ra,4(sp)
 4014608:	df000017 	ldw	fp,0(sp)
 401460c:	dec00204 	addi	sp,sp,8
 4014610:	f800283a 	ret

04014614 <_raise_r>:

int 
_raise_r (struct _reent *ptr,
     int sig)
{
 4014614:	defffb04 	addi	sp,sp,-20
 4014618:	dfc00415 	stw	ra,16(sp)
 401461c:	df000315 	stw	fp,12(sp)
 4014620:	df000304 	addi	fp,sp,12
 4014624:	e13ffe15 	stw	r4,-8(fp)
 4014628:	e17ffd15 	stw	r5,-12(fp)
  _sig_func_ptr func;

  if (sig < 0 || sig >= NSIG)
 401462c:	e0bffd17 	ldw	r2,-12(fp)
 4014630:	10000316 	blt	r2,zero,4014640 <_raise_r+0x2c>
 4014634:	e0bffd17 	ldw	r2,-12(fp)
 4014638:	10800810 	cmplti	r2,r2,32
 401463c:	1000051e 	bne	r2,zero,4014654 <_raise_r+0x40>
    {
      ptr->_errno = EINVAL;
 4014640:	e0bffe17 	ldw	r2,-8(fp)
 4014644:	00c00584 	movi	r3,22
 4014648:	10c00015 	stw	r3,0(r2)
      return -1;
 401464c:	00bfffc4 	movi	r2,-1
 4014650:	00002c06 	br	4014704 <_raise_r+0xf0>
    }

  if (ptr->_sig_func == NULL)
 4014654:	e0bffe17 	ldw	r2,-8(fp)
 4014658:	1080b717 	ldw	r2,732(r2)
 401465c:	1000021e 	bne	r2,zero,4014668 <_raise_r+0x54>
    func = SIG_DFL;
 4014660:	e03fff15 	stw	zero,-4(fp)
 4014664:	00000706 	br	4014684 <_raise_r+0x70>
  else
    func = ptr->_sig_func[sig];
 4014668:	e0bffe17 	ldw	r2,-8(fp)
 401466c:	10c0b717 	ldw	r3,732(r2)
 4014670:	e0bffd17 	ldw	r2,-12(fp)
 4014674:	100490ba 	slli	r2,r2,2
 4014678:	1885883a 	add	r2,r3,r2
 401467c:	10800017 	ldw	r2,0(r2)
 4014680:	e0bfff15 	stw	r2,-4(fp)

  if (func == SIG_DFL)
 4014684:	e0bfff17 	ldw	r2,-4(fp)
 4014688:	1000071e 	bne	r2,zero,40146a8 <_raise_r+0x94>
    return _kill_r (ptr, _getpid_r (ptr), sig);
 401468c:	e13ffe17 	ldw	r4,-8(fp)
 4014690:	40149440 	call	4014944 <_getpid_r>
 4014694:	e1bffd17 	ldw	r6,-12(fp)
 4014698:	100b883a 	mov	r5,r2
 401469c:	e13ffe17 	ldw	r4,-8(fp)
 40146a0:	40148dc0 	call	40148dc <_kill_r>
 40146a4:	00001706 	br	4014704 <_raise_r+0xf0>
  else if (func == SIG_IGN)
 40146a8:	e0bfff17 	ldw	r2,-4(fp)
 40146ac:	10800058 	cmpnei	r2,r2,1
 40146b0:	1000021e 	bne	r2,zero,40146bc <_raise_r+0xa8>
    return 0;
 40146b4:	0005883a 	mov	r2,zero
 40146b8:	00001206 	br	4014704 <_raise_r+0xf0>
  else if (func == SIG_ERR)
 40146bc:	e0bfff17 	ldw	r2,-4(fp)
 40146c0:	10bfffd8 	cmpnei	r2,r2,-1
 40146c4:	1000051e 	bne	r2,zero,40146dc <_raise_r+0xc8>
    {
      ptr->_errno = EINVAL;
 40146c8:	e0bffe17 	ldw	r2,-8(fp)
 40146cc:	00c00584 	movi	r3,22
 40146d0:	10c00015 	stw	r3,0(r2)
      return 1;
 40146d4:	00800044 	movi	r2,1
 40146d8:	00000a06 	br	4014704 <_raise_r+0xf0>
    }
  else
    {
      ptr->_sig_func[sig] = SIG_DFL;
 40146dc:	e0bffe17 	ldw	r2,-8(fp)
 40146e0:	10c0b717 	ldw	r3,732(r2)
 40146e4:	e0bffd17 	ldw	r2,-12(fp)
 40146e8:	100490ba 	slli	r2,r2,2
 40146ec:	1885883a 	add	r2,r3,r2
 40146f0:	10000015 	stw	zero,0(r2)
      func (sig);
 40146f4:	e0bfff17 	ldw	r2,-4(fp)
 40146f8:	e13ffd17 	ldw	r4,-12(fp)
 40146fc:	103ee83a 	callr	r2
      return 0;
 4014700:	0005883a 	mov	r2,zero
    }
}
 4014704:	e037883a 	mov	sp,fp
 4014708:	dfc00117 	ldw	ra,4(sp)
 401470c:	df000017 	ldw	fp,0(sp)
 4014710:	dec00204 	addi	sp,sp,8
 4014714:	f800283a 	ret

04014718 <__sigtramp_r>:

int
__sigtramp_r (struct _reent *ptr,
     int sig)
{
 4014718:	defffb04 	addi	sp,sp,-20
 401471c:	dfc00415 	stw	ra,16(sp)
 4014720:	df000315 	stw	fp,12(sp)
 4014724:	df000304 	addi	fp,sp,12
 4014728:	e13ffe15 	stw	r4,-8(fp)
 401472c:	e17ffd15 	stw	r5,-12(fp)
  _sig_func_ptr func;

  if (sig < 0 || sig >= NSIG)
 4014730:	e0bffd17 	ldw	r2,-12(fp)
 4014734:	10000316 	blt	r2,zero,4014744 <__sigtramp_r+0x2c>
 4014738:	e0bffd17 	ldw	r2,-12(fp)
 401473c:	10800810 	cmplti	r2,r2,32
 4014740:	1000021e 	bne	r2,zero,401474c <__sigtramp_r+0x34>
    {
      return -1;
 4014744:	00bfffc4 	movi	r2,-1
 4014748:	00002706 	br	40147e8 <__sigtramp_r+0xd0>
    }

  if (ptr->_sig_func == NULL && _init_signal_r (ptr) != 0)
 401474c:	e0bffe17 	ldw	r2,-8(fp)
 4014750:	1080b717 	ldw	r2,732(r2)
 4014754:	1000051e 	bne	r2,zero,401476c <__sigtramp_r+0x54>
 4014758:	e13ffe17 	ldw	r4,-8(fp)
 401475c:	40144c40 	call	40144c4 <_init_signal_r>
 4014760:	10000226 	beq	r2,zero,401476c <__sigtramp_r+0x54>
    return -1;
 4014764:	00bfffc4 	movi	r2,-1
 4014768:	00001f06 	br	40147e8 <__sigtramp_r+0xd0>

  func = ptr->_sig_func[sig];
 401476c:	e0bffe17 	ldw	r2,-8(fp)
 4014770:	10c0b717 	ldw	r3,732(r2)
 4014774:	e0bffd17 	ldw	r2,-12(fp)
 4014778:	100490ba 	slli	r2,r2,2
 401477c:	1885883a 	add	r2,r3,r2
 4014780:	10800017 	ldw	r2,0(r2)
 4014784:	e0bfff15 	stw	r2,-4(fp)
  if (func == SIG_DFL)
 4014788:	e0bfff17 	ldw	r2,-4(fp)
 401478c:	1000021e 	bne	r2,zero,4014798 <__sigtramp_r+0x80>
    return 1;
 4014790:	00800044 	movi	r2,1
 4014794:	00001406 	br	40147e8 <__sigtramp_r+0xd0>
  else if (func == SIG_ERR)
 4014798:	e0bfff17 	ldw	r2,-4(fp)
 401479c:	10bfffd8 	cmpnei	r2,r2,-1
 40147a0:	1000021e 	bne	r2,zero,40147ac <__sigtramp_r+0x94>
    return 2;
 40147a4:	00800084 	movi	r2,2
 40147a8:	00000f06 	br	40147e8 <__sigtramp_r+0xd0>
  else if (func == SIG_IGN)
 40147ac:	e0bfff17 	ldw	r2,-4(fp)
 40147b0:	10800058 	cmpnei	r2,r2,1
 40147b4:	1000021e 	bne	r2,zero,40147c0 <__sigtramp_r+0xa8>
    return 3;
 40147b8:	008000c4 	movi	r2,3
 40147bc:	00000a06 	br	40147e8 <__sigtramp_r+0xd0>
  else
    {
      ptr->_sig_func[sig] = SIG_DFL;
 40147c0:	e0bffe17 	ldw	r2,-8(fp)
 40147c4:	10c0b717 	ldw	r3,732(r2)
 40147c8:	e0bffd17 	ldw	r2,-12(fp)
 40147cc:	100490ba 	slli	r2,r2,2
 40147d0:	1885883a 	add	r2,r3,r2
 40147d4:	10000015 	stw	zero,0(r2)
      func (sig);
 40147d8:	e0bfff17 	ldw	r2,-4(fp)
 40147dc:	e13ffd17 	ldw	r4,-12(fp)
 40147e0:	103ee83a 	callr	r2
      return 0;
 40147e4:	0005883a 	mov	r2,zero
    }
}
 40147e8:	e037883a 	mov	sp,fp
 40147ec:	dfc00117 	ldw	ra,4(sp)
 40147f0:	df000017 	ldw	fp,0(sp)
 40147f4:	dec00204 	addi	sp,sp,8
 40147f8:	f800283a 	ret

040147fc <raise>:

#ifndef _REENT_ONLY

int 
raise (int sig)
{
 40147fc:	defffd04 	addi	sp,sp,-12
 4014800:	dfc00215 	stw	ra,8(sp)
 4014804:	df000115 	stw	fp,4(sp)
 4014808:	df000104 	addi	fp,sp,4
 401480c:	e13fff15 	stw	r4,-4(fp)
  return _raise_r (_REENT, sig);
 4014810:	d0a00117 	ldw	r2,-32764(gp)
 4014814:	e17fff17 	ldw	r5,-4(fp)
 4014818:	1009883a 	mov	r4,r2
 401481c:	40146140 	call	4014614 <_raise_r>
}
 4014820:	e037883a 	mov	sp,fp
 4014824:	dfc00117 	ldw	ra,4(sp)
 4014828:	df000017 	ldw	fp,0(sp)
 401482c:	dec00204 	addi	sp,sp,8
 4014830:	f800283a 	ret

04014834 <signal>:

_sig_func_ptr
signal (int sig,
	_sig_func_ptr func)
{
 4014834:	defffc04 	addi	sp,sp,-16
 4014838:	dfc00315 	stw	ra,12(sp)
 401483c:	df000215 	stw	fp,8(sp)
 4014840:	df000204 	addi	fp,sp,8
 4014844:	e13fff15 	stw	r4,-4(fp)
 4014848:	e17ffe15 	stw	r5,-8(fp)
  return _signal_r (_REENT, sig, func);
 401484c:	d0a00117 	ldw	r2,-32764(gp)
 4014850:	e1bffe17 	ldw	r6,-8(fp)
 4014854:	e17fff17 	ldw	r5,-4(fp)
 4014858:	1009883a 	mov	r4,r2
 401485c:	40145600 	call	4014560 <_signal_r>
}
 4014860:	e037883a 	mov	sp,fp
 4014864:	dfc00117 	ldw	ra,4(sp)
 4014868:	df000017 	ldw	fp,0(sp)
 401486c:	dec00204 	addi	sp,sp,8
 4014870:	f800283a 	ret

04014874 <_init_signal>:

int 
_init_signal (void)
{
 4014874:	defffe04 	addi	sp,sp,-8
 4014878:	dfc00115 	stw	ra,4(sp)
 401487c:	df000015 	stw	fp,0(sp)
 4014880:	d839883a 	mov	fp,sp
  return _init_signal_r (_REENT);
 4014884:	d0a00117 	ldw	r2,-32764(gp)
 4014888:	1009883a 	mov	r4,r2
 401488c:	40144c40 	call	40144c4 <_init_signal_r>
}
 4014890:	e037883a 	mov	sp,fp
 4014894:	dfc00117 	ldw	ra,4(sp)
 4014898:	df000017 	ldw	fp,0(sp)
 401489c:	dec00204 	addi	sp,sp,8
 40148a0:	f800283a 	ret

040148a4 <__sigtramp>:

int
__sigtramp (int sig)
{
 40148a4:	defffd04 	addi	sp,sp,-12
 40148a8:	dfc00215 	stw	ra,8(sp)
 40148ac:	df000115 	stw	fp,4(sp)
 40148b0:	df000104 	addi	fp,sp,4
 40148b4:	e13fff15 	stw	r4,-4(fp)
  return __sigtramp_r (_REENT, sig);
 40148b8:	d0a00117 	ldw	r2,-32764(gp)
 40148bc:	e17fff17 	ldw	r5,-4(fp)
 40148c0:	1009883a 	mov	r4,r2
 40148c4:	40147180 	call	4014718 <__sigtramp_r>
}
 40148c8:	e037883a 	mov	sp,fp
 40148cc:	dfc00117 	ldw	ra,4(sp)
 40148d0:	df000017 	ldw	fp,0(sp)
 40148d4:	dec00204 	addi	sp,sp,8
 40148d8:	f800283a 	ret

040148dc <_kill_r>:

int
_kill_r (struct _reent *ptr,
     int pid,
     int sig)
{
 40148dc:	defffa04 	addi	sp,sp,-24
 40148e0:	dfc00515 	stw	ra,20(sp)
 40148e4:	df000415 	stw	fp,16(sp)
 40148e8:	df000404 	addi	fp,sp,16
 40148ec:	e13ffe15 	stw	r4,-8(fp)
 40148f0:	e17ffd15 	stw	r5,-12(fp)
 40148f4:	e1bffc15 	stw	r6,-16(fp)
  int ret;

  errno = 0;
 40148f8:	d0272915 	stw	zero,-25436(gp)
  if ((ret = _kill (pid, sig)) == -1 && errno != 0)
 40148fc:	e17ffc17 	ldw	r5,-16(fp)
 4014900:	e13ffd17 	ldw	r4,-12(fp)
 4014904:	40184080 	call	4018408 <kill>
 4014908:	e0bfff15 	stw	r2,-4(fp)
 401490c:	e0bfff17 	ldw	r2,-4(fp)
 4014910:	10bfffd8 	cmpnei	r2,r2,-1
 4014914:	1000051e 	bne	r2,zero,401492c <_kill_r+0x50>
 4014918:	d0a72917 	ldw	r2,-25436(gp)
 401491c:	10000326 	beq	r2,zero,401492c <_kill_r+0x50>
    ptr->_errno = errno;
 4014920:	d0e72917 	ldw	r3,-25436(gp)
 4014924:	e0bffe17 	ldw	r2,-8(fp)
 4014928:	10c00015 	stw	r3,0(r2)
  return ret;
 401492c:	e0bfff17 	ldw	r2,-4(fp)
}
 4014930:	e037883a 	mov	sp,fp
 4014934:	dfc00117 	ldw	ra,4(sp)
 4014938:	df000017 	ldw	fp,0(sp)
 401493c:	dec00204 	addi	sp,sp,8
 4014940:	f800283a 	ret

04014944 <_getpid_r>:
	still must have the reentrant pointer argument.
*/

int
_getpid_r (struct _reent *ptr)
{
 4014944:	defffc04 	addi	sp,sp,-16
 4014948:	dfc00315 	stw	ra,12(sp)
 401494c:	df000215 	stw	fp,8(sp)
 4014950:	df000204 	addi	fp,sp,8
 4014954:	e13ffe15 	stw	r4,-8(fp)
  int ret;
  ret = _getpid ();
 4014958:	40180280 	call	4018028 <getpid>
 401495c:	e0bfff15 	stw	r2,-4(fp)
  return ret;
 4014960:	e0bfff17 	ldw	r2,-4(fp)
}
 4014964:	e037883a 	mov	sp,fp
 4014968:	dfc00117 	ldw	ra,4(sp)
 401496c:	df000017 	ldw	fp,0(sp)
 4014970:	dec00204 	addi	sp,sp,8
 4014974:	f800283a 	ret

04014978 <__udivdi3>:
 4014978:	defff504 	addi	sp,sp,-44
 401497c:	dd000515 	stw	r20,20(sp)
 4014980:	dc800315 	stw	r18,12(sp)
 4014984:	dfc00a15 	stw	ra,40(sp)
 4014988:	df000915 	stw	fp,36(sp)
 401498c:	ddc00815 	stw	r23,32(sp)
 4014990:	dd800715 	stw	r22,28(sp)
 4014994:	dd400615 	stw	r21,24(sp)
 4014998:	dcc00415 	stw	r19,16(sp)
 401499c:	dc400215 	stw	r17,8(sp)
 40149a0:	dc000115 	stw	r16,4(sp)
 40149a4:	2029883a 	mov	r20,r4
 40149a8:	2825883a 	mov	r18,r5
 40149ac:	3800461e 	bne	r7,zero,4014ac8 <__udivdi3+0x150>
 40149b0:	3823883a 	mov	r17,r7
 40149b4:	3021883a 	mov	r16,r6
 40149b8:	2027883a 	mov	r19,r4
 40149bc:	2980622e 	bgeu	r5,r6,4014b48 <__udivdi3+0x1d0>
 40149c0:	00bfffd4 	movui	r2,65535
 40149c4:	282b883a 	mov	r21,r5
 40149c8:	1180aa2e 	bgeu	r2,r6,4014c74 <__udivdi3+0x2fc>
 40149cc:	00804034 	movhi	r2,256
 40149d0:	30815936 	bltu	r6,r2,4014f38 <__udivdi3+0x5c0>
 40149d4:	3006d63a 	srli	r3,r6,24
 40149d8:	04400604 	movi	r17,24
 40149dc:	008100b4 	movhi	r2,1026
 40149e0:	1885883a 	add	r2,r3,r2
 40149e4:	112c7c03 	ldbu	r4,-19984(r2)
 40149e8:	00800804 	movi	r2,32
 40149ec:	2463883a 	add	r17,r4,r17
 40149f0:	1449c83a 	sub	r4,r2,r17
 40149f4:	14400526 	beq	r2,r17,4014a0c <__udivdi3+0x94>
 40149f8:	9106983a 	sll	r3,r18,r4
 40149fc:	a462d83a 	srl	r17,r20,r17
 4014a00:	3120983a 	sll	r16,r6,r4
 4014a04:	a126983a 	sll	r19,r20,r4
 4014a08:	88eab03a 	or	r21,r17,r3
 4014a0c:	802cd43a 	srli	r22,r16,16
 4014a10:	a809883a 	mov	r4,r21
 4014a14:	853fffcc 	andi	r20,r16,65535
 4014a18:	b00b883a 	mov	r5,r22
 4014a1c:	40075480 	call	4007548 <__umodsi3>
 4014a20:	a809883a 	mov	r4,r21
 4014a24:	b00b883a 	mov	r5,r22
 4014a28:	1025883a 	mov	r18,r2
 4014a2c:	40074e40 	call	40074e4 <__udivsi3>
 4014a30:	a009883a 	mov	r4,r20
 4014a34:	100b883a 	mov	r5,r2
 4014a38:	102b883a 	mov	r21,r2
 4014a3c:	40075a40 	call	40075a4 <__mulsi3>
 4014a40:	9024943a 	slli	r18,r18,16
 4014a44:	9808d43a 	srli	r4,r19,16
 4014a48:	9108b03a 	or	r4,r18,r4
 4014a4c:	2080052e 	bgeu	r4,r2,4014a64 <__udivdi3+0xec>
 4014a50:	2409883a 	add	r4,r4,r16
 4014a54:	a8ffffc4 	addi	r3,r21,-1
 4014a58:	24000136 	bltu	r4,r16,4014a60 <__udivdi3+0xe8>
 4014a5c:	20814736 	bltu	r4,r2,4014f7c <__udivdi3+0x604>
 4014a60:	182b883a 	mov	r21,r3
 4014a64:	20a3c83a 	sub	r17,r4,r2
 4014a68:	8809883a 	mov	r4,r17
 4014a6c:	b00b883a 	mov	r5,r22
 4014a70:	40075480 	call	4007548 <__umodsi3>
 4014a74:	8809883a 	mov	r4,r17
 4014a78:	1023883a 	mov	r17,r2
 4014a7c:	b00b883a 	mov	r5,r22
 4014a80:	8822943a 	slli	r17,r17,16
 4014a84:	40074e40 	call	40074e4 <__udivsi3>
 4014a88:	100b883a 	mov	r5,r2
 4014a8c:	a009883a 	mov	r4,r20
 4014a90:	9cffffcc 	andi	r19,r19,65535
 4014a94:	1025883a 	mov	r18,r2
 4014a98:	8ce6b03a 	or	r19,r17,r19
 4014a9c:	40075a40 	call	40075a4 <__mulsi3>
 4014aa0:	9880052e 	bgeu	r19,r2,4014ab8 <__udivdi3+0x140>
 4014aa4:	84e7883a 	add	r19,r16,r19
 4014aa8:	90ffffc4 	addi	r3,r18,-1
 4014aac:	9c000136 	bltu	r19,r16,4014ab4 <__udivdi3+0x13c>
 4014ab0:	98813036 	bltu	r19,r2,4014f74 <__udivdi3+0x5fc>
 4014ab4:	1825883a 	mov	r18,r3
 4014ab8:	a80c943a 	slli	r6,r21,16
 4014abc:	0007883a 	mov	r3,zero
 4014ac0:	3484b03a 	or	r2,r6,r18
 4014ac4:	00000306 	br	4014ad4 <__udivdi3+0x15c>
 4014ac8:	29c00e2e 	bgeu	r5,r7,4014b04 <__udivdi3+0x18c>
 4014acc:	0007883a 	mov	r3,zero
 4014ad0:	0005883a 	mov	r2,zero
 4014ad4:	dfc00a17 	ldw	ra,40(sp)
 4014ad8:	df000917 	ldw	fp,36(sp)
 4014adc:	ddc00817 	ldw	r23,32(sp)
 4014ae0:	dd800717 	ldw	r22,28(sp)
 4014ae4:	dd400617 	ldw	r21,24(sp)
 4014ae8:	dd000517 	ldw	r20,20(sp)
 4014aec:	dcc00417 	ldw	r19,16(sp)
 4014af0:	dc800317 	ldw	r18,12(sp)
 4014af4:	dc400217 	ldw	r17,8(sp)
 4014af8:	dc000117 	ldw	r16,4(sp)
 4014afc:	dec00b04 	addi	sp,sp,44
 4014b00:	f800283a 	ret
 4014b04:	00bfffd4 	movui	r2,65535
 4014b08:	11c05f2e 	bgeu	r2,r7,4014c88 <__udivdi3+0x310>
 4014b0c:	00804034 	movhi	r2,256
 4014b10:	3880fb36 	bltu	r7,r2,4014f00 <__udivdi3+0x588>
 4014b14:	3806d63a 	srli	r3,r7,24
 4014b18:	01000604 	movi	r4,24
 4014b1c:	008100b4 	movhi	r2,1026
 4014b20:	1885883a 	add	r2,r3,r2
 4014b24:	10ec7c03 	ldbu	r3,-19984(r2)
 4014b28:	00800804 	movi	r2,32
 4014b2c:	1907883a 	add	r3,r3,r4
 4014b30:	10e3c83a 	sub	r17,r2,r3
 4014b34:	10c0901e 	bne	r2,r3,4014d78 <__udivdi3+0x400>
 4014b38:	3c80f636 	bltu	r7,r18,4014f14 <__udivdi3+0x59c>
 4014b3c:	a185403a 	cmpgeu	r2,r20,r6
 4014b40:	0007883a 	mov	r3,zero
 4014b44:	003fe306 	br	4014ad4 <__udivdi3+0x15c>
 4014b48:	3000041e 	bne	r6,zero,4014b5c <__udivdi3+0x1e4>
 4014b4c:	000b883a 	mov	r5,zero
 4014b50:	01000044 	movi	r4,1
 4014b54:	40074e40 	call	40074e4 <__udivsi3>
 4014b58:	1021883a 	mov	r16,r2
 4014b5c:	00bfffd4 	movui	r2,65535
 4014b60:	14003f2e 	bgeu	r2,r16,4014c60 <__udivdi3+0x2e8>
 4014b64:	00804034 	movhi	r2,256
 4014b68:	8080f036 	bltu	r16,r2,4014f2c <__udivdi3+0x5b4>
 4014b6c:	8006d63a 	srli	r3,r16,24
 4014b70:	04400604 	movi	r17,24
 4014b74:	008100b4 	movhi	r2,1026
 4014b78:	1885883a 	add	r2,r3,r2
 4014b7c:	10ac7c03 	ldbu	r2,-19984(r2)
 4014b80:	00c00804 	movi	r3,32
 4014b84:	1463883a 	add	r17,r2,r17
 4014b88:	1c45c83a 	sub	r2,r3,r17
 4014b8c:	1c40431e 	bne	r3,r17,4014c9c <__udivdi3+0x324>
 4014b90:	802cd43a 	srli	r22,r16,16
 4014b94:	9423c83a 	sub	r17,r18,r16
 4014b98:	853fffcc 	andi	r20,r16,65535
 4014b9c:	00c00044 	movi	r3,1
 4014ba0:	b00b883a 	mov	r5,r22
 4014ba4:	8809883a 	mov	r4,r17
 4014ba8:	d8c00015 	stw	r3,0(sp)
 4014bac:	40075480 	call	4007548 <__umodsi3>
 4014bb0:	b00b883a 	mov	r5,r22
 4014bb4:	8809883a 	mov	r4,r17
 4014bb8:	1025883a 	mov	r18,r2
 4014bbc:	40074e40 	call	40074e4 <__udivsi3>
 4014bc0:	1009883a 	mov	r4,r2
 4014bc4:	a00b883a 	mov	r5,r20
 4014bc8:	102b883a 	mov	r21,r2
 4014bcc:	40075a40 	call	40075a4 <__mulsi3>
 4014bd0:	9024943a 	slli	r18,r18,16
 4014bd4:	9808d43a 	srli	r4,r19,16
 4014bd8:	d8c00017 	ldw	r3,0(sp)
 4014bdc:	9108b03a 	or	r4,r18,r4
 4014be0:	2080052e 	bgeu	r4,r2,4014bf8 <__udivdi3+0x280>
 4014be4:	2409883a 	add	r4,r4,r16
 4014be8:	a97fffc4 	addi	r5,r21,-1
 4014bec:	24000136 	bltu	r4,r16,4014bf4 <__udivdi3+0x27c>
 4014bf0:	2080e536 	bltu	r4,r2,4014f88 <__udivdi3+0x610>
 4014bf4:	282b883a 	mov	r21,r5
 4014bf8:	20a3c83a 	sub	r17,r4,r2
 4014bfc:	8809883a 	mov	r4,r17
 4014c00:	b00b883a 	mov	r5,r22
 4014c04:	d8c00015 	stw	r3,0(sp)
 4014c08:	40075480 	call	4007548 <__umodsi3>
 4014c0c:	8809883a 	mov	r4,r17
 4014c10:	1023883a 	mov	r17,r2
 4014c14:	b00b883a 	mov	r5,r22
 4014c18:	8822943a 	slli	r17,r17,16
 4014c1c:	40074e40 	call	40074e4 <__udivsi3>
 4014c20:	a00b883a 	mov	r5,r20
 4014c24:	1009883a 	mov	r4,r2
 4014c28:	9cffffcc 	andi	r19,r19,65535
 4014c2c:	1025883a 	mov	r18,r2
 4014c30:	8ce6b03a 	or	r19,r17,r19
 4014c34:	40075a40 	call	40075a4 <__mulsi3>
 4014c38:	d8c00017 	ldw	r3,0(sp)
 4014c3c:	9880052e 	bgeu	r19,r2,4014c54 <__udivdi3+0x2dc>
 4014c40:	84e7883a 	add	r19,r16,r19
 4014c44:	913fffc4 	addi	r4,r18,-1
 4014c48:	9c000136 	bltu	r19,r16,4014c50 <__udivdi3+0x2d8>
 4014c4c:	9880c736 	bltu	r19,r2,4014f6c <__udivdi3+0x5f4>
 4014c50:	2025883a 	mov	r18,r4
 4014c54:	a80c943a 	slli	r6,r21,16
 4014c58:	3484b03a 	or	r2,r6,r18
 4014c5c:	003f9d06 	br	4014ad4 <__udivdi3+0x15c>
 4014c60:	80804030 	cmpltui	r2,r16,256
 4014c64:	1000b71e 	bne	r2,zero,4014f44 <__udivdi3+0x5cc>
 4014c68:	8006d23a 	srli	r3,r16,8
 4014c6c:	04400204 	movi	r17,8
 4014c70:	003fc006 	br	4014b74 <__udivdi3+0x1fc>
 4014c74:	30804030 	cmpltui	r2,r6,256
 4014c78:	1000a41e 	bne	r2,zero,4014f0c <__udivdi3+0x594>
 4014c7c:	3006d23a 	srli	r3,r6,8
 4014c80:	04400204 	movi	r17,8
 4014c84:	003f5506 	br	40149dc <__udivdi3+0x64>
 4014c88:	38804030 	cmpltui	r2,r7,256
 4014c8c:	1000a41e 	bne	r2,zero,4014f20 <__udivdi3+0x5a8>
 4014c90:	3806d23a 	srli	r3,r7,8
 4014c94:	01000204 	movi	r4,8
 4014c98:	003fa006 	br	4014b1c <__udivdi3+0x1a4>
 4014c9c:	80a0983a 	sll	r16,r16,r2
 4014ca0:	946ed83a 	srl	r23,r18,r17
 4014ca4:	9086983a 	sll	r3,r18,r2
 4014ca8:	802cd43a 	srli	r22,r16,16
 4014cac:	a462d83a 	srl	r17,r20,r17
 4014cb0:	b809883a 	mov	r4,r23
 4014cb4:	b00b883a 	mov	r5,r22
 4014cb8:	88eab03a 	or	r21,r17,r3
 4014cbc:	a0a6983a 	sll	r19,r20,r2
 4014cc0:	40075480 	call	4007548 <__umodsi3>
 4014cc4:	b809883a 	mov	r4,r23
 4014cc8:	b00b883a 	mov	r5,r22
 4014ccc:	1025883a 	mov	r18,r2
 4014cd0:	853fffcc 	andi	r20,r16,65535
 4014cd4:	40074e40 	call	40074e4 <__udivsi3>
 4014cd8:	a009883a 	mov	r4,r20
 4014cdc:	100b883a 	mov	r5,r2
 4014ce0:	102f883a 	mov	r23,r2
 4014ce4:	40075a40 	call	40075a4 <__mulsi3>
 4014ce8:	9024943a 	slli	r18,r18,16
 4014cec:	a808d43a 	srli	r4,r21,16
 4014cf0:	9108b03a 	or	r4,r18,r4
 4014cf4:	2080062e 	bgeu	r4,r2,4014d10 <__udivdi3+0x398>
 4014cf8:	2409883a 	add	r4,r4,r16
 4014cfc:	b8ffffc4 	addi	r3,r23,-1
 4014d00:	24009836 	bltu	r4,r16,4014f64 <__udivdi3+0x5ec>
 4014d04:	2080972e 	bgeu	r4,r2,4014f64 <__udivdi3+0x5ec>
 4014d08:	bdffff84 	addi	r23,r23,-2
 4014d0c:	2409883a 	add	r4,r4,r16
 4014d10:	20a3c83a 	sub	r17,r4,r2
 4014d14:	8809883a 	mov	r4,r17
 4014d18:	b00b883a 	mov	r5,r22
 4014d1c:	40075480 	call	4007548 <__umodsi3>
 4014d20:	1025883a 	mov	r18,r2
 4014d24:	8809883a 	mov	r4,r17
 4014d28:	b00b883a 	mov	r5,r22
 4014d2c:	9024943a 	slli	r18,r18,16
 4014d30:	40074e40 	call	40074e4 <__udivsi3>
 4014d34:	100b883a 	mov	r5,r2
 4014d38:	a009883a 	mov	r4,r20
 4014d3c:	ac7fffcc 	andi	r17,r21,65535
 4014d40:	1039883a 	mov	fp,r2
 4014d44:	9462b03a 	or	r17,r18,r17
 4014d48:	40075a40 	call	40075a4 <__mulsi3>
 4014d4c:	8880062e 	bgeu	r17,r2,4014d68 <__udivdi3+0x3f0>
 4014d50:	8c23883a 	add	r17,r17,r16
 4014d54:	e0ffffc4 	addi	r3,fp,-1
 4014d58:	8c007e36 	bltu	r17,r16,4014f54 <__udivdi3+0x5dc>
 4014d5c:	88807d2e 	bgeu	r17,r2,4014f54 <__udivdi3+0x5dc>
 4014d60:	e73fff84 	addi	fp,fp,-2
 4014d64:	8c23883a 	add	r17,r17,r16
 4014d68:	b806943a 	slli	r3,r23,16
 4014d6c:	88a3c83a 	sub	r17,r17,r2
 4014d70:	1f06b03a 	or	r3,r3,fp
 4014d74:	003f8a06 	br	4014ba0 <__udivdi3+0x228>
 4014d78:	30e6d83a 	srl	r19,r6,r3
 4014d7c:	3c4e983a 	sll	r7,r7,r17
 4014d80:	90e0d83a 	srl	r16,r18,r3
 4014d84:	a0c4d83a 	srl	r2,r20,r3
 4014d88:	99e6b03a 	or	r19,r19,r7
 4014d8c:	9446983a 	sll	r3,r18,r17
 4014d90:	9838d43a 	srli	fp,r19,16
 4014d94:	8009883a 	mov	r4,r16
 4014d98:	10eab03a 	or	r21,r2,r3
 4014d9c:	e00b883a 	mov	r5,fp
 4014da0:	346c983a 	sll	r22,r6,r17
 4014da4:	dd400015 	stw	r21,0(sp)
 4014da8:	40075480 	call	4007548 <__umodsi3>
 4014dac:	8009883a 	mov	r4,r16
 4014db0:	e00b883a 	mov	r5,fp
 4014db4:	102f883a 	mov	r23,r2
 4014db8:	9cbfffcc 	andi	r18,r19,65535
 4014dbc:	40074e40 	call	40074e4 <__udivsi3>
 4014dc0:	9009883a 	mov	r4,r18
 4014dc4:	100b883a 	mov	r5,r2
 4014dc8:	1021883a 	mov	r16,r2
 4014dcc:	40075a40 	call	40075a4 <__mulsi3>
 4014dd0:	b82e943a 	slli	r23,r23,16
 4014dd4:	a808d43a 	srli	r4,r21,16
 4014dd8:	b908b03a 	or	r4,r23,r4
 4014ddc:	2080062e 	bgeu	r4,r2,4014df8 <__udivdi3+0x480>
 4014de0:	24c9883a 	add	r4,r4,r19
 4014de4:	817fffc4 	addi	r5,r16,-1
 4014de8:	24c05c36 	bltu	r4,r19,4014f5c <__udivdi3+0x5e4>
 4014dec:	20805b2e 	bgeu	r4,r2,4014f5c <__udivdi3+0x5e4>
 4014df0:	843fff84 	addi	r16,r16,-2
 4014df4:	24c9883a 	add	r4,r4,r19
 4014df8:	20abc83a 	sub	r21,r4,r2
 4014dfc:	a809883a 	mov	r4,r21
 4014e00:	e00b883a 	mov	r5,fp
 4014e04:	40075480 	call	4007548 <__umodsi3>
 4014e08:	a809883a 	mov	r4,r21
 4014e0c:	e00b883a 	mov	r5,fp
 4014e10:	102b883a 	mov	r21,r2
 4014e14:	40074e40 	call	40074e4 <__udivsi3>
 4014e18:	9009883a 	mov	r4,r18
 4014e1c:	100b883a 	mov	r5,r2
 4014e20:	102f883a 	mov	r23,r2
 4014e24:	40075a40 	call	40075a4 <__mulsi3>
 4014e28:	d8c00017 	ldw	r3,0(sp)
 4014e2c:	a82a943a 	slli	r21,r21,16
 4014e30:	1cbfffcc 	andi	r18,r3,65535
 4014e34:	aca4b03a 	or	r18,r21,r18
 4014e38:	9080062e 	bgeu	r18,r2,4014e54 <__udivdi3+0x4dc>
 4014e3c:	94e5883a 	add	r18,r18,r19
 4014e40:	b8ffffc4 	addi	r3,r23,-1
 4014e44:	94c04136 	bltu	r18,r19,4014f4c <__udivdi3+0x5d4>
 4014e48:	9080402e 	bgeu	r18,r2,4014f4c <__udivdi3+0x5d4>
 4014e4c:	bdffff84 	addi	r23,r23,-2
 4014e50:	94e5883a 	add	r18,r18,r19
 4014e54:	8020943a 	slli	r16,r16,16
 4014e58:	bd7fffcc 	andi	r21,r23,65535
 4014e5c:	b73fffcc 	andi	fp,r22,65535
 4014e60:	85e0b03a 	or	r16,r16,r23
 4014e64:	8026d43a 	srli	r19,r16,16
 4014e68:	a809883a 	mov	r4,r21
 4014e6c:	e00b883a 	mov	r5,fp
 4014e70:	b02cd43a 	srli	r22,r22,16
 4014e74:	90a5c83a 	sub	r18,r18,r2
 4014e78:	40075a40 	call	40075a4 <__mulsi3>
 4014e7c:	9809883a 	mov	r4,r19
 4014e80:	e00b883a 	mov	r5,fp
 4014e84:	102f883a 	mov	r23,r2
 4014e88:	40075a40 	call	40075a4 <__mulsi3>
 4014e8c:	9809883a 	mov	r4,r19
 4014e90:	b00b883a 	mov	r5,r22
 4014e94:	1027883a 	mov	r19,r2
 4014e98:	40075a40 	call	40075a4 <__mulsi3>
 4014e9c:	a809883a 	mov	r4,r21
 4014ea0:	b00b883a 	mov	r5,r22
 4014ea4:	102b883a 	mov	r21,r2
 4014ea8:	40075a40 	call	40075a4 <__mulsi3>
 4014eac:	b806d43a 	srli	r3,r23,16
 4014eb0:	14c5883a 	add	r2,r2,r19
 4014eb4:	1887883a 	add	r3,r3,r2
 4014eb8:	1cc0022e 	bgeu	r3,r19,4014ec4 <__udivdi3+0x54c>
 4014ebc:	00800074 	movhi	r2,1
 4014ec0:	a8ab883a 	add	r21,r21,r2
 4014ec4:	1804d43a 	srli	r2,r3,16
 4014ec8:	156b883a 	add	r21,r2,r21
 4014ecc:	95400936 	bltu	r18,r21,4014ef4 <__udivdi3+0x57c>
 4014ed0:	95400326 	beq	r18,r21,4014ee0 <__udivdi3+0x568>
 4014ed4:	8005883a 	mov	r2,r16
 4014ed8:	0007883a 	mov	r3,zero
 4014edc:	003efd06 	br	4014ad4 <__udivdi3+0x15c>
 4014ee0:	1806943a 	slli	r3,r3,16
 4014ee4:	a44c983a 	sll	r6,r20,r17
 4014ee8:	bdffffcc 	andi	r23,r23,65535
 4014eec:	1dc7883a 	add	r3,r3,r23
 4014ef0:	30fff82e 	bgeu	r6,r3,4014ed4 <__udivdi3+0x55c>
 4014ef4:	80bfffc4 	addi	r2,r16,-1
 4014ef8:	0007883a 	mov	r3,zero
 4014efc:	003ef506 	br	4014ad4 <__udivdi3+0x15c>
 4014f00:	3806d43a 	srli	r3,r7,16
 4014f04:	01000404 	movi	r4,16
 4014f08:	003f0406 	br	4014b1c <__udivdi3+0x1a4>
 4014f0c:	3007883a 	mov	r3,r6
 4014f10:	003eb206 	br	40149dc <__udivdi3+0x64>
 4014f14:	0007883a 	mov	r3,zero
 4014f18:	00800044 	movi	r2,1
 4014f1c:	003eed06 	br	4014ad4 <__udivdi3+0x15c>
 4014f20:	3807883a 	mov	r3,r7
 4014f24:	0009883a 	mov	r4,zero
 4014f28:	003efc06 	br	4014b1c <__udivdi3+0x1a4>
 4014f2c:	8006d43a 	srli	r3,r16,16
 4014f30:	04400404 	movi	r17,16
 4014f34:	003f0f06 	br	4014b74 <__udivdi3+0x1fc>
 4014f38:	3006d43a 	srli	r3,r6,16
 4014f3c:	04400404 	movi	r17,16
 4014f40:	003ea606 	br	40149dc <__udivdi3+0x64>
 4014f44:	8007883a 	mov	r3,r16
 4014f48:	003f0a06 	br	4014b74 <__udivdi3+0x1fc>
 4014f4c:	182f883a 	mov	r23,r3
 4014f50:	003fc006 	br	4014e54 <__udivdi3+0x4dc>
 4014f54:	1839883a 	mov	fp,r3
 4014f58:	003f8306 	br	4014d68 <__udivdi3+0x3f0>
 4014f5c:	2821883a 	mov	r16,r5
 4014f60:	003fa506 	br	4014df8 <__udivdi3+0x480>
 4014f64:	182f883a 	mov	r23,r3
 4014f68:	003f6906 	br	4014d10 <__udivdi3+0x398>
 4014f6c:	94bfff84 	addi	r18,r18,-2
 4014f70:	003f3806 	br	4014c54 <__udivdi3+0x2dc>
 4014f74:	94bfff84 	addi	r18,r18,-2
 4014f78:	003ecf06 	br	4014ab8 <__udivdi3+0x140>
 4014f7c:	ad7fff84 	addi	r21,r21,-2
 4014f80:	2409883a 	add	r4,r4,r16
 4014f84:	003eb706 	br	4014a64 <__udivdi3+0xec>
 4014f88:	ad7fff84 	addi	r21,r21,-2
 4014f8c:	2409883a 	add	r4,r4,r16
 4014f90:	003f1906 	br	4014bf8 <__udivdi3+0x280>

04014f94 <__umoddi3>:
 4014f94:	defff304 	addi	sp,sp,-52
 4014f98:	dc400415 	stw	r17,16(sp)
 4014f9c:	dc000315 	stw	r16,12(sp)
 4014fa0:	dfc00c15 	stw	ra,48(sp)
 4014fa4:	df000b15 	stw	fp,44(sp)
 4014fa8:	ddc00a15 	stw	r23,40(sp)
 4014fac:	dd800915 	stw	r22,36(sp)
 4014fb0:	dd400815 	stw	r21,32(sp)
 4014fb4:	dd000715 	stw	r20,28(sp)
 4014fb8:	dcc00615 	stw	r19,24(sp)
 4014fbc:	dc800515 	stw	r18,20(sp)
 4014fc0:	2823883a 	mov	r17,r5
 4014fc4:	2021883a 	mov	r16,r4
 4014fc8:	38003b1e 	bne	r7,zero,40150b8 <__umoddi3+0x124>
 4014fcc:	3825883a 	mov	r18,r7
 4014fd0:	3029883a 	mov	r20,r6
 4014fd4:	2027883a 	mov	r19,r4
 4014fd8:	29805b2e 	bgeu	r5,r6,4015148 <__umoddi3+0x1b4>
 4014fdc:	00bfffd4 	movui	r2,65535
 4014fe0:	282d883a 	mov	r22,r5
 4014fe4:	11809a2e 	bgeu	r2,r6,4015250 <__umoddi3+0x2bc>
 4014fe8:	00804034 	movhi	r2,256
 4014fec:	30814436 	bltu	r6,r2,4015500 <__umoddi3+0x56c>
 4014ff0:	3006d63a 	srli	r3,r6,24
 4014ff4:	04800604 	movi	r18,24
 4014ff8:	008100b4 	movhi	r2,1026
 4014ffc:	1885883a 	add	r2,r3,r2
 4015000:	112c7c03 	ldbu	r4,-19984(r2)
 4015004:	00800804 	movi	r2,32
 4015008:	2489883a 	add	r4,r4,r18
 401500c:	1125c83a 	sub	r18,r2,r4
 4015010:	11000526 	beq	r2,r4,4015028 <__umoddi3+0x94>
 4015014:	8ca2983a 	sll	r17,r17,r18
 4015018:	8108d83a 	srl	r4,r16,r4
 401501c:	34a8983a 	sll	r20,r6,r18
 4015020:	84a6983a 	sll	r19,r16,r18
 4015024:	246cb03a 	or	r22,r4,r17
 4015028:	a02ed43a 	srli	r23,r20,16
 401502c:	b009883a 	mov	r4,r22
 4015030:	a57fffcc 	andi	r21,r20,65535
 4015034:	b80b883a 	mov	r5,r23
 4015038:	40075480 	call	4007548 <__umodsi3>
 401503c:	b80b883a 	mov	r5,r23
 4015040:	b009883a 	mov	r4,r22
 4015044:	1023883a 	mov	r17,r2
 4015048:	40074e40 	call	40074e4 <__udivsi3>
 401504c:	a809883a 	mov	r4,r21
 4015050:	100b883a 	mov	r5,r2
 4015054:	40075a40 	call	40075a4 <__mulsi3>
 4015058:	8822943a 	slli	r17,r17,16
 401505c:	9808d43a 	srli	r4,r19,16
 4015060:	8908b03a 	or	r4,r17,r4
 4015064:	2080042e 	bgeu	r4,r2,4015078 <__umoddi3+0xe4>
 4015068:	2509883a 	add	r4,r4,r20
 401506c:	25000236 	bltu	r4,r20,4015078 <__umoddi3+0xe4>
 4015070:	2080012e 	bgeu	r4,r2,4015078 <__umoddi3+0xe4>
 4015074:	2509883a 	add	r4,r4,r20
 4015078:	20a1c83a 	sub	r16,r4,r2
 401507c:	b80b883a 	mov	r5,r23
 4015080:	8009883a 	mov	r4,r16
 4015084:	40075480 	call	4007548 <__umodsi3>
 4015088:	b80b883a 	mov	r5,r23
 401508c:	8009883a 	mov	r4,r16
 4015090:	1023883a 	mov	r17,r2
 4015094:	40074e40 	call	40074e4 <__udivsi3>
 4015098:	8822943a 	slli	r17,r17,16
 401509c:	100b883a 	mov	r5,r2
 40150a0:	a809883a 	mov	r4,r21
 40150a4:	40075a40 	call	40075a4 <__mulsi3>
 40150a8:	98ffffcc 	andi	r3,r19,65535
 40150ac:	88c6b03a 	or	r3,r17,r3
 40150b0:	18805e2e 	bgeu	r3,r2,401522c <__umoddi3+0x298>
 40150b4:	00005906 	br	401521c <__umoddi3+0x288>
 40150b8:	2005883a 	mov	r2,r4
 40150bc:	29c00d2e 	bgeu	r5,r7,40150f4 <__umoddi3+0x160>
 40150c0:	2807883a 	mov	r3,r5
 40150c4:	dfc00c17 	ldw	ra,48(sp)
 40150c8:	df000b17 	ldw	fp,44(sp)
 40150cc:	ddc00a17 	ldw	r23,40(sp)
 40150d0:	dd800917 	ldw	r22,36(sp)
 40150d4:	dd400817 	ldw	r21,32(sp)
 40150d8:	dd000717 	ldw	r20,28(sp)
 40150dc:	dcc00617 	ldw	r19,24(sp)
 40150e0:	dc800517 	ldw	r18,20(sp)
 40150e4:	dc400417 	ldw	r17,16(sp)
 40150e8:	dc000317 	ldw	r16,12(sp)
 40150ec:	dec00d04 	addi	sp,sp,52
 40150f0:	f800283a 	ret
 40150f4:	013fffd4 	movui	r4,65535
 40150f8:	2807883a 	mov	r3,r5
 40150fc:	21c0592e 	bgeu	r4,r7,4015264 <__umoddi3+0x2d0>
 4015100:	01004034 	movhi	r4,256
 4015104:	39010336 	bltu	r7,r4,4015514 <__umoddi3+0x580>
 4015108:	3808d63a 	srli	r4,r7,24
 401510c:	02000604 	movi	r8,24
 4015110:	014100b4 	movhi	r5,1026
 4015114:	214b883a 	add	r5,r4,r5
 4015118:	2d2c7c03 	ldbu	r20,-19984(r5)
 401511c:	01000804 	movi	r4,32
 4015120:	a229883a 	add	r20,r20,r8
 4015124:	252bc83a 	sub	r21,r4,r20
 4015128:	2500531e 	bne	r4,r20,4015278 <__umoddi3+0x2e4>
 401512c:	3c400136 	bltu	r7,r17,4015134 <__umoddi3+0x1a0>
 4015130:	81bfe436 	bltu	r16,r6,40150c4 <__umoddi3+0x130>
 4015134:	8185c83a 	sub	r2,r16,r6
 4015138:	89cfc83a 	sub	r7,r17,r7
 401513c:	8087803a 	cmpltu	r3,r16,r2
 4015140:	38c7c83a 	sub	r3,r7,r3
 4015144:	003fdf06 	br	40150c4 <__umoddi3+0x130>
 4015148:	3000041e 	bne	r6,zero,401515c <__umoddi3+0x1c8>
 401514c:	000b883a 	mov	r5,zero
 4015150:	01000044 	movi	r4,1
 4015154:	40074e40 	call	40074e4 <__udivsi3>
 4015158:	1029883a 	mov	r20,r2
 401515c:	00bfffd4 	movui	r2,65535
 4015160:	1500362e 	bgeu	r2,r20,401523c <__umoddi3+0x2a8>
 4015164:	00804034 	movhi	r2,256
 4015168:	a080ed36 	bltu	r20,r2,4015520 <__umoddi3+0x58c>
 401516c:	a006d63a 	srli	r3,r20,24
 4015170:	04800604 	movi	r18,24
 4015174:	008100b4 	movhi	r2,1026
 4015178:	1885883a 	add	r2,r3,r2
 401517c:	15ac7c03 	ldbu	r22,-19984(r2)
 4015180:	00800804 	movi	r2,32
 4015184:	b4ad883a 	add	r22,r22,r18
 4015188:	15a5c83a 	sub	r18,r2,r22
 401518c:	1580a51e 	bne	r2,r22,4015424 <__umoddi3+0x490>
 4015190:	a02ed43a 	srli	r23,r20,16
 4015194:	8d23c83a 	sub	r17,r17,r20
 4015198:	a57fffcc 	andi	r21,r20,65535
 401519c:	8809883a 	mov	r4,r17
 40151a0:	b80b883a 	mov	r5,r23
 40151a4:	40075480 	call	4007548 <__umodsi3>
 40151a8:	8809883a 	mov	r4,r17
 40151ac:	b80b883a 	mov	r5,r23
 40151b0:	1023883a 	mov	r17,r2
 40151b4:	40074e40 	call	40074e4 <__udivsi3>
 40151b8:	1009883a 	mov	r4,r2
 40151bc:	a80b883a 	mov	r5,r21
 40151c0:	40075a40 	call	40075a4 <__mulsi3>
 40151c4:	8822943a 	slli	r17,r17,16
 40151c8:	9808d43a 	srli	r4,r19,16
 40151cc:	8908b03a 	or	r4,r17,r4
 40151d0:	2080032e 	bgeu	r4,r2,40151e0 <__umoddi3+0x24c>
 40151d4:	2509883a 	add	r4,r4,r20
 40151d8:	25000136 	bltu	r4,r20,40151e0 <__umoddi3+0x24c>
 40151dc:	2080dc36 	bltu	r4,r2,4015550 <__umoddi3+0x5bc>
 40151e0:	20a1c83a 	sub	r16,r4,r2
 40151e4:	b80b883a 	mov	r5,r23
 40151e8:	8009883a 	mov	r4,r16
 40151ec:	40075480 	call	4007548 <__umodsi3>
 40151f0:	b80b883a 	mov	r5,r23
 40151f4:	8009883a 	mov	r4,r16
 40151f8:	1023883a 	mov	r17,r2
 40151fc:	8822943a 	slli	r17,r17,16
 4015200:	40074e40 	call	40074e4 <__udivsi3>
 4015204:	a80b883a 	mov	r5,r21
 4015208:	1009883a 	mov	r4,r2
 401520c:	40075a40 	call	40075a4 <__mulsi3>
 4015210:	9cffffcc 	andi	r19,r19,65535
 4015214:	8cc6b03a 	or	r3,r17,r19
 4015218:	1880042e 	bgeu	r3,r2,401522c <__umoddi3+0x298>
 401521c:	1d07883a 	add	r3,r3,r20
 4015220:	1d000236 	bltu	r3,r20,401522c <__umoddi3+0x298>
 4015224:	1880012e 	bgeu	r3,r2,401522c <__umoddi3+0x298>
 4015228:	1d07883a 	add	r3,r3,r20
 401522c:	1885c83a 	sub	r2,r3,r2
 4015230:	1484d83a 	srl	r2,r2,r18
 4015234:	0007883a 	mov	r3,zero
 4015238:	003fa206 	br	40150c4 <__umoddi3+0x130>
 401523c:	a0804030 	cmpltui	r2,r20,256
 4015240:	1000ba1e 	bne	r2,zero,401552c <__umoddi3+0x598>
 4015244:	a006d23a 	srli	r3,r20,8
 4015248:	04800204 	movi	r18,8
 401524c:	003fc906 	br	4015174 <__umoddi3+0x1e0>
 4015250:	30804030 	cmpltui	r2,r6,256
 4015254:	1000ad1e 	bne	r2,zero,401550c <__umoddi3+0x578>
 4015258:	3006d23a 	srli	r3,r6,8
 401525c:	04800204 	movi	r18,8
 4015260:	003f6506 	br	4014ff8 <__umoddi3+0x64>
 4015264:	39004030 	cmpltui	r4,r7,256
 4015268:	2000b21e 	bne	r4,zero,4015534 <__umoddi3+0x5a0>
 401526c:	3808d23a 	srli	r4,r7,8
 4015270:	02000204 	movi	r8,8
 4015274:	003fa606 	br	4015110 <__umoddi3+0x17c>
 4015278:	3d4e983a 	sll	r7,r7,r21
 401527c:	3508d83a 	srl	r4,r6,r20
 4015280:	8d2cd83a 	srl	r22,r17,r20
 4015284:	8504d83a 	srl	r2,r16,r20
 4015288:	21e4b03a 	or	r18,r4,r7
 401528c:	8d62983a 	sll	r17,r17,r21
 4015290:	9026d43a 	srli	r19,r18,16
 4015294:	354c983a 	sll	r6,r6,r21
 4015298:	1444b03a 	or	r2,r2,r17
 401529c:	b009883a 	mov	r4,r22
 40152a0:	980b883a 	mov	r5,r19
 40152a4:	d9800115 	stw	r6,4(sp)
 40152a8:	d8800015 	stw	r2,0(sp)
 40152ac:	40075480 	call	4007548 <__umodsi3>
 40152b0:	980b883a 	mov	r5,r19
 40152b4:	b009883a 	mov	r4,r22
 40152b8:	102f883a 	mov	r23,r2
 40152bc:	947fffcc 	andi	r17,r18,65535
 40152c0:	40074e40 	call	40074e4 <__udivsi3>
 40152c4:	8809883a 	mov	r4,r17
 40152c8:	100b883a 	mov	r5,r2
 40152cc:	1039883a 	mov	fp,r2
 40152d0:	40075a40 	call	40075a4 <__mulsi3>
 40152d4:	d8c00017 	ldw	r3,0(sp)
 40152d8:	b82e943a 	slli	r23,r23,16
 40152dc:	8560983a 	sll	r16,r16,r21
 40152e0:	1808d43a 	srli	r4,r3,16
 40152e4:	b908b03a 	or	r4,r23,r4
 40152e8:	2080062e 	bgeu	r4,r2,4015304 <__umoddi3+0x370>
 40152ec:	2489883a 	add	r4,r4,r18
 40152f0:	e17fffc4 	addi	r5,fp,-1
 40152f4:	24809436 	bltu	r4,r18,4015548 <__umoddi3+0x5b4>
 40152f8:	2080932e 	bgeu	r4,r2,4015548 <__umoddi3+0x5b4>
 40152fc:	e73fff84 	addi	fp,fp,-2
 4015300:	2489883a 	add	r4,r4,r18
 4015304:	20adc83a 	sub	r22,r4,r2
 4015308:	980b883a 	mov	r5,r19
 401530c:	b009883a 	mov	r4,r22
 4015310:	40075480 	call	4007548 <__umodsi3>
 4015314:	980b883a 	mov	r5,r19
 4015318:	b009883a 	mov	r4,r22
 401531c:	102f883a 	mov	r23,r2
 4015320:	40074e40 	call	40074e4 <__udivsi3>
 4015324:	100b883a 	mov	r5,r2
 4015328:	8809883a 	mov	r4,r17
 401532c:	d8800215 	stw	r2,8(sp)
 4015330:	40075a40 	call	40075a4 <__mulsi3>
 4015334:	d8c00017 	ldw	r3,0(sp)
 4015338:	b82e943a 	slli	r23,r23,16
 401533c:	d9400217 	ldw	r5,8(sp)
 4015340:	1c7fffcc 	andi	r17,r3,65535
 4015344:	bc62b03a 	or	r17,r23,r17
 4015348:	8880062e 	bgeu	r17,r2,4015364 <__umoddi3+0x3d0>
 401534c:	8ca3883a 	add	r17,r17,r18
 4015350:	28ffffc4 	addi	r3,r5,-1
 4015354:	8c807a36 	bltu	r17,r18,4015540 <__umoddi3+0x5ac>
 4015358:	8880792e 	bgeu	r17,r2,4015540 <__umoddi3+0x5ac>
 401535c:	297fff84 	addi	r5,r5,-2
 4015360:	8ca3883a 	add	r17,r17,r18
 4015364:	e02c943a 	slli	r22,fp,16
 4015368:	d9c00117 	ldw	r7,4(sp)
 401536c:	29bfffcc 	andi	r6,r5,65535
 4015370:	b16cb03a 	or	r22,r22,r5
 4015374:	38ffffcc 	andi	r3,r7,65535
 4015378:	b02cd43a 	srli	r22,r22,16
 401537c:	180b883a 	mov	r5,r3
 4015380:	3009883a 	mov	r4,r6
 4015384:	3838d43a 	srli	fp,r7,16
 4015388:	182f883a 	mov	r23,r3
 401538c:	d9800015 	stw	r6,0(sp)
 4015390:	88a3c83a 	sub	r17,r17,r2
 4015394:	40075a40 	call	40075a4 <__mulsi3>
 4015398:	b80b883a 	mov	r5,r23
 401539c:	b009883a 	mov	r4,r22
 40153a0:	102f883a 	mov	r23,r2
 40153a4:	40075a40 	call	40075a4 <__mulsi3>
 40153a8:	e00b883a 	mov	r5,fp
 40153ac:	b009883a 	mov	r4,r22
 40153b0:	102d883a 	mov	r22,r2
 40153b4:	40075a40 	call	40075a4 <__mulsi3>
 40153b8:	d9800017 	ldw	r6,0(sp)
 40153bc:	e00b883a 	mov	r5,fp
 40153c0:	1039883a 	mov	fp,r2
 40153c4:	3009883a 	mov	r4,r6
 40153c8:	40075a40 	call	40075a4 <__mulsi3>
 40153cc:	b808d43a 	srli	r4,r23,16
 40153d0:	1585883a 	add	r2,r2,r22
 40153d4:	2089883a 	add	r4,r4,r2
 40153d8:	2580022e 	bgeu	r4,r22,40153e4 <__umoddi3+0x450>
 40153dc:	00800074 	movhi	r2,1
 40153e0:	e0b9883a 	add	fp,fp,r2
 40153e4:	2006d43a 	srli	r3,r4,16
 40153e8:	2008943a 	slli	r4,r4,16
 40153ec:	bdffffcc 	andi	r23,r23,65535
 40153f0:	1f07883a 	add	r3,r3,fp
 40153f4:	25c9883a 	add	r4,r4,r23
 40153f8:	88c03a36 	bltu	r17,r3,40154e4 <__umoddi3+0x550>
 40153fc:	88c03826 	beq	r17,r3,40154e0 <__umoddi3+0x54c>
 4015400:	8109c83a 	sub	r4,r16,r4
 4015404:	8121803a 	cmpltu	r16,r16,r4
 4015408:	88c7c83a 	sub	r3,r17,r3
 401540c:	1c07c83a 	sub	r3,r3,r16
 4015410:	1d04983a 	sll	r2,r3,r20
 4015414:	2548d83a 	srl	r4,r4,r21
 4015418:	1d46d83a 	srl	r3,r3,r21
 401541c:	1104b03a 	or	r2,r2,r4
 4015420:	003f2806 	br	40150c4 <__umoddi3+0x130>
 4015424:	a4a8983a 	sll	r20,r20,r18
 4015428:	8da6d83a 	srl	r19,r17,r22
 401542c:	8ca2983a 	sll	r17,r17,r18
 4015430:	a02ed43a 	srli	r23,r20,16
 4015434:	9809883a 	mov	r4,r19
 4015438:	85acd83a 	srl	r22,r16,r22
 401543c:	b80b883a 	mov	r5,r23
 4015440:	40075480 	call	4007548 <__umodsi3>
 4015444:	9809883a 	mov	r4,r19
 4015448:	b80b883a 	mov	r5,r23
 401544c:	b46cb03a 	or	r22,r22,r17
 4015450:	a57fffcc 	andi	r21,r20,65535
 4015454:	1023883a 	mov	r17,r2
 4015458:	40074e40 	call	40074e4 <__udivsi3>
 401545c:	a809883a 	mov	r4,r21
 4015460:	100b883a 	mov	r5,r2
 4015464:	40075a40 	call	40075a4 <__mulsi3>
 4015468:	8822943a 	slli	r17,r17,16
 401546c:	b008d43a 	srli	r4,r22,16
 4015470:	84a6983a 	sll	r19,r16,r18
 4015474:	8908b03a 	or	r4,r17,r4
 4015478:	2080042e 	bgeu	r4,r2,401548c <__umoddi3+0x4f8>
 401547c:	2509883a 	add	r4,r4,r20
 4015480:	25000236 	bltu	r4,r20,401548c <__umoddi3+0x4f8>
 4015484:	2080012e 	bgeu	r4,r2,401548c <__umoddi3+0x4f8>
 4015488:	2509883a 	add	r4,r4,r20
 401548c:	20a1c83a 	sub	r16,r4,r2
 4015490:	8009883a 	mov	r4,r16
 4015494:	b80b883a 	mov	r5,r23
 4015498:	40075480 	call	4007548 <__umodsi3>
 401549c:	8009883a 	mov	r4,r16
 40154a0:	1021883a 	mov	r16,r2
 40154a4:	b80b883a 	mov	r5,r23
 40154a8:	8020943a 	slli	r16,r16,16
 40154ac:	40074e40 	call	40074e4 <__udivsi3>
 40154b0:	100b883a 	mov	r5,r2
 40154b4:	a809883a 	mov	r4,r21
 40154b8:	b47fffcc 	andi	r17,r22,65535
 40154bc:	40075a40 	call	40075a4 <__mulsi3>
 40154c0:	8462b03a 	or	r17,r16,r17
 40154c4:	8880042e 	bgeu	r17,r2,40154d8 <__umoddi3+0x544>
 40154c8:	8d23883a 	add	r17,r17,r20
 40154cc:	8d000236 	bltu	r17,r20,40154d8 <__umoddi3+0x544>
 40154d0:	8880012e 	bgeu	r17,r2,40154d8 <__umoddi3+0x544>
 40154d4:	8d23883a 	add	r17,r17,r20
 40154d8:	88a3c83a 	sub	r17,r17,r2
 40154dc:	003f2f06 	br	401519c <__umoddi3+0x208>
 40154e0:	813fc72e 	bgeu	r16,r4,4015400 <__umoddi3+0x46c>
 40154e4:	d8800117 	ldw	r2,4(sp)
 40154e8:	20a7c83a 	sub	r19,r4,r2
 40154ec:	24c9803a 	cmpltu	r4,r4,r19
 40154f0:	2489883a 	add	r4,r4,r18
 40154f4:	1907c83a 	sub	r3,r3,r4
 40154f8:	9809883a 	mov	r4,r19
 40154fc:	003fc006 	br	4015400 <__umoddi3+0x46c>
 4015500:	3006d43a 	srli	r3,r6,16
 4015504:	04800404 	movi	r18,16
 4015508:	003ebb06 	br	4014ff8 <__umoddi3+0x64>
 401550c:	3007883a 	mov	r3,r6
 4015510:	003eb906 	br	4014ff8 <__umoddi3+0x64>
 4015514:	3808d43a 	srli	r4,r7,16
 4015518:	02000404 	movi	r8,16
 401551c:	003efc06 	br	4015110 <__umoddi3+0x17c>
 4015520:	a006d43a 	srli	r3,r20,16
 4015524:	04800404 	movi	r18,16
 4015528:	003f1206 	br	4015174 <__umoddi3+0x1e0>
 401552c:	a007883a 	mov	r3,r20
 4015530:	003f1006 	br	4015174 <__umoddi3+0x1e0>
 4015534:	3809883a 	mov	r4,r7
 4015538:	0011883a 	mov	r8,zero
 401553c:	003ef406 	br	4015110 <__umoddi3+0x17c>
 4015540:	180b883a 	mov	r5,r3
 4015544:	003f8706 	br	4015364 <__umoddi3+0x3d0>
 4015548:	2839883a 	mov	fp,r5
 401554c:	003f6d06 	br	4015304 <__umoddi3+0x370>
 4015550:	2509883a 	add	r4,r4,r20
 4015554:	003f2206 	br	40151e0 <__umoddi3+0x24c>

04015558 <__adddf3>:
 4015558:	02000434 	movhi	r8,16
 401555c:	423fffc4 	addi	r8,r8,-1
 4015560:	3a12703a 	and	r9,r7,r8
 4015564:	2a06703a 	and	r3,r5,r8
 4015568:	2818d53a 	srli	r12,r5,20
 401556c:	3804d53a 	srli	r2,r7,20
 4015570:	481490fa 	slli	r10,r9,3
 4015574:	280ad7fa 	srli	r5,r5,31
 4015578:	180690fa 	slli	r3,r3,3
 401557c:	2016d77a 	srli	r11,r4,29
 4015580:	3012d77a 	srli	r9,r6,29
 4015584:	380ed7fa 	srli	r7,r7,31
 4015588:	defffb04 	addi	sp,sp,-20
 401558c:	dc400115 	stw	r17,4(sp)
 4015590:	dc000015 	stw	r16,0(sp)
 4015594:	dfc00415 	stw	ra,16(sp)
 4015598:	dcc00315 	stw	r19,12(sp)
 401559c:	dc800215 	stw	r18,8(sp)
 40155a0:	201c90fa 	slli	r14,r4,3
 40155a4:	301a90fa 	slli	r13,r6,3
 40155a8:	6441ffcc 	andi	r17,r12,2047
 40155ac:	2821883a 	mov	r16,r5
 40155b0:	58c6b03a 	or	r3,r11,r3
 40155b4:	1081ffcc 	andi	r2,r2,2047
 40155b8:	4a92b03a 	or	r9,r9,r10
 40155bc:	29c06326 	beq	r5,r7,401574c <__adddf3+0x1f4>
 40155c0:	888bc83a 	sub	r5,r17,r2
 40155c4:	0140560e 	bge	zero,r5,4015720 <__adddf3+0x1c8>
 40155c8:	10007526 	beq	r2,zero,40157a0 <__adddf3+0x248>
 40155cc:	8881ffd8 	cmpnei	r2,r17,2047
 40155d0:	10012d26 	beq	r2,zero,4015a88 <__adddf3+0x530>
 40155d4:	4a402034 	orhi	r9,r9,128
 40155d8:	28800e48 	cmpgei	r2,r5,57
 40155dc:	1000f41e 	bne	r2,zero,40159b0 <__adddf3+0x458>
 40155e0:	28800808 	cmpgei	r2,r5,32
 40155e4:	1001471e 	bne	r2,zero,4015b04 <__adddf3+0x5ac>
 40155e8:	00800804 	movi	r2,32
 40155ec:	1145c83a 	sub	r2,r2,r5
 40155f0:	6948d83a 	srl	r4,r13,r5
 40155f4:	48a4983a 	sll	r18,r9,r2
 40155f8:	6884983a 	sll	r2,r13,r2
 40155fc:	494ad83a 	srl	r5,r9,r5
 4015600:	9124b03a 	or	r18,r18,r4
 4015604:	101ac03a 	cmpne	r13,r2,zero
 4015608:	9364b03a 	or	r18,r18,r13
 401560c:	1947c83a 	sub	r3,r3,r5
 4015610:	74a5c83a 	sub	r18,r14,r18
 4015614:	7489803a 	cmpltu	r4,r14,r18
 4015618:	1909c83a 	sub	r4,r3,r4
 401561c:	2080202c 	andhi	r2,r4,128
 4015620:	10008626 	beq	r2,zero,401583c <__adddf3+0x2e4>
 4015624:	00802034 	movhi	r2,128
 4015628:	10bfffc4 	addi	r2,r2,-1
 401562c:	20a6703a 	and	r19,r4,r2
 4015630:	9800d626 	beq	r19,zero,401598c <__adddf3+0x434>
 4015634:	9809883a 	mov	r4,r19
 4015638:	4017d600 	call	4017d60 <__clzsi2>
 401563c:	133ffe04 	addi	r12,r2,-8
 4015640:	01000804 	movi	r4,32
 4015644:	2309c83a 	sub	r4,r4,r12
 4015648:	9108d83a 	srl	r4,r18,r4
 401564c:	9b04983a 	sll	r2,r19,r12
 4015650:	9324983a 	sll	r18,r18,r12
 4015654:	2088b03a 	or	r4,r4,r2
 4015658:	6440c716 	blt	r12,r17,4015978 <__adddf3+0x420>
 401565c:	6459c83a 	sub	r12,r12,r17
 4015660:	62000044 	addi	r8,r12,1
 4015664:	40800808 	cmpgei	r2,r8,32
 4015668:	1001191e 	bne	r2,zero,4015ad0 <__adddf3+0x578>
 401566c:	00800804 	movi	r2,32
 4015670:	1205c83a 	sub	r2,r2,r8
 4015674:	9206d83a 	srl	r3,r18,r8
 4015678:	90a4983a 	sll	r18,r18,r2
 401567c:	2084983a 	sll	r2,r4,r2
 4015680:	2208d83a 	srl	r4,r4,r8
 4015684:	9024c03a 	cmpne	r18,r18,zero
 4015688:	10c4b03a 	or	r2,r2,r3
 401568c:	14a4b03a 	or	r18,r2,r18
 4015690:	0023883a 	mov	r17,zero
 4015694:	908001cc 	andi	r2,r18,7
 4015698:	10000726 	beq	r2,zero,40156b8 <__adddf3+0x160>
 401569c:	908003cc 	andi	r2,r18,15
 40156a0:	10800120 	cmpeqi	r2,r2,4
 40156a4:	1000041e 	bne	r2,zero,40156b8 <__adddf3+0x160>
 40156a8:	90c00104 	addi	r3,r18,4
 40156ac:	1ca5803a 	cmpltu	r18,r3,r18
 40156b0:	2489883a 	add	r4,r4,r18
 40156b4:	1825883a 	mov	r18,r3
 40156b8:	2080202c 	andhi	r2,r4,128
 40156bc:	10006126 	beq	r2,zero,4015844 <__adddf3+0x2ec>
 40156c0:	89400044 	addi	r5,r17,1
 40156c4:	2881ffe0 	cmpeqi	r2,r5,2047
 40156c8:	2941ffcc 	andi	r5,r5,2047
 40156cc:	1000731e 	bne	r2,zero,401589c <__adddf3+0x344>
 40156d0:	023fe034 	movhi	r8,65408
 40156d4:	423fffc4 	addi	r8,r8,-1
 40156d8:	2210703a 	and	r8,r4,r8
 40156dc:	4006927a 	slli	r3,r8,9
 40156e0:	9024d0fa 	srli	r18,r18,3
 40156e4:	4004977a 	slli	r2,r8,29
 40156e8:	1806d33a 	srli	r3,r3,12
 40156ec:	1484b03a 	or	r2,r2,r18
 40156f0:	280a953a 	slli	r5,r5,20
 40156f4:	84003fcc 	andi	r16,r16,255
 40156f8:	802097fa 	slli	r16,r16,31
 40156fc:	28c6b03a 	or	r3,r5,r3
 4015700:	1c06b03a 	or	r3,r3,r16
 4015704:	dfc00417 	ldw	ra,16(sp)
 4015708:	dcc00317 	ldw	r19,12(sp)
 401570c:	dc800217 	ldw	r18,8(sp)
 4015710:	dc400117 	ldw	r17,4(sp)
 4015714:	dc000017 	ldw	r16,0(sp)
 4015718:	dec00504 	addi	sp,sp,20
 401571c:	f800283a 	ret
 4015720:	28002726 	beq	r5,zero,40157c0 <__adddf3+0x268>
 4015724:	144bc83a 	sub	r5,r2,r17
 4015728:	8800be1e 	bne	r17,zero,4015a24 <__adddf3+0x4cc>
 401572c:	1b88b03a 	or	r4,r3,r14
 4015730:	20013126 	beq	r4,zero,4015bf8 <__adddf3+0x6a0>
 4015734:	293fffc4 	addi	r4,r5,-1
 4015738:	20017226 	beq	r4,zero,4015d04 <__adddf3+0x7ac>
 401573c:	2941ffd8 	cmpnei	r5,r5,2047
 4015740:	2801c226 	beq	r5,zero,4015e4c <__adddf3+0x8f4>
 4015744:	200b883a 	mov	r5,r4
 4015748:	0000b906 	br	4015a30 <__adddf3+0x4d8>
 401574c:	888bc83a 	sub	r5,r17,r2
 4015750:	0140700e 	bge	zero,r5,4015914 <__adddf3+0x3bc>
 4015754:	10002a26 	beq	r2,zero,4015800 <__adddf3+0x2a8>
 4015758:	8881ffd8 	cmpnei	r2,r17,2047
 401575c:	1000ca26 	beq	r2,zero,4015a88 <__adddf3+0x530>
 4015760:	4a402034 	orhi	r9,r9,128
 4015764:	28800e48 	cmpgei	r2,r5,57
 4015768:	1000421e 	bne	r2,zero,4015874 <__adddf3+0x31c>
 401576c:	28800808 	cmpgei	r2,r5,32
 4015770:	1000ff26 	beq	r2,zero,4015b70 <__adddf3+0x618>
 4015774:	2cbff804 	addi	r18,r5,-32
 4015778:	29000820 	cmpeqi	r4,r5,32
 401577c:	4c84d83a 	srl	r2,r9,r18
 4015780:	2000041e 	bne	r4,zero,4015794 <__adddf3+0x23c>
 4015784:	01001004 	movi	r4,64
 4015788:	214bc83a 	sub	r5,r4,r5
 401578c:	4952983a 	sll	r9,r9,r5
 4015790:	6a5ab03a 	or	r13,r13,r9
 4015794:	6824c03a 	cmpne	r18,r13,zero
 4015798:	90a4b03a 	or	r18,r18,r2
 401579c:	00003706 	br	401587c <__adddf3+0x324>
 40157a0:	4b44b03a 	or	r2,r9,r13
 40157a4:	1000b126 	beq	r2,zero,4015a6c <__adddf3+0x514>
 40157a8:	28bfffc4 	addi	r2,r5,-1
 40157ac:	10011a26 	beq	r2,zero,4015c18 <__adddf3+0x6c0>
 40157b0:	2941ffd8 	cmpnei	r5,r5,2047
 40157b4:	28012526 	beq	r5,zero,4015c4c <__adddf3+0x6f4>
 40157b8:	100b883a 	mov	r5,r2
 40157bc:	003f8606 	br	40155d8 <__adddf3+0x80>
 40157c0:	8a800044 	addi	r10,r17,1
 40157c4:	5281ff8c 	andi	r10,r10,2046
 40157c8:	50008b1e 	bne	r10,zero,40159f8 <__adddf3+0x4a0>
 40157cc:	1b96b03a 	or	r11,r3,r14
 40157d0:	4b44b03a 	or	r2,r9,r13
 40157d4:	8801031e 	bne	r17,zero,4015be4 <__adddf3+0x68c>
 40157d8:	58014126 	beq	r11,zero,4015ce0 <__adddf3+0x788>
 40157dc:	1001571e 	bne	r2,zero,4015d3c <__adddf3+0x7e4>
 40157e0:	1804977a 	slli	r2,r3,29
 40157e4:	01480034 	movhi	r5,8192
 40157e8:	297fffc4 	addi	r5,r5,-1
 40157ec:	2148703a 	and	r4,r4,r5
 40157f0:	1810d0fa 	srli	r8,r3,3
 40157f4:	1104b03a 	or	r2,r2,r4
 40157f8:	500b883a 	mov	r5,r10
 40157fc:	00001806 	br	4015860 <__adddf3+0x308>
 4015800:	4b44b03a 	or	r2,r9,r13
 4015804:	10010a26 	beq	r2,zero,4015c30 <__adddf3+0x6d8>
 4015808:	28bfffc4 	addi	r2,r5,-1
 401580c:	10000426 	beq	r2,zero,4015820 <__adddf3+0x2c8>
 4015810:	2941ffd8 	cmpnei	r5,r5,2047
 4015814:	28014226 	beq	r5,zero,4015d20 <__adddf3+0x7c8>
 4015818:	100b883a 	mov	r5,r2
 401581c:	003fd106 	br	4015764 <__adddf3+0x20c>
 4015820:	7365883a 	add	r18,r14,r13
 4015824:	1a47883a 	add	r3,r3,r9
 4015828:	9389803a 	cmpltu	r4,r18,r14
 401582c:	1909883a 	add	r4,r3,r4
 4015830:	2080202c 	andhi	r2,r4,128
 4015834:	10009b1e 	bne	r2,zero,4015aa4 <__adddf3+0x54c>
 4015838:	04400044 	movi	r17,1
 401583c:	908001cc 	andi	r2,r18,7
 4015840:	103f961e 	bne	r2,zero,401569c <__adddf3+0x144>
 4015844:	9024d0fa 	srli	r18,r18,3
 4015848:	2004977a 	slli	r2,r4,29
 401584c:	2010d0fa 	srli	r8,r4,3
 4015850:	880b883a 	mov	r5,r17
 4015854:	9084b03a 	or	r2,r18,r2
 4015858:	28c1ffe0 	cmpeqi	r3,r5,2047
 401585c:	1800251e 	bne	r3,zero,40158f4 <__adddf3+0x39c>
 4015860:	00c00434 	movhi	r3,16
 4015864:	18ffffc4 	addi	r3,r3,-1
 4015868:	40c6703a 	and	r3,r8,r3
 401586c:	2941ffcc 	andi	r5,r5,2047
 4015870:	003f9f06 	br	40156f0 <__adddf3+0x198>
 4015874:	4b64b03a 	or	r18,r9,r13
 4015878:	9024c03a 	cmpne	r18,r18,zero
 401587c:	93a5883a 	add	r18,r18,r14
 4015880:	9389803a 	cmpltu	r4,r18,r14
 4015884:	20c9883a 	add	r4,r4,r3
 4015888:	2080202c 	andhi	r2,r4,128
 401588c:	103feb26 	beq	r2,zero,401583c <__adddf3+0x2e4>
 4015890:	8c400044 	addi	r17,r17,1
 4015894:	8881ffe0 	cmpeqi	r2,r17,2047
 4015898:	10008326 	beq	r2,zero,4015aa8 <__adddf3+0x550>
 401589c:	0141ffc4 	movi	r5,2047
 40158a0:	0007883a 	mov	r3,zero
 40158a4:	0005883a 	mov	r2,zero
 40158a8:	003f9106 	br	40156f0 <__adddf3+0x198>
 40158ac:	4b44b03a 	or	r2,r9,r13
 40158b0:	180a977a 	slli	r5,r3,29
 40158b4:	1810d0fa 	srli	r8,r3,3
 40158b8:	10016c26 	beq	r2,zero,4015e6c <__adddf3+0x914>
 40158bc:	00c80034 	movhi	r3,8192
 40158c0:	18ffffc4 	addi	r3,r3,-1
 40158c4:	20c4703a 	and	r2,r4,r3
 40158c8:	4100022c 	andhi	r4,r8,8
 40158cc:	1144b03a 	or	r2,r2,r5
 40158d0:	20000826 	beq	r4,zero,40158f4 <__adddf3+0x39c>
 40158d4:	4808d0fa 	srli	r4,r9,3
 40158d8:	2140022c 	andhi	r5,r4,8
 40158dc:	2800051e 	bne	r5,zero,40158f4 <__adddf3+0x39c>
 40158e0:	4804977a 	slli	r2,r9,29
 40158e4:	30cc703a 	and	r6,r6,r3
 40158e8:	3821883a 	mov	r16,r7
 40158ec:	3084b03a 	or	r2,r6,r2
 40158f0:	2011883a 	mov	r8,r4
 40158f4:	4086b03a 	or	r3,r8,r2
 40158f8:	18017126 	beq	r3,zero,4015ec0 <__adddf3+0x968>
 40158fc:	01000434 	movhi	r4,16
 4015900:	40c00234 	orhi	r3,r8,8
 4015904:	213fffc4 	addi	r4,r4,-1
 4015908:	1906703a 	and	r3,r3,r4
 401590c:	0141ffc4 	movi	r5,2047
 4015910:	003f7706 	br	40156f0 <__adddf3+0x198>
 4015914:	28002926 	beq	r5,zero,40159bc <__adddf3+0x464>
 4015918:	144bc83a 	sub	r5,r2,r17
 401591c:	88008c26 	beq	r17,zero,4015b50 <__adddf3+0x5f8>
 4015920:	1101ffd8 	cmpnei	r4,r2,2047
 4015924:	20011126 	beq	r4,zero,4015d6c <__adddf3+0x814>
 4015928:	18c02034 	orhi	r3,r3,128
 401592c:	29000e48 	cmpgei	r4,r5,57
 4015930:	2000d51e 	bne	r4,zero,4015c88 <__adddf3+0x730>
 4015934:	29000808 	cmpgei	r4,r5,32
 4015938:	2001511e 	bne	r4,zero,4015e80 <__adddf3+0x928>
 401593c:	01000804 	movi	r4,32
 4015940:	2149c83a 	sub	r4,r4,r5
 4015944:	1924983a 	sll	r18,r3,r4
 4015948:	714cd83a 	srl	r6,r14,r5
 401594c:	7108983a 	sll	r4,r14,r4
 4015950:	194ad83a 	srl	r5,r3,r5
 4015954:	91a4b03a 	or	r18,r18,r6
 4015958:	2006c03a 	cmpne	r3,r4,zero
 401595c:	90e4b03a 	or	r18,r18,r3
 4015960:	4953883a 	add	r9,r9,r5
 4015964:	9365883a 	add	r18,r18,r13
 4015968:	9349803a 	cmpltu	r4,r18,r13
 401596c:	2249883a 	add	r4,r4,r9
 4015970:	1023883a 	mov	r17,r2
 4015974:	003fc406 	br	4015888 <__adddf3+0x330>
 4015978:	023fe034 	movhi	r8,65408
 401597c:	423fffc4 	addi	r8,r8,-1
 4015980:	8b23c83a 	sub	r17,r17,r12
 4015984:	2208703a 	and	r4,r4,r8
 4015988:	003f4206 	br	4015694 <__adddf3+0x13c>
 401598c:	9009883a 	mov	r4,r18
 4015990:	4017d600 	call	4017d60 <__clzsi2>
 4015994:	13000604 	addi	r12,r2,24
 4015998:	60c00808 	cmpgei	r3,r12,32
 401599c:	183f2826 	beq	r3,zero,4015640 <__adddf3+0xe8>
 40159a0:	113ffe04 	addi	r4,r2,-8
 40159a4:	9108983a 	sll	r4,r18,r4
 40159a8:	0025883a 	mov	r18,zero
 40159ac:	003f2a06 	br	4015658 <__adddf3+0x100>
 40159b0:	4b64b03a 	or	r18,r9,r13
 40159b4:	9024c03a 	cmpne	r18,r18,zero
 40159b8:	003f1506 	br	4015610 <__adddf3+0xb8>
 40159bc:	8a000044 	addi	r8,r17,1
 40159c0:	4081ff8c 	andi	r2,r8,2046
 40159c4:	1000751e 	bne	r2,zero,4015b9c <__adddf3+0x644>
 40159c8:	1b84b03a 	or	r2,r3,r14
 40159cc:	8800bc1e 	bne	r17,zero,4015cc0 <__adddf3+0x768>
 40159d0:	10010c26 	beq	r2,zero,4015e04 <__adddf3+0x8ac>
 40159d4:	4b44b03a 	or	r2,r9,r13
 40159d8:	1001111e 	bne	r2,zero,4015e20 <__adddf3+0x8c8>
 40159dc:	180c977a 	slli	r6,r3,29
 40159e0:	00880034 	movhi	r2,8192
 40159e4:	10bfffc4 	addi	r2,r2,-1
 40159e8:	2084703a 	and	r2,r4,r2
 40159ec:	1810d0fa 	srli	r8,r3,3
 40159f0:	1184b03a 	or	r2,r2,r6
 40159f4:	003f9a06 	br	4015860 <__adddf3+0x308>
 40159f8:	7365c83a 	sub	r18,r14,r13
 40159fc:	1a67c83a 	sub	r19,r3,r9
 4015a00:	7489803a 	cmpltu	r4,r14,r18
 4015a04:	9927c83a 	sub	r19,r19,r4
 4015a08:	9880202c 	andhi	r2,r19,128
 4015a0c:	10006f1e 	bne	r2,zero,4015bcc <__adddf3+0x674>
 4015a10:	94c4b03a 	or	r2,r18,r19
 4015a14:	103f061e 	bne	r2,zero,4015630 <__adddf3+0xd8>
 4015a18:	0011883a 	mov	r8,zero
 4015a1c:	0021883a 	mov	r16,zero
 4015a20:	003f8f06 	br	4015860 <__adddf3+0x308>
 4015a24:	1101ffd8 	cmpnei	r4,r2,2047
 4015a28:	20008f26 	beq	r4,zero,4015c68 <__adddf3+0x710>
 4015a2c:	18c02034 	orhi	r3,r3,128
 4015a30:	29000e48 	cmpgei	r4,r5,57
 4015a34:	20003e1e 	bne	r4,zero,4015b30 <__adddf3+0x5d8>
 4015a38:	29000808 	cmpgei	r4,r5,32
 4015a3c:	2000951e 	bne	r4,zero,4015c94 <__adddf3+0x73c>
 4015a40:	01000804 	movi	r4,32
 4015a44:	2149c83a 	sub	r4,r4,r5
 4015a48:	1924983a 	sll	r18,r3,r4
 4015a4c:	714cd83a 	srl	r6,r14,r5
 4015a50:	711c983a 	sll	r14,r14,r4
 4015a54:	1946d83a 	srl	r3,r3,r5
 4015a58:	91a4b03a 	or	r18,r18,r6
 4015a5c:	701cc03a 	cmpne	r14,r14,zero
 4015a60:	93a4b03a 	or	r18,r18,r14
 4015a64:	48d3c83a 	sub	r9,r9,r3
 4015a68:	00003306 	br	4015b38 <__adddf3+0x5e0>
 4015a6c:	1824977a 	slli	r18,r3,29
 4015a70:	01880034 	movhi	r6,8192
 4015a74:	31bfffc4 	addi	r6,r6,-1
 4015a78:	2184703a 	and	r2,r4,r6
 4015a7c:	1810d0fa 	srli	r8,r3,3
 4015a80:	1484b03a 	or	r2,r2,r18
 4015a84:	003f7406 	br	4015858 <__adddf3+0x300>
 4015a88:	1804977a 	slli	r2,r3,29
 4015a8c:	01480034 	movhi	r5,8192
 4015a90:	297fffc4 	addi	r5,r5,-1
 4015a94:	2148703a 	and	r4,r4,r5
 4015a98:	1810d0fa 	srli	r8,r3,3
 4015a9c:	1104b03a 	or	r2,r2,r4
 4015aa0:	003f9406 	br	40158f4 <__adddf3+0x39c>
 4015aa4:	04400084 	movi	r17,2
 4015aa8:	00bfe034 	movhi	r2,65408
 4015aac:	10bfffc4 	addi	r2,r2,-1
 4015ab0:	9006d07a 	srli	r3,r18,1
 4015ab4:	2088703a 	and	r4,r4,r2
 4015ab8:	200497fa 	slli	r2,r4,31
 4015abc:	9480004c 	andi	r18,r18,1
 4015ac0:	1ca4b03a 	or	r18,r3,r18
 4015ac4:	2008d07a 	srli	r4,r4,1
 4015ac8:	14a4b03a 	or	r18,r2,r18
 4015acc:	003ef106 	br	4015694 <__adddf3+0x13c>
 4015ad0:	633ff844 	addi	r12,r12,-31
 4015ad4:	40800820 	cmpeqi	r2,r8,32
 4015ad8:	2318d83a 	srl	r12,r4,r12
 4015adc:	1000041e 	bne	r2,zero,4015af0 <__adddf3+0x598>
 4015ae0:	00801004 	movi	r2,64
 4015ae4:	1211c83a 	sub	r8,r2,r8
 4015ae8:	2208983a 	sll	r4,r4,r8
 4015aec:	9124b03a 	or	r18,r18,r4
 4015af0:	9024c03a 	cmpne	r18,r18,zero
 4015af4:	9324b03a 	or	r18,r18,r12
 4015af8:	0009883a 	mov	r4,zero
 4015afc:	0023883a 	mov	r17,zero
 4015b00:	003f4e06 	br	401583c <__adddf3+0x2e4>
 4015b04:	2cbff804 	addi	r18,r5,-32
 4015b08:	29000820 	cmpeqi	r4,r5,32
 4015b0c:	4c84d83a 	srl	r2,r9,r18
 4015b10:	2000041e 	bne	r4,zero,4015b24 <__adddf3+0x5cc>
 4015b14:	01001004 	movi	r4,64
 4015b18:	214bc83a 	sub	r5,r4,r5
 4015b1c:	4952983a 	sll	r9,r9,r5
 4015b20:	6a5ab03a 	or	r13,r13,r9
 4015b24:	6824c03a 	cmpne	r18,r13,zero
 4015b28:	90a4b03a 	or	r18,r18,r2
 4015b2c:	003eb806 	br	4015610 <__adddf3+0xb8>
 4015b30:	1b88b03a 	or	r4,r3,r14
 4015b34:	2024c03a 	cmpne	r18,r4,zero
 4015b38:	6ca5c83a 	sub	r18,r13,r18
 4015b3c:	6c89803a 	cmpltu	r4,r13,r18
 4015b40:	4909c83a 	sub	r4,r9,r4
 4015b44:	3821883a 	mov	r16,r7
 4015b48:	1023883a 	mov	r17,r2
 4015b4c:	003eb306 	br	401561c <__adddf3+0xc4>
 4015b50:	1b88b03a 	or	r4,r3,r14
 4015b54:	20008c26 	beq	r4,zero,4015d88 <__adddf3+0x830>
 4015b58:	293fffc4 	addi	r4,r5,-1
 4015b5c:	2000d326 	beq	r4,zero,4015eac <__adddf3+0x954>
 4015b60:	2941ffd8 	cmpnei	r5,r5,2047
 4015b64:	28008126 	beq	r5,zero,4015d6c <__adddf3+0x814>
 4015b68:	200b883a 	mov	r5,r4
 4015b6c:	003f6f06 	br	401592c <__adddf3+0x3d4>
 4015b70:	00800804 	movi	r2,32
 4015b74:	1145c83a 	sub	r2,r2,r5
 4015b78:	6948d83a 	srl	r4,r13,r5
 4015b7c:	48a4983a 	sll	r18,r9,r2
 4015b80:	6884983a 	sll	r2,r13,r2
 4015b84:	494ad83a 	srl	r5,r9,r5
 4015b88:	9124b03a 	or	r18,r18,r4
 4015b8c:	101ac03a 	cmpne	r13,r2,zero
 4015b90:	9364b03a 	or	r18,r18,r13
 4015b94:	1947883a 	add	r3,r3,r5
 4015b98:	003f3806 	br	401587c <__adddf3+0x324>
 4015b9c:	4081ffe0 	cmpeqi	r2,r8,2047
 4015ba0:	103f3e1e 	bne	r2,zero,401589c <__adddf3+0x344>
 4015ba4:	7345883a 	add	r2,r14,r13
 4015ba8:	139d803a 	cmpltu	r14,r2,r14
 4015bac:	1a49883a 	add	r4,r3,r9
 4015bb0:	2389883a 	add	r4,r4,r14
 4015bb4:	202497fa 	slli	r18,r4,31
 4015bb8:	1004d07a 	srli	r2,r2,1
 4015bbc:	2008d07a 	srli	r4,r4,1
 4015bc0:	4023883a 	mov	r17,r8
 4015bc4:	90a4b03a 	or	r18,r18,r2
 4015bc8:	003f1c06 	br	401583c <__adddf3+0x2e4>
 4015bcc:	6ba5c83a 	sub	r18,r13,r14
 4015bd0:	48c9c83a 	sub	r4,r9,r3
 4015bd4:	6c85803a 	cmpltu	r2,r13,r18
 4015bd8:	20a7c83a 	sub	r19,r4,r2
 4015bdc:	3821883a 	mov	r16,r7
 4015be0:	003e9306 	br	4015630 <__adddf3+0xd8>
 4015be4:	58006f1e 	bne	r11,zero,4015da4 <__adddf3+0x84c>
 4015be8:	10001f1e 	bne	r2,zero,4015c68 <__adddf3+0x710>
 4015bec:	00bfffc4 	movi	r2,-1
 4015bf0:	0021883a 	mov	r16,zero
 4015bf4:	003f4106 	br	40158fc <__adddf3+0x3a4>
 4015bf8:	4808977a 	slli	r4,r9,29
 4015bfc:	00c80034 	movhi	r3,8192
 4015c00:	18ffffc4 	addi	r3,r3,-1
 4015c04:	30c4703a 	and	r2,r6,r3
 4015c08:	4810d0fa 	srli	r8,r9,3
 4015c0c:	1104b03a 	or	r2,r2,r4
 4015c10:	3821883a 	mov	r16,r7
 4015c14:	003f1006 	br	4015858 <__adddf3+0x300>
 4015c18:	7365c83a 	sub	r18,r14,r13
 4015c1c:	1a47c83a 	sub	r3,r3,r9
 4015c20:	7489803a 	cmpltu	r4,r14,r18
 4015c24:	1909c83a 	sub	r4,r3,r4
 4015c28:	04400044 	movi	r17,1
 4015c2c:	003e7b06 	br	401561c <__adddf3+0xc4>
 4015c30:	1824977a 	slli	r18,r3,29
 4015c34:	01c80034 	movhi	r7,8192
 4015c38:	39ffffc4 	addi	r7,r7,-1
 4015c3c:	21c4703a 	and	r2,r4,r7
 4015c40:	1810d0fa 	srli	r8,r3,3
 4015c44:	1484b03a 	or	r2,r2,r18
 4015c48:	003f0306 	br	4015858 <__adddf3+0x300>
 4015c4c:	1824977a 	slli	r18,r3,29
 4015c50:	01480034 	movhi	r5,8192
 4015c54:	297fffc4 	addi	r5,r5,-1
 4015c58:	2144703a 	and	r2,r4,r5
 4015c5c:	1810d0fa 	srli	r8,r3,3
 4015c60:	1484b03a 	or	r2,r2,r18
 4015c64:	003f2306 	br	40158f4 <__adddf3+0x39c>
 4015c68:	4806977a 	slli	r3,r9,29
 4015c6c:	00880034 	movhi	r2,8192
 4015c70:	10bfffc4 	addi	r2,r2,-1
 4015c74:	3084703a 	and	r2,r6,r2
 4015c78:	4810d0fa 	srli	r8,r9,3
 4015c7c:	10c4b03a 	or	r2,r2,r3
 4015c80:	3821883a 	mov	r16,r7
 4015c84:	003f1b06 	br	40158f4 <__adddf3+0x39c>
 4015c88:	1b88b03a 	or	r4,r3,r14
 4015c8c:	2024c03a 	cmpne	r18,r4,zero
 4015c90:	003f3406 	br	4015964 <__adddf3+0x40c>
 4015c94:	2cbff804 	addi	r18,r5,-32
 4015c98:	29800820 	cmpeqi	r6,r5,32
 4015c9c:	1c88d83a 	srl	r4,r3,r18
 4015ca0:	3000041e 	bne	r6,zero,4015cb4 <__adddf3+0x75c>
 4015ca4:	01801004 	movi	r6,64
 4015ca8:	314bc83a 	sub	r5,r6,r5
 4015cac:	1946983a 	sll	r3,r3,r5
 4015cb0:	70dcb03a 	or	r14,r14,r3
 4015cb4:	7024c03a 	cmpne	r18,r14,zero
 4015cb8:	9124b03a 	or	r18,r18,r4
 4015cbc:	003f9e06 	br	4015b38 <__adddf3+0x5e0>
 4015cc0:	103efa1e 	bne	r2,zero,40158ac <__adddf3+0x354>
 4015cc4:	4804977a 	slli	r2,r9,29
 4015cc8:	00c80034 	movhi	r3,8192
 4015ccc:	18ffffc4 	addi	r3,r3,-1
 4015cd0:	30cc703a 	and	r6,r6,r3
 4015cd4:	4810d0fa 	srli	r8,r9,3
 4015cd8:	1184b03a 	or	r2,r2,r6
 4015cdc:	003f0506 	br	40158f4 <__adddf3+0x39c>
 4015ce0:	10004426 	beq	r2,zero,4015df4 <__adddf3+0x89c>
 4015ce4:	4806977a 	slli	r3,r9,29
 4015ce8:	00880034 	movhi	r2,8192
 4015cec:	10bfffc4 	addi	r2,r2,-1
 4015cf0:	3084703a 	and	r2,r6,r2
 4015cf4:	4810d0fa 	srli	r8,r9,3
 4015cf8:	10c4b03a 	or	r2,r2,r3
 4015cfc:	3821883a 	mov	r16,r7
 4015d00:	003ed706 	br	4015860 <__adddf3+0x308>
 4015d04:	6ba5c83a 	sub	r18,r13,r14
 4015d08:	48c7c83a 	sub	r3,r9,r3
 4015d0c:	6c85803a 	cmpltu	r2,r13,r18
 4015d10:	1889c83a 	sub	r4,r3,r2
 4015d14:	3821883a 	mov	r16,r7
 4015d18:	04400044 	movi	r17,1
 4015d1c:	003e3f06 	br	401561c <__adddf3+0xc4>
 4015d20:	180a977a 	slli	r5,r3,29
 4015d24:	00880034 	movhi	r2,8192
 4015d28:	10bfffc4 	addi	r2,r2,-1
 4015d2c:	2084703a 	and	r2,r4,r2
 4015d30:	1810d0fa 	srli	r8,r3,3
 4015d34:	1144b03a 	or	r2,r2,r5
 4015d38:	003eee06 	br	40158f4 <__adddf3+0x39c>
 4015d3c:	7365c83a 	sub	r18,r14,r13
 4015d40:	7485803a 	cmpltu	r2,r14,r18
 4015d44:	1a49c83a 	sub	r4,r3,r9
 4015d48:	2089c83a 	sub	r4,r4,r2
 4015d4c:	2080202c 	andhi	r2,r4,128
 4015d50:	10002626 	beq	r2,zero,4015dec <__adddf3+0x894>
 4015d54:	6ba5c83a 	sub	r18,r13,r14
 4015d58:	48c7c83a 	sub	r3,r9,r3
 4015d5c:	6c85803a 	cmpltu	r2,r13,r18
 4015d60:	1889c83a 	sub	r4,r3,r2
 4015d64:	3821883a 	mov	r16,r7
 4015d68:	003e4a06 	br	4015694 <__adddf3+0x13c>
 4015d6c:	4806977a 	slli	r3,r9,29
 4015d70:	00880034 	movhi	r2,8192
 4015d74:	10bfffc4 	addi	r2,r2,-1
 4015d78:	3084703a 	and	r2,r6,r2
 4015d7c:	4810d0fa 	srli	r8,r9,3
 4015d80:	10c4b03a 	or	r2,r2,r3
 4015d84:	003edb06 	br	40158f4 <__adddf3+0x39c>
 4015d88:	4806977a 	slli	r3,r9,29
 4015d8c:	00880034 	movhi	r2,8192
 4015d90:	10bfffc4 	addi	r2,r2,-1
 4015d94:	3084703a 	and	r2,r6,r2
 4015d98:	4810d0fa 	srli	r8,r9,3
 4015d9c:	10c4b03a 	or	r2,r2,r3
 4015da0:	003ead06 	br	4015858 <__adddf3+0x300>
 4015da4:	180a977a 	slli	r5,r3,29
 4015da8:	1810d0fa 	srli	r8,r3,3
 4015dac:	10002f26 	beq	r2,zero,4015e6c <__adddf3+0x914>
 4015db0:	00c80034 	movhi	r3,8192
 4015db4:	18ffffc4 	addi	r3,r3,-1
 4015db8:	20c4703a 	and	r2,r4,r3
 4015dbc:	4100022c 	andhi	r4,r8,8
 4015dc0:	1144b03a 	or	r2,r2,r5
 4015dc4:	203ecb26 	beq	r4,zero,40158f4 <__adddf3+0x39c>
 4015dc8:	4808d0fa 	srli	r4,r9,3
 4015dcc:	2140022c 	andhi	r5,r4,8
 4015dd0:	283ec81e 	bne	r5,zero,40158f4 <__adddf3+0x39c>
 4015dd4:	4812977a 	slli	r9,r9,29
 4015dd8:	30c4703a 	and	r2,r6,r3
 4015ddc:	3821883a 	mov	r16,r7
 4015de0:	1244b03a 	or	r2,r2,r9
 4015de4:	2011883a 	mov	r8,r4
 4015de8:	003ec206 	br	40158f4 <__adddf3+0x39c>
 4015dec:	9104b03a 	or	r2,r18,r4
 4015df0:	103e921e 	bne	r2,zero,401583c <__adddf3+0x2e4>
 4015df4:	0011883a 	mov	r8,zero
 4015df8:	100b883a 	mov	r5,r2
 4015dfc:	0021883a 	mov	r16,zero
 4015e00:	003e9706 	br	4015860 <__adddf3+0x308>
 4015e04:	4804977a 	slli	r2,r9,29
 4015e08:	00c80034 	movhi	r3,8192
 4015e0c:	18ffffc4 	addi	r3,r3,-1
 4015e10:	30cc703a 	and	r6,r6,r3
 4015e14:	4810d0fa 	srli	r8,r9,3
 4015e18:	1184b03a 	or	r2,r2,r6
 4015e1c:	003e9006 	br	4015860 <__adddf3+0x308>
 4015e20:	7365883a 	add	r18,r14,r13
 4015e24:	1a47883a 	add	r3,r3,r9
 4015e28:	9389803a 	cmpltu	r4,r18,r14
 4015e2c:	1909883a 	add	r4,r3,r4
 4015e30:	2080202c 	andhi	r2,r4,128
 4015e34:	103e8126 	beq	r2,zero,401583c <__adddf3+0x2e4>
 4015e38:	00bfe034 	movhi	r2,65408
 4015e3c:	10bfffc4 	addi	r2,r2,-1
 4015e40:	2088703a 	and	r4,r4,r2
 4015e44:	04400044 	movi	r17,1
 4015e48:	003e7c06 	br	401583c <__adddf3+0x2e4>
 4015e4c:	4804977a 	slli	r2,r9,29
 4015e50:	00c80034 	movhi	r3,8192
 4015e54:	18ffffc4 	addi	r3,r3,-1
 4015e58:	30cc703a 	and	r6,r6,r3
 4015e5c:	4810d0fa 	srli	r8,r9,3
 4015e60:	1184b03a 	or	r2,r2,r6
 4015e64:	3821883a 	mov	r16,r7
 4015e68:	003ea206 	br	40158f4 <__adddf3+0x39c>
 4015e6c:	00880034 	movhi	r2,8192
 4015e70:	10bfffc4 	addi	r2,r2,-1
 4015e74:	2084703a 	and	r2,r4,r2
 4015e78:	1144b03a 	or	r2,r2,r5
 4015e7c:	003e9d06 	br	40158f4 <__adddf3+0x39c>
 4015e80:	293ff804 	addi	r4,r5,-32
 4015e84:	29800820 	cmpeqi	r6,r5,32
 4015e88:	1908d83a 	srl	r4,r3,r4
 4015e8c:	3000041e 	bne	r6,zero,4015ea0 <__adddf3+0x948>
 4015e90:	01801004 	movi	r6,64
 4015e94:	314bc83a 	sub	r5,r6,r5
 4015e98:	1946983a 	sll	r3,r3,r5
 4015e9c:	70dcb03a 	or	r14,r14,r3
 4015ea0:	7024c03a 	cmpne	r18,r14,zero
 4015ea4:	9124b03a 	or	r18,r18,r4
 4015ea8:	003eae06 	br	4015964 <__adddf3+0x40c>
 4015eac:	7365883a 	add	r18,r14,r13
 4015eb0:	1a47883a 	add	r3,r3,r9
 4015eb4:	9345803a 	cmpltu	r2,r18,r13
 4015eb8:	1889883a 	add	r4,r3,r2
 4015ebc:	003e5c06 	br	4015830 <__adddf3+0x2d8>
 4015ec0:	0005883a 	mov	r2,zero
 4015ec4:	0141ffc4 	movi	r5,2047
 4015ec8:	0007883a 	mov	r3,zero
 4015ecc:	003e0806 	br	40156f0 <__adddf3+0x198>

04015ed0 <__divdf3>:
 4015ed0:	2810d53a 	srli	r8,r5,20
 4015ed4:	defff004 	addi	sp,sp,-64
 4015ed8:	dc000615 	stw	r16,24(sp)
 4015edc:	04000434 	movhi	r16,16
 4015ee0:	df000e15 	stw	fp,56(sp)
 4015ee4:	ddc00d15 	stw	r23,52(sp)
 4015ee8:	dd800c15 	stw	r22,48(sp)
 4015eec:	dd000a15 	stw	r20,40(sp)
 4015ef0:	843fffc4 	addi	r16,r16,-1
 4015ef4:	dfc00f15 	stw	ra,60(sp)
 4015ef8:	dd400b15 	stw	r21,44(sp)
 4015efc:	dcc00915 	stw	r19,36(sp)
 4015f00:	dc800815 	stw	r18,32(sp)
 4015f04:	dc400715 	stw	r17,28(sp)
 4015f08:	4201ffcc 	andi	r8,r8,2047
 4015f0c:	282ed7fa 	srli	r23,r5,31
 4015f10:	3039883a 	mov	fp,r6
 4015f14:	382d883a 	mov	r22,r7
 4015f18:	2029883a 	mov	r20,r4
 4015f1c:	2c20703a 	and	r16,r5,r16
 4015f20:	40005326 	beq	r8,zero,4016070 <__divdf3+0x1a0>
 4015f24:	4081ffe0 	cmpeqi	r2,r8,2047
 4015f28:	1000641e 	bne	r2,zero,40160bc <__divdf3+0x1ec>
 4015f2c:	2026d77a 	srli	r19,r4,29
 4015f30:	800a90fa 	slli	r5,r16,3
 4015f34:	202890fa 	slli	r20,r4,3
 4015f38:	44bf0044 	addi	r18,r8,-1023
 4015f3c:	994ab03a 	or	r5,r19,r5
 4015f40:	2cc02034 	orhi	r19,r5,128
 4015f44:	0021883a 	mov	r16,zero
 4015f48:	0023883a 	mov	r17,zero
 4015f4c:	b010d53a 	srli	r8,r22,20
 4015f50:	00c00434 	movhi	r3,16
 4015f54:	18ffffc4 	addi	r3,r3,-1
 4015f58:	4201ffcc 	andi	r8,r8,2047
 4015f5c:	b02ad7fa 	srli	r21,r22,31
 4015f60:	b0ec703a 	and	r22,r22,r3
 4015f64:	40005c26 	beq	r8,zero,40160d8 <__divdf3+0x208>
 4015f68:	4081ffe0 	cmpeqi	r2,r8,2047
 4015f6c:	1000201e 	bne	r2,zero,4015ff0 <__divdf3+0x120>
 4015f70:	b00690fa 	slli	r3,r22,3
 4015f74:	e004d77a 	srli	r2,fp,29
 4015f78:	e01490fa 	slli	r10,fp,3
 4015f7c:	423f0044 	addi	r8,r8,-1023
 4015f80:	10c6b03a 	or	r3,r2,r3
 4015f84:	1d802034 	orhi	r22,r3,128
 4015f88:	9225c83a 	sub	r18,r18,r8
 4015f8c:	0007883a 	mov	r3,zero
 4015f90:	80800428 	cmpgeui	r2,r16,16
 4015f94:	bd52f03a 	xor	r9,r23,r21
 4015f98:	1000a81e 	bne	r2,zero,401623c <__divdf3+0x36c>
 4015f9c:	800c90ba 	slli	r6,r16,2
 4015fa0:	00810074 	movhi	r2,1025
 4015fa4:	3085883a 	add	r2,r6,r2
 4015fa8:	1097ec17 	ldw	r2,24496(r2)
 4015fac:	1000683a 	jmp	r2
 4015fb0:	0401623c 	xorhi	r16,zero,1416
 4015fb4:	04016060 	cmpeqi	r16,zero,1409
 4015fb8:	0401600c 	andi	r16,zero,1408
 4015fbc:	04016184 	movi	r16,1414
 4015fc0:	0401600c 	andi	r16,zero,1408
 4015fc4:	040161e0 	cmpeqi	r16,zero,1415
 4015fc8:	0401600c 	andi	r16,zero,1408
 4015fcc:	04016184 	movi	r16,1414
 4015fd0:	04016060 	cmpeqi	r16,zero,1409
 4015fd4:	04016060 	cmpeqi	r16,zero,1409
 4015fd8:	040161e0 	cmpeqi	r16,zero,1415
 4015fdc:	04016184 	movi	r16,1414
 4015fe0:	0401611c 	xori	r16,zero,1412
 4015fe4:	0401611c 	xori	r16,zero,1412
 4015fe8:	0401611c 	xori	r16,zero,1412
 4015fec:	040161f8 	rdprs	r16,zero,1415
 4015ff0:	b714b03a 	or	r10,r22,fp
 4015ff4:	94be0044 	addi	r18,r18,-2047
 4015ff8:	5000671e 	bne	r10,zero,4016198 <__divdf3+0x2c8>
 4015ffc:	84000094 	ori	r16,r16,2
 4016000:	002d883a 	mov	r22,zero
 4016004:	00c00084 	movi	r3,2
 4016008:	003fe106 	br	4015f90 <__divdf3+0xc0>
 401600c:	0007883a 	mov	r3,zero
 4016010:	000b883a 	mov	r5,zero
 4016014:	0029883a 	mov	r20,zero
 4016018:	1806953a 	slli	r3,r3,20
 401601c:	4a403fcc 	andi	r9,r9,255
 4016020:	481297fa 	slli	r9,r9,31
 4016024:	1946b03a 	or	r3,r3,r5
 4016028:	a005883a 	mov	r2,r20
 401602c:	1a46b03a 	or	r3,r3,r9
 4016030:	dfc00f17 	ldw	ra,60(sp)
 4016034:	df000e17 	ldw	fp,56(sp)
 4016038:	ddc00d17 	ldw	r23,52(sp)
 401603c:	dd800c17 	ldw	r22,48(sp)
 4016040:	dd400b17 	ldw	r21,44(sp)
 4016044:	dd000a17 	ldw	r20,40(sp)
 4016048:	dcc00917 	ldw	r19,36(sp)
 401604c:	dc800817 	ldw	r18,32(sp)
 4016050:	dc400717 	ldw	r17,28(sp)
 4016054:	dc000617 	ldw	r16,24(sp)
 4016058:	dec01004 	addi	sp,sp,64
 401605c:	f800283a 	ret
 4016060:	00c1ffc4 	movi	r3,2047
 4016064:	000b883a 	mov	r5,zero
 4016068:	0029883a 	mov	r20,zero
 401606c:	003fea06 	br	4016018 <__divdf3+0x148>
 4016070:	2426b03a 	or	r19,r4,r16
 4016074:	2023883a 	mov	r17,r4
 4016078:	98004f26 	beq	r19,zero,40161b8 <__divdf3+0x2e8>
 401607c:	80017b26 	beq	r16,zero,401666c <__divdf3+0x79c>
 4016080:	8009883a 	mov	r4,r16
 4016084:	4017d600 	call	4017d60 <__clzsi2>
 4016088:	113ffd44 	addi	r4,r2,-11
 401608c:	00c00744 	movi	r3,29
 4016090:	14fffe04 	addi	r19,r2,-8
 4016094:	1907c83a 	sub	r3,r3,r4
 4016098:	84ca983a 	sll	r5,r16,r19
 401609c:	88c6d83a 	srl	r3,r17,r3
 40160a0:	8ce8983a 	sll	r20,r17,r19
 40160a4:	1966b03a 	or	r19,r3,r5
 40160a8:	023f0344 	movi	r8,-1011
 40160ac:	40a5c83a 	sub	r18,r8,r2
 40160b0:	0021883a 	mov	r16,zero
 40160b4:	0023883a 	mov	r17,zero
 40160b8:	003fa406 	br	4015f4c <__divdf3+0x7c>
 40160bc:	2426b03a 	or	r19,r4,r16
 40160c0:	9800421e 	bne	r19,zero,40161cc <__divdf3+0x2fc>
 40160c4:	0029883a 	mov	r20,zero
 40160c8:	04000204 	movi	r16,8
 40160cc:	0481ffc4 	movi	r18,2047
 40160d0:	04400084 	movi	r17,2
 40160d4:	003f9d06 	br	4015f4c <__divdf3+0x7c>
 40160d8:	b714b03a 	or	r10,r22,fp
 40160dc:	50003226 	beq	r10,zero,40161a8 <__divdf3+0x2d8>
 40160e0:	b0016c26 	beq	r22,zero,4016694 <__divdf3+0x7c4>
 40160e4:	b009883a 	mov	r4,r22
 40160e8:	4017d600 	call	4017d60 <__clzsi2>
 40160ec:	117ffd44 	addi	r5,r2,-11
 40160f0:	01000744 	movi	r4,29
 40160f4:	12bffe04 	addi	r10,r2,-8
 40160f8:	2149c83a 	sub	r4,r4,r5
 40160fc:	b286983a 	sll	r3,r22,r10
 4016100:	e108d83a 	srl	r4,fp,r4
 4016104:	e294983a 	sll	r10,fp,r10
 4016108:	20ecb03a 	or	r22,r4,r3
 401610c:	1491883a 	add	r8,r2,r18
 4016110:	4480fcc4 	addi	r18,r8,1011
 4016114:	0007883a 	mov	r3,zero
 4016118:	003f9d06 	br	4015f90 <__divdf3+0xc0>
 401611c:	b813883a 	mov	r9,r23
 4016120:	888000a0 	cmpeqi	r2,r17,2
 4016124:	103fce1e 	bne	r2,zero,4016060 <__divdf3+0x190>
 4016128:	888000e0 	cmpeqi	r2,r17,3
 401612c:	1001ac1e 	bne	r2,zero,40167e0 <__divdf3+0x910>
 4016130:	88800060 	cmpeqi	r2,r17,1
 4016134:	103fb51e 	bne	r2,zero,401600c <__divdf3+0x13c>
 4016138:	9440ffc4 	addi	r17,r18,1023
 401613c:	04411c0e 	bge	zero,r17,40165b0 <__divdf3+0x6e0>
 4016140:	a08001cc 	andi	r2,r20,7
 4016144:	1001831e 	bne	r2,zero,4016754 <__divdf3+0x884>
 4016148:	a008d0fa 	srli	r4,r20,3
 401614c:	9880402c 	andhi	r2,r19,256
 4016150:	10000426 	beq	r2,zero,4016164 <__divdf3+0x294>
 4016154:	00bfc034 	movhi	r2,65280
 4016158:	10bfffc4 	addi	r2,r2,-1
 401615c:	98a6703a 	and	r19,r19,r2
 4016160:	94410004 	addi	r17,r18,1024
 4016164:	8881ffc8 	cmpgei	r2,r17,2047
 4016168:	103fbd1e 	bne	r2,zero,4016060 <__divdf3+0x190>
 401616c:	9828977a 	slli	r20,r19,29
 4016170:	980a927a 	slli	r5,r19,9
 4016174:	88c1ffcc 	andi	r3,r17,2047
 4016178:	a128b03a 	or	r20,r20,r4
 401617c:	280ad33a 	srli	r5,r5,12
 4016180:	003fa506 	br	4016018 <__divdf3+0x148>
 4016184:	a813883a 	mov	r9,r21
 4016188:	b027883a 	mov	r19,r22
 401618c:	5029883a 	mov	r20,r10
 4016190:	1823883a 	mov	r17,r3
 4016194:	003fe206 	br	4016120 <__divdf3+0x250>
 4016198:	840000d4 	ori	r16,r16,3
 401619c:	e015883a 	mov	r10,fp
 40161a0:	00c000c4 	movi	r3,3
 40161a4:	003f7a06 	br	4015f90 <__divdf3+0xc0>
 40161a8:	84000054 	ori	r16,r16,1
 40161ac:	002d883a 	mov	r22,zero
 40161b0:	00c00044 	movi	r3,1
 40161b4:	003f7606 	br	4015f90 <__divdf3+0xc0>
 40161b8:	0029883a 	mov	r20,zero
 40161bc:	04000104 	movi	r16,4
 40161c0:	0025883a 	mov	r18,zero
 40161c4:	04400044 	movi	r17,1
 40161c8:	003f6006 	br	4015f4c <__divdf3+0x7c>
 40161cc:	8027883a 	mov	r19,r16
 40161d0:	0481ffc4 	movi	r18,2047
 40161d4:	04000304 	movi	r16,12
 40161d8:	044000c4 	movi	r17,3
 40161dc:	003f5b06 	br	4015f4c <__divdf3+0x7c>
 40161e0:	01400434 	movhi	r5,16
 40161e4:	0013883a 	mov	r9,zero
 40161e8:	297fffc4 	addi	r5,r5,-1
 40161ec:	053fffc4 	movi	r20,-1
 40161f0:	00c1ffc4 	movi	r3,2047
 40161f4:	003f8806 	br	4016018 <__divdf3+0x148>
 40161f8:	9880022c 	andhi	r2,r19,8
 40161fc:	10000926 	beq	r2,zero,4016224 <__divdf3+0x354>
 4016200:	b080022c 	andhi	r2,r22,8
 4016204:	1000071e 	bne	r2,zero,4016224 <__divdf3+0x354>
 4016208:	00800434 	movhi	r2,16
 401620c:	b1400234 	orhi	r5,r22,8
 4016210:	10bfffc4 	addi	r2,r2,-1
 4016214:	288a703a 	and	r5,r5,r2
 4016218:	a813883a 	mov	r9,r21
 401621c:	5029883a 	mov	r20,r10
 4016220:	003ff306 	br	40161f0 <__divdf3+0x320>
 4016224:	00800434 	movhi	r2,16
 4016228:	99400234 	orhi	r5,r19,8
 401622c:	10bfffc4 	addi	r2,r2,-1
 4016230:	288a703a 	and	r5,r5,r2
 4016234:	b813883a 	mov	r9,r23
 4016238:	003fed06 	br	40161f0 <__divdf3+0x320>
 401623c:	b4c10536 	bltu	r22,r19,4016654 <__divdf3+0x784>
 4016240:	b4c10326 	beq	r22,r19,4016650 <__divdf3+0x780>
 4016244:	94bfffc4 	addi	r18,r18,-1
 4016248:	a039883a 	mov	fp,r20
 401624c:	9821883a 	mov	r16,r19
 4016250:	0023883a 	mov	r17,zero
 4016254:	b006923a 	slli	r3,r22,8
 4016258:	502cd63a 	srli	r22,r10,24
 401625c:	8009883a 	mov	r4,r16
 4016260:	182ed43a 	srli	r23,r3,16
 4016264:	b0ecb03a 	or	r22,r22,r3
 4016268:	da400015 	stw	r9,0(sp)
 401626c:	b80b883a 	mov	r5,r23
 4016270:	502a923a 	slli	r21,r10,8
 4016274:	b53fffcc 	andi	r20,r22,65535
 4016278:	40074e40 	call	40074e4 <__udivsi3>
 401627c:	100b883a 	mov	r5,r2
 4016280:	a009883a 	mov	r4,r20
 4016284:	1027883a 	mov	r19,r2
 4016288:	40075a40 	call	40075a4 <__mulsi3>
 401628c:	8009883a 	mov	r4,r16
 4016290:	b80b883a 	mov	r5,r23
 4016294:	1021883a 	mov	r16,r2
 4016298:	40075480 	call	4007548 <__umodsi3>
 401629c:	1004943a 	slli	r2,r2,16
 40162a0:	e008d43a 	srli	r4,fp,16
 40162a4:	da400017 	ldw	r9,0(sp)
 40162a8:	2088b03a 	or	r4,r4,r2
 40162ac:	2400042e 	bgeu	r4,r16,40162c0 <__divdf3+0x3f0>
 40162b0:	2589883a 	add	r4,r4,r22
 40162b4:	98bfffc4 	addi	r2,r19,-1
 40162b8:	2581082e 	bgeu	r4,r22,40166dc <__divdf3+0x80c>
 40162bc:	1027883a 	mov	r19,r2
 40162c0:	2421c83a 	sub	r16,r4,r16
 40162c4:	b80b883a 	mov	r5,r23
 40162c8:	8009883a 	mov	r4,r16
 40162cc:	da400215 	stw	r9,8(sp)
 40162d0:	40074e40 	call	40074e4 <__udivsi3>
 40162d4:	100b883a 	mov	r5,r2
 40162d8:	a009883a 	mov	r4,r20
 40162dc:	d8800115 	stw	r2,4(sp)
 40162e0:	40075a40 	call	40075a4 <__mulsi3>
 40162e4:	b80b883a 	mov	r5,r23
 40162e8:	8009883a 	mov	r4,r16
 40162ec:	d8800015 	stw	r2,0(sp)
 40162f0:	40075480 	call	4007548 <__umodsi3>
 40162f4:	100c943a 	slli	r6,r2,16
 40162f8:	d8c00017 	ldw	r3,0(sp)
 40162fc:	e73fffcc 	andi	fp,fp,65535
 4016300:	e18cb03a 	or	r6,fp,r6
 4016304:	d9c00117 	ldw	r7,4(sp)
 4016308:	da400217 	ldw	r9,8(sp)
 401630c:	30c0042e 	bgeu	r6,r3,4016320 <__divdf3+0x450>
 4016310:	358d883a 	add	r6,r6,r22
 4016314:	38bfffc4 	addi	r2,r7,-1
 4016318:	3580ec2e 	bgeu	r6,r22,40166cc <__divdf3+0x7fc>
 401631c:	100f883a 	mov	r7,r2
 4016320:	9826943a 	slli	r19,r19,16
 4016324:	af3fffcc 	andi	fp,r21,65535
 4016328:	30c7c83a 	sub	r3,r6,r3
 401632c:	99e6b03a 	or	r19,r19,r7
 4016330:	980ed43a 	srli	r7,r19,16
 4016334:	9abfffcc 	andi	r10,r19,65535
 4016338:	5009883a 	mov	r4,r10
 401633c:	e00b883a 	mov	r5,fp
 4016340:	da400515 	stw	r9,20(sp)
 4016344:	d8c00315 	stw	r3,12(sp)
 4016348:	da800415 	stw	r10,16(sp)
 401634c:	d9c00015 	stw	r7,0(sp)
 4016350:	40075a40 	call	40075a4 <__mulsi3>
 4016354:	d9c00017 	ldw	r7,0(sp)
 4016358:	e00b883a 	mov	r5,fp
 401635c:	d8800215 	stw	r2,8(sp)
 4016360:	3809883a 	mov	r4,r7
 4016364:	40075a40 	call	40075a4 <__mulsi3>
 4016368:	d9c00017 	ldw	r7,0(sp)
 401636c:	a820d43a 	srli	r16,r21,16
 4016370:	d8800115 	stw	r2,4(sp)
 4016374:	3809883a 	mov	r4,r7
 4016378:	800b883a 	mov	r5,r16
 401637c:	40075a40 	call	40075a4 <__mulsi3>
 4016380:	da800417 	ldw	r10,16(sp)
 4016384:	8009883a 	mov	r4,r16
 4016388:	d8800015 	stw	r2,0(sp)
 401638c:	500b883a 	mov	r5,r10
 4016390:	40075a40 	call	40075a4 <__mulsi3>
 4016394:	d9800217 	ldw	r6,8(sp)
 4016398:	d9c00117 	ldw	r7,4(sp)
 401639c:	da000017 	ldw	r8,0(sp)
 40163a0:	3008d43a 	srli	r4,r6,16
 40163a4:	11c5883a 	add	r2,r2,r7
 40163a8:	d8c00317 	ldw	r3,12(sp)
 40163ac:	2089883a 	add	r4,r4,r2
 40163b0:	da400517 	ldw	r9,20(sp)
 40163b4:	21c0022e 	bgeu	r4,r7,40163c0 <__divdf3+0x4f0>
 40163b8:	00800074 	movhi	r2,1
 40163bc:	4091883a 	add	r8,r8,r2
 40163c0:	200ad43a 	srli	r5,r4,16
 40163c4:	2008943a 	slli	r4,r4,16
 40163c8:	31bfffcc 	andi	r6,r6,65535
 40163cc:	2a0b883a 	add	r5,r5,r8
 40163d0:	218d883a 	add	r6,r4,r6
 40163d4:	19409436 	bltu	r3,r5,4016628 <__divdf3+0x758>
 40163d8:	19409226 	beq	r3,r5,4016624 <__divdf3+0x754>
 40163dc:	898dc83a 	sub	r6,r17,r6
 40163e0:	89a3803a 	cmpltu	r17,r17,r6
 40163e4:	1947c83a 	sub	r3,r3,r5
 40163e8:	1c47c83a 	sub	r3,r3,r17
 40163ec:	9440ffc4 	addi	r17,r18,1023
 40163f0:	b0c0d326 	beq	r22,r3,4016740 <__divdf3+0x870>
 40163f4:	1809883a 	mov	r4,r3
 40163f8:	b80b883a 	mov	r5,r23
 40163fc:	d9800315 	stw	r6,12(sp)
 4016400:	da400215 	stw	r9,8(sp)
 4016404:	d8c00015 	stw	r3,0(sp)
 4016408:	40074e40 	call	40074e4 <__udivsi3>
 401640c:	100b883a 	mov	r5,r2
 4016410:	a009883a 	mov	r4,r20
 4016414:	d8800115 	stw	r2,4(sp)
 4016418:	40075a40 	call	40075a4 <__mulsi3>
 401641c:	d8c00017 	ldw	r3,0(sp)
 4016420:	b80b883a 	mov	r5,r23
 4016424:	d8800015 	stw	r2,0(sp)
 4016428:	1809883a 	mov	r4,r3
 401642c:	40075480 	call	4007548 <__umodsi3>
 4016430:	d9800317 	ldw	r6,12(sp)
 4016434:	1006943a 	slli	r3,r2,16
 4016438:	da000017 	ldw	r8,0(sp)
 401643c:	3008d43a 	srli	r4,r6,16
 4016440:	d9c00117 	ldw	r7,4(sp)
 4016444:	da400217 	ldw	r9,8(sp)
 4016448:	20c6b03a 	or	r3,r4,r3
 401644c:	1a00062e 	bgeu	r3,r8,4016468 <__divdf3+0x598>
 4016450:	1d87883a 	add	r3,r3,r22
 4016454:	38bfffc4 	addi	r2,r7,-1
 4016458:	1d80c836 	bltu	r3,r22,401677c <__divdf3+0x8ac>
 401645c:	1a00c72e 	bgeu	r3,r8,401677c <__divdf3+0x8ac>
 4016460:	39ffff84 	addi	r7,r7,-2
 4016464:	1d87883a 	add	r3,r3,r22
 4016468:	1a07c83a 	sub	r3,r3,r8
 401646c:	1809883a 	mov	r4,r3
 4016470:	b80b883a 	mov	r5,r23
 4016474:	d9800415 	stw	r6,16(sp)
 4016478:	da400315 	stw	r9,12(sp)
 401647c:	d9c00215 	stw	r7,8(sp)
 4016480:	d8c00115 	stw	r3,4(sp)
 4016484:	40074e40 	call	40074e4 <__udivsi3>
 4016488:	100b883a 	mov	r5,r2
 401648c:	a009883a 	mov	r4,r20
 4016490:	d8800015 	stw	r2,0(sp)
 4016494:	40075a40 	call	40075a4 <__mulsi3>
 4016498:	d8c00117 	ldw	r3,4(sp)
 401649c:	b80b883a 	mov	r5,r23
 40164a0:	102f883a 	mov	r23,r2
 40164a4:	1809883a 	mov	r4,r3
 40164a8:	40075480 	call	4007548 <__umodsi3>
 40164ac:	d9800417 	ldw	r6,16(sp)
 40164b0:	1004943a 	slli	r2,r2,16
 40164b4:	da000017 	ldw	r8,0(sp)
 40164b8:	31bfffcc 	andi	r6,r6,65535
 40164bc:	308cb03a 	or	r6,r6,r2
 40164c0:	d9c00217 	ldw	r7,8(sp)
 40164c4:	da400317 	ldw	r9,12(sp)
 40164c8:	35c0062e 	bgeu	r6,r23,40164e4 <__divdf3+0x614>
 40164cc:	358d883a 	add	r6,r6,r22
 40164d0:	40bfffc4 	addi	r2,r8,-1
 40164d4:	3580a736 	bltu	r6,r22,4016774 <__divdf3+0x8a4>
 40164d8:	35c0a62e 	bgeu	r6,r23,4016774 <__divdf3+0x8a4>
 40164dc:	423fff84 	addi	r8,r8,-2
 40164e0:	358d883a 	add	r6,r6,r22
 40164e4:	3828943a 	slli	r20,r7,16
 40164e8:	35d5c83a 	sub	r10,r6,r23
 40164ec:	e009883a 	mov	r4,fp
 40164f0:	a228b03a 	or	r20,r20,r8
 40164f4:	a1ffffcc 	andi	r7,r20,65535
 40164f8:	a02ed43a 	srli	r23,r20,16
 40164fc:	380b883a 	mov	r5,r7
 4016500:	da400315 	stw	r9,12(sp)
 4016504:	da800215 	stw	r10,8(sp)
 4016508:	d9c00115 	stw	r7,4(sp)
 401650c:	40075a40 	call	40075a4 <__mulsi3>
 4016510:	e00b883a 	mov	r5,fp
 4016514:	b809883a 	mov	r4,r23
 4016518:	1039883a 	mov	fp,r2
 401651c:	40075a40 	call	40075a4 <__mulsi3>
 4016520:	8009883a 	mov	r4,r16
 4016524:	b80b883a 	mov	r5,r23
 4016528:	d8800015 	stw	r2,0(sp)
 401652c:	40075a40 	call	40075a4 <__mulsi3>
 4016530:	d9c00117 	ldw	r7,4(sp)
 4016534:	8009883a 	mov	r4,r16
 4016538:	1021883a 	mov	r16,r2
 401653c:	380b883a 	mov	r5,r7
 4016540:	40075a40 	call	40075a4 <__mulsi3>
 4016544:	d9800017 	ldw	r6,0(sp)
 4016548:	e006d43a 	srli	r3,fp,16
 401654c:	da800217 	ldw	r10,8(sp)
 4016550:	1185883a 	add	r2,r2,r6
 4016554:	1887883a 	add	r3,r3,r2
 4016558:	da400317 	ldw	r9,12(sp)
 401655c:	1980022e 	bgeu	r3,r6,4016568 <__divdf3+0x698>
 4016560:	00800074 	movhi	r2,1
 4016564:	80a1883a 	add	r16,r16,r2
 4016568:	1808d43a 	srli	r4,r3,16
 401656c:	1806943a 	slli	r3,r3,16
 4016570:	e73fffcc 	andi	fp,fp,65535
 4016574:	2409883a 	add	r4,r4,r16
 4016578:	1f07883a 	add	r3,r3,fp
 401657c:	51000436 	bltu	r10,r4,4016590 <__divdf3+0x6c0>
 4016580:	51000226 	beq	r10,r4,401658c <__divdf3+0x6bc>
 4016584:	a5000054 	ori	r20,r20,1
 4016588:	003eec06 	br	401613c <__divdf3+0x26c>
 401658c:	183eeb26 	beq	r3,zero,401613c <__divdf3+0x26c>
 4016590:	b28d883a 	add	r6,r22,r10
 4016594:	a0bfffc4 	addi	r2,r20,-1
 4016598:	35806536 	bltu	r6,r22,4016730 <__divdf3+0x860>
 401659c:	31008036 	bltu	r6,r4,40167a0 <__divdf3+0x8d0>
 40165a0:	31009426 	beq	r6,r4,40167f4 <__divdf3+0x924>
 40165a4:	1029883a 	mov	r20,r2
 40165a8:	003ff606 	br	4016584 <__divdf3+0x6b4>
 40165ac:	053fffc4 	movi	r20,-1
 40165b0:	01400044 	movi	r5,1
 40165b4:	2c4bc83a 	sub	r5,r5,r17
 40165b8:	28800e48 	cmpgei	r2,r5,57
 40165bc:	103e931e 	bne	r2,zero,401600c <__divdf3+0x13c>
 40165c0:	28800808 	cmpgei	r2,r5,32
 40165c4:	1000491e 	bne	r2,zero,40166ec <__divdf3+0x81c>
 40165c8:	92010784 	addi	r8,r18,1054
 40165cc:	9a04983a 	sll	r2,r19,r8
 40165d0:	a146d83a 	srl	r3,r20,r5
 40165d4:	a210983a 	sll	r8,r20,r8
 40165d8:	994ad83a 	srl	r5,r19,r5
 40165dc:	10e8b03a 	or	r20,r2,r3
 40165e0:	4010c03a 	cmpne	r8,r8,zero
 40165e4:	a228b03a 	or	r20,r20,r8
 40165e8:	a08001cc 	andi	r2,r20,7
 40165ec:	10000726 	beq	r2,zero,401660c <__divdf3+0x73c>
 40165f0:	a08003cc 	andi	r2,r20,15
 40165f4:	10800120 	cmpeqi	r2,r2,4
 40165f8:	1000041e 	bne	r2,zero,401660c <__divdf3+0x73c>
 40165fc:	a0800104 	addi	r2,r20,4
 4016600:	1529803a 	cmpltu	r20,r2,r20
 4016604:	2d0b883a 	add	r5,r5,r20
 4016608:	1029883a 	mov	r20,r2
 401660c:	2880202c 	andhi	r2,r5,128
 4016610:	10006f26 	beq	r2,zero,40167d0 <__divdf3+0x900>
 4016614:	00c00044 	movi	r3,1
 4016618:	000b883a 	mov	r5,zero
 401661c:	0029883a 	mov	r20,zero
 4016620:	003e7d06 	br	4016018 <__divdf3+0x148>
 4016624:	89bf6d2e 	bgeu	r17,r6,40163dc <__divdf3+0x50c>
 4016628:	8d63883a 	add	r17,r17,r21
 401662c:	8d45803a 	cmpltu	r2,r17,r21
 4016630:	1585883a 	add	r2,r2,r22
 4016634:	1887883a 	add	r3,r3,r2
 4016638:	98bfffc4 	addi	r2,r19,-1
 401663c:	b0c0202e 	bgeu	r22,r3,40166c0 <__divdf3+0x7f0>
 4016640:	19405136 	bltu	r3,r5,4016788 <__divdf3+0x8b8>
 4016644:	28c04f26 	beq	r5,r3,4016784 <__divdf3+0x8b4>
 4016648:	1027883a 	mov	r19,r2
 401664c:	003f6306 	br	40163dc <__divdf3+0x50c>
 4016650:	a2befc36 	bltu	r20,r10,4016244 <__divdf3+0x374>
 4016654:	983897fa 	slli	fp,r19,31
 4016658:	a004d07a 	srli	r2,r20,1
 401665c:	9820d07a 	srli	r16,r19,1
 4016660:	a02297fa 	slli	r17,r20,31
 4016664:	e0b8b03a 	or	fp,fp,r2
 4016668:	003efa06 	br	4016254 <__divdf3+0x384>
 401666c:	4017d600 	call	4017d60 <__clzsi2>
 4016670:	11000544 	addi	r4,r2,21
 4016674:	20c00748 	cmpgei	r3,r4,29
 4016678:	100b883a 	mov	r5,r2
 401667c:	10800804 	addi	r2,r2,32
 4016680:	183e8226 	beq	r3,zero,401608c <__divdf3+0x1bc>
 4016684:	297ffe04 	addi	r5,r5,-8
 4016688:	a166983a 	sll	r19,r20,r5
 401668c:	0029883a 	mov	r20,zero
 4016690:	003e8506 	br	40160a8 <__divdf3+0x1d8>
 4016694:	e009883a 	mov	r4,fp
 4016698:	4017d600 	call	4017d60 <__clzsi2>
 401669c:	11400544 	addi	r5,r2,21
 40166a0:	29000748 	cmpgei	r4,r5,29
 40166a4:	1007883a 	mov	r3,r2
 40166a8:	10800804 	addi	r2,r2,32
 40166ac:	203e9026 	beq	r4,zero,40160f0 <__divdf3+0x220>
 40166b0:	18fffe04 	addi	r3,r3,-8
 40166b4:	e0ec983a 	sll	r22,fp,r3
 40166b8:	0015883a 	mov	r10,zero
 40166bc:	003e9306 	br	401610c <__divdf3+0x23c>
 40166c0:	b0ffe11e 	bne	r22,r3,4016648 <__divdf3+0x778>
 40166c4:	8d7fe036 	bltu	r17,r21,4016648 <__divdf3+0x778>
 40166c8:	003fdd06 	br	4016640 <__divdf3+0x770>
 40166cc:	30ff132e 	bgeu	r6,r3,401631c <__divdf3+0x44c>
 40166d0:	39ffff84 	addi	r7,r7,-2
 40166d4:	358d883a 	add	r6,r6,r22
 40166d8:	003f1106 	br	4016320 <__divdf3+0x450>
 40166dc:	243ef72e 	bgeu	r4,r16,40162bc <__divdf3+0x3ec>
 40166e0:	9cffff84 	addi	r19,r19,-2
 40166e4:	2589883a 	add	r4,r4,r22
 40166e8:	003ef506 	br	40162c0 <__divdf3+0x3f0>
 40166ec:	00fff844 	movi	r3,-31
 40166f0:	1c47c83a 	sub	r3,r3,r17
 40166f4:	29400820 	cmpeqi	r5,r5,32
 40166f8:	98c6d83a 	srl	r3,r19,r3
 40166fc:	2800031e 	bne	r5,zero,401670c <__divdf3+0x83c>
 4016700:	91410f84 	addi	r5,r18,1086
 4016704:	994a983a 	sll	r5,r19,r5
 4016708:	a168b03a 	or	r20,r20,r5
 401670c:	a028c03a 	cmpne	r20,r20,zero
 4016710:	a0e8b03a 	or	r20,r20,r3
 4016714:	a4c001cc 	andi	r19,r20,7
 4016718:	9800291e 	bne	r19,zero,40167c0 <__divdf3+0x8f0>
 401671c:	000b883a 	mov	r5,zero
 4016720:	a028d0fa 	srli	r20,r20,3
 4016724:	0007883a 	mov	r3,zero
 4016728:	a4e8b03a 	or	r20,r20,r19
 401672c:	003e3a06 	br	4016018 <__divdf3+0x148>
 4016730:	1029883a 	mov	r20,r2
 4016734:	313f931e 	bne	r6,r4,4016584 <__divdf3+0x6b4>
 4016738:	1d7f921e 	bne	r3,r21,4016584 <__divdf3+0x6b4>
 401673c:	003e7f06 	br	401613c <__divdf3+0x26c>
 4016740:	047f9a0e 	bge	zero,r17,40165ac <__divdf3+0x6dc>
 4016744:	0009883a 	mov	r4,zero
 4016748:	05000044 	movi	r20,1
 401674c:	9d27883a 	add	r19,r19,r20
 4016750:	003e7e06 	br	401614c <__divdf3+0x27c>
 4016754:	a08003cc 	andi	r2,r20,15
 4016758:	10800118 	cmpnei	r2,r2,4
 401675c:	103e7a26 	beq	r2,zero,4016148 <__divdf3+0x278>
 4016760:	a1000104 	addi	r4,r20,4
 4016764:	00bffec4 	movi	r2,-5
 4016768:	2008d0fa 	srli	r4,r4,3
 401676c:	1529803a 	cmpltu	r20,r2,r20
 4016770:	003ff606 	br	401674c <__divdf3+0x87c>
 4016774:	1011883a 	mov	r8,r2
 4016778:	003f5a06 	br	40164e4 <__divdf3+0x614>
 401677c:	100f883a 	mov	r7,r2
 4016780:	003f3906 	br	4016468 <__divdf3+0x598>
 4016784:	89bfb02e 	bgeu	r17,r6,4016648 <__divdf3+0x778>
 4016788:	8d63883a 	add	r17,r17,r21
 401678c:	8d45803a 	cmpltu	r2,r17,r21
 4016790:	1585883a 	add	r2,r2,r22
 4016794:	9cffff84 	addi	r19,r19,-2
 4016798:	1887883a 	add	r3,r3,r2
 401679c:	003f0f06 	br	40163dc <__divdf3+0x50c>
 40167a0:	ad45883a 	add	r2,r21,r21
 40167a4:	156b803a 	cmpltu	r21,r2,r21
 40167a8:	adad883a 	add	r22,r21,r22
 40167ac:	358d883a 	add	r6,r6,r22
 40167b0:	a53fff84 	addi	r20,r20,-2
 40167b4:	102b883a 	mov	r21,r2
 40167b8:	313fdf26 	beq	r6,r4,4016738 <__divdf3+0x868>
 40167bc:	003f7106 	br	4016584 <__divdf3+0x6b4>
 40167c0:	a08003cc 	andi	r2,r20,15
 40167c4:	10800118 	cmpnei	r2,r2,4
 40167c8:	000b883a 	mov	r5,zero
 40167cc:	103f8b1e 	bne	r2,zero,40165fc <__divdf3+0x72c>
 40167d0:	2804927a 	slli	r2,r5,9
 40167d4:	2826977a 	slli	r19,r5,29
 40167d8:	100ad33a 	srli	r5,r2,12
 40167dc:	003fd006 	br	4016720 <__divdf3+0x850>
 40167e0:	00800434 	movhi	r2,16
 40167e4:	99400234 	orhi	r5,r19,8
 40167e8:	10bfffc4 	addi	r2,r2,-1
 40167ec:	288a703a 	and	r5,r5,r2
 40167f0:	003e7f06 	br	40161f0 <__divdf3+0x320>
 40167f4:	a8ffea36 	bltu	r21,r3,40167a0 <__divdf3+0x8d0>
 40167f8:	1029883a 	mov	r20,r2
 40167fc:	1d7f611e 	bne	r3,r21,4016584 <__divdf3+0x6b4>
 4016800:	003e4e06 	br	401613c <__divdf3+0x26c>

04016804 <__eqdf2>:
 4016804:	2810d53a 	srli	r8,r5,20
 4016808:	3806d53a 	srli	r3,r7,20
 401680c:	00800434 	movhi	r2,16
 4016810:	4201ffcc 	andi	r8,r8,2047
 4016814:	10bfffc4 	addi	r2,r2,-1
 4016818:	4241ffd8 	cmpnei	r9,r8,2047
 401681c:	2814d7fa 	srli	r10,r5,31
 4016820:	3816d7fa 	srli	r11,r7,31
 4016824:	288a703a 	and	r5,r5,r2
 4016828:	388e703a 	and	r7,r7,r2
 401682c:	1881ffcc 	andi	r2,r3,2047
 4016830:	48000626 	beq	r9,zero,401684c <__eqdf2+0x48>
 4016834:	10c1ffe0 	cmpeqi	r3,r2,2047
 4016838:	1800021e 	bne	r3,zero,4016844 <__eqdf2+0x40>
 401683c:	4080011e 	bne	r8,r2,4016844 <__eqdf2+0x40>
 4016840:	29c00826 	beq	r5,r7,4016864 <__eqdf2+0x60>
 4016844:	00800044 	movi	r2,1
 4016848:	f800283a 	ret
 401684c:	2906b03a 	or	r3,r5,r4
 4016850:	183ffc1e 	bne	r3,zero,4016844 <__eqdf2+0x40>
 4016854:	1081ffd8 	cmpnei	r2,r2,2047
 4016858:	103ffa1e 	bne	r2,zero,4016844 <__eqdf2+0x40>
 401685c:	398eb03a 	or	r7,r7,r6
 4016860:	383ff81e 	bne	r7,zero,4016844 <__eqdf2+0x40>
 4016864:	21bff71e 	bne	r4,r6,4016844 <__eqdf2+0x40>
 4016868:	52c00426 	beq	r10,r11,401687c <__eqdf2+0x78>
 401686c:	403ff51e 	bne	r8,zero,4016844 <__eqdf2+0x40>
 4016870:	290ab03a 	or	r5,r5,r4
 4016874:	2804c03a 	cmpne	r2,r5,zero
 4016878:	f800283a 	ret
 401687c:	0005883a 	mov	r2,zero
 4016880:	f800283a 	ret

04016884 <__gedf2>:
 4016884:	2810d53a 	srli	r8,r5,20
 4016888:	3812d53a 	srli	r9,r7,20
 401688c:	00c00434 	movhi	r3,16
 4016890:	4201ffcc 	andi	r8,r8,2047
 4016894:	18ffffc4 	addi	r3,r3,-1
 4016898:	4281ffd8 	cmpnei	r10,r8,2047
 401689c:	2816d7fa 	srli	r11,r5,31
 40168a0:	3804d7fa 	srli	r2,r7,31
 40168a4:	28ca703a 	and	r5,r5,r3
 40168a8:	38ce703a 	and	r7,r7,r3
 40168ac:	48c1ffcc 	andi	r3,r9,2047
 40168b0:	50000b26 	beq	r10,zero,40168e0 <__gedf2+0x5c>
 40168b4:	1a41ffd8 	cmpnei	r9,r3,2047
 40168b8:	48000d26 	beq	r9,zero,40168f0 <__gedf2+0x6c>
 40168bc:	4000191e 	bne	r8,zero,4016924 <__gedf2+0xa0>
 40168c0:	2914b03a 	or	r10,r5,r4
 40168c4:	5013003a 	cmpeq	r9,r10,zero
 40168c8:	1800131e 	bne	r3,zero,4016918 <__gedf2+0x94>
 40168cc:	3998b03a 	or	r12,r7,r6
 40168d0:	6000111e 	bne	r12,zero,4016918 <__gedf2+0x94>
 40168d4:	50000a1e 	bne	r10,zero,4016900 <__gedf2+0x7c>
 40168d8:	0005883a 	mov	r2,zero
 40168dc:	f800283a 	ret
 40168e0:	2912b03a 	or	r9,r5,r4
 40168e4:	48001e1e 	bne	r9,zero,4016960 <__gedf2+0xdc>
 40168e8:	1a41ffe0 	cmpeqi	r9,r3,2047
 40168ec:	48000d26 	beq	r9,zero,4016924 <__gedf2+0xa0>
 40168f0:	3992b03a 	or	r9,r7,r6
 40168f4:	48001a1e 	bne	r9,zero,4016960 <__gedf2+0xdc>
 40168f8:	40000526 	beq	r8,zero,4016910 <__gedf2+0x8c>
 40168fc:	58800d26 	beq	r11,r2,4016934 <__gedf2+0xb0>
 4016900:	00800044 	movi	r2,1
 4016904:	58000626 	beq	r11,zero,4016920 <__gedf2+0x9c>
 4016908:	00bfffc4 	movi	r2,-1
 401690c:	f800283a 	ret
 4016910:	2912b03a 	or	r9,r5,r4
 4016914:	4813003a 	cmpeq	r9,r9,zero
 4016918:	483ff826 	beq	r9,zero,40168fc <__gedf2+0x78>
 401691c:	103ffa26 	beq	r2,zero,4016908 <__gedf2+0x84>
 4016920:	f800283a 	ret
 4016924:	183ff51e 	bne	r3,zero,40168fc <__gedf2+0x78>
 4016928:	3992b03a 	or	r9,r7,r6
 401692c:	483ff31e 	bne	r9,zero,40168fc <__gedf2+0x78>
 4016930:	003ff306 	br	4016900 <__gedf2+0x7c>
 4016934:	1a000716 	blt	r3,r8,4016954 <__gedf2+0xd0>
 4016938:	40fff816 	blt	r8,r3,401691c <__gedf2+0x98>
 401693c:	397ff036 	bltu	r7,r5,4016900 <__gedf2+0x7c>
 4016940:	29c00926 	beq	r5,r7,4016968 <__gedf2+0xe4>
 4016944:	29ffe42e 	bgeu	r5,r7,40168d8 <__gedf2+0x54>
 4016948:	583fef26 	beq	r11,zero,4016908 <__gedf2+0x84>
 401694c:	5805883a 	mov	r2,r11
 4016950:	f800283a 	ret
 4016954:	103fec1e 	bne	r2,zero,4016908 <__gedf2+0x84>
 4016958:	00800044 	movi	r2,1
 401695c:	f800283a 	ret
 4016960:	00bfff84 	movi	r2,-2
 4016964:	f800283a 	ret
 4016968:	313fe536 	bltu	r6,r4,4016900 <__gedf2+0x7c>
 401696c:	21bfda2e 	bgeu	r4,r6,40168d8 <__gedf2+0x54>
 4016970:	003ff506 	br	4016948 <__gedf2+0xc4>

04016974 <__ledf2>:
 4016974:	2810d53a 	srli	r8,r5,20
 4016978:	3812d53a 	srli	r9,r7,20
 401697c:	00c00434 	movhi	r3,16
 4016980:	4201ffcc 	andi	r8,r8,2047
 4016984:	18ffffc4 	addi	r3,r3,-1
 4016988:	4281ffd8 	cmpnei	r10,r8,2047
 401698c:	2816d7fa 	srli	r11,r5,31
 4016990:	3804d7fa 	srli	r2,r7,31
 4016994:	28ca703a 	and	r5,r5,r3
 4016998:	38ce703a 	and	r7,r7,r3
 401699c:	48c1ffcc 	andi	r3,r9,2047
 40169a0:	50000b26 	beq	r10,zero,40169d0 <__ledf2+0x5c>
 40169a4:	1a41ffd8 	cmpnei	r9,r3,2047
 40169a8:	48000d26 	beq	r9,zero,40169e0 <__ledf2+0x6c>
 40169ac:	40001b1e 	bne	r8,zero,4016a1c <__ledf2+0xa8>
 40169b0:	2914b03a 	or	r10,r5,r4
 40169b4:	5013003a 	cmpeq	r9,r10,zero
 40169b8:	18000e1e 	bne	r3,zero,40169f4 <__ledf2+0x80>
 40169bc:	3998b03a 	or	r12,r7,r6
 40169c0:	60000c1e 	bne	r12,zero,40169f4 <__ledf2+0x80>
 40169c4:	50000d1e 	bne	r10,zero,40169fc <__ledf2+0x88>
 40169c8:	0005883a 	mov	r2,zero
 40169cc:	f800283a 	ret
 40169d0:	2912b03a 	or	r9,r5,r4
 40169d4:	48000d1e 	bne	r9,zero,4016a0c <__ledf2+0x98>
 40169d8:	1a41ffe0 	cmpeqi	r9,r3,2047
 40169dc:	48000f26 	beq	r9,zero,4016a1c <__ledf2+0xa8>
 40169e0:	3992b03a 	or	r9,r7,r6
 40169e4:	4800091e 	bne	r9,zero,4016a0c <__ledf2+0x98>
 40169e8:	4000031e 	bne	r8,zero,40169f8 <__ledf2+0x84>
 40169ec:	2912b03a 	or	r9,r5,r4
 40169f0:	4813003a 	cmpeq	r9,r9,zero
 40169f4:	4800071e 	bne	r9,zero,4016a14 <__ledf2+0xa0>
 40169f8:	58800c26 	beq	r11,r2,4016a2c <__ledf2+0xb8>
 40169fc:	00800044 	movi	r2,1
 4016a00:	58000526 	beq	r11,zero,4016a18 <__ledf2+0xa4>
 4016a04:	00bfffc4 	movi	r2,-1
 4016a08:	f800283a 	ret
 4016a0c:	00800084 	movi	r2,2
 4016a10:	f800283a 	ret
 4016a14:	103ffb26 	beq	r2,zero,4016a04 <__ledf2+0x90>
 4016a18:	f800283a 	ret
 4016a1c:	183ff61e 	bne	r3,zero,40169f8 <__ledf2+0x84>
 4016a20:	3992b03a 	or	r9,r7,r6
 4016a24:	483ff41e 	bne	r9,zero,40169f8 <__ledf2+0x84>
 4016a28:	003ff406 	br	40169fc <__ledf2+0x88>
 4016a2c:	1a00030e 	bge	r3,r8,4016a3c <__ledf2+0xc8>
 4016a30:	103ff41e 	bne	r2,zero,4016a04 <__ledf2+0x90>
 4016a34:	00800044 	movi	r2,1
 4016a38:	f800283a 	ret
 4016a3c:	40fff516 	blt	r8,r3,4016a14 <__ledf2+0xa0>
 4016a40:	397fee36 	bltu	r7,r5,40169fc <__ledf2+0x88>
 4016a44:	29c00426 	beq	r5,r7,4016a58 <__ledf2+0xe4>
 4016a48:	29ffdf2e 	bgeu	r5,r7,40169c8 <__ledf2+0x54>
 4016a4c:	583fed26 	beq	r11,zero,4016a04 <__ledf2+0x90>
 4016a50:	5805883a 	mov	r2,r11
 4016a54:	f800283a 	ret
 4016a58:	313fe836 	bltu	r6,r4,40169fc <__ledf2+0x88>
 4016a5c:	21bfda2e 	bgeu	r4,r6,40169c8 <__ledf2+0x54>
 4016a60:	003ffa06 	br	4016a4c <__ledf2+0xd8>

04016a64 <__muldf3>:
 4016a64:	2810d53a 	srli	r8,r5,20
 4016a68:	defff004 	addi	sp,sp,-64
 4016a6c:	00800434 	movhi	r2,16
 4016a70:	df000e15 	stw	fp,56(sp)
 4016a74:	dd000a15 	stw	r20,40(sp)
 4016a78:	dcc00915 	stw	r19,36(sp)
 4016a7c:	dc400715 	stw	r17,28(sp)
 4016a80:	10bfffc4 	addi	r2,r2,-1
 4016a84:	dfc00f15 	stw	ra,60(sp)
 4016a88:	ddc00d15 	stw	r23,52(sp)
 4016a8c:	dd800c15 	stw	r22,48(sp)
 4016a90:	dd400b15 	stw	r21,44(sp)
 4016a94:	dc800815 	stw	r18,32(sp)
 4016a98:	dc000615 	stw	r16,24(sp)
 4016a9c:	4201ffcc 	andi	r8,r8,2047
 4016aa0:	2828d7fa 	srli	r20,r5,31
 4016aa4:	2023883a 	mov	r17,r4
 4016aa8:	3039883a 	mov	fp,r6
 4016aac:	28a6703a 	and	r19,r5,r2
 4016ab0:	40005a26 	beq	r8,zero,4016c1c <__muldf3+0x1b8>
 4016ab4:	4081ffe0 	cmpeqi	r2,r8,2047
 4016ab8:	10006c1e 	bne	r2,zero,4016c6c <__muldf3+0x208>
 4016abc:	980a90fa 	slli	r5,r19,3
 4016ac0:	2026d77a 	srli	r19,r4,29
 4016ac4:	202490fa 	slli	r18,r4,3
 4016ac8:	423f0044 	addi	r8,r8,-1023
 4016acc:	9966b03a 	or	r19,r19,r5
 4016ad0:	9cc02034 	orhi	r19,r19,128
 4016ad4:	002b883a 	mov	r21,zero
 4016ad8:	002d883a 	mov	r22,zero
 4016adc:	3804d53a 	srli	r2,r7,20
 4016ae0:	00c00434 	movhi	r3,16
 4016ae4:	18ffffc4 	addi	r3,r3,-1
 4016ae8:	1081ffcc 	andi	r2,r2,2047
 4016aec:	382ed7fa 	srli	r23,r7,31
 4016af0:	38e0703a 	and	r16,r7,r3
 4016af4:	10006426 	beq	r2,zero,4016c88 <__muldf3+0x224>
 4016af8:	10c1ffe0 	cmpeqi	r3,r2,2047
 4016afc:	1800211e 	bne	r3,zero,4016b84 <__muldf3+0x120>
 4016b00:	e008d77a 	srli	r4,fp,29
 4016b04:	802090fa 	slli	r16,r16,3
 4016b08:	e02290fa 	slli	r17,fp,3
 4016b0c:	10bf0044 	addi	r2,r2,-1023
 4016b10:	2420b03a 	or	r16,r4,r16
 4016b14:	84002034 	orhi	r16,r16,128
 4016b18:	4091883a 	add	r8,r8,r2
 4016b1c:	0009883a 	mov	r4,zero
 4016b20:	a8800428 	cmpgeui	r2,r21,16
 4016b24:	a5ccf03a 	xor	r6,r20,r23
 4016b28:	41c00044 	addi	r7,r8,1
 4016b2c:	10006d1e 	bne	r2,zero,4016ce4 <__muldf3+0x280>
 4016b30:	a80490ba 	slli	r2,r21,2
 4016b34:	00c10074 	movhi	r3,1025
 4016b38:	10c7883a 	add	r3,r2,r3
 4016b3c:	189ad117 	ldw	r2,27460(r3)
 4016b40:	1000683a 	jmp	r2
 4016b44:	04016ce4 	muli	r16,zero,1459
 4016b48:	04016ba4 	muli	r16,zero,1454
 4016b4c:	04016ba4 	muli	r16,zero,1454
 4016b50:	04016ba0 	cmpeqi	r16,zero,1454
 4016b54:	04016bb0 	cmpltui	r16,zero,1454
 4016b58:	04016bb0 	cmpltui	r16,zero,1454
 4016b5c:	04017060 	cmpeqi	r16,zero,1473
 4016b60:	04016ba0 	cmpeqi	r16,zero,1454
 4016b64:	04016bb0 	cmpltui	r16,zero,1454
 4016b68:	04017060 	cmpeqi	r16,zero,1473
 4016b6c:	04016bb0 	cmpltui	r16,zero,1454
 4016b70:	04016ba0 	cmpeqi	r16,zero,1454
 4016b74:	04017010 	cmplti	r16,zero,1472
 4016b78:	04017010 	cmplti	r16,zero,1472
 4016b7c:	04017010 	cmplti	r16,zero,1472
 4016b80:	040170ec 	andhi	r16,zero,1475
 4016b84:	e422b03a 	or	r17,fp,r16
 4016b88:	4201ffc4 	addi	r8,r8,2047
 4016b8c:	8801221e 	bne	r17,zero,4017018 <__muldf3+0x5b4>
 4016b90:	ad400094 	ori	r21,r21,2
 4016b94:	0021883a 	mov	r16,zero
 4016b98:	01000084 	movi	r4,2
 4016b9c:	003fe006 	br	4016b20 <__muldf3+0xbc>
 4016ba0:	b80d883a 	mov	r6,r23
 4016ba4:	8027883a 	mov	r19,r16
 4016ba8:	8825883a 	mov	r18,r17
 4016bac:	202d883a 	mov	r22,r4
 4016bb0:	b08000a0 	cmpeqi	r2,r22,2
 4016bb4:	1000471e 	bne	r2,zero,4016cd4 <__muldf3+0x270>
 4016bb8:	b08000e0 	cmpeqi	r2,r22,3
 4016bbc:	10018e1e 	bne	r2,zero,40171f8 <__muldf3+0x794>
 4016bc0:	b0800060 	cmpeqi	r2,r22,1
 4016bc4:	1000f826 	beq	r2,zero,4016fa8 <__muldf3+0x544>
 4016bc8:	0007883a 	mov	r3,zero
 4016bcc:	0027883a 	mov	r19,zero
 4016bd0:	0025883a 	mov	r18,zero
 4016bd4:	1806953a 	slli	r3,r3,20
 4016bd8:	31803fcc 	andi	r6,r6,255
 4016bdc:	300c97fa 	slli	r6,r6,31
 4016be0:	1cc6b03a 	or	r3,r3,r19
 4016be4:	9005883a 	mov	r2,r18
 4016be8:	1986b03a 	or	r3,r3,r6
 4016bec:	dfc00f17 	ldw	ra,60(sp)
 4016bf0:	df000e17 	ldw	fp,56(sp)
 4016bf4:	ddc00d17 	ldw	r23,52(sp)
 4016bf8:	dd800c17 	ldw	r22,48(sp)
 4016bfc:	dd400b17 	ldw	r21,44(sp)
 4016c00:	dd000a17 	ldw	r20,40(sp)
 4016c04:	dcc00917 	ldw	r19,36(sp)
 4016c08:	dc800817 	ldw	r18,32(sp)
 4016c0c:	dc400717 	ldw	r17,28(sp)
 4016c10:	dc000617 	ldw	r16,24(sp)
 4016c14:	dec01004 	addi	sp,sp,64
 4016c18:	f800283a 	ret
 4016c1c:	9924b03a 	or	r18,r19,r4
 4016c20:	90010a26 	beq	r18,zero,401704c <__muldf3+0x5e8>
 4016c24:	d9c00015 	stw	r7,0(sp)
 4016c28:	98014d26 	beq	r19,zero,4017160 <__muldf3+0x6fc>
 4016c2c:	9809883a 	mov	r4,r19
 4016c30:	4017d600 	call	4017d60 <__clzsi2>
 4016c34:	d9c00017 	ldw	r7,0(sp)
 4016c38:	113ffd44 	addi	r4,r2,-11
 4016c3c:	00c00744 	movi	r3,29
 4016c40:	14bffe04 	addi	r18,r2,-8
 4016c44:	1907c83a 	sub	r3,r3,r4
 4016c48:	9ca6983a 	sll	r19,r19,r18
 4016c4c:	88c6d83a 	srl	r3,r17,r3
 4016c50:	8ca4983a 	sll	r18,r17,r18
 4016c54:	1ce6b03a 	or	r19,r3,r19
 4016c58:	023f0344 	movi	r8,-1011
 4016c5c:	4091c83a 	sub	r8,r8,r2
 4016c60:	002b883a 	mov	r21,zero
 4016c64:	002d883a 	mov	r22,zero
 4016c68:	003f9c06 	br	4016adc <__muldf3+0x78>
 4016c6c:	9924b03a 	or	r18,r19,r4
 4016c70:	9000f11e 	bne	r18,zero,4017038 <__muldf3+0x5d4>
 4016c74:	0027883a 	mov	r19,zero
 4016c78:	05400204 	movi	r21,8
 4016c7c:	0201ffc4 	movi	r8,2047
 4016c80:	05800084 	movi	r22,2
 4016c84:	003f9506 	br	4016adc <__muldf3+0x78>
 4016c88:	e422b03a 	or	r17,fp,r16
 4016c8c:	8800e626 	beq	r17,zero,4017028 <__muldf3+0x5c4>
 4016c90:	da000015 	stw	r8,0(sp)
 4016c94:	80012626 	beq	r16,zero,4017130 <__muldf3+0x6cc>
 4016c98:	8009883a 	mov	r4,r16
 4016c9c:	4017d600 	call	4017d60 <__clzsi2>
 4016ca0:	da000017 	ldw	r8,0(sp)
 4016ca4:	117ffd44 	addi	r5,r2,-11
 4016ca8:	01000744 	movi	r4,29
 4016cac:	147ffe04 	addi	r17,r2,-8
 4016cb0:	2149c83a 	sub	r4,r4,r5
 4016cb4:	8460983a 	sll	r16,r16,r17
 4016cb8:	e108d83a 	srl	r4,fp,r4
 4016cbc:	e462983a 	sll	r17,fp,r17
 4016cc0:	2420b03a 	or	r16,r4,r16
 4016cc4:	4091c83a 	sub	r8,r8,r2
 4016cc8:	423f0344 	addi	r8,r8,-1011
 4016ccc:	0009883a 	mov	r4,zero
 4016cd0:	003f9306 	br	4016b20 <__muldf3+0xbc>
 4016cd4:	00c1ffc4 	movi	r3,2047
 4016cd8:	0027883a 	mov	r19,zero
 4016cdc:	0025883a 	mov	r18,zero
 4016ce0:	003fbc06 	br	4016bd4 <__muldf3+0x170>
 4016ce4:	9028d43a 	srli	r20,r18,16
 4016ce8:	8f3fffcc 	andi	fp,r17,65535
 4016cec:	957fffcc 	andi	r21,r18,65535
 4016cf0:	a80b883a 	mov	r5,r21
 4016cf4:	e009883a 	mov	r4,fp
 4016cf8:	d9800315 	stw	r6,12(sp)
 4016cfc:	da000215 	stw	r8,8(sp)
 4016d00:	d9c00115 	stw	r7,4(sp)
 4016d04:	8822d43a 	srli	r17,r17,16
 4016d08:	40075a40 	call	40075a4 <__mulsi3>
 4016d0c:	e00b883a 	mov	r5,fp
 4016d10:	a009883a 	mov	r4,r20
 4016d14:	102d883a 	mov	r22,r2
 4016d18:	40075a40 	call	40075a4 <__mulsi3>
 4016d1c:	880b883a 	mov	r5,r17
 4016d20:	a009883a 	mov	r4,r20
 4016d24:	102f883a 	mov	r23,r2
 4016d28:	40075a40 	call	40075a4 <__mulsi3>
 4016d2c:	a80b883a 	mov	r5,r21
 4016d30:	8809883a 	mov	r4,r17
 4016d34:	d8800015 	stw	r2,0(sp)
 4016d38:	40075a40 	call	40075a4 <__mulsi3>
 4016d3c:	b006d43a 	srli	r3,r22,16
 4016d40:	15e5883a 	add	r18,r2,r23
 4016d44:	d9c00117 	ldw	r7,4(sp)
 4016d48:	1c87883a 	add	r3,r3,r18
 4016d4c:	da000217 	ldw	r8,8(sp)
 4016d50:	d9800317 	ldw	r6,12(sp)
 4016d54:	1dc0042e 	bgeu	r3,r23,4016d68 <__muldf3+0x304>
 4016d58:	d9000017 	ldw	r4,0(sp)
 4016d5c:	00800074 	movhi	r2,1
 4016d60:	2085883a 	add	r2,r4,r2
 4016d64:	d8800015 	stw	r2,0(sp)
 4016d68:	1804943a 	slli	r2,r3,16
 4016d6c:	85ffffcc 	andi	r23,r16,65535
 4016d70:	b5bfffcc 	andi	r22,r22,65535
 4016d74:	1585883a 	add	r2,r2,r22
 4016d78:	a80b883a 	mov	r5,r21
 4016d7c:	b809883a 	mov	r4,r23
 4016d80:	1824d43a 	srli	r18,r3,16
 4016d84:	d9800515 	stw	r6,20(sp)
 4016d88:	da000415 	stw	r8,16(sp)
 4016d8c:	d9c00315 	stw	r7,12(sp)
 4016d90:	8020d43a 	srli	r16,r16,16
 4016d94:	d8800115 	stw	r2,4(sp)
 4016d98:	40075a40 	call	40075a4 <__mulsi3>
 4016d9c:	a009883a 	mov	r4,r20
 4016da0:	b80b883a 	mov	r5,r23
 4016da4:	d8800215 	stw	r2,8(sp)
 4016da8:	40075a40 	call	40075a4 <__mulsi3>
 4016dac:	a009883a 	mov	r4,r20
 4016db0:	800b883a 	mov	r5,r16
 4016db4:	102d883a 	mov	r22,r2
 4016db8:	40075a40 	call	40075a4 <__mulsi3>
 4016dbc:	a80b883a 	mov	r5,r21
 4016dc0:	8009883a 	mov	r4,r16
 4016dc4:	1029883a 	mov	r20,r2
 4016dc8:	40075a40 	call	40075a4 <__mulsi3>
 4016dcc:	da800217 	ldw	r10,8(sp)
 4016dd0:	1585883a 	add	r2,r2,r22
 4016dd4:	d9c00317 	ldw	r7,12(sp)
 4016dd8:	5006d43a 	srli	r3,r10,16
 4016ddc:	da000417 	ldw	r8,16(sp)
 4016de0:	d9800517 	ldw	r6,20(sp)
 4016de4:	1887883a 	add	r3,r3,r2
 4016de8:	1d80022e 	bgeu	r3,r22,4016df4 <__muldf3+0x390>
 4016dec:	00800074 	movhi	r2,1
 4016df0:	a0a9883a 	add	r20,r20,r2
 4016df4:	1804d43a 	srli	r2,r3,16
 4016df8:	1806943a 	slli	r3,r3,16
 4016dfc:	982cd43a 	srli	r22,r19,16
 4016e00:	9d7fffcc 	andi	r21,r19,65535
 4016e04:	e009883a 	mov	r4,fp
 4016e08:	54ffffcc 	andi	r19,r10,65535
 4016e0c:	a80b883a 	mov	r5,r21
 4016e10:	1ce7883a 	add	r19,r3,r19
 4016e14:	d9800515 	stw	r6,20(sp)
 4016e18:	da000415 	stw	r8,16(sp)
 4016e1c:	d9c00315 	stw	r7,12(sp)
 4016e20:	1529883a 	add	r20,r2,r20
 4016e24:	40075a40 	call	40075a4 <__mulsi3>
 4016e28:	e00b883a 	mov	r5,fp
 4016e2c:	b009883a 	mov	r4,r22
 4016e30:	d8800215 	stw	r2,8(sp)
 4016e34:	40075a40 	call	40075a4 <__mulsi3>
 4016e38:	8809883a 	mov	r4,r17
 4016e3c:	b00b883a 	mov	r5,r22
 4016e40:	1039883a 	mov	fp,r2
 4016e44:	40075a40 	call	40075a4 <__mulsi3>
 4016e48:	8809883a 	mov	r4,r17
 4016e4c:	a80b883a 	mov	r5,r21
 4016e50:	1023883a 	mov	r17,r2
 4016e54:	40075a40 	call	40075a4 <__mulsi3>
 4016e58:	d8c00217 	ldw	r3,8(sp)
 4016e5c:	1705883a 	add	r2,r2,fp
 4016e60:	d9c00317 	ldw	r7,12(sp)
 4016e64:	1808d43a 	srli	r4,r3,16
 4016e68:	da000417 	ldw	r8,16(sp)
 4016e6c:	d9800517 	ldw	r6,20(sp)
 4016e70:	2089883a 	add	r4,r4,r2
 4016e74:	94e5883a 	add	r18,r18,r19
 4016e78:	2700022e 	bgeu	r4,fp,4016e84 <__muldf3+0x420>
 4016e7c:	00800074 	movhi	r2,1
 4016e80:	88a3883a 	add	r17,r17,r2
 4016e84:	2004d43a 	srli	r2,r4,16
 4016e88:	2038943a 	slli	fp,r4,16
 4016e8c:	18ffffcc 	andi	r3,r3,65535
 4016e90:	b809883a 	mov	r4,r23
 4016e94:	a80b883a 	mov	r5,r21
 4016e98:	d9800415 	stw	r6,16(sp)
 4016e9c:	da000315 	stw	r8,12(sp)
 4016ea0:	d9c00215 	stw	r7,8(sp)
 4016ea4:	e0f9883a 	add	fp,fp,r3
 4016ea8:	1463883a 	add	r17,r2,r17
 4016eac:	40075a40 	call	40075a4 <__mulsi3>
 4016eb0:	b80b883a 	mov	r5,r23
 4016eb4:	b009883a 	mov	r4,r22
 4016eb8:	102f883a 	mov	r23,r2
 4016ebc:	40075a40 	call	40075a4 <__mulsi3>
 4016ec0:	b00b883a 	mov	r5,r22
 4016ec4:	8009883a 	mov	r4,r16
 4016ec8:	102d883a 	mov	r22,r2
 4016ecc:	40075a40 	call	40075a4 <__mulsi3>
 4016ed0:	a80b883a 	mov	r5,r21
 4016ed4:	8009883a 	mov	r4,r16
 4016ed8:	1021883a 	mov	r16,r2
 4016edc:	40075a40 	call	40075a4 <__mulsi3>
 4016ee0:	b80ad43a 	srli	r5,r23,16
 4016ee4:	1585883a 	add	r2,r2,r22
 4016ee8:	d9c00217 	ldw	r7,8(sp)
 4016eec:	288b883a 	add	r5,r5,r2
 4016ef0:	da000317 	ldw	r8,12(sp)
 4016ef4:	d9800417 	ldw	r6,16(sp)
 4016ef8:	2d80022e 	bgeu	r5,r22,4016f04 <__muldf3+0x4a0>
 4016efc:	00800074 	movhi	r2,1
 4016f00:	80a1883a 	add	r16,r16,r2
 4016f04:	2806943a 	slli	r3,r5,16
 4016f08:	d8800017 	ldw	r2,0(sp)
 4016f0c:	bdffffcc 	andi	r23,r23,65535
 4016f10:	1dc7883a 	add	r3,r3,r23
 4016f14:	90ab883a 	add	r21,r18,r2
 4016f18:	acd5803a 	cmpltu	r10,r21,r19
 4016f1c:	1d07883a 	add	r3,r3,r20
 4016f20:	af2b883a 	add	r21,r21,fp
 4016f24:	1a97883a 	add	r11,r3,r10
 4016f28:	af09803a 	cmpltu	r4,r21,fp
 4016f2c:	2826d43a 	srli	r19,r5,16
 4016f30:	5c53883a 	add	r9,r11,r17
 4016f34:	4905883a 	add	r2,r9,r4
 4016f38:	1d29803a 	cmpltu	r20,r3,r20
 4016f3c:	5a95803a 	cmpltu	r10,r11,r10
 4016f40:	1109803a 	cmpltu	r4,r2,r4
 4016f44:	a2a8b03a 	or	r20,r20,r10
 4016f48:	4c63803a 	cmpltu	r17,r9,r17
 4016f4c:	a4e7883a 	add	r19,r20,r19
 4016f50:	8908b03a 	or	r4,r17,r4
 4016f54:	a824927a 	slli	r18,r21,9
 4016f58:	d8c00117 	ldw	r3,4(sp)
 4016f5c:	9927883a 	add	r19,r19,r4
 4016f60:	9c27883a 	add	r19,r19,r16
 4016f64:	9826927a 	slli	r19,r19,9
 4016f68:	a82ad5fa 	srli	r21,r21,23
 4016f6c:	100ad5fa 	srli	r5,r2,23
 4016f70:	90e4b03a 	or	r18,r18,r3
 4016f74:	1004927a 	slli	r2,r2,9
 4016f78:	9024c03a 	cmpne	r18,r18,zero
 4016f7c:	9564b03a 	or	r18,r18,r21
 4016f80:	98c0402c 	andhi	r3,r19,256
 4016f84:	90a4b03a 	or	r18,r18,r2
 4016f88:	9966b03a 	or	r19,r19,r5
 4016f8c:	18007f26 	beq	r3,zero,401718c <__muldf3+0x728>
 4016f90:	9006d07a 	srli	r3,r18,1
 4016f94:	980497fa 	slli	r2,r19,31
 4016f98:	9480004c 	andi	r18,r18,1
 4016f9c:	9826d07a 	srli	r19,r19,1
 4016fa0:	1c86b03a 	or	r3,r3,r18
 4016fa4:	18a4b03a 	or	r18,r3,r2
 4016fa8:	3900ffc4 	addi	r4,r7,1023
 4016fac:	0100320e 	bge	zero,r4,4017078 <__muldf3+0x614>
 4016fb0:	908001cc 	andi	r2,r18,7
 4016fb4:	10000726 	beq	r2,zero,4016fd4 <__muldf3+0x570>
 4016fb8:	908003cc 	andi	r2,r18,15
 4016fbc:	10800120 	cmpeqi	r2,r2,4
 4016fc0:	1000041e 	bne	r2,zero,4016fd4 <__muldf3+0x570>
 4016fc4:	90800104 	addi	r2,r18,4
 4016fc8:	14a5803a 	cmpltu	r18,r2,r18
 4016fcc:	9ca7883a 	add	r19,r19,r18
 4016fd0:	1025883a 	mov	r18,r2
 4016fd4:	9880402c 	andhi	r2,r19,256
 4016fd8:	10000426 	beq	r2,zero,4016fec <__muldf3+0x588>
 4016fdc:	00bfc034 	movhi	r2,65280
 4016fe0:	10bfffc4 	addi	r2,r2,-1
 4016fe4:	98a6703a 	and	r19,r19,r2
 4016fe8:	39010004 	addi	r4,r7,1024
 4016fec:	2081ffc8 	cmpgei	r2,r4,2047
 4016ff0:	103f381e 	bne	r2,zero,4016cd4 <__muldf3+0x270>
 4016ff4:	9804977a 	slli	r2,r19,29
 4016ff8:	9024d0fa 	srli	r18,r18,3
 4016ffc:	9826927a 	slli	r19,r19,9
 4017000:	20c1ffcc 	andi	r3,r4,2047
 4017004:	14a4b03a 	or	r18,r2,r18
 4017008:	9826d33a 	srli	r19,r19,12
 401700c:	003ef106 	br	4016bd4 <__muldf3+0x170>
 4017010:	a00d883a 	mov	r6,r20
 4017014:	003ee606 	br	4016bb0 <__muldf3+0x14c>
 4017018:	ad4000d4 	ori	r21,r21,3
 401701c:	e023883a 	mov	r17,fp
 4017020:	010000c4 	movi	r4,3
 4017024:	003ebe06 	br	4016b20 <__muldf3+0xbc>
 4017028:	ad400054 	ori	r21,r21,1
 401702c:	0021883a 	mov	r16,zero
 4017030:	01000044 	movi	r4,1
 4017034:	003eba06 	br	4016b20 <__muldf3+0xbc>
 4017038:	2025883a 	mov	r18,r4
 401703c:	05400304 	movi	r21,12
 4017040:	0201ffc4 	movi	r8,2047
 4017044:	058000c4 	movi	r22,3
 4017048:	003ea406 	br	4016adc <__muldf3+0x78>
 401704c:	0027883a 	mov	r19,zero
 4017050:	05400104 	movi	r21,4
 4017054:	0011883a 	mov	r8,zero
 4017058:	05800044 	movi	r22,1
 401705c:	003e9f06 	br	4016adc <__muldf3+0x78>
 4017060:	04c00434 	movhi	r19,16
 4017064:	000d883a 	mov	r6,zero
 4017068:	9cffffc4 	addi	r19,r19,-1
 401706c:	04bfffc4 	movi	r18,-1
 4017070:	00c1ffc4 	movi	r3,2047
 4017074:	003ed706 	br	4016bd4 <__muldf3+0x170>
 4017078:	00800044 	movi	r2,1
 401707c:	1105c83a 	sub	r2,r2,r4
 4017080:	10c00e48 	cmpgei	r3,r2,57
 4017084:	183ed01e 	bne	r3,zero,4016bc8 <__muldf3+0x164>
 4017088:	10c00808 	cmpgei	r3,r2,32
 401708c:	1800411e 	bne	r3,zero,4017194 <__muldf3+0x730>
 4017090:	39c10784 	addi	r7,r7,1054
 4017094:	99c6983a 	sll	r3,r19,r7
 4017098:	9088d83a 	srl	r4,r18,r2
 401709c:	91ce983a 	sll	r7,r18,r7
 40170a0:	98a6d83a 	srl	r19,r19,r2
 40170a4:	1904b03a 	or	r2,r3,r4
 40170a8:	3824c03a 	cmpne	r18,r7,zero
 40170ac:	1484b03a 	or	r2,r2,r18
 40170b0:	10c001cc 	andi	r3,r2,7
 40170b4:	18000726 	beq	r3,zero,40170d4 <__muldf3+0x670>
 40170b8:	10c003cc 	andi	r3,r2,15
 40170bc:	18c00120 	cmpeqi	r3,r3,4
 40170c0:	1800041e 	bne	r3,zero,40170d4 <__muldf3+0x670>
 40170c4:	10c00104 	addi	r3,r2,4
 40170c8:	1885803a 	cmpltu	r2,r3,r2
 40170cc:	98a7883a 	add	r19,r19,r2
 40170d0:	1805883a 	mov	r2,r3
 40170d4:	98c0202c 	andhi	r3,r19,128
 40170d8:	18004326 	beq	r3,zero,40171e8 <__muldf3+0x784>
 40170dc:	00c00044 	movi	r3,1
 40170e0:	0027883a 	mov	r19,zero
 40170e4:	0025883a 	mov	r18,zero
 40170e8:	003eba06 	br	4016bd4 <__muldf3+0x170>
 40170ec:	9880022c 	andhi	r2,r19,8
 40170f0:	10000926 	beq	r2,zero,4017118 <__muldf3+0x6b4>
 40170f4:	8080022c 	andhi	r2,r16,8
 40170f8:	1000071e 	bne	r2,zero,4017118 <__muldf3+0x6b4>
 40170fc:	00800434 	movhi	r2,16
 4017100:	84c00234 	orhi	r19,r16,8
 4017104:	10bfffc4 	addi	r2,r2,-1
 4017108:	98a6703a 	and	r19,r19,r2
 401710c:	b80d883a 	mov	r6,r23
 4017110:	8825883a 	mov	r18,r17
 4017114:	003fd606 	br	4017070 <__muldf3+0x60c>
 4017118:	00800434 	movhi	r2,16
 401711c:	9cc00234 	orhi	r19,r19,8
 4017120:	10bfffc4 	addi	r2,r2,-1
 4017124:	98a6703a 	and	r19,r19,r2
 4017128:	a00d883a 	mov	r6,r20
 401712c:	003fd006 	br	4017070 <__muldf3+0x60c>
 4017130:	e009883a 	mov	r4,fp
 4017134:	4017d600 	call	4017d60 <__clzsi2>
 4017138:	11400544 	addi	r5,r2,21
 401713c:	29000748 	cmpgei	r4,r5,29
 4017140:	1007883a 	mov	r3,r2
 4017144:	da000017 	ldw	r8,0(sp)
 4017148:	10800804 	addi	r2,r2,32
 401714c:	203ed626 	beq	r4,zero,4016ca8 <__muldf3+0x244>
 4017150:	1c3ffe04 	addi	r16,r3,-8
 4017154:	e420983a 	sll	r16,fp,r16
 4017158:	0023883a 	mov	r17,zero
 401715c:	003ed906 	br	4016cc4 <__muldf3+0x260>
 4017160:	4017d600 	call	4017d60 <__clzsi2>
 4017164:	11000544 	addi	r4,r2,21
 4017168:	21400748 	cmpgei	r5,r4,29
 401716c:	1007883a 	mov	r3,r2
 4017170:	d9c00017 	ldw	r7,0(sp)
 4017174:	10800804 	addi	r2,r2,32
 4017178:	283eb026 	beq	r5,zero,4016c3c <__muldf3+0x1d8>
 401717c:	1cfffe04 	addi	r19,r3,-8
 4017180:	8ce6983a 	sll	r19,r17,r19
 4017184:	0025883a 	mov	r18,zero
 4017188:	003eb306 	br	4016c58 <__muldf3+0x1f4>
 401718c:	400f883a 	mov	r7,r8
 4017190:	003f8506 	br	4016fa8 <__muldf3+0x544>
 4017194:	00fff844 	movi	r3,-31
 4017198:	1907c83a 	sub	r3,r3,r4
 401719c:	10800820 	cmpeqi	r2,r2,32
 40171a0:	98c6d83a 	srl	r3,r19,r3
 40171a4:	1000031e 	bne	r2,zero,40171b4 <__muldf3+0x750>
 40171a8:	39c10f84 	addi	r7,r7,1086
 40171ac:	99e6983a 	sll	r19,r19,r7
 40171b0:	94e4b03a 	or	r18,r18,r19
 40171b4:	9024c03a 	cmpne	r18,r18,zero
 40171b8:	90c4b03a 	or	r2,r18,r3
 40171bc:	148001cc 	andi	r18,r2,7
 40171c0:	9000051e 	bne	r18,zero,40171d8 <__muldf3+0x774>
 40171c4:	0027883a 	mov	r19,zero
 40171c8:	1004d0fa 	srli	r2,r2,3
 40171cc:	0007883a 	mov	r3,zero
 40171d0:	14a4b03a 	or	r18,r2,r18
 40171d4:	003e7f06 	br	4016bd4 <__muldf3+0x170>
 40171d8:	10c003cc 	andi	r3,r2,15
 40171dc:	18c00118 	cmpnei	r3,r3,4
 40171e0:	0027883a 	mov	r19,zero
 40171e4:	183fb71e 	bne	r3,zero,40170c4 <__muldf3+0x660>
 40171e8:	9806927a 	slli	r3,r19,9
 40171ec:	9824977a 	slli	r18,r19,29
 40171f0:	1826d33a 	srli	r19,r3,12
 40171f4:	003ff406 	br	40171c8 <__muldf3+0x764>
 40171f8:	00800434 	movhi	r2,16
 40171fc:	9cc00234 	orhi	r19,r19,8
 4017200:	10bfffc4 	addi	r2,r2,-1
 4017204:	98a6703a 	and	r19,r19,r2
 4017208:	003f9906 	br	4017070 <__muldf3+0x60c>

0401720c <__subdf3>:
 401720c:	00c00434 	movhi	r3,16
 4017210:	3812d53a 	srli	r9,r7,20
 4017214:	18ffffc4 	addi	r3,r3,-1
 4017218:	defffb04 	addi	sp,sp,-20
 401721c:	28d0703a 	and	r8,r5,r3
 4017220:	38c6703a 	and	r3,r7,r3
 4017224:	2804d7fa 	srli	r2,r5,31
 4017228:	401090fa 	slli	r8,r8,3
 401722c:	280ad53a 	srli	r5,r5,20
 4017230:	180690fa 	slli	r3,r3,3
 4017234:	dcc00315 	stw	r19,12(sp)
 4017238:	dc400115 	stw	r17,4(sp)
 401723c:	2026d77a 	srli	r19,r4,29
 4017240:	3022d77a 	srli	r17,r6,29
 4017244:	4b41ffcc 	andi	r13,r9,2047
 4017248:	dc800215 	stw	r18,8(sp)
 401724c:	dc000015 	stw	r16,0(sp)
 4017250:	dfc00415 	stw	ra,16(sp)
 4017254:	6a41ffe0 	cmpeqi	r9,r13,2047
 4017258:	1025883a 	mov	r18,r2
 401725c:	201690fa 	slli	r11,r4,3
 4017260:	380ed7fa 	srli	r7,r7,31
 4017264:	301490fa 	slli	r10,r6,3
 4017268:	2c01ffcc 	andi	r16,r5,2047
 401726c:	10803fcc 	andi	r2,r2,255
 4017270:	9a10b03a 	or	r8,r19,r8
 4017274:	88c6b03a 	or	r3,r17,r3
 4017278:	48006e1e 	bne	r9,zero,4017434 <__subdf3+0x228>
 401727c:	3a40005c 	xori	r9,r7,1
 4017280:	834bc83a 	sub	r5,r16,r13
 4017284:	12405726 	beq	r2,r9,40173e4 <__subdf3+0x1d8>
 4017288:	01406f0e 	bge	zero,r5,4017448 <__subdf3+0x23c>
 401728c:	68007a26 	beq	r13,zero,4017478 <__subdf3+0x26c>
 4017290:	8081ffd8 	cmpnei	r2,r16,2047
 4017294:	10019f26 	beq	r2,zero,4017914 <__subdf3+0x708>
 4017298:	18c02034 	orhi	r3,r3,128
 401729c:	28800e48 	cmpgei	r2,r5,57
 40172a0:	1000f91e 	bne	r2,zero,4017688 <__subdf3+0x47c>
 40172a4:	28800808 	cmpgei	r2,r5,32
 40172a8:	1001451e 	bne	r2,zero,40177c0 <__subdf3+0x5b4>
 40172ac:	00800804 	movi	r2,32
 40172b0:	1145c83a 	sub	r2,r2,r5
 40172b4:	18a2983a 	sll	r17,r3,r2
 40172b8:	5148d83a 	srl	r4,r10,r5
 40172bc:	5084983a 	sll	r2,r10,r2
 40172c0:	1946d83a 	srl	r3,r3,r5
 40172c4:	8922b03a 	or	r17,r17,r4
 40172c8:	1004c03a 	cmpne	r2,r2,zero
 40172cc:	88a2b03a 	or	r17,r17,r2
 40172d0:	40d1c83a 	sub	r8,r8,r3
 40172d4:	5c63c83a 	sub	r17,r11,r17
 40172d8:	5c49803a 	cmpltu	r4,r11,r17
 40172dc:	4109c83a 	sub	r4,r8,r4
 40172e0:	2080202c 	andhi	r2,r4,128
 40172e4:	1000a526 	beq	r2,zero,401757c <__subdf3+0x370>
 40172e8:	04c02034 	movhi	r19,128
 40172ec:	9cffffc4 	addi	r19,r19,-1
 40172f0:	24e6703a 	and	r19,r4,r19
 40172f4:	9800db26 	beq	r19,zero,4017664 <__subdf3+0x458>
 40172f8:	9809883a 	mov	r4,r19
 40172fc:	4017d600 	call	4017d60 <__clzsi2>
 4017300:	117ffe04 	addi	r5,r2,-8
 4017304:	01000804 	movi	r4,32
 4017308:	2149c83a 	sub	r4,r4,r5
 401730c:	8906d83a 	srl	r3,r17,r4
 4017310:	9948983a 	sll	r4,r19,r5
 4017314:	8962983a 	sll	r17,r17,r5
 4017318:	1908b03a 	or	r4,r3,r4
 401731c:	2c00cc16 	blt	r5,r16,4017650 <__subdf3+0x444>
 4017320:	2c0bc83a 	sub	r5,r5,r16
 4017324:	28c00044 	addi	r3,r5,1
 4017328:	18800808 	cmpgei	r2,r3,32
 401732c:	1001171e 	bne	r2,zero,401778c <__subdf3+0x580>
 4017330:	00800804 	movi	r2,32
 4017334:	10c5c83a 	sub	r2,r2,r3
 4017338:	88cad83a 	srl	r5,r17,r3
 401733c:	88a2983a 	sll	r17,r17,r2
 4017340:	2084983a 	sll	r2,r4,r2
 4017344:	20c8d83a 	srl	r4,r4,r3
 4017348:	8822c03a 	cmpne	r17,r17,zero
 401734c:	1144b03a 	or	r2,r2,r5
 4017350:	1462b03a 	or	r17,r2,r17
 4017354:	0021883a 	mov	r16,zero
 4017358:	888001cc 	andi	r2,r17,7
 401735c:	10000726 	beq	r2,zero,401737c <__subdf3+0x170>
 4017360:	888003cc 	andi	r2,r17,15
 4017364:	10800120 	cmpeqi	r2,r2,4
 4017368:	1000041e 	bne	r2,zero,401737c <__subdf3+0x170>
 401736c:	88c00104 	addi	r3,r17,4
 4017370:	1c63803a 	cmpltu	r17,r3,r17
 4017374:	2449883a 	add	r4,r4,r17
 4017378:	1823883a 	mov	r17,r3
 401737c:	2080202c 	andhi	r2,r4,128
 4017380:	10008026 	beq	r2,zero,4017584 <__subdf3+0x378>
 4017384:	81400044 	addi	r5,r16,1
 4017388:	2881ffe0 	cmpeqi	r2,r5,2047
 401738c:	2941ffcc 	andi	r5,r5,2047
 4017390:	1000921e 	bne	r2,zero,40175dc <__subdf3+0x3d0>
 4017394:	00bfe034 	movhi	r2,65408
 4017398:	10bfffc4 	addi	r2,r2,-1
 401739c:	2088703a 	and	r4,r4,r2
 40173a0:	2006927a 	slli	r3,r4,9
 40173a4:	8822d0fa 	srli	r17,r17,3
 40173a8:	2004977a 	slli	r2,r4,29
 40173ac:	1806d33a 	srli	r3,r3,12
 40173b0:	1444b03a 	or	r2,r2,r17
 40173b4:	280a953a 	slli	r5,r5,20
 40173b8:	94803fcc 	andi	r18,r18,255
 40173bc:	902497fa 	slli	r18,r18,31
 40173c0:	28c6b03a 	or	r3,r5,r3
 40173c4:	1c86b03a 	or	r3,r3,r18
 40173c8:	dfc00417 	ldw	ra,16(sp)
 40173cc:	dcc00317 	ldw	r19,12(sp)
 40173d0:	dc800217 	ldw	r18,8(sp)
 40173d4:	dc400117 	ldw	r17,4(sp)
 40173d8:	dc000017 	ldw	r16,0(sp)
 40173dc:	dec00504 	addi	sp,sp,20
 40173e0:	f800283a 	ret
 40173e4:	01402e0e 	bge	zero,r5,40174a0 <__subdf3+0x294>
 40173e8:	68005526 	beq	r13,zero,4017540 <__subdf3+0x334>
 40173ec:	8081ffd8 	cmpnei	r2,r16,2047
 40173f0:	10013b26 	beq	r2,zero,40178e0 <__subdf3+0x6d4>
 40173f4:	18c02034 	orhi	r3,r3,128
 40173f8:	28800e48 	cmpgei	r2,r5,57
 40173fc:	10006d1e 	bne	r2,zero,40175b4 <__subdf3+0x3a8>
 4017400:	28800808 	cmpgei	r2,r5,32
 4017404:	10010826 	beq	r2,zero,4017828 <__subdf3+0x61c>
 4017408:	2c7ff804 	addi	r17,r5,-32
 401740c:	29000820 	cmpeqi	r4,r5,32
 4017410:	1c44d83a 	srl	r2,r3,r17
 4017414:	2000041e 	bne	r4,zero,4017428 <__subdf3+0x21c>
 4017418:	01001004 	movi	r4,64
 401741c:	214bc83a 	sub	r5,r4,r5
 4017420:	1946983a 	sll	r3,r3,r5
 4017424:	50d4b03a 	or	r10,r10,r3
 4017428:	5022c03a 	cmpne	r17,r10,zero
 401742c:	88a2b03a 	or	r17,r17,r2
 4017430:	00006206 	br	40175bc <__subdf3+0x3b0>
 4017434:	1a98b03a 	or	r12,r3,r10
 4017438:	817e0044 	addi	r5,r16,-2047
 401743c:	6000161e 	bne	r12,zero,4017498 <__subdf3+0x28c>
 4017440:	3a40005c 	xori	r9,r7,1
 4017444:	12401626 	beq	r2,r9,40174a0 <__subdf3+0x294>
 4017448:	28002e26 	beq	r5,zero,4017504 <__subdf3+0x2f8>
 401744c:	6c0bc83a 	sub	r5,r13,r16
 4017450:	4825883a 	mov	r18,r9
 4017454:	80009e1e 	bne	r16,zero,40176d0 <__subdf3+0x4c4>
 4017458:	42c4b03a 	or	r2,r8,r11
 401745c:	10010926 	beq	r2,zero,4017884 <__subdf3+0x678>
 4017460:	28bfffc4 	addi	r2,r5,-1
 4017464:	10016826 	beq	r2,zero,4017a08 <__subdf3+0x7fc>
 4017468:	2941ffd8 	cmpnei	r5,r5,2047
 401746c:	28015f26 	beq	r5,zero,40179ec <__subdf3+0x7e0>
 4017470:	100b883a 	mov	r5,r2
 4017474:	00009906 	br	40176dc <__subdf3+0x4d0>
 4017478:	1a84b03a 	or	r2,r3,r10
 401747c:	1000b126 	beq	r2,zero,4017744 <__subdf3+0x538>
 4017480:	28bfffc4 	addi	r2,r5,-1
 4017484:	10011d26 	beq	r2,zero,40178fc <__subdf3+0x6f0>
 4017488:	2941ffd8 	cmpnei	r5,r5,2047
 401748c:	28011426 	beq	r5,zero,40178e0 <__subdf3+0x6d4>
 4017490:	100b883a 	mov	r5,r2
 4017494:	003f8106 	br	401729c <__subdf3+0x90>
 4017498:	3a403fcc 	andi	r9,r7,255
 401749c:	11ffea1e 	bne	r2,r7,4017448 <__subdf3+0x23c>
 40174a0:	28007c26 	beq	r5,zero,4017694 <__subdf3+0x488>
 40174a4:	6c0bc83a 	sub	r5,r13,r16
 40174a8:	8000d726 	beq	r16,zero,4017808 <__subdf3+0x5fc>
 40174ac:	6881ffd8 	cmpnei	r2,r13,2047
 40174b0:	10012626 	beq	r2,zero,401794c <__subdf3+0x740>
 40174b4:	42002034 	orhi	r8,r8,128
 40174b8:	28800e48 	cmpgei	r2,r5,57
 40174bc:	10012a1e 	bne	r2,zero,4017968 <__subdf3+0x75c>
 40174c0:	28800808 	cmpgei	r2,r5,32
 40174c4:	1001821e 	bne	r2,zero,4017ad0 <__subdf3+0x8c4>
 40174c8:	00800804 	movi	r2,32
 40174cc:	1145c83a 	sub	r2,r2,r5
 40174d0:	40a2983a 	sll	r17,r8,r2
 40174d4:	5948d83a 	srl	r4,r11,r5
 40174d8:	5884983a 	sll	r2,r11,r2
 40174dc:	4150d83a 	srl	r8,r8,r5
 40174e0:	8922b03a 	or	r17,r17,r4
 40174e4:	1004c03a 	cmpne	r2,r2,zero
 40174e8:	88a2b03a 	or	r17,r17,r2
 40174ec:	1a07883a 	add	r3,r3,r8
 40174f0:	8aa3883a 	add	r17,r17,r10
 40174f4:	8a89803a 	cmpltu	r4,r17,r10
 40174f8:	20c9883a 	add	r4,r4,r3
 40174fc:	6821883a 	mov	r16,r13
 4017500:	00003106 	br	40175c8 <__subdf3+0x3bc>
 4017504:	80800044 	addi	r2,r16,1
 4017508:	1081ff8c 	andi	r2,r2,2046
 401750c:	1000821e 	bne	r2,zero,4017718 <__subdf3+0x50c>
 4017510:	42ceb03a 	or	r7,r8,r11
 4017514:	1a84b03a 	or	r2,r3,r10
 4017518:	8000e11e 	bne	r16,zero,40178a0 <__subdf3+0x694>
 401751c:	38012a26 	beq	r7,zero,40179c8 <__subdf3+0x7bc>
 4017520:	1001461e 	bne	r2,zero,4017a3c <__subdf3+0x830>
 4017524:	4004977a 	slli	r2,r8,29
 4017528:	00c80034 	movhi	r3,8192
 401752c:	18ffffc4 	addi	r3,r3,-1
 4017530:	20c8703a 	and	r4,r4,r3
 4017534:	4010d0fa 	srli	r8,r8,3
 4017538:	1104b03a 	or	r2,r2,r4
 401753c:	00001806 	br	40175a0 <__subdf3+0x394>
 4017540:	1a84b03a 	or	r2,r3,r10
 4017544:	1000fa26 	beq	r2,zero,4017930 <__subdf3+0x724>
 4017548:	28bfffc4 	addi	r2,r5,-1
 401754c:	10000426 	beq	r2,zero,4017560 <__subdf3+0x354>
 4017550:	2941ffd8 	cmpnei	r5,r5,2047
 4017554:	28013226 	beq	r5,zero,4017a20 <__subdf3+0x814>
 4017558:	100b883a 	mov	r5,r2
 401755c:	003fa606 	br	40173f8 <__subdf3+0x1ec>
 4017560:	5aa3883a 	add	r17,r11,r10
 4017564:	40c9883a 	add	r4,r8,r3
 4017568:	8ad7803a 	cmpltu	r11,r17,r11
 401756c:	22c9883a 	add	r4,r4,r11
 4017570:	2080202c 	andhi	r2,r4,128
 4017574:	10007a1e 	bne	r2,zero,4017760 <__subdf3+0x554>
 4017578:	04000044 	movi	r16,1
 401757c:	888001cc 	andi	r2,r17,7
 4017580:	103f771e 	bne	r2,zero,4017360 <__subdf3+0x154>
 4017584:	8822d0fa 	srli	r17,r17,3
 4017588:	2004977a 	slli	r2,r4,29
 401758c:	2010d0fa 	srli	r8,r4,3
 4017590:	800b883a 	mov	r5,r16
 4017594:	8884b03a 	or	r2,r17,r2
 4017598:	28c1ffe0 	cmpeqi	r3,r5,2047
 401759c:	1800241e 	bne	r3,zero,4017630 <__subdf3+0x424>
 40175a0:	00c00434 	movhi	r3,16
 40175a4:	18ffffc4 	addi	r3,r3,-1
 40175a8:	40c6703a 	and	r3,r8,r3
 40175ac:	2941ffcc 	andi	r5,r5,2047
 40175b0:	003f8006 	br	40173b4 <__subdf3+0x1a8>
 40175b4:	1aa2b03a 	or	r17,r3,r10
 40175b8:	8822c03a 	cmpne	r17,r17,zero
 40175bc:	8ae3883a 	add	r17,r17,r11
 40175c0:	8ac9803a 	cmpltu	r4,r17,r11
 40175c4:	2209883a 	add	r4,r4,r8
 40175c8:	2080202c 	andhi	r2,r4,128
 40175cc:	103feb26 	beq	r2,zero,401757c <__subdf3+0x370>
 40175d0:	84000044 	addi	r16,r16,1
 40175d4:	8081ffe0 	cmpeqi	r2,r16,2047
 40175d8:	10006226 	beq	r2,zero,4017764 <__subdf3+0x558>
 40175dc:	0141ffc4 	movi	r5,2047
 40175e0:	0007883a 	mov	r3,zero
 40175e4:	0005883a 	mov	r2,zero
 40175e8:	003f7206 	br	40173b4 <__subdf3+0x1a8>
 40175ec:	400e977a 	slli	r7,r8,29
 40175f0:	4010d0fa 	srli	r8,r8,3
 40175f4:	1000ef26 	beq	r2,zero,40179b4 <__subdf3+0x7a8>
 40175f8:	01480034 	movhi	r5,8192
 40175fc:	297fffc4 	addi	r5,r5,-1
 4017600:	2144703a 	and	r2,r4,r5
 4017604:	4100022c 	andhi	r4,r8,8
 4017608:	11c4b03a 	or	r2,r2,r7
 401760c:	20000826 	beq	r4,zero,4017630 <__subdf3+0x424>
 4017610:	1808d0fa 	srli	r4,r3,3
 4017614:	21c0022c 	andhi	r7,r4,8
 4017618:	3800051e 	bne	r7,zero,4017630 <__subdf3+0x424>
 401761c:	1804977a 	slli	r2,r3,29
 4017620:	314c703a 	and	r6,r6,r5
 4017624:	4825883a 	mov	r18,r9
 4017628:	3084b03a 	or	r2,r6,r2
 401762c:	2011883a 	mov	r8,r4
 4017630:	1206b03a 	or	r3,r2,r8
 4017634:	18013e26 	beq	r3,zero,4017b30 <__subdf3+0x924>
 4017638:	01000434 	movhi	r4,16
 401763c:	40c00234 	orhi	r3,r8,8
 4017640:	213fffc4 	addi	r4,r4,-1
 4017644:	1906703a 	and	r3,r3,r4
 4017648:	0141ffc4 	movi	r5,2047
 401764c:	003f5906 	br	40173b4 <__subdf3+0x1a8>
 4017650:	00ffe034 	movhi	r3,65408
 4017654:	18ffffc4 	addi	r3,r3,-1
 4017658:	8161c83a 	sub	r16,r16,r5
 401765c:	20c8703a 	and	r4,r4,r3
 4017660:	003f3d06 	br	4017358 <__subdf3+0x14c>
 4017664:	8809883a 	mov	r4,r17
 4017668:	4017d600 	call	4017d60 <__clzsi2>
 401766c:	11400604 	addi	r5,r2,24
 4017670:	28c00808 	cmpgei	r3,r5,32
 4017674:	183f2326 	beq	r3,zero,4017304 <__subdf3+0xf8>
 4017678:	113ffe04 	addi	r4,r2,-8
 401767c:	8908983a 	sll	r4,r17,r4
 4017680:	0023883a 	mov	r17,zero
 4017684:	003f2506 	br	401731c <__subdf3+0x110>
 4017688:	1aa2b03a 	or	r17,r3,r10
 401768c:	8822c03a 	cmpne	r17,r17,zero
 4017690:	003f1006 	br	40172d4 <__subdf3+0xc8>
 4017694:	80800044 	addi	r2,r16,1
 4017698:	11c1ff8c 	andi	r7,r2,2046
 401769c:	38006d1e 	bne	r7,zero,4017854 <__subdf3+0x648>
 40176a0:	42c4b03a 	or	r2,r8,r11
 40176a4:	8000be1e 	bne	r16,zero,40179a0 <__subdf3+0x794>
 40176a8:	1000f726 	beq	r2,zero,4017a88 <__subdf3+0x87c>
 40176ac:	1a84b03a 	or	r2,r3,r10
 40176b0:	1000fc1e 	bne	r2,zero,4017aa4 <__subdf3+0x898>
 40176b4:	4006977a 	slli	r3,r8,29
 40176b8:	00880034 	movhi	r2,8192
 40176bc:	10bfffc4 	addi	r2,r2,-1
 40176c0:	2084703a 	and	r2,r4,r2
 40176c4:	4010d0fa 	srli	r8,r8,3
 40176c8:	10c4b03a 	or	r2,r2,r3
 40176cc:	003fb406 	br	40175a0 <__subdf3+0x394>
 40176d0:	6881ffd8 	cmpnei	r2,r13,2047
 40176d4:	10009d26 	beq	r2,zero,401794c <__subdf3+0x740>
 40176d8:	42002034 	orhi	r8,r8,128
 40176dc:	28800e48 	cmpgei	r2,r5,57
 40176e0:	1000421e 	bne	r2,zero,40177ec <__subdf3+0x5e0>
 40176e4:	28800808 	cmpgei	r2,r5,32
 40176e8:	1000a21e 	bne	r2,zero,4017974 <__subdf3+0x768>
 40176ec:	00800804 	movi	r2,32
 40176f0:	1145c83a 	sub	r2,r2,r5
 40176f4:	40a2983a 	sll	r17,r8,r2
 40176f8:	5948d83a 	srl	r4,r11,r5
 40176fc:	5896983a 	sll	r11,r11,r2
 4017700:	4150d83a 	srl	r8,r8,r5
 4017704:	8922b03a 	or	r17,r17,r4
 4017708:	5816c03a 	cmpne	r11,r11,zero
 401770c:	8ae2b03a 	or	r17,r17,r11
 4017710:	1a07c83a 	sub	r3,r3,r8
 4017714:	00003706 	br	40177f4 <__subdf3+0x5e8>
 4017718:	5aa3c83a 	sub	r17,r11,r10
 401771c:	40e7c83a 	sub	r19,r8,r3
 4017720:	5c49803a 	cmpltu	r4,r11,r17
 4017724:	9927c83a 	sub	r19,r19,r4
 4017728:	9880202c 	andhi	r2,r19,128
 401772c:	1000661e 	bne	r2,zero,40178c8 <__subdf3+0x6bc>
 4017730:	8cc4b03a 	or	r2,r17,r19
 4017734:	103eef1e 	bne	r2,zero,40172f4 <__subdf3+0xe8>
 4017738:	0011883a 	mov	r8,zero
 401773c:	0025883a 	mov	r18,zero
 4017740:	003f9706 	br	40175a0 <__subdf3+0x394>
 4017744:	4022977a 	slli	r17,r8,29
 4017748:	00880034 	movhi	r2,8192
 401774c:	10bfffc4 	addi	r2,r2,-1
 4017750:	2088703a 	and	r4,r4,r2
 4017754:	4010d0fa 	srli	r8,r8,3
 4017758:	2444b03a 	or	r2,r4,r17
 401775c:	003f8e06 	br	4017598 <__subdf3+0x38c>
 4017760:	04000084 	movi	r16,2
 4017764:	00bfe034 	movhi	r2,65408
 4017768:	10bfffc4 	addi	r2,r2,-1
 401776c:	8806d07a 	srli	r3,r17,1
 4017770:	2088703a 	and	r4,r4,r2
 4017774:	200497fa 	slli	r2,r4,31
 4017778:	8c40004c 	andi	r17,r17,1
 401777c:	1c62b03a 	or	r17,r3,r17
 4017780:	2008d07a 	srli	r4,r4,1
 4017784:	1462b03a 	or	r17,r2,r17
 4017788:	003ef306 	br	4017358 <__subdf3+0x14c>
 401778c:	297ff844 	addi	r5,r5,-31
 4017790:	18800820 	cmpeqi	r2,r3,32
 4017794:	214ad83a 	srl	r5,r4,r5
 4017798:	1000041e 	bne	r2,zero,40177ac <__subdf3+0x5a0>
 401779c:	00801004 	movi	r2,64
 40177a0:	10c7c83a 	sub	r3,r2,r3
 40177a4:	20c8983a 	sll	r4,r4,r3
 40177a8:	8922b03a 	or	r17,r17,r4
 40177ac:	8822c03a 	cmpne	r17,r17,zero
 40177b0:	8962b03a 	or	r17,r17,r5
 40177b4:	0009883a 	mov	r4,zero
 40177b8:	0021883a 	mov	r16,zero
 40177bc:	003f6f06 	br	401757c <__subdf3+0x370>
 40177c0:	2c7ff804 	addi	r17,r5,-32
 40177c4:	29000820 	cmpeqi	r4,r5,32
 40177c8:	1c44d83a 	srl	r2,r3,r17
 40177cc:	2000041e 	bne	r4,zero,40177e0 <__subdf3+0x5d4>
 40177d0:	01001004 	movi	r4,64
 40177d4:	214bc83a 	sub	r5,r4,r5
 40177d8:	1946983a 	sll	r3,r3,r5
 40177dc:	50d4b03a 	or	r10,r10,r3
 40177e0:	5022c03a 	cmpne	r17,r10,zero
 40177e4:	88a2b03a 	or	r17,r17,r2
 40177e8:	003eba06 	br	40172d4 <__subdf3+0xc8>
 40177ec:	42d0b03a 	or	r8,r8,r11
 40177f0:	4022c03a 	cmpne	r17,r8,zero
 40177f4:	5463c83a 	sub	r17,r10,r17
 40177f8:	5449803a 	cmpltu	r4,r10,r17
 40177fc:	1909c83a 	sub	r4,r3,r4
 4017800:	6821883a 	mov	r16,r13
 4017804:	003eb606 	br	40172e0 <__subdf3+0xd4>
 4017808:	42c4b03a 	or	r2,r8,r11
 401780c:	10009726 	beq	r2,zero,4017a6c <__subdf3+0x860>
 4017810:	28bfffc4 	addi	r2,r5,-1
 4017814:	1000b926 	beq	r2,zero,4017afc <__subdf3+0x8f0>
 4017818:	2941ffd8 	cmpnei	r5,r5,2047
 401781c:	28007326 	beq	r5,zero,40179ec <__subdf3+0x7e0>
 4017820:	100b883a 	mov	r5,r2
 4017824:	003f2406 	br	40174b8 <__subdf3+0x2ac>
 4017828:	00800804 	movi	r2,32
 401782c:	1145c83a 	sub	r2,r2,r5
 4017830:	18a2983a 	sll	r17,r3,r2
 4017834:	5148d83a 	srl	r4,r10,r5
 4017838:	5084983a 	sll	r2,r10,r2
 401783c:	1946d83a 	srl	r3,r3,r5
 4017840:	8922b03a 	or	r17,r17,r4
 4017844:	1004c03a 	cmpne	r2,r2,zero
 4017848:	88a2b03a 	or	r17,r17,r2
 401784c:	40d1883a 	add	r8,r8,r3
 4017850:	003f5a06 	br	40175bc <__subdf3+0x3b0>
 4017854:	1101ffe0 	cmpeqi	r4,r2,2047
 4017858:	203f601e 	bne	r4,zero,40175dc <__subdf3+0x3d0>
 401785c:	5a95883a 	add	r10,r11,r10
 4017860:	52d7803a 	cmpltu	r11,r10,r11
 4017864:	40c9883a 	add	r4,r8,r3
 4017868:	22c9883a 	add	r4,r4,r11
 401786c:	202297fa 	slli	r17,r4,31
 4017870:	5014d07a 	srli	r10,r10,1
 4017874:	2008d07a 	srli	r4,r4,1
 4017878:	1021883a 	mov	r16,r2
 401787c:	8aa2b03a 	or	r17,r17,r10
 4017880:	003f3e06 	br	401757c <__subdf3+0x370>
 4017884:	1808977a 	slli	r4,r3,29
 4017888:	00880034 	movhi	r2,8192
 401788c:	10bfffc4 	addi	r2,r2,-1
 4017890:	308c703a 	and	r6,r6,r2
 4017894:	1810d0fa 	srli	r8,r3,3
 4017898:	3104b03a 	or	r2,r6,r4
 401789c:	003f3e06 	br	4017598 <__subdf3+0x38c>
 40178a0:	383f521e 	bne	r7,zero,40175ec <__subdf3+0x3e0>
 40178a4:	10009d26 	beq	r2,zero,4017b1c <__subdf3+0x910>
 40178a8:	1808977a 	slli	r4,r3,29
 40178ac:	00880034 	movhi	r2,8192
 40178b0:	10bfffc4 	addi	r2,r2,-1
 40178b4:	3084703a 	and	r2,r6,r2
 40178b8:	1810d0fa 	srli	r8,r3,3
 40178bc:	1104b03a 	or	r2,r2,r4
 40178c0:	4825883a 	mov	r18,r9
 40178c4:	003f5a06 	br	4017630 <__subdf3+0x424>
 40178c8:	52e3c83a 	sub	r17,r10,r11
 40178cc:	1a09c83a 	sub	r4,r3,r8
 40178d0:	5467803a 	cmpltu	r19,r10,r17
 40178d4:	24e7c83a 	sub	r19,r4,r19
 40178d8:	4825883a 	mov	r18,r9
 40178dc:	003e8506 	br	40172f4 <__subdf3+0xe8>
 40178e0:	4022977a 	slli	r17,r8,29
 40178e4:	00880034 	movhi	r2,8192
 40178e8:	10bfffc4 	addi	r2,r2,-1
 40178ec:	2088703a 	and	r4,r4,r2
 40178f0:	4010d0fa 	srli	r8,r8,3
 40178f4:	2444b03a 	or	r2,r4,r17
 40178f8:	003f4d06 	br	4017630 <__subdf3+0x424>
 40178fc:	5aa3c83a 	sub	r17,r11,r10
 4017900:	40c9c83a 	sub	r4,r8,r3
 4017904:	5c57803a 	cmpltu	r11,r11,r17
 4017908:	22c9c83a 	sub	r4,r4,r11
 401790c:	04000044 	movi	r16,1
 4017910:	003e7306 	br	40172e0 <__subdf3+0xd4>
 4017914:	4004977a 	slli	r2,r8,29
 4017918:	00c80034 	movhi	r3,8192
 401791c:	18ffffc4 	addi	r3,r3,-1
 4017920:	20c8703a 	and	r4,r4,r3
 4017924:	4010d0fa 	srli	r8,r8,3
 4017928:	1104b03a 	or	r2,r2,r4
 401792c:	003f4006 	br	4017630 <__subdf3+0x424>
 4017930:	4004977a 	slli	r2,r8,29
 4017934:	00c80034 	movhi	r3,8192
 4017938:	18ffffc4 	addi	r3,r3,-1
 401793c:	20c8703a 	and	r4,r4,r3
 4017940:	4010d0fa 	srli	r8,r8,3
 4017944:	1104b03a 	or	r2,r2,r4
 4017948:	003f1306 	br	4017598 <__subdf3+0x38c>
 401794c:	1804977a 	slli	r2,r3,29
 4017950:	01080034 	movhi	r4,8192
 4017954:	213fffc4 	addi	r4,r4,-1
 4017958:	310c703a 	and	r6,r6,r4
 401795c:	1810d0fa 	srli	r8,r3,3
 4017960:	1184b03a 	or	r2,r2,r6
 4017964:	003f3206 	br	4017630 <__subdf3+0x424>
 4017968:	42d0b03a 	or	r8,r8,r11
 401796c:	4022c03a 	cmpne	r17,r8,zero
 4017970:	003edf06 	br	40174f0 <__subdf3+0x2e4>
 4017974:	2c7ff804 	addi	r17,r5,-32
 4017978:	29000820 	cmpeqi	r4,r5,32
 401797c:	4444d83a 	srl	r2,r8,r17
 4017980:	2000041e 	bne	r4,zero,4017994 <__subdf3+0x788>
 4017984:	01001004 	movi	r4,64
 4017988:	214bc83a 	sub	r5,r4,r5
 401798c:	4150983a 	sll	r8,r8,r5
 4017990:	5a16b03a 	or	r11,r11,r8
 4017994:	5822c03a 	cmpne	r17,r11,zero
 4017998:	88a2b03a 	or	r17,r17,r2
 401799c:	003f9506 	br	40177f4 <__subdf3+0x5e8>
 40179a0:	103fea26 	beq	r2,zero,401794c <__subdf3+0x740>
 40179a4:	1a94b03a 	or	r10,r3,r10
 40179a8:	400e977a 	slli	r7,r8,29
 40179ac:	4010d0fa 	srli	r8,r8,3
 40179b0:	503f111e 	bne	r10,zero,40175f8 <__subdf3+0x3ec>
 40179b4:	00880034 	movhi	r2,8192
 40179b8:	10bfffc4 	addi	r2,r2,-1
 40179bc:	2084703a 	and	r2,r4,r2
 40179c0:	11c4b03a 	or	r2,r2,r7
 40179c4:	003f1a06 	br	4017630 <__subdf3+0x424>
 40179c8:	103f5b26 	beq	r2,zero,4017738 <__subdf3+0x52c>
 40179cc:	1804977a 	slli	r2,r3,29
 40179d0:	01080034 	movhi	r4,8192
 40179d4:	213fffc4 	addi	r4,r4,-1
 40179d8:	310c703a 	and	r6,r6,r4
 40179dc:	1810d0fa 	srli	r8,r3,3
 40179e0:	1184b03a 	or	r2,r2,r6
 40179e4:	4825883a 	mov	r18,r9
 40179e8:	003eed06 	br	40175a0 <__subdf3+0x394>
 40179ec:	1808977a 	slli	r4,r3,29
 40179f0:	00880034 	movhi	r2,8192
 40179f4:	10bfffc4 	addi	r2,r2,-1
 40179f8:	3084703a 	and	r2,r6,r2
 40179fc:	1810d0fa 	srli	r8,r3,3
 4017a00:	1104b03a 	or	r2,r2,r4
 4017a04:	003f0a06 	br	4017630 <__subdf3+0x424>
 4017a08:	52e3c83a 	sub	r17,r10,r11
 4017a0c:	1a09c83a 	sub	r4,r3,r8
 4017a10:	5455803a 	cmpltu	r10,r10,r17
 4017a14:	2289c83a 	sub	r4,r4,r10
 4017a18:	04000044 	movi	r16,1
 4017a1c:	003e3006 	br	40172e0 <__subdf3+0xd4>
 4017a20:	4006977a 	slli	r3,r8,29
 4017a24:	00880034 	movhi	r2,8192
 4017a28:	10bfffc4 	addi	r2,r2,-1
 4017a2c:	2084703a 	and	r2,r4,r2
 4017a30:	4010d0fa 	srli	r8,r8,3
 4017a34:	10c4b03a 	or	r2,r2,r3
 4017a38:	003efd06 	br	4017630 <__subdf3+0x424>
 4017a3c:	5aa3c83a 	sub	r17,r11,r10
 4017a40:	5c45803a 	cmpltu	r2,r11,r17
 4017a44:	40c9c83a 	sub	r4,r8,r3
 4017a48:	2089c83a 	sub	r4,r4,r2
 4017a4c:	2080202c 	andhi	r2,r4,128
 4017a50:	10002f26 	beq	r2,zero,4017b10 <__subdf3+0x904>
 4017a54:	52e3c83a 	sub	r17,r10,r11
 4017a58:	1a09c83a 	sub	r4,r3,r8
 4017a5c:	5455803a 	cmpltu	r10,r10,r17
 4017a60:	2289c83a 	sub	r4,r4,r10
 4017a64:	4825883a 	mov	r18,r9
 4017a68:	003e3b06 	br	4017358 <__subdf3+0x14c>
 4017a6c:	1808977a 	slli	r4,r3,29
 4017a70:	00880034 	movhi	r2,8192
 4017a74:	10bfffc4 	addi	r2,r2,-1
 4017a78:	3084703a 	and	r2,r6,r2
 4017a7c:	1810d0fa 	srli	r8,r3,3
 4017a80:	1104b03a 	or	r2,r2,r4
 4017a84:	003ec406 	br	4017598 <__subdf3+0x38c>
 4017a88:	1808977a 	slli	r4,r3,29
 4017a8c:	00880034 	movhi	r2,8192
 4017a90:	10bfffc4 	addi	r2,r2,-1
 4017a94:	3084703a 	and	r2,r6,r2
 4017a98:	1810d0fa 	srli	r8,r3,3
 4017a9c:	1104b03a 	or	r2,r2,r4
 4017aa0:	003ebf06 	br	40175a0 <__subdf3+0x394>
 4017aa4:	5aa3883a 	add	r17,r11,r10
 4017aa8:	40c9883a 	add	r4,r8,r3
 4017aac:	8ad7803a 	cmpltu	r11,r17,r11
 4017ab0:	22c9883a 	add	r4,r4,r11
 4017ab4:	2080202c 	andhi	r2,r4,128
 4017ab8:	103eb026 	beq	r2,zero,401757c <__subdf3+0x370>
 4017abc:	00bfe034 	movhi	r2,65408
 4017ac0:	10bfffc4 	addi	r2,r2,-1
 4017ac4:	2088703a 	and	r4,r4,r2
 4017ac8:	04000044 	movi	r16,1
 4017acc:	003eab06 	br	401757c <__subdf3+0x370>
 4017ad0:	28bff804 	addi	r2,r5,-32
 4017ad4:	29000820 	cmpeqi	r4,r5,32
 4017ad8:	4084d83a 	srl	r2,r8,r2
 4017adc:	2000041e 	bne	r4,zero,4017af0 <__subdf3+0x8e4>
 4017ae0:	01001004 	movi	r4,64
 4017ae4:	214bc83a 	sub	r5,r4,r5
 4017ae8:	4150983a 	sll	r8,r8,r5
 4017aec:	5a16b03a 	or	r11,r11,r8
 4017af0:	5822c03a 	cmpne	r17,r11,zero
 4017af4:	88a2b03a 	or	r17,r17,r2
 4017af8:	003e7d06 	br	40174f0 <__subdf3+0x2e4>
 4017afc:	5aa3883a 	add	r17,r11,r10
 4017b00:	40c9883a 	add	r4,r8,r3
 4017b04:	8a95803a 	cmpltu	r10,r17,r10
 4017b08:	2289883a 	add	r4,r4,r10
 4017b0c:	003e9806 	br	4017570 <__subdf3+0x364>
 4017b10:	8904b03a 	or	r2,r17,r4
 4017b14:	103f0826 	beq	r2,zero,4017738 <__subdf3+0x52c>
 4017b18:	003e9806 	br	401757c <__subdf3+0x370>
 4017b1c:	02000434 	movhi	r8,16
 4017b20:	423fffc4 	addi	r8,r8,-1
 4017b24:	0025883a 	mov	r18,zero
 4017b28:	00bfffc4 	movi	r2,-1
 4017b2c:	003ec206 	br	4017638 <__subdf3+0x42c>
 4017b30:	0005883a 	mov	r2,zero
 4017b34:	0141ffc4 	movi	r5,2047
 4017b38:	0007883a 	mov	r3,zero
 4017b3c:	003e1d06 	br	40173b4 <__subdf3+0x1a8>

04017b40 <__unorddf2>:
 4017b40:	2806d53a 	srli	r3,r5,20
 4017b44:	3810d53a 	srli	r8,r7,20
 4017b48:	02400434 	movhi	r9,16
 4017b4c:	18c1ffcc 	andi	r3,r3,2047
 4017b50:	4a7fffc4 	addi	r9,r9,-1
 4017b54:	18c1ffd8 	cmpnei	r3,r3,2047
 4017b58:	2a4a703a 	and	r5,r5,r9
 4017b5c:	3a4e703a 	and	r7,r7,r9
 4017b60:	4201ffcc 	andi	r8,r8,2047
 4017b64:	18000426 	beq	r3,zero,4017b78 <__unorddf2+0x38>
 4017b68:	4201ffd8 	cmpnei	r8,r8,2047
 4017b6c:	40000626 	beq	r8,zero,4017b88 <__unorddf2+0x48>
 4017b70:	0005883a 	mov	r2,zero
 4017b74:	f800283a 	ret
 4017b78:	214ab03a 	or	r5,r4,r5
 4017b7c:	283ffa26 	beq	r5,zero,4017b68 <__unorddf2+0x28>
 4017b80:	00800044 	movi	r2,1
 4017b84:	f800283a 	ret
 4017b88:	398eb03a 	or	r7,r7,r6
 4017b8c:	3804c03a 	cmpne	r2,r7,zero
 4017b90:	f800283a 	ret

04017b94 <__fixdfsi>:
 4017b94:	2806d53a 	srli	r3,r5,20
 4017b98:	01800434 	movhi	r6,16
 4017b9c:	31bfffc4 	addi	r6,r6,-1
 4017ba0:	18c1ffcc 	andi	r3,r3,2047
 4017ba4:	19c0ffd0 	cmplti	r7,r3,1023
 4017ba8:	2810d7fa 	srli	r8,r5,31
 4017bac:	298a703a 	and	r5,r5,r6
 4017bb0:	3800061e 	bne	r7,zero,4017bcc <__fixdfsi+0x38>
 4017bb4:	18810790 	cmplti	r2,r3,1054
 4017bb8:	1000061e 	bne	r2,zero,4017bd4 <__fixdfsi+0x40>
 4017bbc:	00a00034 	movhi	r2,32768
 4017bc0:	10bfffc4 	addi	r2,r2,-1
 4017bc4:	4085883a 	add	r2,r8,r2
 4017bc8:	f800283a 	ret
 4017bcc:	0005883a 	mov	r2,zero
 4017bd0:	f800283a 	ret
 4017bd4:	01810cc4 	movi	r6,1075
 4017bd8:	30cdc83a 	sub	r6,r6,r3
 4017bdc:	30800808 	cmpgei	r2,r6,32
 4017be0:	29400434 	orhi	r5,r5,16
 4017be4:	1000071e 	bne	r2,zero,4017c04 <__fixdfsi+0x70>
 4017be8:	18befb44 	addi	r2,r3,-1043
 4017bec:	2884983a 	sll	r2,r5,r2
 4017bf0:	2188d83a 	srl	r4,r4,r6
 4017bf4:	1104b03a 	or	r2,r2,r4
 4017bf8:	403ff526 	beq	r8,zero,4017bd0 <__fixdfsi+0x3c>
 4017bfc:	0085c83a 	sub	r2,zero,r2
 4017c00:	f800283a 	ret
 4017c04:	008104c4 	movi	r2,1043
 4017c08:	10c5c83a 	sub	r2,r2,r3
 4017c0c:	2884d83a 	srl	r2,r5,r2
 4017c10:	003ff906 	br	4017bf8 <__fixdfsi+0x64>

04017c14 <__floatsidf>:
 4017c14:	defffd04 	addi	sp,sp,-12
 4017c18:	dfc00215 	stw	ra,8(sp)
 4017c1c:	dc400115 	stw	r17,4(sp)
 4017c20:	dc000015 	stw	r16,0(sp)
 4017c24:	20001326 	beq	r4,zero,4017c74 <__floatsidf+0x60>
 4017c28:	2022d7fa 	srli	r17,r4,31
 4017c2c:	2021883a 	mov	r16,r4
 4017c30:	20002516 	blt	r4,zero,4017cc8 <__floatsidf+0xb4>
 4017c34:	8009883a 	mov	r4,r16
 4017c38:	4017d600 	call	4017d60 <__clzsi2>
 4017c3c:	01410784 	movi	r5,1054
 4017c40:	288bc83a 	sub	r5,r5,r2
 4017c44:	10c002c8 	cmpgei	r3,r2,11
 4017c48:	2941ffcc 	andi	r5,r5,2047
 4017c4c:	1800171e 	bne	r3,zero,4017cac <__floatsidf+0x98>
 4017c50:	00c002c4 	movi	r3,11
 4017c54:	1887c83a 	sub	r3,r3,r2
 4017c58:	80c6d83a 	srl	r3,r16,r3
 4017c5c:	01000434 	movhi	r4,16
 4017c60:	10800544 	addi	r2,r2,21
 4017c64:	213fffc4 	addi	r4,r4,-1
 4017c68:	8084983a 	sll	r2,r16,r2
 4017c6c:	1906703a 	and	r3,r3,r4
 4017c70:	00000406 	br	4017c84 <__floatsidf+0x70>
 4017c74:	0023883a 	mov	r17,zero
 4017c78:	000b883a 	mov	r5,zero
 4017c7c:	0007883a 	mov	r3,zero
 4017c80:	0005883a 	mov	r2,zero
 4017c84:	280a953a 	slli	r5,r5,20
 4017c88:	8c403fcc 	andi	r17,r17,255
 4017c8c:	882297fa 	slli	r17,r17,31
 4017c90:	28c6b03a 	or	r3,r5,r3
 4017c94:	1c46b03a 	or	r3,r3,r17
 4017c98:	dfc00217 	ldw	ra,8(sp)
 4017c9c:	dc400117 	ldw	r17,4(sp)
 4017ca0:	dc000017 	ldw	r16,0(sp)
 4017ca4:	dec00304 	addi	sp,sp,12
 4017ca8:	f800283a 	ret
 4017cac:	10bffd44 	addi	r2,r2,-11
 4017cb0:	8086983a 	sll	r3,r16,r2
 4017cb4:	00800434 	movhi	r2,16
 4017cb8:	10bfffc4 	addi	r2,r2,-1
 4017cbc:	1886703a 	and	r3,r3,r2
 4017cc0:	0005883a 	mov	r2,zero
 4017cc4:	003fef06 	br	4017c84 <__floatsidf+0x70>
 4017cc8:	0121c83a 	sub	r16,zero,r4
 4017ccc:	003fd906 	br	4017c34 <__floatsidf+0x20>

04017cd0 <__floatunsidf>:
 4017cd0:	defffe04 	addi	sp,sp,-8
 4017cd4:	dc000015 	stw	r16,0(sp)
 4017cd8:	dfc00115 	stw	ra,4(sp)
 4017cdc:	2021883a 	mov	r16,r4
 4017ce0:	20000f26 	beq	r4,zero,4017d20 <__floatunsidf+0x50>
 4017ce4:	4017d600 	call	4017d60 <__clzsi2>
 4017ce8:	00c10784 	movi	r3,1054
 4017cec:	1887c83a 	sub	r3,r3,r2
 4017cf0:	110002c8 	cmpgei	r4,r2,11
 4017cf4:	18c1ffcc 	andi	r3,r3,2047
 4017cf8:	2000121e 	bne	r4,zero,4017d44 <__floatunsidf+0x74>
 4017cfc:	014002c4 	movi	r5,11
 4017d00:	288bc83a 	sub	r5,r5,r2
 4017d04:	814ad83a 	srl	r5,r16,r5
 4017d08:	01000434 	movhi	r4,16
 4017d0c:	10800544 	addi	r2,r2,21
 4017d10:	213fffc4 	addi	r4,r4,-1
 4017d14:	80a0983a 	sll	r16,r16,r2
 4017d18:	290a703a 	and	r5,r5,r4
 4017d1c:	00000206 	br	4017d28 <__floatunsidf+0x58>
 4017d20:	0007883a 	mov	r3,zero
 4017d24:	000b883a 	mov	r5,zero
 4017d28:	1806953a 	slli	r3,r3,20
 4017d2c:	8005883a 	mov	r2,r16
 4017d30:	1946b03a 	or	r3,r3,r5
 4017d34:	dfc00117 	ldw	ra,4(sp)
 4017d38:	dc000017 	ldw	r16,0(sp)
 4017d3c:	dec00204 	addi	sp,sp,8
 4017d40:	f800283a 	ret
 4017d44:	10bffd44 	addi	r2,r2,-11
 4017d48:	808a983a 	sll	r5,r16,r2
 4017d4c:	00800434 	movhi	r2,16
 4017d50:	10bfffc4 	addi	r2,r2,-1
 4017d54:	288a703a 	and	r5,r5,r2
 4017d58:	0021883a 	mov	r16,zero
 4017d5c:	003ff206 	br	4017d28 <__floatunsidf+0x58>

04017d60 <__clzsi2>:
 4017d60:	00bfffd4 	movui	r2,65535
 4017d64:	11000436 	bltu	r2,r4,4017d78 <__clzsi2+0x18>
 4017d68:	20804030 	cmpltui	r2,r4,256
 4017d6c:	10000e26 	beq	r2,zero,4017da8 <__clzsi2+0x48>
 4017d70:	01400804 	movi	r5,32
 4017d74:	00000406 	br	4017d88 <__clzsi2+0x28>
 4017d78:	00804034 	movhi	r2,256
 4017d7c:	20800736 	bltu	r4,r2,4017d9c <__clzsi2+0x3c>
 4017d80:	2008d63a 	srli	r4,r4,24
 4017d84:	01400204 	movi	r5,8
 4017d88:	00c100b4 	movhi	r3,1026
 4017d8c:	20c7883a 	add	r3,r4,r3
 4017d90:	18ac7c03 	ldbu	r2,-19984(r3)
 4017d94:	2885c83a 	sub	r2,r5,r2
 4017d98:	f800283a 	ret
 4017d9c:	2008d43a 	srli	r4,r4,16
 4017da0:	01400404 	movi	r5,16
 4017da4:	003ff806 	br	4017d88 <__clzsi2+0x28>
 4017da8:	2008d23a 	srli	r4,r4,8
 4017dac:	01400604 	movi	r5,24
 4017db0:	003ff506 	br	4017d88 <__clzsi2+0x28>

04017db4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 4017db4:	defffe04 	addi	sp,sp,-8
 4017db8:	dfc00115 	stw	ra,4(sp)
 4017dbc:	df000015 	stw	fp,0(sp)
 4017dc0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 4017dc4:	d0a00a17 	ldw	r2,-32728(gp)
 4017dc8:	10000326 	beq	r2,zero,4017dd8 <alt_get_errno+0x24>
 4017dcc:	d0a00a17 	ldw	r2,-32728(gp)
 4017dd0:	103ee83a 	callr	r2
 4017dd4:	00000106 	br	4017ddc <alt_get_errno+0x28>
 4017dd8:	d0a72904 	addi	r2,gp,-25436
}
 4017ddc:	e037883a 	mov	sp,fp
 4017de0:	dfc00117 	ldw	ra,4(sp)
 4017de4:	df000017 	ldw	fp,0(sp)
 4017de8:	dec00204 	addi	sp,sp,8
 4017dec:	f800283a 	ret

04017df0 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
 4017df0:	defffb04 	addi	sp,sp,-20
 4017df4:	dfc00415 	stw	ra,16(sp)
 4017df8:	df000315 	stw	fp,12(sp)
 4017dfc:	df000304 	addi	fp,sp,12
 4017e00:	e13ffd15 	stw	r4,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
 4017e04:	e0bffd17 	ldw	r2,-12(fp)
 4017e08:	10000916 	blt	r2,zero,4017e30 <close+0x40>
 4017e0c:	e0fffd17 	ldw	r3,-12(fp)
 4017e10:	1805883a 	mov	r2,r3
 4017e14:	1085883a 	add	r2,r2,r2
 4017e18:	10c5883a 	add	r2,r2,r3
 4017e1c:	100490ba 	slli	r2,r2,2
 4017e20:	00c100b4 	movhi	r3,1026
 4017e24:	18ef3f04 	addi	r3,r3,-17156
 4017e28:	10c5883a 	add	r2,r2,r3
 4017e2c:	00000106 	br	4017e34 <close+0x44>
 4017e30:	0005883a 	mov	r2,zero
 4017e34:	e0bfff15 	stw	r2,-4(fp)

  if (fd)
 4017e38:	e0bfff17 	ldw	r2,-4(fp)
 4017e3c:	10001926 	beq	r2,zero,4017ea4 <close+0xb4>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
 4017e40:	e0bfff17 	ldw	r2,-4(fp)
 4017e44:	10800017 	ldw	r2,0(r2)
 4017e48:	10800417 	ldw	r2,16(r2)
 4017e4c:	10000626 	beq	r2,zero,4017e68 <close+0x78>
 4017e50:	e0bfff17 	ldw	r2,-4(fp)
 4017e54:	10800017 	ldw	r2,0(r2)
 4017e58:	10800417 	ldw	r2,16(r2)
 4017e5c:	e13fff17 	ldw	r4,-4(fp)
 4017e60:	103ee83a 	callr	r2
 4017e64:	00000106 	br	4017e6c <close+0x7c>
 4017e68:	0005883a 	mov	r2,zero
 4017e6c:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
 4017e70:	e13ffd17 	ldw	r4,-12(fp)
 4017e74:	40189440 	call	4018944 <alt_release_fd>
    if (rval < 0)
 4017e78:	e0bffe17 	ldw	r2,-8(fp)
 4017e7c:	1000070e 	bge	r2,zero,4017e9c <close+0xac>
    {
      ALT_ERRNO = -rval;
 4017e80:	4017db40 	call	4017db4 <alt_get_errno>
 4017e84:	1007883a 	mov	r3,r2
 4017e88:	e0bffe17 	ldw	r2,-8(fp)
 4017e8c:	0085c83a 	sub	r2,zero,r2
 4017e90:	18800015 	stw	r2,0(r3)
      return -1;
 4017e94:	00bfffc4 	movi	r2,-1
 4017e98:	00000706 	br	4017eb8 <close+0xc8>
    }
    return 0;
 4017e9c:	0005883a 	mov	r2,zero
 4017ea0:	00000506 	br	4017eb8 <close+0xc8>
  }
  else
  {
    ALT_ERRNO = EBADFD;
 4017ea4:	4017db40 	call	4017db4 <alt_get_errno>
 4017ea8:	1007883a 	mov	r3,r2
 4017eac:	00801444 	movi	r2,81
 4017eb0:	18800015 	stw	r2,0(r3)
    return -1;
 4017eb4:	00bfffc4 	movi	r2,-1
  }
}
 4017eb8:	e037883a 	mov	sp,fp
 4017ebc:	dfc00117 	ldw	ra,4(sp)
 4017ec0:	df000017 	ldw	fp,0(sp)
 4017ec4:	dec00204 	addi	sp,sp,8
 4017ec8:	f800283a 	ret

04017ecc <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
 4017ecc:	defffc04 	addi	sp,sp,-16
 4017ed0:	df000315 	stw	fp,12(sp)
 4017ed4:	df000304 	addi	fp,sp,12
 4017ed8:	e13fff15 	stw	r4,-4(fp)
 4017edc:	e17ffe15 	stw	r5,-8(fp)
 4017ee0:	e1bffd15 	stw	r6,-12(fp)
  return len;
 4017ee4:	e0bffd17 	ldw	r2,-12(fp)
}
 4017ee8:	e037883a 	mov	sp,fp
 4017eec:	df000017 	ldw	fp,0(sp)
 4017ef0:	dec00104 	addi	sp,sp,4
 4017ef4:	f800283a 	ret

04017ef8 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
 4017ef8:	defffd04 	addi	sp,sp,-12
 4017efc:	df000215 	stw	fp,8(sp)
 4017f00:	df000204 	addi	fp,sp,8
 4017f04:	e13ffe15 	stw	r4,-8(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
 4017f08:	0001883a 	nop
 4017f0c:	e0bffe17 	ldw	r2,-8(fp)
 4017f10:	e0bfff15 	stw	r2,-4(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
 4017f14:	e0bfff17 	ldw	r2,-4(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
 4017f18:	10000226 	beq	r2,zero,4017f24 <_exit+0x2c>
    ALT_SIM_FAIL();
 4017f1c:	002af070 	cmpltui	zero,zero,43969
  } else {
    ALT_SIM_PASS();
  }
#endif /* DEBUG_STUB */
}
 4017f20:	00000106 	br	4017f28 <_exit+0x30>
    ALT_SIM_PASS();
 4017f24:	002af0b0 	cmpltui	zero,zero,43970
}
 4017f28:	0001883a 	nop
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
 4017f2c:	003fff06 	br	4017f2c <_exit+0x34>

04017f30 <alt_get_errno>:
{
 4017f30:	defffe04 	addi	sp,sp,-8
 4017f34:	dfc00115 	stw	ra,4(sp)
 4017f38:	df000015 	stw	fp,0(sp)
 4017f3c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 4017f40:	d0a00a17 	ldw	r2,-32728(gp)
 4017f44:	10000326 	beq	r2,zero,4017f54 <alt_get_errno+0x24>
 4017f48:	d0a00a17 	ldw	r2,-32728(gp)
 4017f4c:	103ee83a 	callr	r2
 4017f50:	00000106 	br	4017f58 <alt_get_errno+0x28>
 4017f54:	d0a72904 	addi	r2,gp,-25436
}
 4017f58:	e037883a 	mov	sp,fp
 4017f5c:	dfc00117 	ldw	ra,4(sp)
 4017f60:	df000017 	ldw	fp,0(sp)
 4017f64:	dec00204 	addi	sp,sp,8
 4017f68:	f800283a 	ret

04017f6c <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
 4017f6c:	defffb04 	addi	sp,sp,-20
 4017f70:	dfc00415 	stw	ra,16(sp)
 4017f74:	df000315 	stw	fp,12(sp)
 4017f78:	df000304 	addi	fp,sp,12
 4017f7c:	e13ffe15 	stw	r4,-8(fp)
 4017f80:	e17ffd15 	stw	r5,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 4017f84:	e0bffe17 	ldw	r2,-8(fp)
 4017f88:	10000916 	blt	r2,zero,4017fb0 <fstat+0x44>
 4017f8c:	e0fffe17 	ldw	r3,-8(fp)
 4017f90:	1805883a 	mov	r2,r3
 4017f94:	1085883a 	add	r2,r2,r2
 4017f98:	10c5883a 	add	r2,r2,r3
 4017f9c:	100490ba 	slli	r2,r2,2
 4017fa0:	00c100b4 	movhi	r3,1026
 4017fa4:	18ef3f04 	addi	r3,r3,-17156
 4017fa8:	10c5883a 	add	r2,r2,r3
 4017fac:	00000106 	br	4017fb4 <fstat+0x48>
 4017fb0:	0005883a 	mov	r2,zero
 4017fb4:	e0bfff15 	stw	r2,-4(fp)
  
  if (fd)
 4017fb8:	e0bfff17 	ldw	r2,-4(fp)
 4017fbc:	10001026 	beq	r2,zero,4018000 <fstat+0x94>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
 4017fc0:	e0bfff17 	ldw	r2,-4(fp)
 4017fc4:	10800017 	ldw	r2,0(r2)
 4017fc8:	10800817 	ldw	r2,32(r2)
 4017fcc:	10000726 	beq	r2,zero,4017fec <fstat+0x80>
    {
      return fd->dev->fstat(fd, st);
 4017fd0:	e0bfff17 	ldw	r2,-4(fp)
 4017fd4:	10800017 	ldw	r2,0(r2)
 4017fd8:	10800817 	ldw	r2,32(r2)
 4017fdc:	e17ffd17 	ldw	r5,-12(fp)
 4017fe0:	e13fff17 	ldw	r4,-4(fp)
 4017fe4:	103ee83a 	callr	r2
 4017fe8:	00000a06 	br	4018014 <fstat+0xa8>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
 4017fec:	e0bffd17 	ldw	r2,-12(fp)
 4017ff0:	00c80004 	movi	r3,8192
 4017ff4:	10c00115 	stw	r3,4(r2)
      return 0;
 4017ff8:	0005883a 	mov	r2,zero
 4017ffc:	00000506 	br	4018014 <fstat+0xa8>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 4018000:	4017f300 	call	4017f30 <alt_get_errno>
 4018004:	1007883a 	mov	r3,r2
 4018008:	00801444 	movi	r2,81
 401800c:	18800015 	stw	r2,0(r3)
    return -1;
 4018010:	00bfffc4 	movi	r2,-1
  }
}
 4018014:	e037883a 	mov	sp,fp
 4018018:	dfc00117 	ldw	ra,4(sp)
 401801c:	df000017 	ldw	fp,0(sp)
 4018020:	dec00204 	addi	sp,sp,8
 4018024:	f800283a 	ret

04018028 <getpid>:
 *
 * ALT_GETPID is mapped onto the getpid() system call in alt_syscall.h
 */
 
int ALT_GETPID (void)
{
 4018028:	deffff04 	addi	sp,sp,-4
 401802c:	df000015 	stw	fp,0(sp)
 4018030:	d839883a 	mov	fp,sp
  return 0;
 4018034:	0005883a 	mov	r2,zero
}
 4018038:	e037883a 	mov	sp,fp
 401803c:	df000017 	ldw	fp,0(sp)
 4018040:	dec00104 	addi	sp,sp,4
 4018044:	f800283a 	ret

04018048 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 4018048:	defff904 	addi	sp,sp,-28
 401804c:	dfc00615 	stw	ra,24(sp)
 4018050:	df000515 	stw	fp,20(sp)
 4018054:	df000504 	addi	fp,sp,20
 4018058:	e13fff15 	stw	r4,-4(fp)
 401805c:	e17ffe15 	stw	r5,-8(fp)
 4018060:	e1bffd15 	stw	r6,-12(fp)
 4018064:	e1fffc15 	stw	r7,-16(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
 4018068:	e0800217 	ldw	r2,8(fp)
 401806c:	d8800015 	stw	r2,0(sp)
 4018070:	e1fffc17 	ldw	r7,-16(fp)
 4018074:	e1bffd17 	ldw	r6,-12(fp)
 4018078:	e17ffe17 	ldw	r5,-8(fp)
 401807c:	e13fff17 	ldw	r4,-4(fp)
 4018080:	40181f80 	call	40181f8 <alt_iic_isr_register>
}  
 4018084:	e037883a 	mov	sp,fp
 4018088:	dfc00117 	ldw	ra,4(sp)
 401808c:	df000017 	ldw	fp,0(sp)
 4018090:	dec00204 	addi	sp,sp,8
 4018094:	f800283a 	ret

04018098 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
 4018098:	defff904 	addi	sp,sp,-28
 401809c:	df000615 	stw	fp,24(sp)
 40180a0:	df000604 	addi	fp,sp,24
 40180a4:	e13ffb15 	stw	r4,-20(fp)
 40180a8:	e17ffa15 	stw	r5,-24(fp)
 40180ac:	e0bffa17 	ldw	r2,-24(fp)
 40180b0:	e0bfff15 	stw	r2,-4(fp)
  NIOS2_READ_STATUS (context);
 40180b4:	0005303a 	rdctl	r2,status
 40180b8:	e0bffe15 	stw	r2,-8(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 40180bc:	e0fffe17 	ldw	r3,-8(fp)
 40180c0:	00bfff84 	movi	r2,-2
 40180c4:	1884703a 	and	r2,r3,r2
 40180c8:	1001703a 	wrctl	status,r2
  return context;
 40180cc:	e0bffe17 	ldw	r2,-8(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 40180d0:	e0bffd15 	stw	r2,-12(fp)

  alt_irq_active |= (1 << id);
 40180d4:	00c00044 	movi	r3,1
 40180d8:	e0bfff17 	ldw	r2,-4(fp)
 40180dc:	1884983a 	sll	r2,r3,r2
 40180e0:	1007883a 	mov	r3,r2
 40180e4:	d0a72a17 	ldw	r2,-25432(gp)
 40180e8:	1884b03a 	or	r2,r3,r2
 40180ec:	d0a72a15 	stw	r2,-25432(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 40180f0:	d0a72a17 	ldw	r2,-25432(gp)
 40180f4:	100170fa 	wrctl	ienable,r2
 40180f8:	e0bffd17 	ldw	r2,-12(fp)
 40180fc:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context);
 4018100:	e0bffc17 	ldw	r2,-16(fp)
 4018104:	1001703a 	wrctl	status,r2
}
 4018108:	0001883a 	nop

  alt_irq_enable_all(status);

  return 0;
 401810c:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
}
 4018110:	e037883a 	mov	sp,fp
 4018114:	df000017 	ldw	fp,0(sp)
 4018118:	dec00104 	addi	sp,sp,4
 401811c:	f800283a 	ret

04018120 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
 4018120:	defff904 	addi	sp,sp,-28
 4018124:	df000615 	stw	fp,24(sp)
 4018128:	df000604 	addi	fp,sp,24
 401812c:	e13ffb15 	stw	r4,-20(fp)
 4018130:	e17ffa15 	stw	r5,-24(fp)
 4018134:	e0bffa17 	ldw	r2,-24(fp)
 4018138:	e0bfff15 	stw	r2,-4(fp)
  NIOS2_READ_STATUS (context);
 401813c:	0005303a 	rdctl	r2,status
 4018140:	e0bffe15 	stw	r2,-8(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 4018144:	e0fffe17 	ldw	r3,-8(fp)
 4018148:	00bfff84 	movi	r2,-2
 401814c:	1884703a 	and	r2,r3,r2
 4018150:	1001703a 	wrctl	status,r2
  return context;
 4018154:	e0bffe17 	ldw	r2,-8(fp)
  status = alt_irq_disable_all ();
 4018158:	e0bffd15 	stw	r2,-12(fp)
  alt_irq_active &= ~(1 << id);
 401815c:	00c00044 	movi	r3,1
 4018160:	e0bfff17 	ldw	r2,-4(fp)
 4018164:	1884983a 	sll	r2,r3,r2
 4018168:	0084303a 	nor	r2,zero,r2
 401816c:	1007883a 	mov	r3,r2
 4018170:	d0a72a17 	ldw	r2,-25432(gp)
 4018174:	1884703a 	and	r2,r3,r2
 4018178:	d0a72a15 	stw	r2,-25432(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 401817c:	d0a72a17 	ldw	r2,-25432(gp)
 4018180:	100170fa 	wrctl	ienable,r2
 4018184:	e0bffd17 	ldw	r2,-12(fp)
 4018188:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context);
 401818c:	e0bffc17 	ldw	r2,-16(fp)
 4018190:	1001703a 	wrctl	status,r2
}
 4018194:	0001883a 	nop
  return 0;
 4018198:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
}
 401819c:	e037883a 	mov	sp,fp
 40181a0:	df000017 	ldw	fp,0(sp)
 40181a4:	dec00104 	addi	sp,sp,4
 40181a8:	f800283a 	ret

040181ac <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
 40181ac:	defffc04 	addi	sp,sp,-16
 40181b0:	df000315 	stw	fp,12(sp)
 40181b4:	df000304 	addi	fp,sp,12
 40181b8:	e13ffe15 	stw	r4,-8(fp)
 40181bc:	e17ffd15 	stw	r5,-12(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
 40181c0:	000530fa 	rdctl	r2,ienable
 40181c4:	e0bfff15 	stw	r2,-4(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
 40181c8:	00c00044 	movi	r3,1
 40181cc:	e0bffd17 	ldw	r2,-12(fp)
 40181d0:	1884983a 	sll	r2,r3,r2
 40181d4:	1007883a 	mov	r3,r2
 40181d8:	e0bfff17 	ldw	r2,-4(fp)
 40181dc:	1884703a 	and	r2,r3,r2
 40181e0:	1004c03a 	cmpne	r2,r2,zero
 40181e4:	10803fcc 	andi	r2,r2,255
}
 40181e8:	e037883a 	mov	sp,fp
 40181ec:	df000017 	ldw	fp,0(sp)
 40181f0:	dec00104 	addi	sp,sp,4
 40181f4:	f800283a 	ret

040181f8 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 40181f8:	defff504 	addi	sp,sp,-44
 40181fc:	dfc00a15 	stw	ra,40(sp)
 4018200:	df000915 	stw	fp,36(sp)
 4018204:	df000904 	addi	fp,sp,36
 4018208:	e13ffa15 	stw	r4,-24(fp)
 401820c:	e17ff915 	stw	r5,-28(fp)
 4018210:	e1bff815 	stw	r6,-32(fp)
 4018214:	e1fff715 	stw	r7,-36(fp)
  int rc = -EINVAL;  
 4018218:	00bffa84 	movi	r2,-22
 401821c:	e0bfff15 	stw	r2,-4(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
 4018220:	e0bff917 	ldw	r2,-28(fp)
 4018224:	e0bffe15 	stw	r2,-8(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
 4018228:	e0bffe17 	ldw	r2,-8(fp)
 401822c:	10800808 	cmpgei	r2,r2,32
 4018230:	1000251e 	bne	r2,zero,40182c8 <alt_iic_isr_register+0xd0>
  NIOS2_READ_STATUS (context);
 4018234:	0005303a 	rdctl	r2,status
 4018238:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 401823c:	e0fffc17 	ldw	r3,-16(fp)
 4018240:	00bfff84 	movi	r2,-2
 4018244:	1884703a 	and	r2,r3,r2
 4018248:	1001703a 	wrctl	status,r2
  return context;
 401824c:	e0bffc17 	ldw	r2,-16(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
 4018250:	e0bffd15 	stw	r2,-12(fp)

    alt_irq[id].handler = isr;
 4018254:	e0bffe17 	ldw	r2,-8(fp)
 4018258:	100890fa 	slli	r4,r2,3
 401825c:	e0fff817 	ldw	r3,-32(fp)
 4018260:	008120b4 	movhi	r2,1154
 4018264:	2085883a 	add	r2,r4,r2
 4018268:	10fb3015 	stw	r3,-4928(r2)
    alt_irq[id].context = isr_context;
 401826c:	e0bffe17 	ldw	r2,-8(fp)
 4018270:	100890fa 	slli	r4,r2,3
 4018274:	e0fff717 	ldw	r3,-36(fp)
 4018278:	008120b4 	movhi	r2,1154
 401827c:	2085883a 	add	r2,r4,r2
 4018280:	10fb3115 	stw	r3,-4924(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
 4018284:	e0bff817 	ldw	r2,-32(fp)
 4018288:	10000526 	beq	r2,zero,40182a0 <alt_iic_isr_register+0xa8>
 401828c:	e0bffe17 	ldw	r2,-8(fp)
 4018290:	100b883a 	mov	r5,r2
 4018294:	e13ffa17 	ldw	r4,-24(fp)
 4018298:	40180980 	call	4018098 <alt_ic_irq_enable>
 401829c:	00000406 	br	40182b0 <alt_iic_isr_register+0xb8>
 40182a0:	e0bffe17 	ldw	r2,-8(fp)
 40182a4:	100b883a 	mov	r5,r2
 40182a8:	e13ffa17 	ldw	r4,-24(fp)
 40182ac:	40181200 	call	4018120 <alt_ic_irq_disable>
 40182b0:	e0bfff15 	stw	r2,-4(fp)
 40182b4:	e0bffd17 	ldw	r2,-12(fp)
 40182b8:	e0bffb15 	stw	r2,-20(fp)
  NIOS2_WRITE_STATUS (context);
 40182bc:	e0bffb17 	ldw	r2,-20(fp)
 40182c0:	1001703a 	wrctl	status,r2
}
 40182c4:	0001883a 	nop

    alt_irq_enable_all(status);
  }

  return rc; 
 40182c8:	e0bfff17 	ldw	r2,-4(fp)
}
 40182cc:	e037883a 	mov	sp,fp
 40182d0:	dfc00117 	ldw	ra,4(sp)
 40182d4:	df000017 	ldw	fp,0(sp)
 40182d8:	dec00204 	addi	sp,sp,8
 40182dc:	f800283a 	ret

040182e0 <alt_get_errno>:
{
 40182e0:	defffe04 	addi	sp,sp,-8
 40182e4:	dfc00115 	stw	ra,4(sp)
 40182e8:	df000015 	stw	fp,0(sp)
 40182ec:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 40182f0:	d0a00a17 	ldw	r2,-32728(gp)
 40182f4:	10000326 	beq	r2,zero,4018304 <alt_get_errno+0x24>
 40182f8:	d0a00a17 	ldw	r2,-32728(gp)
 40182fc:	103ee83a 	callr	r2
 4018300:	00000106 	br	4018308 <alt_get_errno+0x28>
 4018304:	d0a72904 	addi	r2,gp,-25436
}
 4018308:	e037883a 	mov	sp,fp
 401830c:	dfc00117 	ldw	ra,4(sp)
 4018310:	df000017 	ldw	fp,0(sp)
 4018314:	dec00204 	addi	sp,sp,8
 4018318:	f800283a 	ret

0401831c <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
 401831c:	deffea04 	addi	sp,sp,-88
 4018320:	dfc01515 	stw	ra,84(sp)
 4018324:	df001415 	stw	fp,80(sp)
 4018328:	df001404 	addi	fp,sp,80
 401832c:	e13fec15 	stw	r4,-80(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 4018330:	e0bfec17 	ldw	r2,-80(fp)
 4018334:	10000916 	blt	r2,zero,401835c <isatty+0x40>
 4018338:	e0ffec17 	ldw	r3,-80(fp)
 401833c:	1805883a 	mov	r2,r3
 4018340:	1085883a 	add	r2,r2,r2
 4018344:	10c5883a 	add	r2,r2,r3
 4018348:	100490ba 	slli	r2,r2,2
 401834c:	00c100b4 	movhi	r3,1026
 4018350:	18ef3f04 	addi	r3,r3,-17156
 4018354:	10c5883a 	add	r2,r2,r3
 4018358:	00000106 	br	4018360 <isatty+0x44>
 401835c:	0005883a 	mov	r2,zero
 4018360:	e0bfff15 	stw	r2,-4(fp)
  
  if (fd)
 4018364:	e0bfff17 	ldw	r2,-4(fp)
 4018368:	10000e26 	beq	r2,zero,40183a4 <isatty+0x88>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
 401836c:	e0bfff17 	ldw	r2,-4(fp)
 4018370:	10800017 	ldw	r2,0(r2)
 4018374:	10800817 	ldw	r2,32(r2)
 4018378:	1000021e 	bne	r2,zero,4018384 <isatty+0x68>
    {
      return 1;
 401837c:	00800044 	movi	r2,1
 4018380:	00000d06 	br	40183b8 <isatty+0x9c>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
 4018384:	e0bfed04 	addi	r2,fp,-76
 4018388:	100b883a 	mov	r5,r2
 401838c:	e13fec17 	ldw	r4,-80(fp)
 4018390:	4017f6c0 	call	4017f6c <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
 4018394:	e0bfee17 	ldw	r2,-72(fp)
 4018398:	10880020 	cmpeqi	r2,r2,8192
 401839c:	10803fcc 	andi	r2,r2,255
 40183a0:	00000506 	br	40183b8 <isatty+0x9c>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 40183a4:	40182e00 	call	40182e0 <alt_get_errno>
 40183a8:	1007883a 	mov	r3,r2
 40183ac:	00801444 	movi	r2,81
 40183b0:	18800015 	stw	r2,0(r3)
    return 0;
 40183b4:	0005883a 	mov	r2,zero
  }
}
 40183b8:	e037883a 	mov	sp,fp
 40183bc:	dfc00117 	ldw	ra,4(sp)
 40183c0:	df000017 	ldw	fp,0(sp)
 40183c4:	dec00204 	addi	sp,sp,8
 40183c8:	f800283a 	ret

040183cc <alt_get_errno>:
{
 40183cc:	defffe04 	addi	sp,sp,-8
 40183d0:	dfc00115 	stw	ra,4(sp)
 40183d4:	df000015 	stw	fp,0(sp)
 40183d8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 40183dc:	d0a00a17 	ldw	r2,-32728(gp)
 40183e0:	10000326 	beq	r2,zero,40183f0 <alt_get_errno+0x24>
 40183e4:	d0a00a17 	ldw	r2,-32728(gp)
 40183e8:	103ee83a 	callr	r2
 40183ec:	00000106 	br	40183f4 <alt_get_errno+0x28>
 40183f0:	d0a72904 	addi	r2,gp,-25436
}
 40183f4:	e037883a 	mov	sp,fp
 40183f8:	dfc00117 	ldw	ra,4(sp)
 40183fc:	df000017 	ldw	fp,0(sp)
 4018400:	dec00204 	addi	sp,sp,8
 4018404:	f800283a 	ret

04018408 <kill>:
 *
 * ALT_KILL is mapped onto the kill() system call in alt_syscall.h
 */

int ALT_KILL (int pid, int sig)
{
 4018408:	defffb04 	addi	sp,sp,-20
 401840c:	dfc00415 	stw	ra,16(sp)
 4018410:	df000315 	stw	fp,12(sp)
 4018414:	df000304 	addi	fp,sp,12
 4018418:	e13ffe15 	stw	r4,-8(fp)
 401841c:	e17ffd15 	stw	r5,-12(fp)
  int status = 0;
 4018420:	e03fff15 	stw	zero,-4(fp)

  if (pid <= 0)
 4018424:	e0bffe17 	ldw	r2,-8(fp)
 4018428:	00802e16 	blt	zero,r2,40184e4 <kill+0xdc>
 401842c:	e0bffd17 	ldw	r2,-12(fp)
 4018430:	10800828 	cmpgeui	r2,r2,32
 4018434:	1000281e 	bne	r2,zero,40184d8 <kill+0xd0>
 4018438:	e0bffd17 	ldw	r2,-12(fp)
 401843c:	100690ba 	slli	r3,r2,2
 4018440:	008100b4 	movhi	r2,1026
 4018444:	1885883a 	add	r2,r3,r2
 4018448:	10a11417 	ldw	r2,-31664(r2)
 401844c:	1000683a 	jmp	r2
 4018450:	040184f8 	rdprs	r16,zero,1555
 4018454:	040184d8 	cmpnei	r16,zero,1555
 4018458:	040184d8 	cmpnei	r16,zero,1555
 401845c:	040184d0 	cmplti	r16,zero,1555
 4018460:	040184d0 	cmplti	r16,zero,1555
 4018464:	040184d0 	cmplti	r16,zero,1555
 4018468:	040184d0 	cmplti	r16,zero,1555
 401846c:	040184d8 	cmpnei	r16,zero,1555
 4018470:	040184d0 	cmplti	r16,zero,1555
 4018474:	040184d0 	cmplti	r16,zero,1555
 4018478:	040184d0 	cmplti	r16,zero,1555
 401847c:	040184d0 	cmplti	r16,zero,1555
 4018480:	040184d0 	cmplti	r16,zero,1555
 4018484:	040184d0 	cmplti	r16,zero,1555
 4018488:	040184d0 	cmplti	r16,zero,1555
 401848c:	040184d0 	cmplti	r16,zero,1555
 4018490:	040184f8 	rdprs	r16,zero,1555
 4018494:	040184d8 	cmpnei	r16,zero,1555
 4018498:	040184d8 	cmpnei	r16,zero,1555
 401849c:	040184d8 	cmpnei	r16,zero,1555
 40184a0:	040184f8 	rdprs	r16,zero,1555
 40184a4:	040184d8 	cmpnei	r16,zero,1555
 40184a8:	040184d8 	cmpnei	r16,zero,1555
 40184ac:	040184d0 	cmplti	r16,zero,1555
 40184b0:	040184d0 	cmplti	r16,zero,1555
 40184b4:	040184d0 	cmplti	r16,zero,1555
 40184b8:	040184d0 	cmplti	r16,zero,1555
 40184bc:	040184d0 	cmplti	r16,zero,1555
 40184c0:	040184d8 	cmpnei	r16,zero,1555
 40184c4:	040184d8 	cmpnei	r16,zero,1555
 40184c8:	040184d0 	cmplti	r16,zero,1555
 40184cc:	040184d0 	cmplti	r16,zero,1555
       * The Posix standard defines the default behaviour for all these signals 
       * as being eqivalent to a call to _exit(). No mechanism is provided to 
       * change this behaviour.
       */

      _exit(0);
 40184d0:	0009883a 	mov	r4,zero
 40184d4:	4017ef80 	call	4017ef8 <_exit>
      break;
    default:

      /* Tried to send an unsupported signal */

      status = EINVAL;
 40184d8:	00800584 	movi	r2,22
 40184dc:	e0bfff15 	stw	r2,-4(fp)
 40184e0:	00000606 	br	40184fc <kill+0xf4>
    }
  }

  else if (pid > 0)
 40184e4:	e0bffe17 	ldw	r2,-8(fp)
 40184e8:	0080040e 	bge	zero,r2,40184fc <kill+0xf4>
  {
    /* Attempted to signal a non-existant process */

    status = ESRCH;
 40184ec:	008000c4 	movi	r2,3
 40184f0:	e0bfff15 	stw	r2,-4(fp)
 40184f4:	00000106 	br	40184fc <kill+0xf4>
      break;
 40184f8:	0001883a 	nop
  }

  if (status)
 40184fc:	e0bfff17 	ldw	r2,-4(fp)
 4018500:	10000626 	beq	r2,zero,401851c <kill+0x114>
  {
    ALT_ERRNO = status;
 4018504:	40183cc0 	call	40183cc <alt_get_errno>
 4018508:	1007883a 	mov	r3,r2
 401850c:	e0bfff17 	ldw	r2,-4(fp)
 4018510:	18800015 	stw	r2,0(r3)
    return -1;
 4018514:	00bfffc4 	movi	r2,-1
 4018518:	00000106 	br	4018520 <kill+0x118>
  }

  return 0;
 401851c:	0005883a 	mov	r2,zero
}
 4018520:	e037883a 	mov	sp,fp
 4018524:	dfc00117 	ldw	ra,4(sp)
 4018528:	df000017 	ldw	fp,0(sp)
 401852c:	dec00204 	addi	sp,sp,8
 4018530:	f800283a 	ret

04018534 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
 4018534:	defffc04 	addi	sp,sp,-16
 4018538:	df000315 	stw	fp,12(sp)
 401853c:	df000304 	addi	fp,sp,12
 4018540:	e13fff15 	stw	r4,-4(fp)
 4018544:	e17ffe15 	stw	r5,-8(fp)
 4018548:	e1bffd15 	stw	r6,-12(fp)
  if (to != from)
 401854c:	e0fffe17 	ldw	r3,-8(fp)
 4018550:	e0bfff17 	ldw	r2,-4(fp)
 4018554:	18800c26 	beq	r3,r2,4018588 <alt_load_section+0x54>
  {
    while( to != end )
 4018558:	00000806 	br	401857c <alt_load_section+0x48>
    {
      *to++ = *from++;
 401855c:	e0ffff17 	ldw	r3,-4(fp)
 4018560:	18800104 	addi	r2,r3,4
 4018564:	e0bfff15 	stw	r2,-4(fp)
 4018568:	e0bffe17 	ldw	r2,-8(fp)
 401856c:	11000104 	addi	r4,r2,4
 4018570:	e13ffe15 	stw	r4,-8(fp)
 4018574:	18c00017 	ldw	r3,0(r3)
 4018578:	10c00015 	stw	r3,0(r2)
    while( to != end )
 401857c:	e0fffe17 	ldw	r3,-8(fp)
 4018580:	e0bffd17 	ldw	r2,-12(fp)
 4018584:	18bff51e 	bne	r3,r2,401855c <alt_load_section+0x28>
    }
  }
}
 4018588:	0001883a 	nop
 401858c:	e037883a 	mov	sp,fp
 4018590:	df000017 	ldw	fp,0(sp)
 4018594:	dec00104 	addi	sp,sp,4
 4018598:	f800283a 	ret

0401859c <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
 401859c:	defffe04 	addi	sp,sp,-8
 40185a0:	dfc00115 	stw	ra,4(sp)
 40185a4:	df000015 	stw	fp,0(sp)
 40185a8:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
 40185ac:	018100b4 	movhi	r6,1026
 40185b0:	31b3d104 	addi	r6,r6,-12476
 40185b4:	014100b4 	movhi	r5,1026
 40185b8:	296ccf04 	addi	r5,r5,-19652
 40185bc:	010100b4 	movhi	r4,1026
 40185c0:	2133d104 	addi	r4,r4,-12476
 40185c4:	40185340 	call	4018534 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
 40185c8:	01810034 	movhi	r6,1024
 40185cc:	3180d904 	addi	r6,r6,868
 40185d0:	01410034 	movhi	r5,1024
 40185d4:	29400804 	addi	r5,r5,32
 40185d8:	01010034 	movhi	r4,1024
 40185dc:	21000804 	addi	r4,r4,32
 40185e0:	40185340 	call	4018534 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
 40185e4:	018100b4 	movhi	r6,1026
 40185e8:	31accf04 	addi	r6,r6,-19652
 40185ec:	014100b4 	movhi	r5,1026
 40185f0:	296af204 	addi	r5,r5,-21560
 40185f4:	010100b4 	movhi	r4,1026
 40185f8:	212af204 	addi	r4,r4,-21560
 40185fc:	40185340 	call	4018534 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
 4018600:	4019d000 	call	4019d00 <alt_dcache_flush_all>
  alt_icache_flush_all();
 4018604:	4019f5c0 	call	4019f5c <alt_icache_flush_all>
}
 4018608:	0001883a 	nop
 401860c:	e037883a 	mov	sp,fp
 4018610:	dfc00117 	ldw	ra,4(sp)
 4018614:	df000017 	ldw	fp,0(sp)
 4018618:	dec00204 	addi	sp,sp,8
 401861c:	f800283a 	ret

04018620 <alt_get_errno>:
{
 4018620:	defffe04 	addi	sp,sp,-8
 4018624:	dfc00115 	stw	ra,4(sp)
 4018628:	df000015 	stw	fp,0(sp)
 401862c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 4018630:	d0a00a17 	ldw	r2,-32728(gp)
 4018634:	10000326 	beq	r2,zero,4018644 <alt_get_errno+0x24>
 4018638:	d0a00a17 	ldw	r2,-32728(gp)
 401863c:	103ee83a 	callr	r2
 4018640:	00000106 	br	4018648 <alt_get_errno+0x28>
 4018644:	d0a72904 	addi	r2,gp,-25436
}
 4018648:	e037883a 	mov	sp,fp
 401864c:	dfc00117 	ldw	ra,4(sp)
 4018650:	df000017 	ldw	fp,0(sp)
 4018654:	dec00204 	addi	sp,sp,8
 4018658:	f800283a 	ret

0401865c <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
 401865c:	defff904 	addi	sp,sp,-28
 4018660:	dfc00615 	stw	ra,24(sp)
 4018664:	df000515 	stw	fp,20(sp)
 4018668:	df000504 	addi	fp,sp,20
 401866c:	e13ffd15 	stw	r4,-12(fp)
 4018670:	e17ffc15 	stw	r5,-16(fp)
 4018674:	e1bffb15 	stw	r6,-20(fp)
  alt_fd* fd;
  off_t   rc = 0; 
 4018678:	e03fff15 	stw	zero,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 401867c:	e0bffd17 	ldw	r2,-12(fp)
 4018680:	10000916 	blt	r2,zero,40186a8 <lseek+0x4c>
 4018684:	e0fffd17 	ldw	r3,-12(fp)
 4018688:	1805883a 	mov	r2,r3
 401868c:	1085883a 	add	r2,r2,r2
 4018690:	10c5883a 	add	r2,r2,r3
 4018694:	100490ba 	slli	r2,r2,2
 4018698:	00c100b4 	movhi	r3,1026
 401869c:	18ef3f04 	addi	r3,r3,-17156
 40186a0:	10c5883a 	add	r2,r2,r3
 40186a4:	00000106 	br	40186ac <lseek+0x50>
 40186a8:	0005883a 	mov	r2,zero
 40186ac:	e0bffe15 	stw	r2,-8(fp)
  
  if (fd) 
 40186b0:	e0bffe17 	ldw	r2,-8(fp)
 40186b4:	10001026 	beq	r2,zero,40186f8 <lseek+0x9c>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
 40186b8:	e0bffe17 	ldw	r2,-8(fp)
 40186bc:	10800017 	ldw	r2,0(r2)
 40186c0:	10800717 	ldw	r2,28(r2)
 40186c4:	10000926 	beq	r2,zero,40186ec <lseek+0x90>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
 40186c8:	e0bffe17 	ldw	r2,-8(fp)
 40186cc:	10800017 	ldw	r2,0(r2)
 40186d0:	10800717 	ldw	r2,28(r2)
 40186d4:	e1bffb17 	ldw	r6,-20(fp)
 40186d8:	e17ffc17 	ldw	r5,-16(fp)
 40186dc:	e13ffe17 	ldw	r4,-8(fp)
 40186e0:	103ee83a 	callr	r2
 40186e4:	e0bfff15 	stw	r2,-4(fp)
 40186e8:	00000506 	br	4018700 <lseek+0xa4>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
 40186ec:	00bfde84 	movi	r2,-134
 40186f0:	e0bfff15 	stw	r2,-4(fp)
 40186f4:	00000206 	br	4018700 <lseek+0xa4>
    }
  }
  else  
  {
    rc = -EBADFD;
 40186f8:	00bfebc4 	movi	r2,-81
 40186fc:	e0bfff15 	stw	r2,-4(fp)
  }

  if (rc < 0)
 4018700:	e0bfff17 	ldw	r2,-4(fp)
 4018704:	1000070e 	bge	r2,zero,4018724 <lseek+0xc8>
  {
    ALT_ERRNO = -rc;
 4018708:	40186200 	call	4018620 <alt_get_errno>
 401870c:	1007883a 	mov	r3,r2
 4018710:	e0bfff17 	ldw	r2,-4(fp)
 4018714:	0085c83a 	sub	r2,zero,r2
 4018718:	18800015 	stw	r2,0(r3)
    rc = -1;
 401871c:	00bfffc4 	movi	r2,-1
 4018720:	e0bfff15 	stw	r2,-4(fp)
  }

  return rc;
 4018724:	e0bfff17 	ldw	r2,-4(fp)
}
 4018728:	e037883a 	mov	sp,fp
 401872c:	dfc00117 	ldw	ra,4(sp)
 4018730:	df000017 	ldw	fp,0(sp)
 4018734:	dec00204 	addi	sp,sp,8
 4018738:	f800283a 	ret

0401873c <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 401873c:	defffd04 	addi	sp,sp,-12
 4018740:	dfc00215 	stw	ra,8(sp)
 4018744:	df000115 	stw	fp,4(sp)
 4018748:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 401874c:	0009883a 	mov	r4,zero
 4018750:	4018be00 	call	4018be0 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
 4018754:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 4018758:	4018c1c0 	call	4018c1c <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
 401875c:	018100b4 	movhi	r6,1026
 4018760:	31acbf04 	addi	r6,r6,-19716
 4018764:	014100b4 	movhi	r5,1026
 4018768:	296cbf04 	addi	r5,r5,-19716
 401876c:	010100b4 	movhi	r4,1026
 4018770:	212cbf04 	addi	r4,r4,-19716
 4018774:	401a0e80 	call	401a0e8 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
 4018778:	4019e040 	call	4019e04 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
 401877c:	010100b4 	movhi	r4,1026
 4018780:	21279a04 	addi	r4,r4,-24984
 4018784:	401a76c0 	call	401a76c <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
 4018788:	d0a72b17 	ldw	r2,-25428(gp)
 401878c:	d0e72c17 	ldw	r3,-25424(gp)
 4018790:	d1272d17 	ldw	r4,-25420(gp)
 4018794:	200d883a 	mov	r6,r4
 4018798:	180b883a 	mov	r5,r3
 401879c:	1009883a 	mov	r4,r2
 40187a0:	40073740 	call	4007374 <main>
 40187a4:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
 40187a8:	01000044 	movi	r4,1
 40187ac:	4017df00 	call	4017df0 <close>
  exit (result);
 40187b0:	e13fff17 	ldw	r4,-4(fp)
 40187b4:	401a7a80 	call	401a7a8 <exit>

040187b8 <__malloc_lock>:
 * configuration is single threaded, so there is nothing to do here. Note that 
 * this requires that malloc is never called by an interrupt service routine.
 */

void __malloc_lock ( struct _reent *_r )
{
 40187b8:	defffe04 	addi	sp,sp,-8
 40187bc:	df000115 	stw	fp,4(sp)
 40187c0:	df000104 	addi	fp,sp,4
 40187c4:	e13fff15 	stw	r4,-4(fp)
}
 40187c8:	0001883a 	nop
 40187cc:	e037883a 	mov	sp,fp
 40187d0:	df000017 	ldw	fp,0(sp)
 40187d4:	dec00104 	addi	sp,sp,4
 40187d8:	f800283a 	ret

040187dc <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
 40187dc:	defffe04 	addi	sp,sp,-8
 40187e0:	df000115 	stw	fp,4(sp)
 40187e4:	df000104 	addi	fp,sp,4
 40187e8:	e13fff15 	stw	r4,-4(fp)
}
 40187ec:	0001883a 	nop
 40187f0:	e037883a 	mov	sp,fp
 40187f4:	df000017 	ldw	fp,0(sp)
 40187f8:	dec00104 	addi	sp,sp,4
 40187fc:	f800283a 	ret

04018800 <alt_get_errno>:
{
 4018800:	defffe04 	addi	sp,sp,-8
 4018804:	dfc00115 	stw	ra,4(sp)
 4018808:	df000015 	stw	fp,0(sp)
 401880c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 4018810:	d0a00a17 	ldw	r2,-32728(gp)
 4018814:	10000326 	beq	r2,zero,4018824 <alt_get_errno+0x24>
 4018818:	d0a00a17 	ldw	r2,-32728(gp)
 401881c:	103ee83a 	callr	r2
 4018820:	00000106 	br	4018828 <alt_get_errno+0x28>
 4018824:	d0a72904 	addi	r2,gp,-25436
}
 4018828:	e037883a 	mov	sp,fp
 401882c:	dfc00117 	ldw	ra,4(sp)
 4018830:	df000017 	ldw	fp,0(sp)
 4018834:	dec00204 	addi	sp,sp,8
 4018838:	f800283a 	ret

0401883c <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
 401883c:	defff904 	addi	sp,sp,-28
 4018840:	dfc00615 	stw	ra,24(sp)
 4018844:	df000515 	stw	fp,20(sp)
 4018848:	df000504 	addi	fp,sp,20
 401884c:	e13ffd15 	stw	r4,-12(fp)
 4018850:	e17ffc15 	stw	r5,-16(fp)
 4018854:	e1bffb15 	stw	r6,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 4018858:	e0bffd17 	ldw	r2,-12(fp)
 401885c:	10000916 	blt	r2,zero,4018884 <read+0x48>
 4018860:	e0fffd17 	ldw	r3,-12(fp)
 4018864:	1805883a 	mov	r2,r3
 4018868:	1085883a 	add	r2,r2,r2
 401886c:	10c5883a 	add	r2,r2,r3
 4018870:	100490ba 	slli	r2,r2,2
 4018874:	00c100b4 	movhi	r3,1026
 4018878:	18ef3f04 	addi	r3,r3,-17156
 401887c:	10c5883a 	add	r2,r2,r3
 4018880:	00000106 	br	4018888 <read+0x4c>
 4018884:	0005883a 	mov	r2,zero
 4018888:	e0bfff15 	stw	r2,-4(fp)
  
  if (fd)
 401888c:	e0bfff17 	ldw	r2,-4(fp)
 4018890:	10002226 	beq	r2,zero,401891c <read+0xe0>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 4018894:	e0bfff17 	ldw	r2,-4(fp)
 4018898:	10800217 	ldw	r2,8(r2)
 401889c:	108000cc 	andi	r2,r2,3
 40188a0:	10800060 	cmpeqi	r2,r2,1
 40188a4:	1000181e 	bne	r2,zero,4018908 <read+0xcc>
        (fd->dev->read))
 40188a8:	e0bfff17 	ldw	r2,-4(fp)
 40188ac:	10800017 	ldw	r2,0(r2)
 40188b0:	10800517 	ldw	r2,20(r2)
    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 40188b4:	10001426 	beq	r2,zero,4018908 <read+0xcc>
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
 40188b8:	e0bfff17 	ldw	r2,-4(fp)
 40188bc:	10800017 	ldw	r2,0(r2)
 40188c0:	10800517 	ldw	r2,20(r2)
 40188c4:	e0fffb17 	ldw	r3,-20(fp)
 40188c8:	180d883a 	mov	r6,r3
 40188cc:	e17ffc17 	ldw	r5,-16(fp)
 40188d0:	e13fff17 	ldw	r4,-4(fp)
 40188d4:	103ee83a 	callr	r2
 40188d8:	e0bffe15 	stw	r2,-8(fp)
 40188dc:	e0bffe17 	ldw	r2,-8(fp)
 40188e0:	1000070e 	bge	r2,zero,4018900 <read+0xc4>
        {
          ALT_ERRNO = -rval;
 40188e4:	40188000 	call	4018800 <alt_get_errno>
 40188e8:	1007883a 	mov	r3,r2
 40188ec:	e0bffe17 	ldw	r2,-8(fp)
 40188f0:	0085c83a 	sub	r2,zero,r2
 40188f4:	18800015 	stw	r2,0(r3)
          return -1;
 40188f8:	00bfffc4 	movi	r2,-1
 40188fc:	00000c06 	br	4018930 <read+0xf4>
        }
        return rval;
 4018900:	e0bffe17 	ldw	r2,-8(fp)
 4018904:	00000a06 	br	4018930 <read+0xf4>
      }
      else
      {
        ALT_ERRNO = EACCES;
 4018908:	40188000 	call	4018800 <alt_get_errno>
 401890c:	1007883a 	mov	r3,r2
 4018910:	00800344 	movi	r2,13
 4018914:	18800015 	stw	r2,0(r3)
 4018918:	00000406 	br	401892c <read+0xf0>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
 401891c:	40188000 	call	4018800 <alt_get_errno>
 4018920:	1007883a 	mov	r3,r2
 4018924:	00801444 	movi	r2,81
 4018928:	18800015 	stw	r2,0(r3)
  }
  return -1;
 401892c:	00bfffc4 	movi	r2,-1
}
 4018930:	e037883a 	mov	sp,fp
 4018934:	dfc00117 	ldw	ra,4(sp)
 4018938:	df000017 	ldw	fp,0(sp)
 401893c:	dec00204 	addi	sp,sp,8
 4018940:	f800283a 	ret

04018944 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
 4018944:	defffe04 	addi	sp,sp,-8
 4018948:	df000115 	stw	fp,4(sp)
 401894c:	df000104 	addi	fp,sp,4
 4018950:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
 4018954:	e0bfff17 	ldw	r2,-4(fp)
 4018958:	108000d0 	cmplti	r2,r2,3
 401895c:	1000101e 	bne	r2,zero,40189a0 <alt_release_fd+0x5c>
  {
    alt_fd_list[fd].fd_flags = 0;
 4018960:	e0ffff17 	ldw	r3,-4(fp)
 4018964:	1805883a 	mov	r2,r3
 4018968:	1085883a 	add	r2,r2,r2
 401896c:	10c5883a 	add	r2,r2,r3
 4018970:	100490ba 	slli	r2,r2,2
 4018974:	00c100b4 	movhi	r3,1026
 4018978:	10c7883a 	add	r3,r2,r3
 401897c:	182f4115 	stw	zero,-17148(r3)
    alt_fd_list[fd].dev      = 0;
 4018980:	e0ffff17 	ldw	r3,-4(fp)
 4018984:	1805883a 	mov	r2,r3
 4018988:	1085883a 	add	r2,r2,r2
 401898c:	10c5883a 	add	r2,r2,r3
 4018990:	100490ba 	slli	r2,r2,2
 4018994:	00c100b4 	movhi	r3,1026
 4018998:	10c7883a 	add	r3,r2,r3
 401899c:	182f3f15 	stw	zero,-17156(r3)
  }
}
 40189a0:	0001883a 	nop
 40189a4:	e037883a 	mov	sp,fp
 40189a8:	df000017 	ldw	fp,0(sp)
 40189ac:	dec00104 	addi	sp,sp,4
 40189b0:	f800283a 	ret

040189b4 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
 40189b4:	defff904 	addi	sp,sp,-28
 40189b8:	df000615 	stw	fp,24(sp)
 40189bc:	df000604 	addi	fp,sp,24
 40189c0:	e13ffa15 	stw	r4,-24(fp)
  NIOS2_READ_STATUS (context);
 40189c4:	0005303a 	rdctl	r2,status
 40189c8:	e0bffd15 	stw	r2,-12(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 40189cc:	e0fffd17 	ldw	r3,-12(fp)
 40189d0:	00bfff84 	movi	r2,-2
 40189d4:	1884703a 	and	r2,r3,r2
 40189d8:	1001703a 	wrctl	status,r2
  return context;
 40189dc:	e0bffd17 	ldw	r2,-12(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
 40189e0:	e0bfff15 	stw	r2,-4(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
 40189e4:	d0a00c17 	ldw	r2,-32720(gp)
 40189e8:	10c000c4 	addi	r3,r2,3
 40189ec:	00bfff04 	movi	r2,-4
 40189f0:	1884703a 	and	r2,r3,r2
 40189f4:	d0a00c15 	stw	r2,-32720(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
 40189f8:	d0e00c17 	ldw	r3,-32720(gp)
 40189fc:	e0bffa17 	ldw	r2,-24(fp)
 4018a00:	1887883a 	add	r3,r3,r2
 4018a04:	00820034 	movhi	r2,2048
 4018a08:	10800004 	addi	r2,r2,0
 4018a0c:	10c0072e 	bgeu	r2,r3,4018a2c <sbrk+0x78>
 4018a10:	e0bfff17 	ldw	r2,-4(fp)
 4018a14:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context);
 4018a18:	e0bffc17 	ldw	r2,-16(fp)
 4018a1c:	1001703a 	wrctl	status,r2
}
 4018a20:	0001883a 	nop
    alt_irq_enable_all(context);
    return (caddr_t)-1;
 4018a24:	00bfffc4 	movi	r2,-1
 4018a28:	00000c06 	br	4018a5c <sbrk+0xa8>
  }
#endif

  prev_heap_end = heap_end; 
 4018a2c:	d0a00c17 	ldw	r2,-32720(gp)
 4018a30:	e0bffe15 	stw	r2,-8(fp)
  heap_end += incr; 
 4018a34:	d0e00c17 	ldw	r3,-32720(gp)
 4018a38:	e0bffa17 	ldw	r2,-24(fp)
 4018a3c:	1885883a 	add	r2,r3,r2
 4018a40:	d0a00c15 	stw	r2,-32720(gp)
 4018a44:	e0bfff17 	ldw	r2,-4(fp)
 4018a48:	e0bffb15 	stw	r2,-20(fp)
  NIOS2_WRITE_STATUS (context);
 4018a4c:	e0bffb17 	ldw	r2,-20(fp)
 4018a50:	1001703a 	wrctl	status,r2
}
 4018a54:	0001883a 	nop

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
 4018a58:	e0bffe17 	ldw	r2,-8(fp)
} 
 4018a5c:	e037883a 	mov	sp,fp
 4018a60:	df000017 	ldw	fp,0(sp)
 4018a64:	dec00104 	addi	sp,sp,4
 4018a68:	f800283a 	ret

04018a6c <alt_get_errno>:
{
 4018a6c:	defffe04 	addi	sp,sp,-8
 4018a70:	dfc00115 	stw	ra,4(sp)
 4018a74:	df000015 	stw	fp,0(sp)
 4018a78:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 4018a7c:	d0a00a17 	ldw	r2,-32728(gp)
 4018a80:	10000326 	beq	r2,zero,4018a90 <alt_get_errno+0x24>
 4018a84:	d0a00a17 	ldw	r2,-32728(gp)
 4018a88:	103ee83a 	callr	r2
 4018a8c:	00000106 	br	4018a94 <alt_get_errno+0x28>
 4018a90:	d0a72904 	addi	r2,gp,-25436
}
 4018a94:	e037883a 	mov	sp,fp
 4018a98:	dfc00117 	ldw	ra,4(sp)
 4018a9c:	df000017 	ldw	fp,0(sp)
 4018aa0:	dec00204 	addi	sp,sp,8
 4018aa4:	f800283a 	ret

04018aa8 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
 4018aa8:	defff904 	addi	sp,sp,-28
 4018aac:	dfc00615 	stw	ra,24(sp)
 4018ab0:	df000515 	stw	fp,20(sp)
 4018ab4:	df000504 	addi	fp,sp,20
 4018ab8:	e13ffd15 	stw	r4,-12(fp)
 4018abc:	e17ffc15 	stw	r5,-16(fp)
 4018ac0:	e1bffb15 	stw	r6,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 4018ac4:	e0bffd17 	ldw	r2,-12(fp)
 4018ac8:	10000916 	blt	r2,zero,4018af0 <write+0x48>
 4018acc:	e0fffd17 	ldw	r3,-12(fp)
 4018ad0:	1805883a 	mov	r2,r3
 4018ad4:	1085883a 	add	r2,r2,r2
 4018ad8:	10c5883a 	add	r2,r2,r3
 4018adc:	100490ba 	slli	r2,r2,2
 4018ae0:	00c100b4 	movhi	r3,1026
 4018ae4:	18ef3f04 	addi	r3,r3,-17156
 4018ae8:	10c5883a 	add	r2,r2,r3
 4018aec:	00000106 	br	4018af4 <write+0x4c>
 4018af0:	0005883a 	mov	r2,zero
 4018af4:	e0bfff15 	stw	r2,-4(fp)
  
  if (fd)
 4018af8:	e0bfff17 	ldw	r2,-4(fp)
 4018afc:	10002126 	beq	r2,zero,4018b84 <write+0xdc>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
 4018b00:	e0bfff17 	ldw	r2,-4(fp)
 4018b04:	10800217 	ldw	r2,8(r2)
 4018b08:	108000cc 	andi	r2,r2,3
 4018b0c:	10001826 	beq	r2,zero,4018b70 <write+0xc8>
 4018b10:	e0bfff17 	ldw	r2,-4(fp)
 4018b14:	10800017 	ldw	r2,0(r2)
 4018b18:	10800617 	ldw	r2,24(r2)
 4018b1c:	10001426 	beq	r2,zero,4018b70 <write+0xc8>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
 4018b20:	e0bfff17 	ldw	r2,-4(fp)
 4018b24:	10800017 	ldw	r2,0(r2)
 4018b28:	10800617 	ldw	r2,24(r2)
 4018b2c:	e0fffb17 	ldw	r3,-20(fp)
 4018b30:	180d883a 	mov	r6,r3
 4018b34:	e17ffc17 	ldw	r5,-16(fp)
 4018b38:	e13fff17 	ldw	r4,-4(fp)
 4018b3c:	103ee83a 	callr	r2
 4018b40:	e0bffe15 	stw	r2,-8(fp)
 4018b44:	e0bffe17 	ldw	r2,-8(fp)
 4018b48:	1000070e 	bge	r2,zero,4018b68 <write+0xc0>
      {
        ALT_ERRNO = -rval;
 4018b4c:	4018a6c0 	call	4018a6c <alt_get_errno>
 4018b50:	1007883a 	mov	r3,r2
 4018b54:	e0bffe17 	ldw	r2,-8(fp)
 4018b58:	0085c83a 	sub	r2,zero,r2
 4018b5c:	18800015 	stw	r2,0(r3)
        return -1;
 4018b60:	00bfffc4 	movi	r2,-1
 4018b64:	00000c06 	br	4018b98 <write+0xf0>
      }
      return rval;
 4018b68:	e0bffe17 	ldw	r2,-8(fp)
 4018b6c:	00000a06 	br	4018b98 <write+0xf0>
    }
    else
    {
      ALT_ERRNO = EACCES;
 4018b70:	4018a6c0 	call	4018a6c <alt_get_errno>
 4018b74:	1007883a 	mov	r3,r2
 4018b78:	00800344 	movi	r2,13
 4018b7c:	18800015 	stw	r2,0(r3)
 4018b80:	00000406 	br	4018b94 <write+0xec>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
 4018b84:	4018a6c0 	call	4018a6c <alt_get_errno>
 4018b88:	1007883a 	mov	r3,r2
 4018b8c:	00801444 	movi	r2,81
 4018b90:	18800015 	stw	r2,0(r3)
  }
  return -1;
 4018b94:	00bfffc4 	movi	r2,-1
}
 4018b98:	e037883a 	mov	sp,fp
 4018b9c:	dfc00117 	ldw	ra,4(sp)
 4018ba0:	df000017 	ldw	fp,0(sp)
 4018ba4:	dec00204 	addi	sp,sp,8
 4018ba8:	f800283a 	ret

04018bac <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
 4018bac:	defffd04 	addi	sp,sp,-12
 4018bb0:	dfc00215 	stw	ra,8(sp)
 4018bb4:	df000115 	stw	fp,4(sp)
 4018bb8:	df000104 	addi	fp,sp,4
 4018bbc:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
 4018bc0:	d1600704 	addi	r5,gp,-32740
 4018bc4:	e13fff17 	ldw	r4,-4(fp)
 4018bc8:	4019d5c0 	call	4019d5c <alt_dev_llist_insert>
}
 4018bcc:	e037883a 	mov	sp,fp
 4018bd0:	dfc00117 	ldw	ra,4(sp)
 4018bd4:	df000017 	ldw	fp,0(sp)
 4018bd8:	dec00204 	addi	sp,sp,8
 4018bdc:	f800283a 	ret

04018be0 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 4018be0:	defffd04 	addi	sp,sp,-12
 4018be4:	dfc00215 	stw	ra,8(sp)
 4018be8:	df000115 	stw	fp,4(sp)
 4018bec:	df000104 	addi	fp,sp,4
 4018bf0:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2, nios2);
 4018bf4:	401a5880 	call	401a588 <altera_nios2_gen2_irq_init>
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 4018bf8:	00800044 	movi	r2,1
 4018bfc:	1001703a 	wrctl	status,r2
}
 4018c00:	0001883a 	nop
    alt_irq_cpu_enable_interrupts();
}
 4018c04:	0001883a 	nop
 4018c08:	e037883a 	mov	sp,fp
 4018c0c:	dfc00117 	ldw	ra,4(sp)
 4018c10:	df000017 	ldw	fp,0(sp)
 4018c14:	dec00204 	addi	sp,sp,8
 4018c18:	f800283a 	ret

04018c1c <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 4018c1c:	defffe04 	addi	sp,sp,-8
 4018c20:	dfc00115 	stw	ra,4(sp)
 4018c24:	df000015 	stw	fp,0(sp)
 4018c28:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( SYS_CLK, sys_clk);
 4018c2c:	01c0fa04 	movi	r7,1000
 4018c30:	01800084 	movi	r6,2
 4018c34:	000b883a 	mov	r5,zero
 4018c38:	01020034 	movhi	r4,2048
 4018c3c:	21040004 	addi	r4,r4,4096
 4018c40:	401977c0 	call	401977c <alt_avalon_timer_sc_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
 4018c44:	000d883a 	mov	r6,zero
 4018c48:	000b883a 	mov	r5,zero
 4018c4c:	010100b4 	movhi	r4,1026
 4018c50:	212fa904 	addi	r4,r4,-16732
 4018c54:	4018df00 	call	4018df0 <altera_avalon_jtag_uart_init>
 4018c58:	010100b4 	movhi	r4,1026
 4018c5c:	212f9f04 	addi	r4,r4,-16772
 4018c60:	4018bac0 	call	4018bac <alt_dev_reg>
    ALTERA_AVALON_SPI_INIT ( ESP32_SPI, esp32_spi);
 4018c64:	0001883a 	nop
    ALTERA_UP_AVALON_ACCELEROMETER_SPI_INIT ( ACCELEROMETER_SPI, accelerometer_spi);
 4018c68:	010100b4 	movhi	r4,1026
 4018c6c:	2133b704 	addi	r4,r4,-12580
 4018c70:	4018bac0 	call	4018bac <alt_dev_reg>
}
 4018c74:	0001883a 	nop
 4018c78:	e037883a 	mov	sp,fp
 4018c7c:	dfc00117 	ldw	ra,4(sp)
 4018c80:	df000017 	ldw	fp,0(sp)
 4018c84:	dec00204 	addi	sp,sp,8
 4018c88:	f800283a 	ret

04018c8c <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 4018c8c:	defffa04 	addi	sp,sp,-24
 4018c90:	dfc00515 	stw	ra,20(sp)
 4018c94:	df000415 	stw	fp,16(sp)
 4018c98:	df000404 	addi	fp,sp,16
 4018c9c:	e13ffe15 	stw	r4,-8(fp)
 4018ca0:	e17ffd15 	stw	r5,-12(fp)
 4018ca4:	e1bffc15 	stw	r6,-16(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 4018ca8:	e0bffe17 	ldw	r2,-8(fp)
 4018cac:	10800017 	ldw	r2,0(r2)
 4018cb0:	e0bfff15 	stw	r2,-4(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
 4018cb4:	e0bfff17 	ldw	r2,-4(fp)
 4018cb8:	10c00a04 	addi	r3,r2,40
 4018cbc:	e0bffe17 	ldw	r2,-8(fp)
 4018cc0:	10800217 	ldw	r2,8(r2)
 4018cc4:	100f883a 	mov	r7,r2
 4018cc8:	e1bffc17 	ldw	r6,-16(fp)
 4018ccc:	e17ffd17 	ldw	r5,-12(fp)
 4018cd0:	1809883a 	mov	r4,r3
 4018cd4:	40192b80 	call	40192b8 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
 4018cd8:	e037883a 	mov	sp,fp
 4018cdc:	dfc00117 	ldw	ra,4(sp)
 4018ce0:	df000017 	ldw	fp,0(sp)
 4018ce4:	dec00204 	addi	sp,sp,8
 4018ce8:	f800283a 	ret

04018cec <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 4018cec:	defffa04 	addi	sp,sp,-24
 4018cf0:	dfc00515 	stw	ra,20(sp)
 4018cf4:	df000415 	stw	fp,16(sp)
 4018cf8:	df000404 	addi	fp,sp,16
 4018cfc:	e13ffe15 	stw	r4,-8(fp)
 4018d00:	e17ffd15 	stw	r5,-12(fp)
 4018d04:	e1bffc15 	stw	r6,-16(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 4018d08:	e0bffe17 	ldw	r2,-8(fp)
 4018d0c:	10800017 	ldw	r2,0(r2)
 4018d10:	e0bfff15 	stw	r2,-4(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
 4018d14:	e0bfff17 	ldw	r2,-4(fp)
 4018d18:	10c00a04 	addi	r3,r2,40
 4018d1c:	e0bffe17 	ldw	r2,-8(fp)
 4018d20:	10800217 	ldw	r2,8(r2)
 4018d24:	100f883a 	mov	r7,r2
 4018d28:	e1bffc17 	ldw	r6,-16(fp)
 4018d2c:	e17ffd17 	ldw	r5,-12(fp)
 4018d30:	1809883a 	mov	r4,r3
 4018d34:	40194d80 	call	40194d8 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
 4018d38:	e037883a 	mov	sp,fp
 4018d3c:	dfc00117 	ldw	ra,4(sp)
 4018d40:	df000017 	ldw	fp,0(sp)
 4018d44:	dec00204 	addi	sp,sp,8
 4018d48:	f800283a 	ret

04018d4c <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
 4018d4c:	defffc04 	addi	sp,sp,-16
 4018d50:	dfc00315 	stw	ra,12(sp)
 4018d54:	df000215 	stw	fp,8(sp)
 4018d58:	df000204 	addi	fp,sp,8
 4018d5c:	e13ffe15 	stw	r4,-8(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 4018d60:	e0bffe17 	ldw	r2,-8(fp)
 4018d64:	10800017 	ldw	r2,0(r2)
 4018d68:	e0bfff15 	stw	r2,-4(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
 4018d6c:	e0bfff17 	ldw	r2,-4(fp)
 4018d70:	10c00a04 	addi	r3,r2,40
 4018d74:	e0bffe17 	ldw	r2,-8(fp)
 4018d78:	10800217 	ldw	r2,8(r2)
 4018d7c:	100b883a 	mov	r5,r2
 4018d80:	1809883a 	mov	r4,r3
 4018d84:	401915c0 	call	401915c <altera_avalon_jtag_uart_close>
}
 4018d88:	e037883a 	mov	sp,fp
 4018d8c:	dfc00117 	ldw	ra,4(sp)
 4018d90:	df000017 	ldw	fp,0(sp)
 4018d94:	dec00204 	addi	sp,sp,8
 4018d98:	f800283a 	ret

04018d9c <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
 4018d9c:	defffa04 	addi	sp,sp,-24
 4018da0:	dfc00515 	stw	ra,20(sp)
 4018da4:	df000415 	stw	fp,16(sp)
 4018da8:	df000404 	addi	fp,sp,16
 4018dac:	e13ffe15 	stw	r4,-8(fp)
 4018db0:	e17ffd15 	stw	r5,-12(fp)
 4018db4:	e1bffc15 	stw	r6,-16(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
 4018db8:	e0bffe17 	ldw	r2,-8(fp)
 4018dbc:	10800017 	ldw	r2,0(r2)
 4018dc0:	e0bfff15 	stw	r2,-4(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
 4018dc4:	e0bfff17 	ldw	r2,-4(fp)
 4018dc8:	10800a04 	addi	r2,r2,40
 4018dcc:	e1bffc17 	ldw	r6,-16(fp)
 4018dd0:	e17ffd17 	ldw	r5,-12(fp)
 4018dd4:	1009883a 	mov	r4,r2
 4018dd8:	40191c40 	call	40191c4 <altera_avalon_jtag_uart_ioctl>
}
 4018ddc:	e037883a 	mov	sp,fp
 4018de0:	dfc00117 	ldw	ra,4(sp)
 4018de4:	df000017 	ldw	fp,0(sp)
 4018de8:	dec00204 	addi	sp,sp,8
 4018dec:	f800283a 	ret

04018df0 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
 4018df0:	defffa04 	addi	sp,sp,-24
 4018df4:	dfc00515 	stw	ra,20(sp)
 4018df8:	df000415 	stw	fp,16(sp)
 4018dfc:	df000404 	addi	fp,sp,16
 4018e00:	e13fff15 	stw	r4,-4(fp)
 4018e04:	e17ffe15 	stw	r5,-8(fp)
 4018e08:	e1bffd15 	stw	r6,-12(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 4018e0c:	e0bfff17 	ldw	r2,-4(fp)
 4018e10:	00c00044 	movi	r3,1
 4018e14:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
 4018e18:	e0bfff17 	ldw	r2,-4(fp)
 4018e1c:	10800017 	ldw	r2,0(r2)
 4018e20:	10800104 	addi	r2,r2,4
 4018e24:	1007883a 	mov	r3,r2
 4018e28:	e0bfff17 	ldw	r2,-4(fp)
 4018e2c:	10800817 	ldw	r2,32(r2)
 4018e30:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
 4018e34:	e0bffe17 	ldw	r2,-8(fp)
 4018e38:	e0fffd17 	ldw	r3,-12(fp)
 4018e3c:	d8000015 	stw	zero,0(sp)
 4018e40:	e1ffff17 	ldw	r7,-4(fp)
 4018e44:	018100b4 	movhi	r6,1026
 4018e48:	31a3ac04 	addi	r6,r6,-29008
 4018e4c:	180b883a 	mov	r5,r3
 4018e50:	1009883a 	mov	r4,r2
 4018e54:	40180480 	call	4018048 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
 4018e58:	e0bfff17 	ldw	r2,-4(fp)
 4018e5c:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
 4018e60:	e0bfff17 	ldw	r2,-4(fp)
 4018e64:	10800204 	addi	r2,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 4018e68:	d0e72f17 	ldw	r3,-25412(gp)
 4018e6c:	e1ffff17 	ldw	r7,-4(fp)
 4018e70:	018100b4 	movhi	r6,1026
 4018e74:	31a42f04 	addi	r6,r6,-28484
 4018e78:	180b883a 	mov	r5,r3
 4018e7c:	1009883a 	mov	r4,r2
 4018e80:	4019bcc0 	call	4019bcc <alt_alarm_start>
 4018e84:	1000040e 	bge	r2,zero,4018e98 <altera_avalon_jtag_uart_init+0xa8>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
 4018e88:	e0ffff17 	ldw	r3,-4(fp)
 4018e8c:	00a00034 	movhi	r2,32768
 4018e90:	10bfffc4 	addi	r2,r2,-1
 4018e94:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
 4018e98:	0001883a 	nop
 4018e9c:	e037883a 	mov	sp,fp
 4018ea0:	dfc00117 	ldw	ra,4(sp)
 4018ea4:	df000017 	ldw	fp,0(sp)
 4018ea8:	dec00204 	addi	sp,sp,8
 4018eac:	f800283a 	ret

04018eb0 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
 4018eb0:	defff804 	addi	sp,sp,-32
 4018eb4:	df000715 	stw	fp,28(sp)
 4018eb8:	df000704 	addi	fp,sp,28
 4018ebc:	e13ff915 	stw	r4,-28(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
 4018ec0:	e0bff917 	ldw	r2,-28(fp)
 4018ec4:	e0bffd15 	stw	r2,-12(fp)
  unsigned int base = sp->base;
 4018ec8:	e0bffd17 	ldw	r2,-12(fp)
 4018ecc:	10800017 	ldw	r2,0(r2)
 4018ed0:	e0bffc15 	stw	r2,-16(fp)
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 4018ed4:	e0bffc17 	ldw	r2,-16(fp)
 4018ed8:	10800104 	addi	r2,r2,4
 4018edc:	10800037 	ldwio	r2,0(r2)
 4018ee0:	e0bffb15 	stw	r2,-20(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
 4018ee4:	e0bffb17 	ldw	r2,-20(fp)
 4018ee8:	1080c00c 	andi	r2,r2,768
 4018eec:	10006d26 	beq	r2,zero,40190a4 <altera_avalon_jtag_uart_irq+0x1f4>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
 4018ef0:	e0bffb17 	ldw	r2,-20(fp)
 4018ef4:	1080400c 	andi	r2,r2,256
 4018ef8:	10003526 	beq	r2,zero,4018fd0 <altera_avalon_jtag_uart_irq+0x120>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
 4018efc:	00800074 	movhi	r2,1
 4018f00:	e0bfff15 	stw	r2,-4(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 4018f04:	e0bffd17 	ldw	r2,-12(fp)
 4018f08:	10800a17 	ldw	r2,40(r2)
 4018f0c:	10800044 	addi	r2,r2,1
 4018f10:	1081ffcc 	andi	r2,r2,2047
 4018f14:	e0bffa15 	stw	r2,-24(fp)
        if (next == sp->rx_out)
 4018f18:	e0bffd17 	ldw	r2,-12(fp)
 4018f1c:	10800b17 	ldw	r2,44(r2)
 4018f20:	e0fffa17 	ldw	r3,-24(fp)
 4018f24:	18801526 	beq	r3,r2,4018f7c <altera_avalon_jtag_uart_irq+0xcc>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
 4018f28:	e0bffc17 	ldw	r2,-16(fp)
 4018f2c:	10800037 	ldwio	r2,0(r2)
 4018f30:	e0bfff15 	stw	r2,-4(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
 4018f34:	e0bfff17 	ldw	r2,-4(fp)
 4018f38:	10a0000c 	andi	r2,r2,32768
 4018f3c:	10001126 	beq	r2,zero,4018f84 <altera_avalon_jtag_uart_irq+0xd4>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
 4018f40:	e0bffd17 	ldw	r2,-12(fp)
 4018f44:	10800a17 	ldw	r2,40(r2)
 4018f48:	e0ffff17 	ldw	r3,-4(fp)
 4018f4c:	1809883a 	mov	r4,r3
 4018f50:	e0fffd17 	ldw	r3,-12(fp)
 4018f54:	1885883a 	add	r2,r3,r2
 4018f58:	11000e05 	stb	r4,56(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 4018f5c:	e0bffd17 	ldw	r2,-12(fp)
 4018f60:	10800a17 	ldw	r2,40(r2)
 4018f64:	10800044 	addi	r2,r2,1
 4018f68:	10c1ffcc 	andi	r3,r2,2047
 4018f6c:	e0bffd17 	ldw	r2,-12(fp)
 4018f70:	10c00a15 	stw	r3,40(r2)
 * HAL.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_no_error (void)
{
  return 0;
 4018f74:	0001883a 	nop
      {
 4018f78:	003fe206 	br	4018f04 <altera_avalon_jtag_uart_irq+0x54>
          break;
 4018f7c:	0001883a 	nop
 4018f80:	00000106 	br	4018f88 <altera_avalon_jtag_uart_irq+0xd8>
          break;
 4018f84:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
 4018f88:	e0bfff17 	ldw	r2,-4(fp)
 4018f8c:	10bfffec 	andhi	r2,r2,65535
 4018f90:	10000f26 	beq	r2,zero,4018fd0 <altera_avalon_jtag_uart_irq+0x120>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 4018f94:	e0bffd17 	ldw	r2,-12(fp)
 4018f98:	10c00817 	ldw	r3,32(r2)
 4018f9c:	00bfff84 	movi	r2,-2
 4018fa0:	1886703a 	and	r3,r3,r2
 4018fa4:	e0bffd17 	ldw	r2,-12(fp)
 4018fa8:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
 4018fac:	e0bffc17 	ldw	r2,-16(fp)
 4018fb0:	10800104 	addi	r2,r2,4
 4018fb4:	1007883a 	mov	r3,r2
 4018fb8:	e0bffd17 	ldw	r2,-12(fp)
 4018fbc:	10800817 	ldw	r2,32(r2)
 4018fc0:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 4018fc4:	e0bffc17 	ldw	r2,-16(fp)
 4018fc8:	10800104 	addi	r2,r2,4
 4018fcc:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
 4018fd0:	e0bffb17 	ldw	r2,-20(fp)
 4018fd4:	1080800c 	andi	r2,r2,512
 4018fd8:	103fbe26 	beq	r2,zero,4018ed4 <altera_avalon_jtag_uart_irq+0x24>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
 4018fdc:	e0bffb17 	ldw	r2,-20(fp)
 4018fe0:	1004d43a 	srli	r2,r2,16
 4018fe4:	e0bffe15 	stw	r2,-8(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
 4018fe8:	00001406 	br	401903c <altera_avalon_jtag_uart_irq+0x18c>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
 4018fec:	e0bffc17 	ldw	r2,-16(fp)
 4018ff0:	e0fffd17 	ldw	r3,-12(fp)
 4018ff4:	18c00d17 	ldw	r3,52(r3)
 4018ff8:	e13ffd17 	ldw	r4,-12(fp)
 4018ffc:	20c7883a 	add	r3,r4,r3
 4019000:	18c20e03 	ldbu	r3,2104(r3)
 4019004:	18c03fcc 	andi	r3,r3,255
 4019008:	18c0201c 	xori	r3,r3,128
 401900c:	18ffe004 	addi	r3,r3,-128
 4019010:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 4019014:	e0bffd17 	ldw	r2,-12(fp)
 4019018:	10800d17 	ldw	r2,52(r2)
 401901c:	10800044 	addi	r2,r2,1
 4019020:	10c1ffcc 	andi	r3,r2,2047
 4019024:	e0bffd17 	ldw	r2,-12(fp)
 4019028:	10c00d15 	stw	r3,52(r2)
 401902c:	0001883a 	nop

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
 4019030:	e0bffe17 	ldw	r2,-8(fp)
 4019034:	10bfffc4 	addi	r2,r2,-1
 4019038:	e0bffe15 	stw	r2,-8(fp)
      while (space > 0 && sp->tx_out != sp->tx_in)
 401903c:	e0bffe17 	ldw	r2,-8(fp)
 4019040:	10000526 	beq	r2,zero,4019058 <altera_avalon_jtag_uart_irq+0x1a8>
 4019044:	e0bffd17 	ldw	r2,-12(fp)
 4019048:	10c00d17 	ldw	r3,52(r2)
 401904c:	e0bffd17 	ldw	r2,-12(fp)
 4019050:	10800c17 	ldw	r2,48(r2)
 4019054:	18bfe51e 	bne	r3,r2,4018fec <altera_avalon_jtag_uart_irq+0x13c>
      }

      if (space > 0)
 4019058:	e0bffe17 	ldw	r2,-8(fp)
 401905c:	103f9d26 	beq	r2,zero,4018ed4 <altera_avalon_jtag_uart_irq+0x24>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 4019060:	e0bffd17 	ldw	r2,-12(fp)
 4019064:	10c00817 	ldw	r3,32(r2)
 4019068:	00bfff44 	movi	r2,-3
 401906c:	1886703a 	and	r3,r3,r2
 4019070:	e0bffd17 	ldw	r2,-12(fp)
 4019074:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 4019078:	e0bffd17 	ldw	r2,-12(fp)
 401907c:	10800017 	ldw	r2,0(r2)
 4019080:	10800104 	addi	r2,r2,4
 4019084:	1007883a 	mov	r3,r2
 4019088:	e0bffd17 	ldw	r2,-12(fp)
 401908c:	10800817 	ldw	r2,32(r2)
 4019090:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 4019094:	e0bffc17 	ldw	r2,-16(fp)
 4019098:	10800104 	addi	r2,r2,4
 401909c:	10800037 	ldwio	r2,0(r2)
  {
 40190a0:	003f8c06 	br	4018ed4 <altera_avalon_jtag_uart_irq+0x24>
      break;
 40190a4:	0001883a 	nop
      }
    }
  }
}
 40190a8:	0001883a 	nop
 40190ac:	e037883a 	mov	sp,fp
 40190b0:	df000017 	ldw	fp,0(sp)
 40190b4:	dec00104 	addi	sp,sp,4
 40190b8:	f800283a 	ret

040190bc <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
 40190bc:	defffc04 	addi	sp,sp,-16
 40190c0:	df000315 	stw	fp,12(sp)
 40190c4:	df000304 	addi	fp,sp,12
 40190c8:	e13ffd15 	stw	r4,-12(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
 40190cc:	e0bffd17 	ldw	r2,-12(fp)
 40190d0:	e0bfff15 	stw	r2,-4(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
 40190d4:	e0bfff17 	ldw	r2,-4(fp)
 40190d8:	10800017 	ldw	r2,0(r2)
 40190dc:	10800104 	addi	r2,r2,4
 40190e0:	10800037 	ldwio	r2,0(r2)
 40190e4:	e0bffe15 	stw	r2,-8(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
 40190e8:	e0bffe17 	ldw	r2,-8(fp)
 40190ec:	1081000c 	andi	r2,r2,1024
 40190f0:	10000b26 	beq	r2,zero,4019120 <altera_avalon_jtag_uart_timeout+0x64>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
 40190f4:	e0bfff17 	ldw	r2,-4(fp)
 40190f8:	10800017 	ldw	r2,0(r2)
 40190fc:	10800104 	addi	r2,r2,4
 4019100:	1007883a 	mov	r3,r2
 4019104:	e0bfff17 	ldw	r2,-4(fp)
 4019108:	10800817 	ldw	r2,32(r2)
 401910c:	10810014 	ori	r2,r2,1024
 4019110:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
 4019114:	e0bfff17 	ldw	r2,-4(fp)
 4019118:	10000915 	stw	zero,36(r2)
 401911c:	00000a06 	br	4019148 <altera_avalon_jtag_uart_timeout+0x8c>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
 4019120:	e0bfff17 	ldw	r2,-4(fp)
 4019124:	10c00917 	ldw	r3,36(r2)
 4019128:	00a00034 	movhi	r2,32768
 401912c:	10bfff04 	addi	r2,r2,-4
 4019130:	10c00536 	bltu	r2,r3,4019148 <altera_avalon_jtag_uart_timeout+0x8c>
    sp->host_inactive++;
 4019134:	e0bfff17 	ldw	r2,-4(fp)
 4019138:	10800917 	ldw	r2,36(r2)
 401913c:	10c00044 	addi	r3,r2,1
 4019140:	e0bfff17 	ldw	r2,-4(fp)
 4019144:	10c00915 	stw	r3,36(r2)
 4019148:	d0a72f17 	ldw	r2,-25412(gp)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
 401914c:	e037883a 	mov	sp,fp
 4019150:	df000017 	ldw	fp,0(sp)
 4019154:	dec00104 	addi	sp,sp,4
 4019158:	f800283a 	ret

0401915c <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
 401915c:	defffd04 	addi	sp,sp,-12
 4019160:	df000215 	stw	fp,8(sp)
 4019164:	df000204 	addi	fp,sp,8
 4019168:	e13fff15 	stw	r4,-4(fp)
 401916c:	e17ffe15 	stw	r5,-8(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 4019170:	00000506 	br	4019188 <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
 4019174:	e0bffe17 	ldw	r2,-8(fp)
 4019178:	1090000c 	andi	r2,r2,16384
 401917c:	10000226 	beq	r2,zero,4019188 <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
 4019180:	00bffd44 	movi	r2,-11
 4019184:	00000b06 	br	40191b4 <altera_avalon_jtag_uart_close+0x58>
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 4019188:	e0bfff17 	ldw	r2,-4(fp)
 401918c:	10c00d17 	ldw	r3,52(r2)
 4019190:	e0bfff17 	ldw	r2,-4(fp)
 4019194:	10800c17 	ldw	r2,48(r2)
 4019198:	18800526 	beq	r3,r2,40191b0 <altera_avalon_jtag_uart_close+0x54>
 401919c:	e0bfff17 	ldw	r2,-4(fp)
 40191a0:	10c00917 	ldw	r3,36(r2)
 40191a4:	e0bfff17 	ldw	r2,-4(fp)
 40191a8:	10800117 	ldw	r2,4(r2)
 40191ac:	18bff136 	bltu	r3,r2,4019174 <altera_avalon_jtag_uart_close+0x18>
    }
  }

  return 0;
 40191b0:	0005883a 	mov	r2,zero
}
 40191b4:	e037883a 	mov	sp,fp
 40191b8:	df000017 	ldw	fp,0(sp)
 40191bc:	dec00104 	addi	sp,sp,4
 40191c0:	f800283a 	ret

040191c4 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
 40191c4:	defffa04 	addi	sp,sp,-24
 40191c8:	df000515 	stw	fp,20(sp)
 40191cc:	df000504 	addi	fp,sp,20
 40191d0:	e13ffd15 	stw	r4,-12(fp)
 40191d4:	e17ffc15 	stw	r5,-16(fp)
 40191d8:	e1bffb15 	stw	r6,-20(fp)
  int rc = -ENOTTY;
 40191dc:	00bff9c4 	movi	r2,-25
 40191e0:	e0bfff15 	stw	r2,-4(fp)

  switch (req)
 40191e4:	e0bffc17 	ldw	r2,-16(fp)
 40191e8:	109a8060 	cmpeqi	r2,r2,27137
 40191ec:	1000041e 	bne	r2,zero,4019200 <altera_avalon_jtag_uart_ioctl+0x3c>
 40191f0:	e0bffc17 	ldw	r2,-16(fp)
 40191f4:	109a80a0 	cmpeqi	r2,r2,27138
 40191f8:	1000181e 	bne	r2,zero,401925c <altera_avalon_jtag_uart_ioctl+0x98>
      rc = 0;
    }
    break;

  default:
    break;
 40191fc:	00002906 	br	40192a4 <altera_avalon_jtag_uart_ioctl+0xe0>
    if (sp->timeout != INT_MAX)
 4019200:	e0bffd17 	ldw	r2,-12(fp)
 4019204:	10c00117 	ldw	r3,4(r2)
 4019208:	00a00034 	movhi	r2,32768
 401920c:	10bfffc4 	addi	r2,r2,-1
 4019210:	18802126 	beq	r3,r2,4019298 <altera_avalon_jtag_uart_ioctl+0xd4>
      int timeout = *((int *)arg);
 4019214:	e0bffb17 	ldw	r2,-20(fp)
 4019218:	10800017 	ldw	r2,0(r2)
 401921c:	e0bffe15 	stw	r2,-8(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
 4019220:	e0bffe17 	ldw	r2,-8(fp)
 4019224:	10800090 	cmplti	r2,r2,2
 4019228:	1000061e 	bne	r2,zero,4019244 <altera_avalon_jtag_uart_ioctl+0x80>
 401922c:	e0fffe17 	ldw	r3,-8(fp)
 4019230:	00a00034 	movhi	r2,32768
 4019234:	10bfffc4 	addi	r2,r2,-1
 4019238:	18800226 	beq	r3,r2,4019244 <altera_avalon_jtag_uart_ioctl+0x80>
 401923c:	e0bffe17 	ldw	r2,-8(fp)
 4019240:	00000206 	br	401924c <altera_avalon_jtag_uart_ioctl+0x88>
 4019244:	00a00034 	movhi	r2,32768
 4019248:	10bfff84 	addi	r2,r2,-2
 401924c:	e0fffd17 	ldw	r3,-12(fp)
 4019250:	18800115 	stw	r2,4(r3)
      rc = 0;
 4019254:	e03fff15 	stw	zero,-4(fp)
    break;
 4019258:	00000f06 	br	4019298 <altera_avalon_jtag_uart_ioctl+0xd4>
    if (sp->timeout != INT_MAX)
 401925c:	e0bffd17 	ldw	r2,-12(fp)
 4019260:	10c00117 	ldw	r3,4(r2)
 4019264:	00a00034 	movhi	r2,32768
 4019268:	10bfffc4 	addi	r2,r2,-1
 401926c:	18800c26 	beq	r3,r2,40192a0 <altera_avalon_jtag_uart_ioctl+0xdc>
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
 4019270:	e0bffd17 	ldw	r2,-12(fp)
 4019274:	10c00917 	ldw	r3,36(r2)
 4019278:	e0bffd17 	ldw	r2,-12(fp)
 401927c:	10800117 	ldw	r2,4(r2)
 4019280:	1885803a 	cmpltu	r2,r3,r2
 4019284:	10c03fcc 	andi	r3,r2,255
 4019288:	e0bffb17 	ldw	r2,-20(fp)
 401928c:	10c00015 	stw	r3,0(r2)
      rc = 0;
 4019290:	e03fff15 	stw	zero,-4(fp)
    break;
 4019294:	00000206 	br	40192a0 <altera_avalon_jtag_uart_ioctl+0xdc>
    break;
 4019298:	0001883a 	nop
 401929c:	00000106 	br	40192a4 <altera_avalon_jtag_uart_ioctl+0xe0>
    break;
 40192a0:	0001883a 	nop
  }

  return rc;
 40192a4:	e0bfff17 	ldw	r2,-4(fp)
}
 40192a8:	e037883a 	mov	sp,fp
 40192ac:	df000017 	ldw	fp,0(sp)
 40192b0:	dec00104 	addi	sp,sp,4
 40192b4:	f800283a 	ret

040192b8 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
 40192b8:	defff304 	addi	sp,sp,-52
 40192bc:	dfc00c15 	stw	ra,48(sp)
 40192c0:	df000b15 	stw	fp,44(sp)
 40192c4:	df000b04 	addi	fp,sp,44
 40192c8:	e13ff815 	stw	r4,-32(fp)
 40192cc:	e17ff715 	stw	r5,-36(fp)
 40192d0:	e1bff615 	stw	r6,-40(fp)
 40192d4:	e1fff515 	stw	r7,-44(fp)
  char * ptr = buffer;
 40192d8:	e0bff717 	ldw	r2,-36(fp)
 40192dc:	e0bfff15 	stw	r2,-4(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 40192e0:	00004706 	br	4019400 <altera_avalon_jtag_uart_read+0x148>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
 40192e4:	e0bff817 	ldw	r2,-32(fp)
 40192e8:	10800a17 	ldw	r2,40(r2)
 40192ec:	e0bffd15 	stw	r2,-12(fp)
      out = sp->rx_out;
 40192f0:	e0bff817 	ldw	r2,-32(fp)
 40192f4:	10800b17 	ldw	r2,44(r2)
 40192f8:	e0bffc15 	stw	r2,-16(fp)

      if (in >= out)
 40192fc:	e0fffd17 	ldw	r3,-12(fp)
 4019300:	e0bffc17 	ldw	r2,-16(fp)
 4019304:	18800536 	bltu	r3,r2,401931c <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
 4019308:	e0fffd17 	ldw	r3,-12(fp)
 401930c:	e0bffc17 	ldw	r2,-16(fp)
 4019310:	1885c83a 	sub	r2,r3,r2
 4019314:	e0bffe15 	stw	r2,-8(fp)
 4019318:	00000406 	br	401932c <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
 401931c:	00c20004 	movi	r3,2048
 4019320:	e0bffc17 	ldw	r2,-16(fp)
 4019324:	1885c83a 	sub	r2,r3,r2
 4019328:	e0bffe15 	stw	r2,-8(fp)

      if (n == 0)
 401932c:	e0bffe17 	ldw	r2,-8(fp)
 4019330:	10001e26 	beq	r2,zero,40193ac <altera_avalon_jtag_uart_read+0xf4>
        break; /* No more data available */

      if (n > space)
 4019334:	e0fff617 	ldw	r3,-40(fp)
 4019338:	e0bffe17 	ldw	r2,-8(fp)
 401933c:	1880022e 	bgeu	r3,r2,4019348 <altera_avalon_jtag_uart_read+0x90>
        n = space;
 4019340:	e0bff617 	ldw	r2,-40(fp)
 4019344:	e0bffe15 	stw	r2,-8(fp)

      memcpy(ptr, sp->rx_buf + out, n);
 4019348:	e0bff817 	ldw	r2,-32(fp)
 401934c:	10c00e04 	addi	r3,r2,56
 4019350:	e0bffc17 	ldw	r2,-16(fp)
 4019354:	1885883a 	add	r2,r3,r2
 4019358:	e1bffe17 	ldw	r6,-8(fp)
 401935c:	100b883a 	mov	r5,r2
 4019360:	e13fff17 	ldw	r4,-4(fp)
 4019364:	40075cc0 	call	40075cc <memcpy>
      ptr   += n;
 4019368:	e0ffff17 	ldw	r3,-4(fp)
 401936c:	e0bffe17 	ldw	r2,-8(fp)
 4019370:	1885883a 	add	r2,r3,r2
 4019374:	e0bfff15 	stw	r2,-4(fp)
      space -= n;
 4019378:	e0fff617 	ldw	r3,-40(fp)
 401937c:	e0bffe17 	ldw	r2,-8(fp)
 4019380:	1885c83a 	sub	r2,r3,r2
 4019384:	e0bff615 	stw	r2,-40(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 4019388:	e0fffc17 	ldw	r3,-16(fp)
 401938c:	e0bffe17 	ldw	r2,-8(fp)
 4019390:	1885883a 	add	r2,r3,r2
 4019394:	10c1ffcc 	andi	r3,r2,2047
 4019398:	e0bff817 	ldw	r2,-32(fp)
 401939c:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
 40193a0:	e0bff617 	ldw	r2,-40(fp)
 40193a4:	00bfcf16 	blt	zero,r2,40192e4 <altera_avalon_jtag_uart_read+0x2c>
 40193a8:	00000106 	br	40193b0 <altera_avalon_jtag_uart_read+0xf8>
        break; /* No more data available */
 40193ac:	0001883a 	nop

    /* If we read any data then return it */
    if (ptr != buffer)
 40193b0:	e0ffff17 	ldw	r3,-4(fp)
 40193b4:	e0bff717 	ldw	r2,-36(fp)
 40193b8:	1880141e 	bne	r3,r2,401940c <altera_avalon_jtag_uart_read+0x154>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
 40193bc:	e0bff517 	ldw	r2,-44(fp)
 40193c0:	1090000c 	andi	r2,r2,16384
 40193c4:	1000131e 	bne	r2,zero,4019414 <altera_avalon_jtag_uart_read+0x15c>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
 40193c8:	0001883a 	nop
 40193cc:	e0bff817 	ldw	r2,-32(fp)
 40193d0:	10800a17 	ldw	r2,40(r2)
 40193d4:	e0fffd17 	ldw	r3,-12(fp)
 40193d8:	1880051e 	bne	r3,r2,40193f0 <altera_avalon_jtag_uart_read+0x138>
 40193dc:	e0bff817 	ldw	r2,-32(fp)
 40193e0:	10c00917 	ldw	r3,36(r2)
 40193e4:	e0bff817 	ldw	r2,-32(fp)
 40193e8:	10800117 	ldw	r2,4(r2)
 40193ec:	18bff736 	bltu	r3,r2,40193cc <altera_avalon_jtag_uart_read+0x114>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
 40193f0:	e0bff817 	ldw	r2,-32(fp)
 40193f4:	10800a17 	ldw	r2,40(r2)
 40193f8:	e0fffd17 	ldw	r3,-12(fp)
 40193fc:	18800726 	beq	r3,r2,401941c <altera_avalon_jtag_uart_read+0x164>
  while (space > 0)
 4019400:	e0bff617 	ldw	r2,-40(fp)
 4019404:	00bfb716 	blt	zero,r2,40192e4 <altera_avalon_jtag_uart_read+0x2c>
 4019408:	00000506 	br	4019420 <altera_avalon_jtag_uart_read+0x168>
      break;
 401940c:	0001883a 	nop
 4019410:	00000306 	br	4019420 <altera_avalon_jtag_uart_read+0x168>
      break;
 4019414:	0001883a 	nop
 4019418:	00000106 	br	4019420 <altera_avalon_jtag_uart_read+0x168>
      break;
 401941c:	0001883a 	nop
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
 4019420:	e0ffff17 	ldw	r3,-4(fp)
 4019424:	e0bff717 	ldw	r2,-36(fp)
 4019428:	18801926 	beq	r3,r2,4019490 <altera_avalon_jtag_uart_read+0x1d8>
  NIOS2_READ_STATUS (context);
 401942c:	0005303a 	rdctl	r2,status
 4019430:	e0bff915 	stw	r2,-28(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 4019434:	e0fff917 	ldw	r3,-28(fp)
 4019438:	00bfff84 	movi	r2,-2
 401943c:	1884703a 	and	r2,r3,r2
 4019440:	1001703a 	wrctl	status,r2
  return context;
 4019444:	e0bff917 	ldw	r2,-28(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
 4019448:	e0bffb15 	stw	r2,-20(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 401944c:	e0bff817 	ldw	r2,-32(fp)
 4019450:	10800817 	ldw	r2,32(r2)
 4019454:	10c00054 	ori	r3,r2,1
 4019458:	e0bff817 	ldw	r2,-32(fp)
 401945c:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 4019460:	e0bff817 	ldw	r2,-32(fp)
 4019464:	10800017 	ldw	r2,0(r2)
 4019468:	10800104 	addi	r2,r2,4
 401946c:	1007883a 	mov	r3,r2
 4019470:	e0bff817 	ldw	r2,-32(fp)
 4019474:	10800817 	ldw	r2,32(r2)
 4019478:	18800035 	stwio	r2,0(r3)
 401947c:	e0bffb17 	ldw	r2,-20(fp)
 4019480:	e0bffa15 	stw	r2,-24(fp)
  NIOS2_WRITE_STATUS (context);
 4019484:	e0bffa17 	ldw	r2,-24(fp)
 4019488:	1001703a 	wrctl	status,r2
}
 401948c:	0001883a 	nop
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
 4019490:	e0ffff17 	ldw	r3,-4(fp)
 4019494:	e0bff717 	ldw	r2,-36(fp)
 4019498:	18800426 	beq	r3,r2,40194ac <altera_avalon_jtag_uart_read+0x1f4>
    return ptr - buffer;
 401949c:	e0ffff17 	ldw	r3,-4(fp)
 40194a0:	e0bff717 	ldw	r2,-36(fp)
 40194a4:	1885c83a 	sub	r2,r3,r2
 40194a8:	00000606 	br	40194c4 <altera_avalon_jtag_uart_read+0x20c>
  else if (flags & O_NONBLOCK)
 40194ac:	e0bff517 	ldw	r2,-44(fp)
 40194b0:	1090000c 	andi	r2,r2,16384
 40194b4:	10000226 	beq	r2,zero,40194c0 <altera_avalon_jtag_uart_read+0x208>
    return -EWOULDBLOCK;
 40194b8:	00bffd44 	movi	r2,-11
 40194bc:	00000106 	br	40194c4 <altera_avalon_jtag_uart_read+0x20c>
  else
    return -EIO;
 40194c0:	00bffec4 	movi	r2,-5
}
 40194c4:	e037883a 	mov	sp,fp
 40194c8:	dfc00117 	ldw	ra,4(sp)
 40194cc:	df000017 	ldw	fp,0(sp)
 40194d0:	dec00204 	addi	sp,sp,8
 40194d4:	f800283a 	ret

040194d8 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 40194d8:	defff304 	addi	sp,sp,-52
 40194dc:	dfc00c15 	stw	ra,48(sp)
 40194e0:	df000b15 	stw	fp,44(sp)
 40194e4:	df000b04 	addi	fp,sp,44
 40194e8:	e13ff815 	stw	r4,-32(fp)
 40194ec:	e17ff715 	stw	r5,-36(fp)
 40194f0:	e1bff615 	stw	r6,-40(fp)
 40194f4:	e1fff515 	stw	r7,-44(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
 40194f8:	e03fff15 	stw	zero,-4(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
 40194fc:	e0bff717 	ldw	r2,-36(fp)
 4019500:	e0bffd15 	stw	r2,-12(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 4019504:	00003706 	br	40195e4 <altera_avalon_jtag_uart_write+0x10c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
 4019508:	e0bff817 	ldw	r2,-32(fp)
 401950c:	10800c17 	ldw	r2,48(r2)
 4019510:	e0bffc15 	stw	r2,-16(fp)
      out = sp->tx_out;
 4019514:	e0bff817 	ldw	r2,-32(fp)
 4019518:	10800d17 	ldw	r2,52(r2)
 401951c:	e0bfff15 	stw	r2,-4(fp)

      if (in < out)
 4019520:	e0fffc17 	ldw	r3,-16(fp)
 4019524:	e0bfff17 	ldw	r2,-4(fp)
 4019528:	1880062e 	bgeu	r3,r2,4019544 <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
 401952c:	e0ffff17 	ldw	r3,-4(fp)
 4019530:	e0bffc17 	ldw	r2,-16(fp)
 4019534:	1885c83a 	sub	r2,r3,r2
 4019538:	10bfffc4 	addi	r2,r2,-1
 401953c:	e0bffe15 	stw	r2,-8(fp)
 4019540:	00000b06 	br	4019570 <altera_avalon_jtag_uart_write+0x98>
      else if (out > 0)
 4019544:	e0bfff17 	ldw	r2,-4(fp)
 4019548:	10000526 	beq	r2,zero,4019560 <altera_avalon_jtag_uart_write+0x88>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
 401954c:	00c20004 	movi	r3,2048
 4019550:	e0bffc17 	ldw	r2,-16(fp)
 4019554:	1885c83a 	sub	r2,r3,r2
 4019558:	e0bffe15 	stw	r2,-8(fp)
 401955c:	00000406 	br	4019570 <altera_avalon_jtag_uart_write+0x98>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
 4019560:	00c1ffc4 	movi	r3,2047
 4019564:	e0bffc17 	ldw	r2,-16(fp)
 4019568:	1885c83a 	sub	r2,r3,r2
 401956c:	e0bffe15 	stw	r2,-8(fp)

      if (n == 0)
 4019570:	e0bffe17 	ldw	r2,-8(fp)
 4019574:	10001e26 	beq	r2,zero,40195f0 <altera_avalon_jtag_uart_write+0x118>
        break;

      if (n > count)
 4019578:	e0fff617 	ldw	r3,-40(fp)
 401957c:	e0bffe17 	ldw	r2,-8(fp)
 4019580:	1880022e 	bgeu	r3,r2,401958c <altera_avalon_jtag_uart_write+0xb4>
        n = count;
 4019584:	e0bff617 	ldw	r2,-40(fp)
 4019588:	e0bffe15 	stw	r2,-8(fp)

      memcpy(sp->tx_buf + in, ptr, n);
 401958c:	e0bff817 	ldw	r2,-32(fp)
 4019590:	10c20e04 	addi	r3,r2,2104
 4019594:	e0bffc17 	ldw	r2,-16(fp)
 4019598:	1885883a 	add	r2,r3,r2
 401959c:	e1bffe17 	ldw	r6,-8(fp)
 40195a0:	e17ff717 	ldw	r5,-36(fp)
 40195a4:	1009883a 	mov	r4,r2
 40195a8:	40075cc0 	call	40075cc <memcpy>
      ptr   += n;
 40195ac:	e0fff717 	ldw	r3,-36(fp)
 40195b0:	e0bffe17 	ldw	r2,-8(fp)
 40195b4:	1885883a 	add	r2,r3,r2
 40195b8:	e0bff715 	stw	r2,-36(fp)
      count -= n;
 40195bc:	e0fff617 	ldw	r3,-40(fp)
 40195c0:	e0bffe17 	ldw	r2,-8(fp)
 40195c4:	1885c83a 	sub	r2,r3,r2
 40195c8:	e0bff615 	stw	r2,-40(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 40195cc:	e0fffc17 	ldw	r3,-16(fp)
 40195d0:	e0bffe17 	ldw	r2,-8(fp)
 40195d4:	1885883a 	add	r2,r3,r2
 40195d8:	10c1ffcc 	andi	r3,r2,2047
 40195dc:	e0bff817 	ldw	r2,-32(fp)
 40195e0:	10c00c15 	stw	r3,48(r2)
    while (count > 0)
 40195e4:	e0bff617 	ldw	r2,-40(fp)
 40195e8:	00bfc716 	blt	zero,r2,4019508 <altera_avalon_jtag_uart_write+0x30>
 40195ec:	00000106 	br	40195f4 <altera_avalon_jtag_uart_write+0x11c>
        break;
 40195f0:	0001883a 	nop
  NIOS2_READ_STATUS (context);
 40195f4:	0005303a 	rdctl	r2,status
 40195f8:	e0bff915 	stw	r2,-28(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 40195fc:	e0fff917 	ldw	r3,-28(fp)
 4019600:	00bfff84 	movi	r2,-2
 4019604:	1884703a 	and	r2,r3,r2
 4019608:	1001703a 	wrctl	status,r2
  return context;
 401960c:	e0bff917 	ldw	r2,-28(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
 4019610:	e0bffb15 	stw	r2,-20(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 4019614:	e0bff817 	ldw	r2,-32(fp)
 4019618:	10800817 	ldw	r2,32(r2)
 401961c:	10c00094 	ori	r3,r2,2
 4019620:	e0bff817 	ldw	r2,-32(fp)
 4019624:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 4019628:	e0bff817 	ldw	r2,-32(fp)
 401962c:	10800017 	ldw	r2,0(r2)
 4019630:	10800104 	addi	r2,r2,4
 4019634:	1007883a 	mov	r3,r2
 4019638:	e0bff817 	ldw	r2,-32(fp)
 401963c:	10800817 	ldw	r2,32(r2)
 4019640:	18800035 	stwio	r2,0(r3)
 4019644:	e0bffb17 	ldw	r2,-20(fp)
 4019648:	e0bffa15 	stw	r2,-24(fp)
  NIOS2_WRITE_STATUS (context);
 401964c:	e0bffa17 	ldw	r2,-24(fp)
 4019650:	1001703a 	wrctl	status,r2
}
 4019654:	0001883a 	nop
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
 4019658:	e0bff617 	ldw	r2,-40(fp)
 401965c:	0080100e 	bge	zero,r2,40196a0 <altera_avalon_jtag_uart_write+0x1c8>
    {
      if (flags & O_NONBLOCK)
 4019660:	e0bff517 	ldw	r2,-44(fp)
 4019664:	1090000c 	andi	r2,r2,16384
 4019668:	1000101e 	bne	r2,zero,40196ac <altera_avalon_jtag_uart_write+0x1d4>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
 401966c:	0001883a 	nop
 4019670:	e0bff817 	ldw	r2,-32(fp)
 4019674:	10800d17 	ldw	r2,52(r2)
 4019678:	e0ffff17 	ldw	r3,-4(fp)
 401967c:	1880051e 	bne	r3,r2,4019694 <altera_avalon_jtag_uart_write+0x1bc>
 4019680:	e0bff817 	ldw	r2,-32(fp)
 4019684:	10c00917 	ldw	r3,36(r2)
 4019688:	e0bff817 	ldw	r2,-32(fp)
 401968c:	10800117 	ldw	r2,4(r2)
 4019690:	18bff736 	bltu	r3,r2,4019670 <altera_avalon_jtag_uart_write+0x198>
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
 4019694:	e0bff817 	ldw	r2,-32(fp)
 4019698:	10800917 	ldw	r2,36(r2)
 401969c:	1000051e 	bne	r2,zero,40196b4 <altera_avalon_jtag_uart_write+0x1dc>
         break;
    }
  }
  while (count > 0);
 40196a0:	e0bff617 	ldw	r2,-40(fp)
 40196a4:	00bfcf16 	blt	zero,r2,40195e4 <altera_avalon_jtag_uart_write+0x10c>
 40196a8:	00000306 	br	40196b8 <altera_avalon_jtag_uart_write+0x1e0>
        break;
 40196ac:	0001883a 	nop
 40196b0:	00000106 	br	40196b8 <altera_avalon_jtag_uart_write+0x1e0>
         break;
 40196b4:	0001883a 	nop
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
 40196b8:	e0fff717 	ldw	r3,-36(fp)
 40196bc:	e0bffd17 	ldw	r2,-12(fp)
 40196c0:	18800426 	beq	r3,r2,40196d4 <altera_avalon_jtag_uart_write+0x1fc>
    return ptr - start;
 40196c4:	e0fff717 	ldw	r3,-36(fp)
 40196c8:	e0bffd17 	ldw	r2,-12(fp)
 40196cc:	1885c83a 	sub	r2,r3,r2
 40196d0:	00000606 	br	40196ec <altera_avalon_jtag_uart_write+0x214>
  else if (flags & O_NONBLOCK)
 40196d4:	e0bff517 	ldw	r2,-44(fp)
 40196d8:	1090000c 	andi	r2,r2,16384
 40196dc:	10000226 	beq	r2,zero,40196e8 <altera_avalon_jtag_uart_write+0x210>
    return -EWOULDBLOCK;
 40196e0:	00bffd44 	movi	r2,-11
 40196e4:	00000106 	br	40196ec <altera_avalon_jtag_uart_write+0x214>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
 40196e8:	00bffec4 	movi	r2,-5
}
 40196ec:	e037883a 	mov	sp,fp
 40196f0:	dfc00117 	ldw	ra,4(sp)
 40196f4:	df000017 	ldw	fp,0(sp)
 40196f8:	dec00204 	addi	sp,sp,8
 40196fc:	f800283a 	ret

04019700 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
 4019700:	defffa04 	addi	sp,sp,-24
 4019704:	dfc00515 	stw	ra,20(sp)
 4019708:	df000415 	stw	fp,16(sp)
 401970c:	df000404 	addi	fp,sp,16
 4019710:	e13ffc15 	stw	r4,-16(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
 4019714:	0007883a 	mov	r3,zero
 4019718:	e0bffc17 	ldw	r2,-16(fp)
 401971c:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
 4019720:	e0bffc17 	ldw	r2,-16(fp)
 4019724:	10800104 	addi	r2,r2,4
 4019728:	10800037 	ldwio	r2,0(r2)
  NIOS2_READ_STATUS (context);
 401972c:	0005303a 	rdctl	r2,status
 4019730:	e0bffd15 	stw	r2,-12(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 4019734:	e0fffd17 	ldw	r3,-12(fp)
 4019738:	00bfff84 	movi	r2,-2
 401973c:	1884703a 	and	r2,r3,r2
 4019740:	1001703a 	wrctl	status,r2
  return context;
 4019744:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
 4019748:	e0bfff15 	stw	r2,-4(fp)
  alt_tick ();
 401974c:	401a4800 	call	401a480 <alt_tick>
 4019750:	e0bfff17 	ldw	r2,-4(fp)
 4019754:	e0bffe15 	stw	r2,-8(fp)
  NIOS2_WRITE_STATUS (context);
 4019758:	e0bffe17 	ldw	r2,-8(fp)
 401975c:	1001703a 	wrctl	status,r2
}
 4019760:	0001883a 	nop
  alt_irq_enable_all(cpu_sr);
}
 4019764:	0001883a 	nop
 4019768:	e037883a 	mov	sp,fp
 401976c:	dfc00117 	ldw	ra,4(sp)
 4019770:	df000017 	ldw	fp,0(sp)
 4019774:	dec00204 	addi	sp,sp,8
 4019778:	f800283a 	ret

0401977c <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
 401977c:	defff804 	addi	sp,sp,-32
 4019780:	dfc00715 	stw	ra,28(sp)
 4019784:	df000615 	stw	fp,24(sp)
 4019788:	df000604 	addi	fp,sp,24
 401978c:	e13ffe15 	stw	r4,-8(fp)
 4019790:	e17ffd15 	stw	r5,-12(fp)
 4019794:	e1bffc15 	stw	r6,-16(fp)
 4019798:	e1fffb15 	stw	r7,-20(fp)
 401979c:	e0bffb17 	ldw	r2,-20(fp)
 40197a0:	e0bfff15 	stw	r2,-4(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
 40197a4:	d0a72f17 	ldw	r2,-25412(gp)
 40197a8:	1000031e 	bne	r2,zero,40197b8 <alt_avalon_timer_sc_init+0x3c>
  {
    _alt_tick_rate = nticks;
 40197ac:	e0bfff17 	ldw	r2,-4(fp)
 40197b0:	d0a72f15 	stw	r2,-25412(gp)
    return 0;
 40197b4:	00000106 	br	40197bc <alt_avalon_timer_sc_init+0x40>
  }
  else
  {
    return -1;
 40197b8:	0001883a 	nop
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
 40197bc:	e0bffe17 	ldw	r2,-8(fp)
 40197c0:	10800104 	addi	r2,r2,4
 40197c4:	00c001c4 	movi	r3,7
 40197c8:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
 40197cc:	d8000015 	stw	zero,0(sp)
 40197d0:	e1fffe17 	ldw	r7,-8(fp)
 40197d4:	018100b4 	movhi	r6,1026
 40197d8:	31a5c004 	addi	r6,r6,-26880
 40197dc:	e17ffc17 	ldw	r5,-16(fp)
 40197e0:	e13ffd17 	ldw	r4,-12(fp)
 40197e4:	40180480 	call	4018048 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
 40197e8:	0001883a 	nop
 40197ec:	e037883a 	mov	sp,fp
 40197f0:	dfc00117 	ldw	ra,4(sp)
 40197f4:	df000017 	ldw	fp,0(sp)
 40197f8:	dec00204 	addi	sp,sp,8
 40197fc:	f800283a 	ret

04019800 <alt_up_accelerometer_spi_open_dev>:

#include "altera_up_avalon_accelerometer_spi.h"
#include "altera_up_avalon_accelerometer_spi_regs.h"

alt_up_accelerometer_spi_dev* alt_up_accelerometer_spi_open_dev(const char* name)
{
 4019800:	defffc04 	addi	sp,sp,-16
 4019804:	dfc00315 	stw	ra,12(sp)
 4019808:	df000215 	stw	fp,8(sp)
 401980c:	df000204 	addi	fp,sp,8
 4019810:	e13ffe15 	stw	r4,-8(fp)
  // find the device from the device list 
  // (see altera_hal/HAL/inc/priv/alt_file.h 
  // and altera_hal/HAL/src/alt_find_dev.c 
  // for details)
  alt_up_accelerometer_spi_dev *dev = (alt_up_accelerometer_spi_dev*)alt_find_dev(name, &alt_dev_list);
 4019814:	d1600704 	addi	r5,gp,-32740
 4019818:	e13ffe17 	ldw	r4,-8(fp)
 401981c:	4019ecc0 	call	4019ecc <alt_find_dev>
 4019820:	e0bfff15 	stw	r2,-4(fp)

  return dev;
 4019824:	e0bfff17 	ldw	r2,-4(fp)
}
 4019828:	e037883a 	mov	sp,fp
 401982c:	dfc00117 	ldw	ra,4(sp)
 4019830:	df000017 	ldw	fp,0(sp)
 4019834:	dec00204 	addi	sp,sp,8
 4019838:	f800283a 	ret

0401983c <alt_up_accelerometer_spi_read_address_register>:
 * @param addr -- a pointer to the location where the read address should be stored
 *
 * @return 0 for success 
 **/
int alt_up_accelerometer_spi_read_address_register(alt_up_accelerometer_spi_dev *accel_spi, alt_u8 *addr)
{
 401983c:	defffd04 	addi	sp,sp,-12
 4019840:	df000215 	stw	fp,8(sp)
 4019844:	df000204 	addi	fp,sp,8
 4019848:	e13fff15 	stw	r4,-4(fp)
 401984c:	e17ffe15 	stw	r5,-8(fp)
	// reads data from the device Address register
	*(addr) = IORD_ALT_UP_ACCELEROMETER_SPI_ADDRESS(accel_spi->base); 
 4019850:	e0bfff17 	ldw	r2,-4(fp)
 4019854:	10800a17 	ldw	r2,40(r2)
 4019858:	10800023 	ldbuio	r2,0(r2)
 401985c:	10803fcc 	andi	r2,r2,255
 4019860:	1007883a 	mov	r3,r2
 4019864:	e0bffe17 	ldw	r2,-8(fp)
 4019868:	10c00005 	stb	r3,0(r2)

	return 0;
 401986c:	0005883a 	mov	r2,zero
}
 4019870:	e037883a 	mov	sp,fp
 4019874:	df000017 	ldw	fp,0(sp)
 4019878:	dec00104 	addi	sp,sp,4
 401987c:	f800283a 	ret

04019880 <alt_up_accelerometer_spi_read>:
 * @param data -- a pointer to the location where the read data should be stored
 *
 * @return 0 for success
 **/
int alt_up_accelerometer_spi_read(alt_up_accelerometer_spi_dev *accel_spi, alt_u8 addr, alt_u8 *data)
{
 4019880:	defffc04 	addi	sp,sp,-16
 4019884:	df000315 	stw	fp,12(sp)
 4019888:	df000304 	addi	fp,sp,12
 401988c:	e13fff15 	stw	r4,-4(fp)
 4019890:	2805883a 	mov	r2,r5
 4019894:	e1bffd15 	stw	r6,-12(fp)
 4019898:	e0bffe05 	stb	r2,-8(fp)
	// set the register address in the Address register
	IOWR_ALT_UP_ACCELEROMETER_SPI_ADDRESS(accel_spi->base, addr & ALT_UP_ACCELEROMETER_SPI_ADDRESS_ADDR_MSK); 
 401989c:	e0bfff17 	ldw	r2,-4(fp)
 40198a0:	10800a17 	ldw	r2,40(r2)
 40198a4:	1007883a 	mov	r3,r2
 40198a8:	e0bffe03 	ldbu	r2,-8(fp)
 40198ac:	10800fcc 	andi	r2,r2,63
 40198b0:	18800025 	stbio	r2,0(r3)

	// read data to the device Data register
	*(data) = IORD_ALT_UP_ACCELEROMETER_SPI_DATA(accel_spi->base) & ALT_UP_ACCELEROMETER_SPI_DATA_DATA_MSK;
 40198b4:	e0bfff17 	ldw	r2,-4(fp)
 40198b8:	10800a17 	ldw	r2,40(r2)
 40198bc:	10800044 	addi	r2,r2,1
 40198c0:	10800023 	ldbuio	r2,0(r2)
 40198c4:	10803fcc 	andi	r2,r2,255
 40198c8:	1007883a 	mov	r3,r2
 40198cc:	e0bffd17 	ldw	r2,-12(fp)
 40198d0:	10c00005 	stb	r3,0(r2)

	return 0;
 40198d4:	0005883a 	mov	r2,zero
}
 40198d8:	e037883a 	mov	sp,fp
 40198dc:	df000017 	ldw	fp,0(sp)
 40198e0:	dec00104 	addi	sp,sp,4
 40198e4:	f800283a 	ret

040198e8 <alt_up_accelerometer_spi_write>:
 * @param data -- the data to be written
 *
 * @return 0 for success
 **/
int alt_up_accelerometer_spi_write(alt_up_accelerometer_spi_dev *accel_spi, alt_u8 addr, alt_u8 data)
{
 40198e8:	defffc04 	addi	sp,sp,-16
 40198ec:	df000315 	stw	fp,12(sp)
 40198f0:	df000304 	addi	fp,sp,12
 40198f4:	e13fff15 	stw	r4,-4(fp)
 40198f8:	2805883a 	mov	r2,r5
 40198fc:	3007883a 	mov	r3,r6
 4019900:	e0bffe05 	stb	r2,-8(fp)
 4019904:	1805883a 	mov	r2,r3
 4019908:	e0bffd05 	stb	r2,-12(fp)
	// set the register address in the Address register
	IOWR_ALT_UP_ACCELEROMETER_SPI_ADDRESS(accel_spi->base, addr & ALT_UP_ACCELEROMETER_SPI_ADDRESS_ADDR_MSK); 
 401990c:	e0bfff17 	ldw	r2,-4(fp)
 4019910:	10800a17 	ldw	r2,40(r2)
 4019914:	1007883a 	mov	r3,r2
 4019918:	e0bffe03 	ldbu	r2,-8(fp)
 401991c:	10800fcc 	andi	r2,r2,63
 4019920:	18800025 	stbio	r2,0(r3)

	// write data to the device Data register
	IOWR_ALT_UP_ACCELEROMETER_SPI_DATA(accel_spi->base, data & ALT_UP_ACCELEROMETER_SPI_DATA_DATA_MSK); 
 4019924:	e0bfff17 	ldw	r2,-4(fp)
 4019928:	10800a17 	ldw	r2,40(r2)
 401992c:	10800044 	addi	r2,r2,1
 4019930:	1007883a 	mov	r3,r2
 4019934:	e0bffd03 	ldbu	r2,-12(fp)
 4019938:	18800025 	stbio	r2,0(r3)

	return 0;
 401993c:	0005883a 	mov	r2,zero
}
 4019940:	e037883a 	mov	sp,fp
 4019944:	df000017 	ldw	fp,0(sp)
 4019948:	dec00104 	addi	sp,sp,4
 401994c:	f800283a 	ret

04019950 <alt_up_accelerometer_spi_read_x_axis>:
 * @param x_axis -- a pointer to the location where the x axis data should be stored
 *
 * @return 0 for success or -1 for failure
 **/
int alt_up_accelerometer_spi_read_x_axis(alt_up_accelerometer_spi_dev *accel_spi, alt_32 *x_axis)
{
 4019950:	defffd04 	addi	sp,sp,-12
 4019954:	df000215 	stw	fp,8(sp)
 4019958:	df000204 	addi	fp,sp,8
 401995c:	e13fff15 	stw	r4,-4(fp)
 4019960:	e17ffe15 	stw	r5,-8(fp)
	// set the register address in the Address register
	IOWR_ALT_UP_ACCELEROMETER_SPI_ADDRESS(accel_spi->base, ACCELEROMETER_SPI_X_AXIS_LOWER_BYTE & ALT_UP_ACCELEROMETER_SPI_ADDRESS_ADDR_MSK); 
 4019964:	e0bfff17 	ldw	r2,-4(fp)
 4019968:	10800a17 	ldw	r2,40(r2)
 401996c:	1007883a 	mov	r3,r2
 4019970:	00800c84 	movi	r2,50
 4019974:	18800025 	stbio	r2,0(r3)

	// read data to the device Data register
	*(x_axis) = IORD_ALT_UP_ACCELEROMETER_SPI_DATA(accel_spi->base) & ALT_UP_ACCELEROMETER_SPI_DATA_DATA_MSK;
 4019978:	e0bfff17 	ldw	r2,-4(fp)
 401997c:	10800a17 	ldw	r2,40(r2)
 4019980:	10800044 	addi	r2,r2,1
 4019984:	10800023 	ldbuio	r2,0(r2)
 4019988:	10803fcc 	andi	r2,r2,255
 401998c:	10ffffcc 	andi	r3,r2,65535
 4019990:	e0bffe17 	ldw	r2,-8(fp)
 4019994:	10c00015 	stw	r3,0(r2)

	// set the register address in the Address register
	IOWR_ALT_UP_ACCELEROMETER_SPI_ADDRESS(accel_spi->base, ACCELEROMETER_SPI_X_AXIS_UPPER_BYTE & ALT_UP_ACCELEROMETER_SPI_ADDRESS_ADDR_MSK); 
 4019998:	e0bfff17 	ldw	r2,-4(fp)
 401999c:	10800a17 	ldw	r2,40(r2)
 40199a0:	1007883a 	mov	r3,r2
 40199a4:	00800cc4 	movi	r2,51
 40199a8:	18800025 	stbio	r2,0(r3)

	// read data to the device Data register
	*(x_axis) += (IORD_ALT_UP_ACCELEROMETER_SPI_DATA(accel_spi->base) & ALT_UP_ACCELEROMETER_SPI_DATA_DATA_MSK) << 8;
 40199ac:	e0bfff17 	ldw	r2,-4(fp)
 40199b0:	10800a17 	ldw	r2,40(r2)
 40199b4:	10800044 	addi	r2,r2,1
 40199b8:	10800023 	ldbuio	r2,0(r2)
 40199bc:	10803fcc 	andi	r2,r2,255
 40199c0:	1006923a 	slli	r3,r2,8
 40199c4:	00804034 	movhi	r2,256
 40199c8:	10bfc004 	addi	r2,r2,-256
 40199cc:	1884703a 	and	r2,r3,r2
 40199d0:	e0fffe17 	ldw	r3,-8(fp)
 40199d4:	18c00017 	ldw	r3,0(r3)
 40199d8:	10c5883a 	add	r2,r2,r3
 40199dc:	1007883a 	mov	r3,r2
 40199e0:	e0bffe17 	ldw	r2,-8(fp)
 40199e4:	10c00015 	stw	r3,0(r2)

	if (*(x_axis) & 0x00008000)
 40199e8:	e0bffe17 	ldw	r2,-8(fp)
 40199ec:	10800017 	ldw	r2,0(r2)
 40199f0:	10a0000c 	andi	r2,r2,32768
 40199f4:	10000626 	beq	r2,zero,4019a10 <alt_up_accelerometer_spi_read_x_axis+0xc0>
	{
		*(x_axis) |= 0xFFFF0000;
 40199f8:	e0bffe17 	ldw	r2,-8(fp)
 40199fc:	10800017 	ldw	r2,0(r2)
 4019a00:	10bffff4 	orhi	r2,r2,65535
 4019a04:	1007883a 	mov	r3,r2
 4019a08:	e0bffe17 	ldw	r2,-8(fp)
 4019a0c:	10c00015 	stw	r3,0(r2)
	}

	return 0;
 4019a10:	0005883a 	mov	r2,zero
}
 4019a14:	e037883a 	mov	sp,fp
 4019a18:	df000017 	ldw	fp,0(sp)
 4019a1c:	dec00104 	addi	sp,sp,4
 4019a20:	f800283a 	ret

04019a24 <alt_up_accelerometer_spi_read_y_axis>:
 * @param y_axis -- a pointer to the location where the y axis data should be stored
 *
 * @return 0 for success or -1 for failure
 **/
int alt_up_accelerometer_spi_read_y_axis(alt_up_accelerometer_spi_dev *accel_spi, alt_32 *y_axis)
{
 4019a24:	defffd04 	addi	sp,sp,-12
 4019a28:	df000215 	stw	fp,8(sp)
 4019a2c:	df000204 	addi	fp,sp,8
 4019a30:	e13fff15 	stw	r4,-4(fp)
 4019a34:	e17ffe15 	stw	r5,-8(fp)
	// set the register address in the Address register
	IOWR_ALT_UP_ACCELEROMETER_SPI_ADDRESS(accel_spi->base, ACCELEROMETER_SPI_Y_AXIS_LOWER_BYTE & ALT_UP_ACCELEROMETER_SPI_ADDRESS_ADDR_MSK); 
 4019a38:	e0bfff17 	ldw	r2,-4(fp)
 4019a3c:	10800a17 	ldw	r2,40(r2)
 4019a40:	1007883a 	mov	r3,r2
 4019a44:	00800d04 	movi	r2,52
 4019a48:	18800025 	stbio	r2,0(r3)

	// read data to the device Data register
	*(y_axis) = IORD_ALT_UP_ACCELEROMETER_SPI_DATA(accel_spi->base) & ALT_UP_ACCELEROMETER_SPI_DATA_DATA_MSK;
 4019a4c:	e0bfff17 	ldw	r2,-4(fp)
 4019a50:	10800a17 	ldw	r2,40(r2)
 4019a54:	10800044 	addi	r2,r2,1
 4019a58:	10800023 	ldbuio	r2,0(r2)
 4019a5c:	10803fcc 	andi	r2,r2,255
 4019a60:	10ffffcc 	andi	r3,r2,65535
 4019a64:	e0bffe17 	ldw	r2,-8(fp)
 4019a68:	10c00015 	stw	r3,0(r2)

	// set the register address in the Address register
	IOWR_ALT_UP_ACCELEROMETER_SPI_ADDRESS(accel_spi->base, ACCELEROMETER_SPI_Y_AXIS_UPPER_BYTE & ALT_UP_ACCELEROMETER_SPI_ADDRESS_ADDR_MSK); 
 4019a6c:	e0bfff17 	ldw	r2,-4(fp)
 4019a70:	10800a17 	ldw	r2,40(r2)
 4019a74:	1007883a 	mov	r3,r2
 4019a78:	00800d44 	movi	r2,53
 4019a7c:	18800025 	stbio	r2,0(r3)

	// read data to the device Data register
	*(y_axis) += (IORD_ALT_UP_ACCELEROMETER_SPI_DATA(accel_spi->base) & ALT_UP_ACCELEROMETER_SPI_DATA_DATA_MSK) << 8;
 4019a80:	e0bfff17 	ldw	r2,-4(fp)
 4019a84:	10800a17 	ldw	r2,40(r2)
 4019a88:	10800044 	addi	r2,r2,1
 4019a8c:	10800023 	ldbuio	r2,0(r2)
 4019a90:	10803fcc 	andi	r2,r2,255
 4019a94:	1006923a 	slli	r3,r2,8
 4019a98:	00804034 	movhi	r2,256
 4019a9c:	10bfc004 	addi	r2,r2,-256
 4019aa0:	1884703a 	and	r2,r3,r2
 4019aa4:	e0fffe17 	ldw	r3,-8(fp)
 4019aa8:	18c00017 	ldw	r3,0(r3)
 4019aac:	10c5883a 	add	r2,r2,r3
 4019ab0:	1007883a 	mov	r3,r2
 4019ab4:	e0bffe17 	ldw	r2,-8(fp)
 4019ab8:	10c00015 	stw	r3,0(r2)

	if (*(y_axis) & 0x00008000)
 4019abc:	e0bffe17 	ldw	r2,-8(fp)
 4019ac0:	10800017 	ldw	r2,0(r2)
 4019ac4:	10a0000c 	andi	r2,r2,32768
 4019ac8:	10000626 	beq	r2,zero,4019ae4 <alt_up_accelerometer_spi_read_y_axis+0xc0>
	{
		*(y_axis) |= 0xFFFF0000;
 4019acc:	e0bffe17 	ldw	r2,-8(fp)
 4019ad0:	10800017 	ldw	r2,0(r2)
 4019ad4:	10bffff4 	orhi	r2,r2,65535
 4019ad8:	1007883a 	mov	r3,r2
 4019adc:	e0bffe17 	ldw	r2,-8(fp)
 4019ae0:	10c00015 	stw	r3,0(r2)
	}

	return 0;
 4019ae4:	0005883a 	mov	r2,zero
}
 4019ae8:	e037883a 	mov	sp,fp
 4019aec:	df000017 	ldw	fp,0(sp)
 4019af0:	dec00104 	addi	sp,sp,4
 4019af4:	f800283a 	ret

04019af8 <alt_up_accelerometer_spi_read_z_axis>:
 * @param z_axis -- a pointer to the location where the z axis data should be stored
 *
 * @return 0 for success or -1 for failure
 **/
int alt_up_accelerometer_spi_read_z_axis(alt_up_accelerometer_spi_dev *accel_spi, alt_32 *z_axis)
{
 4019af8:	defffd04 	addi	sp,sp,-12
 4019afc:	df000215 	stw	fp,8(sp)
 4019b00:	df000204 	addi	fp,sp,8
 4019b04:	e13fff15 	stw	r4,-4(fp)
 4019b08:	e17ffe15 	stw	r5,-8(fp)
	// set the register address in the Address register
	IOWR_ALT_UP_ACCELEROMETER_SPI_ADDRESS(accel_spi->base, ACCELEROMETER_SPI_Z_AXIS_LOWER_BYTE & ALT_UP_ACCELEROMETER_SPI_ADDRESS_ADDR_MSK); 
 4019b0c:	e0bfff17 	ldw	r2,-4(fp)
 4019b10:	10800a17 	ldw	r2,40(r2)
 4019b14:	1007883a 	mov	r3,r2
 4019b18:	00800d84 	movi	r2,54
 4019b1c:	18800025 	stbio	r2,0(r3)

	// read data to the device Data register
	*(z_axis) = IORD_ALT_UP_ACCELEROMETER_SPI_DATA(accel_spi->base) & ALT_UP_ACCELEROMETER_SPI_DATA_DATA_MSK;
 4019b20:	e0bfff17 	ldw	r2,-4(fp)
 4019b24:	10800a17 	ldw	r2,40(r2)
 4019b28:	10800044 	addi	r2,r2,1
 4019b2c:	10800023 	ldbuio	r2,0(r2)
 4019b30:	10803fcc 	andi	r2,r2,255
 4019b34:	10ffffcc 	andi	r3,r2,65535
 4019b38:	e0bffe17 	ldw	r2,-8(fp)
 4019b3c:	10c00015 	stw	r3,0(r2)

	// set the register address in the Address register
	IOWR_ALT_UP_ACCELEROMETER_SPI_ADDRESS(accel_spi->base, ACCELEROMETER_SPI_Z_AXIS_UPPER_BYTE & ALT_UP_ACCELEROMETER_SPI_ADDRESS_ADDR_MSK); 
 4019b40:	e0bfff17 	ldw	r2,-4(fp)
 4019b44:	10800a17 	ldw	r2,40(r2)
 4019b48:	1007883a 	mov	r3,r2
 4019b4c:	00800dc4 	movi	r2,55
 4019b50:	18800025 	stbio	r2,0(r3)

	// read data to the device Data register
	*(z_axis) += (IORD_ALT_UP_ACCELEROMETER_SPI_DATA(accel_spi->base) & ALT_UP_ACCELEROMETER_SPI_DATA_DATA_MSK) << 8;
 4019b54:	e0bfff17 	ldw	r2,-4(fp)
 4019b58:	10800a17 	ldw	r2,40(r2)
 4019b5c:	10800044 	addi	r2,r2,1
 4019b60:	10800023 	ldbuio	r2,0(r2)
 4019b64:	10803fcc 	andi	r2,r2,255
 4019b68:	1006923a 	slli	r3,r2,8
 4019b6c:	00804034 	movhi	r2,256
 4019b70:	10bfc004 	addi	r2,r2,-256
 4019b74:	1884703a 	and	r2,r3,r2
 4019b78:	e0fffe17 	ldw	r3,-8(fp)
 4019b7c:	18c00017 	ldw	r3,0(r3)
 4019b80:	10c5883a 	add	r2,r2,r3
 4019b84:	1007883a 	mov	r3,r2
 4019b88:	e0bffe17 	ldw	r2,-8(fp)
 4019b8c:	10c00015 	stw	r3,0(r2)

	if (*(z_axis) & 0x00008000)
 4019b90:	e0bffe17 	ldw	r2,-8(fp)
 4019b94:	10800017 	ldw	r2,0(r2)
 4019b98:	10a0000c 	andi	r2,r2,32768
 4019b9c:	10000626 	beq	r2,zero,4019bb8 <alt_up_accelerometer_spi_read_z_axis+0xc0>
	{
		*(z_axis) |= 0xFFFF0000;
 4019ba0:	e0bffe17 	ldw	r2,-8(fp)
 4019ba4:	10800017 	ldw	r2,0(r2)
 4019ba8:	10bffff4 	orhi	r2,r2,65535
 4019bac:	1007883a 	mov	r3,r2
 4019bb0:	e0bffe17 	ldw	r2,-8(fp)
 4019bb4:	10c00015 	stw	r3,0(r2)
	}

	return 0;
 4019bb8:	0005883a 	mov	r2,zero
}
 4019bbc:	e037883a 	mov	sp,fp
 4019bc0:	df000017 	ldw	fp,0(sp)
 4019bc4:	dec00104 	addi	sp,sp,4
 4019bc8:	f800283a 	ret

04019bcc <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
 4019bcc:	defff504 	addi	sp,sp,-44
 4019bd0:	df000a15 	stw	fp,40(sp)
 4019bd4:	df000a04 	addi	fp,sp,40
 4019bd8:	e13ff915 	stw	r4,-28(fp)
 4019bdc:	e17ff815 	stw	r5,-32(fp)
 4019be0:	e1bff715 	stw	r6,-36(fp)
 4019be4:	e1fff615 	stw	r7,-40(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
 4019be8:	e03fff15 	stw	zero,-4(fp)
  return _alt_tick_rate;
 4019bec:	d0a72f17 	ldw	r2,-25412(gp)
  
  if (alt_ticks_per_second ())
 4019bf0:	10003e26 	beq	r2,zero,4019cec <alt_alarm_start+0x120>
  {
    if (alarm)
 4019bf4:	e0bff917 	ldw	r2,-28(fp)
 4019bf8:	10003a26 	beq	r2,zero,4019ce4 <alt_alarm_start+0x118>
    {
      alarm->callback = callback;
 4019bfc:	e0bff917 	ldw	r2,-28(fp)
 4019c00:	e0fff717 	ldw	r3,-36(fp)
 4019c04:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
 4019c08:	e0bff917 	ldw	r2,-28(fp)
 4019c0c:	e0fff617 	ldw	r3,-40(fp)
 4019c10:	10c00515 	stw	r3,20(r2)
  NIOS2_READ_STATUS (context);
 4019c14:	0005303a 	rdctl	r2,status
 4019c18:	e0bffd15 	stw	r2,-12(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 4019c1c:	e0fffd17 	ldw	r3,-12(fp)
 4019c20:	00bfff84 	movi	r2,-2
 4019c24:	1884703a 	and	r2,r3,r2
 4019c28:	1001703a 	wrctl	status,r2
  return context;
 4019c2c:	e0bffd17 	ldw	r2,-12(fp)
 
      irq_context = alt_irq_disable_all ();
 4019c30:	e0bffe15 	stw	r2,-8(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 4019c34:	d0a73017 	ldw	r2,-25408(gp)
      
      current_nticks = alt_nticks();
 4019c38:	e0bfff15 	stw	r2,-4(fp)
      
      alarm->time = nticks + current_nticks + 1; 
 4019c3c:	e0fff817 	ldw	r3,-32(fp)
 4019c40:	e0bfff17 	ldw	r2,-4(fp)
 4019c44:	1885883a 	add	r2,r3,r2
 4019c48:	10c00044 	addi	r3,r2,1
 4019c4c:	e0bff917 	ldw	r2,-28(fp)
 4019c50:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
 4019c54:	e0bff917 	ldw	r2,-28(fp)
 4019c58:	10c00217 	ldw	r3,8(r2)
 4019c5c:	e0bfff17 	ldw	r2,-4(fp)
 4019c60:	1880042e 	bgeu	r3,r2,4019c74 <alt_alarm_start+0xa8>
      {
        alarm->rollover = 1;
 4019c64:	e0bff917 	ldw	r2,-28(fp)
 4019c68:	00c00044 	movi	r3,1
 4019c6c:	10c00405 	stb	r3,16(r2)
 4019c70:	00000206 	br	4019c7c <alt_alarm_start+0xb0>
      }
      else
      {
        alarm->rollover = 0;
 4019c74:	e0bff917 	ldw	r2,-28(fp)
 4019c78:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
 4019c7c:	e0bff917 	ldw	r2,-28(fp)
 4019c80:	d0e00d04 	addi	r3,gp,-32716
 4019c84:	e0fffb15 	stw	r3,-20(fp)
 4019c88:	e0bffa15 	stw	r2,-24(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 4019c8c:	e0bffa17 	ldw	r2,-24(fp)
 4019c90:	e0fffb17 	ldw	r3,-20(fp)
 4019c94:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 4019c98:	e0bffb17 	ldw	r2,-20(fp)
 4019c9c:	10c00017 	ldw	r3,0(r2)
 4019ca0:	e0bffa17 	ldw	r2,-24(fp)
 4019ca4:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 4019ca8:	e0bffb17 	ldw	r2,-20(fp)
 4019cac:	10800017 	ldw	r2,0(r2)
 4019cb0:	e0fffa17 	ldw	r3,-24(fp)
 4019cb4:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 4019cb8:	e0bffb17 	ldw	r2,-20(fp)
 4019cbc:	e0fffa17 	ldw	r3,-24(fp)
 4019cc0:	10c00015 	stw	r3,0(r2)
}
 4019cc4:	0001883a 	nop
 4019cc8:	e0bffe17 	ldw	r2,-8(fp)
 4019ccc:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context);
 4019cd0:	e0bffc17 	ldw	r2,-16(fp)
 4019cd4:	1001703a 	wrctl	status,r2
}
 4019cd8:	0001883a 	nop
      alt_irq_enable_all (irq_context);

      return 0;
 4019cdc:	0005883a 	mov	r2,zero
 4019ce0:	00000306 	br	4019cf0 <alt_alarm_start+0x124>
    }
    else
    {
      return -EINVAL;
 4019ce4:	00bffa84 	movi	r2,-22
 4019ce8:	00000106 	br	4019cf0 <alt_alarm_start+0x124>
    }
  }
  else
  {
    return -ENOTSUP;
 4019cec:	00bfde84 	movi	r2,-134
  }
}
 4019cf0:	e037883a 	mov	sp,fp
 4019cf4:	df000017 	ldw	fp,0(sp)
 4019cf8:	dec00104 	addi	sp,sp,4
 4019cfc:	f800283a 	ret

04019d00 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
 4019d00:	deffff04 	addi	sp,sp,-4
 4019d04:	df000015 	stw	fp,0(sp)
 4019d08:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 4019d0c:	0001883a 	nop
 4019d10:	e037883a 	mov	sp,fp
 4019d14:	df000017 	ldw	fp,0(sp)
 4019d18:	dec00104 	addi	sp,sp,4
 4019d1c:	f800283a 	ret

04019d20 <alt_get_errno>:
{
 4019d20:	defffe04 	addi	sp,sp,-8
 4019d24:	dfc00115 	stw	ra,4(sp)
 4019d28:	df000015 	stw	fp,0(sp)
 4019d2c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 4019d30:	d0a00a17 	ldw	r2,-32728(gp)
 4019d34:	10000326 	beq	r2,zero,4019d44 <alt_get_errno+0x24>
 4019d38:	d0a00a17 	ldw	r2,-32728(gp)
 4019d3c:	103ee83a 	callr	r2
 4019d40:	00000106 	br	4019d48 <alt_get_errno+0x28>
 4019d44:	d0a72904 	addi	r2,gp,-25436
}
 4019d48:	e037883a 	mov	sp,fp
 4019d4c:	dfc00117 	ldw	ra,4(sp)
 4019d50:	df000017 	ldw	fp,0(sp)
 4019d54:	dec00204 	addi	sp,sp,8
 4019d58:	f800283a 	ret

04019d5c <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
 4019d5c:	defffa04 	addi	sp,sp,-24
 4019d60:	dfc00515 	stw	ra,20(sp)
 4019d64:	df000415 	stw	fp,16(sp)
 4019d68:	df000404 	addi	fp,sp,16
 4019d6c:	e13ffd15 	stw	r4,-12(fp)
 4019d70:	e17ffc15 	stw	r5,-16(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
 4019d74:	e0bffd17 	ldw	r2,-12(fp)
 4019d78:	10000326 	beq	r2,zero,4019d88 <alt_dev_llist_insert+0x2c>
 4019d7c:	e0bffd17 	ldw	r2,-12(fp)
 4019d80:	10800217 	ldw	r2,8(r2)
 4019d84:	1000061e 	bne	r2,zero,4019da0 <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
 4019d88:	4019d200 	call	4019d20 <alt_get_errno>
 4019d8c:	1007883a 	mov	r3,r2
 4019d90:	00800584 	movi	r2,22
 4019d94:	18800015 	stw	r2,0(r3)
    return -EINVAL;
 4019d98:	00bffa84 	movi	r2,-22
 4019d9c:	00001406 	br	4019df0 <alt_dev_llist_insert+0x94>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
 4019da0:	e0bffd17 	ldw	r2,-12(fp)
 4019da4:	e0fffc17 	ldw	r3,-16(fp)
 4019da8:	e0ffff15 	stw	r3,-4(fp)
 4019dac:	e0bffe15 	stw	r2,-8(fp)
  entry->previous = list;
 4019db0:	e0bffe17 	ldw	r2,-8(fp)
 4019db4:	e0ffff17 	ldw	r3,-4(fp)
 4019db8:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 4019dbc:	e0bfff17 	ldw	r2,-4(fp)
 4019dc0:	10c00017 	ldw	r3,0(r2)
 4019dc4:	e0bffe17 	ldw	r2,-8(fp)
 4019dc8:	10c00015 	stw	r3,0(r2)
  list->next->previous = entry;
 4019dcc:	e0bfff17 	ldw	r2,-4(fp)
 4019dd0:	10800017 	ldw	r2,0(r2)
 4019dd4:	e0fffe17 	ldw	r3,-8(fp)
 4019dd8:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 4019ddc:	e0bfff17 	ldw	r2,-4(fp)
 4019de0:	e0fffe17 	ldw	r3,-8(fp)
 4019de4:	10c00015 	stw	r3,0(r2)
}
 4019de8:	0001883a 	nop

  return 0;  
 4019dec:	0005883a 	mov	r2,zero
}
 4019df0:	e037883a 	mov	sp,fp
 4019df4:	dfc00117 	ldw	ra,4(sp)
 4019df8:	df000017 	ldw	fp,0(sp)
 4019dfc:	dec00204 	addi	sp,sp,8
 4019e00:	f800283a 	ret

04019e04 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
 4019e04:	defffd04 	addi	sp,sp,-12
 4019e08:	dfc00215 	stw	ra,8(sp)
 4019e0c:	df000115 	stw	fp,4(sp)
 4019e10:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 4019e14:	008100b4 	movhi	r2,1026
 4019e18:	10aaf104 	addi	r2,r2,-21564
 4019e1c:	e0bfff15 	stw	r2,-4(fp)
 4019e20:	00000606 	br	4019e3c <_do_ctors+0x38>
        (*ctor) (); 
 4019e24:	e0bfff17 	ldw	r2,-4(fp)
 4019e28:	10800017 	ldw	r2,0(r2)
 4019e2c:	103ee83a 	callr	r2
  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 4019e30:	e0bfff17 	ldw	r2,-4(fp)
 4019e34:	10bfff04 	addi	r2,r2,-4
 4019e38:	e0bfff15 	stw	r2,-4(fp)
 4019e3c:	e0ffff17 	ldw	r3,-4(fp)
 4019e40:	008100b4 	movhi	r2,1026
 4019e44:	10aaf204 	addi	r2,r2,-21560
 4019e48:	18bff62e 	bgeu	r3,r2,4019e24 <_do_ctors+0x20>
}
 4019e4c:	0001883a 	nop
 4019e50:	0001883a 	nop
 4019e54:	e037883a 	mov	sp,fp
 4019e58:	dfc00117 	ldw	ra,4(sp)
 4019e5c:	df000017 	ldw	fp,0(sp)
 4019e60:	dec00204 	addi	sp,sp,8
 4019e64:	f800283a 	ret

04019e68 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
 4019e68:	defffd04 	addi	sp,sp,-12
 4019e6c:	dfc00215 	stw	ra,8(sp)
 4019e70:	df000115 	stw	fp,4(sp)
 4019e74:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 4019e78:	008100b4 	movhi	r2,1026
 4019e7c:	10aaf104 	addi	r2,r2,-21564
 4019e80:	e0bfff15 	stw	r2,-4(fp)
 4019e84:	00000606 	br	4019ea0 <_do_dtors+0x38>
        (*dtor) (); 
 4019e88:	e0bfff17 	ldw	r2,-4(fp)
 4019e8c:	10800017 	ldw	r2,0(r2)
 4019e90:	103ee83a 	callr	r2
  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 4019e94:	e0bfff17 	ldw	r2,-4(fp)
 4019e98:	10bfff04 	addi	r2,r2,-4
 4019e9c:	e0bfff15 	stw	r2,-4(fp)
 4019ea0:	e0ffff17 	ldw	r3,-4(fp)
 4019ea4:	008100b4 	movhi	r2,1026
 4019ea8:	10aaf204 	addi	r2,r2,-21560
 4019eac:	18bff62e 	bgeu	r3,r2,4019e88 <_do_dtors+0x20>
}
 4019eb0:	0001883a 	nop
 4019eb4:	0001883a 	nop
 4019eb8:	e037883a 	mov	sp,fp
 4019ebc:	dfc00117 	ldw	ra,4(sp)
 4019ec0:	df000017 	ldw	fp,0(sp)
 4019ec4:	dec00204 	addi	sp,sp,8
 4019ec8:	f800283a 	ret

04019ecc <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
 4019ecc:	defffa04 	addi	sp,sp,-24
 4019ed0:	dfc00515 	stw	ra,20(sp)
 4019ed4:	df000415 	stw	fp,16(sp)
 4019ed8:	df000404 	addi	fp,sp,16
 4019edc:	e13ffd15 	stw	r4,-12(fp)
 4019ee0:	e17ffc15 	stw	r5,-16(fp)
  alt_dev* next = (alt_dev*) llist->next;
 4019ee4:	e0bffc17 	ldw	r2,-16(fp)
 4019ee8:	10800017 	ldw	r2,0(r2)
 4019eec:	e0bfff15 	stw	r2,-4(fp)
  alt_32 len;

  len  = strlen(name) + 1;
 4019ef0:	e13ffd17 	ldw	r4,-12(fp)
 4019ef4:	4007b340 	call	4007b34 <strlen>
 4019ef8:	10800044 	addi	r2,r2,1
 4019efc:	e0bffe15 	stw	r2,-8(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 4019f00:	00000d06 	br	4019f38 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
 4019f04:	e0bfff17 	ldw	r2,-4(fp)
 4019f08:	10800217 	ldw	r2,8(r2)
 4019f0c:	e0fffe17 	ldw	r3,-8(fp)
 4019f10:	180d883a 	mov	r6,r3
 4019f14:	e17ffd17 	ldw	r5,-12(fp)
 4019f18:	1009883a 	mov	r4,r2
 4019f1c:	401a7f00 	call	401a7f0 <memcmp>
 4019f20:	1000021e 	bne	r2,zero,4019f2c <alt_find_dev+0x60>
    {
      /* match found */

      return next;
 4019f24:	e0bfff17 	ldw	r2,-4(fp)
 4019f28:	00000706 	br	4019f48 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
 4019f2c:	e0bfff17 	ldw	r2,-4(fp)
 4019f30:	10800017 	ldw	r2,0(r2)
 4019f34:	e0bfff15 	stw	r2,-4(fp)
  while (next != (alt_dev*) llist)
 4019f38:	e0ffff17 	ldw	r3,-4(fp)
 4019f3c:	e0bffc17 	ldw	r2,-16(fp)
 4019f40:	18bff01e 	bne	r3,r2,4019f04 <alt_find_dev+0x38>
  }
  
  /* No match found */
  
  return NULL;
 4019f44:	0005883a 	mov	r2,zero
}
 4019f48:	e037883a 	mov	sp,fp
 4019f4c:	dfc00117 	ldw	ra,4(sp)
 4019f50:	df000017 	ldw	fp,0(sp)
 4019f54:	dec00204 	addi	sp,sp,8
 4019f58:	f800283a 	ret

04019f5c <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
 4019f5c:	deffff04 	addi	sp,sp,-4
 4019f60:	df000015 	stw	fp,0(sp)
 4019f64:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
#endif
}
 4019f68:	0001883a 	nop
 4019f6c:	e037883a 	mov	sp,fp
 4019f70:	df000017 	ldw	fp,0(sp)
 4019f74:	dec00104 	addi	sp,sp,4
 4019f78:	f800283a 	ret

04019f7c <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
 4019f7c:	defffe04 	addi	sp,sp,-8
 4019f80:	df000115 	stw	fp,4(sp)
 4019f84:	df000104 	addi	fp,sp,4
 4019f88:	e13fff15 	stw	r4,-4(fp)
 4019f8c:	e0bfff17 	ldw	r2,-4(fp)
 4019f90:	10bffe84 	addi	r2,r2,-6
 4019f94:	10c00428 	cmpgeui	r3,r2,16
 4019f98:	1800191e 	bne	r3,zero,401a000 <alt_exception_cause_generated_bad_addr+0x84>
 4019f9c:	100690ba 	slli	r3,r2,2
 4019fa0:	008100b4 	movhi	r2,1026
 4019fa4:	1885883a 	add	r2,r3,r2
 4019fa8:	10a7ec17 	ldw	r2,-24656(r2)
 4019fac:	1000683a 	jmp	r2
 4019fb0:	04019ff0 	cmpltui	r16,zero,1663
 4019fb4:	04019ff0 	cmpltui	r16,zero,1663
 4019fb8:	0401a000 	call	401a00 <__alt_mem_dram-0x3bfe600>
 4019fbc:	0401a000 	call	401a00 <__alt_mem_dram-0x3bfe600>
 4019fc0:	0401a000 	call	401a00 <__alt_mem_dram-0x3bfe600>
 4019fc4:	04019ff0 	cmpltui	r16,zero,1663
 4019fc8:	04019ff8 	rdprs	r16,zero,1663
 4019fcc:	0401a000 	call	401a00 <__alt_mem_dram-0x3bfe600>
 4019fd0:	04019ff0 	cmpltui	r16,zero,1663
 4019fd4:	04019ff0 	cmpltui	r16,zero,1663
 4019fd8:	0401a000 	call	401a00 <__alt_mem_dram-0x3bfe600>
 4019fdc:	04019ff0 	cmpltui	r16,zero,1663
 4019fe0:	04019ff8 	rdprs	r16,zero,1663
 4019fe4:	0401a000 	call	401a00 <__alt_mem_dram-0x3bfe600>
 4019fe8:	0401a000 	call	401a00 <__alt_mem_dram-0x3bfe600>
 4019fec:	04019ff0 	cmpltui	r16,zero,1663
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
 4019ff0:	00800044 	movi	r2,1
 4019ff4:	00000306 	br	401a004 <alt_exception_cause_generated_bad_addr+0x88>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
 4019ff8:	0005883a 	mov	r2,zero
 4019ffc:	00000106 	br	401a004 <alt_exception_cause_generated_bad_addr+0x88>

  default:
    return 0;
 401a000:	0005883a 	mov	r2,zero
  }
}
 401a004:	e037883a 	mov	sp,fp
 401a008:	df000017 	ldw	fp,0(sp)
 401a00c:	dec00104 	addi	sp,sp,4
 401a010:	f800283a 	ret

0401a014 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
 401a014:	defff904 	addi	sp,sp,-28
 401a018:	dfc00615 	stw	ra,24(sp)
 401a01c:	df000515 	stw	fp,20(sp)
 401a020:	df000504 	addi	fp,sp,20
 401a024:	e13ffe15 	stw	r4,-8(fp)
 401a028:	e17ffd15 	stw	r5,-12(fp)
 401a02c:	e1bffc15 	stw	r6,-16(fp)
 401a030:	e1fffb15 	stw	r7,-20(fp)
  int old;

  old = open (name, flags, mode);
 401a034:	e1bffb17 	ldw	r6,-20(fp)
 401a038:	e17ffc17 	ldw	r5,-16(fp)
 401a03c:	e13ffd17 	ldw	r4,-12(fp)
 401a040:	401a27c0 	call	401a27c <open>
 401a044:	e0bfff15 	stw	r2,-4(fp)

  if (old >= 0)
 401a048:	e0bfff17 	ldw	r2,-4(fp)
 401a04c:	10002016 	blt	r2,zero,401a0d0 <alt_open_fd+0xbc>
  {
    fd->dev      = alt_fd_list[old].dev;
 401a050:	e0ffff17 	ldw	r3,-4(fp)
 401a054:	1805883a 	mov	r2,r3
 401a058:	1085883a 	add	r2,r2,r2
 401a05c:	10c5883a 	add	r2,r2,r3
 401a060:	100490ba 	slli	r2,r2,2
 401a064:	00c100b4 	movhi	r3,1026
 401a068:	10c7883a 	add	r3,r2,r3
 401a06c:	18ef3f17 	ldw	r3,-17156(r3)
 401a070:	e0bffe17 	ldw	r2,-8(fp)
 401a074:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
 401a078:	e0ffff17 	ldw	r3,-4(fp)
 401a07c:	1805883a 	mov	r2,r3
 401a080:	1085883a 	add	r2,r2,r2
 401a084:	10c5883a 	add	r2,r2,r3
 401a088:	100490ba 	slli	r2,r2,2
 401a08c:	00c100b4 	movhi	r3,1026
 401a090:	10c7883a 	add	r3,r2,r3
 401a094:	18ef4017 	ldw	r3,-17152(r3)
 401a098:	e0bffe17 	ldw	r2,-8(fp)
 401a09c:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
 401a0a0:	e0ffff17 	ldw	r3,-4(fp)
 401a0a4:	1805883a 	mov	r2,r3
 401a0a8:	1085883a 	add	r2,r2,r2
 401a0ac:	10c5883a 	add	r2,r2,r3
 401a0b0:	100490ba 	slli	r2,r2,2
 401a0b4:	00c100b4 	movhi	r3,1026
 401a0b8:	10c7883a 	add	r3,r2,r3
 401a0bc:	18ef4117 	ldw	r3,-17148(r3)
 401a0c0:	e0bffe17 	ldw	r2,-8(fp)
 401a0c4:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
 401a0c8:	e13fff17 	ldw	r4,-4(fp)
 401a0cc:	40189440 	call	4018944 <alt_release_fd>
  }
} 
 401a0d0:	0001883a 	nop
 401a0d4:	e037883a 	mov	sp,fp
 401a0d8:	dfc00117 	ldw	ra,4(sp)
 401a0dc:	df000017 	ldw	fp,0(sp)
 401a0e0:	dec00204 	addi	sp,sp,8
 401a0e4:	f800283a 	ret

0401a0e8 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
 401a0e8:	defffb04 	addi	sp,sp,-20
 401a0ec:	dfc00415 	stw	ra,16(sp)
 401a0f0:	df000315 	stw	fp,12(sp)
 401a0f4:	df000304 	addi	fp,sp,12
 401a0f8:	e13fff15 	stw	r4,-4(fp)
 401a0fc:	e17ffe15 	stw	r5,-8(fp)
 401a100:	e1bffd15 	stw	r6,-12(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
 401a104:	01c07fc4 	movi	r7,511
 401a108:	01800044 	movi	r6,1
 401a10c:	e17fff17 	ldw	r5,-4(fp)
 401a110:	010100b4 	movhi	r4,1026
 401a114:	212f4204 	addi	r4,r4,-17144
 401a118:	401a0140 	call	401a014 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
 401a11c:	01c07fc4 	movi	r7,511
 401a120:	000d883a 	mov	r6,zero
 401a124:	e17ffe17 	ldw	r5,-8(fp)
 401a128:	010100b4 	movhi	r4,1026
 401a12c:	212f3f04 	addi	r4,r4,-17156
 401a130:	401a0140 	call	401a014 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
 401a134:	01c07fc4 	movi	r7,511
 401a138:	01800044 	movi	r6,1
 401a13c:	e17ffd17 	ldw	r5,-12(fp)
 401a140:	010100b4 	movhi	r4,1026
 401a144:	212f4504 	addi	r4,r4,-17132
 401a148:	401a0140 	call	401a014 <alt_open_fd>
}  
 401a14c:	0001883a 	nop
 401a150:	e037883a 	mov	sp,fp
 401a154:	dfc00117 	ldw	ra,4(sp)
 401a158:	df000017 	ldw	fp,0(sp)
 401a15c:	dec00204 	addi	sp,sp,8
 401a160:	f800283a 	ret

0401a164 <alt_get_errno>:
{
 401a164:	defffe04 	addi	sp,sp,-8
 401a168:	dfc00115 	stw	ra,4(sp)
 401a16c:	df000015 	stw	fp,0(sp)
 401a170:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 401a174:	d0a00a17 	ldw	r2,-32728(gp)
 401a178:	10000326 	beq	r2,zero,401a188 <alt_get_errno+0x24>
 401a17c:	d0a00a17 	ldw	r2,-32728(gp)
 401a180:	103ee83a 	callr	r2
 401a184:	00000106 	br	401a18c <alt_get_errno+0x28>
 401a188:	d0a72904 	addi	r2,gp,-25436
}
 401a18c:	e037883a 	mov	sp,fp
 401a190:	dfc00117 	ldw	ra,4(sp)
 401a194:	df000017 	ldw	fp,0(sp)
 401a198:	dec00204 	addi	sp,sp,8
 401a19c:	f800283a 	ret

0401a1a0 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
 401a1a0:	defffd04 	addi	sp,sp,-12
 401a1a4:	df000215 	stw	fp,8(sp)
 401a1a8:	df000204 	addi	fp,sp,8
 401a1ac:	e13ffe15 	stw	r4,-8(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
 401a1b0:	e0bffe17 	ldw	r2,-8(fp)
 401a1b4:	10800217 	ldw	r2,8(r2)
 401a1b8:	10d00034 	orhi	r3,r2,16384
 401a1bc:	e0bffe17 	ldw	r2,-8(fp)
 401a1c0:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 401a1c4:	e03fff15 	stw	zero,-4(fp)
 401a1c8:	00002306 	br	401a258 <alt_file_locked+0xb8>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 401a1cc:	e0ffff17 	ldw	r3,-4(fp)
 401a1d0:	1805883a 	mov	r2,r3
 401a1d4:	1085883a 	add	r2,r2,r2
 401a1d8:	10c5883a 	add	r2,r2,r3
 401a1dc:	100490ba 	slli	r2,r2,2
 401a1e0:	00c100b4 	movhi	r3,1026
 401a1e4:	10c7883a 	add	r3,r2,r3
 401a1e8:	18ef3f17 	ldw	r3,-17156(r3)
 401a1ec:	e0bffe17 	ldw	r2,-8(fp)
 401a1f0:	10800017 	ldw	r2,0(r2)
 401a1f4:	1880151e 	bne	r3,r2,401a24c <alt_file_locked+0xac>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 401a1f8:	e0ffff17 	ldw	r3,-4(fp)
 401a1fc:	1805883a 	mov	r2,r3
 401a200:	1085883a 	add	r2,r2,r2
 401a204:	10c5883a 	add	r2,r2,r3
 401a208:	100490ba 	slli	r2,r2,2
 401a20c:	00c100b4 	movhi	r3,1026
 401a210:	10c7883a 	add	r3,r2,r3
 401a214:	18af4117 	ldw	r2,-17148(r3)
    if ((alt_fd_list[i].dev == fd->dev) &&
 401a218:	10000c0e 	bge	r2,zero,401a24c <alt_file_locked+0xac>
        (&alt_fd_list[i] != fd))
 401a21c:	e0ffff17 	ldw	r3,-4(fp)
 401a220:	1805883a 	mov	r2,r3
 401a224:	1085883a 	add	r2,r2,r2
 401a228:	10c5883a 	add	r2,r2,r3
 401a22c:	100490ba 	slli	r2,r2,2
 401a230:	00c100b4 	movhi	r3,1026
 401a234:	18ef3f04 	addi	r3,r3,-17156
 401a238:	10c5883a 	add	r2,r2,r3
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 401a23c:	e0fffe17 	ldw	r3,-8(fp)
 401a240:	18800226 	beq	r3,r2,401a24c <alt_file_locked+0xac>
    {
      return -EACCES;
 401a244:	00bffcc4 	movi	r2,-13
 401a248:	00000806 	br	401a26c <alt_file_locked+0xcc>
  for (i = 0; i <= alt_max_fd; i++)
 401a24c:	e0bfff17 	ldw	r2,-4(fp)
 401a250:	10800044 	addi	r2,r2,1
 401a254:	e0bfff15 	stw	r2,-4(fp)
 401a258:	d0a00917 	ldw	r2,-32732(gp)
 401a25c:	1007883a 	mov	r3,r2
 401a260:	e0bfff17 	ldw	r2,-4(fp)
 401a264:	18bfd92e 	bgeu	r3,r2,401a1cc <alt_file_locked+0x2c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
 401a268:	0005883a 	mov	r2,zero
}
 401a26c:	e037883a 	mov	sp,fp
 401a270:	df000017 	ldw	fp,0(sp)
 401a274:	dec00104 	addi	sp,sp,4
 401a278:	f800283a 	ret

0401a27c <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
 401a27c:	defff604 	addi	sp,sp,-40
 401a280:	dfc00915 	stw	ra,36(sp)
 401a284:	df000815 	stw	fp,32(sp)
 401a288:	df000804 	addi	fp,sp,32
 401a28c:	e13ffa15 	stw	r4,-24(fp)
 401a290:	e17ff915 	stw	r5,-28(fp)
 401a294:	e1bff815 	stw	r6,-32(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
 401a298:	00bfffc4 	movi	r2,-1
 401a29c:	e0bffe15 	stw	r2,-8(fp)
  int status = -ENODEV;
 401a2a0:	00bffb44 	movi	r2,-19
 401a2a4:	e0bffd15 	stw	r2,-12(fp)
  int isafs = 0;
 401a2a8:	e03ffc15 	stw	zero,-16(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
 401a2ac:	d1600704 	addi	r5,gp,-32740
 401a2b0:	e13ffa17 	ldw	r4,-24(fp)
 401a2b4:	4019ecc0 	call	4019ecc <alt_find_dev>
 401a2b8:	e0bfff15 	stw	r2,-4(fp)
 401a2bc:	e0bfff17 	ldw	r2,-4(fp)
 401a2c0:	1000051e 	bne	r2,zero,401a2d8 <open+0x5c>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
 401a2c4:	e13ffa17 	ldw	r4,-24(fp)
 401a2c8:	401a5ac0 	call	401a5ac <alt_find_file>
 401a2cc:	e0bfff15 	stw	r2,-4(fp)
    isafs = 1;
 401a2d0:	00800044 	movi	r2,1
 401a2d4:	e0bffc15 	stw	r2,-16(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
 401a2d8:	e0bfff17 	ldw	r2,-4(fp)
 401a2dc:	10002c26 	beq	r2,zero,401a390 <open+0x114>
  {
    if ((index = alt_get_fd (dev)) < 0)
 401a2e0:	e13fff17 	ldw	r4,-4(fp)
 401a2e4:	401a6b40 	call	401a6b4 <alt_get_fd>
 401a2e8:	e0bffe15 	stw	r2,-8(fp)
 401a2ec:	e0bffe17 	ldw	r2,-8(fp)
 401a2f0:	1000030e 	bge	r2,zero,401a300 <open+0x84>
    {
      status = index;
 401a2f4:	e0bffe17 	ldw	r2,-8(fp)
 401a2f8:	e0bffd15 	stw	r2,-12(fp)
 401a2fc:	00002606 	br	401a398 <open+0x11c>
    }
    else
    {
      fd = &alt_fd_list[index];
 401a300:	e0fffe17 	ldw	r3,-8(fp)
 401a304:	1805883a 	mov	r2,r3
 401a308:	1085883a 	add	r2,r2,r2
 401a30c:	10c5883a 	add	r2,r2,r3
 401a310:	100490ba 	slli	r2,r2,2
 401a314:	00c100b4 	movhi	r3,1026
 401a318:	18ef3f04 	addi	r3,r3,-17156
 401a31c:	10c5883a 	add	r2,r2,r3
 401a320:	e0bffb15 	stw	r2,-20(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
 401a324:	e0fff917 	ldw	r3,-28(fp)
 401a328:	00900034 	movhi	r2,16384
 401a32c:	10bfffc4 	addi	r2,r2,-1
 401a330:	1886703a 	and	r3,r3,r2
 401a334:	e0bffb17 	ldw	r2,-20(fp)
 401a338:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
 401a33c:	e0bffc17 	ldw	r2,-16(fp)
 401a340:	1000051e 	bne	r2,zero,401a358 <open+0xdc>
 401a344:	e13ffb17 	ldw	r4,-20(fp)
 401a348:	401a1a00 	call	401a1a0 <alt_file_locked>
 401a34c:	e0bffd15 	stw	r2,-12(fp)
 401a350:	e0bffd17 	ldw	r2,-12(fp)
 401a354:	10001016 	blt	r2,zero,401a398 <open+0x11c>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
 401a358:	e0bfff17 	ldw	r2,-4(fp)
 401a35c:	10800317 	ldw	r2,12(r2)
 401a360:	10000826 	beq	r2,zero,401a384 <open+0x108>
 401a364:	e0bfff17 	ldw	r2,-4(fp)
 401a368:	10800317 	ldw	r2,12(r2)
 401a36c:	e1fff817 	ldw	r7,-32(fp)
 401a370:	e1bff917 	ldw	r6,-28(fp)
 401a374:	e17ffa17 	ldw	r5,-24(fp)
 401a378:	e13ffb17 	ldw	r4,-20(fp)
 401a37c:	103ee83a 	callr	r2
 401a380:	00000106 	br	401a388 <open+0x10c>
 401a384:	0005883a 	mov	r2,zero
 401a388:	e0bffd15 	stw	r2,-12(fp)
 401a38c:	00000206 	br	401a398 <open+0x11c>
      }
    }
  }
  else
  {
    status = -ENODEV;
 401a390:	00bffb44 	movi	r2,-19
 401a394:	e0bffd15 	stw	r2,-12(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
 401a398:	e0bffd17 	ldw	r2,-12(fp)
 401a39c:	1000090e 	bge	r2,zero,401a3c4 <open+0x148>
  {
    alt_release_fd (index);  
 401a3a0:	e13ffe17 	ldw	r4,-8(fp)
 401a3a4:	40189440 	call	4018944 <alt_release_fd>
    ALT_ERRNO = -status;
 401a3a8:	401a1640 	call	401a164 <alt_get_errno>
 401a3ac:	1007883a 	mov	r3,r2
 401a3b0:	e0bffd17 	ldw	r2,-12(fp)
 401a3b4:	0085c83a 	sub	r2,zero,r2
 401a3b8:	18800015 	stw	r2,0(r3)
    return -1;
 401a3bc:	00bfffc4 	movi	r2,-1
 401a3c0:	00000106 	br	401a3c8 <open+0x14c>
  }
  
  /* return the reference upon success */

  return index;
 401a3c4:	e0bffe17 	ldw	r2,-8(fp)
}
 401a3c8:	e037883a 	mov	sp,fp
 401a3cc:	dfc00117 	ldw	ra,4(sp)
 401a3d0:	df000017 	ldw	fp,0(sp)
 401a3d4:	dec00204 	addi	sp,sp,8
 401a3d8:	f800283a 	ret

0401a3dc <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
 401a3dc:	defffa04 	addi	sp,sp,-24
 401a3e0:	df000515 	stw	fp,20(sp)
 401a3e4:	df000504 	addi	fp,sp,20
 401a3e8:	e13ffb15 	stw	r4,-20(fp)
  NIOS2_READ_STATUS (context);
 401a3ec:	0005303a 	rdctl	r2,status
 401a3f0:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 401a3f4:	e0fffc17 	ldw	r3,-16(fp)
 401a3f8:	00bfff84 	movi	r2,-2
 401a3fc:	1884703a 	and	r2,r3,r2
 401a400:	1001703a 	wrctl	status,r2
  return context;
 401a404:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
 401a408:	e0bfff15 	stw	r2,-4(fp)
  alt_llist_remove (&alarm->llist);
 401a40c:	e0bffb17 	ldw	r2,-20(fp)
 401a410:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 401a414:	e0bffd17 	ldw	r2,-12(fp)
 401a418:	10800017 	ldw	r2,0(r2)
 401a41c:	e0fffd17 	ldw	r3,-12(fp)
 401a420:	18c00117 	ldw	r3,4(r3)
 401a424:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
 401a428:	e0bffd17 	ldw	r2,-12(fp)
 401a42c:	10800117 	ldw	r2,4(r2)
 401a430:	e0fffd17 	ldw	r3,-12(fp)
 401a434:	18c00017 	ldw	r3,0(r3)
 401a438:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 401a43c:	e0bffd17 	ldw	r2,-12(fp)
 401a440:	e0fffd17 	ldw	r3,-12(fp)
 401a444:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
 401a448:	e0bffd17 	ldw	r2,-12(fp)
 401a44c:	e0fffd17 	ldw	r3,-12(fp)
 401a450:	10c00015 	stw	r3,0(r2)
} 
 401a454:	0001883a 	nop
 401a458:	e0bfff17 	ldw	r2,-4(fp)
 401a45c:	e0bffe15 	stw	r2,-8(fp)
  NIOS2_WRITE_STATUS (context);
 401a460:	e0bffe17 	ldw	r2,-8(fp)
 401a464:	1001703a 	wrctl	status,r2
}
 401a468:	0001883a 	nop
  alt_irq_enable_all (irq_context);
}
 401a46c:	0001883a 	nop
 401a470:	e037883a 	mov	sp,fp
 401a474:	df000017 	ldw	fp,0(sp)
 401a478:	dec00104 	addi	sp,sp,4
 401a47c:	f800283a 	ret

0401a480 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 401a480:	defffb04 	addi	sp,sp,-20
 401a484:	dfc00415 	stw	ra,16(sp)
 401a488:	df000315 	stw	fp,12(sp)
 401a48c:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 401a490:	d0a00d17 	ldw	r2,-32716(gp)
 401a494:	e0bfff15 	stw	r2,-4(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 401a498:	d0a73017 	ldw	r2,-25408(gp)
 401a49c:	10800044 	addi	r2,r2,1
 401a4a0:	d0a73015 	stw	r2,-25408(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 401a4a4:	00002e06 	br	401a560 <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
 401a4a8:	e0bfff17 	ldw	r2,-4(fp)
 401a4ac:	10800017 	ldw	r2,0(r2)
 401a4b0:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 401a4b4:	e0bfff17 	ldw	r2,-4(fp)
 401a4b8:	10800403 	ldbu	r2,16(r2)
 401a4bc:	10803fcc 	andi	r2,r2,255
 401a4c0:	10000426 	beq	r2,zero,401a4d4 <alt_tick+0x54>
 401a4c4:	d0a73017 	ldw	r2,-25408(gp)
 401a4c8:	1000021e 	bne	r2,zero,401a4d4 <alt_tick+0x54>
    {
      alarm->rollover = 0;
 401a4cc:	e0bfff17 	ldw	r2,-4(fp)
 401a4d0:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
 401a4d4:	e0bfff17 	ldw	r2,-4(fp)
 401a4d8:	10800217 	ldw	r2,8(r2)
 401a4dc:	d0e73017 	ldw	r3,-25408(gp)
 401a4e0:	18801d36 	bltu	r3,r2,401a558 <alt_tick+0xd8>
 401a4e4:	e0bfff17 	ldw	r2,-4(fp)
 401a4e8:	10800403 	ldbu	r2,16(r2)
 401a4ec:	10803fcc 	andi	r2,r2,255
 401a4f0:	1000191e 	bne	r2,zero,401a558 <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
 401a4f4:	e0bfff17 	ldw	r2,-4(fp)
 401a4f8:	10800317 	ldw	r2,12(r2)
 401a4fc:	e0ffff17 	ldw	r3,-4(fp)
 401a500:	18c00517 	ldw	r3,20(r3)
 401a504:	1809883a 	mov	r4,r3
 401a508:	103ee83a 	callr	r2
 401a50c:	e0bffd15 	stw	r2,-12(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 401a510:	e0bffd17 	ldw	r2,-12(fp)
 401a514:	1000031e 	bne	r2,zero,401a524 <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
 401a518:	e13fff17 	ldw	r4,-4(fp)
 401a51c:	401a3dc0 	call	401a3dc <alt_alarm_stop>
 401a520:	00000d06 	br	401a558 <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
 401a524:	e0bfff17 	ldw	r2,-4(fp)
 401a528:	10c00217 	ldw	r3,8(r2)
 401a52c:	e0bffd17 	ldw	r2,-12(fp)
 401a530:	1887883a 	add	r3,r3,r2
 401a534:	e0bfff17 	ldw	r2,-4(fp)
 401a538:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 401a53c:	e0bfff17 	ldw	r2,-4(fp)
 401a540:	10c00217 	ldw	r3,8(r2)
 401a544:	d0a73017 	ldw	r2,-25408(gp)
 401a548:	1880032e 	bgeu	r3,r2,401a558 <alt_tick+0xd8>
        {
          alarm->rollover = 1;
 401a54c:	e0bfff17 	ldw	r2,-4(fp)
 401a550:	00c00044 	movi	r3,1
 401a554:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
 401a558:	e0bffe17 	ldw	r2,-8(fp)
 401a55c:	e0bfff15 	stw	r2,-4(fp)
  while (alarm != (alt_alarm*) &alt_alarm_list)
 401a560:	e0ffff17 	ldw	r3,-4(fp)
 401a564:	d0a00d04 	addi	r2,gp,-32716
 401a568:	18bfcf1e 	bne	r3,r2,401a4a8 <alt_tick+0x28>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
 401a56c:	0001883a 	nop
}
 401a570:	0001883a 	nop
 401a574:	e037883a 	mov	sp,fp
 401a578:	dfc00117 	ldw	ra,4(sp)
 401a57c:	df000017 	ldw	fp,0(sp)
 401a580:	dec00204 	addi	sp,sp,8
 401a584:	f800283a 	ret

0401a588 <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
 401a588:	deffff04 	addi	sp,sp,-4
 401a58c:	df000015 	stw	fp,0(sp)
 401a590:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
 401a594:	000170fa 	wrctl	ienable,zero
}
 401a598:	0001883a 	nop
 401a59c:	e037883a 	mov	sp,fp
 401a5a0:	df000017 	ldw	fp,0(sp)
 401a5a4:	dec00104 	addi	sp,sp,4
 401a5a8:	f800283a 	ret

0401a5ac <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
 401a5ac:	defffb04 	addi	sp,sp,-20
 401a5b0:	dfc00415 	stw	ra,16(sp)
 401a5b4:	df000315 	stw	fp,12(sp)
 401a5b8:	df000304 	addi	fp,sp,12
 401a5bc:	e13ffd15 	stw	r4,-12(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
 401a5c0:	d0a00517 	ldw	r2,-32748(gp)
 401a5c4:	e0bfff15 	stw	r2,-4(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 401a5c8:	00003106 	br	401a690 <alt_find_file+0xe4>
  {
    len = strlen(next->name);
 401a5cc:	e0bfff17 	ldw	r2,-4(fp)
 401a5d0:	10800217 	ldw	r2,8(r2)
 401a5d4:	1009883a 	mov	r4,r2
 401a5d8:	4007b340 	call	4007b34 <strlen>
 401a5dc:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
 401a5e0:	e0bfff17 	ldw	r2,-4(fp)
 401a5e4:	10c00217 	ldw	r3,8(r2)
 401a5e8:	e0bffe17 	ldw	r2,-8(fp)
 401a5ec:	10bfffc4 	addi	r2,r2,-1
 401a5f0:	1885883a 	add	r2,r3,r2
 401a5f4:	10800003 	ldbu	r2,0(r2)
 401a5f8:	10803fcc 	andi	r2,r2,255
 401a5fc:	1080201c 	xori	r2,r2,128
 401a600:	10bfe004 	addi	r2,r2,-128
 401a604:	10800bd8 	cmpnei	r2,r2,47
 401a608:	1000031e 	bne	r2,zero,401a618 <alt_find_file+0x6c>
    {
      len -= 1;
 401a60c:	e0bffe17 	ldw	r2,-8(fp)
 401a610:	10bfffc4 	addi	r2,r2,-1
 401a614:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 401a618:	e0bffe17 	ldw	r2,-8(fp)
 401a61c:	e0fffd17 	ldw	r3,-12(fp)
 401a620:	1885883a 	add	r2,r3,r2
 401a624:	10800003 	ldbu	r2,0(r2)
 401a628:	10803fcc 	andi	r2,r2,255
 401a62c:	1080201c 	xori	r2,r2,128
 401a630:	10bfe004 	addi	r2,r2,-128
 401a634:	10800be0 	cmpeqi	r2,r2,47
 401a638:	1000081e 	bne	r2,zero,401a65c <alt_find_file+0xb0>
 401a63c:	e0bffe17 	ldw	r2,-8(fp)
 401a640:	e0fffd17 	ldw	r3,-12(fp)
 401a644:	1885883a 	add	r2,r3,r2
 401a648:	10800003 	ldbu	r2,0(r2)
 401a64c:	10803fcc 	andi	r2,r2,255
 401a650:	1080201c 	xori	r2,r2,128
 401a654:	10bfe004 	addi	r2,r2,-128
 401a658:	10000a1e 	bne	r2,zero,401a684 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
 401a65c:	e0bfff17 	ldw	r2,-4(fp)
 401a660:	10800217 	ldw	r2,8(r2)
 401a664:	e0fffe17 	ldw	r3,-8(fp)
 401a668:	180d883a 	mov	r6,r3
 401a66c:	e17ffd17 	ldw	r5,-12(fp)
 401a670:	1009883a 	mov	r4,r2
 401a674:	401a7f00 	call	401a7f0 <memcmp>
    if (((name[len] == '/') || (name[len] == '\0')) && 
 401a678:	1000021e 	bne	r2,zero,401a684 <alt_find_file+0xd8>
    {
      /* match found */

      return next;
 401a67c:	e0bfff17 	ldw	r2,-4(fp)
 401a680:	00000706 	br	401a6a0 <alt_find_file+0xf4>
    }
    next = (alt_dev*) next->llist.next;
 401a684:	e0bfff17 	ldw	r2,-4(fp)
 401a688:	10800017 	ldw	r2,0(r2)
 401a68c:	e0bfff15 	stw	r2,-4(fp)
  while (next != (alt_dev*) &alt_fs_list)
 401a690:	e0ffff17 	ldw	r3,-4(fp)
 401a694:	d0a00504 	addi	r2,gp,-32748
 401a698:	18bfcc1e 	bne	r3,r2,401a5cc <alt_find_file+0x20>
  }
  
  /* No match found */
  
  return NULL;     
 401a69c:	0005883a 	mov	r2,zero
}
 401a6a0:	e037883a 	mov	sp,fp
 401a6a4:	dfc00117 	ldw	ra,4(sp)
 401a6a8:	df000017 	ldw	fp,0(sp)
 401a6ac:	dec00204 	addi	sp,sp,8
 401a6b0:	f800283a 	ret

0401a6b4 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
 401a6b4:	defffc04 	addi	sp,sp,-16
 401a6b8:	df000315 	stw	fp,12(sp)
 401a6bc:	df000304 	addi	fp,sp,12
 401a6c0:	e13ffd15 	stw	r4,-12(fp)
  alt_32 i;
  int rc = -EMFILE;
 401a6c4:	00bffa04 	movi	r2,-24
 401a6c8:	e0bffe15 	stw	r2,-8(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 401a6cc:	e03fff15 	stw	zero,-4(fp)
 401a6d0:	00001d06 	br	401a748 <alt_get_fd+0x94>
  {
    if (!alt_fd_list[i].dev)
 401a6d4:	e0ffff17 	ldw	r3,-4(fp)
 401a6d8:	1805883a 	mov	r2,r3
 401a6dc:	1085883a 	add	r2,r2,r2
 401a6e0:	10c5883a 	add	r2,r2,r3
 401a6e4:	100490ba 	slli	r2,r2,2
 401a6e8:	00c100b4 	movhi	r3,1026
 401a6ec:	10c7883a 	add	r3,r2,r3
 401a6f0:	18af3f17 	ldw	r2,-17156(r3)
 401a6f4:	1000111e 	bne	r2,zero,401a73c <alt_get_fd+0x88>
    {
      alt_fd_list[i].dev = dev;
 401a6f8:	e0ffff17 	ldw	r3,-4(fp)
 401a6fc:	1805883a 	mov	r2,r3
 401a700:	1085883a 	add	r2,r2,r2
 401a704:	10c5883a 	add	r2,r2,r3
 401a708:	100490ba 	slli	r2,r2,2
 401a70c:	e13ffd17 	ldw	r4,-12(fp)
 401a710:	00c100b4 	movhi	r3,1026
 401a714:	10c7883a 	add	r3,r2,r3
 401a718:	192f3f15 	stw	r4,-17156(r3)
      if (i > alt_max_fd)
 401a71c:	d0e00917 	ldw	r3,-32732(gp)
 401a720:	e0bfff17 	ldw	r2,-4(fp)
 401a724:	1880020e 	bge	r3,r2,401a730 <alt_get_fd+0x7c>
      {
        alt_max_fd = i;
 401a728:	e0bfff17 	ldw	r2,-4(fp)
 401a72c:	d0a00915 	stw	r2,-32732(gp)
      }
      rc = i;
 401a730:	e0bfff17 	ldw	r2,-4(fp)
 401a734:	e0bffe15 	stw	r2,-8(fp)
      goto alt_get_fd_exit;
 401a738:	00000706 	br	401a758 <alt_get_fd+0xa4>
  for (i = 0; i < ALT_MAX_FD; i++)
 401a73c:	e0bfff17 	ldw	r2,-4(fp)
 401a740:	10800044 	addi	r2,r2,1
 401a744:	e0bfff15 	stw	r2,-4(fp)
 401a748:	e0bfff17 	ldw	r2,-4(fp)
 401a74c:	10800810 	cmplti	r2,r2,32
 401a750:	103fe01e 	bne	r2,zero,401a6d4 <alt_get_fd+0x20>
    }
  }

 alt_get_fd_exit:
 401a754:	0001883a 	nop
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
 401a758:	e0bffe17 	ldw	r2,-8(fp)
}
 401a75c:	e037883a 	mov	sp,fp
 401a760:	df000017 	ldw	fp,0(sp)
 401a764:	dec00104 	addi	sp,sp,4
 401a768:	f800283a 	ret

0401a76c <atexit>:
 * Register a function to be performed at exit.
 */

int
atexit (void (*fn) (void))
{
 401a76c:	defffd04 	addi	sp,sp,-12
 401a770:	dfc00215 	stw	ra,8(sp)
 401a774:	df000115 	stw	fp,4(sp)
 401a778:	df000104 	addi	fp,sp,4
 401a77c:	e13fff15 	stw	r4,-4(fp)
  return __register_exitproc (__et_atexit, fn, NULL, NULL);
 401a780:	000f883a 	mov	r7,zero
 401a784:	000d883a 	mov	r6,zero
 401a788:	e17fff17 	ldw	r5,-4(fp)
 401a78c:	0009883a 	mov	r4,zero
 401a790:	401a9240 	call	401a924 <__register_exitproc>
}
 401a794:	e037883a 	mov	sp,fp
 401a798:	dfc00117 	ldw	ra,4(sp)
 401a79c:	df000017 	ldw	fp,0(sp)
 401a7a0:	dec00204 	addi	sp,sp,8
 401a7a4:	f800283a 	ret

0401a7a8 <exit>:
 * Exit, flushing stdio buffers if necessary.
 */

void
exit (int code)
{
 401a7a8:	defffd04 	addi	sp,sp,-12
 401a7ac:	dfc00215 	stw	ra,8(sp)
 401a7b0:	df000115 	stw	fp,4(sp)
 401a7b4:	df000104 	addi	fp,sp,4
 401a7b8:	e13fff15 	stw	r4,-4(fp)
#ifdef _LITE_EXIT
  /* Refer to comments in __atexit.c for more details of lite exit.  */
  void __call_exitprocs (int, void *) __attribute__((weak));
  if (__call_exitprocs)
#endif
    __call_exitprocs (code, NULL);
 401a7bc:	000b883a 	mov	r5,zero
 401a7c0:	e13fff17 	ldw	r4,-4(fp)
 401a7c4:	401aa3c0 	call	401aa3c <__call_exitprocs>
#ifndef WANT_SMALL_STDIO        /* IntelSpecific */
  if (_GLOBAL_REENT->__cleanup)
 401a7c8:	d0a00217 	ldw	r2,-32760(gp)
 401a7cc:	10800f17 	ldw	r2,60(r2)
 401a7d0:	10000526 	beq	r2,zero,401a7e8 <exit+0x40>
    (*_GLOBAL_REENT->__cleanup) (_GLOBAL_REENT);
 401a7d4:	d0a00217 	ldw	r2,-32760(gp)
 401a7d8:	10800f17 	ldw	r2,60(r2)
 401a7dc:	d0e00217 	ldw	r3,-32760(gp)
 401a7e0:	1809883a 	mov	r4,r3
 401a7e4:	103ee83a 	callr	r2
#endif                          /* IntelSpecific */
  _exit (code);
 401a7e8:	e13fff17 	ldw	r4,-4(fp)
 401a7ec:	4017ef80 	call	4017ef8 <_exit>

0401a7f0 <memcmp>:

int
memcmp (const void *m1,
	const void *m2,
	size_t n)
{
 401a7f0:	defff804 	addi	sp,sp,-32
 401a7f4:	df000715 	stw	fp,28(sp)
 401a7f8:	df000704 	addi	fp,sp,28
 401a7fc:	e13ffb15 	stw	r4,-20(fp)
 401a800:	e17ffa15 	stw	r5,-24(fp)
 401a804:	e1bff915 	stw	r6,-28(fp)
      s1++;
      s2++;
    }
  return 0;
#else  
  unsigned char *s1 = (unsigned char *) m1;
 401a808:	e0bffb17 	ldw	r2,-20(fp)
 401a80c:	e0bfff15 	stw	r2,-4(fp)
  unsigned char *s2 = (unsigned char *) m2;
 401a810:	e0bffa17 	ldw	r2,-24(fp)
 401a814:	e0bffe15 	stw	r2,-8(fp)
  unsigned long *a2;

  /* If the size is too small, or either pointer is unaligned,
     then we punt to the byte compare loop.  Hopefully this will
     not turn up in inner loops.  */
  if (!TOO_SMALL(n) && !UNALIGNED(s1,s2))
 401a818:	e0bff917 	ldw	r2,-28(fp)
 401a81c:	10800130 	cmpltui	r2,r2,4
 401a820:	1000371e 	bne	r2,zero,401a900 <memcmp+0x110>
 401a824:	e0ffff17 	ldw	r3,-4(fp)
 401a828:	e0bffe17 	ldw	r2,-8(fp)
 401a82c:	1884b03a 	or	r2,r3,r2
 401a830:	108000cc 	andi	r2,r2,3
 401a834:	1000321e 	bne	r2,zero,401a900 <memcmp+0x110>
    {
      /* Otherwise, load and compare the blocks of memory one 
         word at a time.  */
      a1 = (unsigned long*) s1;
 401a838:	e0bfff17 	ldw	r2,-4(fp)
 401a83c:	e0bffd15 	stw	r2,-12(fp)
      a2 = (unsigned long*) s2;
 401a840:	e0bffe17 	ldw	r2,-8(fp)
 401a844:	e0bffc15 	stw	r2,-16(fp)
      while (n >= LBLOCKSIZE)
 401a848:	00000e06 	br	401a884 <memcmp+0x94>
        {
          if (*a1 != *a2) 
 401a84c:	e0bffd17 	ldw	r2,-12(fp)
 401a850:	10c00017 	ldw	r3,0(r2)
 401a854:	e0bffc17 	ldw	r2,-16(fp)
 401a858:	10800017 	ldw	r2,0(r2)
 401a85c:	18800d1e 	bne	r3,r2,401a894 <memcmp+0xa4>
   	    break;
          a1++;
 401a860:	e0bffd17 	ldw	r2,-12(fp)
 401a864:	10800104 	addi	r2,r2,4
 401a868:	e0bffd15 	stw	r2,-12(fp)
          a2++;
 401a86c:	e0bffc17 	ldw	r2,-16(fp)
 401a870:	10800104 	addi	r2,r2,4
 401a874:	e0bffc15 	stw	r2,-16(fp)
          n -= LBLOCKSIZE;
 401a878:	e0bff917 	ldw	r2,-28(fp)
 401a87c:	10bfff04 	addi	r2,r2,-4
 401a880:	e0bff915 	stw	r2,-28(fp)
      while (n >= LBLOCKSIZE)
 401a884:	e0bff917 	ldw	r2,-28(fp)
 401a888:	10800128 	cmpgeui	r2,r2,4
 401a88c:	103fef1e 	bne	r2,zero,401a84c <memcmp+0x5c>
 401a890:	00000106 	br	401a898 <memcmp+0xa8>
   	    break;
 401a894:	0001883a 	nop
        }

      /* check m mod LBLOCKSIZE remaining characters */

      s1 = (unsigned char*)a1;
 401a898:	e0bffd17 	ldw	r2,-12(fp)
 401a89c:	e0bfff15 	stw	r2,-4(fp)
      s2 = (unsigned char*)a2;
 401a8a0:	e0bffc17 	ldw	r2,-16(fp)
 401a8a4:	e0bffe15 	stw	r2,-8(fp)
    }

  while (n--)
 401a8a8:	00001506 	br	401a900 <memcmp+0x110>
    {
      if (*s1 != *s2)
 401a8ac:	e0bfff17 	ldw	r2,-4(fp)
 401a8b0:	10c00003 	ldbu	r3,0(r2)
 401a8b4:	e0bffe17 	ldw	r2,-8(fp)
 401a8b8:	10800003 	ldbu	r2,0(r2)
 401a8bc:	18c03fcc 	andi	r3,r3,255
 401a8c0:	10803fcc 	andi	r2,r2,255
 401a8c4:	18800826 	beq	r3,r2,401a8e8 <memcmp+0xf8>
	return *s1 - *s2;
 401a8c8:	e0bfff17 	ldw	r2,-4(fp)
 401a8cc:	10800003 	ldbu	r2,0(r2)
 401a8d0:	10c03fcc 	andi	r3,r2,255
 401a8d4:	e0bffe17 	ldw	r2,-8(fp)
 401a8d8:	10800003 	ldbu	r2,0(r2)
 401a8dc:	10803fcc 	andi	r2,r2,255
 401a8e0:	1885c83a 	sub	r2,r3,r2
 401a8e4:	00000b06 	br	401a914 <memcmp+0x124>
      s1++;
 401a8e8:	e0bfff17 	ldw	r2,-4(fp)
 401a8ec:	10800044 	addi	r2,r2,1
 401a8f0:	e0bfff15 	stw	r2,-4(fp)
      s2++;
 401a8f4:	e0bffe17 	ldw	r2,-8(fp)
 401a8f8:	10800044 	addi	r2,r2,1
 401a8fc:	e0bffe15 	stw	r2,-8(fp)
  while (n--)
 401a900:	e0bff917 	ldw	r2,-28(fp)
 401a904:	10ffffc4 	addi	r3,r2,-1
 401a908:	e0fff915 	stw	r3,-28(fp)
 401a90c:	103fe71e 	bne	r2,zero,401a8ac <memcmp+0xbc>
    }

  return 0;
 401a910:	0005883a 	mov	r2,zero
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 401a914:	e037883a 	mov	sp,fp
 401a918:	df000017 	ldw	fp,0(sp)
 401a91c:	dec00104 	addi	sp,sp,4
 401a920:	f800283a 	ret

0401a924 <__register_exitproc>:
int
__register_exitproc (int type,
	void (*fn) (void),
	void *arg,
	void *d)
{
 401a924:	defff904 	addi	sp,sp,-28
 401a928:	df000615 	stw	fp,24(sp)
 401a92c:	dc000515 	stw	r16,20(sp)
 401a930:	df000604 	addi	fp,sp,24
 401a934:	e13ffd15 	stw	r4,-12(fp)
 401a938:	e17ffc15 	stw	r5,-16(fp)
 401a93c:	e1bffb15 	stw	r6,-20(fp)
 401a940:	e1fffa15 	stw	r7,-24(fp)

#ifndef __SINGLE_THREAD__
  __lock_acquire_recursive(__atexit_recursive_mutex);
#endif

  p = _GLOBAL_ATEXIT;
 401a944:	d0a00217 	ldw	r2,-32760(gp)
 401a948:	14005217 	ldw	r16,328(r2)
  if (p == NULL)
 401a94c:	8000041e 	bne	r16,zero,401a960 <__register_exitproc+0x3c>
    {
      _GLOBAL_ATEXIT = p = _GLOBAL_ATEXIT0;
 401a950:	d0a00217 	ldw	r2,-32760(gp)
 401a954:	14005304 	addi	r16,r2,332
 401a958:	d0a00217 	ldw	r2,-32760(gp)
 401a95c:	14005215 	stw	r16,328(r2)
      extern struct _on_exit_args * const __on_exit_args _ATTRIBUTE ((weak));
      if (&__on_exit_args != NULL)
	p->_on_exit_args_ptr = __on_exit_args;
#endif	/* def _REENT_SMALL */
    }
  if (p->_ind >= _ATEXIT_SIZE)
 401a960:	80800117 	ldw	r2,4(r16)
 401a964:	10800810 	cmplti	r2,r2,32
 401a968:	1000021e 	bne	r2,zero,401a974 <__register_exitproc+0x50>
    {
#if !defined (_ATEXIT_DYNAMIC_ALLOC) || !defined (MALLOC_PROVIDED)
#ifndef __SINGLE_THREAD__
      __lock_release_recursive(__atexit_recursive_mutex);
#endif
      return -1;
 401a96c:	00bfffc4 	movi	r2,-1
 401a970:	00002d06 	br	401aa28 <__register_exitproc+0x104>
      p->_on_exit_args_ptr = NULL;
#endif
#endif
    }

  if (type != __et_atexit)
 401a974:	e0bffd17 	ldw	r2,-12(fp)
 401a978:	10002226 	beq	r2,zero,401aa04 <__register_exitproc+0xe0>
	  args->_is_cxa = 0;
	  p->_on_exit_args_ptr = args;
#endif
	}
#else
      args = &p->_on_exit_args;
 401a97c:	80802204 	addi	r2,r16,136
 401a980:	e0bffe15 	stw	r2,-8(fp)
#endif
      args->_fnargs[p->_ind] = arg;
 401a984:	80800117 	ldw	r2,4(r16)
 401a988:	e0fffe17 	ldw	r3,-8(fp)
 401a98c:	100490ba 	slli	r2,r2,2
 401a990:	1885883a 	add	r2,r3,r2
 401a994:	e0fffb17 	ldw	r3,-20(fp)
 401a998:	10c00015 	stw	r3,0(r2)
      args->_fntypes |= (1 << p->_ind);
 401a99c:	e0bffe17 	ldw	r2,-8(fp)
 401a9a0:	10804017 	ldw	r2,256(r2)
 401a9a4:	80c00117 	ldw	r3,4(r16)
 401a9a8:	01000044 	movi	r4,1
 401a9ac:	20c6983a 	sll	r3,r4,r3
 401a9b0:	10c6b03a 	or	r3,r2,r3
 401a9b4:	e0bffe17 	ldw	r2,-8(fp)
 401a9b8:	10c04015 	stw	r3,256(r2)
      args->_dso_handle[p->_ind] = d;
 401a9bc:	80800117 	ldw	r2,4(r16)
 401a9c0:	e0fffe17 	ldw	r3,-8(fp)
 401a9c4:	10800804 	addi	r2,r2,32
 401a9c8:	100490ba 	slli	r2,r2,2
 401a9cc:	1885883a 	add	r2,r3,r2
 401a9d0:	e0fffa17 	ldw	r3,-24(fp)
 401a9d4:	10c00015 	stw	r3,0(r2)
      if (type == __et_cxa)
 401a9d8:	e0bffd17 	ldw	r2,-12(fp)
 401a9dc:	10800098 	cmpnei	r2,r2,2
 401a9e0:	1000081e 	bne	r2,zero,401aa04 <__register_exitproc+0xe0>
	args->_is_cxa |= (1 << p->_ind);
 401a9e4:	e0bffe17 	ldw	r2,-8(fp)
 401a9e8:	10804117 	ldw	r2,260(r2)
 401a9ec:	80c00117 	ldw	r3,4(r16)
 401a9f0:	01000044 	movi	r4,1
 401a9f4:	20c6983a 	sll	r3,r4,r3
 401a9f8:	10c6b03a 	or	r3,r2,r3
 401a9fc:	e0bffe17 	ldw	r2,-8(fp)
 401aa00:	10c04115 	stw	r3,260(r2)
    }
  p->_fns[p->_ind++] = fn;
 401aa04:	80800117 	ldw	r2,4(r16)
 401aa08:	10c00044 	addi	r3,r2,1
 401aa0c:	80c00115 	stw	r3,4(r16)
 401aa10:	10800084 	addi	r2,r2,2
 401aa14:	100490ba 	slli	r2,r2,2
 401aa18:	8085883a 	add	r2,r16,r2
 401aa1c:	e0fffc17 	ldw	r3,-16(fp)
 401aa20:	10c00015 	stw	r3,0(r2)
#ifndef __SINGLE_THREAD__
  __lock_release_recursive(__atexit_recursive_mutex);
#endif
  return 0;
 401aa24:	0005883a 	mov	r2,zero
}
 401aa28:	e6ffff04 	addi	sp,fp,-4
 401aa2c:	df000117 	ldw	fp,4(sp)
 401aa30:	dc000017 	ldw	r16,0(sp)
 401aa34:	dec00204 	addi	sp,sp,8
 401aa38:	f800283a 	ret

0401aa3c <__call_exitprocs>:
 * otherwise only the handlers from that DSO are called.
 */

void 
__call_exitprocs (int code, void *d)
{
 401aa3c:	defff504 	addi	sp,sp,-44
 401aa40:	dfc00a15 	stw	ra,40(sp)
 401aa44:	df000915 	stw	fp,36(sp)
 401aa48:	dc800815 	stw	r18,32(sp)
 401aa4c:	dc400715 	stw	r17,28(sp)
 401aa50:	dc000615 	stw	r16,24(sp)
 401aa54:	df000904 	addi	fp,sp,36
 401aa58:	e13ff815 	stw	r4,-32(fp)
 401aa5c:	e17ff715 	stw	r5,-36(fp)
  __lock_acquire_recursive(__atexit_recursive_mutex);
#endif

 restart:

  p = _GLOBAL_ATEXIT;
 401aa60:	d0a00217 	ldw	r2,-32760(gp)
 401aa64:	14005217 	ldw	r16,328(r2)
  lastp = &_GLOBAL_ATEXIT;
 401aa68:	d0a00217 	ldw	r2,-32760(gp)
 401aa6c:	10805204 	addi	r2,r2,328
 401aa70:	e0bffc15 	stw	r2,-16(fp)
  while (p)
 401aa74:	80004b26 	beq	r16,zero,401aba4 <__call_exitprocs+0x168>
    {
#ifdef _REENT_SMALL
      args = p->_on_exit_args_ptr;
#else
      args = &p->_on_exit_args;
 401aa78:	84802204 	addi	r18,r16,136
#endif
      for (n = p->_ind - 1; n >= 0; n--)
 401aa7c:	80800117 	ldw	r2,4(r16)
 401aa80:	147fffc4 	addi	r17,r2,-1
 401aa84:	00004506 	br	401ab9c <__call_exitprocs+0x160>
	{
	  int ind;

	  i = 1 << n;
 401aa88:	00800044 	movi	r2,1
 401aa8c:	1444983a 	sll	r2,r2,r17
 401aa90:	e0bffb15 	stw	r2,-20(fp)

	  /* Skip functions not from this dso.  */
	  if (d && (!args || args->_dso_handle[n] != d))
 401aa94:	e0bff717 	ldw	r2,-36(fp)
 401aa98:	10000726 	beq	r2,zero,401aab8 <__call_exitprocs+0x7c>
 401aa9c:	90003b26 	beq	r18,zero,401ab8c <__call_exitprocs+0x150>
 401aaa0:	88800804 	addi	r2,r17,32
 401aaa4:	100490ba 	slli	r2,r2,2
 401aaa8:	9085883a 	add	r2,r18,r2
 401aaac:	10800017 	ldw	r2,0(r2)
 401aab0:	e0fff717 	ldw	r3,-36(fp)
 401aab4:	1880351e 	bne	r3,r2,401ab8c <__call_exitprocs+0x150>
	    continue;

	  /* Remove the function now to protect against the
	     function calling exit recursively.  */
	  fn = p->_fns[n];
 401aab8:	88800084 	addi	r2,r17,2
 401aabc:	100490ba 	slli	r2,r2,2
 401aac0:	8085883a 	add	r2,r16,r2
 401aac4:	10800017 	ldw	r2,0(r2)
 401aac8:	e0bffa15 	stw	r2,-24(fp)
	  if (n == p->_ind - 1)
 401aacc:	80800117 	ldw	r2,4(r16)
 401aad0:	10bfffc4 	addi	r2,r2,-1
 401aad4:	8880041e 	bne	r17,r2,401aae8 <__call_exitprocs+0xac>
	    p->_ind--;
 401aad8:	80800117 	ldw	r2,4(r16)
 401aadc:	10bfffc4 	addi	r2,r2,-1
 401aae0:	80800115 	stw	r2,4(r16)
 401aae4:	00000406 	br	401aaf8 <__call_exitprocs+0xbc>
	  else
	    p->_fns[n] = NULL;
 401aae8:	88800084 	addi	r2,r17,2
 401aaec:	100490ba 	slli	r2,r2,2
 401aaf0:	8085883a 	add	r2,r16,r2
 401aaf4:	10000015 	stw	zero,0(r2)

	  /* Skip functions that have already been called.  */
	  if (!fn)
 401aaf8:	e0bffa17 	ldw	r2,-24(fp)
 401aafc:	10002526 	beq	r2,zero,401ab94 <__call_exitprocs+0x158>
	    continue;

	  ind = p->_ind;
 401ab00:	80800117 	ldw	r2,4(r16)
 401ab04:	e0bff915 	stw	r2,-28(fp)

	  /* Call the function.  */
	  if (!args || (args->_fntypes & i) == 0)
 401ab08:	90000426 	beq	r18,zero,401ab1c <__call_exitprocs+0xe0>
 401ab0c:	90c04017 	ldw	r3,256(r18)
 401ab10:	e0bffb17 	ldw	r2,-20(fp)
 401ab14:	1884703a 	and	r2,r3,r2
 401ab18:	1000031e 	bne	r2,zero,401ab28 <__call_exitprocs+0xec>
	    fn ();
 401ab1c:	e0bffa17 	ldw	r2,-24(fp)
 401ab20:	103ee83a 	callr	r2
 401ab24:	00001206 	br	401ab70 <__call_exitprocs+0x134>
	  else if ((args->_is_cxa & i) == 0)
 401ab28:	90c04117 	ldw	r3,260(r18)
 401ab2c:	e0bffb17 	ldw	r2,-20(fp)
 401ab30:	1884703a 	and	r2,r3,r2
 401ab34:	1000081e 	bne	r2,zero,401ab58 <__call_exitprocs+0x11c>
	    (*((void (*)(int, void *)) fn))(code, args->_fnargs[n]);
 401ab38:	880490ba 	slli	r2,r17,2
 401ab3c:	9085883a 	add	r2,r18,r2
 401ab40:	10c00017 	ldw	r3,0(r2)
 401ab44:	e0bffa17 	ldw	r2,-24(fp)
 401ab48:	180b883a 	mov	r5,r3
 401ab4c:	e13ff817 	ldw	r4,-32(fp)
 401ab50:	103ee83a 	callr	r2
 401ab54:	00000606 	br	401ab70 <__call_exitprocs+0x134>
	  else
	    (*((void (*)(void *)) fn))(args->_fnargs[n]);
 401ab58:	880490ba 	slli	r2,r17,2
 401ab5c:	9085883a 	add	r2,r18,r2
 401ab60:	10c00017 	ldw	r3,0(r2)
 401ab64:	e0bffa17 	ldw	r2,-24(fp)
 401ab68:	1809883a 	mov	r4,r3
 401ab6c:	103ee83a 	callr	r2

	  /* The function we called call atexit and registered another
	     function (or functions).  Call these new functions before
	     continuing with the already registered functions.  */
	  if (ind != p->_ind || *lastp != p)
 401ab70:	80800117 	ldw	r2,4(r16)
 401ab74:	e0fff917 	ldw	r3,-28(fp)
 401ab78:	18bfb91e 	bne	r3,r2,401aa60 <__call_exitprocs+0x24>
 401ab7c:	e0bffc17 	ldw	r2,-16(fp)
 401ab80:	10800017 	ldw	r2,0(r2)
 401ab84:	80800426 	beq	r16,r2,401ab98 <__call_exitprocs+0x15c>
	    goto restart;
 401ab88:	003fb506 	br	401aa60 <__call_exitprocs+0x24>
	    continue;
 401ab8c:	0001883a 	nop
 401ab90:	00000106 	br	401ab98 <__call_exitprocs+0x15c>
	    continue;
 401ab94:	0001883a 	nop
      for (n = p->_ind - 1; n >= 0; n--)
 401ab98:	8c7fffc4 	addi	r17,r17,-1
 401ab9c:	883fba0e 	bge	r17,zero,401aa88 <__call_exitprocs+0x4c>
	}

#if !defined (_ATEXIT_DYNAMIC_ALLOC) || !defined (MALLOC_PROVIDED)
      break;
 401aba0:	0001883a 	nop
    }
#ifndef __SINGLE_THREAD__
  __lock_release_recursive(__atexit_recursive_mutex);
#endif

}
 401aba4:	0001883a 	nop
 401aba8:	e6fffd04 	addi	sp,fp,-12
 401abac:	dfc00417 	ldw	ra,16(sp)
 401abb0:	df000317 	ldw	fp,12(sp)
 401abb4:	dc800217 	ldw	r18,8(sp)
 401abb8:	dc400117 	ldw	r17,4(sp)
 401abbc:	dc000017 	ldw	r16,0(sp)
 401abc0:	dec00504 	addi	sp,sp,20
 401abc4:	f800283a 	ret
